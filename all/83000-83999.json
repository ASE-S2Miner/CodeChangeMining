[{"original_method":"AbstractPlanNode handleAggregationOperators(AbstractPlanNode root) {\n        AggregatePlanNode aggNode = null;\n\n        /* Check if any aggregate expressions are present */\n        boolean containsAggregateExpression = m_parsedSelect.hasAggregateExpression();\n\n        if (m_partitioning.requiresTwoFragments()) {\n            AbstractPlanNode candidate = root.getChild(0).getChild(0);\n            candidate.clearParents();\n            root.getChild(0).clearChildren();\n            root.getChild(0).addAndLinkChild(indexAccessForGroupByExprs(candidate));\n        } else {\n            root = indexAccessForGroupByExprs(root);\n        }\n        /*\n         * \"Select A from T group by A\" is grouped but has no aggregate operator\n         * expressions. Catch that case by checking the grouped flag\n         */\n        if (containsAggregateExpression || m_parsedSelect.isGrouped()) {\n            AggregatePlanNode topAggNode;\n            // A hash is required to build up per-group aggregates in parallel vs.\n            // when there is only one aggregation over the entire table OR when the\n            // per-group aggregates are being built serially from the ordered output\n            // of an index scan.\n            // Currently, an index scan only claims to have a sort direction when its output\n            // matches the order demanded by the ORDER BY clause.\n            // The only way these ordered indexed columns could survive the aggregation process\n            // (unaggregated) is if they are also GROUP BY columns. So an index with a valid\n            // sort direction indicates that all of the ORDER BY columns are grouped, but how\n            // do we know that ALL of the GROUPED columns are ordered, so we can ditch the hash?\n            // TODO: There appears to be some such test missing here.\n\n            // The way that an index scan under-claims the sorted-ness of its output can lead to cases\n            // where a hash is used needlessly -- it's possible that there is no ORDER BY or that\n            // the indexed columns come out sorted in some wrong direction WRT the order by.\n            // In that case, we could miss the possibility that the index produces sufficient sorted-ness\n            // not to interleave groups, and so we would needlessly use a hash.\n            // This is the less ambitious aspect of issue ENG-4096. The more ambitious aspect\n            // is that the ability to by-pass use of the hash could actually motivate selection of\n            // a compatible index scan, even when one would not be motivated by a WHERE or ORDER BY clause.\n            if (m_parsedSelect.isGrouped() &&\n                (root.getPlanNodeType() != PlanNodeType.INDEXSCAN ||\n                 ((IndexScanPlanNode) root).getSortDirection() == SortDirectionType.INVALID )) {\n                aggNode = new HashAggregatePlanNode();\n                topAggNode = new HashAggregatePlanNode();\n            } else {\n                aggNode = new AggregatePlanNode();\n                topAggNode = new AggregatePlanNode();\n            }\n\n            int outputColumnIndex = 0;\n            NodeSchema agg_schema = new NodeSchema();\n            NodeSchema top_agg_schema = new NodeSchema();\n\n            for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.aggResultColumns) {\n                AbstractExpression rootExpr = col.expression;\n                AbstractExpression agg_input_expr = null;\n                SchemaColumn schema_col = null;\n                SchemaColumn top_schema_col = null;\n                if (rootExpr instanceof AggregateExpression) {\n                    ExpressionType agg_expression_type = rootExpr.getExpressionType();\n                    agg_input_expr = rootExpr.getLeft();\n\n                    // A bit of a hack: ProjectionNodes after the\n                    // aggregate node need the output columns here to\n                    // contain TupleValueExpressions (effectively on a temp table).\n                    // So we construct one based on the output of the\n                    // aggregate expression, the column alias provided by HSQL,\n                    // and the offset into the output table schema for the\n                    // aggregate node that we're computing.\n                    // Oh, oh, it's magic, you know..\n                    TupleValueExpression tve = new TupleValueExpression();\n                    tve.setValueType(rootExpr.getValueType());\n                    tve.setValueSize(rootExpr.getValueSize());\n                    tve.setColumnIndex(outputColumnIndex);\n                    tve.setColumnName(\"\");\n                    tve.setColumnAlias(col.alias);\n                    tve.setTableName(\"VOLT_TEMP_TABLE\");\n                    boolean is_distinct = ((AggregateExpression)rootExpr).isDistinct();\n                    aggNode.addAggregate(agg_expression_type, is_distinct, outputColumnIndex, agg_input_expr);\n                    schema_col = new SchemaColumn(\"VOLT_TEMP_TABLE\", \"\", col.alias, tve);\n                    top_schema_col = new SchemaColumn(\"VOLT_TEMP_TABLE\", \"\", col.alias, tve);\n\n                    /*\n                     * Special case count(*), count(), sum(), min() and max() to\n                     * push them down to each partition. It will do the\n                     * push-down if the select columns only contains the listed\n                     * aggregate operators and other group-by columns. If the\n                     * select columns includes any other aggregates, it will not\n                     * do the push-down. - nshi\n                     */\n                    if (topAggNode != null) {\n                        ExpressionType top_expression_type = agg_expression_type;\n                        /*\n                         * For count(*), count() and sum(), the pushed-down\n                         * aggregate node doesn't change. An extra sum()\n                         * aggregate node is added to the coordinator to sum up\n                         * the numbers from all the partitions. The input schema\n                         * and the output schema of the sum() aggregate node is\n                         * the same as the output schema of the push-down\n                         * aggregate node.\n                         *\n                         * If DISTINCT is specified, don't do push-down for\n                         * count() and sum()\n                         */\n                        if (agg_expression_type == ExpressionType.AGGREGATE_COUNT_STAR ||\n                            agg_expression_type == ExpressionType.AGGREGATE_COUNT ||\n                            agg_expression_type == ExpressionType.AGGREGATE_SUM) {\n                            if (is_distinct) {\n                                topAggNode = null;\n                            }\n                            else {\n                                top_expression_type = ExpressionType.AGGREGATE_SUM;\n                            }\n                        }\n                        /*\n                         * For min() and max(), the pushed-down aggregate node\n                         * doesn't change. An extra aggregate node of the same\n                         * type is added to the coordinator. The input schema\n                         * and the output schema of the top aggregate node is\n                         * the same as the output schema of the pushed-down\n                         * aggregate node.\n                         */\n                        else if (agg_expression_type != ExpressionType.AGGREGATE_MIN &&\n                                 agg_expression_type != ExpressionType.AGGREGATE_MAX) {\n                            /*\n                             * Unsupported aggregate for push-down (AVG for example).\n                             */\n                            topAggNode = null;\n                        }\n\n                        if (topAggNode != null) {\n                            /*\n                             * Input column of the top aggregate node is the output column of the push-down aggregate node\n                             */\n                            topAggNode.addAggregate(top_expression_type, is_distinct, outputColumnIndex, tve);\n                        }\n                    }\n                }\n\n                // If the rootExpr is not itself an AggregateExpression but simply contains one (or more)\n                // like \"MAX(counter)+1\" or \"MAX(col)/MIN(col)\" the assumptions about matching input and output\n                // columns break down.\n                else if (rootExpr.hasAnySubexpressionOfClass(AggregateExpression.class)) {\n                    assert(false);\n                }\n                else\n                {\n                    /*\n                     * These columns are the pass through columns that are not being\n                     * aggregated on. These are the ones from the SELECT list. They\n                     * MUST already exist in the child node's output. Find them and\n                     * add them to the aggregate's output.\n                     */\n                    schema_col = new SchemaColumn(col.tableName, col.columnName, col.alias, col.expression);\n                    AbstractExpression topExpr = null;\n                    if (col.groupBy) {\n                        topExpr = m_parsedSelect.groupByExpressions.get(col.alias);\n                    } else {\n                        topExpr = col.expression;\n                    }\n                    top_schema_col = new SchemaColumn(col.tableName, col.columnName, col.alias, topExpr);\n                }\n\n                agg_schema.addColumn(schema_col);\n                top_agg_schema.addColumn(top_schema_col);\n                outputColumnIndex++;\n            }\n\n            for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.groupByColumns) {\n                aggNode.addGroupByExpression(col.expression);\n\n                if (topAggNode != null) {\n                    topAggNode.addGroupByExpression(m_parsedSelect.groupByExpressions.get(col.alias));\n                }\n            }\n            aggNode.setOutputSchema(agg_schema);\n            if (topAggNode != null) {\n                if (m_parsedSelect.hasComplexGroupby()) {\n                    topAggNode.setOutputSchema(top_agg_schema);\n                } else {\n                    topAggNode.setOutputSchema(agg_schema);\n                }\n\n            }\n\n            NodeSchema newSchema = m_parsedSelect.getNewSchema();\n            root = pushDownAggregate(root, aggNode, topAggNode, m_parsedSelect.hasComplexAgg(), newSchema);\n        }\n\n        if (m_parsedSelect.isGrouped()) {\n            // DISTINCT is redundant with GROUP BY IFF all of the grouping columns are present in the display columns. Return early.\n            if (m_parsedSelect.displayColumnsContainAllGroupByColumns()) {\n                return root;\n            }\n        }\n        // DISTINCT is redundant on a single-row result. Return early.\n        else if (containsAggregateExpression) {\n            return root;\n        }\n\n        // Handle DISTINCT if it is not redundant with aggregation/grouping.\n        return handleDistinct(root);\n    }","id":83000,"modified_method":"AbstractPlanNode handleAggregationOperators(AbstractPlanNode root) {\n        AggregatePlanNode aggNode = null;\n\n        /* Check if any aggregate expressions are present */\n        boolean containsAggregateExpression = m_parsedSelect.hasAggregateExpression();\n\n        /*\n         * \"Select A from T group by A\" is grouped but has no aggregate operator\n         * expressions. Catch that case by checking the grouped flag\n         */\n        if (containsAggregateExpression || m_parsedSelect.isGrouped()) {\n            AggregatePlanNode topAggNode;\n            if (m_partitioning.requiresTwoFragments()) {\n                AbstractPlanNode candidate = root.getChild(0).getChild(0);\n                candidate = indexAccessForGroupByExprs(candidate);\n                if (candidate.getPlanNodeType() == PlanNodeType.INDEXSCAN) {\n                    candidate.clearParents();\n                    root.getChild(0).clearChildren();\n                    root.getChild(0).addAndLinkChild(candidate);\n                }\n            } else {\n                root = indexAccessForGroupByExprs(root);\n            }\n            // A hash is required to build up per-group aggregates in parallel vs.\n            // when there is only one aggregation over the entire table OR when the\n            // per-group aggregates are being built serially from the ordered output\n            // of an index scan.\n            // Currently, an index scan only claims to have a sort direction when its output\n            // matches the order demanded by the ORDER BY clause.\n            // The only way these ordered indexed columns could survive the aggregation process\n            // (unaggregated) is if they are also GROUP BY columns. So an index with a valid\n            // sort direction indicates that all of the ORDER BY columns are grouped, but how\n            // do we know that ALL of the GROUPED columns are ordered, so we can ditch the hash?\n            // TODO: There appears to be some such test missing here.\n\n            // The way that an index scan under-claims the sorted-ness of its output can lead to cases\n            // where a hash is used needlessly -- it's possible that there is no ORDER BY or that\n            // the indexed columns come out sorted in some wrong direction WRT the order by.\n            // In that case, we could miss the possibility that the index produces sufficient sorted-ness\n            // not to interleave groups, and so we would needlessly use a hash.\n            // This is the less ambitious aspect of issue ENG-4096. The more ambitious aspect\n            // is that the ability to by-pass use of the hash could actually motivate selection of\n            // a compatible index scan, even when one would not be motivated by a WHERE or ORDER BY clause.\n            if (m_parsedSelect.isGrouped() &&\n                (root.getPlanNodeType() != PlanNodeType.INDEXSCAN ||\n                 ((IndexScanPlanNode) root).getSortDirection() == SortDirectionType.INVALID )) {\n                aggNode = new HashAggregatePlanNode();\n                topAggNode = new HashAggregatePlanNode();\n            } else {\n                aggNode = new AggregatePlanNode();\n                topAggNode = new AggregatePlanNode();\n            }\n\n            int outputColumnIndex = 0;\n            NodeSchema agg_schema = new NodeSchema();\n            NodeSchema top_agg_schema = new NodeSchema();\n\n            for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.aggResultColumns) {\n                AbstractExpression rootExpr = col.expression;\n                AbstractExpression agg_input_expr = null;\n                SchemaColumn schema_col = null;\n                SchemaColumn top_schema_col = null;\n                if (rootExpr instanceof AggregateExpression) {\n                    ExpressionType agg_expression_type = rootExpr.getExpressionType();\n                    agg_input_expr = rootExpr.getLeft();\n\n                    // A bit of a hack: ProjectionNodes after the\n                    // aggregate node need the output columns here to\n                    // contain TupleValueExpressions (effectively on a temp table).\n                    // So we construct one based on the output of the\n                    // aggregate expression, the column alias provided by HSQL,\n                    // and the offset into the output table schema for the\n                    // aggregate node that we're computing.\n                    // Oh, oh, it's magic, you know..\n                    TupleValueExpression tve = new TupleValueExpression();\n                    tve.setValueType(rootExpr.getValueType());\n                    tve.setValueSize(rootExpr.getValueSize());\n                    tve.setColumnIndex(outputColumnIndex);\n                    tve.setColumnName(\"\");\n                    tve.setColumnAlias(col.alias);\n                    tve.setTableName(\"VOLT_TEMP_TABLE\");\n                    boolean is_distinct = ((AggregateExpression)rootExpr).isDistinct();\n                    aggNode.addAggregate(agg_expression_type, is_distinct, outputColumnIndex, agg_input_expr);\n                    schema_col = new SchemaColumn(\"VOLT_TEMP_TABLE\", \"\", col.alias, tve);\n                    top_schema_col = new SchemaColumn(\"VOLT_TEMP_TABLE\", \"\", col.alias, tve);\n\n                    /*\n                     * Special case count(*), count(), sum(), min() and max() to\n                     * push them down to each partition. It will do the\n                     * push-down if the select columns only contains the listed\n                     * aggregate operators and other group-by columns. If the\n                     * select columns includes any other aggregates, it will not\n                     * do the push-down. - nshi\n                     */\n                    if (topAggNode != null) {\n                        ExpressionType top_expression_type = agg_expression_type;\n                        /*\n                         * For count(*), count() and sum(), the pushed-down\n                         * aggregate node doesn't change. An extra sum()\n                         * aggregate node is added to the coordinator to sum up\n                         * the numbers from all the partitions. The input schema\n                         * and the output schema of the sum() aggregate node is\n                         * the same as the output schema of the push-down\n                         * aggregate node.\n                         *\n                         * If DISTINCT is specified, don't do push-down for\n                         * count() and sum()\n                         */\n                        if (agg_expression_type == ExpressionType.AGGREGATE_COUNT_STAR ||\n                            agg_expression_type == ExpressionType.AGGREGATE_COUNT ||\n                            agg_expression_type == ExpressionType.AGGREGATE_SUM) {\n                            if (is_distinct) {\n                                topAggNode = null;\n                            }\n                            else {\n                                top_expression_type = ExpressionType.AGGREGATE_SUM;\n                            }\n                        }\n                        /*\n                         * For min() and max(), the pushed-down aggregate node\n                         * doesn't change. An extra aggregate node of the same\n                         * type is added to the coordinator. The input schema\n                         * and the output schema of the top aggregate node is\n                         * the same as the output schema of the pushed-down\n                         * aggregate node.\n                         */\n                        else if (agg_expression_type != ExpressionType.AGGREGATE_MIN &&\n                                 agg_expression_type != ExpressionType.AGGREGATE_MAX) {\n                            /*\n                             * Unsupported aggregate for push-down (AVG for example).\n                             */\n                            topAggNode = null;\n                        }\n\n                        if (topAggNode != null) {\n                            /*\n                             * Input column of the top aggregate node is the output column of the push-down aggregate node\n                             */\n                            topAggNode.addAggregate(top_expression_type, is_distinct, outputColumnIndex, tve);\n                        }\n                    }\n                }\n\n                // If the rootExpr is not itself an AggregateExpression but simply contains one (or more)\n                // like \"MAX(counter)+1\" or \"MAX(col)/MIN(col)\" the assumptions about matching input and output\n                // columns break down.\n                else if (rootExpr.hasAnySubexpressionOfClass(AggregateExpression.class)) {\n                    assert(false);\n                }\n                else\n                {\n                    /*\n                     * These columns are the pass through columns that are not being\n                     * aggregated on. These are the ones from the SELECT list. They\n                     * MUST already exist in the child node's output. Find them and\n                     * add them to the aggregate's output.\n                     */\n                    schema_col = new SchemaColumn(col.tableName, col.columnName, col.alias, col.expression);\n                    AbstractExpression topExpr = null;\n                    if (col.groupBy) {\n                        topExpr = m_parsedSelect.groupByExpressions.get(col.alias);\n                    } else {\n                        topExpr = col.expression;\n                    }\n                    top_schema_col = new SchemaColumn(col.tableName, col.columnName, col.alias, topExpr);\n                }\n\n                agg_schema.addColumn(schema_col);\n                top_agg_schema.addColumn(top_schema_col);\n                outputColumnIndex++;\n            }\n\n            for (ParsedSelectStmt.ParsedColInfo col : m_parsedSelect.groupByColumns) {\n                aggNode.addGroupByExpression(col.expression);\n\n                if (topAggNode != null) {\n                    topAggNode.addGroupByExpression(m_parsedSelect.groupByExpressions.get(col.alias));\n                }\n            }\n            aggNode.setOutputSchema(agg_schema);\n            if (topAggNode != null) {\n                if (m_parsedSelect.hasComplexGroupby()) {\n                    topAggNode.setOutputSchema(top_agg_schema);\n                } else {\n                    topAggNode.setOutputSchema(agg_schema);\n                }\n\n            }\n\n            NodeSchema newSchema = m_parsedSelect.getNewSchema();\n            root = pushDownAggregate(root, aggNode, topAggNode, m_parsedSelect.hasComplexAgg(), newSchema);\n        }\n\n        if (m_parsedSelect.isGrouped()) {\n            // DISTINCT is redundant with GROUP BY IFF all of the grouping columns are present in the display columns. Return early.\n            if (m_parsedSelect.displayColumnsContainAllGroupByColumns()) {\n                return root;\n            }\n        }\n        // DISTINCT is redundant on a single-row result. Return early.\n        else if (containsAggregateExpression) {\n            return root;\n        }\n\n        // Handle DISTINCT if it is not redundant with aggregation/grouping.\n        return handleDistinct(root);\n    }","commit_id":"57e3f9953e934fab59f4e2c0b7e6a9c9c72d7c90","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void resolveColumnIndexes()\n    {\n        IndexScanPlanNode inline_scan =\n            (IndexScanPlanNode) m_inlineNodes.get(PlanNodeType.INDEXSCAN);\n        assert (m_children.size() == 1 && inline_scan != null);\n        for (AbstractPlanNode child : m_children)\n        {\n            child.resolveColumnIndexes();\n        }\n        for (AbstractPlanNode inline : m_inlineNodes.values())\n        {\n            // Some of this will get undone for the inlined index scan later\n            // but this will resolve any column tracking with an inlined projection\n            inline.resolveColumnIndexes();\n        }\n        // We need the schema from the target table from the inlined index\n        NodeSchema index_schema = inline_scan.getTableSchema();\n        // We need the output schema from the child node\n        NodeSchema outer_schema = m_children.get(0).getOutputSchema();\n\n        // pull every expression out of the inlined index scan\n        // and resolve all of the TVEs against our two input schema from above.\n        // The EE still uses assignTupleValueIndexes to figure out which input\n        // table to use for each of these TVEs\n        //  get the predicate (which is the inlined node's predicate,\n        //  the planner currently blithely ignores that abstractjoinnode also\n        //  has a predicate field, and so do we.\n        List<TupleValueExpression> predicate_tves =\n            ExpressionUtil.getTupleValueExpressions(inline_scan.getPredicate());\n        for (TupleValueExpression tve : predicate_tves)\n        {\n            // this double-schema search is somewhat common, maybe it\n            // can find a static home in NodeSchema or something --izzy\n            int index = outer_schema.getIndexOfTve(tve);\n            if (index == -1)\n            {\n                index = index_schema.getIndexOfTve(tve);\n                if (index == -1)\n                {\n                    throw new RuntimeException(\"Unable to find index for nestloopindexscan TVE: \" +\n                                               tve.toString());\n                }\n            }\n            tve.setColumnIndex(index);\n        }\n\n        //  get the end expression and search key expressions\n        List<TupleValueExpression> index_tves =\n            new ArrayList<TupleValueExpression>();\n        index_tves.addAll(ExpressionUtil.getTupleValueExpressions(inline_scan.getEndExpression()));\n        for (AbstractExpression search_exp : inline_scan.getSearchKeyExpressions())\n        {\n            index_tves.addAll(ExpressionUtil.getTupleValueExpressions(search_exp));\n        }\n        for (TupleValueExpression tve : index_tves)\n        {\n            int index = outer_schema.getIndexOfTve(tve);\n            if (index == -1)\n            {\n                index = index_schema.getIndexOfTve(tve);\n                if (index == -1)\n                {\n                    throw new RuntimeException(\"Unable to find index for nestloopindexscan TVE: \" +\n                                               tve.toString());\n                }\n            }\n            tve.setColumnIndex(index);\n        }\n\n        // need to resolve the indexes of the output schema and\n        // order the combined output schema coherently\n        TreeMap<Integer, SchemaColumn> sort_cols =\n            new TreeMap<Integer, SchemaColumn>();\n        for (SchemaColumn col : m_outputSchema.getColumns())\n        {\n            // Right now these all need to be TVEs\n            assert(col.getExpression() instanceof TupleValueExpression);\n            TupleValueExpression tve = (TupleValueExpression)col.getExpression();\n            int index = outer_schema.getIndexOfTve(tve);\n            if (index == -1)\n            {\n                index = index_schema.getIndexOfTve(tve);\n                if (index == -1)\n                {\n                    throw new RuntimeException(\"Unable to find index for column: \" +\n                                               col.toString());\n                }\n                sort_cols.put(index + outer_schema.size(), col);\n            }\n            else\n            {\n                sort_cols.put(index, col);\n            }\n            tve.setColumnIndex(index);\n        }\n        // rebuild the output schema from the tree-sorted columns\n        NodeSchema new_output_schema = new NodeSchema();\n        for (SchemaColumn col : sort_cols.values())\n        {\n            new_output_schema.addColumn(col);\n        }\n        m_outputSchema = new_output_schema;\n        m_hasSignificantOutputSchema = true;\n    }","id":83001,"modified_method":"@Override\n    public void resolveColumnIndexes()\n    {\n        IndexScanPlanNode inline_scan =\n            (IndexScanPlanNode) m_inlineNodes.get(PlanNodeType.INDEXSCAN);\n        assert (m_children.size() == 1 && inline_scan != null);\n        for (AbstractPlanNode child : m_children)\n        {\n            child.resolveColumnIndexes();\n        }\n        for (AbstractPlanNode inline : m_inlineNodes.values())\n        {\n            if (inline instanceof LimitPlanNode)\n            {\n                // special handling for possible LIMIT node\n                inline.m_outputSchema = m_outputSchema.clone();\n                inline.m_hasSignificantOutputSchema = false; // It's just another cheap knock-off\n            } else {\n                // Some of this will get undone for the inlined index scan later\n                // but this will resolve any column tracking with an inlined projection\n                inline.resolveColumnIndexes();\n            }\n        }\n        // We need the schema from the target table from the inlined index\n        NodeSchema index_schema = inline_scan.getTableSchema();\n        // We need the output schema from the child node\n        NodeSchema outer_schema = m_children.get(0).getOutputSchema();\n\n        // pull every expression out of the inlined index scan\n        // and resolve all of the TVEs against our two input schema from above.\n        // The EE still uses assignTupleValueIndexes to figure out which input\n        // table to use for each of these TVEs\n        //  get the predicate (which is the inlined node's predicate,\n        //  the planner currently blithely ignores that abstractjoinnode also\n        //  has a predicate field, and so do we.\n        List<TupleValueExpression> predicate_tves =\n            ExpressionUtil.getTupleValueExpressions(inline_scan.getPredicate());\n        for (TupleValueExpression tve : predicate_tves)\n        {\n            // this double-schema search is somewhat common, maybe it\n            // can find a static home in NodeSchema or something --izzy\n            int index = outer_schema.getIndexOfTve(tve);\n            if (index == -1)\n            {\n                index = index_schema.getIndexOfTve(tve);\n                if (index == -1)\n                {\n                    throw new RuntimeException(\"Unable to find index for nestloopindexscan TVE: \" +\n                                               tve.toString());\n                }\n            }\n            tve.setColumnIndex(index);\n        }\n\n        //  get the end expression and search key expressions\n        List<TupleValueExpression> index_tves =\n            new ArrayList<TupleValueExpression>();\n        index_tves.addAll(ExpressionUtil.getTupleValueExpressions(inline_scan.getEndExpression()));\n        for (AbstractExpression search_exp : inline_scan.getSearchKeyExpressions())\n        {\n            index_tves.addAll(ExpressionUtil.getTupleValueExpressions(search_exp));\n        }\n        for (TupleValueExpression tve : index_tves)\n        {\n            int index = outer_schema.getIndexOfTve(tve);\n            if (index == -1)\n            {\n                index = index_schema.getIndexOfTve(tve);\n                if (index == -1)\n                {\n                    throw new RuntimeException(\"Unable to find index for nestloopindexscan TVE: \" +\n                                               tve.toString());\n                }\n            }\n            tve.setColumnIndex(index);\n        }\n\n        // need to resolve the indexes of the output schema and\n        // order the combined output schema coherently\n        TreeMap<Integer, SchemaColumn> sort_cols =\n            new TreeMap<Integer, SchemaColumn>();\n        for (SchemaColumn col : m_outputSchema.getColumns())\n        {\n            // Right now these all need to be TVEs\n            assert(col.getExpression() instanceof TupleValueExpression);\n            TupleValueExpression tve = (TupleValueExpression)col.getExpression();\n            int index = outer_schema.getIndexOfTve(tve);\n            if (index == -1)\n            {\n                index = index_schema.getIndexOfTve(tve);\n                if (index == -1)\n                {\n                    throw new RuntimeException(\"Unable to find index for column: \" +\n                                               col.toString());\n                }\n                sort_cols.put(index + outer_schema.size(), col);\n            }\n            else\n            {\n                sort_cols.put(index, col);\n            }\n            tve.setColumnIndex(index);\n        }\n        // rebuild the output schema from the tree-sorted columns\n        NodeSchema new_output_schema = new NodeSchema();\n        for (SchemaColumn col : sort_cols.values())\n        {\n            new_output_schema.addColumn(col);\n        }\n        m_outputSchema = new_output_schema;\n        m_hasSignificantOutputSchema = true;\n    }","commit_id":"e21ee1c3ec2e99fe44e706fe4a4010021aaacc33","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void generateOutputSchema(Database db)\n    {\n        // Important safety tip regarding this inlined\n        // index scan and ITS inlined projection:\n        // That projection is currently only used/usable as\n        // a means to narrow the set of columns from the\n        // indexscan's target table that make it into the\n        // rest of the plan.  the expressions that are\n        // given to the projection are currently not ever used\n        IndexScanPlanNode inlineScan =\n            (IndexScanPlanNode) m_inlineNodes.get(PlanNodeType.INDEXSCAN);\n        assert(inlineScan != null);\n        inlineScan.generateOutputSchema(db);\n        assert(m_children.size() == 1);\n        m_children.get(0).generateOutputSchema(db);\n        // Join the schema together to form the output schema\n        // The child subplan's output is the outer table\n        // The inlined node's output is the inner table\n        m_outputSchema =\n            m_children.get(0).getOutputSchema().\n            join(inlineScan.getOutputSchema()).copyAndReplaceWithTVE();\n        m_hasSignificantOutputSchema = true;\n\n        if (m_children.get(0).getPlanNodeType() == PlanNodeType.MATERIALIZEDSCAN) {\n            assert (((MaterializedScanPlanNode)m_children.get(0)).getSortDirection() == inlineScan.getSortDirection());\n            m_sortDirection = inlineScan.getSortDirection();\n        }\n    }","id":83002,"modified_method":"@Override\n    public void generateOutputSchema(Database db)\n    {\n        // Important safety tip regarding this inlined\n        // index scan and ITS inlined projection:\n        // That projection is currently only used/usable as\n        // a means to narrow the set of columns from the\n        // indexscan's target table that make it into the\n        // rest of the plan.  the expressions that are\n        // given to the projection are currently not ever used\n        IndexScanPlanNode inlineScan =\n            (IndexScanPlanNode) m_inlineNodes.get(PlanNodeType.INDEXSCAN);\n        assert(inlineScan != null);\n        inlineScan.generateOutputSchema(db);\n        assert(m_children.size() == 1);\n        m_children.get(0).generateOutputSchema(db);\n        // Join the schema together to form the output schema\n        // The child subplan's output is the outer table\n        // The inlined node's output is the inner table\n        m_outputSchema =\n            m_children.get(0).getOutputSchema().\n            join(inlineScan.getOutputSchema()).copyAndReplaceWithTVE();\n        m_hasSignificantOutputSchema = true;\n\n        if (m_children.get(0).getPlanNodeType() == PlanNodeType.MATERIALIZEDSCAN) {\n            assert (((MaterializedScanPlanNode)m_children.get(0)).getSortDirection() == inlineScan.getSortDirection());\n            m_sortDirection = inlineScan.getSortDirection();\n        }\n        if (m_children.get(0).getPlanNodeType() == PlanNodeType.INDEXSCAN) {\n            // sortDirection is only used in handleOrderBy(),\n            // and the sortDirection used in EE is from inlined IndexScan node\n            m_sortDirection = ((IndexScanPlanNode)m_children.get(0)).getSortDirection();\n        }\n    }","commit_id":"e21ee1c3ec2e99fe44e706fe4a4010021aaacc33","url":"https://github.com/VoltDB/voltdb"},{"original_method":"AbstractPlanNode recursivelyApply(AbstractPlanNode plan) {\n        assert(plan != null);\n\n        // depth first:\n        //     find LimitPlanNodes with exactly one child\n        //     where that child is an AbstractScanPlanNode\n        //     disconnect the LimitPlanNode\n        //     and inline the LimitPlanNode in to the AbstractScanPlanNode\n\n        ArrayList<AbstractPlanNode> children = new ArrayList<AbstractPlanNode>();\n        for (int i = 0; i < plan.getChildCount(); i++)\n            children.add(plan.getChild(i));\n        plan.clearChildren();\n\n        for (AbstractPlanNode child : children) {\n            // TODO this will break when children feed multiple parents\n            child = recursivelyApply(child);\n            child.clearParents();\n            plan.addAndLinkChild(child);\n        }\n\n        if ((plan instanceof LimitPlanNode) == false)\n            return plan;\n\n        if (plan.getChildCount() != 1)\n            return plan;\n\n        AbstractPlanNode child = plan.getChild(0);\n        if ((child instanceof AbstractScanPlanNode) == false)\n            return plan;\n\n        plan.clearChildren();\n        child.clearParents();\n        child.addInlinePlanNode(plan);\n\n        return child;\n    }","id":83003,"modified_method":"AbstractPlanNode recursivelyApply(AbstractPlanNode plan) {\n        assert(plan != null);\n\n        // depth first:\n        //     find LimitPlanNodes with exactly one child\n        //     where that child is an AbstractScanPlanNode\n        //     disconnect the LimitPlanNode\n        //     and inline the LimitPlanNode in to the AbstractScanPlanNode\n\n        ArrayList<AbstractPlanNode> children = new ArrayList<AbstractPlanNode>();\n        for (int i = 0; i < plan.getChildCount(); i++)\n            children.add(plan.getChild(i));\n        plan.clearChildren();\n\n        for (AbstractPlanNode child : children) {\n            // TODO this will break when children feed multiple parents\n            child = recursivelyApply(child);\n            child.clearParents();\n            plan.addAndLinkChild(child);\n        }\n\n        if ((plan instanceof LimitPlanNode) == false)\n            return plan;\n\n        if (plan.getChildCount() != 1)\n            return plan;\n\n        AbstractPlanNode child = plan.getChild(0);\n\n        // for AbstractScanPlanNode, push down the LIMIT to the scan node\n        if (child instanceof AbstractScanPlanNode) {\n            plan.clearChildren();\n            child.clearParents();\n            child.addInlinePlanNode(plan);\n            return child;\n        }\n\n        // for ENG-4676: Projection + NestLoopIndexPlanNode with sort direction, push down the LIMIT to the join node\n        if ((child instanceof ProjectionPlanNode) &&\n                (child.getChild(0) instanceof NestLoopIndexPlanNode) &&\n                (((NestLoopIndexPlanNode)(child.getChild(0))).getSortDirection() != SortDirectionType.INVALID)) {\n            plan.clearChildren();\n            child.clearParents();\n            child.getChild(0).addInlinePlanNode(plan);\n            return child;\n        }\n\n        return plan;\n\n    }","commit_id":"e21ee1c3ec2e99fe44e706fe4a4010021aaacc33","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Stop all threads related to this client.  No further calls may be made\n   * using this client. */\n  @Override\n  public void close() {\n    if (LOG.isDebugEnabled()) LOG.debug(\"Stopping rpc client\");\n    if (!running.compareAndSet(true, false)) return;\n\n    // wake up all connections\n    synchronized (connections) {\n      for (Connection conn : connections.values()) {\n        conn.interrupt();\n        if (conn.callSender != null) {\n          conn.callSender.interrupt();\n        }\n\n        // In case the CallSender did not setupIOStreams() yet, the Connection may not be started\n        // at all (if CallSender has a cancelled Call it can happen). See HBASE-13851\n        if (!conn.isAlive()) {\n          if (conn.markClosed(new InterruptedIOException(\"RpcClient is closing\"))) {\n            conn.close();\n          }\n        }\n      }\n    }\n\n    // wait until all connections are closed\n    while (!connections.isEmpty()) {\n      try {\n        Thread.sleep(100);\n      } catch (InterruptedException e) {\n        LOG.info(\"Interrupted while stopping the client. We still have \" + connections.size() +\n            \" connections.\");\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }","id":83004,"modified_method":"/** Stop all threads related to this client.  No further calls may be made\n   * using this client. */\n  @Override\n  public void close() {\n    if (LOG.isDebugEnabled()) LOG.debug(\"Stopping rpc client\");\n    if (!running.compareAndSet(true, false)) return;\n\n    Set<Connection> connsToClose = null;\n    // wake up all connections\n    synchronized (connections) {\n      for (Connection conn : connections.values()) {\n        conn.interrupt();\n        if (conn.callSender != null) {\n          conn.callSender.interrupt();\n        }\n\n        // In case the CallSender did not setupIOStreams() yet, the Connection may not be started\n        // at all (if CallSender has a cancelled Call it can happen). See HBASE-13851\n        if (!conn.isAlive()) {\n          if (connsToClose == null) {\n            connsToClose = new HashSet<Connection>();\n          }\n          connsToClose.add(conn);\n        }\n      }\n    }\n    if (connsToClose != null) {\n      for (Connection conn : connsToClose) {\n        conn.markClosed(new InterruptedIOException(\"RpcClient is closing\"));\n        conn.close();\n      }\n    }\n    // wait until all connections are closed\n    while (!connections.isEmpty()) {\n      try {\n        Thread.sleep(100);\n      } catch (InterruptedException e) {\n        LOG.info(\"Interrupted while stopping the client. We still have \" + connections.size() +\n            \" connections.\");\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }","commit_id":"b0f52332651ecbb8af11557df5af3189c7283212","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * Initiates a call by sending the parameter to the remote server.\n     * Note: this is not called from the Connection thread, but by other\n     * threads.\n     * @see #readResponse()\n     */\n    private void writeRequest(Call call, final int priority, Span span) throws IOException {\n      RequestHeader.Builder builder = RequestHeader.newBuilder();\n      builder.setCallId(call.id);\n      if (span != null) {\n        builder.setTraceInfo(\n            RPCTInfo.newBuilder().setParentId(span.getSpanId()).setTraceId(span.getTraceId()));\n      }\n      builder.setMethodName(call.md.getName());\n      builder.setRequestParam(call.param != null);\n      ByteBuffer cellBlock = ipcUtil.buildCellBlock(this.codec, this.compressor, call.cells);\n      if (cellBlock != null) {\n        CellBlockMeta.Builder cellBlockBuilder = CellBlockMeta.newBuilder();\n        cellBlockBuilder.setLength(cellBlock.limit());\n        builder.setCellBlockMeta(cellBlockBuilder.build());\n      }\n      // Only pass priority if there one.  Let zero be same as no priority.\n      if (priority != 0) builder.setPriority(priority);\n      RequestHeader header = builder.build();\n\n      setupIOstreams();\n\n      // Now we're going to write the call. We take the lock, then check that the connection\n      //  is still valid, and, if so we do the write to the socket. If the write fails, we don't\n      //  know where we stand, we have to close the connection.\n      checkIsOpen();\n      IOException writeException = null;\n      synchronized (this.outLock) {\n        if (Thread.interrupted()) throw new InterruptedIOException();\n\n        calls.put(call.id, call); // We put first as we don't want the connection to become idle.\n        checkIsOpen(); // Now we're checking that it didn't became idle in between.\n\n        try {\n          IPCUtil.write(this.out, header, call.param, cellBlock);\n        } catch (IOException e) {\n          // We set the value inside the synchronized block, this way the next in line\n          //  won't even try to write\n          if (markClosed(e)) {\n            close();\n          }\n          writeException = e;\n          interrupt();\n        }\n      }\n\n      // We added a call, and may be started the connection close. In both cases, we\n      //  need to notify the reader.\n      synchronized (this) {\n        notifyAll();\n      }\n\n      // Now that we notified, we can rethrow the exception if any. Otherwise we're good.\n      if (writeException != null) throw writeException;\n    }","id":83005,"modified_method":"/**\n     * Initiates a call by sending the parameter to the remote server.\n     * Note: this is not called from the Connection thread, but by other\n     * threads.\n     * @see #readResponse()\n     */\n    private void writeRequest(Call call, final int priority, Span span) throws IOException {\n      RequestHeader.Builder builder = RequestHeader.newBuilder();\n      builder.setCallId(call.id);\n      if (span != null) {\n        builder.setTraceInfo(\n            RPCTInfo.newBuilder().setParentId(span.getSpanId()).setTraceId(span.getTraceId()));\n      }\n      builder.setMethodName(call.md.getName());\n      builder.setRequestParam(call.param != null);\n      ByteBuffer cellBlock = ipcUtil.buildCellBlock(this.codec, this.compressor, call.cells);\n      if (cellBlock != null) {\n        CellBlockMeta.Builder cellBlockBuilder = CellBlockMeta.newBuilder();\n        cellBlockBuilder.setLength(cellBlock.limit());\n        builder.setCellBlockMeta(cellBlockBuilder.build());\n      }\n      // Only pass priority if there one.  Let zero be same as no priority.\n      if (priority != 0) builder.setPriority(priority);\n      RequestHeader header = builder.build();\n\n      setupIOstreams();\n\n      // Now we're going to write the call. We take the lock, then check that the connection\n      //  is still valid, and, if so we do the write to the socket. If the write fails, we don't\n      //  know where we stand, we have to close the connection.\n      checkIsOpen();\n      IOException writeException = null;\n      synchronized (this.outLock) {\n        if (Thread.interrupted()) throw new InterruptedIOException();\n\n        calls.put(call.id, call); // We put first as we don't want the connection to become idle.\n        checkIsOpen(); // Now we're checking that it didn't became idle in between.\n\n        try {\n          IPCUtil.write(this.out, header, call.param, cellBlock);\n        } catch (IOException e) {\n          // We set the value inside the synchronized block, this way the next in line\n          //  won't even try to write\n          markClosed(e);\n          close();\n          writeException = e;\n          interrupt();\n        }\n      }\n\n      // We added a call, and may be started the connection close. In both cases, we\n      //  need to notify the reader.\n      synchronized (this) {\n        notifyAll();\n      }\n\n      // Now that we notified, we can rethrow the exception if any. Otherwise we're good.\n      if (writeException != null) throw writeException;\n    }","commit_id":"b0f52332651ecbb8af11557df5af3189c7283212","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public void run() {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(getName() + \": starting, connections \" + connections.size());\n      }\n\n      WaitForWorkResult result = WaitForWorkResult.CALLER_SHOULD_CLOSE;\n      try {\n        result = waitForWork(); // Wait here for work - read or close connection\n        while (result == WaitForWorkResult.READ_RESPONSE) {\n          if (readResponse()) {\n            // shouldCloseConnection is set to true by readResponse(). Close the connection\n            result = WaitForWorkResult.CALLER_SHOULD_CLOSE;\n          } else {\n            result = waitForWork();\n          }\n        }\n      } catch (InterruptedException t) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(getName() + \": interrupted while waiting for call responses\");\n        }\n        if (markClosed(ExceptionUtil.asInterrupt(t))) {\n          // shouldCloseConnection is set to true. Close connection\n          result = WaitForWorkResult.CALLER_SHOULD_CLOSE;\n        }\n      } catch (Throwable t) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(getName() + \": unexpected throwable while waiting for call responses\", t);\n        }\n        if (markClosed(new IOException(\"Unexpected throwable while waiting call responses\", t))) {\n          // shouldCloseConnection is set to true. Close connection\n          result = WaitForWorkResult.CALLER_SHOULD_CLOSE;\n        }\n      }\n      if (result == WaitForWorkResult.CALLER_SHOULD_CLOSE) {\n        close();\n      }\n\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(getName() + \": stopped, connections \" + connections.size());\n      }\n    }","id":83006,"modified_method":"@Override\n    public void run() {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(getName() + \": starting, connections \" + connections.size());\n      }\n\n      try {\n        while (waitForWork()) { // Wait here for work - read or close connection\n          readResponse();\n        }\n      } catch (InterruptedException t) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(getName() + \": interrupted while waiting for call responses\");\n        }\n        markClosed(ExceptionUtil.asInterrupt(t));\n      } catch (Throwable t) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(getName() + \": unexpected throwable while waiting for call responses\", t);\n        }\n        markClosed(new IOException(\"Unexpected throwable while waiting call responses\", t));\n      }\n\n      close();\n\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(getName() + \": stopped, connections \" + connections.size());\n      }\n    }","commit_id":"b0f52332651ecbb8af11557df5af3189c7283212","url":"https://github.com/apache/hbase"},{"original_method":"/**\n       * Reads the call from the queue, write them on the socket.\n       */\n      @Override\n      public void run() {\n        boolean closeBySelf = false;\n        while (!shouldCloseConnection.get()) {\n          CallFuture cts = null;\n          try {\n            cts = callsToWrite.take();\n          } catch (InterruptedException e) {\n            closeBySelf = markClosed(new InterruptedIOException());\n          }\n\n          if (cts == null || cts == CallFuture.DEATH_PILL) {\n            assert shouldCloseConnection.get();\n            break;\n          }\n\n          if (cts.call.done) {\n            continue;\n          }\n\n          if (cts.call.checkAndSetTimeout()) {\n            continue;\n          }\n\n          try {\n            Connection.this.tracedWriteRequest(cts.call, cts.priority, cts.span);\n          } catch (IOException e) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"call write error for call #\" + cts.call.id\n                + \", message =\" + e.getMessage());\n            }\n            cts.call.setException(e);\n            closeBySelf = markClosed(e);\n          }\n        }\n\n        cleanup();\n        if (closeBySelf) {\n          close();\n        }\n      }","id":83007,"modified_method":"/**\n       * Reads the call from the queue, write them on the socket.\n       */\n      @Override\n      public void run() {\n        while (!shouldCloseConnection.get()) {\n          CallFuture cts = null;\n          try {\n            cts = callsToWrite.take();\n          } catch (InterruptedException e) {\n            markClosed(new InterruptedIOException());\n          }\n\n          if (cts == null || cts == CallFuture.DEATH_PILL) {\n            assert shouldCloseConnection.get();\n            break;\n          }\n\n          if (cts.call.done) {\n            continue;\n          }\n\n          if (cts.call.checkAndSetTimeout()) {\n            continue;\n          }\n\n          try {\n            Connection.this.tracedWriteRequest(cts.call, cts.priority, cts.span);\n          } catch (IOException e) {\n            if (LOG.isDebugEnabled()) {\n              LOG.debug(\"call write error for call #\" + cts.call.id\n                + \", message =\" + e.getMessage());\n            }\n            cts.call.setException(e);\n            markClosed(e);\n          }\n        }\n\n        cleanup();\n      }","commit_id":"b0f52332651ecbb8af11557df5af3189c7283212","url":"https://github.com/apache/hbase"},{"original_method":"protected synchronized WaitForWorkResult waitForWork() throws InterruptedException {\n      // beware of the concurrent access to the calls list: we can add calls, but as well\n      //  remove them.\n      long waitUntil = EnvironmentEdgeManager.currentTime() + minIdleTimeBeforeClose;\n\n      while (true) {\n        if (shouldCloseConnection.get()) {\n          return WaitForWorkResult.CLOSED;\n        }\n\n        if (!running.get()) {\n          if (markClosed(new IOException(\"stopped with \" + calls.size() + \" pending request(s)\"))) {\n            return WaitForWorkResult.CALLER_SHOULD_CLOSE;\n          }\n          return WaitForWorkResult.CLOSED;\n        }\n\n        if (!calls.isEmpty()) {\n          return WaitForWorkResult.READ_RESPONSE;\n        }\n\n        if (EnvironmentEdgeManager.currentTime() >= waitUntil) {\n          // Connection is idle.\n          // We expect the number of calls to be zero here, but actually someone can\n          //  adds a call at the any moment, as there is no synchronization between this task\n          //  and adding new calls. It's not a big issue, but it will get an exception.\n          if (markClosed(new IOException(\n              \"idle connection closed with \" + calls.size() + \" pending request(s)\"))) {\n            return WaitForWorkResult.CALLER_SHOULD_CLOSE;\n          }\n          return WaitForWorkResult.CLOSED;\n        }\n\n        wait(Math.min(minIdleTimeBeforeClose, 1000));\n      }\n    }","id":83008,"modified_method":"protected synchronized boolean waitForWork() throws InterruptedException {\n      // beware of the concurrent access to the calls list: we can add calls, but as well\n      //  remove them.\n      long waitUntil = EnvironmentEdgeManager.currentTime() + minIdleTimeBeforeClose;\n\n      while (true) {\n        if (shouldCloseConnection.get()) {\n          return false;\n        }\n\n        if (!running.get()) {\n          markClosed(new IOException(\"stopped with \" + calls.size() + \" pending request(s)\"));\n          return false;\n        }\n\n        if (!calls.isEmpty()) {\n          // shouldCloseConnection can be set to true by a parallel thread here. The caller\n          //  will need to check anyway.\n          return true;\n        }\n\n        if (EnvironmentEdgeManager.currentTime() >= waitUntil) {\n          // Connection is idle.\n          // We expect the number of calls to be zero here, but actually someone can\n          //  adds a call at the any moment, as there is no synchronization between this task\n          //  and adding new calls. It's not a big issue, but it will get an exception.\n          markClosed(new IOException(\n              \"idle connection closed with \" + calls.size() + \" pending request(s)\"));\n          return false;\n        }\n\n        wait(Math.min(minIdleTimeBeforeClose, 1000));\n      }\n    }","commit_id":"b0f52332651ecbb8af11557df5af3189c7283212","url":"https://github.com/apache/hbase"},{"original_method":"protected boolean readResponse() {\n      if (shouldCloseConnection.get()) return false;\n      Call call = null;\n      boolean expectedCall = false;\n      try {\n        // See HBaseServer.Call.setResponse for where we write out the response.\n        // Total size of the response.  Unused.  But have to read it in anyways.\n        int totalSize = in.readInt();\n\n        // Read the header\n        ResponseHeader responseHeader = ResponseHeader.parseDelimitedFrom(in);\n        int id = responseHeader.getCallId();\n        call = calls.remove(id); // call.done have to be set before leaving this method\n        expectedCall = (call != null && !call.done);\n        if (!expectedCall) {\n          // So we got a response for which we have no corresponding 'call' here on the client-side.\n          // We probably timed out waiting, cleaned up all references, and now the server decides\n          // to return a response.  There is nothing we can do w/ the response at this stage. Clean\n          // out the wire of the response so its out of the way and we can get other responses on\n          // this connection.\n          int readSoFar = IPCUtil.getTotalSizeWhenWrittenDelimited(responseHeader);\n          int whatIsLeftToRead = totalSize - readSoFar;\n          IOUtils.skipFully(in, whatIsLeftToRead);\n          return false;\n        }\n        if (responseHeader.hasException()) {\n          ExceptionResponse exceptionResponse = responseHeader.getException();\n          RemoteException re = createRemoteException(exceptionResponse);\n          call.setException(re);\n          if (isFatalConnectionException(exceptionResponse)) {\n            return markClosed(re);\n          }\n        } else {\n          Message value = null;\n          if (call.responseDefaultType != null) {\n            Builder builder = call.responseDefaultType.newBuilderForType();\n            ProtobufUtil.mergeDelimitedFrom(builder, in);\n            value = builder.build();\n          }\n          CellScanner cellBlockScanner = null;\n          if (responseHeader.hasCellBlockMeta()) {\n            int size = responseHeader.getCellBlockMeta().getLength();\n            byte [] cellBlock = new byte[size];\n            IOUtils.readFully(this.in, cellBlock, 0, cellBlock.length);\n            cellBlockScanner = ipcUtil.createCellScanner(this.codec, this.compressor, cellBlock);\n          }\n          call.setResponse(value, cellBlockScanner);\n        }\n      } catch (IOException e) {\n        if (expectedCall) call.setException(e);\n        if (e instanceof SocketTimeoutException) {\n          // Clean up open calls but don't treat this as a fatal condition,\n          // since we expect certain responses to not make it by the specified\n          // {@link ConnectionId#rpcTimeout}.\n          if (LOG.isTraceEnabled()) LOG.trace(\"ignored\", e);\n        } else {\n          // Treat this as a fatal condition and close this connection\n          return markClosed(e);\n        }\n      } finally {\n        cleanupCalls(false);\n      }\n      return false;\n    }","id":83009,"modified_method":"protected void readResponse() {\n      if (shouldCloseConnection.get()) return;\n      Call call = null;\n      boolean expectedCall = false;\n      try {\n        // See HBaseServer.Call.setResponse for where we write out the response.\n        // Total size of the response.  Unused.  But have to read it in anyways.\n        int totalSize = in.readInt();\n\n        // Read the header\n        ResponseHeader responseHeader = ResponseHeader.parseDelimitedFrom(in);\n        int id = responseHeader.getCallId();\n        call = calls.remove(id); // call.done have to be set before leaving this method\n        expectedCall = (call != null && !call.done);\n        if (!expectedCall) {\n          // So we got a response for which we have no corresponding 'call' here on the client-side.\n          // We probably timed out waiting, cleaned up all references, and now the server decides\n          // to return a response.  There is nothing we can do w/ the response at this stage. Clean\n          // out the wire of the response so its out of the way and we can get other responses on\n          // this connection.\n          int readSoFar = IPCUtil.getTotalSizeWhenWrittenDelimited(responseHeader);\n          int whatIsLeftToRead = totalSize - readSoFar;\n          IOUtils.skipFully(in, whatIsLeftToRead);\n          return;\n        }\n        if (responseHeader.hasException()) {\n          ExceptionResponse exceptionResponse = responseHeader.getException();\n          RemoteException re = createRemoteException(exceptionResponse);\n          call.setException(re);\n          if (isFatalConnectionException(exceptionResponse)) {\n            markClosed(re);\n          }\n        } else {\n          Message value = null;\n          if (call.responseDefaultType != null) {\n            Builder builder = call.responseDefaultType.newBuilderForType();\n            ProtobufUtil.mergeDelimitedFrom(builder, in);\n            value = builder.build();\n          }\n          CellScanner cellBlockScanner = null;\n          if (responseHeader.hasCellBlockMeta()) {\n            int size = responseHeader.getCellBlockMeta().getLength();\n            byte [] cellBlock = new byte[size];\n            IOUtils.readFully(this.in, cellBlock, 0, cellBlock.length);\n            cellBlockScanner = ipcUtil.createCellScanner(this.codec, this.compressor, cellBlock);\n          }\n          call.setResponse(value, cellBlockScanner);\n        }\n      } catch (IOException e) {\n        if (expectedCall) call.setException(e);\n        if (e instanceof SocketTimeoutException) {\n          // Clean up open calls but don't treat this as a fatal condition,\n          // since we expect certain responses to not make it by the specified\n          // {@link ConnectionId#rpcTimeout}.\n          if (LOG.isTraceEnabled()) LOG.trace(\"ignored\", e);\n        } else {\n          // Treat this as a fatal condition and close this connection\n          markClosed(e);\n        }\n      } finally {\n        cleanupCalls(false);\n      }\n    }","commit_id":"b0f52332651ecbb8af11557df5af3189c7283212","url":"https://github.com/apache/hbase"},{"original_method":"protected boolean markClosed(IOException e) {\n      if (e == null) throw new NullPointerException();\n\n      boolean ret = shouldCloseConnection.compareAndSet(false, true);\n      if (ret) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(getName() + \": marking at should close, reason: \" + e.getMessage());\n        }\n        if (callSender != null) {\n          callSender.close();\n        }\n      }\n      return ret;\n    }","id":83010,"modified_method":"protected synchronized void markClosed(IOException e) {\n      if (e == null) throw new NullPointerException();\n\n      if (shouldCloseConnection.compareAndSet(false, true)) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(getName() + \": marking at should close, reason: \" + e.getMessage());\n        }\n        if (callSender != null) {\n          callSender.close();\n        }\n        notifyAll();\n      }\n    }","commit_id":"b0f52332651ecbb8af11557df5af3189c7283212","url":"https://github.com/apache/hbase"},{"original_method":"protected synchronized void setupIOstreams() throws IOException {\n      if (socket != null) {\n        // The connection is already available. Perfect.\n        return;\n      }\n\n      if (shouldCloseConnection.get()){\n        throw new ConnectionClosingException(\"This connection is closing\");\n      }\n\n      if (failedServers.isFailedServer(remoteId.getAddress())) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Not trying to connect to \" + server +\n              \" this server is in the failed servers list\");\n        }\n        IOException e = new FailedServerException(\n            \"This server is in the failed servers list: \" + server);\n        if (markClosed(e)) {\n          close();\n        }\n        throw e;\n      }\n\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \" + server);\n        }\n        short numRetries = 0;\n        final short MAX_RETRIES = 5;\n        Random rand = null;\n        while (true) {\n          setupConnection();\n          InputStream inStream = NetUtils.getInputStream(socket);\n          // This creates a socket with a write timeout. This timeout cannot be changed.\n          OutputStream outStream = NetUtils.getOutputStream(socket, writeTO);\n          // Write out the preamble -- MAGIC, version, and auth to use.\n          writeConnectionHeaderPreamble(outStream);\n          if (useSasl) {\n            final InputStream in2 = inStream;\n            final OutputStream out2 = outStream;\n            UserGroupInformation ticket = remoteId.getTicket().getUGI();\n            if (authMethod == AuthMethod.KERBEROS) {\n              if (ticket != null && ticket.getRealUser() != null) {\n                ticket = ticket.getRealUser();\n              }\n            }\n            boolean continueSasl;\n            if (ticket == null) throw new FatalConnectionException(\"ticket/user is null\");\n            try {\n              continueSasl = ticket.doAs(new PrivilegedExceptionAction<Boolean>() {\n                @Override\n                public Boolean run() throws IOException {\n                  return setupSaslConnection(in2, out2);\n                }\n              });\n            } catch (Exception ex) {\n              ExceptionUtil.rethrowIfInterrupt(ex);\n              if (rand == null) {\n                rand = new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand, ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let's set up Sasl i/o streams.\n              inStream = saslRpcClient.getInputStream(inStream);\n              outStream = saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod = AuthMethod.SIMPLE;\n              useSasl = false;\n            }\n          }\n          this.in = new DataInputStream(new BufferedInputStream(inStream));\n          synchronized (this.outLock) {\n            this.out = new DataOutputStream(new BufferedOutputStream(outStream));\n          }\n          // Now write out the connection header\n          writeConnectionHeader();\n\n          // start the receiver thread after the socket connection has been set up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        IOException e = ExceptionUtil.asInterrupt(t);\n        if (e == null) {\n          failedServers.addToFailedServers(remoteId.address);\n          if (t instanceof LinkageError) {\n            // probably the hbase hadoop version does not match the running hadoop version\n            e = new DoNotRetryIOException(t);\n          } else if (t instanceof IOException) {\n            e = (IOException) t;\n          } else {\n            e = new IOException(\"Could not set up IO Streams to \" + server, t);\n          }\n        }\n        if (markClosed(e)) {\n          close();\n        }\n        throw e;\n      }\n    }","id":83011,"modified_method":"protected synchronized void setupIOstreams() throws IOException {\n      if (socket != null) {\n        // The connection is already available. Perfect.\n        return;\n      }\n\n      if (shouldCloseConnection.get()){\n        throw new ConnectionClosingException(\"This connection is closing\");\n      }\n\n      if (failedServers.isFailedServer(remoteId.getAddress())) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Not trying to connect to \" + server +\n              \" this server is in the failed servers list\");\n        }\n        IOException e = new FailedServerException(\n            \"This server is in the failed servers list: \" + server);\n        markClosed(e);\n        close();\n        throw e;\n      }\n\n      try {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Connecting to \" + server);\n        }\n        short numRetries = 0;\n        final short MAX_RETRIES = 5;\n        Random rand = null;\n        while (true) {\n          setupConnection();\n          InputStream inStream = NetUtils.getInputStream(socket);\n          // This creates a socket with a write timeout. This timeout cannot be changed.\n          OutputStream outStream = NetUtils.getOutputStream(socket, writeTO);\n          // Write out the preamble -- MAGIC, version, and auth to use.\n          writeConnectionHeaderPreamble(outStream);\n          if (useSasl) {\n            final InputStream in2 = inStream;\n            final OutputStream out2 = outStream;\n            UserGroupInformation ticket = remoteId.getTicket().getUGI();\n            if (authMethod == AuthMethod.KERBEROS) {\n              if (ticket != null && ticket.getRealUser() != null) {\n                ticket = ticket.getRealUser();\n              }\n            }\n            boolean continueSasl;\n            if (ticket == null) throw new FatalConnectionException(\"ticket/user is null\");\n            try {\n              continueSasl = ticket.doAs(new PrivilegedExceptionAction<Boolean>() {\n                @Override\n                public Boolean run() throws IOException {\n                  return setupSaslConnection(in2, out2);\n                }\n              });\n            } catch (Exception ex) {\n              ExceptionUtil.rethrowIfInterrupt(ex);\n              if (rand == null) {\n                rand = new Random();\n              }\n              handleSaslConnectionFailure(numRetries++, MAX_RETRIES, ex, rand, ticket);\n              continue;\n            }\n            if (continueSasl) {\n              // Sasl connect is successful. Let's set up Sasl i/o streams.\n              inStream = saslRpcClient.getInputStream(inStream);\n              outStream = saslRpcClient.getOutputStream(outStream);\n            } else {\n              // fall back to simple auth because server told us so.\n              authMethod = AuthMethod.SIMPLE;\n              useSasl = false;\n            }\n          }\n          this.in = new DataInputStream(new BufferedInputStream(inStream));\n          synchronized (this.outLock) {\n            this.out = new DataOutputStream(new BufferedOutputStream(outStream));\n          }\n          // Now write out the connection header\n          writeConnectionHeader();\n\n          // start the receiver thread after the socket connection has been set up\n          start();\n          return;\n        }\n      } catch (Throwable t) {\n        IOException e = ExceptionUtil.asInterrupt(t);\n        if (e == null) {\n          failedServers.addToFailedServers(remoteId.address);\n          if (t instanceof LinkageError) {\n            // probably the hbase hadoop version does not match the running hadoop version\n            e = new DoNotRetryIOException(t);\n          } else if (t instanceof IOException) {\n            e = (IOException) t;\n          } else {\n            e = new IOException(\"Could not set up IO Streams to \" + server, t);\n          }\n        }\n        markClosed(e);\n        close();\n        throw e;\n      }\n    }","commit_id":"b0f52332651ecbb8af11557df5af3189c7283212","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public void run() {\n      MethodDescriptor md = SERVICE.getDescriptorForType().findMethodByName(\"echo\");\n\n      while (running.get()) {\n        boolean isBigPayload = random.nextBoolean();\n        String message = isBigPayload ? BIG_PAYLOAD : id + numCalls;\n        EchoRequestProto param = EchoRequestProto.newBuilder().setMessage(message).build();\n        EchoResponseProto ret = EchoResponseProto.newBuilder().setMessage(\"foo\").build();\n\n        TestRpcServer server = cluster.getRandomServer();\n        try {\n          User user = User.getCurrent();\n          InetSocketAddress address = server.getListenerAddress();\n          if (address == null) {\n            throw new IOException(\"Listener channel is closed\");\n          }\n          ret = (EchoResponseProto)\n              rpcClient.callBlockingMethod(md, null, param, ret, user, address);\n        } catch (Exception e) {\n          LOG.warn(e);\n          continue; // expected in case connection is closing or closed\n        }\n\n        try {\n          assertNotNull(ret);\n          assertEquals(message, ret.getMessage());\n        } catch (Throwable t) {\n          exception.compareAndSet(null, t);\n        }\n\n        numCalls++;\n      }\n    }","id":83012,"modified_method":"@Override\n    public void run() {\n      MethodDescriptor md = SERVICE.getDescriptorForType().findMethodByName(\"echo\");\n\n      while (running.get()) {\n        boolean isBigPayload = random.nextBoolean();\n        String message = isBigPayload ? BIG_PAYLOAD : id + numCalls;\n        EchoRequestProto param = EchoRequestProto.newBuilder().setMessage(message).build();\n        EchoResponseProto ret = EchoResponseProto.newBuilder().setMessage(\"foo\").build();\n\n        TestRpcServer server = cluster.getRandomServer();\n        try {\n          User user = User.getCurrent();\n          InetSocketAddress address = server.getListenerAddress();\n          if (address == null) {\n            throw new IOException(\"Listener channel is closed\");\n          }\n          sending.set(true);\n          ret = (EchoResponseProto)\n              rpcClient.callBlockingMethod(md, null, param, ret, user, address);\n        } catch (Exception e) {\n          LOG.warn(e);\n          continue; // expected in case connection is closing or closed\n        }\n\n        try {\n          assertNotNull(ret);\n          assertEquals(message, ret.getMessage());\n        } catch (Throwable t) {\n          exception.compareAndSet(null, t);\n        }\n\n        numCalls++;\n      }\n    }","commit_id":"da88b4824054f57fbcbc7795469ab2369a39b5ed","url":"https://github.com/apache/hbase"},{"original_method":"/** Stop all threads related to this client.  No further calls may be made\n   * using this client. */\n  @Override\n  public void close() {\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Stopping rpc client\");\n    }\n    if (!running.compareAndSet(true, false)){\n      return;\n    }\n\n    Set<Connection> connsToClose = null;\n    // wake up all connections\n    synchronized (connections) {\n      for (Connection conn : connections.values()) {\n        conn.interrupt();\n        if (conn.callSender != null) {\n          conn.callSender.interrupt();\n        }\n\n        // In case the CallSender did not setupIOStreams() yet, the Connection may not be started\n        // at all (if CallSender has a cancelled Call it can happen). See HBASE-13851\n        if (!conn.isAlive()) {\n          if (connsToClose == null) {\n            connsToClose = new HashSet<>();\n          }\n          connsToClose.add(conn);\n        }\n      }\n    }\n    if (connsToClose != null) {\n      for (Connection conn : connsToClose) {\n        if (conn.markClosed(new InterruptedIOException(\"RpcClient is closing\"))) {\n          conn.close();\n        }\n      }\n    }\n    // wait until all connections are closed\n    while (!connections.isEmpty()) {\n      try {\n        Thread.sleep(10);\n      } catch (InterruptedException e) {\n        LOG.info(\"Interrupted while stopping the client. We still have \" + connections.size() +\n            \" connections.\");\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }","id":83013,"modified_method":"/** Stop all threads related to this client.  No further calls may be made\n   * using this client. */\n  @Override\n  public void close() {\n    if (LOG.isDebugEnabled()){\n      LOG.debug(\"Stopping rpc client\");\n    }\n    if (!running.compareAndSet(true, false)){\n      return;\n    }\n\n    Set<Connection> connsToClose = null;\n    // wake up all connections\n    synchronized (connections) {\n      for (Connection conn : connections.values()) {\n        conn.interrupt();\n        if (conn.callSender != null) {\n          conn.callSender.interrupt();\n        }\n\n        // In case the CallSender did not setupIOStreams() yet, the Connection may not be started\n        // at all (if CallSender has a cancelled Call it can happen). See HBASE-13851\n        if (!conn.isAlive()) {\n          if (connsToClose == null) {\n            connsToClose = new HashSet<>();\n          }\n          connsToClose.add(conn);\n        }\n      }\n    }\n    if (connsToClose != null) {\n      for (Connection conn : connsToClose) {\n        conn.markClosed(new InterruptedIOException(\"RpcClient is closing\"));\n        conn.close();\n      }\n    }\n    // wait until all connections are closed\n    while (!connections.isEmpty()) {\n      try {\n        Thread.sleep(10);\n      } catch (InterruptedException e) {\n        LOG.info(\"Interrupted while stopping the client. We still have \" + connections.size() +\n            \" connections.\");\n        Thread.currentThread().interrupt();\n        return;\n      }\n    }\n  }","commit_id":"da88b4824054f57fbcbc7795469ab2369a39b5ed","url":"https://github.com/apache/hbase"},{"original_method":"public static int shiftBackward(CharSequence buffer, int offset, String chars) {\n    if (offset >= buffer.length()) return offset;\n\n    while (true) {\n      if (offset < 0) break;\n      char c = buffer.charAt(offset);\n      int i;\n      for (i = 0; i < chars.length(); i++) {\n        if (c == chars.charAt(i)) break;\n      }\n      if (i == chars.length()) break;\n      offset--;\n    }\n    return offset;\n  }","id":83014,"modified_method":"public static int shiftBackward(CharSequence buffer, int offset, String charsToSkip) {\n    if (offset >= buffer.length()) return offset;\n\n    while (true) {\n      if (offset < 0) break;\n      char c = buffer.charAt(offset);\n      int i;\n      for (i = 0; i < charsToSkip.length(); i++) {\n        if (c == charsToSkip.charAt(i)) break;\n      }\n      if (i == charsToSkip.length()) break;\n      offset--;\n    }\n    return offset;\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void deleteToWordStart(Editor editor) {\n    int endOffset = editor.getCaretModel().getOffset();\n    EditorActionUtil.moveCaretToPreviousWord(editor, false);\n    int startOffset = editor.getCaretModel().getOffset();\n    Document document = editor.getDocument();\n    document.deleteString(startOffset, endOffset);\n  }","id":83015,"modified_method":"private static void deleteToWordStart(Editor editor) {\n    final CaretModel caretModel = editor.getCaretModel();\n    int endOffset = caretModel.getOffset();\n    \n    // The logic is as follows:\n    //   1. Check are there white-space symbols starting at the current caret position going backwards. Delete them if any;\n    //   2. Otherwise locate previous word start and delete the text up to it;\n    // Example:\n    //    'test string    <caret>' -> 'test string<caret>'\n    //    'test string<caret>'     -> 'test <caret>'\n\n    Document document = editor.getDocument();\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    int startOffset = -1;\n    if (!selectionModel.hasSelection() && !selectionModel.hasBlockSelection()) {\n      int i = CharArrayUtil.shiftBackward(document.getCharsSequence(), Math.max(0, endOffset - 1), \" \\t\\n\");\n      if (i >= 0 && i < endOffset - 1) {\n        startOffset = i + 1; // We need offset of the first white space symbol, not offset of the last non-white space symbol before it.\n      }\n    }\n\n    if (startOffset < 0) {\n      EditorActionUtil.moveCaretToPreviousWord(editor, false);\n      startOffset = caretModel.getOffset();\n    }\n    \n    document.deleteString(startOffset, endOffset);\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void end() {\n    doAction(IdeActions.ACTION_EDITOR_MOVE_LINE_END);\n  }","id":83016,"modified_method":"protected static void end() {\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_LINE_END);\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void killRegion() {\n    doAction(\"EditorKillRegion\");\n  }","id":83017,"modified_method":"protected static void killRegion() {\n    executeAction(\"EditorKillRegion\");\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void moveCaretToNextWordWithSelection() {\n    doAction(\"EditorNextWordWithSelection\");\n  }","id":83018,"modified_method":"protected static void moveCaretToNextWordWithSelection() {\n    executeAction(\"EditorNextWordWithSelection\");\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void cutLineBackward() {\n    doAction(\"EditorCutLineBackward\");\n  }","id":83019,"modified_method":"protected static void cutLineBackward() {\n    executeAction(\"EditorCutLineBackward\");\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void killRingSave() {\n    doAction(\"EditorKillRingSave\");\n  }","id":83020,"modified_method":"protected static void killRingSave() {\n    executeAction(\"EditorKillRingSave\");\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void delete() {\n    doAction(IdeActions.ACTION_EDITOR_DELETE);\n  }","id":83021,"modified_method":"protected static void delete() {\n    executeAction(IdeActions.ACTION_EDITOR_DELETE);\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void copy() {\n    doAction(IdeActions.ACTION_EDITOR_COPY);\n  }","id":83022,"modified_method":"protected static void copy() {\n    executeAction(IdeActions.ACTION_EDITOR_COPY);\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void home() {\n    doAction(IdeActions.ACTION_EDITOR_MOVE_LINE_START);\n  }","id":83023,"modified_method":"protected static void home() {\n    executeAction(IdeActions.ACTION_EDITOR_MOVE_LINE_START);\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void killToWordEnd() {\n    doAction(\"EditorKillToWordEnd\");\n  }","id":83024,"modified_method":"protected static void killToWordEnd() {\n    executeAction(\"EditorKillToWordEnd\");\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void cutToLineEnd() {\n    doAction(\"EditorCutLineEnd\");\n  }","id":83025,"modified_method":"protected static void cutToLineEnd() {\n    executeAction(\"EditorCutLineEnd\");\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void paste() {\n    doAction(IdeActions.ACTION_EDITOR_PASTE);\n  }","id":83026,"modified_method":"protected static void paste() {\n    executeAction(IdeActions.ACTION_EDITOR_PASTE);\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void killToWordStart() {\n    doAction(\"EditorKillToWordStart\");\n  }","id":83027,"modified_method":"protected static void killToWordStart() {\n    executeAction(\"EditorKillToWordStart\");\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void moveCaretToPreviousWordWithSelection() {\n    doAction(\"EditorPreviousWordWithSelection\");\n  }","id":83028,"modified_method":"protected static void moveCaretToPreviousWordWithSelection() {\n    executeAction(\"EditorPreviousWordWithSelection\");\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void unindent() {\n    doAction(\"EditorUnindentSelection\");\n  }","id":83029,"modified_method":"protected static void unindent() {\n    executeAction(\"EditorUnindentSelection\");\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doAction(@NotNull final String actionId) {\n    CommandProcessor.getInstance().executeCommand(getProject(), new Runnable() {\n      @Override\n      public void run() {\n        EditorActionManager actionManager = EditorActionManager.getInstance();\n        EditorActionHandler actionHandler = actionManager.getActionHandler(actionId);\n        actionHandler.execute(getEditor(), DataManager.getInstance().getDataContext());\n      }\n    }, \"\", null);\n  }","id":83030,"modified_method":"protected static void executeAction(@NotNull final String actionId) {\n    CommandProcessor.getInstance().executeCommand(getProject(), new Runnable() {\n      @Override\n      public void run() {\n        EditorActionManager actionManager = EditorActionManager.getInstance();\n        EditorActionHandler actionHandler = actionManager.getActionHandler(actionId);\n        actionHandler.execute(getEditor(), DataManager.getInstance().getDataContext());\n      }\n    }, \"\", null);\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected static void backspace() {\n    doAction(IdeActions.ACTION_EDITOR_BACKSPACE);\n  }","id":83031,"modified_method":"protected static void backspace() {\n    executeAction(IdeActions.ACTION_EDITOR_BACKSPACE);\n  }","commit_id":"720ae9faa5d87b514986aed5dc56d27a1c69ca49","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private OpenFileDescriptor(final Project project, @NotNull final VirtualFile file, int line, int col, int offset, boolean persistent) {\n    myProject = project;\n\n    myFile = file;\n    myLine = line;\n    myColumn = col;\n    myOffset = offset;\n    if (offset >= 0) {\n      myRangeMarker = LazyRangeMarkerFactory.getInstance(project).createRangeMarker(file, offset);\n    }\n    else if (line >= 0 ){\n      myRangeMarker = LazyRangeMarkerFactory.getInstance(project).createRangeMarker(file, line, Math.max(0, col), persistent);\n    }\n    else {\n      myRangeMarker = null;\n    }\n  }","id":83032,"modified_method":"private OpenFileDescriptor(@NotNull Project project, @NotNull VirtualFile file,\n                             int logicalLine, int logicalColumn, int offset, boolean persistent) {\n    myProject = project;\n\n    myFile = file;\n    myLogicalLine = logicalLine;\n    myLogicalColumn = logicalColumn;\n    myOffset = offset;\n    if (offset >= 0) {\n      myRangeMarker = LazyRangeMarkerFactory.getInstance(project).createRangeMarker(file, offset);\n    }\n    else if (logicalLine >= 0 ){\n      myRangeMarker = LazyRangeMarkerFactory.getInstance(project).createRangeMarker(file, logicalLine, Math.max(0, logicalColumn), persistent);\n    }\n    else {\n      myRangeMarker = null;\n    }\n  }","commit_id":"78167d30065584fe7f0868fc94f6ad8d604a75f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getLine() {\n    return myLine;\n  }","id":83033,"modified_method":"public int getLine() {\n    return myLogicalLine;\n  }","commit_id":"78167d30065584fe7f0868fc94f6ad8d604a75f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OpenFileDescriptor(Project project, @NotNull VirtualFile file, int line, int col) {\n    this(project, file, line, col, -1, false);\n  }","id":83034,"modified_method":"public OpenFileDescriptor(@NotNull Project project, @NotNull VirtualFile file, int logicalLine, int logicalColumn) {\n    this(project, file, logicalLine, logicalColumn, -1, false);\n  }","commit_id":"78167d30065584fe7f0868fc94f6ad8d604a75f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void navigateIn(@NotNull Editor e) {\n    if (getOffset() >= 0) {\n      e.getCaretModel().moveToOffset(Math.min(getOffset(), e.getDocument().getTextLength()));\n    }\n    else if (getLine() != -1) {\n      LogicalPosition pos = new LogicalPosition(getLine(), getColumn());\n      e.getCaretModel().moveToLogicalPosition(pos);\n    }\n    else {\n      return;\n    }\n\n    e.getSelectionModel().removeSelection();\n    scrollToCaret(e);\n    unfoldCurrentLine(e);\n  }","id":83035,"modified_method":"public void navigateIn(@NotNull Editor e) {\n    final int offset = getOffset();\n    CaretModel caretModel = e.getCaretModel();\n    boolean caretMoved = false;\n    if (myLogicalLine != -1) {\n      LogicalPosition pos = new LogicalPosition(myLogicalLine, myLogicalColumn);\n      if (offset < 0 || offset == e.logicalPositionToOffset(pos)) {\n        caretModel.moveToLogicalPosition(pos);\n        caretMoved = true;\n      }\n    }\n    if (!caretMoved && offset >= 0) {\n      caretModel.moveToOffset(Math.min(offset, e.getDocument().getTextLength()));\n      caretMoved = true;\n    }\n\n    if (caretMoved) {\n      e.getSelectionModel().removeSelection();\n      scrollToCaret(e);\n      unfoldCurrentLine(e);\n    }\n  }","commit_id":"78167d30065584fe7f0868fc94f6ad8d604a75f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OpenFileDescriptor(Project project, @NotNull VirtualFile file, int line, int col, boolean persistent) {\n    this(project, file, line, col, -1, persistent);\n  }","id":83036,"modified_method":"public OpenFileDescriptor(@NotNull Project project, @NotNull VirtualFile file,\n                            int logicalLine, int logicalColumn, boolean persistent) {\n    this(project, file, logicalLine, logicalColumn, -1, persistent);\n  }","commit_id":"78167d30065584fe7f0868fc94f6ad8d604a75f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getColumn() {\n    return myColumn;\n  }","id":83037,"modified_method":"public int getColumn() {\n    return myLogicalColumn;\n  }","commit_id":"78167d30065584fe7f0868fc94f6ad8d604a75f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OpenFileHyperlinkInfo(Project project, @NotNull final VirtualFile file, final int line, final int column) {\n    myProject = project;\n    myFile = file;\n    myLine = line;\n    myColumn = column;\n  }","id":83038,"modified_method":"public OpenFileHyperlinkInfo(@NotNull Project project, @NotNull VirtualFile file,\n                               int documentLine, int documentColumn) {\n    myProject = project;\n    myFile = file;\n    myDocumentLine = documentLine;\n    myDocumentColumn = documentColumn;\n  }","commit_id":"78167d30065584fe7f0868fc94f6ad8d604a75f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public OpenFileDescriptor getDescriptor() {\n    return new OpenFileDescriptor(myProject, myFile, myLine, myColumn);\n  }","id":83039,"modified_method":"public OpenFileDescriptor getDescriptor() {\n    int offset = calculateOffset(myFile, myDocumentLine, myDocumentColumn);\n    if (offset != -1) {\n      return new OpenFileDescriptor(myProject, myFile, offset);\n    }\n    // although document position != logical position, it seems better than returning 'null'\n    return new OpenFileDescriptor(myProject, myFile, myDocumentLine, myDocumentColumn);\n  }","commit_id":"78167d30065584fe7f0868fc94f6ad8d604a75f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doPaste(final Editor editor,\n                              final Project project,\n                              final PsiFile file,\n                              final Document document) {\n    Transferable content = CopyPasteManager.getInstance().getContents();\n    if (content != null) {\n      String text = null;\n      try {\n        text = (String)content.getTransferData(DataFlavor.stringFlavor);\n      }\n      catch (Exception e) {\n        editor.getComponent().getToolkit().beep();\n      }\n      if (text == null) return;\n\n      final CodeInsightSettings settings = CodeInsightSettings.getInstance();\n\n      final Map<CopyPastePostProcessor, TextBlockTransferableData> extraData = new HashMap<CopyPastePostProcessor, TextBlockTransferableData>();\n      for(CopyPastePostProcessor processor: Extensions.getExtensions(CopyPastePostProcessor.EP_NAME)) {\n        TextBlockTransferableData data = processor.extractTransferableData(content);\n        if (data != null) {\n          extraData.put(processor, data);\n        }\n      }\n\n      text = TextBlockTransferable.convertLineSeparators(text, \"\\n\", extraData.values());\n\n      final int col = editor.getCaretModel().getLogicalPosition().column;\n      if (editor.getSelectionModel().hasSelection()) {\n        ApplicationManager.getApplication().runWriteAction(\n          new Runnable() {\n            public void run() {\n              EditorModificationUtil.deleteSelectedText(editor);\n            }\n          }\n        );\n      }\n\n      RawText rawText = RawText.fromTransferable(content);\n\n      String newText = text;\n      for(CopyPastePreProcessor preProcessor: Extensions.getExtensions(CopyPastePreProcessor.EP_NAME)) {\n        newText = preProcessor.preprocessOnPaste(project, file, editor, newText, rawText);\n      }\n      int indentOptions = text.equals(newText) ? settings.REFORMAT_ON_PASTE : CodeInsightSettings.REFORMAT_BLOCK;\n      text = newText;\n\n      if (LanguageFormatting.INSTANCE.forContext(file) == null && indentOptions != CodeInsightSettings.NO_REFORMAT) {\n        indentOptions = CodeInsightSettings.INDENT_BLOCK;\n      }\n\n      int length = text.length();\n      final String text1 = text;\n\n      ApplicationManager.getApplication().runWriteAction(\n        new Runnable() {\n          public void run() {\n            EditorModificationUtil.insertStringAtCaret(editor, text1, false, true);\n          }\n        }\n      );\n\n      int offset = editor.getCaretModel().getOffset() - length;\n      if (offset < 0) {\n        length += offset;\n        offset = 0;\n      }\n      final RangeMarker bounds = document.createRangeMarker(offset, offset + length);\n\n      editor.getCaretModel().moveToOffset(bounds.getEndOffset());\n      editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      editor.getSelectionModel().removeSelection();\n\n      final Ref<Boolean> indented = new Ref<Boolean>(Boolean.FALSE);\n      for(Map.Entry<CopyPastePostProcessor, TextBlockTransferableData> e: extraData.entrySet()) {\n        //noinspection unchecked\n        e.getKey().processTransferableData(project, editor, bounds, col, indented, e.getValue());\n      }\n\n      final int indentOptions1 = indentOptions;\n      ApplicationManager.getApplication().runWriteAction(\n        new Runnable() {\n          public void run() {\n            switch (indentOptions1) {\n              case CodeInsightSettings.INDENT_BLOCK:\n                if (!indented.get()) {\n                  indentBlock(project, editor, bounds.getStartOffset(), bounds.getEndOffset(), col);\n                }\n                break;\n\n              case CodeInsightSettings.INDENT_EACH_LINE:\n                if (!indented.get()) {\n                  indentEachLine(project, editor, bounds.getStartOffset(), bounds.getEndOffset());\n                }\n                break;\n\n              case CodeInsightSettings.REFORMAT_BLOCK:\n                indentEachLine(project, editor, bounds.getStartOffset(), bounds.getEndOffset()); // this is needed for example when inserting a comment before method\n                reformatBlock(project, editor, bounds.getStartOffset(), bounds.getEndOffset());\n                break;\n            }\n          }\n        }\n      );\n\n      if (bounds.isValid()) {\n        editor.getCaretModel().moveToOffset(bounds.getEndOffset());\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n        editor.getSelectionModel().removeSelection();\n        editor.putUserData(EditorEx.LAST_PASTED_REGION, new TextRange(bounds.getStartOffset(), bounds.getEndOffset()));\n      }\n    }\n  }","id":83040,"modified_method":"private static void doPaste(final Editor editor,\n                              final Project project,\n                              final PsiFile file,\n                              final Document document) {\n    Transferable content = CopyPasteManager.getInstance().getContents();\n    if (content != null) {\n      String text = null;\n      try {\n        text = (String)content.getTransferData(DataFlavor.stringFlavor);\n      }\n      catch (Exception e) {\n        editor.getComponent().getToolkit().beep();\n      }\n      if (text == null) return;\n\n      final CodeInsightSettings settings = CodeInsightSettings.getInstance();\n\n      final Map<CopyPastePostProcessor, TextBlockTransferableData> extraData = new HashMap<CopyPastePostProcessor, TextBlockTransferableData>();\n      for(CopyPastePostProcessor processor: Extensions.getExtensions(CopyPastePostProcessor.EP_NAME)) {\n        TextBlockTransferableData data = processor.extractTransferableData(content);\n        if (data != null) {\n          extraData.put(processor, data);\n        }\n      }\n\n      text = TextBlockTransferable.convertLineSeparators(text, \"\\n\", extraData.values());\n\n      final CaretModel caretModel = editor.getCaretModel();\n      final SelectionModel selectionModel = editor.getSelectionModel();\n      final int col = caretModel.getLogicalPosition().column;\n      \n      // There is a possible case that we want to perform paste while there is an active selection at the editor and caret is located\n      // inside it (e.g. Ctrl+A is pressed while caret is not at the zero column). We want to insert the text at selection start column\n      // then, hence, inserted block of text should be indented according to the selection start as well.\n      final int blockIndentAnchorColumn;\n      final int caretOffset = caretModel.getOffset();\n      if (selectionModel.hasSelection() && caretOffset >= selectionModel.getSelectionStart()\n          && caretOffset < selectionModel.getSelectionEnd()) \n      {\n        blockIndentAnchorColumn = editor.offsetToLogicalPosition(selectionModel.getSelectionStart()).column;\n      }\n      else {\n        blockIndentAnchorColumn = col;\n      }\n        \n      if (selectionModel.hasSelection()) {\n        ApplicationManager.getApplication().runWriteAction(\n          new Runnable() {\n            public void run() {\n              EditorModificationUtil.deleteSelectedText(editor);\n            }\n          }\n        );\n      }\n\n      RawText rawText = RawText.fromTransferable(content);\n\n      String newText = text;\n      for(CopyPastePreProcessor preProcessor: Extensions.getExtensions(CopyPastePreProcessor.EP_NAME)) {\n        newText = preProcessor.preprocessOnPaste(project, file, editor, newText, rawText);\n      }\n      int indentOptions = text.equals(newText) ? settings.REFORMAT_ON_PASTE : CodeInsightSettings.REFORMAT_BLOCK;\n      text = newText;\n\n      if (LanguageFormatting.INSTANCE.forContext(file) == null && indentOptions != CodeInsightSettings.NO_REFORMAT) {\n        indentOptions = CodeInsightSettings.INDENT_BLOCK;\n      }\n\n      int length = text.length();\n      final String text1 = text;\n\n      ApplicationManager.getApplication().runWriteAction(\n        new Runnable() {\n          public void run() {\n            EditorModificationUtil.insertStringAtCaret(editor, text1, false, true);\n          }\n        }\n      );\n\n      int offset = caretModel.getOffset() - length;\n      if (offset < 0) {\n        length += offset;\n        offset = 0;\n      }\n      final RangeMarker bounds = document.createRangeMarker(offset, offset + length);\n\n      caretModel.moveToOffset(bounds.getEndOffset());\n      editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      selectionModel.removeSelection();\n\n      final Ref<Boolean> indented = new Ref<Boolean>(Boolean.FALSE);\n      for(Map.Entry<CopyPastePostProcessor, TextBlockTransferableData> e: extraData.entrySet()) {\n        //noinspection unchecked\n        e.getKey().processTransferableData(project, editor, bounds, col, indented, e.getValue());\n      }\n\n      final int indentOptions1 = indentOptions;\n      ApplicationManager.getApplication().runWriteAction(\n        new Runnable() {\n          public void run() {\n            switch (indentOptions1) {\n              case CodeInsightSettings.INDENT_BLOCK:\n                if (!indented.get()) {\n                  indentBlock(project, editor, bounds.getStartOffset(), bounds.getEndOffset(), blockIndentAnchorColumn);\n                }\n                break;\n\n              case CodeInsightSettings.INDENT_EACH_LINE:\n                if (!indented.get()) {\n                  indentEachLine(project, editor, bounds.getStartOffset(), bounds.getEndOffset());\n                }\n                break;\n\n              case CodeInsightSettings.REFORMAT_BLOCK:\n                indentEachLine(project, editor, bounds.getStartOffset(), bounds.getEndOffset()); // this is needed for example when inserting a comment before method\n                reformatBlock(project, editor, bounds.getStartOffset(), bounds.getEndOffset());\n                break;\n            }\n          }\n        }\n      );\n\n      if (bounds.isValid()) {\n        caretModel.moveToOffset(bounds.getEndOffset());\n        editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n        selectionModel.removeSelection();\n        editor.putUserData(EditorEx.LAST_PASTED_REGION, new TextRange(bounds.getStartOffset(), bounds.getEndOffset()));\n      }\n    }\n  }","commit_id":"d246dc8a74428cde311557bbb10ab93e821f91d8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public TextRange surroundElements(@NotNull Project project, @NotNull Editor editor, @NotNull PsiElement[] elements)\n      throws IncorrectOperationException {\n      if (elements.length == 0) return null;\n      Language language = elements[0].getContainingFile().getLanguage();\n      Commenter commenter = LanguageCommenters.INSTANCE.forLanguage(language);\n      if (commenter == null) return null;\n      String linePrefix = commenter.getLineCommentPrefix();\n      if (linePrefix == null) return null;\n      int prefixLength = linePrefix.length();\n      int startOffset = elements[0].getTextRange().getStartOffset();\n      int endOffset = elements[elements.length - 1].getTextRange().getEndOffset();\n      int delta = 0;\n      TextRange rangeToSelect = new TextRange(startOffset, startOffset);\n      String startText = myProvider.getStartString();\n      int descPos = startText.indexOf(\"?\");\n      if (descPos >= 0) {\n        startText = startText.replace(\"?\", DEFAULT_DESC_TEXT);\n        rangeToSelect = new TextRange(startOffset + descPos, startOffset + descPos + DEFAULT_DESC_TEXT.length());\n      }\n      editor.getDocument().insertString(endOffset, \"\\n\" + linePrefix + myProvider.getEndString());\n      delta += myProvider.getEndString().length() + prefixLength;\n      editor.getDocument().insertString(startOffset, linePrefix + startText + \"\\n\");\n      delta += startText.length() + prefixLength;\n      rangeToSelect = rangeToSelect.shiftRight(prefixLength);\n      TextRange formatRange = new TextRange(startOffset, endOffset).grown(delta);\n      reformatFinalRange(project, elements[0].getContainingFile(), language, formatRange);\n      return rangeToSelect;\n    }","id":83041,"modified_method":"@Override\n    public TextRange surroundElements(@NotNull Project project, @NotNull Editor editor, @NotNull PsiElement[] elements)\n      throws IncorrectOperationException {\n      if (elements.length == 0) return null;\n      PsiElement firstElement = elements[0];\n      PsiElement lastElement = elements[elements.length - 1];\n      PsiFile psiFile = firstElement.getContainingFile();\n      Language language = psiFile.getLanguage();\n      Commenter commenter = LanguageCommenters.INSTANCE.forLanguage(language);\n      if (commenter == null) return null;\n      String linePrefix = commenter.getLineCommentPrefix();\n      if (linePrefix == null) return null;\n      int prefixLength = linePrefix.length();\n      int startOffset = firstElement.getTextRange().getStartOffset();\n      int endOffset = lastElement.getTextRange().getEndOffset();\n      int delta = 0;\n      TextRange rangeToSelect = new TextRange(startOffset, startOffset);\n      String startText = myProvider.getStartString();\n      int descPos = startText.indexOf(\"?\");\n      if (descPos >= 0) {\n        startText = startText.replace(\"?\", DEFAULT_DESC_TEXT);\n        rangeToSelect = new TextRange(startOffset + descPos, startOffset + descPos + DEFAULT_DESC_TEXT.length());\n      }\n      String startString = linePrefix + startText + \"\\n\";\n      String endString = \"\\n\" + linePrefix + myProvider.getEndString(); \n      editor.getDocument().insertString(endOffset, endString);\n      delta += endString.length();\n      editor.getDocument().insertString(startOffset, startString);\n      delta += startString.length();\n      rangeToSelect = rangeToSelect.shiftRight(prefixLength);\n      PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n      documentManager.commitDocument(documentManager.getDocument(psiFile));\n      adjustLineIndent(project, psiFile, language,\n                       new TextRange(endOffset + delta - endString.length(), endOffset + delta));\n      adjustLineIndent(project, psiFile, language,\n                       new TextRange(startOffset, startOffset + startString.length()));\n      return rangeToSelect;\n    }","commit_id":"7e851eac699b8019c7d182978e3a0882eae42b8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void reformatFinalRange(@NotNull Project project, PsiFile file, Language language, TextRange range) {\n      CommonCodeStyleSettings formatSettings = CodeStyleSettingsManager.getSettings(project).getCommonSettings(language);\n      boolean keepAtFirstCol = formatSettings.KEEP_FIRST_COLUMN_COMMENT;\n      formatSettings.KEEP_FIRST_COLUMN_COMMENT = false;\n      CodeStyleManager.getInstance(project).reformatText(file, range.getStartOffset(), range.getEndOffset());\n      formatSettings.KEEP_FIRST_COLUMN_COMMENT = keepAtFirstCol;\n    }","id":83042,"modified_method":"private static void adjustLineIndent(@NotNull Project project, PsiFile file, Language language, TextRange range) {\n      CommonCodeStyleSettings formatSettings = CodeStyleSettingsManager.getSettings(project).getCommonSettings(language);\n      boolean keepAtFirstCol = formatSettings.KEEP_FIRST_COLUMN_COMMENT;\n      formatSettings.KEEP_FIRST_COLUMN_COMMENT = false;\n      CodeStyleManager.getInstance(project).adjustLineIndent(file, range);\n      formatSettings.KEEP_FIRST_COLUMN_COMMENT = keepAtFirstCol;\n    }","commit_id":"7e851eac699b8019c7d182978e3a0882eae42b8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"HbMustacheImpl(@NotNull ASTNode astNode) {\n    super(astNode);\n  }","id":83043,"modified_method":"public HbMustacheImpl(@NotNull ASTNode astNode) {\n    super(astNode);\n  }","commit_id":"6307ced93c4a3b20fd069fdab0b2bd88da689c78","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/**\n   * When appropriate, adjusts the formatting for some 'staches, particularily close 'staches\n   * and simple inverses (\"{{^}}\" and \"{{else}}\")\n   */\n  private static void adjustMustacheFormatting(Project project, int offset, Editor editor, PsiFile file, FileViewProvider provider) {\n    if (!HbConfig.isFormattingEnabled()) {\n      // formatting disabled; nothing to do\n      return;\n    }\n\n    PsiElement elementAtCaret = provider.findElementAt(offset - 1, HbLanguage.class);\n    PsiElement closeOrSimpleInverseParent = PsiTreeUtil.findFirstParent(elementAtCaret, true, new Condition<PsiElement>() {\n      @Override\n      public boolean value(PsiElement element) {\n        return element != null\n               && (element instanceof HbSimpleInverse\n                   || element instanceof HbCloseBlockMustache);\n      }\n    });\n\n    // run the formatter if the user just completed typing a SIMPLE_INVERSE or a CLOSE_BLOCK_STACHE\n    if (closeOrSimpleInverseParent != null) {\n      // grab the current caret position (AutoIndentLinesHandler is about to mess with it)\n      PsiDocumentManager.getInstance(project).commitAllDocuments();\n      CaretModel caretModel = editor.getCaretModel();\n      CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(project);\n      codeStyleManager.adjustLineIndent(file, editor.getDocument().getLineStartOffset(caretModel.getLogicalPosition().line));\n    }\n  }","id":83044,"modified_method":"/**\n   * When appropriate, adjusts the formatting for some 'staches, particularily close 'staches\n   * and simple inverses (\"{{^}}\" and \"{{else}}\")\n   */\n  private static void adjustMustacheFormatting(Project project, int offset, Editor editor, PsiFile file, FileViewProvider provider) {\n    if (!HbConfig.isFormattingEnabled()) {\n      // formatting disabled; nothing to do\n      return;\n    }\n\n    PsiElement elementAtCaret = provider.findElementAt(offset - 1, HbLanguage.class);\n    PsiElement closeOrSimpleInverseParent = PsiTreeUtil.findFirstParent(elementAtCaret, true, new Condition<PsiElement>() {\n      @Override\n      public boolean value(PsiElement element) {\n        return element != null\n               && (element instanceof HbSimpleInverse\n                   || element instanceof HbCloseBlockMustache);\n      }\n    });\n\n    // run the formatter if the user just completed typing a SIMPLE_INVERSE or a CLOSE_BLOCK_STACHE\n    if (closeOrSimpleInverseParent != null) {\n      // grab the current caret position (AutoIndentLinesHandler is about to mess with it)\n      PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n      CaretModel caretModel = editor.getCaretModel();\n      CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(project);\n      codeStyleManager.adjustLineIndent(file, editor.getDocument().getLineStartOffset(caretModel.getLogicalPosition().line));\n    }\n  }","commit_id":"6307ced93c4a3b20fd069fdab0b2bd88da689c78","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public Result charTyped(char c, Project project, Editor editor, @NotNull PsiFile file) {\n    int offset = editor.getCaretModel().getOffset();\n    FileViewProvider provider = file.getViewProvider();\n\n    if (offset < 2 || offset > editor.getDocument().getTextLength()) {\n      return Result.CONTINUE;\n    }\n\n    String previousChar = editor.getDocument().getText(new TextRange(offset - 2, offset - 1));\n\n    if (provider instanceof HbFileViewProvider) {\n      if (c == '}' && !previousChar.equals(\"}\")) {\n        // seems like we can complete the second brace\n        PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n        PsiElement elementAt = provider.findElementAt(offset - 1, HbLanguage.class);\n        ASTNode node = elementAt != null ? elementAt.getNode() : null;\n        if (node != null && node.getElementType() == HbTokenTypes.INVALID) {\n          // yes we can!\n          previousChar = \"}\";\n          editor.getDocument().insertString(offset, previousChar);\n          editor.getCaretModel().moveToOffset(++offset);\n        }\n      }\n      // if we're looking at a close stache, we may have some business too attend to\n      if (c == '}' && previousChar.equals(\"}\")) {\n        autoInsertCloseTag(project, offset, editor, provider);\n        adjustMustacheFormatting(project, offset, editor, file, provider);\n      }\n    }\n\n    return Result.CONTINUE;\n  }","id":83045,"modified_method":"@Override\n  public Result charTyped(char c, Project project, Editor editor, @NotNull PsiFile file) {\n    int offset = editor.getCaretModel().getOffset();\n    FileViewProvider provider = file.getViewProvider();\n\n    if (offset < 2 || offset > editor.getDocument().getTextLength()) {\n      return Result.CONTINUE;\n    }\n\n    String previousChar = editor.getDocument().getText(new TextRange(offset - 2, offset - 1));\n    boolean closeBraceCompleted = false;\n\n    if (provider instanceof HbFileViewProvider) {\n      if (c == '}' && !previousChar.equals(\"}\")) {\n        // we may be able to complete the second brace\n        PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n        PsiElement elementAt = provider.findElementAt(offset - 1, HbLanguage.class);\n        ASTNode node = elementAt != null ? elementAt.getNode() : null;\n        if (node != null && node.getElementType() == HbTokenTypes.INVALID) {\n          // we should be looking at the beginning of a close brace.  Find its matching open brace and auto-complete based on its type\n          PsiElement mustache = PsiTreeUtil.findFirstParent(elementAt, new Condition<PsiElement>() {\n            @Override\n            public boolean value(PsiElement psiElement) {\n              return psiElement instanceof HbMustache;\n            }\n          });\n\n          if (mustache != null) {\n            String braceCompleter;\n\n            if (mustache.getFirstChild().getNode().getElementType() == HbTokenTypes.OPEN_UNESCAPED) {\n              // add \"}}\" to complete the CLOSE_UNESCAPED\n              braceCompleter = \"}}\";\n            } else {\n              // add \"}\" to complete the CLOSE\n              braceCompleter = \"}\";\n            }\n\n            editor.getDocument().insertString(offset, braceCompleter);\n            offset = offset + braceCompleter.length();\n            editor.getCaretModel().moveToOffset(offset);\n            closeBraceCompleted = true;\n          }\n        }\n      }\n    }\n\n    // if we just completed a close brace or the user just typed one, we may have some business to attend to\n    if (closeBraceCompleted || (c == '}' && previousChar.equals(\"}\"))) {\n      autoInsertCloseTag(project, offset, editor, provider);\n      adjustMustacheFormatting(project, offset, editor, file, provider);\n    }\n\n    return Result.CONTINUE;\n  }","commit_id":"6307ced93c4a3b20fd069fdab0b2bd88da689c78","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void testCloseDoubleBraces() {\n    doCharTest('}', \"foo {{bar<caret>\", \"foo {{bar}}<caret>\");\n    doCharTest('}', \"foo {{#bar<caret>\", \"foo {{#bar}}<caret>{{/bar}}\");\n  }","id":83046,"modified_method":"public void testCloseDoubleBraces() {\n    doCharTest('}', \"foo {{bar<caret>\", \"foo {{bar}}<caret>\");\n    doCharTest('}', \"foo {{&bar<caret>\", \"foo {{&bar}}<caret>\");\n    doCharTest('}', \"foo {{/bar<caret>\", \"foo {{/bar}}<caret>\");\n\n    HbConfig.setAutoGenerateCloseTagEnabled(true);\n    doCharTest('}', \"foo {{#bar<caret>\", \"foo {{#bar}}<caret>{{/bar}}\");\n    doCharTest('}', \"foo {{^bar<caret>\", \"foo {{^bar}}<caret>{{/bar}}\");\n\n    HbConfig.setAutoGenerateCloseTagEnabled(false);\n    doCharTest('}', \"foo {{#bar<caret>\", \"foo {{#bar}}<caret>\");\n    doCharTest('}', \"foo {{^bar<caret>\", \"foo {{^bar}}<caret>\");\n  }","commit_id":"6307ced93c4a3b20fd069fdab0b2bd88da689c78","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void runGoals()\n        throws MojoExecutionException\n    {\n        // TODO: we need to get a reference to the maven component and use that so this\n        // will work purely in an embedded mode. Not sure how to pass the release setting to the plugin in that\n        // instance though - still via -D, or is there a better way?\n\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"mvn\" );\n\n        cl.setWorkingDirectory( workingDirectory );\n\n        if ( this.goals != null )\n        {\n            // accept both space and comma, so the old way still work\n            String [] tokens = StringUtils.split( this.goals, \", \" );\n            \n            for ( int i = 0 ; i < tokens.length ; ++i )\n            {\n                cl.createArgument().setValue( tokens[i] );\n            }\n        }\n        \n        cl.createArgument().setLine( \"-DperformRelease=true\" );\n\n        cl.createArgument().setLine( \"--no-plugin-updates\" );\n\n        if ( !interactive )\n        {\n            cl.createArgument().setLine( \"--batch-mode\" );\n        }\n\n        if ( StringUtils.isEmpty( releasePom ) )\n        {\n            File pomFile = project.getFile();\n\n            releasePom = pomFile.getName();\n        }\n        \n        if ( releasePom.equals( Maven.RELEASE_POMv4 ) && interactive )\n        {\n            StringBuffer warning = new StringBuffer();\n            warning.append( \"\\n*******************************************************************************\\n\" );\n            warning.append( \"\\nYou have chosen to use the fully resolved release-POM to deploy this project.\" );\n            warning.append( \"\\n\" );\n            warning.append( \"\\nNOTE: Deploying artifacts using the fully resolved release-POM \" );\n            warning.append( \"\\nwill result in loss of any version ranges specified for your\");\n            warning.append( \"\\nproject's dependencies.\" );\n            warning.append( \"\\n\" );\n            warning.append( \"\\nAre you sure you want to do this?\" );\n            warning.append( \"\\n\" );\n            warning.append( \"\\n*******************************************************************************\\n\" );\n            \n            getLog().warn( warning );\n            \n            getLog().info( \"Enter the POM filename to use for deployment: [\" + releasePom + \"] \" );\n\n            try\n            {\n                String input = getInputHandler().readLine();\n\n                if ( !StringUtils.isEmpty( input ) )\n                {\n                    releasePom = input;\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"An error has occurred while reading the pom file location.\", e );\n            }\n        }\n        \n        getLog().info( \"Releasing project based on POM: \" + releasePom + \" in working directory: \" + workingDirectory );\n        \n        cl.createArgument().setLine( \"-f \" + releasePom );\n        \n        List profiles = project.getActiveProfiles();\n\n        if ( profiles != null && !profiles.isEmpty() )\n        {\n            StringBuffer buffer = new StringBuffer();\n\n            buffer.append( \"-P \" );\n\n            for ( Iterator it = profiles.iterator(); it.hasNext(); )\n            {\n                Profile profile = (Profile) it.next();\n\n                buffer.append( profile.getId() ).append( \",\" );\n            }\n\n            buffer.setLength( buffer.length() - 1 );\n\n            cl.createArgument().setLine( buffer.toString() );\n        }\n\n        StreamConsumer consumer = new DefaultConsumer();\n\n        try\n        {\n            this.getLog().info( cl.toString() );\n            \n            int result = CommandLineUtils.executeCommandLine( cl, consumer, consumer );\n\n            if ( result != 0 )\n            {\n                throw new MojoExecutionException( \"Result of mvn execution is: \\'\" + result + \"\\'. Release failed.\" );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MojoExecutionException( \"Can't run goal \" + goals, e );\n        }\n    }","id":83047,"modified_method":"private void runGoals()\n        throws MojoExecutionException\n    {\n        // TODO: we need to get a reference to the maven component and use that so this\n        // will work purely in an embedded mode. Not sure how to pass the release setting to the plugin in that\n        // instance though - still via -D, or is there a better way?\n\n        Commandline cl = new Commandline();\n\n        cl.setExecutable( \"mvn\" );\n\n        cl.setWorkingDirectory( workingDirectory );\n\n        if ( this.goals != null )\n        {\n            // accept both space and comma, so the old way still work\n            String [] tokens = StringUtils.split( this.goals, \", \" );\n            \n            for ( int i = 0 ; i < tokens.length ; ++i )\n            {\n                cl.createArgument().setValue( tokens[i] );\n            }\n        }\n        \n        cl.createArgument().setLine( \"-DperformRelease=true\" );\n\n        cl.createArgument().setLine( \"--no-plugin-updates\" );\n\n        if ( !interactive )\n        {\n            cl.createArgument().setLine( \"--batch-mode\" );\n        }\n        \n        if ( StringUtils.isNotEmpty( System.getProperty( MAVEN_TEST_SKIP ) ) )\n        {\n            cl.createArgument().setLine( \"-D\" + MAVEN_TEST_SKIP + \"=\" + System.getProperty( MAVEN_TEST_SKIP ) );\n        }\n\n        if ( StringUtils.isEmpty( releasePom ) )\n        {\n            File pomFile = project.getFile();\n\n            releasePom = pomFile.getName();\n        }\n        \n        if ( releasePom.equals( Maven.RELEASE_POMv4 ) && interactive )\n        {\n            StringBuffer warning = new StringBuffer();\n            warning.append( \"\\n*******************************************************************************\\n\" );\n            warning.append( \"\\nYou have chosen to use the fully resolved release-POM to deploy this project.\" );\n            warning.append( \"\\n\" );\n            warning.append( \"\\nNOTE: Deploying artifacts using the fully resolved release-POM \" );\n            warning.append( \"\\nwill result in loss of any version ranges specified for your\");\n            warning.append( \"\\nproject's dependencies.\" );\n            warning.append( \"\\n\" );\n            warning.append( \"\\nAre you sure you want to do this?\" );\n            warning.append( \"\\n\" );\n            warning.append( \"\\n*******************************************************************************\\n\" );\n            \n            getLog().warn( warning );\n            \n            getLog().info( \"Enter the POM filename to use for deployment: [\" + releasePom + \"] \" );\n\n            try\n            {\n                String input = getInputHandler().readLine();\n\n                if ( !StringUtils.isEmpty( input ) )\n                {\n                    releasePom = input;\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"An error has occurred while reading the pom file location.\", e );\n            }\n        }\n        \n        getLog().info( \"Releasing project based on POM: \" + releasePom + \" in working directory: \" + workingDirectory );\n        \n        cl.createArgument().setLine( \"-f \" + releasePom );\n        \n        List profiles = project.getActiveProfiles();\n\n        if ( profiles != null && !profiles.isEmpty() )\n        {\n            StringBuffer buffer = new StringBuffer();\n\n            buffer.append( \"-P \" );\n\n            for ( Iterator it = profiles.iterator(); it.hasNext(); )\n            {\n                Profile profile = (Profile) it.next();\n\n                buffer.append( profile.getId() ).append( \",\" );\n            }\n\n            buffer.setLength( buffer.length() - 1 );\n\n            cl.createArgument().setLine( buffer.toString() );\n        }\n\n        StreamConsumer consumer = new DefaultConsumer();\n\n        try\n        {\n            this.getLog().info( cl.toString() );\n            \n            int result = CommandLineUtils.executeCommandLine( cl, consumer, consumer );\n\n            if ( result != 0 )\n            {\n                throw new MojoExecutionException( \"Result of mvn execution is: \\'\" + result + \"\\'. Release failed.\" );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MojoExecutionException( \"Can't run goal \" + goals, e );\n        }\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected ReleaseProgressTracker getReleaseProgress()\n        throws MojoExecutionException\n    {\n        if ( releaseProgress == null )\n        {\n            try\n            {\n                releaseProgress = ReleaseProgressTracker.load( basedir.getAbsolutePath() );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Failed to load release information from file: \" +\n                    ReleaseProgressTracker.getReleaseProgressFilename(), e );\n            }\n        }\n\n        return releaseProgress;\n    }","id":83048,"modified_method":"protected ReleaseProgressTracker getReleaseProgress()\n        throws MojoExecutionException\n    {\n        if ( releaseProgress == null )\n        {\n            try\n            {\n                releaseProgress = ReleaseProgressTracker.load( basedir );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Failed to load release information from file: \" +\n                    ReleaseProgressTracker.getReleaseProgressFilename(), e );\n            }\n        }\n\n        return releaseProgress;\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        try\n        {\n            getReleaseProgress().checkpoint( basedir.getAbsolutePath(), ReleaseProgressTracker.CP_INITIALIZED );\n        }\n        catch ( IOException e )\n        {\n            getLog().warn( \"Error writing checkpoint.\", e );\n        }\n\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_PREPARED_RELEASE ) )\n        {\n            checkForLocalModifications();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    checkForPresenceOfSnapshots( project );\n\n                    String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );\n\n                    if ( !ArtifactUtils.isSnapshot( project.getVersion() ) )\n                    {\n                        throw new MojoExecutionException( \"The project \" + project.getGroupId() + \":\" +\n                            project.getArtifactId() + \" isn't a snapshot (\" + project.getVersion() + \").\" );\n                    }\n\n                    getVersionResolver().resolveVersion( project.getOriginalModel(), projectId );\n\n                    Model model = ModelUtils.cloneModel( project.getOriginalModel() );\n\n                    transformPomToReleaseVersionPom( model, projectId, project.getFile(), project.getParentArtifact(),\n                                                     project.getPluginArtifactRepositories() );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir.getAbsolutePath(),\n                                                     ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n\n            }\n\n            if ( generateReleasePoms )\n            {\n                generateReleasePoms();\n            }\n\n            checkInRelease();\n\n            tagRelease();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    Model model = ModelUtils.cloneModel( project.getOriginalModel() );\n\n                    String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );\n                    getVersionResolver().incrementVersion( model, projectId );\n\n                    getScmRewriter().restoreScmInfo( model );\n\n                    transformPomToSnapshotVersionPom( model, project.getFile() );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir.getAbsolutePath(),\n                                                     ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n            }\n\n            if ( generateReleasePoms )\n            {\n                removeReleasePoms();\n            }\n\n            checkInNextSnapshot();\n\n            try\n            {\n                getReleaseProgress().checkpoint( basedir.getAbsolutePath(),\n                                                 ReleaseProgressTracker.CP_PREPARED_RELEASE );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Error writing checkpoint.\", e );\n            }\n        }\n    }","id":83049,"modified_method":"public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        validateConfiguration();\n  \n        checkpoint( ReleaseProgressTracker.CP_INITIALIZED );\n\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_PREPARED_RELEASE ) )\n        {\n            checkForLocalModifications();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    checkForPresenceOfSnapshots( project );\n\n                    String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );\n\n                    if ( !ArtifactUtils.isSnapshot( project.getVersion() ) )\n                    {\n                        throw new MojoExecutionException( \"The project \" + projectId + \" isn't a snapshot (\"\n                            + project.getVersion() + \").\" );\n                    }\n\n                    getVersionResolver().resolveVersion( project.getOriginalModel(), projectId );\n\n                    Model model = ModelUtils.cloneModel( project.getOriginalModel() );\n\n                    transformPomToReleaseVersionPom( model, projectId, project.getFile(), project.getParentArtifact(),\n                                                     project.getPluginArtifactRepositories() );\n                }\n\n                checkpoint( ReleaseProgressTracker.CP_POM_TRANSFORMED_FOR_RELEASE );\n            }\n\n            if ( generateReleasePoms )\n            {\n                generateReleasePoms();\n            }\n\n            checkInRelease();\n\n            tagRelease();\n\n            if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT ) )\n            {\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    Model model = ModelUtils.cloneModel( project.getOriginalModel() );\n\n                    String projectId = ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() );\n                    getVersionResolver().incrementVersion( model, projectId );\n\n                    getScmRewriter().restoreScmInfo( model );\n\n                    transformPomToSnapshotVersionPom( model, project.getFile() );\n                }\n\n                checkpoint( ReleaseProgressTracker.CP_POM_TRANSORMED_FOR_DEVELOPMENT );\n            }\n\n            if ( generateReleasePoms )\n            {\n                removeReleasePoms();\n            }\n\n            checkInNextSnapshot();\n\n            checkpoint( ReleaseProgressTracker.CP_PREPARED_RELEASE );\n        }\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected ReleaseProgressTracker getReleaseProgress()\n        throws MojoExecutionException\n    {\n        if ( releaseProgress == null )\n        {\n            try\n            {\n                releaseProgress = ReleaseProgressTracker.loadOrCreate( basedir.getAbsolutePath() );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn(\n                    \"Cannot read existing release progress file from directory: \" + basedir.getAbsolutePath() + \".\" );\n                getLog().debug( \"Cause\", e );\n\n                releaseProgress = ReleaseProgressTracker.create();\n            }\n\n            if ( resume )\n            {\n                releaseProgress.setResumeAtCheckpoint( true );\n            }\n\n            if ( releaseProgress.getUsername() == null )\n            {\n                if ( username == null )\n                {\n                    username = System.getProperty( \"user.name\" );\n                }\n                releaseProgress.setUsername( username );\n            }\n\n            if ( releaseProgress.getPassword() == null && password != null )\n            {\n                releaseProgress.setPassword( password );\n            }\n\n            if ( releaseProgress.getScmTag() == null )\n            {\n                releaseProgress.setScmTag( getTagLabel() );\n            }\n\n            if ( releaseProgress.getScmTagBase() == null )\n            {\n                releaseProgress.setScmTagBase( tagBase );\n            }\n\n            if ( releaseProgress.getScmUrl() == null )\n            {\n                releaseProgress.setScmUrl( urlScm );\n            }\n\n            if ( releaseProgress.getUsername() == null || releaseProgress.getScmTag() == null ||\n                 releaseProgress.getScmUrl() == null )\n            {\n                throw new MojoExecutionException( \"Missing release preparation information.\" );\n            }\n        }\n        return releaseProgress;\n    }","id":83050,"modified_method":"protected ReleaseProgressTracker getReleaseProgress()\n        throws MojoExecutionException\n    {\n        if ( releaseProgress == null )\n        {\n            try\n            {\n                releaseProgress = ReleaseProgressTracker.loadOrCreate( basedir );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn(\n                    \"Cannot read existing release progress file from directory: \" + basedir.getAbsolutePath() + \".\" );\n                getLog().debug( \"Cause\", e );\n\n                releaseProgress = ReleaseProgressTracker.create( basedir );\n            }\n\n            if ( resume )\n            {\n                releaseProgress.setResumeAtCheckpoint( true );\n            }\n\n            if ( releaseProgress.getScmUrl() == null )\n            {\n                releaseProgress.setScmUrl( urlScm );\n            }\n\n            if ( releaseProgress.getUsername() == null )\n            {\n                if ( username == null )\n                {\n                    username = System.getProperty( \"user.name\" );\n                }\n                releaseProgress.setUsername( username );\n            }\n\n            if ( releaseProgress.getPassword() == null && password != null )\n            {\n                releaseProgress.setPassword( password );\n            }\n\n            if ( releaseProgress.getScmTagBase() == null )\n            {\n                releaseProgress.setScmTagBase( tagBase );\n            }\n\n            if ( releaseProgress.getUsername() == null || releaseProgress.getScmUrl() == null )\n            {\n                throw new MojoExecutionException( \"Missing release preparation information.\" );\n            }\n        }\n        return releaseProgress;\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void checkForLocalModifications()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_LOCAL_MODIFICATIONS_CHECKED ) )\n        {\n            getLog().info( \"Verifying there are no local modifications ...\" );\n\n            List changedFiles;\n\n            try\n            {\n                ScmHelper scm = getScm( basedir.getAbsolutePath() );\n\n                changedFiles = scm.getStatus();\n            }\n            catch ( ScmException e )\n            {\n                throw new MojoExecutionException( \"An error is occurred in the status process.\", e );\n            }\n\n            String releaseProgressFilename = ReleaseProgressTracker.getReleaseProgressFilename();\n\n            for ( Iterator i = changedFiles.iterator(); i.hasNext(); )\n            {\n                ScmFile f = (ScmFile) i.next();\n                if ( \"pom.xml.backup\".equals( f.getPath() ) || f.getPath().equals( releaseProgressFilename ) )\n                {\n                    i.remove();\n                }\n            }\n\n            if ( !changedFiles.isEmpty() )\n            {\n                StringBuffer message = new StringBuffer();\n\n                for ( Iterator i = changedFiles.iterator(); i.hasNext(); )\n                {\n                    ScmFile file = (ScmFile) i.next();\n\n                    message.append( file.toString() );\n\n                    message.append( \"\\n\" );\n                }\n\n                throw new MojoExecutionException(\n                    \"Cannot prepare the release because you have local modifications : \\n\" + message );\n            }\n\n            try\n            {\n                getReleaseProgress().checkpoint( basedir.getAbsolutePath(),\n                                                 ReleaseProgressTracker.CP_LOCAL_MODIFICATIONS_CHECKED );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Error writing checkpoint.\", e );\n            }\n        }\n    }","id":83051,"modified_method":"private void checkForLocalModifications()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_LOCAL_MODIFICATIONS_CHECKED ) )\n        {\n            getLog().info( \"Verifying there are no local modifications ...\" );\n\n            List changedFiles;\n\n            try\n            {\n                ScmHelper scm = getScm( basedir.getAbsolutePath() );\n\n                changedFiles = scm.getStatus();\n            }\n            catch ( ScmException e )\n            {\n                throw new MojoExecutionException( \"An error is occurred in the status process.\", e );\n            }\n\n            String releaseProgressFilename = ReleaseProgressTracker.getReleaseProgressFilename();\n\n            for ( Iterator i = changedFiles.iterator(); i.hasNext(); )\n            {\n                ScmFile f = (ScmFile) i.next();\n                if ( \"pom.xml.backup\".equals( f.getPath() ) || f.getPath().equals( releaseProgressFilename ) )\n                {\n                    i.remove();\n                }\n            }\n\n            if ( !changedFiles.isEmpty() )\n            {\n                StringBuffer message = new StringBuffer();\n\n                for ( Iterator i = changedFiles.iterator(); i.hasNext(); )\n                {\n                    ScmFile file = (ScmFile) i.next();\n\n                    message.append( file.toString() );\n\n                    message.append( \"\\n\" );\n                }\n\n                throw new MojoExecutionException(\n                    \"Cannot prepare the release because you have local modifications : \\n\" + message );\n            }\n\n            checkpoint( ReleaseProgressTracker.CP_LOCAL_MODIFICATIONS_CHECKED );\n        }\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"private String getTagLabel()\n        throws MojoExecutionException\n    {\n        if ( userTag == null )\n        {\n            try\n            {\n                if ( tag == null && interactive )\n                {\n                    getLog().info( \"What tag name should be used? \" );\n\n                    String inputTag = getInputHandler().readLine();\n\n                    if ( !StringUtils.isEmpty( inputTag ) )\n                    {\n                        userTag = inputTag;\n                    }\n                }\n                else\n                {\n                    userTag = tag;\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"An error has occurred in the tag process.\", e );\n            }\n        }\n\n        if ( userTag == null )\n        {\n            userTag = releaseProgress.getScmTag();\n        }\n\n        if ( userTag == null )\n        {\n            throw new MojoExecutionException( \"A tag must be specified\" );\n        }\n\n        return userTag;\n    }","id":83052,"modified_method":"/** Returns the tag name to be used when tagging the release in the scm repository.\n     * <p>\n     * If the userTag is already assigned, that value is returned.\n     * Else if the releaseProperties already has the value, then use that value.\n     * Else if we are interactive then prompt the user for a tag name.\n     * \n     * @return\n     * @throws MojoExecutionException\n     */\n    private String getTagLabel()\n        throws MojoExecutionException\n    {\n        if ( userTag == null )\n        {\n            if ( StringUtils.isNotEmpty( releaseProgress.getScmTag() ) )\n            {\n                userTag = releaseProgress.getScmTag();\n            }\n            else\n            {\n                try\n                {\n                    if ( tag == null && interactive )\n                    {\n                        String prompt = \"What tag name should be used? \";\n\n                        String defaultTag = getDefaultReleaseTag();\n\n                        if ( defaultTag != null )\n                        {\n                            prompt = prompt + \"[\" + defaultTag + \"]\";\n                        }\n\n                        getLog().info( prompt );\n\n                        String inputTag = getInputHandler().readLine();\n\n                        userTag = ( StringUtils.isEmpty( inputTag ) ) ? defaultTag : inputTag;\n                    }\n                    else\n                    {\n                        userTag = tag;\n                    }\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"An error has occurred while reading user input.\", e );\n                }\n\n                // If we were able to get a userTag from the user, save it to our release.properties file\n                if ( userTag != null )\n                {\n                    ReleaseProgressTracker releaseProgress = getReleaseProgress();\n                    releaseProgress.setScmTag( userTag );\n                    try\n                    {\n                        releaseProgress.store();\n                    }\n                    catch ( IOException e )\n                    {\n                        getLog().warn( \"An error occurred while saving the release progress file\", e );\n                    }\n\n                }\n            }\n        }\n\n        if ( userTag == null )\n        {\n            throw new MojoExecutionException( \"A release tag must be specified\" );\n        }\n\n        return userTag;\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void generateReleasePoms()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_GENERATED_RELEASE_POM ) )\n        {\n            String canonicalBasedir;\n\n            try\n            {\n                canonicalBasedir = trimPathForScmCalculation( basedir );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot canonicalize basedir: \" + basedir.getAbsolutePath(), e );\n            }\n\n            for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n            {\n                MavenProject project = (MavenProject) it.next();\n\n                MavenProject releaseProject = new MavenProject( project );\n                Model releaseModel = releaseProject.getModel();\n                fixNullValueInModel( releaseModel, project.getModel() );\n\n                // the release POM should reflect bits of these which were injected at build time...\n                // we don't need these polluting the POM.\n                releaseModel.setProfiles( Collections.EMPTY_LIST );\n                releaseModel.setDependencyManagement( null );\n                releaseProject.getBuild().setPluginManagement( null );\n\n                String projectVersion = releaseModel.getVersion();\n                if ( ArtifactUtils.isSnapshot( projectVersion ) )\n                {\n                    String snapshotVersion = projectVersion;\n\n                    projectVersion =\n                        getVersionResolver().getResolvedVersion( project.getGroupId(), project.getArtifactId() );\n\n                    if ( ArtifactUtils.isSnapshot( projectVersion ) )\n                    {\n                        throw new MojoExecutionException(\n                            \"MAJOR PROBLEM!!! Cannot find resolved version to be used in releasing project: \" +\n                                releaseProject.getId() );\n                    }\n\n                    releaseModel.setVersion( projectVersion );\n\n                    String finalName = releaseModel.getBuild().getFinalName();\n\n                    if ( finalName.equals( releaseModel.getArtifactId() + \"-\" + snapshotVersion ) )\n                    {\n                        releaseModel.getBuild().setFinalName( null );\n                    }\n                    else if ( finalName.indexOf( \"SNAPSHOT\" ) > -1 )\n                    {\n                        throw new MojoExecutionException(\n                            \"Cannot reliably adjust the finalName of project: \" + releaseProject.getId() );\n                    }\n                }\n\n                releaseModel.setParent( null );\n\n                Set artifacts = releaseProject.getArtifacts();\n                \n                if ( artifacts != null )\n                {\n                    //Rewrite dependencies section\n                    List newdeps = new ArrayList();\n\n                    Map oldDeps = new HashMap();\n                    \n                    List deps = releaseProject.getDependencies();\n                    if ( deps != null )\n                    {\n                        for ( Iterator depIterator = deps.iterator(); depIterator.hasNext(); )\n                        {\n                            Dependency dep = (Dependency) depIterator.next();\n                            \n                            oldDeps.put( ArtifactUtils.artifactId( dep.getGroupId(), dep.getArtifactId(), dep.getType(), dep.getVersion() ), dep );\n                        }\n                    }\n\n                    for ( Iterator i = releaseProject.getArtifacts().iterator(); i.hasNext(); )\n                    {\n                        Artifact artifact = (Artifact) i.next();\n                        \n                        String key = artifact.getId();\n\n                        Dependency newdep = new Dependency();\n\n                        newdep.setArtifactId( artifact.getArtifactId() );\n                        newdep.setGroupId( artifact.getGroupId() );\n\n                        String version = artifact.getVersion();\n                        if ( artifact.isSnapshot() )\n                        {\n                            version = getVersionResolver().getResolvedVersion( artifact.getGroupId(),\n                                                                               artifact.getArtifactId() );\n\n                            if ( ArtifactUtils.isSnapshot( version ) )\n                            {\n                                throw new MojoExecutionException(\n                                    \"Unresolved SNAPSHOT version of: \" + artifact + \". Cannot proceed with release.\" );\n                            }\n                        }\n\n                        newdep.setVersion( version );\n                        newdep.setType( artifact.getType() );\n                        newdep.setScope( artifact.getScope() );\n                        newdep.setClassifier( artifact.getClassifier() );\n                        \n                        Dependency old = (Dependency) oldDeps.get( key );\n                        \n                        if ( old != null )\n                        {\n                            newdep.setSystemPath( old.getSystemPath() );\n                            newdep.setExclusions( old.getExclusions() );\n                            newdep.setOptional( old.isOptional() );\n                        }\n\n                        newdeps.add( newdep );\n                    }\n\n                    releaseModel.setDependencies( newdeps );\n                }\n\n                // Use original - don't want the lifecycle introduced ones\n                Build build = releaseProject.getOriginalModel().getBuild();\n                List plugins = build != null ? build.getPlugins() : null;\n\n                if ( plugins != null )\n                {\n                    //Rewrite plugins version\n                    for ( Iterator i = plugins.iterator(); i.hasNext(); )\n                    {\n                        Plugin plugin = (Plugin) i.next();\n\n                        String version;\n                        try\n                        {\n                            version = pluginVersionManager.resolvePluginVersion( plugin.getGroupId(),\n                                                                                 plugin.getArtifactId(), releaseProject,\n                                                                                 getSettings(), localRepository );\n                        }\n                        catch ( PluginVersionResolutionException e )\n                        {\n                            throw new MojoExecutionException(\n                                \"Cannot resolve version for plugin '\" + plugin.getKey() + \"': \" + e.getMessage(), e );\n                        }\n                        catch ( InvalidPluginException e )\n                        {\n                            throw new MojoExecutionException(\n                                \"Cannot resolve version for plugin '\" + plugin.getKey() + \"': \" + e.getMessage(), e );\n                        }\n                        catch ( PluginVersionNotFoundException e )\n                        {\n                            throw new MojoFailureException( e.getMessage() );\n                        }\n\n                        if ( ArtifactUtils.isSnapshot( version ) )\n                        {\n                            throw new MojoFailureException(\n                                \"Resolved version of plugin is a snapshot. Please release this plugin before releasing this project.\\n\\nGroupId: \" +\n                                    plugin.getGroupId() + \"\\nArtifactId: \" + plugin.getArtifactId() +\n                                    \"\\nResolved Version: \" + version + \"\\n\\n\" );\n                        }\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                Reporting reporting = releaseModel.getReporting();\n                List reports = reporting != null ? reporting.getPlugins() : null;\n\n                if ( reports != null )\n                {\n                    //Rewrite report version\n                    for ( Iterator i = reports.iterator(); i.hasNext(); )\n                    {\n                        ReportPlugin plugin = (ReportPlugin) i.next();\n\n                        String version;\n                        try\n                        {\n                            version = pluginVersionManager.resolveReportPluginVersion( plugin.getGroupId(),\n                                                                                       plugin.getArtifactId(),\n                                                                                       releaseProject, getSettings(),\n                                                                                       localRepository );\n                        }\n                        catch ( PluginVersionResolutionException e )\n                        {\n                            throw new MojoExecutionException(\n                                \"Cannot resolve version for report '\" + plugin.getKey() + \"': \" + e.getMessage(), e );\n                        }\n                        catch ( InvalidPluginException e )\n                        {\n                            throw new MojoExecutionException(\n                                \"Cannot resolve version for plugin '\" + plugin.getKey() + \"': \" + e.getMessage(), e );\n                        }\n                        catch ( PluginVersionNotFoundException e )\n                        {\n                            throw new MojoFailureException( e.getMessage() );\n                        }\n\n                        if ( ArtifactUtils.isSnapshot( version ) )\n                        {\n                            throw new MojoFailureException(\n                                \"Resolved version of report is a snapshot. Please release this report plugin before releasing this project.\\n\\nGroupId: \" +\n                                    plugin.getGroupId() + \"\\nArtifactId: \" + plugin.getArtifactId() +\n                                    \"\\nResolved Version: \" + version + \"\\n\\n\" );\n                        }\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                List extensions = build != null ? build.getExtensions() : null;\n\n                if ( extensions != null )\n                {\n                    //Rewrite extension version\n                    Map extensionArtifacts = releaseProject.getExtensionArtifactMap();\n\n                    for ( Iterator i = extensions.iterator(); i.hasNext(); )\n                    {\n                        Extension ext = (Extension) i.next();\n\n                        String extensionId = ArtifactUtils.versionlessKey( ext.getGroupId(), ext.getArtifactId() );\n\n                        Artifact artifact = (Artifact) extensionArtifacts.get( extensionId );\n\n                        String version =\n                            resolveVersion( artifact, \"extension\", releaseProject.getPluginArtifactRepositories() );\n\n                        ext.setVersion( version );\n                    }\n                }\n\n                pathTranslator.unalignFromBaseDirectory( releaseProject.getModel(), project.getFile().getParentFile() );\n\n                File releasePomFile = new File( releaseProject.getFile().getParentFile(), RELEASE_POM );\n\n                Writer writer = null;\n\n                try\n                {\n                    writer = new FileWriter( releasePomFile );\n\n                    releaseProject.writeModel( writer );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Cannot write release-pom to: \" + releasePomFile, e );\n                }\n                finally\n                {\n                    IOUtil.close( writer );\n                }\n\n                try\n                {\n                    String releasePomPath = trimPathForScmCalculation( releasePomFile );\n\n                    releasePomPath = releasePomPath.substring( canonicalBasedir.length() + 1 );\n\n                    ScmHelper scm = getScm( basedir.getAbsolutePath() );\n\n                    scm.add( releasePomPath );\n                }\n                catch ( ScmException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n\n                try\n                {\n                    getReleaseProgress().checkpoint( basedir.getAbsolutePath(),\n                                                     ReleaseProgressTracker.CP_GENERATED_RELEASE_POM );\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Error writing checkpoint.\", e );\n                }\n            }\n        }\n    }","id":83053,"modified_method":"private void generateReleasePoms()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_GENERATED_RELEASE_POM ) )\n        {\n            String canonicalBasedir;\n\n            try\n            {\n                canonicalBasedir = trimPathForScmCalculation( basedir );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot canonicalize basedir: \" + basedir.getAbsolutePath(), e );\n            }\n\n            for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n            {\n                MavenProject project = (MavenProject) it.next();\n\n                MavenProject releaseProject = new MavenProject( project );\n                Model releaseModel = releaseProject.getModel();\n                fixNullValueInModel( releaseModel, project.getModel() );\n\n                // the release POM should reflect bits of these which were injected at build time...\n                // we don't need these polluting the POM.\n                releaseModel.setProfiles( Collections.EMPTY_LIST );\n                releaseModel.setDependencyManagement( null );\n                releaseProject.getBuild().setPluginManagement( null );\n\n                String projectVersion = releaseModel.getVersion();\n                if ( ArtifactUtils.isSnapshot( projectVersion ) )\n                {\n                    String snapshotVersion = projectVersion;\n\n                    projectVersion =\n                        getVersionResolver().getResolvedVersion( project.getGroupId(), project.getArtifactId() );\n\n                    if ( ArtifactUtils.isSnapshot( projectVersion ) )\n                    {\n                        throw new MojoExecutionException(\n                            \"MAJOR PROBLEM!!! Cannot find resolved version to be used in releasing project: \" +\n                                releaseProject.getId() );\n                    }\n\n                    releaseModel.setVersion( projectVersion );\n\n                    String finalName = releaseModel.getBuild().getFinalName();\n\n                    if ( finalName.equals( releaseModel.getArtifactId() + \"-\" + snapshotVersion ) )\n                    {\n                        releaseModel.getBuild().setFinalName( null );\n                    }\n                    else if ( finalName.indexOf( \"SNAPSHOT\" ) > -1 )\n                    {\n                        throw new MojoExecutionException(\n                            \"Cannot reliably adjust the finalName of project: \" + releaseProject.getId() );\n                    }\n                }\n\n                releaseModel.setParent( null );\n\n                Set artifacts = releaseProject.getArtifacts();\n\n                if ( artifacts != null )\n                {\n                    //Rewrite dependencies section\n                    List newdeps = new ArrayList();\n\n                    Map oldDeps = new HashMap();\n\n                    List deps = releaseProject.getDependencies();\n                    if ( deps != null )\n                    {\n                        for ( Iterator depIterator = deps.iterator(); depIterator.hasNext(); )\n                        {\n                            Dependency dep = (Dependency) depIterator.next();\n\n                            oldDeps.put( ArtifactUtils.artifactId( dep.getGroupId(), dep.getArtifactId(), dep.getType(), dep.getVersion() ), dep );\n                        }\n                    }\n\n                    for ( Iterator i = releaseProject.getArtifacts().iterator(); i.hasNext(); )\n                    {\n                        Artifact artifact = (Artifact) i.next();\n\n                        String key = artifact.getId();\n\n                        Dependency newdep = new Dependency();\n\n                        newdep.setArtifactId( artifact.getArtifactId() );\n                        newdep.setGroupId( artifact.getGroupId() );\n\n                        String version = artifact.getVersion();\n                        if ( artifact.isSnapshot() )\n                        {\n                            version = getVersionResolver().getResolvedVersion( artifact.getGroupId(),\n                                                                               artifact.getArtifactId() );\n\n                            if ( ArtifactUtils.isSnapshot( version ) )\n                            {\n                                throw new MojoExecutionException(\n                                    \"Unresolved SNAPSHOT version of: \" + artifact + \". Cannot proceed with release.\" );\n                            }\n                        }\n\n                        newdep.setVersion( version );\n                        newdep.setType( artifact.getType() );\n                        newdep.setScope( artifact.getScope() );\n                        newdep.setClassifier( artifact.getClassifier() );\n\n                        Dependency old = (Dependency) oldDeps.get( key );\n\n                        if ( old != null )\n                        {\n                            newdep.setSystemPath( old.getSystemPath() );\n                            newdep.setExclusions( old.getExclusions() );\n                            newdep.setOptional( old.isOptional() );\n                        }\n\n                        newdeps.add( newdep );\n                    }\n\n                    releaseModel.setDependencies( newdeps );\n                }\n\n                // Use original - don't want the lifecycle introduced ones\n                Build build = releaseProject.getOriginalModel().getBuild();\n                List plugins = build != null ? build.getPlugins() : null;\n\n                if ( plugins != null )\n                {\n                    //Rewrite plugins version\n                    for ( Iterator i = plugins.iterator(); i.hasNext(); )\n                    {\n                        Plugin plugin = (Plugin) i.next();\n\n                        String version;\n                        try\n                        {\n                            version = pluginVersionManager.resolvePluginVersion( plugin.getGroupId(),\n                                                                                 plugin.getArtifactId(), releaseProject,\n                                                                                 getSettings(), localRepository );\n                        }\n                        catch ( PluginVersionResolutionException e )\n                        {\n                            throw new MojoExecutionException(\n                                \"Cannot resolve version for plugin '\" + plugin.getKey() + \"': \" + e.getMessage(), e );\n                        }\n                        catch ( InvalidPluginException e )\n                        {\n                            throw new MojoExecutionException(\n                                \"Cannot resolve version for plugin '\" + plugin.getKey() + \"': \" + e.getMessage(), e );\n                        }\n                        catch ( PluginVersionNotFoundException e )\n                        {\n                            throw new MojoFailureException( e.getMessage() );\n                        }\n\n                        if ( ArtifactUtils.isSnapshot( version ) )\n                        {\n                            throw new MojoFailureException(\n                                \"Resolved version of plugin is a snapshot. Please release this plugin before releasing this project.\\n\\nGroupId: \" +\n                                    plugin.getGroupId() + \"\\nArtifactId: \" + plugin.getArtifactId() +\n                                    \"\\nResolved Version: \" + version + \"\\n\\n\" );\n                        }\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                Reporting reporting = releaseModel.getReporting();\n                List reports = reporting != null ? reporting.getPlugins() : null;\n\n                if ( reports != null )\n                {\n                    //Rewrite report version\n                    for ( Iterator i = reports.iterator(); i.hasNext(); )\n                    {\n                        ReportPlugin plugin = (ReportPlugin) i.next();\n\n                        String version;\n                        try\n                        {\n                            version = pluginVersionManager.resolveReportPluginVersion( plugin.getGroupId(),\n                                                                                       plugin.getArtifactId(),\n                                                                                       releaseProject, getSettings(),\n                                                                                       localRepository );\n                        }\n                        catch ( PluginVersionResolutionException e )\n                        {\n                            throw new MojoExecutionException(\n                                \"Cannot resolve version for report '\" + plugin.getKey() + \"': \" + e.getMessage(), e );\n                        }\n                        catch ( InvalidPluginException e )\n                        {\n                            throw new MojoExecutionException(\n                                \"Cannot resolve version for plugin '\" + plugin.getKey() + \"': \" + e.getMessage(), e );\n                        }\n                        catch ( PluginVersionNotFoundException e )\n                        {\n                            throw new MojoFailureException( e.getMessage() );\n                        }\n\n                        if ( ArtifactUtils.isSnapshot( version ) )\n                        {\n                            throw new MojoFailureException(\n                                \"Resolved version of report is a snapshot. Please release this report plugin before releasing this project.\\n\\nGroupId: \" +\n                                    plugin.getGroupId() + \"\\nArtifactId: \" + plugin.getArtifactId() +\n                                    \"\\nResolved Version: \" + version + \"\\n\\n\" );\n                        }\n\n                        plugin.setVersion( version );\n                    }\n                }\n\n                List extensions = build != null ? build.getExtensions() : null;\n\n                if ( extensions != null )\n                {\n                    //Rewrite extension version\n                    Map extensionArtifacts = releaseProject.getExtensionArtifactMap();\n\n                    for ( Iterator i = extensions.iterator(); i.hasNext(); )\n                    {\n                        Extension ext = (Extension) i.next();\n\n                        String extensionId = ArtifactUtils.versionlessKey( ext.getGroupId(), ext.getArtifactId() );\n\n                        Artifact artifact = (Artifact) extensionArtifacts.get( extensionId );\n\n                        String version =\n                            resolveVersion( artifact, \"extension\", releaseProject.getPluginArtifactRepositories() );\n\n                        ext.setVersion( version );\n                    }\n                }\n\n                pathTranslator.unalignFromBaseDirectory( releaseProject.getModel(), project.getFile().getParentFile() );\n\n                File releasePomFile = new File( releaseProject.getFile().getParentFile(), RELEASE_POM );\n\n                Writer writer = null;\n\n                try\n                {\n                    writer = new FileWriter( releasePomFile );\n\n                    releaseProject.writeModel( writer );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Cannot write release-pom to: \" + releasePomFile, e );\n                }\n                finally\n                {\n                    IOUtil.close( writer );\n                }\n\n                try\n                {\n                    String releasePomPath = trimPathForScmCalculation( releasePomFile );\n\n                    releasePomPath = releasePomPath.substring( canonicalBasedir.length() + 1 );\n\n                    ScmHelper scm = getScm( basedir.getAbsolutePath() );\n\n                    scm.add( releasePomPath );\n                }\n                catch ( ScmException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n                catch ( IOException e )\n                {\n                    throw new MojoExecutionException( \"Error adding the release-pom.xml: \" + releasePomFile, e );\n                }\n\n                checkpoint( ReleaseProgressTracker.CP_GENERATED_RELEASE_POM );\n            }\n        }\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void removeReleasePoms()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_REMOVED_RELEASE_POM ) )\n        {\n            getLog().info( \"Removing release POMs\" );\n\n            File currentReleasePomFile = null;\n\n            try\n            {\n                String canonicalBasedir = trimPathForScmCalculation( basedir );\n\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    currentReleasePomFile = new File( project.getFile().getParentFile(), RELEASE_POM );\n\n                    String releasePomPath = trimPathForScmCalculation( currentReleasePomFile );\n\n                    releasePomPath = releasePomPath.substring( canonicalBasedir.length() + 1 );\n\n                    ScmHelper scm = getScm( basedir.getAbsolutePath() );\n\n                    scm.remove( \"Removing for next development iteration.\", releasePomPath );\n\n                    currentReleasePomFile.delete();\n                }\n            }\n            catch ( ScmException e )\n            {\n                throw new MojoExecutionException( \"Cannot remove \" + currentReleasePomFile + \" from development HEAD.\",\n                                                  e );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot remove \" + currentReleasePomFile + \" from development HEAD.\",\n                                                  e );\n            }\n\n            try\n            {\n                getReleaseProgress().checkpoint( basedir.getAbsolutePath(),\n                                                 ReleaseProgressTracker.CP_REMOVED_RELEASE_POM );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Error writing checkpoint.\", e );\n            }\n        }\n    }","id":83054,"modified_method":"private void removeReleasePoms()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_REMOVED_RELEASE_POM ) )\n        {\n            getLog().info( \"Removing release POMs\" );\n\n            File currentReleasePomFile = null;\n\n            try\n            {\n                String canonicalBasedir = trimPathForScmCalculation( basedir );\n\n                for ( Iterator it = reactorProjects.iterator(); it.hasNext(); )\n                {\n                    MavenProject project = (MavenProject) it.next();\n\n                    currentReleasePomFile = new File( project.getFile().getParentFile(), RELEASE_POM );\n\n                    String releasePomPath = trimPathForScmCalculation( currentReleasePomFile );\n\n                    releasePomPath = releasePomPath.substring( canonicalBasedir.length() + 1 );\n\n                    ScmHelper scm = getScm( basedir.getAbsolutePath() );\n\n                    scm.remove( \"Removing for next development iteration.\", releasePomPath );\n\n                    currentReleasePomFile.delete();\n                }\n            }\n            catch ( ScmException e )\n            {\n                throw new MojoExecutionException( \"Cannot remove \" + currentReleasePomFile + \" from development HEAD.\",\n                                                  e );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Cannot remove \" + currentReleasePomFile + \" from development HEAD.\",\n                                                  e );\n            }\n\n            checkpoint( ReleaseProgressTracker.CP_REMOVED_RELEASE_POM );\n        }\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Tag the release in preparation for performing the release.\n     *\n     * We will provide the user with a default tag name based on the artifact id\n     * and the version of the project being released.\n     *\n     * where artifactId is <code>plexus-action<\/code> and the version is <code>1.0-beta-4<\/code>, the\n     * the suggested tag will be <code>PLEXUS_ACTION_1_0_BETA_4<\/code>.\n     *\n     * @throws MojoExecutionException\n     */\n    private void tagRelease()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_TAGGED_RELEASE ) )\n        {\n            String tag = getTagLabel();\n\n            try\n            {\n                ScmHelper scm = getScm( basedir.getAbsolutePath() );\n\n                scm.setTag( tag );\n\n                getLog().info( \"Tagging release with the label \" + tag + \".\" );\n\n                scm.tag();\n            }\n            catch ( ScmException e )\n            {\n                throw new MojoExecutionException( \"An error is occurred in the tag process.\", e );\n            }\n\n            try\n            {\n                getReleaseProgress().checkpoint( basedir.getAbsolutePath(), ReleaseProgressTracker.CP_TAGGED_RELEASE );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Error writing checkpoint.\", e );\n            }\n        }\n    }","id":83055,"modified_method":"/**\n     * Tag the release in preparation for performing the release.\n     *\n     * We will provide the user with a default tag name based on the artifact id\n     * and the version of the project being released.\n     *\n     * where artifactId is <code>plexus-action<\/code> and the version is <code>1.0-beta-4<\/code>, the\n     * the suggested tag will be <code>PLEXUS_ACTION_1_0_BETA_4<\/code>.\n     *\n     * @throws MojoExecutionException\n     */\n    private void tagRelease()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_TAGGED_RELEASE ) )\n        {\n            String tag = getTagLabel();\n\n            try\n            {\n                ScmHelper scm = getScm( basedir.getAbsolutePath() );\n\n                scm.setTag( tag );\n\n                getLog().info( \"Tagging release with the label \" + tag + \".\" );\n\n                scm.tag();\n            }\n            catch ( ScmException e )\n            {\n                throw new MojoExecutionException( \"An error is occurred in the tag process.\", e );\n            }\n\n            checkpoint( ReleaseProgressTracker.CP_TAGGED_RELEASE );\n        }\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Check in the POM to SCM after it has been transformed where the version has been\n     * set to the release version.\n     *\n     * @throws MojoExecutionException\n     */\n    private void checkInRelease()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_CHECKED_IN_RELEASE_VERSION ) )\n        {\n            getLog().info( \"Checking in modified POMs\" );\n\n            checkIn( \"[maven-release-plugin] prepare release \" + getTagLabel() );\n\n            try\n            {\n                getReleaseProgress().checkpoint( basedir.getAbsolutePath(),\n                                                 ReleaseProgressTracker.CP_CHECKED_IN_RELEASE_VERSION );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Error writing checkpoint.\", e );\n            }\n        }\n    }","id":83056,"modified_method":"/**\n     * Check in the POM to SCM after it has been transformed where the version has been\n     * set to the release version.\n     *\n     * @throws MojoExecutionException\n     */\n    private void checkInRelease()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_CHECKED_IN_RELEASE_VERSION ) )\n        {\n            getLog().info( \"Checking in modified POMs\" );\n\n            checkIn( \"[maven-release-plugin] prepare release \" + getTagLabel() );\n\n            checkpoint( ReleaseProgressTracker.CP_CHECKED_IN_RELEASE_VERSION );\n        }\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void checkInNextSnapshot()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_CHECKED_IN_DEVELOPMENT_VERSION ) )\n        {\n            getLog().info( \"Checking in development POMs\" );\n\n            checkIn( \"[maven-release-plugin] prepare for next development iteration\" );\n\n            try\n            {\n                getReleaseProgress().checkpoint( basedir.getAbsolutePath(),\n                                                 ReleaseProgressTracker.CP_CHECKED_IN_DEVELOPMENT_VERSION );\n            }\n            catch ( IOException e )\n            {\n                getLog().warn( \"Error writing checkpoint.\", e );\n            }\n        }\n    }","id":83057,"modified_method":"private void checkInNextSnapshot()\n        throws MojoExecutionException\n    {\n        if ( !getReleaseProgress().verifyCheckpoint( ReleaseProgressTracker.CP_CHECKED_IN_DEVELOPMENT_VERSION ) )\n        {\n            getLog().info( \"Checking in development POMs\" );\n\n            checkIn( \"[maven-release-plugin] prepare for next development iteration\" );\n\n            checkpoint( ReleaseProgressTracker.CP_CHECKED_IN_DEVELOPMENT_VERSION );\n        }\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void restoreScmInfo( Model model )\n    {\n        Scm scm = model.getScm();\n        if ( scm != null )\n        {\n            String projectId = ArtifactUtils.versionlessKey( model.getGroupId(), model.getArtifactId() );\n\n            releaseProgress.restoreScmInfo( projectId, scm );\n        }\n    }","id":83058,"modified_method":"public void restoreScmInfo( Model model ) \n        throws MojoExecutionException\n    {\n        Scm scm = model.getScm();\n        if ( scm != null )\n        {\n            String groupId = model.getGroupId();\n            if ( groupId == null && model.getParent() != null )\n            {\n                groupId = model.getParent().getGroupId();\n            }\n            \n            if ( groupId == null ) \n            {\n                throw new MojoExecutionException(\"Unable to determine groupId for artifact: \" + model.getArtifactId() );\n            }\n            \n            String projectId = ArtifactUtils.versionlessKey( groupId, model.getArtifactId() );\n\n            releaseProgress.restoreScmInfo( projectId, scm );\n        }\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void rewriteScmConnection( Scm scm, String tag )\n    {\n        if ( scm != null )\n        {\n            String scmConnection = scm.getConnection();\n            if ( scmConnection != null && scmConnection.startsWith( \"scm:svn\" ) )\n            {\n                scm.setConnection( convertSvnConnectionString( scmConnection, tag ) );\n\n                String devConnection = scm.getDeveloperConnection();\n                if ( devConnection != null )\n                {\n                    scm.setDeveloperConnection( convertSvnConnectionString( devConnection, tag ) );\n                }\n\n                String url = scm.getUrl();\n                if ( url != null )\n                {\n                    scm.setUrl( convertSvnConnectionString( url, tag ) );\n                }\n            }\n        }\n    }","id":83059,"modified_method":"private void rewriteScmConnection( Scm scm, String tag )\n    {\n        if ( scm != null )\n        {\n            String scmConnection = scm.getConnection();\n            if ( scmConnection != null && scmConnection.startsWith( \"scm:svn\" ) )\n            {\n                scm.setConnection( SvnTagBranchUtils.resolveTagUrl( scmConnection, tag ) );\n\n                String devConnection = scm.getDeveloperConnection();\n                if ( devConnection != null )\n                {\n                    scm.setDeveloperConnection( SvnTagBranchUtils.resolveTagUrl( devConnection, tag ) );\n                }\n\n                String url = scm.getUrl();\n                if ( url != null )\n                {\n                    scm.setUrl( SvnTagBranchUtils.resolveTagUrl( url, tag ) );\n                }\n            }\n        }\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"private String getVersionFromUser(String promptText, String defaultVersionStr )\n        throws MojoExecutionException\n    {\n        if ( defaultVersionStr != null )\n        {\n            promptText = promptText + \"[\" + defaultVersionStr + \"]\";\n        }\n        \n        try\n        {\n            log.info( promptText );\n\n            String inputVersion = inputHandler.readLine();\n\n            return ( StringUtils.isEmpty( inputVersion ) ) ? defaultVersionStr : inputVersion;\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Can't read version from user input.\", e );\n        }        \n    }","id":83060,"modified_method":"private String getVersionFromUser(String promptText, String defaultVersionStr )\n        throws MojoExecutionException\n    {\n        if ( defaultVersionStr != null )\n        {\n            promptText = promptText + \" [\" + defaultVersionStr + \"]\";\n        }\n        \n        try\n        {\n            log.info( promptText );\n\n            String inputVersion = inputHandler.readLine();\n\n            return ( StringUtils.isEmpty( inputVersion ) ) ? defaultVersionStr : inputVersion;\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Can't read version from user input.\", e );\n        }        \n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void resolveVersion( Model model, String projectId )\n        throws MojoExecutionException\n    {\n        if ( resolvedVersions.containsKey( projectId ) )\n        {\n            throw new IllegalArgumentException(\n                \"Project: \" + projectId + \" is already resolved. Each project should only be resolved once.\" );\n        }\n\n        //Rewrite project version\n        VersionInfo version = getVersionInfo( model.getVersion() );\n\n        String projectVersion = ( version != null ) ? version.getReleaseVersionString() : null;\n\n        if ( interactive )\n        {\n            projectVersion = getVersionFromUser(\"What is the release version for \\'\" + projectId + \"\\'?\", projectVersion);\n        } \n        else if ( StringUtils.isEmpty( projectVersion ) ) \n        {\n            throw new MojoExecutionException(\"Unable to determine release project version\");\n        }\n        \n        model.setVersion( projectVersion );\n\n        resolvedVersions.put( projectId, projectVersion );\n    }","id":83061,"modified_method":"public void resolveVersion( Model model, String projectId )\n        throws MojoExecutionException\n    {\n        if ( resolvedVersions.containsKey( projectId ) )\n        {\n            throw new IllegalArgumentException(\n                \"Project: \" + projectId + \" is already resolved. Each project should only be resolved once.\" );\n        }\n\n        //Rewrite project version\n        VersionInfo version = getVersionInfo( model.getVersion() );\n\n        String projectVersion = ( version != null ) ? version.getReleaseVersionString() : null;\n\n        if ( interactive )\n        {\n            projectVersion = getVersionFromUser(\"What is the release version for \\\"\" + projectId + \"\\\"?\", projectVersion);\n        } \n        else if ( StringUtils.isEmpty( projectVersion ) ) \n        {\n            throw new MojoExecutionException(\"Unable to determine release project version\");\n        }\n        \n        model.setVersion( projectVersion );\n\n        resolvedVersions.put( projectId, projectVersion );\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void incrementVersion( Model model, String projectId )\n        throws MojoExecutionException\n    {\n        VersionInfo version = getVersionInfo( model.getVersion() );\n        \n        if ( version != null && version.isSnapshot() )\n        {\n            throw new MojoExecutionException( \"The project \" + projectId + \" is a snapshot (\"\n                + version.getVersionString() + \"). It appears that the release version has not been committed.\" );\n        }\n\n        VersionInfo nextVersionInfo = ( version != null ) ? version.getNextVersion() : null;\n        \n        String nextVersion = (nextVersionInfo != null) ? nextVersionInfo.getSnapshotVersionString() : null;\n        \n        if ( interactive )\n        {\n            nextVersion = getVersionFromUser(\"What is the new development version for \\'\" + projectId + \"\\'?\", nextVersion );            \n        }\n        else if ( nextVersion == null )\n        {\n            throw new MojoExecutionException( \"Cannot determine incremented development version for: \" + projectId );\n        }\n\n        model.setVersion( nextVersion );\n\n        resolvedVersions.put( projectId, nextVersion );\n    }","id":83062,"modified_method":"public void incrementVersion( Model model, String projectId )\n        throws MojoExecutionException\n    {\n        VersionInfo version = getVersionInfo( model.getVersion() );\n        \n        if ( version != null && version.isSnapshot() )\n        {\n            throw new MojoExecutionException( \"The project \" + projectId + \" is a snapshot (\"\n                + version.getVersionString() + \"). It appears that the release version has not been committed.\" );\n        }\n\n        VersionInfo nextVersionInfo = ( version != null ) ? version.getNextVersion() : null;\n        \n        String nextVersion = (nextVersionInfo != null) ? nextVersionInfo.getSnapshotVersionString() : null;\n        \n        if ( interactive )\n        {\n            nextVersion = getVersionFromUser(\"What is the new development version for \\\"\" + projectId + \"\\\"?\", nextVersion );            \n        }\n        else if ( nextVersion == null )\n        {\n            throw new MojoExecutionException( \"Cannot determine incremented development version for: \" + projectId );\n        }\n\n        model.setVersion( nextVersion );\n\n        resolvedVersions.put( projectId, nextVersion );\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"private VersionInfo getVersionInfo(String version) {\n        // TODO: Provide a way to override the implementation of VersionInfo\n        try \n        {\n            return new DefaultVersionInfo( version );\n        } \n        catch (VersionParseException e)\n        {\n            return null;\n        }\n        \n    }","id":83063,"modified_method":"public VersionInfo getVersionInfo( String version ) {\n        // TODO: Provide a way to override the implementation of VersionInfo\n        try \n        {\n            return new DefaultVersionInfo( version );\n        } \n        catch ( VersionParseException e )\n        {\n            return null;\n        }\n        \n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"private ReleaseProgressTracker( Properties properties )\n    {\n        this.releaseProperties = properties;\n    }","id":83064,"modified_method":"private ReleaseProgressTracker( File propertiesFile, Properties properties )\n    {\n        this.releasePropertiesFile = propertiesFile;\n        this.releaseProperties = properties;\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"public static ReleaseProgressTracker loadOrCreate( String basedir )\n        throws IOException\n    {\n        ReleaseProgressTracker tracker;\n\n        if ( new File( basedir, RELEASE_PROPERTIES ).exists() )\n        {\n            tracker = load( basedir );\n        }\n        else\n        {\n            tracker = create();\n        }\n\n        return tracker;\n    }","id":83065,"modified_method":"public static ReleaseProgressTracker loadOrCreate( File basedir )\n        throws IOException\n    {\n        ReleaseProgressTracker tracker;\n\n        File releasePropertiesFile = new File( basedir, RELEASE_PROPERTIES );\n        if ( releasePropertiesFile.exists() )\n        {\n            tracker = doLoad( releasePropertiesFile );\n        }\n        else\n        {\n            tracker = create( releasePropertiesFile );\n        }\n\n        return tracker;\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void checkpoint( String basedir, String pointName )\n        throws IOException\n    {\n        setCheckpoint( pointName );\n\n        File releasePropertiesFile = new File( basedir, RELEASE_PROPERTIES );\n\n        FileOutputStream outStream = null;\n\n        try\n        {\n            outStream = new FileOutputStream( releasePropertiesFile );\n\n            releaseProperties.store( outStream, \"Generated by Release Plugin on: \" + new Date() );\n        }\n        finally\n        {\n            IOUtil.close( outStream );\n        }\n    }","id":83066,"modified_method":"public void checkpoint( String pointName )\n        throws IOException\n    {\n        setCheckpoint( pointName );\n\n        store();\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"public static ReleaseProgressTracker load( String basedir )\n        throws IOException\n    {\n        File releasePropertiesFile = new File( basedir, RELEASE_PROPERTIES );\n\n        InputStream inStream = null;\n\n        Properties rp;\n        try\n        {\n            inStream = new FileInputStream( releasePropertiesFile );\n\n            rp = new Properties();\n\n            rp.load( inStream );\n        }\n        finally\n        {\n            IOUtil.close( inStream );\n        }\n\n        return new ReleaseProgressTracker( rp );\n    }","id":83067,"modified_method":"public static ReleaseProgressTracker create( File releasePropertiesFile )\n    {\n        return new ReleaseProgressTracker( releasePropertiesFile, new Properties() );\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"private ScmRepository getScmRepository()\n        throws ScmException\n    {\n        ScmRepository repository;\n\n        try\n        {\n            repository = getScmManager().makeScmRepository( url );\n\n            if ( repository.getProvider().equals( \"svn\" ) )\n            {\n                SvnScmProviderRepository svnRepo = (SvnScmProviderRepository) repository.getProviderRepository();\n\n                if ( username != null && username.length() > 0 )\n                {\n                    svnRepo.setUser( username );\n                }\n                if ( password != null && password.length() > 0 )\n                {\n                    svnRepo.setPassword( password );\n                }\n                if ( tagBase != null && tagBase.length() > 0 )\n                {\n                    svnRepo.setTagBase( tagBase );\n                }\n            }\n            \n            if ( repository.getProvider().equals( \"starteam\" ) )\n            {\n                StarteamScmProviderRepository starteamRepo = (StarteamScmProviderRepository) repository.getProviderRepository();\n\n                if ( username != null && username.length() > 0 )\n                {\n                    starteamRepo.setUser( username );\n                }\n                if ( password != null && password.length() > 0 )\n                {\n                    starteamRepo.setPassword( password );\n                }\n            }\n            \n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"Can't load the scm provider.\", e );\n        }\n\n        return repository;\n    }","id":83068,"modified_method":"private ScmRepository getScmRepository()\n        throws ScmException\n    {\n        ScmRepository repository;\n\n        try\n        {\n            repository = getScmManager().makeScmRepository( url );\n\n            ScmProviderRepository scmRepo = repository.getProviderRepository();\n\n            if ( !StringUtils.isEmpty( username ) )\n            {\n                scmRepo.setUser( username );\n            }\n            if ( !StringUtils.isEmpty( password ) )\n            {\n                scmRepo.setPassword( password );\n            }\n\n            if ( repository.getProvider().equals( \"svn\" ) )\n            {\n                SvnScmProviderRepository svnRepo = (SvnScmProviderRepository) repository.getProviderRepository();\n\n                if ( tagBase != null && tagBase.length() > 0 )\n                {\n                    svnRepo.setTagBase( tagBase );\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            throw new ScmException( \"Can't load the scm provider.\", e );\n        }\n\n        return repository;\n    }","commit_id":"038c3d639d4cc51f3e4019a4603737ca45cb4a55","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void setAlarmCode(String alarmCode) {\n            m_alarmCode = alarmCode;\n        }","id":83069,"modified_method":"public void setAlarmCode(String alarmCode) {\n            m_alarmCode = alarmCode;   \n            \n            /* The highest alarm Severity is based on the AlarmCode. */        \n            if(m_alarmCode.equals(\"*C\"))\n                m_highestSeverity = \"Critical\";\n            else if(m_alarmCode.equals(\"**\"))\n                m_highestSeverity = \"Major\";\n            else if(m_alarmCode.equals(\"*\"))\n                m_highestSeverity = \"Minor\";\n            else if(m_alarmCode.equals(\"A\"))\n                m_highestSeverity = \"Cleared\";\n          \n        }","commit_id":"6baa6bccb5d9188014b39ee25f2d788306329477","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setAuotBlock(AutoBlock block) {\n        m_autoBlock = block;\n    }","id":83070,"modified_method":"public void setAutoBlock(AutoBlock block) {\n        m_autoBlock = block;\n    }","commit_id":"6baa6bccb5d9188014b39ee25f2d788306329477","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void processAutoBlock(StringTokenizer lineParser, Tl1AutonomousMessage message) {\n        boolean foundId = false;\n        while(!foundId ) {\n            while (lineParser.hasMoreElements() && !foundId) {\n                String line = (String) lineParser.nextElement();\n                if (line != null && !(line.equals(message.getTerminator()))) {\n                    foundId = true;\n                    message.getAutoBlock().setBlock(line.trim());\n                }\n            }\n        }\n    }","id":83071,"modified_method":"private void processAutoBlock(StringTokenizer lineParser, Tl1AutonomousMessage message) {\n        boolean foundId = false;\n        while(!foundId ) {\n            while (lineParser.hasMoreElements() && !foundId) {\n                String line = (String) lineParser.nextElement();\n                if (line != null && !(line.equals(message.getTerminator()))) {\n                    foundId = true;\n                    foundId = parseAutoBlock(line.trim(), message);\n                    //message.getAutoBlock().setBlock(line.trim());\n                }\n            }\n        }\n    }","commit_id":"6baa6bccb5d9188014b39ee25f2d788306329477","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void waitUntilNextConnectTime() {\n        if (m_started) {\n            if (m_sleeper == null) {\n                m_sleeper = new TimeoutSleeper();\n            }\n            try { m_sleeper.sleep(); } catch (InterruptedException e) { }\n        }\n    }","id":83072,"modified_method":"private void waitUntilNextConnectTime() {\n        long waitTime = m_reconnectionDelay;\n        m_log.debug(\"waitUntilNextConnectTime\");\n        if (m_started) {\n            if (m_sleeper == null) {\n                m_sleeper = new TimeoutSleeper();\n            }\n            m_reconnectTries++;\n            /* If the system is not responding, we want to wait longer and longer for the retry */\n            if(m_reconnectTries > 5)\n                waitTime = m_reconnectionDelay * 5;\n            else if (m_reconnectTries > 10)\n                waitTime = m_reconnectionDelay * 10;\n            m_log.info(\"Waiting \" + waitTime + \" ms......\");\n            try { m_sleeper.sleep(waitTime); } catch (InterruptedException e) {}\n        }\n    }","commit_id":"6baa6bccb5d9188014b39ee25f2d788306329477","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void start() {\n        m_log.info(\"Starting TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n        m_started = true;\n\n        m_socketReader = new Thread(\"TL1-Socket-Reader\") {\n\n            public void run() {\n                readMessages();\n            }\n\n        };\n\n        m_socketReader.start();\n        m_log.info(\"Started TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n    }","id":83073,"modified_method":"public void start() {\n        m_log.info(\"Starting: TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n        m_log.info(\"Start:Connection delay = \" + m_reconnectionDelay );\n        m_started = true;\n\n        m_socketReader = new Thread(\"TL1-Socket-Reader\") {\n\n            public void run() {\n                readMessages();\n            }\n\n        };\n\n        m_socketReader.start();\n        m_log.info(\"Started TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n    }","commit_id":"6baa6bccb5d9188014b39ee25f2d788306329477","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private BufferedReader createReader() {\n        BufferedReader reader;\n        while (m_started) {\n            try {\n                m_tl1Socket = new Socket(m_host, m_port);\n                reader = new BufferedReader(new InputStreamReader(m_tl1Socket.getInputStream()));\n                resetTimeout();\n                return reader;\n            } catch (IOException e) {\n                e.printStackTrace();\n                waitUntilNextConnectTime();\n            } \n        }\n        return null;\n    }","id":83074,"modified_method":"private BufferedReader createReader() {\n        BufferedReader reader;\n        while (m_started) {\n            try {\n                m_tl1Socket = new Socket(m_host, m_port);\n                reader = new BufferedReader(new InputStreamReader(m_tl1Socket.getInputStream()));\n                resetTimeout();\n                return reader;\n            } catch (IOException e) {\n                m_log.error(\"TL1 Connection Failed to \" + m_host + \":\" + m_port);\n                m_log.debug(e);\n                waitUntilNextConnectTime();\n            } \n        }\n        return null;\n    }","commit_id":"6baa6bccb5d9188014b39ee25f2d788306329477","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void resetTimeout() {\n        m_sleeper = null;\n    }","id":83075,"modified_method":"private void resetTimeout() {\n        m_log.debug(\"Resetting timeout Thread\");\n        m_reconnectTries = 0;\n        m_sleeper = null;\n    }","commit_id":"6baa6bccb5d9188014b39ee25f2d788306329477","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void onInit() {\n        log().info(\"onInit: Initializing Tl1d connections.\" );\n        m_tl1Queue = new LinkedBlockingQueue<Tl1AutonomousMessage>();\n    \n        //initialize a factory of configuration\n    \n        List<Tl1Element> configElements = m_configurationDao.getElements();\n    \n        m_tl1Clients = new ArrayList<Tl1Client>();\n        \n        for(Tl1Element element : configElements) {\n            try {\n                Tl1Client client = (Tl1Client) Class.forName(element.getTl1ClientApi()).newInstance();\n                client.setHost(element.getHost());\n                client.setPort(element.getPort());\n                client.setTl1Queue(m_tl1Queue);\n                client.setMessageProcessor((Tl1AutonomousMessageProcessor) Class.forName(element.getTl1MessageParser()).newInstance());\n                client.setLog(log());\n                m_tl1Clients.add(client);\n            } catch (InstantiationException e) {\n                log().error(\"onInit: could not instantiate specified class.\", e);\n            } catch (IllegalAccessException e) {\n                log().error(\"onInit: could not access specified class.\", e);\n            } catch (ClassNotFoundException e) {\n                log().error(\"onInit: could not find specified class.\", e);\n            }\n        }\n\n        log().info(\"onInit: Finished Initializing Tl1d connections.\");  \n    }","id":83076,"modified_method":"public synchronized void onInit() {\n        log().info(\"onInit: Initializing Tl1d connections.\" );\n        m_tl1Queue = new LinkedBlockingQueue<Tl1AutonomousMessage>();\n    \n        //initialize a factory of configuration\n    \n        List<Tl1Element> configElements = m_configurationDao.getElements();\n    \n        m_tl1Clients = new ArrayList<Tl1Client>();\n        \n        for(Tl1Element element : configElements) {\n            try {\n                Tl1Client client = (Tl1Client) Class.forName(element.getTl1ClientApi()).newInstance();\n                client.setHost(element.getHost());\n                client.setPort(element.getPort());\n                client.setTl1Queue(m_tl1Queue);\n                client.setMessageProcessor((Tl1AutonomousMessageProcessor) Class.forName(element.getTl1MessageParser()).newInstance());\n                client.setLog(log());\n                client.setReconnectionDelay(element.getReconnectDelay());\n                m_tl1Clients.add(client);\n            } catch (InstantiationException e) {\n                log().error(\"onInit: could not instantiate specified class.\", e);\n            } catch (IllegalAccessException e) {\n                log().error(\"onInit: could not access specified class.\", e);\n            } catch (ClassNotFoundException e) {\n                log().error(\"onInit: could not find specified class.\", e);\n            }\n        }\n\n        log().info(\"onInit: Finished Initializing Tl1d connections.\");  \n    }","commit_id":"6baa6bccb5d9188014b39ee25f2d788306329477","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void processMessage(Tl1AutonomousMessage message) {\n        log().debug(\"processMessage: Processing message: \"+message);\n\n        EventBuilder bldr = new EventBuilder(Tl1AutonomousMessage.UEI, \"Tl1d\");\n        bldr.setHost(message.getHost());\n        bldr.setTime(message.getTimestamp());\n        bldr.addParam(\"raw-message\", message.getRawMessage());\n        bldr.addParam(\"alarm-code\", message.getId().getAlarmCode());\n        bldr.addParam(\"atag\", message.getId().getAlarmTag());\n        bldr.addParam(\"verb\", message.getId().getVerb());\n        bldr.addParam(\"autoblock\", message.getAutoBlock().getBlock());\n        \n        m_eventManager.sendNow(bldr.getEvent());\n        log().debug(\"processMessage: Message processed: \"+message);\n    }","id":83077,"modified_method":"private void processMessage(Tl1AutonomousMessage message) {\n        log().debug(\"processMessage: Processing message: \"+message);\n\n        EventBuilder bldr = new EventBuilder(Tl1AutonomousMessage.UEI, \"Tl1d\");\n        bldr.setHost(message.getHost());\n        bldr.setInterface(message.getHost()); //interface is the IP\n        bldr.setService(\"TL-1\"); //Service it TL-1\n        bldr.setSeverity(message.getId().getHighestSeverity());\n        \n        bldr.setTime(message.getTimestamp());\n        bldr.addParam(\"raw-message\", message.getRawMessage());\n        bldr.addParam(\"alarm-code\", message.getId().getAlarmCode());\n        bldr.addParam(\"atag\", message.getId().getAlarmTag());\n        bldr.addParam(\"verb\", message.getId().getVerb());\n        bldr.addParam(\"autoblock\", message.getAutoBlock().getBlock());\n        bldr.addParam(\"aid\",message.getAutoBlock().getAid());\n        bldr.addParam(\"additionalParams\",message.getAutoBlock().getAdditionalParams());\n        \n        m_eventManager.sendNow(bldr.getEvent());\n        log().debug(\"processMessage: Message processed: \"+ message);\n    }","commit_id":"6baa6bccb5d9188014b39ee25f2d788306329477","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setAuotBlock(AutoBlock block) {\n        m_autoBlock = block;\n    }","id":83078,"modified_method":"public void setAutoBlock(AutoBlock block) {\n        m_autoBlock = block;\n    }","commit_id":"a8843f2b1b2febc2bd51f0a3f2555292137403c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setAlarmCode(String alarmCode) {\n            m_alarmCode = alarmCode;\n        }","id":83079,"modified_method":"public void setAlarmCode(String alarmCode) {\n            m_alarmCode = alarmCode;   \n            \n            /* The highest alarm Severity is based on the AlarmCode. */        \n            if(m_alarmCode.equals(\"*C\"))\n                m_highestSeverity = \"Critical\";\n            else if(m_alarmCode.equals(\"**\"))\n                m_highestSeverity = \"Major\";\n            else if(m_alarmCode.equals(\"*\"))\n                m_highestSeverity = \"Minor\";\n            else if(m_alarmCode.equals(\"A\"))\n                m_highestSeverity = \"Cleared\";\n          \n        }","commit_id":"a8843f2b1b2febc2bd51f0a3f2555292137403c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void processAutoBlock(StringTokenizer lineParser, Tl1AutonomousMessage message) {\n        boolean foundId = false;\n        while(!foundId ) {\n            while (lineParser.hasMoreElements() && !foundId) {\n                String line = (String) lineParser.nextElement();\n                if (line != null && !(line.equals(message.getTerminator()))) {\n                    foundId = true;\n                    message.getAutoBlock().setBlock(line.trim());\n                }\n            }\n        }\n    }","id":83080,"modified_method":"private void processAutoBlock(StringTokenizer lineParser, Tl1AutonomousMessage message) {\n        boolean foundId = false;\n        while(!foundId ) {\n            while (lineParser.hasMoreElements() && !foundId) {\n                String line = (String) lineParser.nextElement();\n                if (line != null && !(line.equals(message.getTerminator()))) {\n                    foundId = true;\n                    foundId = parseAutoBlock(line.trim(), message);\n                    //message.getAutoBlock().setBlock(line.trim());\n                }\n            }\n        }\n    }","commit_id":"a8843f2b1b2febc2bd51f0a3f2555292137403c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private BufferedReader createReader() {\n        BufferedReader reader;\n        while (m_started) {\n            try {\n                m_tl1Socket = new Socket(m_host, m_port);\n                reader = new BufferedReader(new InputStreamReader(m_tl1Socket.getInputStream()));\n                resetTimeout();\n                return reader;\n            } catch (IOException e) {\n                e.printStackTrace();\n                waitUntilNextConnectTime();\n            } \n        }\n        return null;\n    }","id":83081,"modified_method":"private BufferedReader createReader() {\n        BufferedReader reader;\n        while (m_started) {\n            try {\n                m_tl1Socket = new Socket(m_host, m_port);\n                reader = new BufferedReader(new InputStreamReader(m_tl1Socket.getInputStream()));\n                resetTimeout();\n                return reader;\n            } catch (IOException e) {\n                m_log.error(\"TL1 Connection Failed to \" + m_host + \":\" + m_port);\n                m_log.debug(e);\n                waitUntilNextConnectTime();\n            } \n        }\n        return null;\n    }","commit_id":"a8843f2b1b2febc2bd51f0a3f2555292137403c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void waitUntilNextConnectTime() {\n        if (m_started) {\n            if (m_sleeper == null) {\n                m_sleeper = new TimeoutSleeper();\n            }\n            try { m_sleeper.sleep(); } catch (InterruptedException e) { }\n        }\n    }","id":83082,"modified_method":"private void waitUntilNextConnectTime() {\n        long waitTime = m_reconnectionDelay;\n        m_log.debug(\"waitUntilNextConnectTime\");\n        if (m_started) {\n            if (m_sleeper == null) {\n                m_sleeper = new TimeoutSleeper();\n            }\n            m_reconnectTries++;\n            /* If the system is not responding, we want to wait longer and longer for the retry */\n            if(m_reconnectTries > 5)\n                waitTime = m_reconnectionDelay * 5;\n            else if (m_reconnectTries > 10)\n                waitTime = m_reconnectionDelay * 10;\n            m_log.info(\"Waiting \" + waitTime + \" ms......\");\n            try { m_sleeper.sleep(waitTime); } catch (InterruptedException e) {}\n        }\n    }","commit_id":"a8843f2b1b2febc2bd51f0a3f2555292137403c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void resetTimeout() {\n        m_sleeper = null;\n    }","id":83083,"modified_method":"private void resetTimeout() {\n        m_log.debug(\"Resetting timeout Thread\");\n        m_reconnectTries = 0;\n        m_sleeper = null;\n    }","commit_id":"a8843f2b1b2febc2bd51f0a3f2555292137403c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void start() {\n        m_log.info(\"Starting TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n        m_started = true;\n\n        m_socketReader = new Thread(\"TL1-Socket-Reader\") {\n\n            public void run() {\n                readMessages();\n            }\n\n        };\n\n        m_socketReader.start();\n        m_log.info(\"Started TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n    }","id":83084,"modified_method":"public void start() {\n        m_log.info(\"Starting: TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n        m_log.info(\"Start:Connection delay = \" + m_reconnectionDelay );\n        m_started = true;\n\n        m_socketReader = new Thread(\"TL1-Socket-Reader\") {\n\n            public void run() {\n                readMessages();\n            }\n\n        };\n\n        m_socketReader.start();\n        m_log.info(\"Started TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n    }","commit_id":"a8843f2b1b2febc2bd51f0a3f2555292137403c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void onInit() {\n        log().info(\"onInit: Initializing Tl1d connections.\" );\n        m_tl1Queue = new LinkedBlockingQueue<Tl1AutonomousMessage>();\n    \n        //initialize a factory of configuration\n    \n        List<Tl1Element> configElements = m_configurationDao.getElements();\n    \n        m_tl1Clients = new ArrayList<Tl1Client>();\n        \n        for(Tl1Element element : configElements) {\n            try {\n                Tl1Client client = (Tl1Client) Class.forName(element.getTl1ClientApi()).newInstance();\n                client.setHost(element.getHost());\n                client.setPort(element.getPort());\n                client.setTl1Queue(m_tl1Queue);\n                client.setMessageProcessor((Tl1AutonomousMessageProcessor) Class.forName(element.getTl1MessageParser()).newInstance());\n                client.setLog(log());\n                m_tl1Clients.add(client);\n            } catch (InstantiationException e) {\n                log().error(\"onInit: could not instantiate specified class.\", e);\n            } catch (IllegalAccessException e) {\n                log().error(\"onInit: could not access specified class.\", e);\n            } catch (ClassNotFoundException e) {\n                log().error(\"onInit: could not find specified class.\", e);\n            }\n        }\n\n        log().info(\"onInit: Finished Initializing Tl1d connections.\");  \n    }","id":83085,"modified_method":"public synchronized void onInit() {\n        log().info(\"onInit: Initializing Tl1d connections.\" );\n        m_tl1Queue = new LinkedBlockingQueue<Tl1AutonomousMessage>();\n    \n        //initialize a factory of configuration\n    \n        List<Tl1Element> configElements = m_configurationDao.getElements();\n    \n        m_tl1Clients = new ArrayList<Tl1Client>();\n        \n        for(Tl1Element element : configElements) {\n            try {\n                Tl1Client client = (Tl1Client) Class.forName(element.getTl1ClientApi()).newInstance();\n                client.setHost(element.getHost());\n                client.setPort(element.getPort());\n                client.setTl1Queue(m_tl1Queue);\n                client.setMessageProcessor((Tl1AutonomousMessageProcessor) Class.forName(element.getTl1MessageParser()).newInstance());\n                client.setLog(log());\n                client.setReconnectionDelay(element.getReconnectDelay());\n                m_tl1Clients.add(client);\n            } catch (InstantiationException e) {\n                log().error(\"onInit: could not instantiate specified class.\", e);\n            } catch (IllegalAccessException e) {\n                log().error(\"onInit: could not access specified class.\", e);\n            } catch (ClassNotFoundException e) {\n                log().error(\"onInit: could not find specified class.\", e);\n            }\n        }\n\n        log().info(\"onInit: Finished Initializing Tl1d connections.\");  \n    }","commit_id":"a8843f2b1b2febc2bd51f0a3f2555292137403c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void processMessage(Tl1AutonomousMessage message) {\n        log().debug(\"processMessage: Processing message: \"+message);\n\n        EventBuilder bldr = new EventBuilder(Tl1AutonomousMessage.UEI, \"Tl1d\");\n        bldr.setHost(message.getHost());\n        bldr.setTime(message.getTimestamp());\n        bldr.addParam(\"raw-message\", message.getRawMessage());\n        bldr.addParam(\"alarm-code\", message.getId().getAlarmCode());\n        bldr.addParam(\"atag\", message.getId().getAlarmTag());\n        bldr.addParam(\"verb\", message.getId().getVerb());\n        bldr.addParam(\"autoblock\", message.getAutoBlock().getBlock());\n        \n        m_eventManager.sendNow(bldr.getEvent());\n        log().debug(\"processMessage: Message processed: \"+message);\n    }","id":83086,"modified_method":"private void processMessage(Tl1AutonomousMessage message) {\n        log().debug(\"processMessage: Processing message: \"+message);\n\n        EventBuilder bldr = new EventBuilder(Tl1AutonomousMessage.UEI, \"Tl1d\");\n        bldr.setHost(message.getHost());\n        bldr.setInterface(message.getHost()); //interface is the IP\n        bldr.setService(\"TL-1\"); //Service it TL-1\n        bldr.setSeverity(message.getId().getHighestSeverity());\n        \n        bldr.setTime(message.getTimestamp());\n        bldr.addParam(\"raw-message\", message.getRawMessage());\n        bldr.addParam(\"alarm-code\", message.getId().getAlarmCode());\n        bldr.addParam(\"atag\", message.getId().getAlarmTag());\n        bldr.addParam(\"verb\", message.getId().getVerb());\n        bldr.addParam(\"autoblock\", message.getAutoBlock().getBlock());\n        bldr.addParam(\"aid\",message.getAutoBlock().getAid());\n        bldr.addParam(\"additionalParams\",message.getAutoBlock().getAdditionalParams());\n        \n        m_eventManager.sendNow(bldr.getEvent());\n        log().debug(\"processMessage: Message processed: \"+ message);\n    }","commit_id":"a8843f2b1b2febc2bd51f0a3f2555292137403c3","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setAuotBlock(AutoBlock block) {\n        m_autoBlock = block;\n    }","id":83087,"modified_method":"public void setAutoBlock(AutoBlock block) {\n        m_autoBlock = block;\n    }","commit_id":"4f596ac822220c7fda4d69011d6e111130c1095f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void setAlarmCode(String alarmCode) {\n            m_alarmCode = alarmCode;\n        }","id":83088,"modified_method":"public void setAlarmCode(String alarmCode) {\n            m_alarmCode = alarmCode;   \n            \n            /* The highest alarm Severity is based on the AlarmCode. */        \n            if(m_alarmCode.equals(\"*C\"))\n                m_highestSeverity = \"Critical\";\n            else if(m_alarmCode.equals(\"**\"))\n                m_highestSeverity = \"Major\";\n            else if(m_alarmCode.equals(\"*\"))\n                m_highestSeverity = \"Minor\";\n            else if(m_alarmCode.equals(\"A\"))\n                m_highestSeverity = \"Cleared\";\n          \n        }","commit_id":"4f596ac822220c7fda4d69011d6e111130c1095f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void processAutoBlock(StringTokenizer lineParser, Tl1AutonomousMessage message) {\n        boolean foundId = false;\n        while(!foundId ) {\n            while (lineParser.hasMoreElements() && !foundId) {\n                String line = (String) lineParser.nextElement();\n                if (line != null && !(line.equals(message.getTerminator()))) {\n                    foundId = true;\n                    message.getAutoBlock().setBlock(line.trim());\n                }\n            }\n        }\n    }","id":83089,"modified_method":"private void processAutoBlock(StringTokenizer lineParser, Tl1AutonomousMessage message) {\n        boolean foundId = false;\n        while(!foundId ) {\n            while (lineParser.hasMoreElements() && !foundId) {\n                String line = (String) lineParser.nextElement();\n                if (line != null && !(line.equals(message.getTerminator()))) {\n                    foundId = true;\n                    foundId = parseAutoBlock(line.trim(), message);\n                    //message.getAutoBlock().setBlock(line.trim());\n                }\n            }\n        }\n    }","commit_id":"4f596ac822220c7fda4d69011d6e111130c1095f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void resetTimeout() {\n        m_sleeper = null;\n    }","id":83090,"modified_method":"private void resetTimeout() {\n        m_log.debug(\"Resetting timeout Thread\");\n        m_reconnectTries = 0;\n        m_sleeper = null;\n    }","commit_id":"4f596ac822220c7fda4d69011d6e111130c1095f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void waitUntilNextConnectTime() {\n        if (m_started) {\n            if (m_sleeper == null) {\n                m_sleeper = new TimeoutSleeper();\n            }\n            try { m_sleeper.sleep(); } catch (InterruptedException e) { }\n        }\n    }","id":83091,"modified_method":"private void waitUntilNextConnectTime() {\n        long waitTime = m_reconnectionDelay;\n        m_log.debug(\"waitUntilNextConnectTime\");\n        if (m_started) {\n            if (m_sleeper == null) {\n                m_sleeper = new TimeoutSleeper();\n            }\n            m_reconnectTries++;\n            /* If the system is not responding, we want to wait longer and longer for the retry */\n            if(m_reconnectTries > 5)\n                waitTime = m_reconnectionDelay * 5;\n            else if (m_reconnectTries > 10)\n                waitTime = m_reconnectionDelay * 10;\n            m_log.info(\"Waiting \" + waitTime + \" ms......\");\n            try { m_sleeper.sleep(waitTime); } catch (InterruptedException e) {}\n        }\n    }","commit_id":"4f596ac822220c7fda4d69011d6e111130c1095f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private BufferedReader createReader() {\n        BufferedReader reader;\n        while (m_started) {\n            try {\n                m_tl1Socket = new Socket(m_host, m_port);\n                reader = new BufferedReader(new InputStreamReader(m_tl1Socket.getInputStream()));\n                resetTimeout();\n                return reader;\n            } catch (IOException e) {\n                e.printStackTrace();\n                waitUntilNextConnectTime();\n            } \n        }\n        return null;\n    }","id":83092,"modified_method":"private BufferedReader createReader() {\n        BufferedReader reader;\n        while (m_started) {\n            try {\n                m_tl1Socket = new Socket(m_host, m_port);\n                reader = new BufferedReader(new InputStreamReader(m_tl1Socket.getInputStream()));\n                resetTimeout();\n                return reader;\n            } catch (IOException e) {\n                m_log.error(\"TL1 Connection Failed to \" + m_host + \":\" + m_port);\n                m_log.debug(e);\n                waitUntilNextConnectTime();\n            } \n        }\n        return null;\n    }","commit_id":"4f596ac822220c7fda4d69011d6e111130c1095f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void start() {\n        m_log.info(\"Starting TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n        m_started = true;\n\n        m_socketReader = new Thread(\"TL1-Socket-Reader\") {\n\n            public void run() {\n                readMessages();\n            }\n\n        };\n\n        m_socketReader.start();\n        m_log.info(\"Started TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n    }","id":83093,"modified_method":"public void start() {\n        m_log.info(\"Starting: TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n        m_log.info(\"Start:Connection delay = \" + m_reconnectionDelay );\n        m_started = true;\n\n        m_socketReader = new Thread(\"TL1-Socket-Reader\") {\n\n            public void run() {\n                readMessages();\n            }\n\n        };\n\n        m_socketReader.start();\n        m_log.info(\"Started TL1 client: \"+m_host+\":\"+String.valueOf(m_port));\n    }","commit_id":"4f596ac822220c7fda4d69011d6e111130c1095f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void onInit() {\n        log().info(\"onInit: Initializing Tl1d connections.\" );\n        m_tl1Queue = new LinkedBlockingQueue<Tl1AutonomousMessage>();\n    \n        //initialize a factory of configuration\n    \n        List<Tl1Element> configElements = m_configurationDao.getElements();\n    \n        m_tl1Clients = new ArrayList<Tl1Client>();\n        \n        for(Tl1Element element : configElements) {\n            try {\n                Tl1Client client = (Tl1Client) Class.forName(element.getTl1ClientApi()).newInstance();\n                client.setHost(element.getHost());\n                client.setPort(element.getPort());\n                client.setTl1Queue(m_tl1Queue);\n                client.setMessageProcessor((Tl1AutonomousMessageProcessor) Class.forName(element.getTl1MessageParser()).newInstance());\n                client.setLog(log());\n                m_tl1Clients.add(client);\n            } catch (InstantiationException e) {\n                log().error(\"onInit: could not instantiate specified class.\", e);\n            } catch (IllegalAccessException e) {\n                log().error(\"onInit: could not access specified class.\", e);\n            } catch (ClassNotFoundException e) {\n                log().error(\"onInit: could not find specified class.\", e);\n            }\n        }\n\n        log().info(\"onInit: Finished Initializing Tl1d connections.\");  \n    }","id":83094,"modified_method":"public synchronized void onInit() {\n        log().info(\"onInit: Initializing Tl1d connections.\" );\n        m_tl1Queue = new LinkedBlockingQueue<Tl1AutonomousMessage>();\n    \n        //initialize a factory of configuration\n    \n        List<Tl1Element> configElements = m_configurationDao.getElements();\n    \n        m_tl1Clients = new ArrayList<Tl1Client>();\n        \n        for(Tl1Element element : configElements) {\n            try {\n                Tl1Client client = (Tl1Client) Class.forName(element.getTl1ClientApi()).newInstance();\n                client.setHost(element.getHost());\n                client.setPort(element.getPort());\n                client.setTl1Queue(m_tl1Queue);\n                client.setMessageProcessor((Tl1AutonomousMessageProcessor) Class.forName(element.getTl1MessageParser()).newInstance());\n                client.setLog(log());\n                client.setReconnectionDelay(element.getReconnectDelay());\n                m_tl1Clients.add(client);\n            } catch (InstantiationException e) {\n                log().error(\"onInit: could not instantiate specified class.\", e);\n            } catch (IllegalAccessException e) {\n                log().error(\"onInit: could not access specified class.\", e);\n            } catch (ClassNotFoundException e) {\n                log().error(\"onInit: could not find specified class.\", e);\n            }\n        }\n\n        log().info(\"onInit: Finished Initializing Tl1d connections.\");  \n    }","commit_id":"4f596ac822220c7fda4d69011d6e111130c1095f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void processMessage(Tl1AutonomousMessage message) {\n        log().debug(\"processMessage: Processing message: \"+message);\n\n        EventBuilder bldr = new EventBuilder(Tl1AutonomousMessage.UEI, \"Tl1d\");\n        bldr.setHost(message.getHost());\n        bldr.setTime(message.getTimestamp());\n        bldr.addParam(\"raw-message\", message.getRawMessage());\n        bldr.addParam(\"alarm-code\", message.getId().getAlarmCode());\n        bldr.addParam(\"atag\", message.getId().getAlarmTag());\n        bldr.addParam(\"verb\", message.getId().getVerb());\n        bldr.addParam(\"autoblock\", message.getAutoBlock().getBlock());\n        \n        m_eventManager.sendNow(bldr.getEvent());\n        log().debug(\"processMessage: Message processed: \"+message);\n    }","id":83095,"modified_method":"private void processMessage(Tl1AutonomousMessage message) {\n        log().debug(\"processMessage: Processing message: \"+message);\n\n        EventBuilder bldr = new EventBuilder(Tl1AutonomousMessage.UEI, \"Tl1d\");\n        bldr.setHost(message.getHost());\n        bldr.setInterface(message.getHost()); //interface is the IP\n        bldr.setService(\"TL-1\"); //Service it TL-1\n        bldr.setSeverity(message.getId().getHighestSeverity());\n        \n        bldr.setTime(message.getTimestamp());\n        bldr.addParam(\"raw-message\", message.getRawMessage());\n        bldr.addParam(\"alarm-code\", message.getId().getAlarmCode());\n        bldr.addParam(\"atag\", message.getId().getAlarmTag());\n        bldr.addParam(\"verb\", message.getId().getVerb());\n        bldr.addParam(\"autoblock\", message.getAutoBlock().getBlock());\n        bldr.addParam(\"aid\",message.getAutoBlock().getAid());\n        bldr.addParam(\"additionalParams\",message.getAutoBlock().getAdditionalParams());\n        \n        m_eventManager.sendNow(bldr.getEvent());\n        log().debug(\"processMessage: Message processed: \"+ message);\n    }","commit_id":"4f596ac822220c7fda4d69011d6e111130c1095f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private boolean forceEvict(BlockCacheKey cacheKey) {\n    if (!cacheEnabled) {\n      return false;\n    }\n    RAMQueueEntry removedBlock = checkRamCache(cacheKey);\n    BucketEntry bucketEntry = backingMap.get(cacheKey);\n    if (bucketEntry == null) {\n      if (removedBlock != null) {\n        cacheStats.evicted(0, cacheKey.isPrimary());\n        return true;\n      } else {\n        return false;\n      }\n    }\n    IdLock.Entry lockEntry = null;\n    try {\n      lockEntry = offsetLock.getLockEntry(bucketEntry.offset());\n      if (backingMap.remove(cacheKey, bucketEntry)) {\n        blockEvicted(cacheKey, bucketEntry, removedBlock == null);\n      } else {\n        return false;\n      }\n    } catch (IOException ie) {\n      LOG.warn(\"Failed evicting block \" + cacheKey);\n      return false;\n    } finally {\n      if (lockEntry != null) {\n        offsetLock.releaseLockEntry(lockEntry);\n      }\n    }\n    cacheStats.evicted(bucketEntry.getCachedTime(), cacheKey.isPrimary());\n    return true;\n  }","id":83096,"modified_method":"private boolean forceEvict(BlockCacheKey cacheKey) {\n    if (!cacheEnabled) {\n      return false;\n    }\n    RAMQueueEntry removedBlock = checkRamCache(cacheKey);\n    BucketEntry bucketEntry = backingMap.get(cacheKey);\n    if (bucketEntry == null) {\n      if (removedBlock != null) {\n        cacheStats.evicted(0, cacheKey.isPrimary());\n        return true;\n      } else {\n        return false;\n      }\n    }\n    ReentrantReadWriteLock lock = offsetLock.getLock(bucketEntry.offset());\n    try {\n      lock.writeLock().lock();\n      if (backingMap.remove(cacheKey, bucketEntry)) {\n        blockEvicted(cacheKey, bucketEntry, removedBlock == null);\n      } else {\n        return false;\n      }\n    } finally {\n      lock.writeLock().unlock();\n    }\n    cacheStats.evicted(bucketEntry.getCachedTime(), cacheKey.isPrimary());\n    return true;\n  }","commit_id":"263a0adf79105b9dc166e21c3f5159ade6e2d0a7","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * Flush the entries in ramCache to IOEngine and add bucket entry to backingMap.\n     * Process all that are passed in even if failure being sure to remove from ramCache else we'll\n     * never undo the references and we'll OOME.\n     * @param entries Presumes list passed in here will be processed by this invocation only. No\n     * interference expected.\n     * @throws InterruptedException\n     */\n    @VisibleForTesting\n    void doDrain(final List<RAMQueueEntry> entries) throws InterruptedException {\n      if (entries.isEmpty()) {\n        return;\n      }\n      // This method is a little hard to follow. We run through the passed in entries and for each\n      // successful add, we add a non-null BucketEntry to the below bucketEntries.  Later we must\n      // do cleanup making sure we've cleared ramCache of all entries regardless of whether we\n      // successfully added the item to the bucketcache; if we don't do the cleanup, we'll OOME by\n      // filling ramCache.  We do the clean up by again running through the passed in entries\n      // doing extra work when we find a non-null bucketEntries corresponding entry.\n      final int size = entries.size();\n      BucketEntry[] bucketEntries = new BucketEntry[size];\n      // Index updated inside loop if success or if we can't succeed. We retry if cache is full\n      // when we go to add an entry by going around the loop again without upping the index.\n      int index = 0;\n      while (cacheEnabled && index < size) {\n        RAMQueueEntry re = null;\n        try {\n          re = entries.get(index);\n          if (re == null) {\n            LOG.warn(\"Couldn't get entry or changed on us; who else is messing with it?\");\n            index++;\n            continue;\n          }\n          BucketEntry bucketEntry =\n            re.writeToCache(ioEngine, bucketAllocator, deserialiserMap, realCacheSize);\n          // Successfully added.  Up index and add bucketEntry. Clear io exceptions.\n          bucketEntries[index] = bucketEntry;\n          if (ioErrorStartTime > 0) {\n            ioErrorStartTime = -1;\n          }\n          index++;\n        } catch (BucketAllocatorException fle) {\n          LOG.warn(\"Failed allocation for \" + (re == null ? \"\" : re.getKey()) + \"; \" + fle);\n          // Presume can't add. Too big? Move index on. Entry will be cleared from ramCache below.\n          bucketEntries[index] = null;\n          index++;\n        } catch (CacheFullException cfe) {\n          // Cache full when we tried to add. Try freeing space and then retrying (don't up index)\n          if (!freeInProgress) {\n            freeSpace(\"Full!\");\n          } else {\n            Thread.sleep(50);\n          }\n        } catch (IOException ioex) {\n          // Hopefully transient. Retry. checkIOErrorIsTolerated disables cache if problem.\n          LOG.error(\"Failed writing to bucket cache\", ioex);\n          checkIOErrorIsTolerated();\n        }\n      }\n\n      // Make sure data pages are written are on media before we update maps.\n      try {\n        ioEngine.sync();\n      } catch (IOException ioex) {\n        LOG.error(\"Failed syncing IO engine\", ioex);\n        checkIOErrorIsTolerated();\n        // Since we failed sync, free the blocks in bucket allocator\n        for (int i = 0; i < entries.size(); ++i) {\n          if (bucketEntries[i] != null) {\n            bucketAllocator.freeBlock(bucketEntries[i].offset());\n            bucketEntries[i] = null;\n          }\n        }\n      }\n\n      // Now add to backingMap if successfully added to bucket cache.  Remove from ramCache if\n      // success or error.\n      for (int i = 0; i < size; ++i) {\n        BlockCacheKey key = entries.get(i).getKey();\n        // Only add if non-null entry.\n        if (bucketEntries[i] != null) {\n          backingMap.put(key, bucketEntries[i]);\n        }\n        // Always remove from ramCache even if we failed adding it to the block cache above.\n        RAMQueueEntry ramCacheEntry = ramCache.remove(key);\n        if (ramCacheEntry != null) {\n          heapSize.addAndGet(-1 * entries.get(i).getData().heapSize());\n        } else if (bucketEntries[i] != null){\n          // Block should have already been evicted. Remove it and free space.\n          IdLock.Entry lockEntry = null;\n          try {\n            lockEntry = offsetLock.getLockEntry(bucketEntries[i].offset());\n            if (backingMap.remove(key, bucketEntries[i])) {\n              blockEvicted(key, bucketEntries[i], false);\n            }\n          } catch (IOException e) {\n            LOG.warn(\"failed to free space for \" + key, e);\n          } finally {\n            if (lockEntry != null) {\n              offsetLock.releaseLockEntry(lockEntry);\n            }\n          }\n        }\n      }\n\n      long used = bucketAllocator.getUsedSize();\n      if (used > acceptableSize()) {\n        freeSpace(\"Used=\" + used + \" > acceptable=\" + acceptableSize());\n      }\n      return;\n    }","id":83097,"modified_method":"/**\n     * Flush the entries in ramCache to IOEngine and add bucket entry to backingMap.\n     * Process all that are passed in even if failure being sure to remove from ramCache else we'll\n     * never undo the references and we'll OOME.\n     * @param entries Presumes list passed in here will be processed by this invocation only. No\n     * interference expected.\n     * @throws InterruptedException\n     */\n    @VisibleForTesting\n    void doDrain(final List<RAMQueueEntry> entries) throws InterruptedException {\n      if (entries.isEmpty()) {\n        return;\n      }\n      // This method is a little hard to follow. We run through the passed in entries and for each\n      // successful add, we add a non-null BucketEntry to the below bucketEntries.  Later we must\n      // do cleanup making sure we've cleared ramCache of all entries regardless of whether we\n      // successfully added the item to the bucketcache; if we don't do the cleanup, we'll OOME by\n      // filling ramCache.  We do the clean up by again running through the passed in entries\n      // doing extra work when we find a non-null bucketEntries corresponding entry.\n      final int size = entries.size();\n      BucketEntry[] bucketEntries = new BucketEntry[size];\n      // Index updated inside loop if success or if we can't succeed. We retry if cache is full\n      // when we go to add an entry by going around the loop again without upping the index.\n      int index = 0;\n      while (cacheEnabled && index < size) {\n        RAMQueueEntry re = null;\n        try {\n          re = entries.get(index);\n          if (re == null) {\n            LOG.warn(\"Couldn't get entry or changed on us; who else is messing with it?\");\n            index++;\n            continue;\n          }\n          BucketEntry bucketEntry =\n            re.writeToCache(ioEngine, bucketAllocator, deserialiserMap, realCacheSize);\n          // Successfully added.  Up index and add bucketEntry. Clear io exceptions.\n          bucketEntries[index] = bucketEntry;\n          if (ioErrorStartTime > 0) {\n            ioErrorStartTime = -1;\n          }\n          index++;\n        } catch (BucketAllocatorException fle) {\n          LOG.warn(\"Failed allocation for \" + (re == null ? \"\" : re.getKey()) + \"; \" + fle);\n          // Presume can't add. Too big? Move index on. Entry will be cleared from ramCache below.\n          bucketEntries[index] = null;\n          index++;\n        } catch (CacheFullException cfe) {\n          // Cache full when we tried to add. Try freeing space and then retrying (don't up index)\n          if (!freeInProgress) {\n            freeSpace(\"Full!\");\n          } else {\n            Thread.sleep(50);\n          }\n        } catch (IOException ioex) {\n          // Hopefully transient. Retry. checkIOErrorIsTolerated disables cache if problem.\n          LOG.error(\"Failed writing to bucket cache\", ioex);\n          checkIOErrorIsTolerated();\n        }\n      }\n\n      // Make sure data pages are written are on media before we update maps.\n      try {\n        ioEngine.sync();\n      } catch (IOException ioex) {\n        LOG.error(\"Failed syncing IO engine\", ioex);\n        checkIOErrorIsTolerated();\n        // Since we failed sync, free the blocks in bucket allocator\n        for (int i = 0; i < entries.size(); ++i) {\n          if (bucketEntries[i] != null) {\n            bucketAllocator.freeBlock(bucketEntries[i].offset());\n            bucketEntries[i] = null;\n          }\n        }\n      }\n\n      // Now add to backingMap if successfully added to bucket cache.  Remove from ramCache if\n      // success or error.\n      for (int i = 0; i < size; ++i) {\n        BlockCacheKey key = entries.get(i).getKey();\n        // Only add if non-null entry.\n        if (bucketEntries[i] != null) {\n          backingMap.put(key, bucketEntries[i]);\n        }\n        // Always remove from ramCache even if we failed adding it to the block cache above.\n        RAMQueueEntry ramCacheEntry = ramCache.remove(key);\n        if (ramCacheEntry != null) {\n          heapSize.addAndGet(-1 * entries.get(i).getData().heapSize());\n        } else if (bucketEntries[i] != null){\n          // Block should have already been evicted. Remove it and free space.\n          ReentrantReadWriteLock lock = offsetLock.getLock(bucketEntries[i].offset());\n          try {\n            lock.writeLock().lock();\n            if (backingMap.remove(key, bucketEntries[i])) {\n              blockEvicted(key, bucketEntries[i], false);\n            }\n          } finally {\n            lock.writeLock().unlock();\n          }\n        }\n      }\n\n      long used = bucketAllocator.getUsedSize();\n      if (used > acceptableSize()) {\n        freeSpace(\"Used=\" + used + \" > acceptable=\" + acceptableSize());\n      }\n      return;\n    }","commit_id":"263a0adf79105b9dc166e21c3f5159ade6e2d0a7","url":"https://github.com/apache/hbase"},{"original_method":"public boolean evictBlock(BlockCacheKey cacheKey, boolean deletedBlock) {\n    if (!cacheEnabled) {\n      return false;\n    }\n    RAMQueueEntry removedBlock = checkRamCache(cacheKey);\n    BucketEntry bucketEntry = backingMap.get(cacheKey);\n    if (bucketEntry == null) {\n      if (removedBlock != null) {\n        cacheStats.evicted(0, cacheKey.isPrimary());\n        return true;\n      } else {\n        return false;\n      }\n    }\n    IdLock.Entry lockEntry = null;\n    try {\n      lockEntry = offsetLock.getLockEntry(bucketEntry.offset());\n      int refCount = bucketEntry.refCount.get();\n      if(refCount == 0) {\n        if (backingMap.remove(cacheKey, bucketEntry)) {\n          blockEvicted(cacheKey, bucketEntry, removedBlock == null);\n        } else {\n          return false;\n        }\n      } else {\n        if(!deletedBlock) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"This block \" + cacheKey + \" is still referred by \" + refCount\n                + \" readers. Can not be freed now\");\n          }\n          return false;\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"This block \" + cacheKey + \" is still referred by \" + refCount\n                + \" readers. Can not be freed now. Hence will mark this\"\n                + \" for evicting at a later point\");\n          }\n          bucketEntry.markedForEvict = true;\n        }\n      }\n    } catch (IOException ie) {\n      LOG.warn(\"Failed evicting block \" + cacheKey);\n      return false;\n    } finally {\n      if (lockEntry != null) {\n        offsetLock.releaseLockEntry(lockEntry);\n      }\n    }\n    cacheStats.evicted(bucketEntry.getCachedTime(), cacheKey.isPrimary());\n    return true;\n  }","id":83098,"modified_method":"public boolean evictBlock(BlockCacheKey cacheKey, boolean deletedBlock) {\n    if (!cacheEnabled) {\n      return false;\n    }\n    RAMQueueEntry removedBlock = checkRamCache(cacheKey);\n    BucketEntry bucketEntry = backingMap.get(cacheKey);\n    if (bucketEntry == null) {\n      if (removedBlock != null) {\n        cacheStats.evicted(0, cacheKey.isPrimary());\n        return true;\n      } else {\n        return false;\n      }\n    }\n    ReentrantReadWriteLock lock = offsetLock.getLock(bucketEntry.offset());\n    try {\n      lock.writeLock().lock();\n      int refCount = bucketEntry.refCount.get();\n      if(refCount == 0) {\n        if (backingMap.remove(cacheKey, bucketEntry)) {\n          blockEvicted(cacheKey, bucketEntry, removedBlock == null);\n        } else {\n          return false;\n        }\n      } else {\n        if(!deletedBlock) {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"This block \" + cacheKey + \" is still referred by \" + refCount\n                + \" readers. Can not be freed now\");\n          }\n          return false;\n        } else {\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"This block \" + cacheKey + \" is still referred by \" + refCount\n                + \" readers. Can not be freed now. Hence will mark this\"\n                + \" for evicting at a later point\");\n          }\n          bucketEntry.markedForEvict = true;\n        }\n      }\n    } finally {\n      lock.writeLock().unlock();\n    }\n    cacheStats.evicted(bucketEntry.getCachedTime(), cacheKey.isPrimary());\n    return true;\n  }","commit_id":"263a0adf79105b9dc166e21c3f5159ade6e2d0a7","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Get the buffer of the block with the specified key.\n   * @param key block's cache key\n   * @param caching true if the caller caches blocks on cache misses\n   * @param repeat Whether this is a repeat lookup for the same block\n   * @param updateCacheMetrics Whether we should update cache metrics or not\n   * @return buffer of specified cache key, or null if not in cache\n   */\n  @Override\n  public Cacheable getBlock(BlockCacheKey key, boolean caching, boolean repeat,\n      boolean updateCacheMetrics) {\n    if (!cacheEnabled) {\n      return null;\n    }\n    RAMQueueEntry re = ramCache.get(key);\n    if (re != null) {\n      if (updateCacheMetrics) {\n        cacheStats.hit(caching, key.isPrimary());\n      }\n      re.access(accessCount.incrementAndGet());\n      return re.getData();\n    }\n    BucketEntry bucketEntry = backingMap.get(key);\n    if (bucketEntry != null) {\n      long start = System.nanoTime();\n      IdLock.Entry lockEntry = null;\n      try {\n        lockEntry = offsetLock.getLockEntry(bucketEntry.offset());\n        // We can not read here even if backingMap does contain the given key because its offset\n        // maybe changed. If we lock BlockCacheKey instead of offset, then we can only check\n        // existence here.\n        if (bucketEntry.equals(backingMap.get(key))) {\n          // TODO : change this area - should be removed after server cells and\n          // 12295 are available\n          int len = bucketEntry.getLength();\n          Cacheable cachedBlock = ioEngine.read(bucketEntry.offset(), len,\n              bucketEntry.deserializerReference(this.deserialiserMap));\n          long timeTaken = System.nanoTime() - start;\n          if (updateCacheMetrics) {\n            cacheStats.hit(caching, key.isPrimary());\n            cacheStats.ioHit(timeTaken);\n          }\n          if (cachedBlock.getMemoryType() == MemoryType.SHARED) {\n            bucketEntry.refCount.incrementAndGet();\n          }\n          bucketEntry.access(accessCount.incrementAndGet());\n          if (this.ioErrorStartTime > 0) {\n            ioErrorStartTime = -1;\n          }\n          return cachedBlock;\n        }\n      } catch (IOException ioex) {\n        LOG.error(\"Failed reading block \" + key + \" from bucket cache\", ioex);\n        checkIOErrorIsTolerated();\n      } finally {\n        if (lockEntry != null) {\n          offsetLock.releaseLockEntry(lockEntry);\n        }\n      }\n    }\n    if (!repeat && updateCacheMetrics) {\n      cacheStats.miss(caching, key.isPrimary());\n    }\n    return null;\n  }","id":83099,"modified_method":"/**\n   * Get the buffer of the block with the specified key.\n   * @param key block's cache key\n   * @param caching true if the caller caches blocks on cache misses\n   * @param repeat Whether this is a repeat lookup for the same block\n   * @param updateCacheMetrics Whether we should update cache metrics or not\n   * @return buffer of specified cache key, or null if not in cache\n   */\n  @Override\n  public Cacheable getBlock(BlockCacheKey key, boolean caching, boolean repeat,\n      boolean updateCacheMetrics) {\n    if (!cacheEnabled) {\n      return null;\n    }\n    RAMQueueEntry re = ramCache.get(key);\n    if (re != null) {\n      if (updateCacheMetrics) {\n        cacheStats.hit(caching, key.isPrimary());\n      }\n      re.access(accessCount.incrementAndGet());\n      return re.getData();\n    }\n    BucketEntry bucketEntry = backingMap.get(key);\n    if (bucketEntry != null) {\n      long start = System.nanoTime();\n      ReentrantReadWriteLock lock = offsetLock.getLock(bucketEntry.offset());\n      try {\n        lock.readLock().lock();\n        // We can not read here even if backingMap does contain the given key because its offset\n        // maybe changed. If we lock BlockCacheKey instead of offset, then we can only check\n        // existence here.\n        if (bucketEntry.equals(backingMap.get(key))) {\n          // TODO : change this area - should be removed after server cells and\n          // 12295 are available\n          int len = bucketEntry.getLength();\n          Cacheable cachedBlock = ioEngine.read(bucketEntry.offset(), len,\n              bucketEntry.deserializerReference(this.deserialiserMap));\n          long timeTaken = System.nanoTime() - start;\n          if (updateCacheMetrics) {\n            cacheStats.hit(caching, key.isPrimary());\n            cacheStats.ioHit(timeTaken);\n          }\n          if (cachedBlock.getMemoryType() == MemoryType.SHARED) {\n            bucketEntry.refCount.incrementAndGet();\n          }\n          bucketEntry.access(accessCount.incrementAndGet());\n          if (this.ioErrorStartTime > 0) {\n            ioErrorStartTime = -1;\n          }\n          return cachedBlock;\n        }\n      } catch (IOException ioex) {\n        LOG.error(\"Failed reading block \" + key + \" from bucket cache\", ioex);\n        checkIOErrorIsTolerated();\n      } finally {\n        lock.readLock().unlock();\n      }\n    }\n    if (!repeat && updateCacheMetrics) {\n      cacheStats.miss(caching, key.isPrimary());\n    }\n    return null;\n  }","commit_id":"263a0adf79105b9dc166e21c3f5159ade6e2d0a7","url":"https://github.com/apache/hbase"},{"original_method":"public static void hammerSingleKey(final BlockCache toBeTested,\n      int BlockSize, int numThreads, int numQueries) throws Exception {\n    final BlockCacheKey key = new BlockCacheKey(\"key\", 0);\n    final byte[] buf = new byte[5 * 1024];\n    Arrays.fill(buf, (byte) 5);\n\n    final ByteArrayCacheable bac = new ByteArrayCacheable(buf);\n    Configuration conf = new Configuration();\n    MultithreadedTestUtil.TestContext ctx = new MultithreadedTestUtil.TestContext(\n        conf);\n\n    final AtomicInteger totalQueries = new AtomicInteger();\n    toBeTested.cacheBlock(key, bac);\n\n    for (int i = 0; i < numThreads; i++) {\n      TestThread t = new MultithreadedTestUtil.RepeatingTestThread(ctx) {\n        @Override\n        public void doAnAction() throws Exception {\n          ByteArrayCacheable returned = (ByteArrayCacheable) toBeTested\n              .getBlock(key, false, false, true);\n          assertArrayEquals(buf, returned.buf);\n          totalQueries.incrementAndGet();\n        }\n      };\n\n      t.setDaemon(true);\n      ctx.addThread(t);\n    }\n\n    ctx.startThreads();\n    while (totalQueries.get() < numQueries && ctx.shouldRun()) {\n      Thread.sleep(10);\n    }\n    ctx.stop();\n  }","id":83100,"modified_method":"public static void hammerSingleKey(final BlockCache toBeTested,\n      int BlockSize, int numThreads, int numQueries) throws Exception {\n    final BlockCacheKey key = new BlockCacheKey(\"key\", 0);\n    final byte[] buf = new byte[5 * 1024];\n    Arrays.fill(buf, (byte) 5);\n\n    final ByteArrayCacheable bac = new ByteArrayCacheable(buf);\n    Configuration conf = new Configuration();\n    MultithreadedTestUtil.TestContext ctx = new MultithreadedTestUtil.TestContext(\n        conf);\n\n    final AtomicInteger totalQueries = new AtomicInteger();\n    toBeTested.cacheBlock(key, bac);\n\n    for (int i = 0; i < numThreads; i++) {\n      TestThread t = new MultithreadedTestUtil.RepeatingTestThread(ctx) {\n        @Override\n        public void doAnAction() throws Exception {\n          ByteArrayCacheable returned = (ByteArrayCacheable) toBeTested\n              .getBlock(key, false, false, true);\n          if (returned != null) {\n            assertArrayEquals(buf, returned.buf);\n          } else {\n            Thread.sleep(10);\n          }\n          totalQueries.incrementAndGet();\n        }\n      };\n\n      t.setDaemon(true);\n      ctx.addThread(t);\n    }\n\n    // add a thread to periodically evict and re-cache the block\n    final long blockEvictPeriod = 50;\n    TestThread t = new MultithreadedTestUtil.RepeatingTestThread(ctx) {\n      @Override\n      public void doAnAction() throws Exception {\n        toBeTested.evictBlock(key);\n        toBeTested.cacheBlock(key, bac);\n        Thread.sleep(blockEvictPeriod);\n      }\n    };\n    t.setDaemon(true);\n    ctx.addThread(t);\n\n    ctx.startThreads();\n    while (totalQueries.get() < numQueries && ctx.shouldRun()) {\n      Thread.sleep(10);\n    }\n    ctx.stop();\n  }","commit_id":"263a0adf79105b9dc166e21c3f5159ade6e2d0a7","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testCacheMultiThreadedSingleKey() throws Exception {\n    CacheTestUtils.hammerSingleKey(cache, BLOCK_SIZE, NUM_THREADS, NUM_QUERIES);\n  }","id":83101,"modified_method":"@Test\n  public void testCacheMultiThreadedSingleKey() throws Exception {\n    CacheTestUtils.hammerSingleKey(cache, BLOCK_SIZE, 2 * NUM_THREADS, 2 * NUM_QUERIES);\n  }","commit_id":"263a0adf79105b9dc166e21c3f5159ade6e2d0a7","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testMemoryLeak() throws Exception {\n    final BlockCacheKey cacheKey = new BlockCacheKey(\"dummy\", 1L);\n    cacheAndWaitUntilFlushedToBucket(cache, cacheKey, new CacheTestUtils.ByteArrayCacheable(\n        new byte[10]));\n    long lockId = cache.backingMap.get(cacheKey).offset();\n    IdLock.Entry lockEntry = cache.offsetLock.getLockEntry(lockId);\n    Thread evictThread = new Thread(\"evict-block\") {\n\n      @Override\n      public void run() {\n        cache.evictBlock(cacheKey);\n      }\n\n    };\n    evictThread.start();\n    cache.offsetLock.waitForWaiters(lockId, 1);\n    cache.blockEvicted(cacheKey, cache.backingMap.remove(cacheKey), true);\n    cacheAndWaitUntilFlushedToBucket(cache, cacheKey, new CacheTestUtils.ByteArrayCacheable(\n        new byte[10]));\n    cache.offsetLock.releaseLockEntry(lockEntry);\n    evictThread.join();\n    assertEquals(1L, cache.getBlockCount());\n    assertTrue(cache.getCurrentSize() > 0L);\n    assertTrue(\"We should have a block!\", cache.iterator().hasNext());\n  }","id":83102,"modified_method":"@Test\n  public void testMemoryLeak() throws Exception {\n    final BlockCacheKey cacheKey = new BlockCacheKey(\"dummy\", 1L);\n    cacheAndWaitUntilFlushedToBucket(cache, cacheKey, new CacheTestUtils.ByteArrayCacheable(\n        new byte[10]));\n    long lockId = cache.backingMap.get(cacheKey).offset();\n    ReentrantReadWriteLock lock = cache.offsetLock.getLock(lockId);\n    lock.writeLock().lock();\n    Thread evictThread = new Thread(\"evict-block\") {\n\n      @Override\n      public void run() {\n        cache.evictBlock(cacheKey);\n      }\n\n    };\n    evictThread.start();\n    cache.offsetLock.waitForWaiters(lockId, 1);\n    cache.blockEvicted(cacheKey, cache.backingMap.remove(cacheKey), true);\n    cacheAndWaitUntilFlushedToBucket(cache, cacheKey, new CacheTestUtils.ByteArrayCacheable(\n        new byte[10]));\n    lock.writeLock().unlock();\n    evictThread.join();\n    assertEquals(1L, cache.getBlockCount());\n    assertTrue(cache.getCurrentSize() > 0L);\n    assertTrue(\"We should have a block!\", cache.iterator().hasNext());\n  }","commit_id":"263a0adf79105b9dc166e21c3f5159ade6e2d0a7","url":"https://github.com/apache/hbase"},{"original_method":"private void initCategories(){\n        Set<PortletCategory> allCategories = new HashSet<PortletCategory>();\n        for(PortletCategory childCategory:this.portletCategoryRegistry.getParentCategories(this)){\n            allCategories.add(childCategory);\n            allCategories.addAll(this.portletCategoryRegistry.getAllParentCategories(childCategory));\n        }\n        this.setCategories(allCategories);\n    }","id":83103,"modified_method":"/**\n     * private method that sets the parentCategories field and the categories field\n     * This will ensure that the public methods {@link #getParentCategories() getParentCategories()}\n     * and {@link #getCategories() getCategories()} will not return null.\n     * Empty sets are allowed\n     */\n    private void initCategories(){\n        Set<PortletCategory> allCategories = new HashSet<PortletCategory>();\n        this.setParentCategories(this.portletCategoryRegistry.getParentCategories(this));\n        for(PortletCategory childCategory:this.parentCategories){\n            allCategories.add(childCategory);\n            allCategories.addAll(this.portletCategoryRegistry.getAllParentCategories(childCategory));\n        }\n        this.setCategories(allCategories);\n    }","commit_id":"ee849f6c5e0382505d32c85d384feb108840561a","url":"https://github.com/Jasig/uPortal"},{"original_method":"@RenderMapping(params=\"action=view\")\r\n    public String entryView(RenderRequest renderRequest, RenderResponse renderResponse, WebRequest webRequest, PortletRequest portletRequest, Model model){\r\n        IPortletDefinition result = this.portletDefinitionRegistry.getPortletDefinitionByFname(portletRequest.getParameter(\"fName\"));\r\n        if(result == null){\r\n            this.setUpInitialView(webRequest, portletRequest, model);\r\n            return \"jsp/Marketplace/view\";\r\n        }\r\n        MarketplacePortletDefinition mpDefinition = new MarketplacePortletDefinition(result, this.portletCategoryRegistry);\r\n        IMarketplaceRating tempRatingImpl = marketplaceRatingDAO.getRating(portletRequest.getRemoteUser(),\r\n                portletDefinitionDao.getPortletDefinitionByFname(result.getFName()));\r\n        model.addAttribute(\"rating\", tempRatingImpl==null ? null:tempRatingImpl.getRating());\r\n        model.addAttribute(\"portlet\", mpDefinition);\r\n        model.addAttribute(\"deepLink\",getDeepLink(portalRequestUtils.getPortletHttpRequest(portletRequest), mpDefinition));\r\n        model.addAttribute(\"shortURL\",mpDefinition.getShortURL());\r\n        return \"jsp/Marketplace/entry\";\r\n    }","id":83104,"modified_method":"@RenderMapping(params=\"action=view\")\r\n    public String entryView(RenderRequest renderRequest, RenderResponse renderResponse, WebRequest webRequest, PortletRequest portletRequest, Model model){\r\n        IPortletDefinition result = this.portletDefinitionRegistry.getPortletDefinitionByFname(portletRequest.getParameter(\"fName\"));\r\n        if(result == null){\r\n            this.setUpInitialView(webRequest, portletRequest, model, null);\r\n            return \"jsp/Marketplace/view\";\r\n        }\r\n        MarketplacePortletDefinition mpDefinition = new MarketplacePortletDefinition(result, this.portletCategoryRegistry);\r\n        IMarketplaceRating tempRatingImpl = marketplaceRatingDAO.getRating(portletRequest.getRemoteUser(),\r\n                portletDefinitionDao.getPortletDefinitionByFname(result.getFName()));\r\n        model.addAttribute(\"rating\", tempRatingImpl==null ? null:tempRatingImpl.getRating());\r\n        model.addAttribute(\"portlet\", mpDefinition);\r\n        model.addAttribute(\"deepLink\",getDeepLink(portalRequestUtils.getPortletHttpRequest(portletRequest), mpDefinition));\r\n        model.addAttribute(\"shortURL\",mpDefinition.getShortURL());\r\n        return \"jsp/Marketplace/entry\";\r\n    }","commit_id":"ee849f6c5e0382505d32c85d384feb108840561a","url":"https://github.com/Jasig/uPortal"},{"original_method":"private Map<String,SortedSet<?>> getRegistry(WebRequest request, IPerson user, Boolean seeManage) {\r\n        // get a list of all channels \r\n        List<IPortletDefinition> allChannels = portletDefinitionRegistry.getAllPortletDefinitions();\r\n        // construct a new channel registry\r\n        Map<String,SortedSet<?>> registry = new TreeMap<String,SortedSet<?>>();\r\n        SortedSet<ChannelBean> channels = new TreeSet<ChannelBean>();\r\n        // get user locale\r\n        Locale[] locales = localeStore.getUserLocales(user);\r\n        LocaleManager localeManager = new LocaleManager(user, locales);\r\n        Locale locale = localeManager.getLocales()[0];\r\n\t    \r\n        EntityIdentifier ei = user.getEntityIdentifier();\r\n        IAuthorizationPrincipal ap = AuthorizationService.instance().newPrincipal(ei.getKey(), ei.getType());\r\n\t    \r\n        if(seeManage == true){\t    \r\n            for (IPortletDefinition channel : allChannels) {\r\n                if (ap.canManage(channel.getPortletDefinitionId().getStringId())) {\r\n                    channels.add(getChannel(channel, request, locale));\r\n                }\r\n            }\r\n        }\r\n    \r\n        registry.put(\"channels\", channels);\r\n        registry.put(\"categories\", this.getAllCategories(request));\r\n        return registry;\r\n    }","id":83105,"modified_method":"/**\r\n     * Returns a set of MarketplacePortletDefinitions.  Supply a user to limit \r\n     * the set to only portlets the user can use.  If user is null, this will\r\n     * return all portlets.  Setting user to null will superscede all other\r\n     * parameters.\r\n     *\r\n     * @param request\r\n     * @param user - the user to limit results by. This will filter results to \r\n     *               only portlets that user can use. Null will return all portlets.\r\n     * @param seeManage - additive parameter that will add/not add portlets to returned set.\r\n     *                    true will add portlets to the returned set the user can manage.\r\n     *                    false will not add additional portlets that user can manage.\r\n     *                    If user is null, this parameter doesn't matter.\r\n     * @return a set of portlets filtered that user can use, and other parameters\r\n    */\r\n    public Map<String,Set<?>> getRegistry(WebRequest request, IPerson user, Boolean seeManage){\r\n        // get a list of all channels \r\n        List<IPortletDefinition> allChannels = portletDefinitionRegistry.getAllPortletDefinitions();\r\n        // sets up permissions if user is not null\r\n        EntityIdentifier ei = null;\r\n        IAuthorizationPrincipal ap = null;\r\n        if(user !=null){\r\n            ei = user.getEntityIdentifier();\r\n            ap = AuthorizationService.instance().newPrincipal(ei.getKey(), ei.getType());\r\n        }\r\n        Map<String,Set<?>> registry = new TreeMap<String,Set<?>>();\r\n        Set<MarketplacePortletDefinition> visiblePortlets = new HashSet<MarketplacePortletDefinition>();\r\n        Set<PortletCategory> visibleCategories = new HashSet<PortletCategory>();\r\n        for (IPortletDefinition channel : allChannels) {\r\n            String chanPubId = channel.getPortletDefinitionId().getStringId();\r\n            if(user==null                                   //if user is null, add portlet\r\n                || ap.canSubscribe(chanPubId)               //if can subscribe, add\r\n                || (seeManage && ap.canManage(chanPubId))){ //if can manage, add \r\n                    visiblePortlets.add(new MarketplacePortletDefinition(channel, portletCategoryRegistry));\r\n                    visibleCategories.addAll(this.portletCategoryRegistry.getParentCategories(channel));\r\n            }\r\n        }\r\n        registry.put(\"portlets\", visiblePortlets);\r\n        registry.put(\"categories\", visibleCategories);\r\n        return registry;\r\n    }","commit_id":"ee849f6c5e0382505d32c85d384feb108840561a","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void setUpInitialView(WebRequest webRequest, PortletRequest portletRequest, Model model){\r\n\t\tfinal HttpServletRequest servletRequest = this.portalRequestUtils.getPortletHttpRequest(portletRequest);\r\n\t\tIPerson user = personManager.getPerson(servletRequest);\r\n\t\tArrayList<ChannelBean> portletList = (ArrayList<ChannelBean>) getListOfChannelBeans(webRequest, user, true);\r\n\t\tmodel.addAttribute(\"channelBeanList\", portletList);\r\n\t}","id":83106,"modified_method":"private void setUpInitialView(WebRequest webRequest, PortletRequest portletRequest, Model model, String initialFilter){\r\n        final HttpServletRequest servletRequest = this.portalRequestUtils.getPortletHttpRequest(portletRequest);\r\n        final PortletPreferences preferences = portletRequest.getPreferences();\r\n        final boolean isLogLevelDebug = logger.isDebugEnabled();\r\n\r\n        //Determine if the marketplace is going to show all the portlets\r\n        //Default behavior is to show just the portlets a user can subscribe to\r\n        String showAllPortletsPreferenceValue = preferences.getValue(SHOW_ALL_PORTLETS_PREFERENCE_NAME, \"false\");\r\n        boolean showAllPortlets = Boolean.parseBoolean(showAllPortletsPreferenceValue);\r\n        IPerson user = null;\r\n        if(showAllPortlets == false){\r\n            user = personManager.getPerson(servletRequest);\r\n        }\r\n\r\n        //Determine if the marketplace is going to show portlets that a user can manage, but can't subscribe to.\r\n        //Note - if showing all portlets, this becomes moot.\r\n        //Default behavior is to show portlets that users manage\r\n        String showManagedPortletsPreferenceValue = preferences.getValue(SHOW_MANAGED_PORTLETS_PREFERENCE_NAME, \"true\");\r\n        boolean showManagedPortlets = Boolean.parseBoolean(showManagedPortletsPreferenceValue);\r\n\r\n        if(isLogLevelDebug){\r\n            logger.debug(\"Going to show all portlets?: {}\", Boolean.toString(showAllPortlets));\r\n            logger.debug(\"Going to show managed portlets?: {}\", Boolean.toString(showManagedPortlets));\r\n        }\r\n\r\n        Map<String,Set<?>> registry = getRegistry(webRequest, user, showManagedPortlets);\r\n        @SuppressWarnings(\"unchecked\")\r\n        Set<MarketplacePortletDefinition> portletList = (Set<MarketplacePortletDefinition>) registry.get(\"portlets\");\r\n        model.addAttribute(\"channelBeanList\", portletList);\r\n        @SuppressWarnings(\"unchecked\")\r\n        Set<PortletCategory> categoryList = (Set<PortletCategory>) registry.get(\"categories\");\r\n\r\n        //Determine if the marketplace is going to show the root category\r\n        String showRootCategoryPreferenceValue = preferences.getValue(SHOW_ROOT_CATEGORY_PREFERENCE_NAME, \"false\");\r\n        boolean showRootCategory = Boolean.parseBoolean(showRootCategoryPreferenceValue);\r\n\r\n        if(isLogLevelDebug){\r\n            logger.debug(\"Going to show Root Category?: {}\", Boolean.toString(showRootCategory));\r\n        }\r\n\r\n        if(showRootCategory == false){\r\n            categoryList.remove(this.portletCategoryRegistry.getTopLevelPortletCategory());\r\n        }\r\n\r\n        model.addAttribute(\"categoryList\", categoryList);\r\n        model.addAttribute(\"initialFilter\", initialFilter);\r\n    }","commit_id":"ee849f6c5e0382505d32c85d384feb108840561a","url":"https://github.com/Jasig/uPortal"},{"original_method":"private IChannel instantiateChannel(String chanId, String channelPublishId, String className, long timeOut, Hashtable params) throws Exception {\n        IChannel ch=null;\n\n        // check if the user has permissions to instantiate this channel\n        IAuthorizationPrincipal ap = AuthorizationService.instance().newPrincipal(Integer.toString(this.pcs.getUserLayoutManager().getPerson().getID()), org.jasig.portal.security.IPerson.class);\n\n        if(ap.canRender(Integer.parseInt(channelPublishId))) {\n            \n            boolean exists=false;\n            // this is somewhat of a cheating ... I am trying to avoid instantiating a multithreaded\n            // channel more then once, but it's difficult to implement \"instanceof\" operation on\n            // the java.lang.Class. So, I just look into the staticChannels table.\n            Object cobj=staticChannels.get(className);\n            if(cobj!=null) {\n                exists=true;\n            } else {\n                cobj =  Class.forName (className).newInstance ();\n            }\n\n            // determine what kind of a channel it is.\n            // (perhaps, later this all could be moved to JNDI factories, so everything would be transparent)\n            if(cobj instanceof IMultithreadedChannel) {\n                String uid=this.pcs.getHttpServletRequest().getSession(false).getId()+\"/\"+chanId;\n                if(cobj instanceof IMultithreadedCacheable) {\n                    if(cobj instanceof IPrivileged) {\n                        // both cacheable and privileged\n                        ch=new MultithreadedPrivilegedCacheableChannelAdapter((IMultithreadedChannel)cobj,uid);\n                    } else {\n                        // just cacheable\n                        ch=new MultithreadedCacheableChannelAdapter((IMultithreadedChannel)cobj,uid);\n                    }\n                } else if(cobj instanceof IPrivileged) {\n                    ch=new MultithreadedPrivilegedChannelAdapter((IMultithreadedChannel)cobj,uid);\n                } else {\n                    // plain multithreaded\n                    ch=new MultithreadedChannelAdapter((IMultithreadedChannel)cobj,uid);\n                }\n                // see if we need to add the instance to the staticChannels\n                if(!exists) {\n                    staticChannels.put(className,cobj);\n                }\n            } else {\n                // vanilla IChannel\n                ch=(IChannel)cobj;\n            }\n        } else {\n            // user is not authorized to instantiate this channel\n            // create an instance of an error channel instead\n            LogService.instance().log(LogService.ERROR,\"ChannelManager::instantiateChannel() : user has no authorization to render channel \"+chanId+\".\");\n            ch=new CError(CError.CHANNEL_AUTHORIZATION_EXCEPTION,\"You don't have authorization to render this channel.\",chanId,null);\n        }\n\n        // construct a ChannelStaticData object\n        ChannelStaticData sd = new ChannelStaticData ();\n        sd.setChannelID (chanId);\n        sd.setTimeout (timeOut);\n        sd.setParameters (params);\n        // Set the Id of the channel that exists in UP_CHANNELS\n        sd.setChannelGlobalID(ulm.getChannelGlobalId(chanId));\n        // Set the PermissionManager for this channel (no longer necessary)\n        // sd.setPermissionManager(new ReferencePermissionManager(\"CHAN_ID.\" + ulm.getChannelGlobalId(chanId)));\n\n        // get person object from UsreLayoutManager\n        sd.setPerson(ulm.getPerson());\n\n        sd.setJNDIContext(channelContext);\n\n        ch.setStaticData (sd);\n        channelTable.put (chanId,ch);\n\n        return ch;\n    }","id":83107,"modified_method":"private IChannel instantiateChannel(String chanId, String channelPublishId, String className, long timeOut, Hashtable params) throws Exception {\n        IChannel ch=null;\n\n        // check if the user has permissions to instantiate this channel\n        if(ap==null) {\n            ap = AuthorizationService.instance().newPrincipal(Integer.toString(this.pcs.getUserLayoutManager().getPerson().getID()), org.jasig.portal.security.IPerson.class);\n        } \n\n        if(ap.canRender(Integer.parseInt(channelPublishId))) {\n            \n            boolean exists=false;\n            // this is somewhat of a cheating ... I am trying to avoid instantiating a multithreaded\n            // channel more then once, but it's difficult to implement \"instanceof\" operation on\n            // the java.lang.Class. So, I just look into the staticChannels table.\n            Object cobj=staticChannels.get(className);\n            if(cobj!=null) {\n                exists=true;\n            } else {\n                cobj =  Class.forName (className).newInstance ();\n            }\n\n            // determine what kind of a channel it is.\n            // (perhaps, later this all could be moved to JNDI factories, so everything would be transparent)\n            if(cobj instanceof IMultithreadedChannel) {\n                String uid=this.pcs.getHttpServletRequest().getSession(false).getId()+\"/\"+chanId;\n                if(cobj instanceof IMultithreadedCacheable) {\n                    if(cobj instanceof IPrivileged) {\n                        // both cacheable and privileged\n                        ch=new MultithreadedPrivilegedCacheableChannelAdapter((IMultithreadedChannel)cobj,uid);\n                    } else {\n                        // just cacheable\n                        ch=new MultithreadedCacheableChannelAdapter((IMultithreadedChannel)cobj,uid);\n                    }\n                } else if(cobj instanceof IPrivileged) {\n                    ch=new MultithreadedPrivilegedChannelAdapter((IMultithreadedChannel)cobj,uid);\n                } else {\n                    // plain multithreaded\n                    ch=new MultithreadedChannelAdapter((IMultithreadedChannel)cobj,uid);\n                }\n                // see if we need to add the instance to the staticChannels\n                if(!exists) {\n                    staticChannels.put(className,cobj);\n                }\n            } else {\n                // vanilla IChannel\n                ch=(IChannel)cobj;\n            }\n        } else {\n            // user is not authorized to instantiate this channel\n            // create an instance of an error channel instead\n            ch=new CError(CError.CHANNEL_AUTHORIZATION_EXCEPTION,\"You don't have authorization to render this channel.\",chanId,null);\n        }\n\n        // construct a ChannelStaticData object\n        ChannelStaticData sd = new ChannelStaticData ();\n        sd.setChannelID (chanId);\n        sd.setTimeout (timeOut);\n        sd.setParameters (params);\n        // Set the Id of the channel that exists in UP_CHANNELS\n        sd.setChannelGlobalID(ulm.getChannelGlobalId(chanId));\n        // Set the PermissionManager for this channel (no longer necessary)\n        // sd.setPermissionManager(new ReferencePermissionManager(\"CHAN_ID.\" + ulm.getChannelGlobalId(chanId)));\n\n        // get person object from UsreLayoutManager\n        sd.setPerson(ulm.getPerson());\n\n        sd.setJNDIContext(channelContext);\n\n        ch.setStaticData (sd);\n        channelTable.put (chanId,ch);\n\n        return ch;\n    }","commit_id":"80f0d980e5900081e6937af346aa2b506c67753a","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected IAuthorizationPrincipal getUserPrincipal(final String userName) {\n        final IEntity user = GroupService.getEntity(userName, IPerson.class);\n        \n        final AuthorizationService authService = AuthorizationService.instance();\n        final IAuthorizationPrincipal userPrincipal = authService.newPrincipal(user);\n        return userPrincipal;\n    }","id":83108,"modified_method":"protected IAuthorizationPrincipal getUserPrincipal(final String userName) {\n        final IEntity user = GroupService.getEntity(userName, IPerson.class);\n        if (user == null) {\n            return null;\n        }\n        \n        final AuthorizationService authService = AuthorizationService.instance();\n        return authService.newPrincipal(user);\n    }","commit_id":"a7185e2beeaabac9e037d68b780cee1dadf5ecee","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n  protected String getExtractedSuperNameNotSpecifiedKey() {\n    return RefactoringBundle.message(\"no.interface.name.specified\");\n  }","id":83109,"modified_method":"@Override\n  protected String getExtractedSuperNameNotSpecifiedMessage() {\n    return RefactoringBundle.message(\"no.interface.name.specified\");\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected ExtractSuperBaseProcessor createProcessor() {\n    return new ExtractInterfaceProcessor(myProject, false, getTargetDirectory(), getExtractedSuperName(),\n                                         mySourceClass, getSelectedMembers(),\n                                         new DocCommentPolicy(getDocCommentPolicy()));\n  }","id":83110,"modified_method":"@Override\n  protected ExtractSuperBaseProcessor createProcessor() {\n    return new ExtractInterfaceProcessor(myProject, false, getTargetDirectory(), getExtractedSuperName(),\n                                         mySourceClass, ArrayUtil.toObjectArray(getSelectedMemberInfos(), MemberInfo.class),\n                                         new DocCommentPolicy(getDocCommentPolicy()));\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String getClassNameLabelText() {\n    return RefactoringBundle.message(\"superinterface.name\");\n  }","id":83111,"modified_method":"protected String getClassNameLabelText() {\n    return isExtractSuperclass()\n           ? RefactoringBundle.message(\"interface.name.prompt\")\n           : RefactoringBundle.message(\"rename.implementation.class.to\");\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull final Project project, @NotNull PsiElement[] elements, DataContext dataContext) {\n    if (elements.length != 1) return;\n\n    myProject = project;\n    myClass = (PsiClass)elements[0];\n\n\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(project, myClass)) return;\n\n    final ExtractInterfaceDialog dialog = new ExtractInterfaceDialog(myProject, myClass);\n    dialog.show();\n    if (!dialog.isOK() || !dialog.isExtractSuperclass()) return;\n\n    CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            myInterfaceName = dialog.getExtractedSuperName();\n            mySelectedMembers = dialog.getSelectedMembers();\n            myTargetDir = dialog.getTargetDirectory();\n            myJavaDocPolicy = new DocCommentPolicy(dialog.getDocCommentPolicy());\n            try {\n              doRefactoring();\n            }\n            catch (IncorrectOperationException e) {\n              LOG.error(e);\n            }\n          }\n        });\n      }\n    }, REFACTORING_NAME, null);\n\n  }","id":83112,"modified_method":"public void invoke(@NotNull final Project project, @NotNull PsiElement[] elements, DataContext dataContext) {\n    if (elements.length != 1) return;\n\n    myProject = project;\n    myClass = (PsiClass)elements[0];\n\n\n    if (!CommonRefactoringUtil.checkReadOnlyStatus(project, myClass)) return;\n\n    final ExtractInterfaceDialog dialog = new ExtractInterfaceDialog(myProject, myClass);\n    dialog.show();\n    if (!dialog.isOK() || !dialog.isExtractSuperclass()) return;\n\n    CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n      public void run() {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            myInterfaceName = dialog.getExtractedSuperName();\n            mySelectedMembers = ArrayUtil.toObjectArray(dialog.getSelectedMemberInfos(), MemberInfo.class);\n            myTargetDir = dialog.getTargetDirectory();\n            myJavaDocPolicy = new DocCommentPolicy(dialog.getDocCommentPolicy());\n            try {\n              doRefactoring();\n            }\n            catch (IncorrectOperationException e) {\n              LOG.error(e);\n            }\n          }\n        });\n      }\n    }, REFACTORING_NAME, null);\n\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createActionComponent() {\n    Box box = Box.createHorizontalBox();\n    final String s = StringUtil.decapitalize(getEntityName());\n    myRbExtractSuperclass = new JRadioButton();\n    myRbExtractSuperclass.setText(RefactoringBundle.message(\"extractSuper.extract\", s));\n    myRbExtractSubclass = new JRadioButton();\n    myRbExtractSubclass.setText(RefactoringBundle.message(\"extractSuper.rename.original.class\", s));\n    box.add(myRbExtractSuperclass);\n    box.add(myRbExtractSubclass);\n    box.add(Box.createHorizontalGlue());\n    final ButtonGroup buttonGroup = new ButtonGroup();\n    buttonGroup.add(myRbExtractSuperclass);\n    buttonGroup.add(myRbExtractSubclass);\n    myRbExtractSuperclass.setSelected(true);\n    myRbExtractSuperclass.addItemListener(new ItemListener() {\n      public void itemStateChanged(ItemEvent e) {\n        updateDialogForExtractSuperclass();\n      }\n    });\n\n    myRbExtractSubclass.addItemListener(new ItemListener() {\n      public void itemStateChanged(ItemEvent e) {\n        updateDialogForExtractSubclass();\n      }\n    });\n    return box;\n  }","id":83113,"modified_method":"protected JComponent createActionComponent() {\n    Box box = Box.createHorizontalBox();\n    final String s = StringUtil.decapitalize(getEntityName());\n    myRbExtractSuperclass = new JRadioButton();\n    myRbExtractSuperclass.setText(RefactoringBundle.message(\"extractSuper.extract\", s));\n    myRbExtractSubclass = new JRadioButton();\n    myRbExtractSubclass.setText(RefactoringBundle.message(\"extractSuper.rename.original.class\", s));\n    box.add(myRbExtractSuperclass);\n    box.add(myRbExtractSubclass);\n    box.add(Box.createHorizontalGlue());\n    final ButtonGroup buttonGroup = new ButtonGroup();\n    buttonGroup.add(myRbExtractSuperclass);\n    buttonGroup.add(myRbExtractSubclass);\n    myRbExtractSuperclass.setSelected(true);\n\n    ItemListener listener = new ItemListener() {\n      public void itemStateChanged(ItemEvent e) {\n        updateDialog();\n      }\n    };\n    myRbExtractSuperclass.addItemListener(listener);\n    myRbExtractSubclass.addItemListener(listener);\n    return box;\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract void initPackageNameField();","id":83114,"modified_method":"protected abstract ComponentWithBrowseButton<EditorComboBox> createPackageNameField();","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract String getExtractedSuperNameNotSpecifiedKey();","id":83115,"modified_method":"protected abstract String getExtractedSuperNameNotSpecifiedMessage();","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ExtractSuperBaseDialog(Project project, ClassType sourceClass, List<MemberType> members, String refactoringName) {\n    super(project, true);\n    myRefactoringName = refactoringName;\n\n    mySourceClass = sourceClass;\n    myMemberInfos = members;\n    myTargetDirectory = mySourceClass.getContainingFile().getContainingDirectory();\n  }","id":83116,"modified_method":"public ExtractSuperBaseDialog(Project project, ClassType sourceClass, List<MemberInfoType> members, String refactoringName) {\n    super(project, true);\n    myRefactoringName = refactoringName;\n\n    mySourceClass = sourceClass;\n    myMemberInfos = members;\n    myTargetDirectory = mySourceClass.getContainingFile().getContainingDirectory();\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract void initSourceClassField();","id":83117,"modified_method":"protected abstract JTextField createSourceClassField();","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void init() {\n    setTitle(myRefactoringName);\n\n    initPackageNameField();\n    initSourceClassField();\n    myExtractedSuperNameField = new JTextField();\n\n    myDocCommentPanel = new DocCommentPanel(getDocCommentPanelName());\n    myDocCommentPanel.setPolicy(getDocCommentPolicySetting());\n\n    super.init();\n    updateDialogForExtractSuperclass();\n  }","id":83118,"modified_method":"@Override\n  protected void init() {\n    setTitle(myRefactoringName);\n\n    myPackageNameField = createPackageNameField();\n    mySourceClassField = createSourceClassField();\n    myExtractedSuperNameField = new JTextField();\n\n    myDocCommentPanel = new DocCommentPanel(getDocCommentPanelName());\n    myDocCommentPanel.setPolicy(getDocCommentPolicySetting());\n\n    super.init();\n    updateDialog();\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doAction() {\n    final String[] errorString = new String[]{null};\n    final String extractedSuperName = getExtractedSuperName();\n    final String packageName = getTargetPackageName();\n    RecentsManager.getInstance(myProject).registerRecentEntry(getDestinationPackageRecentKey(), packageName);\n\n    if (\"\".equals(extractedSuperName)) {\n      errorString[0] = getExtractedSuperNameNotSpecifiedKey();\n      myExtractedSuperNameField.requestFocusInWindow();\n    }\n    else {\n      String nameError = validateName(extractedSuperName);\n      if (nameError != null) {\n        errorString[0] = nameError;\n        myExtractedSuperNameField.requestFocusInWindow();\n      }\n      else {\n        CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n          public void run() {\n            try {\n              preparePackage();\n            }\n            catch (IncorrectOperationException e) {\n              errorString[0] = e.getMessage();\n              myPackageNameField.requestFocusInWindow();\n            }\n            catch (OperationFailedException e) {\n              errorString[0] = e.getMessage();\n              myPackageNameField.requestFocusInWindow();\n            }\n          }\n        }, RefactoringBundle.message(\"create.directory\"), null);\n      }\n    }\n    if (errorString[0] != null) {\n      if (errorString[0].length() > 0) {\n        CommonRefactoringUtil.showErrorMessage(myRefactoringName, errorString[0], getHelpId(), myProject);\n      }\n      return;\n    }\n\n    if (!checkConflicts()) return;\n\n    if (!isExtractSuperclass()) {\n      invokeRefactoring(createProcessor());\n    }\n    setDocCommentPolicySetting(getDocCommentPolicy());\n    closeOKAction();\n  }","id":83119,"modified_method":"protected void doAction() {\n    final String[] errorString = new String[]{null};\n    final String extractedSuperName = getExtractedSuperName();\n    final String packageName = getTargetPackageName();\n    RecentsManager.getInstance(myProject).registerRecentEntry(getDestinationPackageRecentKey(), packageName);\n\n    if (\"\".equals(extractedSuperName)) {\n      // TODO just disable OK button\n      errorString[0] = getExtractedSuperNameNotSpecifiedMessage();\n      myExtractedSuperNameField.requestFocusInWindow();\n    }\n    else {\n      String nameError = validateName(extractedSuperName);\n      if (nameError != null) {\n        errorString[0] = nameError;\n        myExtractedSuperNameField.requestFocusInWindow();\n      }\n      else {\n        CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n          public void run() {\n            try {\n              preparePackage();\n            }\n            catch (IncorrectOperationException e) {\n              errorString[0] = e.getMessage();\n              myPackageNameField.requestFocusInWindow();\n            }\n            catch (OperationFailedException e) {\n              errorString[0] = e.getMessage();\n              myPackageNameField.requestFocusInWindow();\n            }\n          }\n        }, RefactoringBundle.message(\"create.directory\"), null);\n      }\n    }\n    if (errorString[0] != null) {\n      if (errorString[0].length() > 0) {\n        CommonRefactoringUtil.showErrorMessage(myRefactoringName, errorString[0], getHelpId(), myProject);\n      }\n      return;\n    }\n\n    if (!checkConflicts()) return;\n\n    if (!isExtractSuperclass()) {\n      invokeRefactoring(createProcessor());\n    }\n    setDocCommentPolicySetting(getDocCommentPolicy());\n    closeOKAction();\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected ExtractSuperBaseProcessor createProcessor() {\n    return new ExtractSuperClassProcessor(myProject, getTargetDirectory(), getExtractedSuperName(),\n                                          mySourceClass, getSelectedMemberInfos(), false,\n                                          new DocCommentPolicy(getDocCommentPolicy()));\n  }","id":83120,"modified_method":"@Override\n  protected ExtractSuperBaseProcessor createProcessor() {\n    return new ExtractSuperClassProcessor(myProject, getTargetDirectory(), getExtractedSuperName(),\n                                          mySourceClass, ArrayUtil.toObjectArray(getSelectedMemberInfos(), MemberInfo.class), false,\n                                          new DocCommentPolicy(getDocCommentPolicy()));\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String getClassNameLabelText() {\n    return RefactoringBundle.message(\"superclass.name\");\n  }","id":83121,"modified_method":"protected String getClassNameLabelText() {\n    return isExtractSuperclass()\n           ? RefactoringBundle.message(\"superclass.name\")\n           : RefactoringBundle.message(\"extractSuper.rename.original.class.to\");\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected String getExtractedSuperNameNotSpecifiedKey() {\n    return RefactoringBundle.message(\"no.superclass.name.specified\");\n  }","id":83122,"modified_method":"@Override\n  protected String getExtractedSuperNameNotSpecifiedMessage() {\n    return RefactoringBundle.message(\"no.superclass.name.specified\");\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doRefactoring(final Project project, final PsiClass subclass, final ExtractSuperclassDialog dialog) {\n    final String superclassName = dialog.getExtractedSuperName();\n    final PsiDirectory targetDirectory = dialog.getTargetDirectory();\n    final MemberInfo[] selectedMemberInfos = dialog.getSelectedMemberInfos();\n    final DocCommentPolicy javaDocPolicy = new DocCommentPolicy(dialog.getDocCommentPolicy());\n    LocalHistoryAction a = LocalHistory.getInstance().startAction(getCommandName(subclass, superclassName));\n    try {\n      PsiClass superclass = null;\n\n      try {\n        superclass =\n          ExtractSuperClassUtil.extractSuperClass(project, targetDirectory, superclassName, subclass, selectedMemberInfos, javaDocPolicy);\n      }\n      finally {\n        a.finish();\n      }\n\n      // ask whether to search references to subclass and turn them into refs to superclass if possible\n      if (superclass != null) {\n        ExtractClassUtil.askAndTurnRefsToSuper(project, subclass, superclass);\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n\n  }","id":83123,"modified_method":"private void doRefactoring(final Project project, final PsiClass subclass, final ExtractSuperclassDialog dialog) {\n    final String superclassName = dialog.getExtractedSuperName();\n    final PsiDirectory targetDirectory = dialog.getTargetDirectory();\n    final MemberInfo[] selectedMemberInfos = ArrayUtil.toObjectArray(dialog.getSelectedMemberInfos(), MemberInfo.class);\n    final DocCommentPolicy javaDocPolicy = new DocCommentPolicy(dialog.getDocCommentPolicy());\n    LocalHistoryAction a = LocalHistory.getInstance().startAction(getCommandName(subclass, superclassName));\n    try {\n      PsiClass superclass = null;\n\n      try {\n        superclass =\n          ExtractSuperClassUtil.extractSuperClass(project, targetDirectory, superclassName, subclass, selectedMemberInfos, javaDocPolicy);\n      }\n      finally {\n        a.finish();\n      }\n\n      // ask whether to search references to subclass and turn them into refs to superclass if possible\n      if (superclass != null) {\n        ExtractClassUtil.askAndTurnRefsToSuper(project, subclass, superclass);\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean checkConflicts(ExtractSuperclassDialog dialog) {\n    final MemberInfo[] infos = dialog.getSelectedMemberInfos();\n    final PsiDirectory targetDirectory = dialog.getTargetDirectory();\n    final PsiPackage targetPackage;\n    if (targetDirectory != null) {\n      targetPackage = JavaDirectoryService.getInstance().getPackage(targetDirectory);\n    }\n    else {\n      targetPackage = null;\n    }\n    final MultiMap<PsiElement,String> conflicts =\n      PullUpConflictsUtil.checkConflicts(infos, mySubclass, mySubclass.getSuperClass(), targetPackage, targetDirectory, dialog.getContainmentVerifier());\n    if (!conflicts.isEmpty()) {\n      ConflictsDialog conflictsDialog = new ConflictsDialog(myProject, conflicts);\n      conflictsDialog.show();\n      final boolean ok = conflictsDialog.isOK();\n      if (!ok && conflictsDialog.isShowConflicts()) dialog.close(DialogWrapper.CANCEL_EXIT_CODE);\n      return ok;\n    }\n    return true;\n  }","id":83124,"modified_method":"public boolean checkConflicts(ExtractSuperclassDialog dialog) {\n    final MemberInfo[] infos = ArrayUtil.toObjectArray(dialog.getSelectedMemberInfos(), MemberInfo.class);\n    final PsiDirectory targetDirectory = dialog.getTargetDirectory();\n    final PsiPackage targetPackage;\n    if (targetDirectory != null) {\n      targetPackage = JavaDirectoryService.getInstance().getPackage(targetDirectory);\n    }\n    else {\n      targetPackage = null;\n    }\n    final MultiMap<PsiElement,String> conflicts =\n      PullUpConflictsUtil.checkConflicts(infos, mySubclass, mySubclass.getSuperClass(), targetPackage, targetDirectory, dialog.getContainmentVerifier());\n    if (!conflicts.isEmpty()) {\n      ConflictsDialog conflictsDialog = new ConflictsDialog(myProject, conflicts);\n      conflictsDialog.show();\n      final boolean ok = conflictsDialog.isOK();\n      if (!ok && conflictsDialog.isShowConflicts()) dialog.close(DialogWrapper.CANCEL_EXIT_CODE);\n      return ok;\n    }\n    return true;\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void initPackageNameField() {\n    String name = \"\";\n    PsiFile file = mySourceClass.getContainingFile();\n    if (file instanceof PsiJavaFile) {\n      name = ((PsiJavaFile)file).getPackageName();\n    }\n    myPackageNameField = new PackageNameReferenceEditorCombo(name, myProject, DESTINATION_PACKAGE_RECENT_KEY,\n                                                             RefactoringBundle.message(\"choose.destination.package\"));\n  }","id":83125,"modified_method":"protected ComponentWithBrowseButton<EditorComboBox> createPackageNameField() {\n    String name = \"\";\n    PsiFile file = mySourceClass.getContainingFile();\n    if (file instanceof PsiJavaFile) {\n      name = ((PsiJavaFile)file).getPackageName();\n    }\n    return new PackageNameReferenceEditorCombo(name, myProject, DESTINATION_PACKAGE_RECENT_KEY,\n                                                             RefactoringBundle.message(\"choose.destination.package\"));\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void initSourceClassField() {\n    mySourceClassField = new JTextField();\n    mySourceClassField.setEditable(false);\n    mySourceClassField.setText(mySourceClass.getQualifiedName());\n  }","id":83126,"modified_method":"protected JTextField createSourceClassField() {\n    JTextField result = new JTextField();\n    result.setEditable(false);\n    result.setText(mySourceClass.getQualifiedName());\n    return result;\n  }","commit_id":"b10b205a27f6307538eab8fecd90f9ae2a9aa060","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(PresentationData data) {\n    final T value = getValue();\n    if (value == null || !value.isValid()) {\n      setValue(null);\n    }\n    if (getValue() == null) return;\n\n    int flags = Iconable.ICON_FLAG_VISIBILITY;\n    if (isMarkReadOnly()) {\n      flags |= Iconable.ICON_FLAG_READ_STATUS;\n    }\n\n    LOG.assertTrue(value.isValid());\n\n    Icon icon = value.getIcon(flags);\n    data.setClosedIcon(icon);\n    data.setOpenIcon(icon);\n    data.setLocationString(myLocationString);\n    data.setPresentableText(myName);\n    if (isDeprecated()) {\n      data.setAttributesKey(CodeInsightColors.DEPRECATED_ATTRIBUTES);\n    }\n    updateImpl(data);\n  }","id":83127,"modified_method":"public void update(PresentationData data) {\n    T value = getValue();\n    if (value == null || !value.isValid()) {\n      setValue(null);\n    }\n\n    value = getValue();\n\n    if (value == null) return;\n\n    int flags = Iconable.ICON_FLAG_VISIBILITY;\n    if (isMarkReadOnly()) {\n      flags |= Iconable.ICON_FLAG_READ_STATUS;\n    }\n\n    LOG.assertTrue(value.isValid());\n\n    Icon icon = value.getIcon(flags);\n    data.setClosedIcon(icon);\n    data.setOpenIcon(icon);\n    data.setLocationString(myLocationString);\n    data.setPresentableText(myName);\n    if (isDeprecated()) {\n      data.setAttributesKey(CodeInsightColors.DEPRECATED_ATTRIBUTES);\n    }\n    updateImpl(data);\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean contains(VirtualFile file) {\n    if (getValue() == null) return false;\n    PsiFile containingFile = getValue().getContainingFile();\n    final VirtualFile valueFile = containingFile.getVirtualFile();\n    if (valueFile != null) {\n      return file.equals(valueFile);\n    } else {\n      return false;\n    }\n  }","id":83128,"modified_method":"public boolean contains(VirtualFile file) {\n    if (getValue() == null) return false;\n    PsiFile containingFile = getValue().getContainingFile();\n    if (containingFile == null) {\n      return false;\n    }\n    final VirtualFile valueFile = containingFile.getVirtualFile();\n    if (valueFile != null) {\n      return file.equals(valueFile);\n    } else {\n      return false;\n    }\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showListPopup(final List<VcsFileRevision> revisions, final AbstractVcs vcs, final VirtualFile file, final Project project) {\n    final DefaultListModel model = new DefaultListModel();\n    for (Iterator<VcsFileRevision> iterator = revisions.iterator(); iterator.hasNext();) {\n      model.addElement(iterator.next());\n    }\n    final JList list = new JList(model);\n    list.setCellRenderer(new VcsRevisionListCellRenderer());\n    Runnable runnable = new Runnable() {\n      public void run() {\n        int index = list.getSelectedIndex();\n        if (index == -1 || index >= list.getModel().getSize()) {\n          return;\n        }\n        VcsFileRevision revision = (VcsFileRevision)list.getSelectedValue();\n        AbstractShowDiffAction.showDiff(vcs.getDiffProvider(), revision.getRevisionNumber(),\n                                        file, project);\n      }\n    };\n\n    if (list.getModel().getSize() == 0) {\n      list.clearSelection();\n    }\n    new ListSpeedSearch(list);\n\n    Window window = null;\n\n    Component focusedComponent = WindowManagerEx.getInstanceEx().getFocusedComponent(project);\n    if (focusedComponent != null) {\n      if (focusedComponent instanceof Window) {\n        window = (Window)focusedComponent;\n      }\n      else {\n        window = SwingUtilities.getWindowAncestor(focusedComponent);\n      }\n    }\n    if (window == null) {\n      window = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow();\n    }\n\n    Rectangle r;\n    if (window != null) {\n      r = window.getBounds();\n    }\n    else {\n      r = WindowManagerEx.getInstanceEx().getScreenBounds();\n    }\n\n    ListPopup popup = new ListPopup(VcsBundle.message(\"lookup.title.vcs.file.revisions\"), createListMainPanel(list),list, runnable, project);\n\n    if (model.getSize() > 0) {\n      Dimension listPreferredSize = list.getPreferredSize();\n      list.setVisibleRowCount(0);\n      Dimension viewPreferredSize = new Dimension(listPreferredSize.width, Math.min(listPreferredSize.height, r.height - 20));\n      final Container parent = list.getParent();\n      if (parent instanceof JComponent) {\n        ((JComponent)parent).setPreferredSize(viewPreferredSize);\n      }\n    }\n\n    popup.getWindow().pack();\n    Dimension popupSize = popup.getSize();\n    int x = r.x + r.width / 2 - popupSize.width / 2;\n    int y = r.y + r.height / 2 - popupSize.height / 2;\n\n    popup.show(x, y);\n  }","id":83129,"modified_method":"private void showListPopup(final List<VcsFileRevision> revisions, final AbstractVcs vcs, final VirtualFile file, final Project project) {\n    final DefaultListModel model = new DefaultListModel();\n    for (final VcsFileRevision revision : revisions) {\n      model.addElement(revision);\n    }\n    final JList list = new JList(model);\n    list.setCellRenderer(new VcsRevisionListCellRenderer());\n    Runnable runnable = new Runnable() {\n      public void run() {\n        int index = list.getSelectedIndex();\n        if (index == -1 || index >= list.getModel().getSize()) {\n          return;\n        }\n        VcsFileRevision revision = (VcsFileRevision)list.getSelectedValue();\n        AbstractShowDiffAction.showDiff(vcs.getDiffProvider(), revision.getRevisionNumber(),\n                                        file, project);\n      }\n    };\n\n    if (list.getModel().getSize() == 0) {\n      list.clearSelection();\n    }\n    new ListSpeedSearch(list);\n\n    Window window = null;\n\n    Component focusedComponent = WindowManagerEx.getInstanceEx().getFocusedComponent(project);\n    if (focusedComponent != null) {\n      if (focusedComponent instanceof Window) {\n        window = (Window)focusedComponent;\n      }\n      else {\n        window = SwingUtilities.getWindowAncestor(focusedComponent);\n      }\n    }\n    if (window == null) {\n      window = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow();\n    }\n\n    Rectangle r;\n    if (window != null) {\n      r = window.getBounds();\n    }\n    else {\n      r = WindowManagerEx.getInstanceEx().getScreenBounds();\n    }\n\n    ListPopup popup = new ListPopup(VcsBundle.message(\"lookup.title.vcs.file.revisions\"), createListMainPanel(list),list, runnable, project);\n\n    if (model.getSize() > 0) {\n      Dimension listPreferredSize = list.getPreferredSize();\n      list.setVisibleRowCount(0);\n      Dimension viewPreferredSize = new Dimension(listPreferredSize.width, Math.min(listPreferredSize.height, r.height - 20));\n      final Container parent = list.getParent();\n      if (parent instanceof JComponent) {\n        //noinspection RedundantCast\n        ((JComponent)parent).setPreferredSize(viewPreferredSize);\n      }\n    }\n\n    popup.getWindow().pack();\n    Dimension popupSize = popup.getSize();\n    int x = r.x + r.width / 2 - popupSize.width / 2;\n    int y = r.y + r.height / 2 - popupSize.height / 2;\n\n    popup.show(x, y);\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showTreePopup(final List<TreeItem<VcsFileRevision>> roots, final VirtualFile file, final Project project, final DiffProvider diffProvider) {\n    final TreeTableView treeTable = new TreeTableView(new ListTreeTableModelOnColumns(new TreeNodeAdapter(null, null, roots), \n                                                                                      new ColumnInfo[]{BRANCH_COLUMN, REVISION_COLUMN,\n                                                                                      DATE_COLUMN, AUTHOR_COLUMN}));\n    Runnable runnable = new Runnable() {\n      public void run() {\n        int index = treeTable.getSelectionModel().getMinSelectionIndex();\n        if (index == -1) {\n          return;\n        }\n        VcsFileRevision revision = getRevisionAt(treeTable, index);\n        AbstractShowDiffAction.showDiff(diffProvider, revision.getRevisionNumber(),\n                                        file, project);\n      }\n    };\n\n    Window window = null;\n\n    Component focusedComponent = WindowManagerEx.getInstanceEx().getFocusedComponent(project);\n    if (focusedComponent != null) {\n      if (focusedComponent instanceof Window) {\n        window = (Window)focusedComponent;\n      }\n      else {\n        window = SwingUtilities.getWindowAncestor(focusedComponent);\n      }\n    }\n    if (window == null) {\n      window = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow();\n    }\n\n    Rectangle r;\n    if (window != null) {\n      r = window.getBounds();\n    }\n    else {\n      r = WindowManagerEx.getInstanceEx().getScreenBounds();\n    }\n    TreeUtil.expandAll(treeTable.getTree());\n\n\n    TreeTablePopup popup = new TreeTablePopup(VcsBundle.message(\"lookup.title.vcs.file.revisions\"), createMainPanel(treeTable),treeTable, runnable, project);\n\n    popup.getWindow().pack();\n    Dimension popupSize = popup.getSize();\n    int x = r.x + r.width / 2 - popupSize.width / 2;\n    int y = r.y + r.height / 2 - popupSize.height / 2;\n\n    popup.show(x, y);\n    \n  }","id":83130,"modified_method":"private void showTreePopup(final List<TreeItem<VcsFileRevision>> roots, final VirtualFile file, final Project project, final DiffProvider diffProvider) {\n    final TreeTableView treeTable = new TreeTableView(new ListTreeTableModelOnColumns(new TreeNodeAdapter(null, null, roots),\n                                                                                      new ColumnInfo[]{BRANCH_COLUMN, REVISION_COLUMN,\n                                                                                      DATE_COLUMN, AUTHOR_COLUMN}));\n    Runnable runnable = new Runnable() {\n      public void run() {\n        int index = treeTable.getSelectionModel().getMinSelectionIndex();\n        if (index == -1) {\n          return;\n        }\n        VcsFileRevision revision = getRevisionAt(treeTable, index);\n        if (revision != null) {\n          AbstractShowDiffAction.showDiff(diffProvider, revision.getRevisionNumber(),\n                                          file, project);\n        }\n      }\n    };\n\n    Window window = null;\n\n    Component focusedComponent = WindowManagerEx.getInstanceEx().getFocusedComponent(project);\n    if (focusedComponent != null) {\n      if (focusedComponent instanceof Window) {\n        window = (Window)focusedComponent;\n      }\n      else {\n        window = SwingUtilities.getWindowAncestor(focusedComponent);\n      }\n    }\n    if (window == null) {\n      window = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusedWindow();\n    }\n\n    Rectangle r;\n    if (window != null) {\n      r = window.getBounds();\n    }\n    else {\n      r = WindowManagerEx.getInstanceEx().getScreenBounds();\n    }\n    TreeUtil.expandAll(treeTable.getTree());\n\n\n    TreeTablePopup popup = new TreeTablePopup(VcsBundle.message(\"lookup.title.vcs.file.revisions\"), createMainPanel(treeTable),treeTable, runnable, project);\n\n    popup.getWindow().pack();\n    Dimension popupSize = popup.getSize();\n    int x = r.x + r.width / 2 - popupSize.width / 2;\n    int y = r.y + r.height / 2 - popupSize.height / 2;\n\n    popup.show(x, y);\n\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void actionPerformed(VcsContext vcsContext) {\n    final VirtualFile file = vcsContext.getSelectedFiles()[0];\n    final Project project = vcsContext.getProject();\n    final AbstractVcs vcs = ProjectLevelVcsManager.getInstance(project).getVcsFor(file);\n    final VcsHistoryProvider vcsHistoryProvider = vcs.getVcsHistoryProvider();\n\n    try {\n      final VcsHistorySession session = vcsHistoryProvider.createSessionFor(new FilePathImpl(file));\n      final List<VcsFileRevision> revisions = session.getRevisionList();\n      final HistoryAsTreeProvider treeHistoryProvider = vcsHistoryProvider.getTreeHistoryProvider();\n      if (treeHistoryProvider != null) {\n        showTreePopup(treeHistoryProvider.createTreeOn(revisions), file, project, vcs.getDiffProvider());        \n      }\n      else {\n        showListPopup(revisions, vcs, file, project);\n      }\n\n    }\n    catch (VcsException e1) {\n      e1.printStackTrace();\n    }\n\n\n  }","id":83131,"modified_method":"protected void actionPerformed(VcsContext vcsContext) {\n    final VirtualFile file = vcsContext.getSelectedFiles()[0];\n    final Project project = vcsContext.getProject();\n    final AbstractVcs vcs = ProjectLevelVcsManager.getInstance(project).getVcsFor(file);\n    final VcsHistoryProvider vcsHistoryProvider = vcs.getVcsHistoryProvider();\n\n    try {\n      final VcsHistorySession session = vcsHistoryProvider.createSessionFor(new FilePathImpl(file));\n      final List<VcsFileRevision> revisions = session.getRevisionList();\n      final HistoryAsTreeProvider treeHistoryProvider = vcsHistoryProvider.getTreeHistoryProvider();\n      if (treeHistoryProvider != null) {\n        showTreePopup(treeHistoryProvider.createTreeOn(revisions), file, project, vcs.getDiffProvider());\n      }\n      else {\n        showListPopup(revisions, vcs, file, project);\n      }\n\n    }\n    catch (VcsException e1) {\n      Messages.showErrorDialog(VcsBundle.message(\"message.text.cannot.show.differences\"), CommonBundle.message(\"title.error\"));\n    }\n\n\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private VcsFileRevision getRevisionAt(final TreeTableView treeTable, final int index) {\n    return ((TreeNodeAdapter)treeTable.getItems().get(index)).getRevision();\n  }","id":83132,"modified_method":"@Nullable private VcsFileRevision getRevisionAt(final TreeTableView treeTable, final int index) {\n    final List items = treeTable.getItems();\n    if (items.size() <= index) {\n      return null;\n    } else {\n      return ((TreeNodeAdapter)items.get(index)).getRevision();\n    }\n\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TreeNodeAdapter(TreeNodeAdapter parent, TreeItem<VcsFileRevision> revision, List<TreeItem<VcsFileRevision>> children) {\n      if (parent != null) {\n        parent.add(this);\n      }\n      myRevision = revision;\n      for (Iterator<TreeItem<VcsFileRevision>> iterator = children.iterator(); iterator.hasNext();) {\n        TreeItem<VcsFileRevision> treeItem = iterator.next();\n        new TreeNodeAdapter(this, treeItem, treeItem.getChildren());\n      }\n    }","id":83133,"modified_method":"public TreeNodeAdapter(TreeNodeAdapter parent, TreeItem<VcsFileRevision> revision, List<TreeItem<VcsFileRevision>> children) {\n      if (parent != null) {\n        parent.add(this);\n      }\n      myRevision = revision;\n      for (TreeItem<VcsFileRevision> treeItem : children) {\n        new TreeNodeAdapter(this, treeItem, treeItem.getChildren());\n      }\n    }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JPanel createMainPanel(final TreeTableView treeTable) {\n    JScrollPane scrollPane = new JScrollPane(treeTable);\n    treeTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    scrollPane.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));\n    \n    treeTable.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n\n    if (treeTable.getRowCount() >= 20) {\n      scrollPane.getViewport().setPreferredSize(new Dimension(treeTable.getPreferredScrollableViewportSize().width, 300));\n    }\n    else {\n      scrollPane.getViewport().setPreferredSize(treeTable.getPreferredSize());\n    }\n    \n    JPanel panel = new JPanel(new BorderLayout());\n    panel.add(scrollPane, BorderLayout.CENTER);\n    final JTextArea textArea = createTextArea();\n    treeTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        final int index = treeTable.getSelectionModel().getMinSelectionIndex();\n        if (index == -1) {\n          textArea.setText(\"\");\n        } else {\n          final VcsFileRevision revision = getRevisionAt(treeTable, index);\n          textArea.setText(revision.getCommitMessage());\n        }\n      }\n    });\n    final JScrollPane textScrollPane = new JScrollPane(textArea);\n    panel.add(textScrollPane, BorderLayout.SOUTH);\n    textScrollPane.setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(Color.lightGray),VcsBundle.message(\"border.selected.revision.commit.message\")));\n    return panel;\n  }","id":83134,"modified_method":"private JPanel createMainPanel(final TreeTableView treeTable) {\n    JScrollPane scrollPane = new JScrollPane(treeTable);\n    treeTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    scrollPane.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));\n\n    treeTable.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));\n\n    if (treeTable.getRowCount() >= 20) {\n      scrollPane.getViewport().setPreferredSize(new Dimension(treeTable.getPreferredScrollableViewportSize().width, 300));\n    }\n    else {\n      scrollPane.getViewport().setPreferredSize(treeTable.getPreferredSize());\n    }\n\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.add(scrollPane, BorderLayout.CENTER);\n    final JTextArea textArea = createTextArea();\n    treeTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        final int index = treeTable.getSelectionModel().getMinSelectionIndex();\n        if (index == -1) {\n          textArea.setText(\"\");\n        } else {\n          final VcsFileRevision revision = getRevisionAt(treeTable, index);\n          if (revision != null) {\n            textArea.setText(revision.getCommitMessage());\n          } else {\n            textArea.setText(\"\");\n          }\n        }\n      }\n    });\n    final JScrollPane textScrollPane = new JScrollPane(textArea);\n    panel.add(textScrollPane, BorderLayout.SOUTH);\n    textScrollPane.setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(Color.lightGray),VcsBundle.message(\"border.selected.revision.commit.message\")));\n    return panel;\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Collection execute(){\n    for (int i = 0; i < myFiles.length; i++) {\n      File file = myFiles[i];\n      LOG.assertTrue(file.isDirectory() || file.isFile() || file.getParentFile().isDirectory(), file.getAbsolutePath());\n      String fileAbsolutePath = file.getAbsolutePath();\n      String filePath = fileAbsolutePath.equals(myRootPath) ? \"/\" : fileAbsolutePath.substring(myRootPath.length() + 1);\n      File relativeFile =  new File(filePath);\n      myResult.add(createAbstractFileObject(relativeFile.getParentFile(), relativeFile, file.isDirectory()));\n    }\n\n    return myResult;\n  }","id":83135,"modified_method":"public Collection execute(){\n    for (File file : myFiles) {\n      if (file.isDirectory() || ! file.isFile() || !file.getParentFile().isDirectory()) {\n        String fileAbsolutePath = file.getAbsolutePath();\n        String filePath = fileAbsolutePath.equals(myRootPath) ? \"/\" : fileAbsolutePath.substring(myRootPath.length() + 1);\n        File relativeFile = new File(filePath);\n        myResult.add(createAbstractFileObject(relativeFile.getParentFile(), relativeFile, file.isDirectory()));\n      }\n    }\n\n    return myResult;\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n    myColumnInfos[columnIndex].setValue(myItems.get(rowIndex), aValue);\n  }","id":83136,"modified_method":"public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n    if (rowIndex < myItems.size()) {\n      myColumnInfos[columnIndex].setValue(myItems.get(rowIndex), aValue);\n    }\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InputStream createLoggingInputStream(final InputStream inputStream) {\n    return new InputStream() {\n      public int read() throws IOException {\n        int result = inputStream.read();\n        getInputLogStream().write(result);\n        getInputLogStream().flush();\n        return result;\n      }\n\n      public void close() throws IOException {\n        myCloseCount++;\n        if (myCloseCount == 2) {\n          myLogOutput.close();\n          myLogOutput = null;\n          myCloseCount = 0;\n        }\n      }\n\n      public int read(byte b[], int off, int len) throws IOException {\n        if (len == 0) return 0;\n        final int read = read();\n        if (read == -1) return -1;\n        b[off] = (byte)read;\n        return 1;\n      }\n    };\n  }","id":83137,"modified_method":"public InputStream createLoggingInputStream(final InputStream inputStream) {\n    return new InputStream() {\n      public int read() throws IOException {\n        int result = inputStream.read();\n        getInputLogStream().write(result);\n        getInputLogStream().flush();\n        return result;\n      }\n\n      public void close() throws IOException {\n        myCloseCount++;\n        if (myCloseCount == 2 && myLogOutput != null) {\n          myLogOutput.close();\n          myLogOutput = null;\n          myCloseCount = 0;\n        }\n      }\n\n      public int read(byte[] b, int off, int len) throws IOException {\n        if (len == 0) return 0;\n        final int read = read();\n        if (read == -1) return -1;\n        b[off] = (byte)read;\n        return 1;\n      }\n    };\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int calcLineNumber(LineStatusTracker tracker, int currentNumber){\n    if (tracker == null) return -1;\n    List ranges = tracker.getRanges();\n    int result = currentNumber;\n\n    for (Iterator each = ranges.iterator(); each.hasNext();) {\n      Range range = (Range) each.next();\n      int startOffset = range.getOffset1();\n      int endOffset = range.getOffset2();\n\n      if ((startOffset <= currentNumber) && (endOffset > currentNumber)) {\n        return ABSENT_LINE_NUMBER;\n      }\n\n      if (endOffset > currentNumber) return result;\n\n      int currentRangeLength = endOffset - startOffset;\n\n      result += range.getUpToDateRangeLength() - currentRangeLength;\n    }\n    return result;\n\n  }","id":83138,"modified_method":"private static int calcLineNumber(LineStatusTracker tracker, int currentNumber){\n    if (tracker == null) return -1;\n    List ranges = tracker.getRanges();\n    int result = currentNumber;\n\n    for (final Object range1 : ranges) {\n      Range range = (Range)range1;\n      int startOffset = range.getOffset1();\n      int endOffset = range.getOffset2();\n\n      if ((startOffset <= currentNumber) && (endOffset > currentNumber)) {\n        return ABSENT_LINE_NUMBER;\n      }\n\n      if (endOffset > currentNumber) return result;\n\n      int currentRangeLength = endOffset - startOffset;\n\n      result += range.getUpToDateRangeLength() - currentRangeLength;\n    }\n    return result;\n\n  }","commit_id":"11a4a9dea4547ae6d4e66da7bb34f73ab60933c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Collection<Item> getSelection() {\n    ArrayList<Item> result = new ArrayList<Item>();\n    int[] selectedRows = getSelectedRows();\n    if (selectedRows == null) return result;\n    for (int selectedRow : selectedRows) {\n      result.add(getItems().get(selectedRow));\n    }\n    return result;\n  }","id":83139,"modified_method":"public Collection<Item> getSelection() {\n    ArrayList<Item> result = new ArrayList<Item>();\n    int[] selectedRows = getSelectedRows();\n    if (selectedRows == null) return result;\n    final List<Item> items = getItems();\n    for (int selectedRow : selectedRows) {\n      if (selectedRow >= 0 && selectedRow < items.size()) {\n        result.add(items.get(selectedRow));\n      }\n    }\n    return result;\n  }","commit_id":"204bdbae01595dd218ded86d65b19728811c8753","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n   * Returns the remote network address in the format <ip>:<port>.\r\n   */\r\n  public String getRemoteAddress() {\r\n    final Socket socket = getProtocol().getChannel().socket;\r\n    if (socket != null) {\r\n      final InetSocketAddress remoteAddress = (InetSocketAddress) socket.getRemoteSocketAddress();\r\n      return remoteAddress.getAddress().getHostAddress() + \":\" + remoteAddress.getPort();\r\n    }\r\n    return null;\r\n  }","id":83140,"modified_method":"/**\r\n   * Returns the remote network address in the format <ip>:<port>.\r\n   */\r\n  public String getRemoteAddress() {\r\n    Socket socket = null;\r\n    if (getProtocol() != null) {\r\n      socket = getProtocol().getChannel().socket;\r\n    } else {\r\n      for (ONetworkProtocol protocol : this.protocols) {\r\n        socket = protocol.getChannel().socket;\r\n        if (socket != null)\r\n          break;\r\n      }\r\n    }\r\n\r\n    if (socket != null) {\r\n      final InetSocketAddress remoteAddress = (InetSocketAddress) socket.getRemoteSocketAddress();\r\n      return remoteAddress.getAddress().getHostAddress() + \":\" + remoteAddress.getPort();\r\n    }\r\n    return null;\r\n  }","commit_id":"6a4e7ce0c36e622d46c72650339c49bde3874568","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void removeConnectFromSession(OClientConnection connection) {\r\n    if (connection.getProtocol() instanceof ONetworkProtocolBinary) {\r\n      byte[] tokenBytes = connection.getTokenBytes();\r\n      OHashToken hashToken = new OHashToken(tokenBytes);\r\n      synchronized (sessions) {\r\n        OClientSessions sess = sessions.get(hashToken);\r\n        if (sess != null) {\r\n          sess.removeConnection(connection);\r\n          if (!sess.isActive()) {\r\n            sessions.remove(hashToken);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }","id":83141,"modified_method":"private void removeConnectionFromSession(OClientConnection connection) {\r\n    if (connection.getProtocol() instanceof ONetworkProtocolBinary) {\r\n      byte[] tokenBytes = connection.getTokenBytes();\r\n      OHashToken hashToken = new OHashToken(tokenBytes);\r\n      synchronized (sessions) {\r\n        OClientSessions sess = sessions.get(hashToken);\r\n        if (sess != null) {\r\n          sess.removeConnection(connection);\r\n          if (!sess.isActive()) {\r\n            sessions.remove(hashToken);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }","commit_id":"6a4e7ce0c36e622d46c72650339c49bde3874568","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void disconnect(final OClientConnection iConnection) {\r\n    OLogManager.instance().debug(this, \"Disconnecting connection %s...\", iConnection);\r\n    OServerPluginHelper.invokeHandlerCallbackOnClientDisconnection(server, iConnection);\r\n    removeConnectFromSession(iConnection);\r\n    iConnection.close();\r\n\r\n    int totalRemoved = 0;\r\n    for (Entry<Integer, OClientConnection> entry : new HashMap<Integer, OClientConnection>(connections).entrySet()) {\r\n      final OClientConnection conn = entry.getValue();\r\n      if (conn != null && conn.equals(iConnection)) {\r\n        connections.remove(entry.getKey());\r\n        totalRemoved++;\r\n      }\r\n    }\r\n\r\n    OLogManager.instance().debug(this, \"Disconnected connection %s found %d channels\", iConnection, totalRemoved);\r\n\r\n  }","id":83142,"modified_method":"public void disconnect(final OClientConnection iConnection) {\r\n    OLogManager.instance().debug(this, \"Disconnecting connection %s...\", iConnection);\r\n    OServerPluginHelper.invokeHandlerCallbackOnClientDisconnection(server, iConnection);\r\n    removeConnectionFromSession(iConnection);\r\n    iConnection.close();\r\n\r\n    int totalRemoved = 0;\r\n    for (Entry<Integer, OClientConnection> entry : new HashMap<Integer, OClientConnection>(connections).entrySet()) {\r\n      final OClientConnection conn = entry.getValue();\r\n      if (conn != null && conn.equals(iConnection)) {\r\n        connections.remove(entry.getKey());\r\n        totalRemoved++;\r\n      }\r\n    }\r\n\r\n    OLogManager.instance().debug(this, \"Disconnected connection %s found %d channels\", iConnection, totalRemoved);\r\n\r\n  }","commit_id":"6a4e7ce0c36e622d46c72650339c49bde3874568","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void shutdown() {\r\n    timerTask.cancel();\r\n\r\n    final Iterator<Entry<Integer, OClientConnection>> iterator = connections.entrySet().iterator();\r\n    while (iterator.hasNext()) {\r\n      final Entry<Integer, OClientConnection> entry = iterator.next();\r\n\r\n      final ONetworkProtocol protocol = entry.getValue().getProtocol();\r\n\r\n      protocol.sendShutdown();\r\n\r\n      OLogManager.instance().debug(this, \"Sending shutdown to thread %s\", protocol);\r\n\r\n      OCommandRequestText command = entry.getValue().getData().command;\r\n      if (command != null && command.isIdempotent()) {\r\n        protocol.interrupt();\r\n      } else {\r\n        if (protocol instanceof ONetworkProtocolBinary\r\n            && ((ONetworkProtocolBinary) protocol).getRequestType() == OChannelBinaryProtocol.REQUEST_SHUTDOWN) {\r\n          continue;\r\n        }\r\n\r\n        final Socket socket;\r\n        if (protocol == null || protocol.getChannel() == null)\r\n          socket = null;\r\n        else\r\n          socket = protocol.getChannel().socket;\r\n\r\n        if (socket != null && !socket.isClosed() && !socket.isInputShutdown()) {\r\n          try {\r\n            OLogManager.instance().debug(this, \"Closing input socket of thread %s\", protocol);\r\n            socket.shutdownInput();\r\n          } catch (IOException e) {\r\n            OLogManager.instance()\r\n                .debug(this, \"Error on closing connection of %s client during shutdown\", e, entry.getValue().getRemoteAddress());\r\n          }\r\n        }\r\n        if (protocol.isAlive()) {\r\n          if (protocol instanceof ONetworkProtocolBinary && ((ONetworkProtocolBinary) protocol).getRequestType() == -1) {\r\n            try {\r\n              OLogManager.instance().debug(this, \"Closing socket of thread %s\", protocol);\r\n              protocol.getChannel().close();\r\n            } catch (Exception e) {\r\n              OLogManager.instance().debug(this, \"Error during chanel close at shutdown\", e);\r\n            }\r\n            OLogManager.instance().debug(this, \"Sending interrupt signal to thread %s\", protocol);\r\n            protocol.interrupt();\r\n          }\r\n\r\n          // protocol.join();\r\n        }\r\n      }\r\n    }\r\n  }","id":83143,"modified_method":"public void shutdown() {\r\n    timerTask.cancel();\r\n\r\n    final Iterator<Entry<Integer, OClientConnection>> iterator = connections.entrySet().iterator();\r\n    while (iterator.hasNext()) {\r\n      final Entry<Integer, OClientConnection> entry = iterator.next();\r\n\r\n      final ONetworkProtocol protocol = entry.getValue().getProtocol();\r\n\r\n      if(protocol != null)\r\n        protocol.sendShutdown();\r\n\r\n      OLogManager.instance().debug(this, \"Sending shutdown to thread %s\", protocol);\r\n\r\n      OCommandRequestText command = entry.getValue().getData().command;\r\n      if (command != null && command.isIdempotent()) {\r\n        protocol.interrupt();\r\n      } else {\r\n        if (protocol instanceof ONetworkProtocolBinary\r\n            && ((ONetworkProtocolBinary) protocol).getRequestType() == OChannelBinaryProtocol.REQUEST_SHUTDOWN) {\r\n          continue;\r\n        }\r\n\r\n        final Socket socket;\r\n        if (protocol == null || protocol.getChannel() == null)\r\n          socket = null;\r\n        else\r\n          socket = protocol.getChannel().socket;\r\n\r\n        if (socket != null && !socket.isClosed() && !socket.isInputShutdown()) {\r\n          try {\r\n            OLogManager.instance().debug(this, \"Closing input socket of thread %s\", protocol);\r\n            socket.shutdownInput();\r\n          } catch (IOException e) {\r\n            OLogManager.instance()\r\n                .debug(this, \"Error on closing connection of %s client during shutdown\", e, entry.getValue().getRemoteAddress());\r\n          }\r\n        }\r\n        if (protocol.isAlive()) {\r\n          if (protocol instanceof ONetworkProtocolBinary && ((ONetworkProtocolBinary) protocol).getRequestType() == -1) {\r\n            try {\r\n              OLogManager.instance().debug(this, \"Closing socket of thread %s\", protocol);\r\n              protocol.getChannel().close();\r\n            } catch (Exception e) {\r\n              OLogManager.instance().debug(this, \"Error during chanel close at shutdown\", e);\r\n            }\r\n            OLogManager.instance().debug(this, \"Sending interrupt signal to thread %s\", protocol);\r\n            protocol.interrupt();\r\n          }\r\n\r\n          // protocol.join();\r\n        }\r\n      }\r\n    }\r\n  }","commit_id":"6a4e7ce0c36e622d46c72650339c49bde3874568","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OClusterDiscoveryListener(final OClusterNode iClusterNode, final OServerNetworkListener iNetworkListener) {\n    super(OServer.getThreadGroup(), \"DiscoveryListener\");\n\n    clusterNode = iClusterNode;\n    binaryNetworkListener = iNetworkListener;\n\n    OLogManager.instance().info(\n        this,\n        \"Listening for cluster nodes on IP multicast \" + iClusterNode.configNetworkMulticastAddress + \":\"\n            + iClusterNode.configNetworkMulticastPort);\n\n    dgram = new DatagramPacket(recvBuffer, recvBuffer.length);\n    try {\n      socket = new MulticastSocket(iClusterNode.configNetworkMulticastPort);\n      socket.joinGroup(iClusterNode.configNetworkMulticastAddress);\n    } catch (IOException e) {\n      OLogManager.instance().error(this, \"Can't startup cluster discovery listener\", e);\n    }\n\n    start();\n  }","id":83144,"modified_method":"public OClusterDiscoveryListener(final OClusterNode iClusterNode, final OServerNetworkListener iNetworkListener) {\n    super(OServer.getThreadGroup(), \"DiscoveryListener\");\n\n    clusterNode = iClusterNode;\n    binaryNetworkListener = iNetworkListener;\n\n    OLogManager.instance().info(\n        this,\n        \"Listening for cluster nodes on IP multicast \" + iClusterNode.networkMulticastAddress + \":\"\n            + iClusterNode.networkMulticastPort);\n\n    dgram = new DatagramPacket(recvBuffer, recvBuffer.length);\n    try {\n      socket = new MulticastSocket(iClusterNode.networkMulticastPort);\n      socket.joinGroup(iClusterNode.networkMulticastAddress);\n    } catch (IOException e) {\n      OLogManager.instance().error(this, \"Can't startup cluster discovery listener\", e);\n    }\n\n    start();\n  }","commit_id":"f6385d87bfb7a2ac5f2593bb9da4d14776cf5d50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OClusterDiscoverySignaler(final OClusterNode iClusterNode, final OServerNetworkListener iNetworkListener) {\n    super(iClusterNode.configNetworkMulticastHeartbeat * 1000, OServer.getThreadGroup(), \"DiscoverySignaler\");\n\n    String buffer = OClusterNode.PACKET_HEADER + OConstants.ORIENT_VERSION + \"|\" + OClusterNode.PROTOCOL_VERSION + \"|\"\n        + iClusterNode.name + \"|\" + iNetworkListener.getInboundAddr().getHostName() + \"|\"\n        + iNetworkListener.getInboundAddr().getPort();\n\n    discoveryPacket = OSecurityManager.instance().encrypt(iClusterNode.securityAlgorithm, iClusterNode.securityKey,\n        buffer.getBytes());\n\n    try {\n      dgram = new DatagramPacket(discoveryPacket, discoveryPacket.length, iClusterNode.configNetworkMulticastAddress,\n          iClusterNode.configNetworkMulticastPort);\n      socket = new DatagramSocket();\n      start();\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Can't startup cluster discovery signaler\", e);\n    }\n  }","id":83145,"modified_method":"public OClusterDiscoverySignaler(final OClusterNode iClusterNode, final OServerNetworkListener iNetworkListener) {\n    super(iClusterNode.networkMulticastHeartbeat, OServer.getThreadGroup(), \"DiscoverySignaler\");\n\n    String buffer = OClusterNode.PACKET_HEADER + OConstants.ORIENT_VERSION + \"|\" + OClusterNode.PROTOCOL_VERSION + \"|\"\n        + iClusterNode.name + \"|\" + iNetworkListener.getInboundAddr().getHostName() + \"|\"\n        + iNetworkListener.getInboundAddr().getPort();\n\n    discoveryPacket = OSecurityManager.instance().encrypt(iClusterNode.securityAlgorithm, iClusterNode.securityKey,\n        buffer.getBytes());\n\n    try {\n      dgram = new DatagramPacket(discoveryPacket, discoveryPacket.length, iClusterNode.networkMulticastAddress,\n          iClusterNode.networkMulticastPort);\n      socket = new DatagramSocket();\n      start();\n    } catch (Exception e) {\n      OLogManager.instance().error(this, \"Can't startup cluster discovery signaler\", e);\n    }\n  }","commit_id":"f6385d87bfb7a2ac5f2593bb9da4d14776cf5d50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Parse parameters and configure services.\r\n   */\r\n  public void config(final OServer iServer, final OServerParameterConfiguration[] iParams) {\r\n    server = iServer;\r\n\r\n    try {\r\n      name = \"unknown\";\r\n      securityKey = null;\r\n      configNetworkMulticastAddress = InetAddress.getByName(\"235.1.1.1\");\r\n      configNetworkMulticastPort = 2424;\r\n      configNetworkMulticastHeartbeat = 10;\r\n      securityAlgorithm = \"Blowfish\";\r\n      byte[] tempSecurityKey = null;\r\n\r\n      if (iParams != null)\r\n        for (OServerParameterConfiguration param : iParams) {\r\n          if (\"name\".equalsIgnoreCase(param.name))\r\n            name = param.value;\r\n          else if (\"security.algorithm\".equalsIgnoreCase(param.name))\r\n            securityAlgorithm = param.value;\r\n          else if (\"security.key\".equalsIgnoreCase(param.name))\r\n            tempSecurityKey = OBase64Utils.decode(param.value);\r\n          else if (\"network.multicast.address\".equalsIgnoreCase(param.name))\r\n            configNetworkMulticastAddress = InetAddress.getByName(param.value);\r\n          else if (\"network.multicast.port\".equalsIgnoreCase(param.name))\r\n            configNetworkMulticastPort = Integer.parseInt(param.value);\r\n          else if (\"network.multicast.heartbeat\".equalsIgnoreCase(param.name))\r\n            configNetworkMulticastHeartbeat = Integer.parseInt(param.value);\r\n        }\r\n\r\n      if (tempSecurityKey == null) {\r\n        OLogManager.instance().info(this, \"Generating Server security key...\");\r\n        // GENERATE NEW SECURITY KEY\r\n        securityKey = OSecurityManager.instance().generateKey(securityAlgorithm, 96);\r\n\r\n        // CHANGE AND SAVE THE NEW CONFIGURATION\r\n        for (OServerHandlerConfiguration handler : iServer.getConfiguration().handlers) {\r\n          if (handler.clazz.equals(getClass().getName())) {\r\n            handler.parameters = new OServerParameterConfiguration[iParams.length + 1];\r\n            for (int i = 0; i < iParams.length; ++i) {\r\n              handler.parameters[i] = iParams[i];\r\n            }\r\n            handler.parameters[iParams.length] = new OServerParameterConfiguration(\"security.key\",\r\n                OBase64Utils.encodeBytes(securityKey.getEncoded()));\r\n          }\r\n        }\r\n        iServer.saveConfiguration();\r\n\r\n      } else\r\n        // CREATE IT FROM STRING REPRESENTATION\r\n        securityKey = OSecurityManager.instance().createKey(securityAlgorithm, tempSecurityKey);\r\n\r\n    } catch (Exception e) {\r\n      throw new OConfigurationException(\"Can't configure OrientDB Server as Cluster Node\", e);\r\n    }\r\n  }","id":83146,"modified_method":"/**\r\n   * Parse parameters and configure services.\r\n   */\r\n  public void config(final OServer iServer, final OServerParameterConfiguration[] iParams) {\r\n    server = iServer;\r\n\r\n    try {\r\n      name = \"unknown\";\r\n      securityKey = null;\r\n      networkMulticastAddress = InetAddress.getByName(\"235.1.1.1\");\r\n      networkMulticastPort = 2424;\r\n      networkMulticastHeartbeat = 5000;\r\n      networkTimeoutMaster = 10000;\r\n      networkTimeoutConnectionSlaves = 2000;\r\n      securityAlgorithm = \"Blowfish\";\r\n      byte[] tempSecurityKey = null;\r\n\r\n      if (iParams != null)\r\n        for (OServerParameterConfiguration param : iParams) {\r\n          if (\"name\".equalsIgnoreCase(param.name))\r\n            name = param.value;\r\n          else if (\"security.algorithm\".equalsIgnoreCase(param.name))\r\n            securityAlgorithm = param.value;\r\n          else if (\"security.key\".equalsIgnoreCase(param.name))\r\n            tempSecurityKey = OBase64Utils.decode(param.value);\r\n          else if (\"network.multicast.address\".equalsIgnoreCase(param.name))\r\n            networkMulticastAddress = InetAddress.getByName(param.value);\r\n          else if (\"network.multicast.port\".equalsIgnoreCase(param.name))\r\n            networkMulticastPort = Integer.parseInt(param.value);\r\n          else if (\"network.multicast.heartbeat\".equalsIgnoreCase(param.name))\r\n            networkMulticastHeartbeat = Integer.parseInt(param.value);\r\n          else if (\"network.timeout.master\".equalsIgnoreCase(param.name))\r\n            networkTimeoutMaster = Integer.parseInt(param.value);\r\n          else if (\"network.timeout.connectionSlaves\".equalsIgnoreCase(param.name))\r\n            networkTimeoutConnectionSlaves = Integer.parseInt(param.value);\r\n        }\r\n\r\n      if (tempSecurityKey == null) {\r\n        OLogManager.instance().info(this, \"Generating Server security key and save it in configuration...\");\r\n        // GENERATE NEW SECURITY KEY\r\n        securityKey = OSecurityManager.instance().generateKey(securityAlgorithm, 96);\r\n\r\n        // CHANGE AND SAVE THE NEW CONFIGURATION\r\n        for (OServerHandlerConfiguration handler : iServer.getConfiguration().handlers) {\r\n          if (handler.clazz.equals(getClass().getName())) {\r\n            handler.parameters = new OServerParameterConfiguration[iParams.length + 1];\r\n            for (int i = 0; i < iParams.length; ++i) {\r\n              handler.parameters[i] = iParams[i];\r\n            }\r\n            handler.parameters[iParams.length] = new OServerParameterConfiguration(\"security.key\",\r\n                OBase64Utils.encodeBytes(securityKey.getEncoded()));\r\n          }\r\n        }\r\n        iServer.saveConfiguration();\r\n\r\n      } else\r\n        // CREATE IT FROM STRING REPRESENTATION\r\n        securityKey = OSecurityManager.instance().createKey(securityAlgorithm, tempSecurityKey);\r\n\r\n    } catch (Exception e) {\r\n      throw new OConfigurationException(\"Can't configure OrientDB Server as Cluster Node\", e);\r\n    }\r\n  }","commit_id":"f6385d87bfb7a2ac5f2593bb9da4d14776cf5d50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void shutdown() {\r\n    discoverySignaler.sendShutdown();\r\n    discoveryListener.sendShutdown();\r\n  }","id":83147,"modified_method":"public void shutdown() {\r\n    if (discoverySignaler != null)\r\n      discoverySignaler.sendShutdown();\r\n    if (discoveryListener != null)\r\n      discoveryListener.sendShutdown();\r\n  }","commit_id":"f6385d87bfb7a2ac5f2593bb9da4d14776cf5d50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void receivedClusterPresence(final String iServerAddress, final int iServerPort) {\r\n    if (nodes.containsKey(iServerAddress))\r\n      // ALREADY REGISTERED, IGNORE IT\r\n      return;\r\n\r\n    final OClusterNodeInfo info = new OClusterNodeInfo(iServerAddress, iServerPort);\r\n    nodes.put(iServerAddress, info);\r\n\r\n    OLogManager.instance().warn(this, \"Discovered new cluster node %s:%d. Trying to connect...\", iServerAddress, iServerPort);\r\n\r\n  }","id":83148,"modified_method":"public void receivedClusterPresence(final String iServerAddress, final int iServerPort) {\r\n    synchronized (slaves) {\r\n      if (slaves.containsKey(iServerAddress))\r\n        // ALREADY REGISTERED, IGNORE IT\r\n        return;\r\n\r\n      final OClusterSlave slave = new OClusterSlave(this, iServerAddress, iServerPort);\r\n      slaves.put(iServerAddress, slave);\r\n\r\n      OLogManager.instance().warn(this, \"Discovered new cluster node %s:%d. Trying to connect...\", iServerAddress, iServerPort);\r\n\r\n      try {\r\n        slave.connect(networkTimeoutConnectionSlaves);\r\n      } catch (IOException e) {\r\n        OLogManager.instance().error(this, \"Can't connect to cluster slave node: %s:%d\", iServerAddress, iServerPort);\r\n      }\r\n    }\r\n  }","commit_id":"f6385d87bfb7a2ac5f2593bb9da4d14776cf5d50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void startup() {\r\n    // FIND THE BINARY NETWORK LISTENER\r\n    OServerNetworkListener binaryNetworkListener = null;\r\n    for (OServerNetworkListener l : server.getListeners()) {\r\n      if (l.getProtocolType().equals(ONetworkProtocolBinary.class)) {\r\n        binaryNetworkListener = l;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (binaryNetworkListener == null)\r\n      OLogManager.instance().error(this, \"Can't find a configured network listener with binary protocol. Can't start cluster node\",\r\n          null, OConfigurationException.class);\r\n\r\n    discoverySignaler = new OClusterDiscoverySignaler(this, binaryNetworkListener);\r\n    discoveryListener = new OClusterDiscoveryListener(this, binaryNetworkListener);\r\n  }","id":83149,"modified_method":"public void startup() {\r\n    // FIND THE BINARY NETWORK LISTENER\r\n    OServerNetworkListener found = null;\r\n    for (OServerNetworkListener l : server.getListeners()) {\r\n      if (l.getProtocolType().equals(ONetworkProtocolBinary.class)) {\r\n        found = l;\r\n        break;\r\n      }\r\n    }\r\n\r\n    final OServerNetworkListener binaryNetworkListener = found;\r\n\r\n    if (binaryNetworkListener == null)\r\n      OLogManager.instance().error(this, \"Can't find a configured network listener with binary protocol. Can't start cluster node\",\r\n          null, OConfigurationException.class);\r\n\r\n    // START THE SIGNALER AND WAIT FOR A CONNECTION\r\n    discoverySignaler = new OClusterDiscoverySignaler(this, binaryNetworkListener);\r\n    Orient.getTimer().schedule(new TimerTask() {\r\n      @Override\r\n      public void run() {\r\n        synchronized (this) {\r\n          // TIMEOUT: STOP TO SEND PACKETS TO BEING DISCOVERED\r\n          discoverySignaler.sendShutdown();\r\n\r\n          if (master != null)\r\n            // I'M NOT THE MASTER, DO NOTHING\r\n            return;\r\n\r\n          // NO NODE HAS JOINED: BECAME THE MASTER AND LISTEN FOR SLAVES\r\n          startListener(binaryNetworkListener);\r\n        }\r\n      }\r\n    }, networkTimeoutMaster);\r\n  }","commit_id":"f6385d87bfb7a2ac5f2593bb9da4d14776cf5d50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public long[] getClusterDataRange(final int iClusterId) {\r\n    checkConnection();\r\n\r\n    do {\r\n      boolean locked = acquireExclusiveLock();\r\n\r\n      try {\r\n        network.writeByte(OChannelBinaryProtocol.CLUSTER_DATARANGE);\r\n        network.writeShort((short) iClusterId);\r\n        network.flush();\r\n\r\n        readStatus();\r\n        return new long[] { network.readLong(), network.readLong() };\r\n      } catch (Exception e) {\r\n        if (handleException(\"Error on getting last entry position count in cluster: \" + iClusterId, e))\r\n          break;\r\n\r\n      } finally {\r\n        releaseExclusiveLock(locked);\r\n      }\r\n    } while (true);\r\n    return null;\r\n  }","id":83150,"modified_method":"public long[] getClusterDataRange(final int iClusterId) {\r\n    checkConnection();\r\n\r\n    do {\r\n      boolean locked = acquireExclusiveLock();\r\n\r\n      try {\r\n        network.writeByte(OChannelBinaryProtocol.DATACLUSTER_DATARANGE);\r\n        network.writeShort((short) iClusterId);\r\n        network.flush();\r\n\r\n        readStatus();\r\n        return new long[] { network.readLong(), network.readLong() };\r\n      } catch (Exception e) {\r\n        if (handleException(\"Error on getting last entry position count in cluster: \" + iClusterId, e))\r\n          break;\r\n\r\n      } finally {\r\n        releaseExclusiveLock(locked);\r\n      }\r\n    } while (true);\r\n    return null;\r\n  }","commit_id":"f6385d87bfb7a2ac5f2593bb9da4d14776cf5d50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int addCluster(final String iClusterName, final OStorage.CLUSTER_TYPE iClusterType, final Object... iArguments) {\r\n    checkConnection();\r\n\r\n    do {\r\n      boolean locked = acquireExclusiveLock();\r\n\r\n      try {\r\n        network.writeByte(OChannelBinaryProtocol.CLUSTER_ADD);\r\n        network.writeString(iClusterType.toString());\r\n        network.writeString(iClusterName);\r\n\r\n        switch (iClusterType) {\r\n        case PHYSICAL:\r\n          // FILE PATH + START SIZE\r\n          network.writeString(iArguments.length > 0 ? (String) iArguments[0] : \"\").writeInt(\r\n              iArguments.length > 0 ? (Integer) iArguments[1] : -1);\r\n          break;\r\n\r\n        case LOGICAL:\r\n          // PHY CLUSTER ID\r\n          network.writeInt(iArguments.length > 0 ? (Integer) iArguments[0] : -1);\r\n          break;\r\n        }\r\n\r\n        network.flush();\r\n\r\n        readStatus();\r\n\r\n        int clusterId = network.readShort();\r\n        clustersIds.put(iClusterName.toLowerCase(), clusterId);\r\n        clustersTypes.put(iClusterName.toLowerCase(), iClusterType.toString());\r\n        return clusterId;\r\n      } catch (Exception e) {\r\n        if (handleException(\"Error on add new cluster\", e))\r\n          break;\r\n\r\n      } finally {\r\n        releaseExclusiveLock(locked);\r\n      }\r\n    } while (true);\r\n    return 0;\r\n  }","id":83151,"modified_method":"public int addCluster(final String iClusterName, final OStorage.CLUSTER_TYPE iClusterType, final Object... iArguments) {\r\n    checkConnection();\r\n\r\n    do {\r\n      boolean locked = acquireExclusiveLock();\r\n\r\n      try {\r\n        network.writeByte(OChannelBinaryProtocol.DATACLUSTER_ADD);\r\n        network.writeString(iClusterType.toString());\r\n        network.writeString(iClusterName);\r\n\r\n        switch (iClusterType) {\r\n        case PHYSICAL:\r\n          // FILE PATH + START SIZE\r\n          network.writeString(iArguments.length > 0 ? (String) iArguments[0] : \"\").writeInt(\r\n              iArguments.length > 0 ? (Integer) iArguments[1] : -1);\r\n          break;\r\n\r\n        case LOGICAL:\r\n          // PHY CLUSTER ID\r\n          network.writeInt(iArguments.length > 0 ? (Integer) iArguments[0] : -1);\r\n          break;\r\n        }\r\n\r\n        network.flush();\r\n\r\n        readStatus();\r\n\r\n        int clusterId = network.readShort();\r\n        clustersIds.put(iClusterName.toLowerCase(), clusterId);\r\n        clustersTypes.put(iClusterName.toLowerCase(), iClusterType.toString());\r\n        return clusterId;\r\n      } catch (Exception e) {\r\n        if (handleException(\"Error on add new cluster\", e))\r\n          break;\r\n\r\n      } finally {\r\n        releaseExclusiveLock(locked);\r\n      }\r\n    } while (true);\r\n    return 0;\r\n  }","commit_id":"f6385d87bfb7a2ac5f2593bb9da4d14776cf5d50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public long count(final int[] iClusterIds) {\r\n    checkConnection();\r\n\r\n    do {\r\n      boolean locked = acquireExclusiveLock();\r\n\r\n      try {\r\n        network.writeByte(OChannelBinaryProtocol.CLUSTER_COUNT);\r\n        network.writeShort((short) iClusterIds.length);\r\n        for (int i = 0; i < iClusterIds.length; ++i)\r\n          network.writeShort((short) iClusterIds[i]);\r\n        network.flush();\r\n\r\n        readStatus();\r\n        return network.readLong();\r\n      } catch (Exception e) {\r\n        if (handleException(\"Error on read record count in clusters: \" + iClusterIds, e))\r\n          break;\r\n\r\n      } finally {\r\n        releaseExclusiveLock(locked);\r\n      }\r\n    } while (true);\r\n    return -1;\r\n  }","id":83152,"modified_method":"public long count(final int[] iClusterIds) {\r\n    checkConnection();\r\n\r\n    do {\r\n      boolean locked = acquireExclusiveLock();\r\n\r\n      try {\r\n        network.writeByte(OChannelBinaryProtocol.DATACLUSTER_COUNT);\r\n        network.writeShort((short) iClusterIds.length);\r\n        for (int i = 0; i < iClusterIds.length; ++i)\r\n          network.writeShort((short) iClusterIds[i]);\r\n        network.flush();\r\n\r\n        readStatus();\r\n        return network.readLong();\r\n      } catch (Exception e) {\r\n        if (handleException(\"Error on read record count in clusters: \" + iClusterIds, e))\r\n          break;\r\n\r\n      } finally {\r\n        releaseExclusiveLock(locked);\r\n      }\r\n    } while (true);\r\n    return -1;\r\n  }","commit_id":"f6385d87bfb7a2ac5f2593bb9da4d14776cf5d50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean removeCluster(final int iClusterId) {\r\n    checkConnection();\r\n\r\n    do {\r\n      boolean locked = acquireExclusiveLock();\r\n\r\n      try {\r\n        network.writeByte(OChannelBinaryProtocol.CLUSTER_REMOVE);\r\n        network.writeShort((short) iClusterId);\r\n\r\n        network.flush();\r\n\r\n        readStatus();\r\n\r\n        if (network.readByte() == '1') {\r\n          // REMOVE THE CLUSTER LOCALLY\r\n          for (Entry<String, Integer> entry : clustersIds.entrySet())\r\n            if (entry.getValue() != null && entry.getValue().intValue() == iClusterId) {\r\n              clustersIds.remove(entry.getKey());\r\n              clustersTypes.remove(entry.getKey());\r\n              break;\r\n            }\r\n\r\n          return true;\r\n        }\r\n        return false;\r\n      } catch (Exception e) {\r\n        if (handleException(\"Error on removing of cluster\", e))\r\n          break;\r\n\r\n      } finally {\r\n        releaseExclusiveLock(locked);\r\n      }\r\n    } while (true);\r\n    return false;\r\n  }","id":83153,"modified_method":"public boolean removeCluster(final int iClusterId) {\r\n    checkConnection();\r\n\r\n    do {\r\n      boolean locked = acquireExclusiveLock();\r\n\r\n      try {\r\n        network.writeByte(OChannelBinaryProtocol.DATACLUSTER_REMOVE);\r\n        network.writeShort((short) iClusterId);\r\n\r\n        network.flush();\r\n\r\n        readStatus();\r\n\r\n        if (network.readByte() == '1') {\r\n          // REMOVE THE CLUSTER LOCALLY\r\n          for (Entry<String, Integer> entry : clustersIds.entrySet())\r\n            if (entry.getValue() != null && entry.getValue().intValue() == iClusterId) {\r\n              clustersIds.remove(entry.getKey());\r\n              clustersTypes.remove(entry.getKey());\r\n              break;\r\n            }\r\n\r\n          return true;\r\n        }\r\n        return false;\r\n      } catch (Exception e) {\r\n        if (handleException(\"Error on removing of cluster\", e))\r\n          break;\r\n\r\n      } finally {\r\n        releaseExclusiveLock(locked);\r\n      }\r\n    } while (true);\r\n    return false;\r\n  }","commit_id":"f6385d87bfb7a2ac5f2593bb9da4d14776cf5d50","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void initialise() throws InitialisationException\n    {\n        if (getScript() == null) {\n            String extension = getDefaultFileExtension();\n            if (!extension.startsWith(\".\")) {\n                extension = \".\" + extension;\n            }\n            setScript(descriptor.getName() + extension);\n            logger.info(\"script name is not set, using default: \" + descriptor.getName() + extension);\n        }\n        // load script before creating a file monitor so that the script name\n        // can\n        // be monified\n        loadInterpreter(getScript());\n        if (autoReload) {\n            File f = new File(getScript());\n            if (f.exists()) {\n                monitor = new FileMonitor(reloadInterval);\n                monitor.addFile(f);\n                monitor.addListener(this);\n                logger.debug(\"Component script is reloadable\");\n            } else {\n                logger.warn(\"Cannot setup autoreload as the script fie is not on the local file system\");\n            }\n        }\n    }","id":83154,"modified_method":"public void initialise() throws InitialisationException\n    {\n        if (getScript() == null && getScriptText()== null) {\n            String extension = getDefaultFileExtension();\n            if (!extension.startsWith(\".\")) {\n                extension = \".\" + extension;\n            }\n            setScript(descriptor.getName() + extension);\n            logger.info(\"script name is not set, using default: \" + descriptor.getName() + extension);\n        }\n\n        if(getScriptText()!=null) {\n            loadInterpreter(getScriptText());\n        } else {\n            // load script before creating a file monitor so that the script name\n            // can be monified\n            loadInterpreter(getScriptUrl(getScript()));\n        }\n        if (autoReload) {\n            File f = new File(getScript());\n            if (f.exists()) {\n                monitor = new FileMonitor(reloadInterval);\n                monitor.addFile(f);\n                monitor.addListener(this);\n                logger.debug(\"Component script is reloadable\");\n            } else {\n                logger.warn(\"Cannot setup autoreload as the script fie is not on the local file system\");\n            }\n        }\n    }","commit_id":"a55ea8a05979471df7593c9156dc046144278d0b","url":"https://github.com/mulesoft/mule"},{"original_method":"protected abstract void loadInterpreter(String script) throws InitialisationException;","id":83155,"modified_method":"protected abstract void loadInterpreter(String scriptText) throws InitialisationException;","commit_id":"a55ea8a05979471df7593c9156dc046144278d0b","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Loads the script for this component\n     * \n     * @param script the script file location\n     * @throws InitialisationException if anything fails while starting up\n     */\n    protected void loadInterpreter(String script) throws InitialisationException\n    {\n        try {\n            File f = new File(script);\n            if (f.exists()) {\n                fileChanged(f);\n            } else {\n                GroovyClassLoader loader = new GroovyClassLoader(Thread.currentThread().getContextClassLoader());\n                URL url = ClassHelper.getResource(script, getClass());\n                if (url == null) {\n                    throw new InitialisationException(new Message(Messages.FAILED_LOAD_X, \"Groovy script: \" + script),\n                                                      this);\n                }\n                Class groovyClass = loader.parseClass(new GroovyCodeSource(url));\n                component = (GroovyObject) groovyClass.newInstance();\n            }\n        } catch (Exception e) {\n            if (e instanceof InitialisationException)\n                throw (InitialisationException) e;\n            throw new InitialisationException(new Message(Messages.FAILED_LOAD_X, \"Groovy component\"), e, this);\n        }\n    }","id":83156,"modified_method":"/**\n     * Loads the script for this component\n     *\n     * @param scriptText the script text\n     * @throws InitialisationException if anything fails while starting up\n     */\n    protected void loadInterpreter(String scriptText) throws InitialisationException\n    {\n        try {\n            GroovyClassLoader loader = new GroovyClassLoader(Thread.currentThread().getContextClassLoader());\n                Class groovyClass = loader.parseClass(new GroovyCodeSource(scriptText, \"\", \"\"));\n                component = (GroovyObject) groovyClass.newInstance();\n\n        } catch (Exception e) {\n            if (e instanceof InitialisationException)\n                throw (InitialisationException) e;\n            throw new InitialisationException(new Message(Messages.FAILED_LOAD_X, \"Groovy component\"), e, this);\n        }\n    }","commit_id":"a55ea8a05979471df7593c9156dc046144278d0b","url":"https://github.com/mulesoft/mule"},{"original_method":"public void execute(\r\n\t\t\tKaleoAction kaleoAction, ExecutionContext executionContext)\r\n\t\tthrows ActionExecutorException {\r\n\r\n\t\ttry {\r\n\t\t\tList<Fact<?>> facts = RulesContextBuilder.buildRulesContext(\r\n\t\t\t\texecutionContext);\r\n\r\n\t\t\tRulesResourceRetriever rulesResourceRetriever =\r\n\t\t\t\tnew RulesResourceRetriever(\r\n\t\t\t\t\tnew StringResourceRetriever(kaleoAction.getScript()));\r\n\t\t\t\r\n\t\t\tRulesEngineUtil.execute(rulesResourceRetriever, facts,\r\n\t\t\t\t PortalClassLoaderUtil.getClassLoader());\r\n\t\t}\r\n\t\tcatch (Exception e) {\r\n\t\t\tthrow new ActionExecutorException(e);\t\t\t\r\n\t\t}\r\n\t}","id":83157,"modified_method":"public void execute(\n\t\t\tKaleoAction kaleoAction, ExecutionContext executionContext)\n\t\tthrows ActionExecutorException {\n\n\t\ttry {\n\t\t\tdoExecute(kaleoAction, executionContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ActionExecutorException(e);\n\t\t}\n\t}","commit_id":"7d32d33d47275ac16a848c9a479635a75eb8dbef","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public boolean evaluate(\r\n\t\tKaleoCondition kaleoCondition, ExecutionContext executionContext)\r\n\t\t\r\n\t\tthrows SystemException, PortalException {\r\n\t\tList<Fact<?>> facts = RulesContextBuilder.buildRulesContext(\r\n\t\t\texecutionContext);\r\n\r\n\t\tRulesResourceRetriever rulesResourceRetriever =\r\n\t\t\tnew RulesResourceRetriever(\r\n\t\t\t\tnew StringResourceRetriever(kaleoCondition.getScript()));\r\n\r\n\t\t//add return values\r\n\t\tQuery resultsQuery = Query.createStandardQuery();\r\n\r\n\t\tMap<String, ?> ruleResults = RulesEngineUtil.execute(\r\n\t\t\trulesResourceRetriever, facts, resultsQuery, \r\n\t\t\tPortalClassLoaderUtil.getClassLoader());\r\n\r\n\t\tBoolean conditionValue = (Boolean)ruleResults.get(\r\n\t\t\tRETURN_PARAMETER_NAME);\r\n\r\n\t\tif (conditionValue == null) {\r\n\t\t\tif (_log.isWarnEnabled()) {\r\n\t\t\t\t_log.warn(\r\n\t\t\t\t\t\"Conditional script did not return value: \" +\r\n\t\t\t\t\tconditionValue + \": \" + kaleoCondition.getScript());\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\treturn conditionValue;\r\n\t\t\r\n\t}","id":83158,"modified_method":"public boolean evaluate(\n\t\t\tKaleoCondition kaleoCondition, ExecutionContext executionContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tList<Fact<?>> facts = RulesContextBuilder.buildRulesContext(\n\t\t\texecutionContext);\n\n\t\tRulesResourceRetriever rulesResourceRetriever =\n\t\t\tnew RulesResourceRetriever(\n\t\t\t\tnew StringResourceRetriever(kaleoCondition.getScript()));\n\n\t\tQuery query = Query.createStandardQuery();\n\n\t\tMap<String, ?> results = RulesEngineUtil.execute(\n\t\t\trulesResourceRetriever, facts, query,\n\t\t\tPortalClassLoaderUtil.getClassLoader());\n\n\t\tBoolean returnValue = (Boolean)results.get(_RETURN_VALUE);\n\n\t\tif (returnValue != null) {\n\t\t\treturn returnValue;\n\t\t}\n\n\t\tif (_log.isWarnEnabled()) {\n\t\t\t_log.warn(\n\t\t\t\t\"Conditional did not return value for script \" +\n\t\t\t\t\tkaleoCondition.getScript());\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"7d32d33d47275ac16a848c9a479635a75eb8dbef","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static List<Fact<?>> buildRulesContext(\r\n\t\tExecutionContext executionContext)\r\n\t\tthrows SystemException, PortalException {\r\n\r\n\t\tMap<String, Serializable> workflowContext =\r\n\t\t\texecutionContext.getWorkflowContext();\r\n\r\n\t\tif (workflowContext == null) {\r\n\t\t\tKaleoInstanceToken kaleoInstanceToken =\r\n\t\t\t\texecutionContext.getKaleoInstanceToken();\r\n\r\n\t\t\tKaleoInstance kaleoInstance = kaleoInstanceToken.getKaleoInstance();\r\n\r\n\t\t\tworkflowContext = WorkflowContextUtil.convert(\r\n\t\t\t\tkaleoInstance.getWorkflowContext());\r\n\t\t}\r\n\r\n\t\tint factInitializeSize = workflowContext.size() + 4;\r\n\t\t\r\n\t\tList<Fact<?>> facts = new ArrayList<Fact<?>>(factInitializeSize);\r\n\r\n\t\tfacts.add(new Fact<Map<String, Serializable>>(\r\n\t\t\t\"workflowContext\", workflowContext));\r\n\r\n\t\tKaleoTaskInstanceToken kaleoTaskInstanceToken =\r\n\t\t\texecutionContext.getKaleoTaskInstanceToken();\r\n\r\n\t\tif (kaleoTaskInstanceToken != null) {\r\n\t\t\tKaleoTask kaleoTask = kaleoTaskInstanceToken.getKaleoTask();\r\n\r\n\t\t\tfacts.add(new Fact<String>(\"taskName\", kaleoTask.getName()));\r\n\r\n\t\t\tfacts.add(new Fact<Long>(\r\n\t\t\t\t\"userId\", kaleoTaskInstanceToken.getUserId()));\r\n\r\n\t\t\tList<WorkflowTaskAssignee> workflowTaskAssignees =\r\n\t\t\t\tKaleoTaskAssignmentInstanceUtil.getWorkflowTaskAssignees(\r\n\t\t\t\t\tkaleoTaskInstanceToken);\r\n\r\n\t\t\tfacts.add(new Fact<List<WorkflowTaskAssignee>>(\r\n\t\t\t\t\"workflowTaskAssignees\", workflowTaskAssignees));\r\n\t\t}\r\n\t\telse {\r\n\t\t\tKaleoInstanceToken kaleoInstanceToken =\r\n\t\t\t\texecutionContext.getKaleoInstanceToken();\r\n\r\n\t\t\tfacts.add(new Fact<Long>(\r\n\t\t\t\t\"userId\", kaleoTaskInstanceToken.getUserId()));\r\n\t\t}\r\n\r\n\t\treturn facts;\r\n\t}","id":83159,"modified_method":"public static List<Fact<?>> buildRulesContext(\n\t\t\tExecutionContext executionContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMap<String, Serializable> workflowContext =\n\t\t\texecutionContext.getWorkflowContext();\n\n\t\tif (workflowContext == null) {\n\t\t\tKaleoInstanceToken kaleoInstanceToken =\n\t\t\t\texecutionContext.getKaleoInstanceToken();\n\n\t\t\tKaleoInstance kaleoInstance = kaleoInstanceToken.getKaleoInstance();\n\n\t\t\tworkflowContext = WorkflowContextUtil.convert(\n\t\t\t\tkaleoInstance.getWorkflowContext());\n\t\t}\n\n\t\tList<Fact<?>> facts = new ArrayList<Fact<?>>(\n\t\t\tworkflowContext.size() + 4);\n\n\t\tfacts.add(\n\t\t\tnew Fact<Map<String, Serializable>>(\n\t\t\t\t\"workflowContext\", workflowContext));\n\n\t\tKaleoTaskInstanceToken kaleoTaskInstanceToken =\n\t\t\texecutionContext.getKaleoTaskInstanceToken();\n\n\t\tif (kaleoTaskInstanceToken != null) {\n\t\t\tKaleoTask kaleoTask = kaleoTaskInstanceToken.getKaleoTask();\n\n\t\t\tfacts.add(new Fact<String>(\"taskName\", kaleoTask.getName()));\n\n\t\t\tfacts.add(\n\t\t\t\tnew Fact<Long>(\"userId\", kaleoTaskInstanceToken.getUserId()));\n\n\t\t\tList<WorkflowTaskAssignee> workflowTaskAssignees =\n\t\t\t\tKaleoTaskAssignmentInstanceUtil.getWorkflowTaskAssignees(\n\t\t\t\t\tkaleoTaskInstanceToken);\n\n\t\t\tfacts.add(\n\t\t\t\tnew Fact<List<WorkflowTaskAssignee>>(\n\t\t\t\t\t\"workflowTaskAssignees\", workflowTaskAssignees));\n\t\t}\n\t\telse {\n\t\t\tKaleoInstanceToken kaleoInstanceToken =\n\t\t\t\texecutionContext.getKaleoInstanceToken();\n\n\t\t\tfacts.add(new Fact<Long>(\"userId\", kaleoInstanceToken.getUserId()));\n\t\t}\n\n\t\treturn facts;\n\t}","commit_id":"7d32d33d47275ac16a848c9a479635a75eb8dbef","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected abstract void loadInterpreter(String script) throws InitialisationException;","id":83160,"modified_method":"protected abstract void loadInterpreter(String scriptText) throws InitialisationException;","commit_id":"c6239d35a5901f63ea97068a609ce94b76b1b266","url":"https://github.com/mulesoft/mule"},{"original_method":"public void initialise() throws InitialisationException\n    {\n        if (getScript() == null) {\n            String extension = getDefaultFileExtension();\n            if (!extension.startsWith(\".\")) {\n                extension = \".\" + extension;\n            }\n            setScript(descriptor.getName() + extension);\n            logger.info(\"script name is not set, using default: \" + descriptor.getName() + extension);\n        }\n        // load script before creating a file monitor so that the script name\n        // can\n        // be monified\n        loadInterpreter(getScript());\n        if (autoReload) {\n            File f = new File(getScript());\n            if (f.exists()) {\n                monitor = new FileMonitor(reloadInterval);\n                monitor.addFile(f);\n                monitor.addListener(this);\n                logger.debug(\"Component script is reloadable\");\n            } else {\n                logger.warn(\"Cannot setup autoreload as the script fie is not on the local file system\");\n            }\n        }\n    }","id":83161,"modified_method":"public void initialise() throws InitialisationException\n    {\n        if (getScript() == null && getScriptText()== null) {\n            String extension = getDefaultFileExtension();\n            if (!extension.startsWith(\".\")) {\n                extension = \".\" + extension;\n            }\n            setScript(descriptor.getName() + extension);\n            logger.info(\"script name is not set, using default: \" + descriptor.getName() + extension);\n        }\n\n        if(getScriptText()!=null) {\n            loadInterpreter(getScriptText());\n        } else {\n            // load script before creating a file monitor so that the script name\n            // can be monified\n            loadInterpreter(getScriptUrl(getScript()));\n        }\n        if (autoReload) {\n            File f = new File(getScript());\n            if (f.exists()) {\n                monitor = new FileMonitor(reloadInterval);\n                monitor.addFile(f);\n                monitor.addListener(this);\n                logger.debug(\"Component script is reloadable\");\n            } else {\n                logger.warn(\"Cannot setup autoreload as the script fie is not on the local file system\");\n            }\n        }\n    }","commit_id":"c6239d35a5901f63ea97068a609ce94b76b1b266","url":"https://github.com/mulesoft/mule"},{"original_method":"public void handleMaster(Master master) {\n        if (!node.joined() && !thisAddress.equals(master.address)) {\n            logger.log(Level.FINEST, \"Handling master response: \" + master);\n            final Address currentMaster = node.getMasterAddress();\n            if (currentMaster != null && !currentMaster.equals(master.address)) {\n                final Connection conn = node.connectionManager.getConnection(currentMaster);\n                if (conn != null && conn.live()) {\n                    logger.log(Level.FINEST, \"Ignoring master response \" + master +\n                              \" since node has an active master: \" + currentMaster);\n                    return;\n                }\n            }\n            node.setMasterAddress(master.address);\n            final Connection connMaster = node.connectionManager.getOrConnect(master.address);\n            if (connMaster != null) {\n                sendJoinRequest(master.address, true);\n            }\n        }\n    }","id":83162,"modified_method":"public void handleMaster(Master master) {\n        if (!node.joined() && !thisAddress.equals(master.address)) {\n            logger.log(Level.FINEST, \"Handling master response: \" + master);\n            final Address currentMaster = node.getMasterAddress();\n            if (currentMaster != null && !currentMaster.equals(master.address)) {\n                final Connection conn = node.connectionManager.getConnection(currentMaster);\n                if (conn != null && conn.live()) {\n                    logger.log(Level.FINEST, \"Ignoring master response \" + master +\n                              \" since node has an active master: \" + currentMaster);\n                    return;\n                }\n            }\n            node.setMasterAddress(master.address);\n            node.connectionManager.getOrConnect(master.address);\n            if (!sendJoinRequest(master.address, true)) {\n                logger.log(Level.WARNING, \"Could not create connection to possible master \" + master.address);\n            }\n        }\n    }","commit_id":"e952dd7df2f2f355ec62461bfe5a7f24512e5532","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public boolean sendJoinRequest(Address toAddress, boolean withCredentials) {\n        if (toAddress == null) {\n            toAddress = node.getMasterAddress();\n        }\n        return sendProcessableTo(node.createJoinInfo(withCredentials), toAddress);\n    }","id":83163,"modified_method":"public boolean sendJoinRequest(Address toAddress, boolean withCredentials) {\n        if (toAddress == null) {\n            toAddress = node.getMasterAddress();\n        }\n        logger.log(Level.INFO, \"Sending join request to \" + toAddress);\n        final boolean send = sendProcessableTo(node.createJoinInfo(withCredentials), toAddress);\n        if (!send) {\n            logger.log(Level.WARNING, \"Could not send join request to \" + toAddress);\n        }\n        return send;\n    }","commit_id":"e952dd7df2f2f355ec62461bfe5a7f24512e5532","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void process() {\n            final Joiner joiner = getNode().getJoiner();\n            if (joiner instanceof TcpIpJoiner) {\n                TcpIpJoiner tcpIpJoiner = (TcpIpJoiner) joiner;\n                boolean shouldApprove = (!(tcpIpJoiner.askingForApproval || node.isMaster()));\n                getNode().clusterManager.sendProcessableTo(new MasterAnswer(node.getThisAddress(), shouldApprove),\n                                                       getConnection());\n            }\n        }","id":83164,"modified_method":"public void process() {\n            final Joiner joiner = node.getJoiner();\n            final Connection conn = getConnection();\n            final Address endpoint = conn.getEndPoint();\n            boolean shouldApprove = false;\n            if (joiner instanceof TcpIpJoiner) {\n                TcpIpJoiner tcpIpJoiner = (TcpIpJoiner) joiner;\n                final Address masterAddress = node.getMasterAddress();\n                shouldApprove = !tcpIpJoiner.askingForApproval && !node.isMaster()\n                                && (masterAddress == null || masterAddress.equals(endpoint));\n            }\n            node.clusterManager.sendProcessableTo(new MasterAnswer(node.getThisAddress(), shouldApprove), conn);\n        }","commit_id":"e952dd7df2f2f355ec62461bfe5a7f24512e5532","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() {\n        ClusterService cm = (ClusterService) getService();\n        NodeServiceImpl nodeService = (NodeServiceImpl) getNodeService();\n        Node node = nodeService.getNode();\n        ILogger logger = nodeService.getLogger(SetMasterOperation.class.getName());\n        if (!node.joined() && !node.getThisAddress().equals(masterAddress)) {\n            logger.log(Level.FINEST, \"Handling master response: \" + this);\n            final Address currentMaster = node.getMasterAddress();\n            if (currentMaster != null && !currentMaster.equals(masterAddress)) {\n                final Connection conn = node.connectionManager.getConnection(currentMaster);\n                if (conn != null && conn.live()) {\n                    logger.log(Level.FINEST, \"Ignoring master response \" + this +\n                                             \" since node has an active master: \" + currentMaster);\n                    return;\n                }\n            }\n            node.setMasterAddress(masterAddress);\n            final Connection connMaster = node.connectionManager.getOrConnect(masterAddress);\n            if (connMaster != null) {\n                cm.sendJoinRequest(masterAddress, true);\n            }\n        }\n    }","id":83165,"modified_method":"public void run() {\n        ClusterService clusterService = getService();\n        NodeServiceImpl nodeService = (NodeServiceImpl) getNodeService();\n        Node node = nodeService.getNode();\n        ILogger logger = nodeService.getLogger(SetMasterOperation.class.getName());\n        if (!node.joined() && !node.getThisAddress().equals(masterAddress)) {\n            logger.log(Level.FINEST, \"Handling master response: \" + this);\n            final Address currentMaster = node.getMasterAddress();\n            if (currentMaster != null && !currentMaster.equals(masterAddress)) {\n                final Connection conn = node.connectionManager.getConnection(currentMaster);\n                if (conn != null && conn.live()) {\n                    logger.log(Level.FINEST, \"Ignoring master response \" + this +\n                                             \" since node has an active master: \" + currentMaster);\n                    return;\n                }\n            }\n            node.setMasterAddress(masterAddress);\n            node.connectionManager.getOrConnect(masterAddress);\n            if (!clusterService.sendJoinRequest(masterAddress, true)) {\n                logger.log(Level.WARNING, \"Could not create connection to possible master \" + masterAddress);\n            }\n        }\n    }","commit_id":"4bd53a98098288328058eba5aea3d77ac365f802","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() {\n            final NodeServiceImpl nodeService = (NodeServiceImpl) getNodeService();\n            Node node = nodeService.getNode();\n            ResponseHandler responseHandler = getResponseHandler();\n            Joiner joiner = node.getJoiner();\n            boolean approvedAsMaster = false;\n            final ILogger logger = node.getLogger(getClass().getName());\n            if (joiner instanceof TcpIpJoiner) {\n                TcpIpJoiner tcpIpJoiner = (TcpIpJoiner) joiner;\n                approvedAsMaster = !tcpIpJoiner.claimingMaster && !node.isMaster();\n            } else {\n                approvedAsMaster = false;\n                logger.log(Level.WARNING, \"This node requires MulticastJoin strategy!\");\n            }\n            logger.log(Level.FINEST, \"Sending '\" + approvedAsMaster + \"' for master claim of node: \" + getCaller());\n            responseHandler.sendResponse(approvedAsMaster);\n        }","id":83166,"modified_method":"public void run() {\n            final NodeServiceImpl nodeService = (NodeServiceImpl) getNodeService();\n            Node node = nodeService.getNode();\n            ResponseHandler responseHandler = getResponseHandler();\n            Joiner joiner = node.getJoiner();\n            boolean approvedAsMaster = false;\n            final ILogger logger = node.getLogger(getClass().getName());\n            if (joiner instanceof TcpIpJoiner) {\n                TcpIpJoiner tcpIpJoiner = (TcpIpJoiner) joiner;\n                final Address endpoint = getCaller();\n                final Address masterAddress = node.getMasterAddress();\n                approvedAsMaster = !tcpIpJoiner.claimingMaster && !node.isMaster()\n                                   && (masterAddress == null || masterAddress.equals(endpoint));\n            } else {\n                approvedAsMaster = false;\n                logger.log(Level.WARNING, \"This node requires MulticastJoin strategy!\");\n            }\n            logger.log(Level.FINEST, \"Sending '\" + approvedAsMaster + \"' for master claim of node: \" + getCaller());\n            responseHandler.sendResponse(approvedAsMaster);\n        }","commit_id":"4bd53a98098288328058eba5aea3d77ac365f802","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void _unregisterManagedService() {\n\t\t_managedServiceServiceRegistration.unregister();\n\n\t\t_managedServiceServiceRegistration = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Unregistered listener for changes in configurationPid \" +\n\t\t\t\t\tSettingsDefinitionUtil.getConfigurationPid(\n\t\t\t\t\t\t_settingsDefinition));\n\t\t}\n\t}","id":83167,"modified_method":"private void _unregisterManagedService() {\n\t\t_managedServiceServiceRegistration.unregister();\n\n\t\t_managedServiceServiceRegistration = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tString pid = SettingsDefinitionUtil.getConfigurationPid(\n\t\t\t\t_settingsDefinition);\n\n\t\t\t_log.debug(\n\t\t\t\t\"Unregistered listener for changes in configurationPid \" + pid);\n\t\t}\n\t}","commit_id":"580febb199eb2b570c6bda6ffd0fc2436c15d651","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void stop() {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Stopping lifecycle of settings class \" +\n\t\t\t\t\tSettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t\t\t_settingsDefinition));\n\t\t}\n\n\t\t_unregisterSettingsProvider();\n\n\t\t_settingsFactory.unregisterSettingsDefinition(_settingsDefinition);\n\n\t\t_unregisterConfigurationBean();\n\n\t\t_unregisterManagedService();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Stopped lifecycle of settings class \" +\n\t\t\t\t\tSettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t\t\t_settingsDefinition));\n\t\t}\n\t}","id":83168,"modified_method":"public void stop() {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tString className = SettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t_settingsDefinition);\n\n\t\t\t_log.debug(\"Stopping lifecycle of settings class \" + className);\n\t\t}\n\n\t\t_unregisterSettingsProvider();\n\n\t\t_settingsFactory.unregisterSettingsDefinition(_settingsDefinition);\n\n\t\t_unregisterConfigurationBean();\n\n\t\t_unregisterManagedService();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tString className = SettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t_settingsDefinition);\n\n\t\t\t_log.info(\"Stopped lifecycle of settings class \" + className);\n\t\t}\n\t}","commit_id":"580febb199eb2b570c6bda6ffd0fc2436c15d651","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _registerSettingsProvider() {\n\t\tDictionary<String, String> properties = new HashMapDictionary<>();\n\n\t\tproperties.put(\n\t\t\t\"class.name\",\n\t\t\tSettingsDefinitionUtil.getSettingsClassName(_settingsDefinition));\n\n\t\tClass settingsProviderServiceClass =\n\t\t\t_settingsProviderBuilder.getSettingsProviderServiceClass();\n\n\t\t_settingsProviderServiceRegistration = _bundleContext.registerService(\n\t\t\tsettingsProviderServiceClass,\n\t\t\t_settingsProviderBuilder.getSettingsProvider(), properties);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Registered settings provider service \" +\n\t\t\t\t\tsettingsProviderServiceClass.getName() + \"<\" +\n\t\t\t\t\tSettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t\t\t_settingsDefinition) + \">\");\n\t\t}\n\t}","id":83169,"modified_method":"private void _registerSettingsProvider() {\n\t\tDictionary<String, String> properties = new HashMapDictionary<>();\n\n\t\tproperties.put(\n\t\t\t\"class.name\",\n\t\t\tSettingsDefinitionUtil.getSettingsClassName(_settingsDefinition));\n\n\t\tClass settingsProviderServiceClass =\n\t\t\t_settingsProviderBuilder.getSettingsProviderServiceClass();\n\n\t\t_settingsProviderServiceRegistration = _bundleContext.registerService(\n\t\t\tsettingsProviderServiceClass,\n\t\t\t_settingsProviderBuilder.getSettingsProvider(), properties);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tString settingsClassName =\n\t\t\t\tSettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t\t_settingsDefinition);\n\n\t\t\t_log.debug(\n\t\t\t\t\"Registered settings provider service \" +\n\t\t\t\t\tsettingsProviderServiceClass.getName() + \"<\" +\n\t\t\t\t\t\tsettingsClassName + \">\");\n\t\t}\n\t}","commit_id":"580febb199eb2b570c6bda6ffd0fc2436c15d651","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void start() {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Starting lifecycle of settings class \" +\n\t\t\t\t\tSettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t\t\t_settingsDefinition));\n\t\t}\n\n\t\t_registerManagedService();\n\n\t\t_registerConfigurationBean();\n\n\t\t_settingsFactory.registerSettingsDefinition(\n\t\t\t_settingsDefinition,\n\t\t\t_configurationBeanBuilder.getConfigurationBean());\n\n\t\t_registerSettingsProvider();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"Started lifecycle of settings class \" +\n\t\t\t\t\tSettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t\t\t_settingsDefinition));\n\t\t}\n\t}","id":83170,"modified_method":"public void start() {\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tString className = SettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t_settingsDefinition);\n\n\t\t\t_log.debug(\"Starting lifecycle of settings class \" + className);\n\t\t}\n\n\t\t_registerManagedService();\n\n\t\t_registerConfigurationBean();\n\n\t\t_settingsFactory.registerSettingsDefinition(\n\t\t\t_settingsDefinition,\n\t\t\t_configurationBeanBuilder.getConfigurationBean());\n\n\t\t_registerSettingsProvider();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tString className = SettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t_settingsDefinition);\n\n\t\t\t_log.info(\n\t\t\t\t\"Started lifecycle of settings class \" + className);\n\t\t}\n\t}","commit_id":"580febb199eb2b570c6bda6ffd0fc2436c15d651","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SettingsDefinitionLifecycleHandler(\n\t\tSettingsDefinition<S, C> settingsDefinition,\n\t\tBundleContext bundleContext, ConfigurationAdmin configurationAdmin,\n\t\tSettingsFactory settingsFactory) {\n\n\t\t_settingsDefinition = settingsDefinition;\n\n\t\t_bundleContext = bundleContext;\n\t\t_configurationAdmin = configurationAdmin;\n\t\t_settingsFactory = settingsFactory;\n\n\t\tif (GroupServiceSettings.class.isAssignableFrom(\n\t\t\t\tsettingsDefinition.getSettingsClass())) {\n\n\t\t\t_settingsProviderBuilder = new GroupServiceSettingsProviderBuilder(\n\t\t\t\tsettingsDefinition, settingsFactory);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Unable to determine service level for class \" +\n\t\t\t\t\tSettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t\t\tsettingsDefinition));\n\t\t}\n\n\t\t_configurationBeanBuilder = new ConfigurationBeanBuilder<>(\n\t\t\tsettingsDefinition, _getConfigurationProperties());\n\t}","id":83171,"modified_method":"public SettingsDefinitionLifecycleHandler(\n\t\tSettingsDefinition<S, C> settingsDefinition,\n\t\tBundleContext bundleContext, ConfigurationAdmin configurationAdmin,\n\t\tSettingsFactory settingsFactory) {\n\n\t\t_settingsDefinition = settingsDefinition;\n\t\t_bundleContext = bundleContext;\n\t\t_configurationAdmin = configurationAdmin;\n\t\t_settingsFactory = settingsFactory;\n\n\t\tif (GroupServiceSettings.class.isAssignableFrom(\n\t\t\t\tsettingsDefinition.getSettingsClass())) {\n\n\t\t\t_settingsProviderBuilder = new GroupServiceSettingsProviderBuilder(\n\t\t\t\tsettingsDefinition, settingsFactory);\n\t\t}\n\t\telse {\n\t\t\tString className = SettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\tsettingsDefinition);\n\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Unable to determine service level for class \" + className);\n\t\t}\n\n\t\t_configurationBeanBuilder = new ConfigurationBeanBuilder<>(\n\t\t\tsettingsDefinition, _getConfigurationProperties());\n\t}","commit_id":"580febb199eb2b570c6bda6ffd0fc2436c15d651","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _registerConfigurationBean() {\n\t\t_configurationBeanServiceRegistration = _bundleContext.registerService(\n\t\t\t_settingsDefinition.getConfigurationBeanClass(),\n\t\t\t_configurationBeanBuilder.getConfigurationBean(),\n\t\t\t_EMPTY_DICTIONARY);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Registered configuration bean service \" +\n\t\t\t\t\tSettingsDefinitionUtil.getConfigurationBeanClassName(\n\t\t\t\t\t\t_settingsDefinition));\n\t\t}\n\t}","id":83172,"modified_method":"private void _registerConfigurationBean() {\n\t\t_configurationBeanServiceRegistration = _bundleContext.registerService(\n\t\t\t_settingsDefinition.getConfigurationBeanClass(),\n\t\t\t_configurationBeanBuilder.getConfigurationBean(),\n\t\t\t_EMPTY_DICTIONARY);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tString className =\n\t\t\t\tSettingsDefinitionUtil.getConfigurationBeanClassName(\n\t\t\t\t\t_settingsDefinition);\n\n\t\t\t_log.debug(\"Registered configuration bean service \" + className);\n\t\t}\n\t}","commit_id":"580febb199eb2b570c6bda6ffd0fc2436c15d651","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _unregisterSettingsProvider() {\n\t\t_settingsProviderServiceRegistration.unregister();\n\n\t\t_settingsProviderServiceRegistration = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tClass<?> settingsProviderServiceClass =\n\t\t\t\t_settingsProviderBuilder.getSettingsProviderServiceClass();\n\n\t\t\t_log.debug(\n\t\t\t\t\"Unregistered settings provider service \" +\n\t\t\t\t\tsettingsProviderServiceClass.getName() + \"<\" +\n\t\t\t\t\tSettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t\t\t_settingsDefinition) + \">\");\n\t\t}\n\t}","id":83173,"modified_method":"private void _unregisterSettingsProvider() {\n\t\t_settingsProviderServiceRegistration.unregister();\n\n\t\t_settingsProviderServiceRegistration = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tClass<?> settingsProviderServiceClass =\n\t\t\t\t_settingsProviderBuilder.getSettingsProviderServiceClass();\n\t\t\tString settingsClassName =\n\t\t\t\tSettingsDefinitionUtil.getSettingsClassName(\n\t\t\t\t\t_settingsDefinition);\n\n\t\t\t_log.debug(\n\t\t\t\t\"Unregistered settings provider service \" +\n\t\t\t\t\tsettingsProviderServiceClass.getName() + \"<\" +\n\t\t\t\t\t\tsettingsClassName + \">\");\n\t\t}\n\t}","commit_id":"580febb199eb2b570c6bda6ffd0fc2436c15d651","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _unregisterConfigurationBean() {\n\t\t_configurationBeanServiceRegistration.unregister();\n\n\t\t_configurationBeanServiceRegistration = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Unregistered configuration bean service \" +\n\t\t\t\t\tSettingsDefinitionUtil.getConfigurationBeanClassName(\n\t\t\t\t\t\t_settingsDefinition));\n\t\t}\n\t}","id":83174,"modified_method":"private void _unregisterConfigurationBean() {\n\t\t_configurationBeanServiceRegistration.unregister();\n\n\t\t_configurationBeanServiceRegistration = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tString className =\n\t\t\t\tSettingsDefinitionUtil.getConfigurationBeanClassName(\n\t\t\t\t\t_settingsDefinition);\n\n\t\t\t_log.debug(\n\t\t\t\t\"Unregistered configuration bean service \" + className);\n\t\t}\n\t}","commit_id":"580febb199eb2b570c6bda6ffd0fc2436c15d651","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _registerManagedService() {\n\t\tManagedService managedService = new ManagedService() {\n\t\t\t@Override\n\t\t\tpublic void updated(Dictionary<String, ?> properties)\n\t\t\t\tthrows ConfigurationException {\n\n\t\t\t\tif (properties == null) {\n\t\t\t\t\tproperties = _EMPTY_DICTIONARY;\n\t\t\t\t}\n\n\t\t\t\t_configurationBeanBuilder.updateProperties(properties);\n\t\t\t}\n\t\t};\n\n\t\tDictionary<String, String> properties = new HashMapDictionary<>();\n\n\t\tproperties.put(\n\t\t\tConstants.SERVICE_PID,\n\t\t\tSettingsDefinitionUtil.getConfigurationPid(_settingsDefinition));\n\n\t\t_managedServiceServiceRegistration = _bundleContext.registerService(\n\t\t\tManagedService.class, managedService, properties);\n\n\t\t_configurationBeanBuilder.updateProperties(\n\t\t\t_getConfigurationProperties());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Registered listener for changes in configurationPid \" +\n\t\t\t\t\tSettingsDefinitionUtil.getConfigurationPid(\n\t\t\t\t\t\t_settingsDefinition));\n\t\t}\n\t}","id":83175,"modified_method":"private void _registerManagedService() {\n\t\tManagedService managedService = new ManagedService() {\n\n\t\t\t@Override\n\t\t\tpublic void updated(Dictionary<String, ?> properties)\n\t\t\t\tthrows ConfigurationException {\n\n\t\t\t\tif (properties == null) {\n\t\t\t\t\tproperties = _EMPTY_DICTIONARY;\n\t\t\t\t}\n\n\t\t\t\t_configurationBeanBuilder.updateProperties(properties);\n\t\t\t}\n\n\t\t};\n\n\t\tDictionary<String, String> properties = new HashMapDictionary<>();\n\n\t\tproperties.put(\n\t\t\tConstants.SERVICE_PID,\n\t\t\tSettingsDefinitionUtil.getConfigurationPid(_settingsDefinition));\n\n\t\t_managedServiceServiceRegistration = _bundleContext.registerService(\n\t\t\tManagedService.class, managedService, properties);\n\n\t\t_configurationBeanBuilder.updateProperties(\n\t\t\t_getConfigurationProperties());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tString pid = SettingsDefinitionUtil.getConfigurationPid(\n\t\t\t\t_settingsDefinition);\n\n\t\t\t_log.debug(\n\t\t\t\t\"Registered listener for changes in configurationPid \" + pid);\n\t\t}\n\t}","commit_id":"580febb199eb2b570c6bda6ffd0fc2436c15d651","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Set<String> getAncestorsNames(String conceptFqName) {\n    if (myAncestorsNamesMap.containsKey(conceptFqName)) {\n      //return new HashSet<String>(myParentsNamesMap.get(conceptFqName));\n      return myAncestorsNamesMap.get(conceptFqName);\n    } else {\n      Set<String> result = new HashSet<String>();\n      Set<String> parents = new HashSet<String>();\n      AbstractConceptDeclaration declaration = findConceptDeclaration(NameUtil.shortNameFromLongName(conceptFqName));\n      if (declaration == null) {\n        return result;\n      }\n\n      result.add(conceptFqName);\n\n      if (declaration instanceof ConceptDeclaration) {\n        ConceptDeclaration cd = (ConceptDeclaration) declaration;\n        if (cd.getExtends() != null) {\n          String fqName = NameUtil.nodeFQName(cd.getExtends());\n          parents.add(fqName);\n          result.addAll(SModelUtil_new.getDeclaringLanguage(\n            cd.getExtends(), GlobalScope.getInstance()).getAncestorsNames(\n            fqName));\n        }\n\n        for (InterfaceConceptReference icr : cd.getImplementses()) {\n          String fqName = NameUtil.nodeFQName(icr.getIntfc());\n          parents.add(fqName);\n          result.addAll(SModelUtil_new.getDeclaringLanguage(\n            icr.getIntfc(), GlobalScope.getInstance()).getAncestorsNames(\n            fqName));\n        }\n      }\n\n      if (declaration instanceof InterfaceConceptDeclaration) {\n        InterfaceConceptDeclaration icd = (InterfaceConceptDeclaration) declaration;\n        for (InterfaceConceptReference icr : icd.getExtendses()) {\n          String fqName = NameUtil.nodeFQName(icr.getIntfc());\n          parents.add(fqName);\n          result.addAll(SModelUtil_new.getDeclaringLanguage(\n            icr.getIntfc(), GlobalScope.getInstance()).getAncestorsNames(\n            fqName));\n        }\n      }\n      myParentsNamesMap.put(conceptFqName, parents);\n      myAncestorsNamesMap.put(conceptFqName, result);\n      //return new HashSet<String>(result);\n      return result;\n    }\n  }","id":83176,"modified_method":"public Set<String> getAncestorsNames(String conceptFqName) {\n    if (myAncestorsNamesMap.containsKey(conceptFqName)) {\n      //return new HashSet<String>(myParentsNamesMap.get(conceptFqName));\n      return myAncestorsNamesMap.get(conceptFqName);\n    } else {\n      Set<String> result = new HashSet<String>();\n      Set<String> parents = new HashSet<String>();\n      AbstractConceptDeclaration declaration = findConceptDeclaration(NameUtil.shortNameFromLongName(conceptFqName));\n      if (declaration == null) {\n        return result;\n      }\n\n      result.add(conceptFqName);\n\n      if (declaration instanceof ConceptDeclaration) {\n        ConceptDeclaration cd = (ConceptDeclaration) declaration;\n        ConceptDeclaration extendedConcept = cd.getExtends();\n        if (extendedConcept != null) {\n          String fqName = NameUtil.nodeFQName(extendedConcept);\n          Language declaringLanguage = SModelUtil_new.getDeclaringLanguage(fqName, GlobalScope.getInstance());\n          if (declaringLanguage != null) {\n            parents.add(fqName);\n            result.addAll(declaringLanguage.getAncestorsNames(fqName));\n          }\n        }\n\n        for (InterfaceConceptReference icr : cd.getImplementses()) {\n          InterfaceConceptDeclaration interfaceConcept = icr.getIntfc();\n          if (interfaceConcept == null) continue;\n          String fqName = NameUtil.nodeFQName(interfaceConcept);\n          Language declaringLanguage = SModelUtil_new.getDeclaringLanguage(fqName, GlobalScope.getInstance());\n          if (declaringLanguage == null) continue;\n          parents.add(fqName);\n          result.addAll(declaringLanguage.getAncestorsNames(fqName));\n        }\n      }\n\n      if (declaration instanceof InterfaceConceptDeclaration) {\n        InterfaceConceptDeclaration icd = (InterfaceConceptDeclaration) declaration;\n        for (InterfaceConceptReference icr : icd.getExtendses()) {\n          InterfaceConceptDeclaration interfaceConcept = icr.getIntfc();\n          if (interfaceConcept == null) continue;\n          String fqName = NameUtil.nodeFQName(interfaceConcept);\n          Language declaringLanguage = SModelUtil_new.getDeclaringLanguage(fqName, GlobalScope.getInstance());\n          if (declaringLanguage == null) continue;\n          parents.add(fqName);\n          result.addAll(declaringLanguage.getAncestorsNames(fqName));\n        }\n      }\n      myParentsNamesMap.put(conceptFqName, parents);\n      myAncestorsNamesMap.put(conceptFqName, result);\n      return result;\n    }\n  }","commit_id":"1c92836cf19187b6cfc03f044105a21567d014e7","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n        String year = String.valueOf( actualYear );\n\n        Model model = getProject().getModel();\n        if ( model.getInceptionYear() != null )\n        {\n            if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n            {\n                if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                {\n                    year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                }\n            }\n            else\n            {\n                getLog().warn( \"The inception year is not a valid year.\" );\n            }\n        }\n\n        StringBuffer options = new StringBuffer();\n        StringBuffer classpath = new StringBuffer();\n        try\n        {\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new MavenReportException( \"Error in plugin descriptor - compile dependencies were not resolved\", e );\n        }\n\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( quotedPathArgument( classpath.toString() ) );\n        }\n\n        StringBuffer sourcePath = new StringBuffer();\n        StringBuffer files = new StringBuffer();\n        for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n        {\n            String sourceDirectory = (String) i.next();\n            String[] fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[]{\"java\"} );\n            if ( fileList != null && fileList.length != 0 )\n            {\n                for ( int j = 0; j < fileList.length; j++ )\n                {\n                    files.append( quotedPathArgument( fileList[j] ) );\n                    files.append( \"\\n\" );\n                }\n            }\n\n            sourcePath.append( sourceDirectory );\n\n            if ( i.hasNext() )\n            {\n                sourcePath.append( PATH_SEPARATOR );\n            }\n        }\n\n        if ( files.length() == 0 )\n        {\n            return;\n        }\n\n        File javadocDirectory = getReportOutputDirectory();\n\n        if ( !javadocDirectory.equals( getOutputDirectory() ) )\n        {\n            // we're in site-embedded report mode, so Doxia has set the\n            // reportOutputDirectory to the basedir of the site.\n            // Append 'apidocs'.\n            javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n        }\n        javadocDirectory.mkdirs();\n\n        File file = new File( javadocDirectory, \"files\" );\n        file.deleteOnExit();\n        try\n        {\n            FileUtils.fileWrite( file.getAbsolutePath(), files.toString() );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to write temporary file for command execution\", e );\n        }\n\n        try\n        {\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet\", e );\n        }\n\n        Commandline cmd = new Commandline();\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n        cmd.setExecutable( getJavadocPath() );\n\n        // General javadoc arguments\n        addArgIfNotEmpty( arguments, \"-locale\", quotedArgument( this.locale ) );\n        addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n        if ( !StringUtils.isEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletPath\", quotedPathArgument( docletPath ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n        addArgIfNotEmpty( arguments, \"-exclude\", quotedArgument( excludePackageNames ), 1.4f );\n        if ( !StringUtils.isEmpty( maxmemory ) )\n        {\n            // Allow '128' or '128m'\n            if ( NumberUtils.isDigits( maxmemory ) )\n            {\n                addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n            }\n            else\n            {\n                if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) ) &&\n                    ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                }\n                else\n                {\n                    getLog().error( \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                }\n            }\n        }\n\n        if ( !StringUtils.isEmpty( minmemory ) )\n        {\n            // Allow '128' or '128m'\n            if ( NumberUtils.isDigits( minmemory ) )\n            {\n                addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n            }\n            else\n            {\n                if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) ) &&\n                    ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                }\n                else\n                {\n                    getLog().error( \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                }\n            }\n        }\n\n        if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        addArgIfNotEmpty( arguments, \"-overview\", quotedArgument( overview ) );\n        addArgIf( arguments, showPackage, \"-package\" );\n        addArgIf( arguments, showPrivate, \"-private\" );\n        addArgIf( arguments, showProtected, \"-protected\" );\n        addArgIf( arguments, public_, \"-public\" );\n        addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n        addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), 1.4f );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, \"-additionalparam\", quotedArgument( additionalparam ) );\n\n        addArgIfNotEmpty( arguments, \"-sourcePath\", quotedPathArgument( sourcePath.toString() ) );\n\n        // javadoc arguments for default doclet\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            bottom = StringUtils.replace( bottom, \"{currentYear}\", year );\n            if ( project.getInceptionYear() != null )\n            {\n                bottom = StringUtils.replace( bottom, \"{inceptionYear}\", project.getInceptionYear() );\n            }\n            else\n            {\n                bottom = StringUtils.replace( bottom, \"{inceptionYear}-\", \"\" );\n            }\n\n            if ( StringUtils.isEmpty( stylesheetfile ) )\n            {\n                stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n            }\n            // End Specify default values\n\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( bottom ) );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( doctitle ) );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ), 1.4f );\n            addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ) );\n            addArgIfNotEmpty( arguments, \"-group\", quotedArgument( group ), true );\n            addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ) );\n            addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n            addArgIfNotEmpty( arguments, \"-link\", quotedPathArgument( link ), true );\n            addArgIfNotEmpty( arguments, \"-linkoffline\", quotedPathArgument( linkoffline ), true );\n            addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), 1.4f );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\", quotedPathArgument( stylesheetfile ) );\n            addArgIfNotEmpty( arguments, \"-tag\", quotedArgument( tag ), 1.4f, true );\n            addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), 1.4f );\n            addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( tagletpath ), 1.4f );\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( windowtitle ) );\n        }\n\n        if ( options.length() > 0 )\n        {\n            File optionsFile = new File( javadocDirectory, \"options\" );\n            for ( Iterator it = arguments.iterator(); it.hasNext(); )\n            {\n                options.append( \" \" );\n                options.append( (String) it.next() );\n            }\n            try\n            {\n                FileUtils.fileWrite( optionsFile.getAbsolutePath(), options.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( \"Unable to write temporary file for command execution\", e );\n            }\n            cmd.createArgument().setValue( \"@options\" );\n            optionsFile.deleteOnExit();\n        }\n\n        cmd.createArgument().setValue( \"@files\" );\n\n        getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command\", e );\n        }\n    }","id":83177,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n        String year = String.valueOf( actualYear );\n\n        Model model = getProject().getModel();\n        if ( model.getInceptionYear() != null )\n        {\n            if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n            {\n                if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                {\n                    year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                }\n            }\n            else\n            {\n                getLog().warn( \"The inception year is not a valid year.\" );\n            }\n        }\n\n        StringBuffer options = new StringBuffer();\n        StringBuffer classpath = new StringBuffer();\n        try\n        {\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new MavenReportException( \"Error in plugin descriptor - compile dependencies were not resolved\", e );\n        }\n\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( quotedPathArgument( classpath.toString() ) );\n        }\n\n        StringBuffer sourcePath = new StringBuffer();\n        StringBuffer files = new StringBuffer();\n        for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n        {\n            String sourceDirectory = (String) i.next();\n            String[] fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[]{\"java\"} );\n            if ( fileList != null && fileList.length != 0 )\n            {\n                for ( int j = 0; j < fileList.length; j++ )\n                {\n                    files.append( quotedPathArgument( fileList[j] ) );\n                    files.append( \"\\n\" );\n                }\n            }\n\n            sourcePath.append( sourceDirectory );\n\n            if ( i.hasNext() )\n            {\n                sourcePath.append( PATH_SEPARATOR );\n            }\n        }\n\n        if ( files.length() == 0 )\n        {\n            return;\n        }\n\n        File javadocDirectory = getReportOutputDirectory();\n\n        if ( !javadocDirectory.equals( getOutputDirectory() ) )\n        {\n            // we're in site-embedded report mode, so Doxia has set the\n            // reportOutputDirectory to the basedir of the site.\n            // Append 'apidocs'.\n            javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n        }\n        javadocDirectory.mkdirs();\n\n        File file = new File( javadocDirectory, \"files\" );\n        file.deleteOnExit();\n        try\n        {\n            FileUtils.fileWrite( file.getAbsolutePath(), files.toString() );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to write temporary file for command execution\", e );\n        }\n\n        try\n        {\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet\", e );\n        }\n\n        Commandline cmd = new Commandline();\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n        cmd.setExecutable( getJavadocPath() );\n\n        // General javadoc arguments\n        addArgIfNotEmpty( arguments, \"-locale\", quotedArgument( this.locale ) );\n        addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n        if ( !StringUtils.isEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletPath\", quotedPathArgument( docletPath ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n        addArgIfNotEmpty( arguments, \"-exclude\", quotedArgument( excludePackageNames ), 1.4f );\n        if ( !StringUtils.isEmpty( maxmemory ) )\n        {\n            // Allow '128' or '128m'\n            if ( NumberUtils.isDigits( maxmemory ) )\n            {\n                addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n            }\n            else\n            {\n                if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) ) &&\n                    ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                }\n                else\n                {\n                    getLog().error( \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                }\n            }\n        }\n\n        if ( !StringUtils.isEmpty( minmemory ) )\n        {\n            // Allow '128' or '128m'\n            if ( NumberUtils.isDigits( minmemory ) )\n            {\n                addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n            }\n            else\n            {\n                if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) ) &&\n                    ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                }\n                else\n                {\n                    getLog().error( \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                }\n            }\n        }\n\n        if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        addArgIfNotEmpty( arguments, \"-overview\", quotedArgument( overview ) );\n        addArgIf( arguments, showPackage, \"-package\" );\n        addArgIf( arguments, showPrivate, \"-private\" );\n        addArgIf( arguments, showProtected, \"-protected\" );\n        addArgIf( arguments, public_, \"-public\" );\n        addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n        addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), 1.4f );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, \"-additionalparam\", quotedArgument( additionalparam ) );\n\n        addArgIfNotEmpty( arguments, \"-sourcePath\", quotedPathArgument( sourcePath.toString() ) );\n\n        // javadoc arguments for default doclet\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            bottom = StringUtils.replace( bottom, \"{currentYear}\", year );\n            if ( project.getInceptionYear() != null )\n            {\n                bottom = StringUtils.replace( bottom, \"{inceptionYear}\", project.getInceptionYear() );\n            }\n            else\n            {\n                bottom = StringUtils.replace( bottom, \"{inceptionYear}-\", \"\" );\n            }\n\n            if ( StringUtils.isEmpty( stylesheetfile ) )\n            {\n                stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n            }\n            // End Specify default values\n\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( bottom ) );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( doctitle ) );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ), 1.4f );\n            addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ) );\n            addArgIfNotEmpty( arguments, \"-group\", quotedArgument( group ), true );\n            addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ) );\n            addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n            \n            if ( !isOffline )\n            {\n                addArgIfNotEmpty( arguments, \"-link\", quotedPathArgument( link ), true );\n                addArgIfNotEmpty( arguments, \"-linkoffline\", quotedPathArgument( linkoffline ), true );\n                addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n            }\n            \n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), 1.4f );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\", quotedPathArgument( stylesheetfile ) );\n            addArgIfNotEmpty( arguments, \"-tag\", quotedArgument( tag ), 1.4f, true );\n            addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), 1.4f );\n            addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( tagletpath ), 1.4f );\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( windowtitle ) );\n        }\n\n        if ( options.length() > 0 )\n        {\n            File optionsFile = new File( javadocDirectory, \"options\" );\n            for ( Iterator it = arguments.iterator(); it.hasNext(); )\n            {\n                options.append( \" \" );\n                options.append( (String) it.next() );\n            }\n            try\n            {\n                FileUtils.fileWrite( optionsFile.getAbsolutePath(), options.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( \"Unable to write temporary file for command execution\", e );\n            }\n            cmd.createArgument().setValue( \"@options\" );\n            optionsFile.deleteOnExit();\n        }\n\n        cmd.createArgument().setValue( \"@files\" );\n\n        getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command\", e );\n        }\n    }","commit_id":"b99ea0af8aca0a5cca88559e673cda6cfa955184","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n        String year = String.valueOf( actualYear );\n\n        Model model = getProject().getModel();\n        if ( model.getInceptionYear() != null )\n        {\n            if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n            {\n                if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                {\n                    year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                }\n            }\n            else\n            {\n                getLog().warn( \"The inception year is not a valid year.\" );\n            }\n        }\n\n        StringBuffer options = new StringBuffer();\n        StringBuffer classpath = new StringBuffer();\n        try\n        {\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new MavenReportException( \"Error in plugin descriptor - compile dependencies were not resolved\", e );\n        }\n\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( quotedPathArgument( classpath.toString() ) );\n        }\n\n        StringBuffer sourcePath = new StringBuffer();\n        StringBuffer files = new StringBuffer();\n        for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n        {\n            String sourceDirectory = (String) i.next();\n            String[] fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[]{\"java\"} );\n            if ( fileList != null && fileList.length != 0 )\n            {\n                for ( int j = 0; j < fileList.length; j++ )\n                {\n                    files.append( quotedPathArgument( fileList[j] ) );\n                    files.append( \"\\n\" );\n                }\n            }\n\n            sourcePath.append( sourceDirectory );\n\n            if ( i.hasNext() )\n            {\n                sourcePath.append( PATH_SEPARATOR );\n            }\n        }\n\n        if ( files.length() == 0 )\n        {\n            return;\n        }\n\n        File javadocDirectory = getReportOutputDirectory();\n\n        if ( !javadocDirectory.equals( getOutputDirectory() ) )\n        {\n            // we're in site-embedded report mode, so Doxia has set the\n            // reportOutputDirectory to the basedir of the site.\n            // Append 'apidocs'.\n            javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n        }\n        javadocDirectory.mkdirs();\n\n        File file = new File( javadocDirectory, \"files\" );\n        file.deleteOnExit();\n        try\n        {\n            FileUtils.fileWrite( file.getAbsolutePath(), files.toString() );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to write temporary file for command execution\", e );\n        }\n\n        try\n        {\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet\", e );\n        }\n\n        Commandline cmd = new Commandline();\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n        cmd.setExecutable( getJavadocPath() );\n\n        // General javadoc arguments\n        addArgIfNotEmpty( arguments, \"-locale\", quotedArgument( this.locale ) );\n        addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n        if ( !StringUtils.isEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletPath\", quotedPathArgument( docletPath ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n        addArgIfNotEmpty( arguments, \"-exclude\", quotedArgument( excludePackageNames ), 1.4f );\n        if ( !StringUtils.isEmpty( maxmemory ) )\n        {\n            // Allow '128' or '128m'\n            if ( NumberUtils.isDigits( maxmemory ) )\n            {\n                addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n            }\n            else\n            {\n                if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) ) &&\n                    ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                }\n                else\n                {\n                    getLog().error( \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                }\n            }\n        }\n\n        if ( !StringUtils.isEmpty( minmemory ) )\n        {\n            // Allow '128' or '128m'\n            if ( NumberUtils.isDigits( minmemory ) )\n            {\n                addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n            }\n            else\n            {\n                if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) ) &&\n                    ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                }\n                else\n                {\n                    getLog().error( \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                }\n            }\n        }\n\n        if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        addArgIfNotEmpty( arguments, \"-overview\", quotedArgument( overview ) );\n        addArgIf( arguments, showPackage, \"-package\" );\n        addArgIf( arguments, showPrivate, \"-private\" );\n        addArgIf( arguments, showProtected, \"-protected\" );\n        addArgIf( arguments, public_, \"-public\" );\n        addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n        addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), 1.4f );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, \"-additionalparam\", quotedArgument( additionalparam ) );\n\n        addArgIfNotEmpty( arguments, \"-sourcePath\", quotedPathArgument( sourcePath.toString() ) );\n\n        // javadoc arguments for default doclet\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            bottom = StringUtils.replace( bottom, \"{currentYear}\", year );\n            if ( project.getInceptionYear() != null )\n            {\n                bottom = StringUtils.replace( bottom, \"{inceptionYear}\", project.getInceptionYear() );\n            }\n            else\n            {\n                bottom = StringUtils.replace( bottom, \"{inceptionYear}-\", \"\" );\n            }\n\n            if ( StringUtils.isEmpty( stylesheetfile ) )\n            {\n                stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n            }\n            // End Specify default values\n\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( bottom ) );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( doctitle ) );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ), 1.4f );\n            addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ) );\n            addArgIfNotEmpty( arguments, \"-group\", quotedArgument( group ), true );\n            addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ) );\n            addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n            addArgIfNotEmpty( arguments, \"-link\", quotedPathArgument( link ), true );\n            addArgIfNotEmpty( arguments, \"-linkoffline\", quotedPathArgument( linkoffline ), true );\n            addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), 1.4f );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\", quotedPathArgument( stylesheetfile ) );\n            addArgIfNotEmpty( arguments, \"-tag\", quotedArgument( tag ), 1.4f, true );\n            addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), 1.4f );\n            addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( tagletpath ), 1.4f );\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( windowtitle ) );\n        }\n\n        if ( options.length() > 0 )\n        {\n            File optionsFile = new File( javadocDirectory, \"options\" );\n            for ( Iterator it = arguments.iterator(); it.hasNext(); )\n            {\n                options.append( \" \" );\n                options.append( (String) it.next() );\n            }\n            try\n            {\n                FileUtils.fileWrite( optionsFile.getAbsolutePath(), options.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( \"Unable to write temporary file for command execution\", e );\n            }\n            cmd.createArgument().setValue( \"@options\" );\n            optionsFile.deleteOnExit();\n        }\n\n        cmd.createArgument().setValue( \"@files\" );\n\n        getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command\", e );\n        }\n    }","id":83178,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#executeReport(java.util.Locale)\n     */\n    protected void executeReport( Locale locale )\n        throws MavenReportException\n    {\n        int actualYear = Calendar.getInstance().get( Calendar.YEAR );\n        String year = String.valueOf( actualYear );\n\n        Model model = getProject().getModel();\n        if ( model.getInceptionYear() != null )\n        {\n            if ( StringUtils.isNumeric( model.getInceptionYear() ) )\n            {\n                if ( Integer.valueOf( model.getInceptionYear() ).intValue() != actualYear )\n                {\n                    year = model.getInceptionYear() + \"-\" + String.valueOf( actualYear );\n                }\n            }\n            else\n            {\n                getLog().warn( \"The inception year is not a valid year.\" );\n            }\n        }\n\n        StringBuffer options = new StringBuffer();\n        StringBuffer classpath = new StringBuffer();\n        try\n        {\n            for ( Iterator i = getProject().getCompileClasspathElements().iterator(); i.hasNext(); )\n            {\n                classpath.append( (String) i.next() );\n\n                if ( i.hasNext() )\n                {\n                    classpath.append( PATH_SEPARATOR );\n                }\n            }\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new MavenReportException( \"Error in plugin descriptor - compile dependencies were not resolved\", e );\n        }\n\n        if ( classpath.length() > 0 )\n        {\n            options.append( \"-classpath \" );\n            options.append( quotedPathArgument( classpath.toString() ) );\n        }\n\n        StringBuffer sourcePath = new StringBuffer();\n        StringBuffer files = new StringBuffer();\n        for ( Iterator i = getProject().getCompileSourceRoots().iterator(); i.hasNext(); )\n        {\n            String sourceDirectory = (String) i.next();\n            String[] fileList = FileUtils.getFilesFromExtension( sourceDirectory, new String[]{\"java\"} );\n            if ( fileList != null && fileList.length != 0 )\n            {\n                for ( int j = 0; j < fileList.length; j++ )\n                {\n                    files.append( quotedPathArgument( fileList[j] ) );\n                    files.append( \"\\n\" );\n                }\n            }\n\n            sourcePath.append( sourceDirectory );\n\n            if ( i.hasNext() )\n            {\n                sourcePath.append( PATH_SEPARATOR );\n            }\n        }\n\n        if ( files.length() == 0 )\n        {\n            return;\n        }\n\n        File javadocDirectory = getReportOutputDirectory();\n\n        if ( !javadocDirectory.equals( getOutputDirectory() ) )\n        {\n            // we're in site-embedded report mode, so Doxia has set the\n            // reportOutputDirectory to the basedir of the site.\n            // Append 'apidocs'.\n            javadocDirectory = new File( javadocDirectory, \"apidocs\" );\n        }\n        javadocDirectory.mkdirs();\n\n        File file = new File( javadocDirectory, \"files\" );\n        file.deleteOnExit();\n        try\n        {\n            FileUtils.fileWrite( file.getAbsolutePath(), files.toString() );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to write temporary file for command execution\", e );\n        }\n\n        try\n        {\n            // Copy default style sheet\n            copyDefaultStylesheet( javadocDirectory );\n        }\n        catch ( IOException e )\n        {\n            throw new MavenReportException( \"Unable to copy default stylesheet\", e );\n        }\n\n        Commandline cmd = new Commandline();\n\n        List arguments = new ArrayList();\n\n        cmd.setWorkingDirectory( javadocDirectory.getAbsolutePath() );\n        cmd.setExecutable( getJavadocPath() );\n\n        // General javadoc arguments\n        addArgIfNotEmpty( arguments, \"-locale\", quotedArgument( this.locale ) );\n        addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n        if ( !StringUtils.isEmpty( doclet ) )\n        {\n            addArgIfNotEmpty( arguments, \"-doclet\", quotedArgument( doclet ) );\n            addArgIfNotEmpty( arguments, \"-docletPath\", quotedPathArgument( docletPath ) );\n        }\n        addArgIfNotEmpty( arguments, \"-encoding\", quotedArgument( encoding ) );\n        addArgIfNotEmpty( arguments, \"-extdirs\", quotedPathArgument( extdirs ) );\n        addArgIfNotEmpty( arguments, \"-exclude\", quotedArgument( excludePackageNames ), 1.4f );\n        if ( !StringUtils.isEmpty( maxmemory ) )\n        {\n            // Allow '128' or '128m'\n            if ( NumberUtils.isDigits( maxmemory ) )\n            {\n                addArgIf( arguments, true, \"-J-Xmx\" + maxmemory + \"m\" );\n            }\n            else\n            {\n                if ( ( NumberUtils.isDigits( maxmemory.substring( 0, maxmemory.length() - 1 ) ) ) &&\n                    ( maxmemory.toLowerCase().endsWith( \"m\" ) ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xmx\" + maxmemory );\n                }\n                else\n                {\n                    getLog().error( \"The maxmemory '\" + maxmemory + \"' is not a valid number. Ignore this option.\" );\n                }\n            }\n        }\n\n        if ( !StringUtils.isEmpty( minmemory ) )\n        {\n            // Allow '128' or '128m'\n            if ( NumberUtils.isDigits( minmemory ) )\n            {\n                addArgIf( arguments, true, \"-J-Xms\" + minmemory + \"m\" );\n            }\n            else\n            {\n                if ( ( NumberUtils.isDigits( minmemory.substring( 0, minmemory.length() - 1 ) ) ) &&\n                    ( minmemory.toLowerCase().endsWith( \"m\" ) ) )\n                {\n                    addArgIf( arguments, true, \"-J-Xms\" + minmemory );\n                }\n                else\n                {\n                    getLog().error( \"The minmemory '\" + minmemory + \"' is not a valid number. Ignore this option.\" );\n                }\n            }\n        }\n\n        if ( old && SystemUtils.isJavaVersionAtLeast( 1.4f ) )\n        {\n            getLog().warn( \"Javadoc 1.4 doesn't support the -1.1 switch anymore. Ignore this option.\" );\n        }\n        else\n        {\n            addArgIf( arguments, old, \"-1.1\" );\n        }\n\n        addArgIfNotEmpty( arguments, \"-overview\", quotedArgument( overview ) );\n        addArgIf( arguments, showPackage, \"-package\" );\n        addArgIf( arguments, showPrivate, \"-private\" );\n        addArgIf( arguments, showProtected, \"-protected\" );\n        addArgIf( arguments, public_, \"-public\" );\n        addArgIf( arguments, quiet, \"-quiet\", 1.4f );\n        addArgIfNotEmpty( arguments, \"-source\", quotedArgument( source ), 1.4f );\n        addArgIf( arguments, verbose, \"-verbose\" );\n        addArgIfNotEmpty( arguments, \"-additionalparam\", quotedArgument( additionalparam ) );\n\n        addArgIfNotEmpty( arguments, \"-sourcePath\", quotedPathArgument( sourcePath.toString() ) );\n\n        // javadoc arguments for default doclet\n        if ( StringUtils.isEmpty( doclet ) )\n        {\n            bottom = StringUtils.replace( bottom, \"{currentYear}\", year );\n            if ( project.getInceptionYear() != null )\n            {\n                bottom = StringUtils.replace( bottom, \"{inceptionYear}\", project.getInceptionYear() );\n            }\n            else\n            {\n                bottom = StringUtils.replace( bottom, \"{inceptionYear}-\", \"\" );\n            }\n\n            if ( StringUtils.isEmpty( stylesheetfile ) )\n            {\n                stylesheetfile = javadocDirectory + File.separator + DEFAULT_CSS_NAME;\n            }\n            // End Specify default values\n\n            addArgIf( arguments, author, \"-author\" );\n            addArgIfNotEmpty( arguments, \"-bottom\", quotedArgument( bottom ) );\n            addArgIf( arguments, breakiterator, \"-breakiterator\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-charset\", quotedArgument( charset ) );\n            addArgIfNotEmpty( arguments, \"-d\", quotedPathArgument( javadocDirectory.toString() ) );\n            addArgIf( arguments, docfilessubdirs, \"-docfilessubdirs\", 1.4f );\n            addArgIfNotEmpty( arguments, \"-docencoding\", quotedArgument( docencoding ) );\n            addArgIfNotEmpty( arguments, \"-doctitle\", quotedArgument( doctitle ) );\n            addArgIfNotEmpty( arguments, \"-excludedocfilessubdir\", quotedPathArgument( excludedocfilessubdir ), 1.4f );\n            addArgIfNotEmpty( arguments, \"-footer\", quotedArgument( footer ) );\n            addArgIfNotEmpty( arguments, \"-group\", quotedArgument( group ), true );\n            addArgIfNotEmpty( arguments, \"-header\", quotedArgument( header ) );\n            addArgIfNotEmpty( arguments, \"-helpfile\", quotedPathArgument( helpfile ) );\n            \n            if ( !isOffline )\n            {\n                addArgIfNotEmpty( arguments, \"-link\", quotedPathArgument( link ), true );\n                addArgIfNotEmpty( arguments, \"-linkoffline\", quotedPathArgument( linkoffline ), true );\n                addArgIf( arguments, linksource, \"-linksource\", 1.4f );\n            }\n            \n            addArgIf( arguments, nodeprecated, \"-nodeprecated\" );\n            addArgIf( arguments, nodeprecatedlist, \"-nodeprecatedlist\" );\n            addArgIf( arguments, nocomment, \"-nocomment\", 1.4f );\n            addArgIf( arguments, nohelp, \"-nohelp\" );\n            addArgIf( arguments, noindex, \"-noindex\" );\n            addArgIf( arguments, nonavbar, \"-nonavbar\" );\n            addArgIfNotEmpty( arguments, \"-noqualifier\", quotedArgument( noqualifier ), 1.4f );\n            addArgIf( arguments, nosince, \"-nosince\" );\n            addArgIf( arguments, notree, \"-notree\" );\n            addArgIf( arguments, serialwarn, \"-serialwarn\" );\n            addArgIf( arguments, splitindex, \"-splitindex\" );\n            addArgIfNotEmpty( arguments, \"-stylesheetfile\", quotedPathArgument( stylesheetfile ) );\n            addArgIfNotEmpty( arguments, \"-tag\", quotedArgument( tag ), 1.4f, true );\n            addArgIfNotEmpty( arguments, \"-taglet\", quotedArgument( taglet ), 1.4f );\n            addArgIfNotEmpty( arguments, \"-tagletpath\", quotedPathArgument( tagletpath ), 1.4f );\n            addArgIf( arguments, use, \"-use\" );\n            addArgIf( arguments, version, \"-version\" );\n            addArgIfNotEmpty( arguments, \"-windowtitle\", quotedArgument( windowtitle ) );\n        }\n\n        if ( options.length() > 0 )\n        {\n            File optionsFile = new File( javadocDirectory, \"options\" );\n            for ( Iterator it = arguments.iterator(); it.hasNext(); )\n            {\n                options.append( \" \" );\n                options.append( (String) it.next() );\n            }\n            try\n            {\n                FileUtils.fileWrite( optionsFile.getAbsolutePath(), options.toString() );\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( \"Unable to write temporary file for command execution\", e );\n            }\n            cmd.createArgument().setValue( \"@options\" );\n            optionsFile.deleteOnExit();\n        }\n\n        cmd.createArgument().setValue( \"@files\" );\n\n        getLog().info( Commandline.toString( cmd.getCommandline() ) );\n\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                throw new MavenReportException( \"Exit code: \" + exitCode + \" - \" + err.getOutput() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new MavenReportException( \"Unable to execute javadoc command\", e );\n        }\n    }","commit_id":"30ce820e63ea7188e65aae977b79e7be07c3f2f3","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    CodeException(DataInput file) throws IOException {\n        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n                .readUnsignedShort());\n    }","id":83179,"modified_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    CodeException(DataInput file) throws IOException {\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    InnerClass(DataInput file) throws IOException {\n        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n                .readUnsignedShort());\n    }","id":83180,"modified_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    InnerClass(DataInput file) throws IOException {\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    LocalVariable(DataInput file, ConstantPool constant_pool) throws IOException {\n        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n                .readUnsignedShort(), file.readUnsignedShort(), constant_pool);\n    }","id":83181,"modified_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    LocalVariable(DataInput file) throws IOException {\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        this.index = file.readUnsignedShort();\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param name_index Index in constant pool\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     * @throws IOException\n     */\n    LocalVariableTable(int name_index, int length, DataInputStream file, ConstantPool constant_pool)\n            throws IOException {\n        this(name_index, length, (LocalVariable[]) null, constant_pool);\n        local_variable_table_length = (file.readUnsignedShort());\n        local_variable_table = new LocalVariable[local_variable_table_length];\n        for (int i = 0; i < local_variable_table_length; i++) {\n            local_variable_table[i] = new LocalVariable(file, constant_pool);\n        }\n    }","id":83182,"modified_method":"/**\n     * Construct object from file stream.\n     * @param name_index Index in constant pool\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     * @throws IOException\n     */\n    LocalVariableTable(int name_index, int length, DataInputStream file, ConstantPool constant_pool)\n            throws IOException {\n        this(name_index, length, (LocalVariable[]) null, constant_pool);\n        local_variable_table_length = (file.readUnsignedShort());\n        local_variable_table = new LocalVariable[local_variable_table_length];\n        for (int i = 0; i < local_variable_table_length; i++) {\n            local_variable_table[i] = new LocalVariable(file);\n        }\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"LocalVariableTypeTable(int nameIdx, int len, DataInputStream dis,ConstantPool cpool) throws IOException {\n    this(nameIdx, len, (LocalVariable[])null, cpool);\n\n    local_variable_type_table_length = (dis.readUnsignedShort());\n    local_variable_type_table = new LocalVariable[local_variable_type_table_length];\n\n    for(int i=0; i < local_variable_type_table_length; i++)\n      local_variable_type_table[i] = new LocalVariable(dis, cpool);\n  }","id":83183,"modified_method":"LocalVariableTypeTable(int nameIdx, int len, DataInputStream dis,ConstantPool cpool) throws IOException {\n    this(nameIdx, len, (LocalVariable[])null, cpool);\n\n    local_variable_type_table_length = (dis.readUnsignedShort());\n    local_variable_type_table = new LocalVariable[local_variable_type_table_length];\n\n    for(int i=0; i < local_variable_type_table_length; i++)\n      local_variable_type_table[i] = new LocalVariable(dis);\n  }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param pmg_index index in constant pool for source file name\n     * @param pmg_class_index Index in constant pool to CONSTANT_Utf8\n     * @param constant_pool Array of constants\n     */\n    public PMGClass(int name_index, int length, int pmg_index, int pmg_class_index,\n            ConstantPool constant_pool) {\n        super(Constants.ATTR_PMG, name_index, length, constant_pool);\n        this.pmg_index = pmg_index;\n        this.pmg_class_index = pmg_class_index;\n    }","id":83184,"modified_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param constant_pool Array of constants\n     */\n    public PMGClass(int name_index, int length, ConstantPool constant_pool) {\n        super(Constants.ATTR_PMG, name_index, length, constant_pool);\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     * @throws IOException\n     */\n    PMGClass(int name_index, int length, DataInput file, ConstantPool constant_pool)\n            throws IOException {\n        this(name_index, length, file.readUnsignedShort(), file.readUnsignedShort(), constant_pool);\n    }","id":83185,"modified_method":"/**\n     * Construct object from file stream.\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     * @throws IOException\n     */\n    PMGClass(int name_index, int length, DataInput file, ConstantPool constant_pool)\n            throws IOException {\n        this(name_index, length, constant_pool);\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param signature_index Index in constant pool to CONSTANT_Utf8\n     * @param constant_pool Array of constants\n     */\n    public Signature(int name_index, int length, int signature_index, ConstantPool constant_pool) {\n        super(Constants.ATTR_SIGNATURE, name_index, length, constant_pool);\n        this.signature_index = signature_index;\n    }","id":83186,"modified_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param constant_pool Array of constants\n     */\n    public Signature(int name_index, int length, ConstantPool constant_pool) {\n        super(Constants.ATTR_SIGNATURE, name_index, length, constant_pool);\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     * @throws IOException\n     */\n    Signature(int name_index, int length, DataInput file, ConstantPool constant_pool)\n            throws IOException {\n        this(name_index, length, file.readUnsignedShort(), constant_pool);\n    }","id":83187,"modified_method":"/**\n     * Construct object from file stream.\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     * @throws IOException\n     */\n    Signature(int name_index, int length, DataInput file, ConstantPool constant_pool)\n            throws IOException {\n        this(name_index, length, constant_pool);\n        file.readUnsignedShort();\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n     * should represent the string \"SourceFile\".\n     * @param length Content length in bytes, the value should be 2.\n     * @param constant_pool The constant pool that this attribute is\n     * associated with.\n     * @param sourcefile_index Index in constant pool to CONSTANT_Utf8.  This\n     * string will be interpreted as the name of the file from which this\n     * class was compiled.  It will not be interpreted as indicating the name\n     * of the directory contqining the file or an absolute path; this\n     * information has to be supplied the consumer of this attribute - in\n     * many cases, the JVM.\n     */\n    public SourceFile(int name_index, int length, int sourcefile_index, ConstantPool constant_pool) {\n        super(Constants.ATTR_SOURCE_FILE, name_index, length, constant_pool);\n        this.sourcefile_index = sourcefile_index;\n    }","id":83188,"modified_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n     * should represent the string \"SourceFile\".\n     * @param length Content length in bytes, the value should be 2.\n     * @param constant_pool The constant pool that this attribute is\n     * associated with.\n     */\n    public SourceFile(int name_index, int length, ConstantPool constant_pool) {\n        super(Constants.ATTR_SOURCE_FILE, name_index, length, constant_pool);\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     * @throws IOException\n     */\n    SourceFile(int name_index, int length, DataInput file, ConstantPool constant_pool)\n            throws IOException {\n        this(name_index, length, file.readUnsignedShort(), constant_pool);\n    }","id":83189,"modified_method":"/**\n     * Construct object from file stream.\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     * @throws IOException\n     */\n    SourceFile(int name_index, int length, DataInput file, ConstantPool constant_pool)\n            throws IOException {\n        this(name_index, length, constant_pool);\n        file.readUnsignedShort();\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"StackMapEntry(DataInputStream file) throws IOException {\n        this(file.readShort(), file.readShort(), null, -1, null);\n    }","id":83190,"modified_method":"StackMapEntry(DataInputStream file) throws IOException {\n        file.readShort();\n        file.readShort();\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    StackMapTableEntry(DataInputStream file) throws IOException {\n        this(file.read(), -1, -1, null, -1, null);\n    }","id":83191,"modified_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    StackMapTableEntry(DataInputStream file) throws IOException {\n        file.read();\n    }","commit_id":"6f7f723914bf9241793eaa5e855bda6e80b3b2da","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index\n     *            Index pointing to the name <em>Code<\/em>\n     * @param length\n     *            Content length in bytes\n     * @param defaultValue\n     *            the annotation's default value\n     * @param constant_pool\n     *            Array of constants\n     */\n    public AnnotationDefault(int name_index, int length,\n            ElementValue defaultValue, ConstantPool constant_pool)\n    {\n        super(Constants.ATTR_ANNOTATION_DEFAULT, name_index, length, constant_pool);\n    }","id":83192,"modified_method":"/**\n     * @param name_index\n     *            Index pointing to the name <em>Code<\/em>\n     * @param length\n     *            Content length in bytes\n     * @param defaultValue\n     *            the annotation's default value\n     * @param constant_pool\n     *            Array of constants\n     */\n    public AnnotationDefault(int name_index, int length,\n            ElementValue defaultValue, ConstantPool constant_pool)\n    {\n        super(name_index, length, constant_pool);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param annotation_type the subclass type of the annotation\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param annotation_table the actual annotations\n     * @param constant_pool Array of constants\n     */\n    public Annotations(byte annotation_type, int name_index, int length, AnnotationEntry[] annotation_table, ConstantPool constant_pool) {\n        super(annotation_type, name_index, length, constant_pool);\n        setAnnotationTable(annotation_table);\n    }","id":83193,"modified_method":"/**\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param annotation_table the actual annotations\n     * @param constant_pool Array of constants\n     */\n    public Annotations(int name_index, int length, AnnotationEntry[] annotation_table, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        setAnnotationTable(annotation_table);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param annotation_type the subclass type of the annotation\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     */\n    public Annotations(byte annotation_type, int name_index, int length, DataInputStream file, ConstantPool constant_pool) throws IOException {\n        this(annotation_type, name_index, length, (AnnotationEntry[]) null, constant_pool);\n        final int annotation_table_length = (file.readUnsignedShort());\n        annotation_table = new AnnotationEntry[annotation_table_length];\n        for (int i = 0; i < annotation_table_length; i++) {\n            annotation_table[i] = AnnotationEntry.read(file, constant_pool);\n        }\n    }","id":83194,"modified_method":"/**\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     */\n    public Annotations(int name_index, int length, DataInputStream file, ConstantPool constant_pool) throws IOException {\n        this(name_index, length, (AnnotationEntry[]) null, constant_pool);\n        final int annotation_table_length = (file.readUnsignedShort());\n        annotation_table = new AnnotationEntry[annotation_table_length];\n        for (int i = 0; i < annotation_table_length; i++) {\n            annotation_table[i] = AnnotationEntry.read(file, constant_pool);\n        }\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"protected Attribute(byte tag, int name_index, int length,\n            ConstantPool constant_pool)\n    {\n        this.tag = tag;\n        this.name_index = name_index;\n        this.length = length;\n        this.constant_pool = constant_pool;\n    }","id":83195,"modified_method":"protected Attribute(int name_index, int length,\n            ConstantPool constant_pool)\n    {\n        this.name_index = name_index;\n        this.length = length;\n        this.constant_pool = constant_pool;\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param code Actual byte code\n     * @param exception_table Table of handled exceptions\n     * @param attributes Attributes of code: LineNumber or LocalVariable\n     * @param constant_pool Array of constants\n     */\n    public Code(int name_index, int length, byte[] code,\n            CodeException[] exception_table, Attribute[] attributes, ConstantPool constant_pool) {\n        super(Constants.ATTR_CODE, name_index, length, constant_pool);\n        setCode(code);\n        setExceptionTable(exception_table);\n        setAttributes(attributes); // Overwrites length!\n    }","id":83196,"modified_method":"/**\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param code Actual byte code\n     * @param exception_table Table of handled exceptions\n     * @param attributes Attributes of code: LineNumber or LocalVariable\n     * @param constant_pool Array of constants\n     */\n    public Code(int name_index, int length, byte[] code,\n            CodeException[] exception_table, Attribute[] attributes, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        setCode(code);\n        setExceptionTable(exception_table);\n        setAttributes(attributes); // Overwrites length!\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Initialize instance from file data.\n     *\n     * @param file Input stream\n     * @throws IOException\n     */\n    ConstantInvokeDynamic(DataInput file) throws IOException {\n        this(file.readUnsignedShort(), file.readUnsignedShort());\n    }","id":83197,"modified_method":"/**\n     * Initialize instance from file data.\n     *\n     * @param file Input stream\n     * @throws IOException\n     */\n    ConstantInvokeDynamic(DataInput file) throws IOException {\n        this();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"public ConstantInvokeDynamic(int bootstrap_method_attr_index,\n            int name_and_type_index) {\n        super(Constants.CONSTANT_InvokeDynamic);\n        this.bootstrap_method_attr_index = bootstrap_method_attr_index;\n        this.name_and_type_index = name_and_type_index;\n    }","id":83198,"modified_method":"public ConstantInvokeDynamic() {\n        super(Constants.CONSTANT_InvokeDynamic);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Initialize instance from file data.\n     *\n     * @param file Input stream\n     * @throws IOException\n     */\n    ConstantMethodHandle(DataInput file) throws IOException {\n        this(file.readUnsignedByte(), file.readUnsignedShort());\n    }","id":83199,"modified_method":"/**\n     * Initialize instance from file data.\n     *\n     * @param file Input stream\n     * @throws IOException\n     */\n    ConstantMethodHandle(DataInput file) throws IOException {\n        this();\n        file.readUnsignedByte();\n        file.readUnsignedShort();\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"public ConstantMethodHandle(int reference_kind, int reference_index) {\n        super(Constants.CONSTANT_MethodHandle);\n        this.reference_kind = reference_kind;\n        this.reference_index = reference_index;\n    }","id":83200,"modified_method":"public ConstantMethodHandle() {\n        super(Constants.CONSTANT_MethodHandle);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"public ConstantMethodType(int descriptor_index) {\n        super(Constants.CONSTANT_MethodType);\n        this.descriptor_index = descriptor_index;\n    }","id":83201,"modified_method":"public ConstantMethodType() {\n        super(Constants.CONSTANT_MethodType);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Initialize instance from file data.\n     *\n     * @param file Input stream\n     * @throws IOException\n     */\n    ConstantMethodType(DataInput file) throws IOException {\n        this(file.readUnsignedShort());\n    }","id":83202,"modified_method":"/**\n     * Initialize instance from file data.\n     *\n     * @param file Input stream\n     * @throws IOException\n     */\n    ConstantMethodType(DataInput file) throws IOException {\n        this();\n        file.readUnsignedShort();\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Name index in constant pool\n     * @param length Content length in bytes\n     * @param constant_pool Array of constants\n     */\n    public ConstantValue(int name_index, int length,\n            ConstantPool constant_pool) {\n        super(Constants.ATTR_CONSTANT_VALUE, name_index, length, constant_pool);\n    }","id":83203,"modified_method":"/**\n     * @param name_index Name index in constant pool\n     * @param length Content length in bytes\n     * @param constant_pool Array of constants\n     */\n    public ConstantValue(int name_index, int length,\n            ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param bytes Attribute contents\n     * @param constant_pool Array of constants\n     */\n    public Deprecated(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {\n        super(Constants.ATTR_DEPRECATED, name_index, length, constant_pool);\n        this.bytes = bytes;\n    }","id":83204,"modified_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param bytes Attribute contents\n     * @param constant_pool Array of constants\n     */\n    public Deprecated(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        this.bytes = bytes;\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"public EnclosingMethod(int nameIndex, int len, DataInputStream dis,\n            ConstantPool cpool) throws IOException {\n        super(Constants.ATTR_ENCLOSING_METHOD, nameIndex, len, cpool);\n        // Unused class index\n        dis.readUnsignedShort();\n        // Unused method index\n        dis.readUnsignedShort();\n    }","id":83205,"modified_method":"public EnclosingMethod(int nameIndex, int len, DataInputStream dis,\n            ConstantPool cpool) throws IOException {\n        super(nameIndex, len, cpool);\n        // Unused class index\n        dis.readUnsignedShort();\n        // Unused method index\n        dis.readUnsignedShort();\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool\n     * @param length Content length in bytes\n     * @param exception_index_table Table of indices in constant pool\n     * @param constant_pool Array of constants\n     */\n    public ExceptionTable(int name_index, int length, int[] exception_index_table,\n            ConstantPool constant_pool) {\n        super(Constants.ATTR_EXCEPTIONS, name_index, length, constant_pool);\n        setExceptionIndexTable(exception_index_table);\n    }","id":83206,"modified_method":"/**\n     * @param name_index Index in constant pool\n     * @param length Content length in bytes\n     * @param exception_index_table Table of indices in constant pool\n     * @param constant_pool Array of constants\n     */\n    public ExceptionTable(int name_index, int length, int[] exception_index_table,\n            ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        setExceptionIndexTable(exception_index_table);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param inner_classes array of inner classes attributes\n     * @param constant_pool Array of constants\n     */\n    public InnerClasses(int name_index, int length, InnerClass[] inner_classes,\n            ConstantPool constant_pool) {\n        super(Constants.ATTR_INNER_CLASSES, name_index, length, constant_pool);\n        setInnerClasses(inner_classes);\n    }","id":83207,"modified_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param inner_classes array of inner classes attributes\n     * @param constant_pool Array of constants\n     */\n    public InnerClasses(int name_index, int length, InnerClass[] inner_classes,\n            ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        setInnerClasses(inner_classes);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    LineNumber(DataInput file) throws IOException {\n        this(file.readUnsignedShort(), file.readUnsignedShort());\n    }","id":83208,"modified_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    LineNumber(DataInput file) throws IOException {\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"public LineNumberTable(int name_index, int length, LineNumber[] line_number_table,\n            ConstantPool constant_pool) {\n        super(Constants.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);\n        setLineNumberTable(line_number_table);\n    }","id":83209,"modified_method":"public LineNumberTable(int name_index, int length, LineNumber[] line_number_table,\n            ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        setLineNumberTable(line_number_table);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    LocalVariable(DataInput file) throws IOException {\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        this.index = file.readUnsignedShort();\n    }","id":83210,"modified_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    LocalVariable(DataInput file) throws IOException {\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n        file.readUnsignedShort();\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool to `LocalVariableTable'\n     * @param length Content length in bytes\n     * @param local_variable_table Table of local variables\n     * @param constant_pool Array of constants\n     */\n    public LocalVariableTable(int name_index, int length, LocalVariable[] local_variable_table,\n            ConstantPool constant_pool) {\n        super(Constants.ATTR_LOCAL_VARIABLE_TABLE, name_index, length, constant_pool);\n        setLocalVariableTable(local_variable_table);\n    }","id":83211,"modified_method":"/**\n     * @param name_index Index in constant pool to `LocalVariableTable'\n     * @param length Content length in bytes\n     * @param local_variable_table Table of local variables\n     * @param constant_pool Array of constants\n     */\n    public LocalVariableTable(int name_index, int length, LocalVariable[] local_variable_table,\n            ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        setLocalVariableTable(local_variable_table);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"public LocalVariableTypeTable(int name_index, int length,\n                                LocalVariable[] local_variable_table,\n                                ConstantPool    constant_pool)\n  {\n    super(Constants.ATTR_LOCAL_VARIABLE_TYPE_TABLE, name_index, length, constant_pool);\n    setLocalVariableTable(local_variable_table);\n  }","id":83212,"modified_method":"public LocalVariableTypeTable(int name_index, int length,\n                                LocalVariable[] local_variable_table,\n                                ConstantPool    constant_pool)\n  {\n    super(name_index, length, constant_pool);\n    setLocalVariableTable(local_variable_table);\n  }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param constant_pool Array of constants\n     */\n    public PMGClass(int name_index, int length, ConstantPool constant_pool) {\n        super(Constants.ATTR_PMG, name_index, length, constant_pool);\n    }","id":83213,"modified_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param constant_pool Array of constants\n     */\n    public PMGClass(int name_index, int length, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param parameter_annotation_type the subclass type of the parameter annotation\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     */\n    ParameterAnnotations(byte parameter_annotation_type, int name_index, int length,\n            DataInputStream file, ConstantPool constant_pool) throws IOException {\n        this(parameter_annotation_type, name_index, length, (ParameterAnnotationEntry[]) null,\n                constant_pool);\n        num_parameters = (file.readUnsignedByte());\n        parameter_annotation_table = new ParameterAnnotationEntry[num_parameters];\n        for (int i = 0; i < num_parameters; i++) {\n            parameter_annotation_table[i] = new ParameterAnnotationEntry(file, constant_pool);\n        }\n    }","id":83214,"modified_method":"/**\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     */\n    ParameterAnnotations(int name_index, int length,\n            DataInputStream file, ConstantPool constant_pool) throws IOException {\n        this(name_index, length, (ParameterAnnotationEntry[]) null,\n                constant_pool);\n        num_parameters = (file.readUnsignedByte());\n        parameter_annotation_table = new ParameterAnnotationEntry[num_parameters];\n        for (int i = 0; i < num_parameters; i++) {\n            parameter_annotation_table[i] = new ParameterAnnotationEntry(file, constant_pool);\n        }\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param parameter_annotation_type the subclass type of the parameter annotation\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param parameter_annotation_table the actual parameter annotations\n     * @param constant_pool Array of constants\n     */\n    public ParameterAnnotations(byte parameter_annotation_type, int name_index, int length,\n            ParameterAnnotationEntry[] parameter_annotation_table, ConstantPool constant_pool) {\n        super(parameter_annotation_type, name_index, length, constant_pool);\n        setParameterAnnotationTable(parameter_annotation_table);\n    }","id":83215,"modified_method":"/**\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param parameter_annotation_table the actual parameter annotations\n     * @param constant_pool Array of constants\n     */\n    public ParameterAnnotations(int name_index, int length,\n            ParameterAnnotationEntry[] parameter_annotation_table, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        setParameterAnnotationTable(parameter_annotation_table);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index\n     *            Index pointing to the name <em>Code<\/em>\n     * @param length\n     *            Content length in bytes\n     * @param file\n     *            Input stream\n     * @param constant_pool\n     *            Array of constants\n     */\n    RuntimeInvisibleAnnotations(int name_index, int length,\n                                DataInputStream file, ConstantPool constant_pool)\n                                throws IOException\n    {\n        super(Constants.ATTR_RUNTIMEIN_VISIBLE_ANNOTATIONS, name_index, length,\n                file, constant_pool);\n    }","id":83216,"modified_method":"/**\n     * @param name_index\n     *            Index pointing to the name <em>Code<\/em>\n     * @param length\n     *            Content length in bytes\n     * @param file\n     *            Input stream\n     * @param constant_pool\n     *            Array of constants\n     */\n    RuntimeInvisibleAnnotations(int name_index, int length,\n                                DataInputStream file, ConstantPool constant_pool)\n                                throws IOException\n    {\n        super(name_index, length,\n                file, constant_pool);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     */\n    RuntimeInvisibleParameterAnnotations(int name_index, int length, DataInputStream file,\n            ConstantPool constant_pool) throws IOException {\n        super(Constants.ATTR_RUNTIMEIN_VISIBLE_PARAMETER_ANNOTATIONS, name_index, length, file,\n                constant_pool);\n    }","id":83217,"modified_method":"/**\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     */\n    RuntimeInvisibleParameterAnnotations(int name_index, int length, DataInputStream file,\n            ConstantPool constant_pool) throws IOException {\n        super(name_index, length, file,\n                constant_pool);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index\n     *            Index pointing to the name <em>Code<\/em>\n     * @param length\n     *            Content length in bytes\n     * @param file\n     *            Input stream\n     * @param constant_pool\n     *            Array of constants\n     */\n    public RuntimeVisibleAnnotations(int name_index, int length,\n            DataInputStream file, ConstantPool constant_pool)\n            throws IOException\n    {\n        super(Constants.ATTR_RUNTIME_VISIBLE_ANNOTATIONS, name_index, length,\n                file, constant_pool);\n    }","id":83218,"modified_method":"/**\n     * @param name_index\n     *            Index pointing to the name <em>Code<\/em>\n     * @param length\n     *            Content length in bytes\n     * @param file\n     *            Input stream\n     * @param constant_pool\n     *            Array of constants\n     */\n    public RuntimeVisibleAnnotations(int name_index, int length,\n            DataInputStream file, ConstantPool constant_pool)\n            throws IOException\n    {\n        super(name_index, length,\n                file, constant_pool);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     */\n    RuntimeVisibleParameterAnnotations(int name_index, int length, DataInputStream file,\n            ConstantPool constant_pool) throws IOException {\n        super(Constants.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, name_index, length, file,\n                constant_pool);\n    }","id":83219,"modified_method":"/**\n     * @param name_index Index pointing to the name <em>Code<\/em>\n     * @param length Content length in bytes\n     * @param file Input stream\n     * @param constant_pool Array of constants\n     */\n    RuntimeVisibleParameterAnnotations(int name_index, int length, DataInputStream file,\n            ConstantPool constant_pool) throws IOException {\n        super(name_index, length, file, constant_pool);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param constant_pool Array of constants\n     */\n    public Signature(int name_index, int length, ConstantPool constant_pool) {\n        super(Constants.ATTR_SIGNATURE, name_index, length, constant_pool);\n    }","id":83220,"modified_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8\n     * @param length Content length in bytes\n     * @param constant_pool Array of constants\n     */\n    public Signature(int name_index, int length, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n     * should represent the string \"SourceFile\".\n     * @param length Content length in bytes, the value should be 2.\n     * @param constant_pool The constant pool that this attribute is\n     * associated with.\n     */\n    public SourceFile(int name_index, int length, ConstantPool constant_pool) {\n        super(Constants.ATTR_SOURCE_FILE, name_index, length, constant_pool);\n    }","id":83221,"modified_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n     * should represent the string \"SourceFile\".\n     * @param length Content length in bytes, the value should be 2.\n     * @param constant_pool The constant pool that this attribute is\n     * associated with.\n     */\n    public SourceFile(int name_index, int length, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"public StackMap(int name_index, int length, StackMapEntry[] map, ConstantPool constant_pool) {\n        super(Constants.ATTR_STACK_MAP, name_index, length, constant_pool);\n        setStackMap(map);\n    }","id":83222,"modified_method":"public StackMap(int name_index, int length, StackMapEntry[] map, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        setStackMap(map);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"public StackMapTable(int name_index, int length, StackMapTableEntry[] map, ConstantPool constant_pool) {\n        super(Constants.ATTR_STACK_MAP_TABLE, name_index, length, constant_pool);\n        setStackMapTable(map);\n    }","id":83223,"modified_method":"public StackMapTable(int name_index, int length, StackMapTableEntry[] map, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        setStackMapTable(map);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n     * should represent the string \"Synthetic\".\n     * @param length Content length in bytes - should be zero.\n     * @param bytes Attribute contents\n     * @param constant_pool The constant pool this attribute is associated\n     * with.\n     */\n    public Synthetic(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {\n        super(Constants.ATTR_SYNTHETIC, name_index, length, constant_pool);\n        this.bytes = bytes;\n    }","id":83224,"modified_method":"/**\n     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n     * should represent the string \"Synthetic\".\n     * @param length Content length in bytes - should be zero.\n     * @param bytes Attribute contents\n     * @param constant_pool The constant pool this attribute is associated\n     * with.\n     */\n    public Synthetic(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        this.bytes = bytes;\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Create a non-standard attribute.\n     *\n     * @param name_index Index in constant pool\n     * @param length Content length in bytes\n     * @param bytes Attribute contents\n     * @param constant_pool Array of constants\n     */\n    public Unknown(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {\n        super(Constants.ATTR_UNKNOWN, name_index, length, constant_pool);\n        this.bytes = bytes;\n        name = ((ConstantUtf8) constant_pool.getConstant(name_index, Constants.CONSTANT_Utf8))\n                .getBytes();\n        unknown_attributes.put(name, this);\n    }","id":83225,"modified_method":"/**\n     * Create a non-standard attribute.\n     *\n     * @param name_index Index in constant pool\n     * @param length Content length in bytes\n     * @param bytes Attribute contents\n     * @param constant_pool Array of constants\n     */\n    public Unknown(int name_index, int length, byte[] bytes, ConstantPool constant_pool) {\n        super(name_index, length, constant_pool);\n        this.bytes = bytes;\n        name = ((ConstantUtf8) constant_pool.getConstant(name_index, Constants.CONSTANT_Utf8))\n                .getBytes();\n        unknown_attributes.put(name, this);\n    }","commit_id":"4658623886971a68cc894e5405c6b3406b0e7fe3","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     * @throws ClassFormatException\n     */\n    protected FieldOrMethod(DataInputStream file, ConstantPool constant_pool) throws IOException,\n            ClassFormatException {\n        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null,\n                constant_pool);\n        attributes_count = file.readUnsignedShort();\n        attributes = new Attribute[attributes_count];\n        for (int i = 0; i < attributes_count; i++) {\n            attributes[i] = Attribute.readAttribute(file, constant_pool);\n        }\n    }","id":83226,"modified_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     * @throws ClassFormatException\n     */\n    protected FieldOrMethod(DataInputStream file, ConstantPool constant_pool) throws IOException,\n            ClassFormatException {\n        this.access_flags = file.readUnsignedShort();\n        this.name_index = file.readUnsignedShort();\n        this.signature_index = file.readUnsignedShort();\n        this.constant_pool = constant_pool;\n\n        attributes_count = file.readUnsignedShort();\n        attributes = new Attribute[attributes_count];\n        for (int i = 0; i < attributes_count; i++) {\n            attributes[i] = Attribute.readAttribute(file, constant_pool);\n        }\n    }","commit_id":"c8d36b9c578589eefede254d60a2787640c69262","url":"https://github.com/apache/tomcat"},{"original_method":"public EnclosingMethod(int nameIndex, int len, DataInputStream dis, ConstantPool cpool) throws IOException {\n        this(nameIndex, len, dis.readUnsignedShort(), dis.readUnsignedShort(), cpool);\n    }","id":83227,"modified_method":"public EnclosingMethod(int nameIndex, int len, DataInputStream dis,\n            ConstantPool cpool) throws IOException {\n        super(Constants.ATTR_ENCLOSING_METHOD, nameIndex, len, cpool);\n        // Unused class index\n        dis.readUnsignedShort();\n        // Unused method index\n        dis.readUnsignedShort();\n    }","commit_id":"1a2d6e1e581e2983d8fe890feea1abd1c0a928c7","url":"https://github.com/apache/tomcat"},{"original_method":"private boolean expressionAssignsVariable(\n    @Nullable PsiExpression expression, @NotNull PsiVariable variable,\n    int stamp, @NotNull Set<MethodSignature> checkedMethods) {\n    if (counter != stamp) {\n      return true;\n    }\n    if (expression == null) {\n      return false;\n    }\n    if (expression instanceof PsiThisExpression ||\n        expression instanceof PsiLiteralExpression ||\n        expression instanceof PsiSuperExpression ||\n        expression instanceof PsiClassObjectAccessExpression) {\n      return false;\n    }\n    else if (expression instanceof PsiReferenceExpression) {\n      final PsiReferenceExpression referenceExpression =\n        (PsiReferenceExpression)expression;\n      return referenceExpressionAssignsVariable(referenceExpression,\n                                                variable,\n                                                stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression callExpression =\n        (PsiMethodCallExpression)expression;\n      return methodCallAssignsVariable(callExpression, variable,\n                                       stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiNewExpression) {\n      final PsiNewExpression newExpression = (PsiNewExpression)expression;\n      return newExpressionAssignsVariable(newExpression, variable,\n                                          stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiArrayInitializerExpression) {\n      final PsiArrayInitializerExpression array =\n        (PsiArrayInitializerExpression)expression;\n      final PsiExpression[] initializers = array.getInitializers();\n      for (final PsiExpression initializer : initializers) {\n        if (expressionAssignsVariable(initializer, variable,\n                                      stamp, checkedMethods)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiTypeCastExpression) {\n      final PsiTypeCastExpression typeCast =\n        (PsiTypeCastExpression)expression;\n      final PsiExpression operand = typeCast.getOperand();\n      return expressionAssignsVariable(operand, variable, stamp,\n                                       checkedMethods);\n    }\n    else if (expression instanceof PsiArrayAccessExpression) {\n      final PsiArrayAccessExpression accessExpression =\n        (PsiArrayAccessExpression)expression;\n      final PsiExpression arrayExpression =\n        accessExpression.getArrayExpression();\n      final PsiExpression indexExpression =\n        accessExpression.getIndexExpression();\n      return expressionAssignsVariable(arrayExpression, variable,\n                                       stamp, checkedMethods) ||\n             expressionAssignsVariable(indexExpression, variable,\n                                       stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiPrefixExpression) {\n      final PsiPrefixExpression prefixExpression =\n        (PsiPrefixExpression)expression;\n      final PsiExpression operand = prefixExpression.getOperand();\n      return expressionAssignsVariable(operand, variable, stamp,\n                                       checkedMethods);\n    }\n    else if (expression instanceof PsiPostfixExpression) {\n      final PsiPostfixExpression postfixExpression =\n        (PsiPostfixExpression)expression;\n      final PsiExpression operand = postfixExpression.getOperand();\n      return expressionAssignsVariable(operand, variable, stamp,\n                                       checkedMethods);\n    }\n    else if (expression instanceof PsiBinaryExpression) {\n      final PsiBinaryExpression binaryExpression =\n        (PsiBinaryExpression)expression;\n      final PsiExpression lhs = binaryExpression.getLOperand();\n      final PsiExpression rhs = binaryExpression.getROperand();\n      return expressionAssignsVariable(lhs, variable, stamp,\n                                       checkedMethods) ||\n             expressionAssignsVariable(rhs, variable, stamp,\n                                       checkedMethods);\n    }\n    else if (expression instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditional =\n        (PsiConditionalExpression)expression;\n      final PsiExpression condition = conditional.getCondition();\n      if (expressionAssignsVariable(condition, variable, stamp,\n                                    checkedMethods)) {\n        return true;\n      }\n      final PsiExpression thenExpression =\n        conditional.getThenExpression();\n      final PsiExpression elseExpression =\n        conditional.getElseExpression();\n      return expressionAssignsVariable(thenExpression, variable,\n                                       stamp, checkedMethods)\n             && expressionAssignsVariable(elseExpression, variable,\n                                          stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignment =\n        (PsiAssignmentExpression)expression;\n      return assignmentExpressionAssignsVariable(assignment, variable,\n                                                 stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression =\n        (PsiParenthesizedExpression)expression;\n      final PsiExpression innerExpression =\n        parenthesizedExpression.getExpression();\n      return expressionAssignsVariable(innerExpression, variable, stamp,\n                                       checkedMethods);\n    }\n    else if (expression instanceof PsiInstanceOfExpression) {\n      final PsiInstanceOfExpression instanceOfExpression =\n        (PsiInstanceOfExpression)expression;\n      final PsiExpression operand = instanceOfExpression.getOperand();\n      return expressionAssignsVariable(operand, variable, stamp,\n                                       checkedMethods);\n    }\n    else {\n      return false;\n    }\n  }","id":83228,"modified_method":"private boolean expressionAssignsVariable(\n    @Nullable PsiExpression expression, @NotNull PsiVariable variable,\n    int stamp, @NotNull Set<MethodSignature> checkedMethods) {\n    if (counter != stamp) {\n      return true;\n    }\n    if (expression == null) {\n      return false;\n    }\n    if (expression instanceof PsiThisExpression ||\n        expression instanceof PsiLiteralExpression ||\n        expression instanceof PsiSuperExpression ||\n        expression instanceof PsiClassObjectAccessExpression) {\n      return false;\n    }\n    else if (expression instanceof PsiReferenceExpression) {\n      final PsiReferenceExpression referenceExpression =\n        (PsiReferenceExpression)expression;\n      return referenceExpressionAssignsVariable(referenceExpression,\n                                                variable,\n                                                stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression callExpression =\n        (PsiMethodCallExpression)expression;\n      return methodCallAssignsVariable(callExpression, variable,\n                                       stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiNewExpression) {\n      final PsiNewExpression newExpression = (PsiNewExpression)expression;\n      return newExpressionAssignsVariable(newExpression, variable,\n                                          stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiArrayInitializerExpression) {\n      final PsiArrayInitializerExpression array =\n        (PsiArrayInitializerExpression)expression;\n      final PsiExpression[] initializers = array.getInitializers();\n      for (final PsiExpression initializer : initializers) {\n        if (expressionAssignsVariable(initializer, variable,\n                                      stamp, checkedMethods)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiTypeCastExpression) {\n      final PsiTypeCastExpression typeCast =\n        (PsiTypeCastExpression)expression;\n      final PsiExpression operand = typeCast.getOperand();\n      return expressionAssignsVariable(operand, variable, stamp,\n                                       checkedMethods);\n    }\n    else if (expression instanceof PsiArrayAccessExpression) {\n      final PsiArrayAccessExpression accessExpression =\n        (PsiArrayAccessExpression)expression;\n      final PsiExpression arrayExpression =\n        accessExpression.getArrayExpression();\n      final PsiExpression indexExpression =\n        accessExpression.getIndexExpression();\n      return expressionAssignsVariable(arrayExpression, variable,\n                                       stamp, checkedMethods) ||\n             expressionAssignsVariable(indexExpression, variable,\n                                       stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiPrefixExpression) {\n      final PsiPrefixExpression prefixExpression =\n        (PsiPrefixExpression)expression;\n      final PsiExpression operand = prefixExpression.getOperand();\n      return expressionAssignsVariable(operand, variable, stamp,\n                                       checkedMethods);\n    }\n    else if (expression instanceof PsiPostfixExpression) {\n      final PsiPostfixExpression postfixExpression =\n        (PsiPostfixExpression)expression;\n      final PsiExpression operand = postfixExpression.getOperand();\n      return expressionAssignsVariable(operand, variable, stamp,\n                                       checkedMethods);\n    }\n    else if (expression instanceof PsiPolyadicExpression) {\n      final PsiPolyadicExpression polyadicExpression = (PsiPolyadicExpression)expression;\n      final PsiExpression[] operands = polyadicExpression.getOperands();\n      for (PsiExpression operand : operands) {\n        if (expressionAssignsVariable(operand, variable, stamp, checkedMethods)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else if (expression instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditional =\n        (PsiConditionalExpression)expression;\n      final PsiExpression condition = conditional.getCondition();\n      if (expressionAssignsVariable(condition, variable, stamp,\n                                    checkedMethods)) {\n        return true;\n      }\n      final PsiExpression thenExpression =\n        conditional.getThenExpression();\n      final PsiExpression elseExpression =\n        conditional.getElseExpression();\n      return expressionAssignsVariable(thenExpression, variable,\n                                       stamp, checkedMethods)\n             && expressionAssignsVariable(elseExpression, variable,\n                                          stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignment =\n        (PsiAssignmentExpression)expression;\n      return assignmentExpressionAssignsVariable(assignment, variable,\n                                                 stamp, checkedMethods);\n    }\n    else if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression =\n        (PsiParenthesizedExpression)expression;\n      final PsiExpression innerExpression =\n        parenthesizedExpression.getExpression();\n      return expressionAssignsVariable(innerExpression, variable, stamp,\n                                       checkedMethods);\n    }\n    else if (expression instanceof PsiInstanceOfExpression) {\n      final PsiInstanceOfExpression instanceOfExpression =\n        (PsiInstanceOfExpression)expression;\n      final PsiExpression operand = instanceOfExpression.getOperand();\n      return expressionAssignsVariable(operand, variable, stamp,\n                                       checkedMethods);\n    }\n    else {\n      return false;\n    }\n  }","commit_id":"e672dc012dec829a13c6eeecc0e14b90c595b2f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiExpression[] getUninitializedReads() {\n    final PsiExpression[] array =\n      new PsiExpression[uninitializedReads.size()];\n    return uninitializedReads.toArray(array);\n  }","id":83229,"modified_method":"public PsiExpression[] getUninitializedReads() {\n    return uninitializedReads.toArray(new PsiExpression[uninitializedReads.size()]);\n  }","commit_id":"e672dc012dec829a13c6eeecc0e14b90c595b2f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean tryStatementAssignsVariable(\n    @NotNull PsiTryStatement tryStatement,\n    @NotNull PsiVariable variable,\n    int stamp, @NotNull Set<MethodSignature> checkedMethods) {\n    final PsiCodeBlock tryBlock = tryStatement.getTryBlock();\n    boolean initializedInTryOrCatch =\n      blockAssignsVariable(tryBlock, variable, stamp, checkedMethods);\n    final PsiCodeBlock[] catchBlocks = tryStatement.getCatchBlocks();\n    for (final PsiCodeBlock catchBlock : catchBlocks) {\n      initializedInTryOrCatch &=\n        blockAssignsVariable(catchBlock, variable,\n                             stamp, checkedMethods);\n    }\n    if (initializedInTryOrCatch) {\n      return true;\n    }\n    final PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n    return blockAssignsVariable(finallyBlock, variable,\n                                stamp, checkedMethods);\n  }","id":83230,"modified_method":"private boolean tryStatementAssignsVariable(@NotNull PsiTryStatement tryStatement, @NotNull PsiVariable variable,\n                                              int stamp, @NotNull Set<MethodSignature> checkedMethods) {\n    final PsiResourceList resourceList = tryStatement.getResourceList();\n    if (resourceList != null) {\n      final List<PsiResourceVariable> resourceVariables = resourceList.getResourceVariables();\n      for (PsiResourceVariable resourceVariable : resourceVariables) {\n        final PsiExpression initializer = resourceVariable.getInitializer();\n        if (expressionAssignsVariable(initializer, variable, stamp, checkedMethods)) {\n          return true;\n        }\n      }\n    }\n    final PsiCodeBlock tryBlock = tryStatement.getTryBlock();\n    boolean initializedInTryOrCatch =\n      blockAssignsVariable(tryBlock, variable, stamp, checkedMethods);\n    final PsiCodeBlock[] catchBlocks = tryStatement.getCatchBlocks();\n    for (final PsiCodeBlock catchBlock : catchBlocks) {\n      initializedInTryOrCatch &=\n        blockAssignsVariable(catchBlock, variable,\n                             stamp, checkedMethods);\n    }\n    if (initializedInTryOrCatch) {\n      return true;\n    }\n    final PsiCodeBlock finallyBlock = tryStatement.getFinallyBlock();\n    return blockAssignsVariable(finallyBlock, variable,\n                                stamp, checkedMethods);\n  }","commit_id":"e672dc012dec829a13c6eeecc0e14b90c595b2f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean referenceExpressionAssignsVariable(\n            @NotNull PsiReferenceExpression referenceExpression,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods) {\n        final PsiExpression qualifierExpression =\n                referenceExpression.getQualifierExpression();\n        if(variable.equals(referenceExpression.resolve())){\n            final PsiElement parent = referenceExpression.getParent();\n            if(parent instanceof PsiAssignmentExpression){\n                final PsiAssignmentExpression assignmentExpression =\n                        (PsiAssignmentExpression)parent;\n                final PsiExpression rhs =\n                        assignmentExpression.getRExpression();\n                if (rhs != null && rhs.equals(referenceExpression)) {\n                    checkReferenceExpression(referenceExpression, variable,\n                            qualifierExpression);\n                }\n            } else {\n                checkReferenceExpression(referenceExpression, variable,\n                        qualifierExpression);\n            }\n        }\n        return referenceExpression.isQualified() &&\n                expressionAssignsVariable(qualifierExpression, variable,\n                        stamp, checkedMethods);\n    }","id":83231,"modified_method":"private boolean referenceExpressionAssignsVariable(\n            @NotNull PsiReferenceExpression referenceExpression,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods) {\n        final PsiExpression qualifierExpression =\n                referenceExpression.getQualifierExpression();\n        if (expressionAssignsVariable(qualifierExpression, variable,\n                        stamp, checkedMethods)) {\n            return true;\n        }\n        if(variable.equals(referenceExpression.resolve())){\n            final PsiElement parent = referenceExpression.getParent();\n            if(parent instanceof PsiAssignmentExpression){\n                final PsiAssignmentExpression assignmentExpression =\n                        (PsiAssignmentExpression)parent;\n                final PsiExpression rhs =\n                        assignmentExpression.getRExpression();\n                if (rhs != null && rhs.equals(referenceExpression)) {\n                    checkReferenceExpression(referenceExpression, variable,\n                            qualifierExpression);\n                }\n            } else {\n                checkReferenceExpression(referenceExpression, variable,\n                        qualifierExpression);\n            }\n        }\n        return false;\n    }","commit_id":"372ccc46617abf81b6d79a3c5eb616d9c8c7d8df","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean methodCallAssignsVariable(\n            @NotNull PsiMethodCallExpression callExpression,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        final PsiExpressionList argumentList = callExpression.getArgumentList();\n        final PsiExpression[] arguments = argumentList.getExpressions();\n        for(final PsiExpression argument : arguments){\n            if(expressionAssignsVariable(argument, variable,\n                    stamp, checkedMethods)){\n                return true;\n            }\n        }\n        final PsiReferenceExpression methodExpression =\n                callExpression.getMethodExpression();\n        if(expressionAssignsVariable(methodExpression, variable,\n                stamp, checkedMethods)) {\n            return true;\n        }\n        final PsiMethod method = callExpression.resolveMethod();\n        if(method == null){\n            return false;\n        }\n        final MethodSignature methodSignature =\n                method.getSignature(PsiSubstitutor.EMPTY);\n        if(!checkedMethods.add(methodSignature)){\n            return false;\n        }\n        final PsiClass containingClass =\n                ClassUtils.getContainingClass(callExpression);\n        final PsiClass calledClass = method.getContainingClass();\n\n        // Can remark out this block to continue chase outside of of\n        // current class\n        if(calledClass == null || !calledClass.equals(containingClass)){\n            return false;\n        }\n\n        if(method.hasModifierProperty(PsiModifier.STATIC)\n                || method.isConstructor()\n                || method.hasModifierProperty(PsiModifier.PRIVATE)\n                || method.hasModifierProperty(PsiModifier.FINAL)\n                || calledClass.hasModifierProperty(PsiModifier.FINAL)){\n            final PsiCodeBlock body = method.getBody();\n            return blockAssignsVariable(body, variable, stamp, checkedMethods);\n        }\n        return false;\n    }","id":83232,"modified_method":"private boolean methodCallAssignsVariable(\n            @NotNull PsiMethodCallExpression callExpression,\n            @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        final PsiReferenceExpression methodExpression =\n                callExpression.getMethodExpression();\n        if(expressionAssignsVariable(methodExpression, variable,\n                stamp, checkedMethods)) {\n            return true;\n        }\n        final PsiExpressionList argumentList = callExpression.getArgumentList();\n        final PsiExpression[] arguments = argumentList.getExpressions();\n        for(final PsiExpression argument : arguments){\n            if(expressionAssignsVariable(argument, variable,\n                    stamp, checkedMethods)){\n                return true;\n            }\n        }\n        final PsiMethod method = callExpression.resolveMethod();\n        if(method == null){\n            return false;\n        }\n        final MethodSignature methodSignature =\n                method.getSignature(PsiSubstitutor.EMPTY);\n        if(!checkedMethods.add(methodSignature)){\n            return false;\n        }\n        final PsiClass containingClass =\n                ClassUtils.getContainingClass(callExpression);\n        final PsiClass calledClass = method.getContainingClass();\n\n        // Can remark out this block to continue chase outside of of\n        // current class\n        if(calledClass == null || !calledClass.equals(containingClass)){\n            return false;\n        }\n\n        if(method.hasModifierProperty(PsiModifier.STATIC)\n                || method.isConstructor()\n                || method.hasModifierProperty(PsiModifier.PRIVATE)\n                || method.hasModifierProperty(PsiModifier.FINAL)\n                || calledClass.hasModifierProperty(PsiModifier.FINAL)){\n            final PsiCodeBlock body = method.getBody();\n            return blockAssignsVariable(body, variable, stamp, checkedMethods);\n        }\n        return false;\n    }","commit_id":"372ccc46617abf81b6d79a3c5eb616d9c8c7d8df","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean expressionAssignsVariable(\n            @Nullable PsiExpression expression, @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        if (counter != stamp) {\n            return true;\n        }\n        if(expression == null){\n            return false;\n        }\n        if(expression instanceof PsiThisExpression ||\n                expression instanceof PsiLiteralExpression ||\n                expression instanceof PsiSuperExpression ||\n                expression instanceof PsiClassObjectAccessExpression){\n            return false;\n        } else if(expression instanceof PsiReferenceExpression){\n            final PsiReferenceExpression referenceExpression =\n                    (PsiReferenceExpression) expression;\n            return referenceExpressionAssignsVariable(referenceExpression,\n                                                      variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiMethodCallExpression){\n            final PsiMethodCallExpression callExpression =\n                    (PsiMethodCallExpression)expression;\n            return methodCallAssignsVariable(callExpression, variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiNewExpression){\n            final PsiNewExpression newExpression = (PsiNewExpression)expression;\n            return newExpressionAssignsVariable(newExpression, variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiArrayInitializerExpression){\n            final PsiArrayInitializerExpression array =\n                    (PsiArrayInitializerExpression) expression;\n            final PsiExpression[] initializers = array.getInitializers();\n            for(final PsiExpression initializer : initializers){\n                if(expressionAssignsVariable(initializer, variable,\n                        stamp, checkedMethods)){\n                    return true;\n                }\n            }\n            return false;\n        } else if(expression instanceof PsiTypeCastExpression){\n            final PsiTypeCastExpression typeCast =\n                    (PsiTypeCastExpression) expression;\n            final PsiExpression operand = typeCast.getOperand();\n            return expressionAssignsVariable(operand, variable, stamp,\n                    checkedMethods);\n        } else if(expression instanceof PsiArrayAccessExpression){\n            final PsiArrayAccessExpression accessExpression =\n                    (PsiArrayAccessExpression) expression;\n            final PsiExpression arrayExpression =\n                    accessExpression.getArrayExpression();\n            final PsiExpression indexExpression =\n                    accessExpression.getIndexExpression();\n            return expressionAssignsVariable(arrayExpression, variable,\n                    stamp, checkedMethods) ||\n                    expressionAssignsVariable(indexExpression, variable,\n                            stamp, checkedMethods);\n        } else if(expression instanceof PsiPrefixExpression){\n            final PsiPrefixExpression prefixExpression =\n                    (PsiPrefixExpression) expression;\n            final PsiExpression operand = prefixExpression.getOperand();\n            return expressionAssignsVariable(operand, variable, stamp,\n                    checkedMethods);\n        } else if(expression instanceof PsiPostfixExpression){\n            final PsiPostfixExpression postfixExpression =\n                    (PsiPostfixExpression) expression;\n            final PsiExpression operand = postfixExpression.getOperand();\n            return expressionAssignsVariable(operand, variable, stamp,\n                    checkedMethods);\n        } else if(expression instanceof PsiBinaryExpression){\n            final PsiBinaryExpression binaryExpression =\n                    (PsiBinaryExpression) expression;\n            final PsiExpression lhs = binaryExpression.getLOperand();\n            final PsiExpression rhs = binaryExpression.getROperand();\n            return expressionAssignsVariable(lhs, variable, stamp,\n                    checkedMethods) ||\n                    expressionAssignsVariable(rhs, variable, stamp,\n                            checkedMethods);\n        } else if(expression instanceof PsiConditionalExpression){\n            final PsiConditionalExpression conditional =\n                    (PsiConditionalExpression) expression;\n            final PsiExpression condition = conditional.getCondition();\n            if(expressionAssignsVariable(condition, variable, stamp,\n                    checkedMethods)){\n                return true;\n            }\n            final PsiExpression thenExpression =\n                    conditional.getThenExpression();\n            final PsiExpression elseExpression =\n                    conditional.getElseExpression();\n            return expressionAssignsVariable(thenExpression, variable,\n                    stamp, checkedMethods)\n                    && expressionAssignsVariable(elseExpression, variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiAssignmentExpression){\n            final PsiAssignmentExpression assignment =\n                    (PsiAssignmentExpression) expression;\n            return assignmentExpressonAssignsVariable(assignment, variable,\n                    stamp, checkedMethods);\n        } else{\n            return false;\n        }\n    }","id":83233,"modified_method":"private boolean expressionAssignsVariable(\n            @Nullable PsiExpression expression, @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        if (counter != stamp) {\n            return true;\n        }\n        if(expression == null){\n            return false;\n        }\n        if(expression instanceof PsiThisExpression ||\n                expression instanceof PsiLiteralExpression ||\n                expression instanceof PsiSuperExpression ||\n                expression instanceof PsiClassObjectAccessExpression){\n            return false;\n        } else if(expression instanceof PsiReferenceExpression){\n            final PsiReferenceExpression referenceExpression =\n                    (PsiReferenceExpression) expression;\n            return referenceExpressionAssignsVariable(referenceExpression,\n                                                      variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiMethodCallExpression){\n            final PsiMethodCallExpression callExpression =\n                    (PsiMethodCallExpression)expression;\n            return methodCallAssignsVariable(callExpression, variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiNewExpression){\n            final PsiNewExpression newExpression = (PsiNewExpression)expression;\n            return newExpressionAssignsVariable(newExpression, variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiArrayInitializerExpression){\n            final PsiArrayInitializerExpression array =\n                    (PsiArrayInitializerExpression) expression;\n            final PsiExpression[] initializers = array.getInitializers();\n            for(final PsiExpression initializer : initializers){\n                if(expressionAssignsVariable(initializer, variable,\n                        stamp, checkedMethods)){\n                    return true;\n                }\n            }\n            return false;\n        } else if(expression instanceof PsiTypeCastExpression){\n            final PsiTypeCastExpression typeCast =\n                    (PsiTypeCastExpression) expression;\n            final PsiExpression operand = typeCast.getOperand();\n            return expressionAssignsVariable(operand, variable, stamp,\n                    checkedMethods);\n        } else if(expression instanceof PsiArrayAccessExpression){\n            final PsiArrayAccessExpression accessExpression =\n                    (PsiArrayAccessExpression) expression;\n            final PsiExpression arrayExpression =\n                    accessExpression.getArrayExpression();\n            final PsiExpression indexExpression =\n                    accessExpression.getIndexExpression();\n            return expressionAssignsVariable(arrayExpression, variable,\n                    stamp, checkedMethods) ||\n                    expressionAssignsVariable(indexExpression, variable,\n                            stamp, checkedMethods);\n        } else if(expression instanceof PsiPrefixExpression){\n            final PsiPrefixExpression prefixExpression =\n                    (PsiPrefixExpression) expression;\n            final PsiExpression operand = prefixExpression.getOperand();\n            return expressionAssignsVariable(operand, variable, stamp,\n                    checkedMethods);\n        } else if(expression instanceof PsiPostfixExpression){\n            final PsiPostfixExpression postfixExpression =\n                    (PsiPostfixExpression) expression;\n            final PsiExpression operand = postfixExpression.getOperand();\n            return expressionAssignsVariable(operand, variable, stamp,\n                    checkedMethods);\n        } else if(expression instanceof PsiBinaryExpression){\n            final PsiBinaryExpression binaryExpression =\n                    (PsiBinaryExpression) expression;\n            final PsiExpression lhs = binaryExpression.getLOperand();\n            final PsiExpression rhs = binaryExpression.getROperand();\n            return expressionAssignsVariable(lhs, variable, stamp,\n                    checkedMethods) ||\n                    expressionAssignsVariable(rhs, variable, stamp,\n                            checkedMethods);\n        } else if(expression instanceof PsiConditionalExpression){\n            final PsiConditionalExpression conditional =\n                    (PsiConditionalExpression) expression;\n            final PsiExpression condition = conditional.getCondition();\n            if(expressionAssignsVariable(condition, variable, stamp,\n                    checkedMethods)){\n                return true;\n            }\n            final PsiExpression thenExpression =\n                    conditional.getThenExpression();\n            final PsiExpression elseExpression =\n                    conditional.getElseExpression();\n            return expressionAssignsVariable(thenExpression, variable,\n                    stamp, checkedMethods)\n                    && expressionAssignsVariable(elseExpression, variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiAssignmentExpression){\n            final PsiAssignmentExpression assignment =\n                    (PsiAssignmentExpression) expression;\n            return assignmentExpressonAssignsVariable(assignment, variable,\n                    stamp, checkedMethods);\n        } else if(expression instanceof PsiParenthesizedExpression) {\n            final PsiParenthesizedExpression parenthesizedExpression =\n                    (PsiParenthesizedExpression) expression;\n            final PsiExpression innerExpression =\n                    parenthesizedExpression.getExpression();\n             return expressionAssignsVariable(innerExpression, variable, stamp,\n                     checkedMethods);\n        } else{\n            assert false : \"unknown expression: \" + expression;\n            return false;\n        }\n    }","commit_id":"372ccc46617abf81b6d79a3c5eb616d9c8c7d8df","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean statementAssignsVariable(\n            @Nullable PsiStatement statement, @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        if(statement == null){\n            return false;\n        }\n        if(ExceptionUtils.statementThrowsException(statement)){\n            return true;\n        }\n        if(statement instanceof PsiBreakStatement ||\n                statement instanceof PsiContinueStatement ||\n                statement instanceof PsiAssertStatement ||\n                statement instanceof PsiEmptyStatement){\n            return false;\n        } else if(statement instanceof PsiReturnStatement){\n            final PsiReturnStatement returnStatement =\n                    (PsiReturnStatement) statement;\n            final PsiExpression returnValue = returnStatement.getReturnValue();\n            return expressionAssignsVariable(returnValue, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiThrowStatement){\n            final PsiThrowStatement throwStatement =\n                    (PsiThrowStatement) statement;\n            final PsiExpression exception = throwStatement.getException();\n            return expressionAssignsVariable(exception, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiExpressionListStatement){\n            final PsiExpressionListStatement list =\n                    (PsiExpressionListStatement) statement;\n            final PsiExpressionList expressionList = list.getExpressionList();\n            final PsiExpression[] expressions = expressionList.getExpressions();\n            for(final PsiExpression expression : expressions){\n                if(expressionAssignsVariable(expression, variable,\n                        stamp, checkedMethods)){\n                    return true;\n                }\n            }\n            return false;\n        } else if(statement instanceof PsiExpressionStatement){\n            final PsiExpressionStatement expressionStatement =\n                    (PsiExpressionStatement) statement;\n            final PsiExpression expression =\n                    expressionStatement.getExpression();\n            return expressionAssignsVariable(expression, variable,\n                    stamp, checkedMethods);\n        } else if (statement instanceof PsiDeclarationStatement){\n            final PsiDeclarationStatement declarationStatement =\n                    (PsiDeclarationStatement)statement;\n            return declarationStatementAssignsVariable(declarationStatement,\n                    variable, stamp, checkedMethods);\n        } else if (statement instanceof PsiForStatement){\n            final PsiForStatement forStatement = (PsiForStatement)statement;\n            return forStatementAssignsVariable(forStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiForeachStatement){\n            final PsiForeachStatement foreachStatement =\n                    (PsiForeachStatement)statement;\n            return foreachStatementAssignsVariable(foreachStatement, variable);\n        } else if(statement instanceof PsiWhileStatement){\n            final PsiWhileStatement whileStatement =\n                    (PsiWhileStatement) statement;\n            return whileStatementAssignsVariable(whileStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiDoWhileStatement) {\n            final PsiDoWhileStatement doWhileStatement =\n                    (PsiDoWhileStatement)statement;\n            return doWhileAssignsVariable(doWhileStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiSynchronizedStatement){\n            final PsiSynchronizedStatement synchronizedStatement =\n                    (PsiSynchronizedStatement)statement;\n            final PsiCodeBlock body = synchronizedStatement.getBody();\n            return blockAssignsVariable(body, variable, stamp, checkedMethods);\n        } else if(statement instanceof PsiBlockStatement){\n            final PsiBlockStatement blockStatement =\n                    (PsiBlockStatement) statement;\n            final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();\n            return blockAssignsVariable(codeBlock, variable, stamp,\n                    checkedMethods);\n        } else if (statement instanceof PsiLabeledStatement){\n            final PsiLabeledStatement labeledStatement =\n                    (PsiLabeledStatement) statement;\n            final PsiStatement statementLabeled =\n                    labeledStatement.getStatement();\n            return statementAssignsVariable(statementLabeled, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiIfStatement){\n            final PsiIfStatement ifStatement = (PsiIfStatement) statement;\n            return ifStatementAssignsVariable(ifStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiTryStatement){\n            final PsiTryStatement tryStatement = (PsiTryStatement) statement;\n            return tryStatementAssignsVariable(tryStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiSwitchStatement){\n            final PsiSwitchStatement switchStatement =\n                    (PsiSwitchStatement) statement;\n            return switchStatementAssignsVariable(switchStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiSwitchLabelStatement){\n            return false;\n        } else{\n            throw new RuntimeException(\"unknown statement: \" + statement);\n            // unknown statement type\n            //return false;\n        }\n    }","id":83234,"modified_method":"private boolean statementAssignsVariable(\n            @Nullable PsiStatement statement, @NotNull PsiVariable variable,\n            int stamp, @NotNull Set<MethodSignature> checkedMethods){\n        if(statement == null){\n            return false;\n        }\n        if(ExceptionUtils.statementThrowsException(statement)){\n            return true;\n        }\n        if(statement instanceof PsiBreakStatement ||\n                statement instanceof PsiContinueStatement ||\n                statement instanceof PsiAssertStatement ||\n                statement instanceof PsiEmptyStatement){\n            return false;\n        } else if(statement instanceof PsiReturnStatement){\n            final PsiReturnStatement returnStatement =\n                    (PsiReturnStatement) statement;\n            final PsiExpression returnValue = returnStatement.getReturnValue();\n            return expressionAssignsVariable(returnValue, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiThrowStatement){\n            final PsiThrowStatement throwStatement =\n                    (PsiThrowStatement) statement;\n            final PsiExpression exception = throwStatement.getException();\n            return expressionAssignsVariable(exception, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiExpressionListStatement){\n            final PsiExpressionListStatement list =\n                    (PsiExpressionListStatement) statement;\n            final PsiExpressionList expressionList = list.getExpressionList();\n            final PsiExpression[] expressions = expressionList.getExpressions();\n            for(final PsiExpression expression : expressions){\n                if(expressionAssignsVariable(expression, variable,\n                        stamp, checkedMethods)){\n                    return true;\n                }\n            }\n            return false;\n        } else if(statement instanceof PsiExpressionStatement){\n            final PsiExpressionStatement expressionStatement =\n                    (PsiExpressionStatement) statement;\n            final PsiExpression expression =\n                    expressionStatement.getExpression();\n            return expressionAssignsVariable(expression, variable,\n                    stamp, checkedMethods);\n        } else if (statement instanceof PsiDeclarationStatement){\n            final PsiDeclarationStatement declarationStatement =\n                    (PsiDeclarationStatement)statement;\n            return declarationStatementAssignsVariable(declarationStatement,\n                    variable, stamp, checkedMethods);\n        } else if (statement instanceof PsiForStatement){\n            final PsiForStatement forStatement = (PsiForStatement)statement;\n            return forStatementAssignsVariable(forStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiForeachStatement){\n            final PsiForeachStatement foreachStatement =\n                    (PsiForeachStatement)statement;\n            return foreachStatementAssignsVariable(foreachStatement, variable);\n        } else if(statement instanceof PsiWhileStatement){\n            final PsiWhileStatement whileStatement =\n                    (PsiWhileStatement) statement;\n            return whileStatementAssignsVariable(whileStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiDoWhileStatement) {\n            final PsiDoWhileStatement doWhileStatement =\n                    (PsiDoWhileStatement)statement;\n            return doWhileAssignsVariable(doWhileStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiSynchronizedStatement){\n            final PsiSynchronizedStatement synchronizedStatement =\n                    (PsiSynchronizedStatement)statement;\n            final PsiCodeBlock body = synchronizedStatement.getBody();\n            return blockAssignsVariable(body, variable, stamp, checkedMethods);\n        } else if(statement instanceof PsiBlockStatement){\n            final PsiBlockStatement blockStatement =\n                    (PsiBlockStatement) statement;\n            final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();\n            return blockAssignsVariable(codeBlock, variable, stamp,\n                    checkedMethods);\n        } else if (statement instanceof PsiLabeledStatement){\n            final PsiLabeledStatement labeledStatement =\n                    (PsiLabeledStatement) statement;\n            final PsiStatement statementLabeled =\n                    labeledStatement.getStatement();\n            return statementAssignsVariable(statementLabeled, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiIfStatement){\n            final PsiIfStatement ifStatement = (PsiIfStatement) statement;\n            return ifStatementAssignsVariable(ifStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiTryStatement){\n            final PsiTryStatement tryStatement = (PsiTryStatement) statement;\n            return tryStatementAssignsVariable(tryStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiSwitchStatement){\n            final PsiSwitchStatement switchStatement =\n                    (PsiSwitchStatement) statement;\n            return switchStatementAssignsVariable(switchStatement, variable,\n                    stamp, checkedMethods);\n        } else if(statement instanceof PsiSwitchLabelStatement){\n            return false;\n        } else{\n            assert false : \"unknown statement: \" + statement;\n            return false;\n        }\n    }","commit_id":"372ccc46617abf81b6d79a3c5eb616d9c8c7d8df","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void trainAndSave(String trainTreebankPath, FileFilter trainTreebankFilter,\n                            String devTreebankPath, FileFilter devTreebankFilter,\n                            String serializedPath) {\n    List<Tree> binarizedTrees = readBinarizedTreebank(trainTreebankPath, trainTreebankFilter);\n\n    int nThreads = op.trainOptions.trainingThreads;\n    nThreads = nThreads <= 0 ? Runtime.getRuntime().availableProcessors() : nThreads;      \n\n    MaxentTagger tagger = null;\n    if (op.testOptions.preTag) {\n      Timing retagTimer = new Timing();\n      tagger = new MaxentTagger(op.testOptions.taggerSerializedFile);\n      redoTags(binarizedTrees, tagger, nThreads);\n      retagTimer.done(\"Retagging\");\n    }\n\n    Timing transitionTimer = new Timing();\n    List<List<Transition>> transitionLists = createTransitionSequences(binarizedTrees);\n    for (List<Transition> transitions : transitionLists) {\n      transitionIndex.addAll(transitions);\n    }\n    transitionTimer.done(\"Converting trees into transition lists\");\n    System.err.println(\"Number of transitions: \" + transitionIndex.size());\n    \n    Random random = new Random(op.trainOptions.randomSeed);\n\n    Treebank devTreebank = null;\n    if (devTreebankPath != null) {\n      devTreebank = readTreebank(devTreebankPath, devTreebankFilter);\n    }\n\n    double bestScore = 0.0;\n    int bestIteration = 0;\n    PriorityQueue<ScoredObject<ShiftReduceParser>> bestModels = null;\n    if (op.trainOptions().averagedModels > 0) {\n      bestModels = new PriorityQueue<ScoredObject<ShiftReduceParser>>(op.trainOptions().averagedModels + 1, ScoredComparator.ASCENDING_COMPARATOR);\n    }\n\n    List<Integer> indices = Generics.newArrayList();\n    for (int i = 0; i < binarizedTrees.size(); ++i) {\n      indices.add(i);\n    }\n\n    Oracle oracle = null;\n    if (op.trainOptions().trainingMethod == ShiftReduceTrainOptions.TrainingMethod.ORACLE) {\n      oracle = new Oracle(binarizedTrees, op.compoundUnaries);\n    }\n\n    List<Update> updates = Generics.newArrayList();\n    MulticoreWrapper<Integer, Pair<Integer, Integer>> wrapper = null;\n    if (nThreads != 1) {\n      updates = Collections.synchronizedList(updates);\n      wrapper = new MulticoreWrapper<Integer, Pair<Integer, Integer>>(op.trainOptions.trainingThreads, new TrainTreeProcessor(binarizedTrees, transitionLists, updates, oracle));\n    }\n\n    IntCounter<String> featureFrequencies = null;\n    if (op.trainOptions().featureFrequencyCutoff > 1) {\n      featureFrequencies = new IntCounter<String>();\n    }\n\n    for (int iteration = 1; iteration <= op.trainOptions.trainingIterations; ++iteration) {\n      Timing trainingTimer = new Timing();\n      int numCorrect = 0;\n      int numWrong = 0;\n      Collections.shuffle(indices, random);\n      for (int start = 0; start < indices.size(); start += op.trainOptions.batchSize) {\n        int end = Math.min(start + op.trainOptions.batchSize, indices.size());\n        Triple<List<Update>, Integer, Integer> result = trainBatch(indices.subList(start, end), binarizedTrees, transitionLists, updates, oracle, wrapper);\n\n        numCorrect += result.second;\n        numWrong += result.third;\n\n        for (Update update : result.first) {\n          for (String feature : update.features) {\n            Weight weights = featureWeights.get(feature);\n            if (weights == null) {\n              weights = new Weight();\n              featureWeights.put(feature, weights);\n            }\n            weights.updateWeight(update.goldTransition, update.delta);\n            weights.updateWeight(update.predictedTransition, -update.delta);\n\n            if (featureFrequencies != null) {\n              featureFrequencies.incrementCount(feature, (update.goldTransition >= 0 && update.predictedTransition >= 0) ? 2 : 1);\n            }\n          }\n        }\n        updates.clear();\n      }\n      trainingTimer.done(\"Iteration \" + iteration);\n      System.err.println(\"While training, got \" + numCorrect + \" transitions correct and \" + numWrong + \" transitions wrong\");\n      outputStats();\n\n\n      double labelF1 = 0.0;\n      if (devTreebank != null) {\n        EvaluateTreebank evaluator = new EvaluateTreebank(op, null, this, tagger);\n        evaluator.testOnTreebank(devTreebank);\n        labelF1 = evaluator.getLBScore();\n        System.err.println(\"Label F1 after \" + iteration + \" iterations: \" + labelF1);\n        \n        if (labelF1 > bestScore) {\n          System.err.println(\"New best dev score (previous best \" + bestScore + \")\");\n          bestScore = labelF1;\n          bestIteration = iteration;\n        } else {\n          System.err.println(\"Failed to improve for \" + (iteration - bestIteration) + \" iteration(s) on previous best score of \" + bestScore);\n          if (op.trainOptions.stalledIterationLimit > 0 && (iteration - bestIteration >= op.trainOptions.stalledIterationLimit)) {\n            System.err.println(\"Failed to improve for too long, stopping training\");\n            break;\n          }\n        }\n        \n        if (bestModels != null) {\n          bestModels.add(new ScoredObject<ShiftReduceParser>(this.deepCopy(), labelF1));\n          if (bestModels.size() > op.trainOptions().averagedModels) {\n            bestModels.poll();\n          }\n        }\n      }\n      if (op.trainOptions().saveIntermediateModels && serializedPath != null && op.trainOptions.debugOutputFrequency > 0) {\n        String tempName = serializedPath.substring(0, serializedPath.length() - 7) + \"-\" + FILENAME.format(iteration) + \"-\" + NF.format(labelF1) + \".ser.gz\";\n        saveModel(tempName);\n        // TODO: we could save a cutoff version of the model,\n        // especially if we also get a dev set number for it, but that\n        // might be overkill\n      }\n    }\n\n    if (wrapper != null) {\n      wrapper.join();\n    }\n\n    if (bestModels != null) {\n      if (op.trainOptions().cvAveragedModels && devTreebank != null) {\n        List<ScoredObject<ShiftReduceParser>> models = Generics.newArrayList();\n        while (bestModels.size() > 0) {\n          models.add(bestModels.poll());\n        }\n        Collections.reverse(models);\n        double bestF1 = 0.0;\n        int bestSize = 0;\n        for (int i = 1; i <= models.size(); ++i) {\n          System.err.println(\"Testing with \" + i + \" models averaged together\");\n          ShiftReduceParser parser = averageScoredModels(models.subList(0, i));\n          EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n          evaluator.testOnTreebank(devTreebank);\n          double labelF1 = evaluator.getLBScore();\n          System.err.println(\"Label F1 for \" + i + \" models: \" + labelF1);\n          if (labelF1 > bestF1) {\n            bestF1 = labelF1;\n            bestSize = i;\n          }\n        }\n        copyWeights(averageScoredModels(models.subList(0, bestSize)));\n      } else {\n        copyWeights(ShiftReduceParser.averageScoredModels(bestModels));\n      }\n    }\n\n    // TODO: perhaps we should filter the features and then get dev\n    // set scores.  That way we can merge the models which are best\n    // after filtering.\n    if (featureFrequencies != null) {\n      filterFeatures(featureFrequencies.keysAbove(op.trainOptions().featureFrequencyCutoff));\n    }\n\n    condenseFeatures();\n\n    if (serializedPath != null) {\n      try {\n        IOUtils.writeObjectToFile(this, serializedPath);\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n  }","id":83235,"modified_method":"private void trainAndSave(List<Pair<String, FileFilter>> trainTreebankPath, \n                            Pair<String, FileFilter> devTreebankPath,\n                            String serializedPath) {\n    List<Tree> binarizedTrees = Generics.newArrayList();\n    for (Pair<String, FileFilter> treebank : trainTreebankPath) {\n      binarizedTrees.addAll(readBinarizedTreebank(treebank.first(), treebank.second()));\n    }\n\n    int nThreads = op.trainOptions.trainingThreads;\n    nThreads = nThreads <= 0 ? Runtime.getRuntime().availableProcessors() : nThreads;      \n\n    MaxentTagger tagger = null;\n    if (op.testOptions.preTag) {\n      Timing retagTimer = new Timing();\n      tagger = new MaxentTagger(op.testOptions.taggerSerializedFile);\n      redoTags(binarizedTrees, tagger, nThreads);\n      retagTimer.done(\"Retagging\");\n    }\n\n    Timing transitionTimer = new Timing();\n    List<List<Transition>> transitionLists = createTransitionSequences(binarizedTrees);\n    for (List<Transition> transitions : transitionLists) {\n      transitionIndex.addAll(transitions);\n    }\n    transitionTimer.done(\"Converting trees into transition lists\");\n    System.err.println(\"Number of transitions: \" + transitionIndex.size());\n    \n    Random random = new Random(op.trainOptions.randomSeed);\n\n    Treebank devTreebank = null;\n    if (devTreebankPath != null) {\n      devTreebank = readTreebank(devTreebankPath.first(), devTreebankPath.second());\n    }\n\n    double bestScore = 0.0;\n    int bestIteration = 0;\n    PriorityQueue<ScoredObject<ShiftReduceParser>> bestModels = null;\n    if (op.trainOptions().averagedModels > 0) {\n      bestModels = new PriorityQueue<ScoredObject<ShiftReduceParser>>(op.trainOptions().averagedModels + 1, ScoredComparator.ASCENDING_COMPARATOR);\n    }\n\n    List<Integer> indices = Generics.newArrayList();\n    for (int i = 0; i < binarizedTrees.size(); ++i) {\n      indices.add(i);\n    }\n\n    Oracle oracle = null;\n    if (op.trainOptions().trainingMethod == ShiftReduceTrainOptions.TrainingMethod.ORACLE) {\n      oracle = new Oracle(binarizedTrees, op.compoundUnaries);\n    }\n\n    List<Update> updates = Generics.newArrayList();\n    MulticoreWrapper<Integer, Pair<Integer, Integer>> wrapper = null;\n    if (nThreads != 1) {\n      updates = Collections.synchronizedList(updates);\n      wrapper = new MulticoreWrapper<Integer, Pair<Integer, Integer>>(op.trainOptions.trainingThreads, new TrainTreeProcessor(binarizedTrees, transitionLists, updates, oracle));\n    }\n\n    IntCounter<String> featureFrequencies = null;\n    if (op.trainOptions().featureFrequencyCutoff > 1) {\n      featureFrequencies = new IntCounter<String>();\n    }\n\n    for (int iteration = 1; iteration <= op.trainOptions.trainingIterations; ++iteration) {\n      Timing trainingTimer = new Timing();\n      int numCorrect = 0;\n      int numWrong = 0;\n      Collections.shuffle(indices, random);\n      for (int start = 0; start < indices.size(); start += op.trainOptions.batchSize) {\n        int end = Math.min(start + op.trainOptions.batchSize, indices.size());\n        Triple<List<Update>, Integer, Integer> result = trainBatch(indices.subList(start, end), binarizedTrees, transitionLists, updates, oracle, wrapper);\n\n        numCorrect += result.second;\n        numWrong += result.third;\n\n        for (Update update : result.first) {\n          for (String feature : update.features) {\n            Weight weights = featureWeights.get(feature);\n            if (weights == null) {\n              weights = new Weight();\n              featureWeights.put(feature, weights);\n            }\n            weights.updateWeight(update.goldTransition, update.delta);\n            weights.updateWeight(update.predictedTransition, -update.delta);\n\n            if (featureFrequencies != null) {\n              featureFrequencies.incrementCount(feature, (update.goldTransition >= 0 && update.predictedTransition >= 0) ? 2 : 1);\n            }\n          }\n        }\n        updates.clear();\n      }\n      trainingTimer.done(\"Iteration \" + iteration);\n      System.err.println(\"While training, got \" + numCorrect + \" transitions correct and \" + numWrong + \" transitions wrong\");\n      outputStats();\n\n\n      double labelF1 = 0.0;\n      if (devTreebank != null) {\n        EvaluateTreebank evaluator = new EvaluateTreebank(op, null, this, tagger);\n        evaluator.testOnTreebank(devTreebank);\n        labelF1 = evaluator.getLBScore();\n        System.err.println(\"Label F1 after \" + iteration + \" iterations: \" + labelF1);\n        \n        if (labelF1 > bestScore) {\n          System.err.println(\"New best dev score (previous best \" + bestScore + \")\");\n          bestScore = labelF1;\n          bestIteration = iteration;\n        } else {\n          System.err.println(\"Failed to improve for \" + (iteration - bestIteration) + \" iteration(s) on previous best score of \" + bestScore);\n          if (op.trainOptions.stalledIterationLimit > 0 && (iteration - bestIteration >= op.trainOptions.stalledIterationLimit)) {\n            System.err.println(\"Failed to improve for too long, stopping training\");\n            break;\n          }\n        }\n        \n        if (bestModels != null) {\n          bestModels.add(new ScoredObject<ShiftReduceParser>(this.deepCopy(), labelF1));\n          if (bestModels.size() > op.trainOptions().averagedModels) {\n            bestModels.poll();\n          }\n        }\n      }\n      if (op.trainOptions().saveIntermediateModels && serializedPath != null && op.trainOptions.debugOutputFrequency > 0) {\n        String tempName = serializedPath.substring(0, serializedPath.length() - 7) + \"-\" + FILENAME.format(iteration) + \"-\" + NF.format(labelF1) + \".ser.gz\";\n        saveModel(tempName);\n        // TODO: we could save a cutoff version of the model,\n        // especially if we also get a dev set number for it, but that\n        // might be overkill\n      }\n    }\n\n    if (wrapper != null) {\n      wrapper.join();\n    }\n\n    if (bestModels != null) {\n      if (op.trainOptions().cvAveragedModels && devTreebank != null) {\n        List<ScoredObject<ShiftReduceParser>> models = Generics.newArrayList();\n        while (bestModels.size() > 0) {\n          models.add(bestModels.poll());\n        }\n        Collections.reverse(models);\n        double bestF1 = 0.0;\n        int bestSize = 0;\n        for (int i = 1; i <= models.size(); ++i) {\n          System.err.println(\"Testing with \" + i + \" models averaged together\");\n          ShiftReduceParser parser = averageScoredModels(models.subList(0, i));\n          EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n          evaluator.testOnTreebank(devTreebank);\n          double labelF1 = evaluator.getLBScore();\n          System.err.println(\"Label F1 for \" + i + \" models: \" + labelF1);\n          if (labelF1 > bestF1) {\n            bestF1 = labelF1;\n            bestSize = i;\n          }\n        }\n        copyWeights(averageScoredModels(models.subList(0, bestSize)));\n      } else {\n        copyWeights(ShiftReduceParser.averageScoredModels(bestModels));\n      }\n    }\n\n    // TODO: perhaps we should filter the features and then get dev\n    // set scores.  That way we can merge the models which are best\n    // after filtering.\n    if (featureFrequencies != null) {\n      filterFeatures(featureFrequencies.keysAbove(op.trainOptions().featureFrequencyCutoff));\n    }\n\n    condenseFeatures();\n\n    if (serializedPath != null) {\n      try {\n        IOUtils.writeObjectToFile(this, serializedPath);\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n  }","commit_id":"e52f626ac5a87fe6a3002180e4a6058483da8b18","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) {\n    List<String> remainingArgs = Generics.newArrayList();\n\n    String trainTreebankPath = null;\n    FileFilter trainTreebankFilter = null;\n    String testTreebankPath = null;\n    FileFilter testTreebankFilter = null;\n    String devTreebankPath = null;\n    FileFilter devTreebankFilter = null;\n\n    String serializedPath = null;\n\n    String tlppClass = null;\n\n    String continueTraining = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-trainTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-trainTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        trainTreebankPath = treebankDescription.first();\n        trainTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-testTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-testTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        testTreebankPath = treebankDescription.first();\n        testTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-devTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-devTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        devTreebankPath = treebankDescription.first();\n        devTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-serializedPath\")) {\n        serializedPath = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-tlpp\")) {\n        tlppClass = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-continueTraining\")) {\n        continueTraining = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        remainingArgs.add(args[argIndex]);\n        ++argIndex;\n      }\n    }\n\n    String[] newArgs = new String[remainingArgs.size()];\n    newArgs = remainingArgs.toArray(newArgs);\n\n    if (trainTreebankPath == null && serializedPath == null) {\n      throw new IllegalArgumentException(\"Must specify a treebank to train from with -trainTreebank or a parser to load with -serializedPath\");\n    }\n\n    ShiftReduceParser parser = null;\n\n    if (trainTreebankPath != null) {\n      System.err.println(\"Training ShiftReduceParser\");\n      System.err.println(\"Initial arguments:\");\n      System.err.println(\"   \" + StringUtils.join(args));\n      if (continueTraining != null) {\n        parser = ShiftReduceParser.loadModel(continueTraining, ArrayUtils.concatenate(FORCE_TAGS, newArgs));\n      } else {\n        ShiftReduceOptions op = buildTrainingOptions(tlppClass, newArgs);\n        parser = new ShiftReduceParser(op);\n      }\n      parser.trainAndSave(trainTreebankPath, trainTreebankFilter, devTreebankPath, devTreebankFilter, serializedPath);\n    }\n\n    if (serializedPath != null && parser == null) {\n      parser = ShiftReduceParser.loadModel(serializedPath, ArrayUtils.concatenate(FORCE_TAGS, newArgs));\n    }\n\n    //parser.outputStats();\n\n    if (testTreebankPath != null) {\n      System.err.println(\"Loading test trees from \" + testTreebankPath);\n      Treebank testTreebank = parser.op.tlpParams.memoryTreebank();\n      testTreebank.loadPath(testTreebankPath, testTreebankFilter);\n      System.err.println(\"Loaded \" + testTreebank.size() + \" trees\");\n\n      EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n      evaluator.testOnTreebank(testTreebank);\n\n      // System.err.println(\"Input tree: \" + tree);\n      // System.err.println(\"Debinarized tree: \" + query.getBestParse());\n      // System.err.println(\"Parsed binarized tree: \" + query.getBestBinarizedParse());\n      // System.err.println(\"Predicted transition sequence: \" + query.getBestTransitionSequence());\n    }\n  }","id":83236,"modified_method":"public static void main(String[] args) {\n    List<String> remainingArgs = Generics.newArrayList();\n\n    List<Pair<String, FileFilter>> trainTreebankPath = null;\n    Pair<String, FileFilter> testTreebankPath = null;\n    Pair<String, FileFilter> devTreebankPath = null;\n\n    String serializedPath = null;\n\n    String tlppClass = null;\n\n    String continueTraining = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-trainTreebank\")) {\n        if (trainTreebankPath == null) {\n          trainTreebankPath = Generics.newArrayList();\n        }\n        trainTreebankPath.add(ArgUtils.getTreebankDescription(args, argIndex, \"-trainTreebank\"));\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n      } else if (args[argIndex].equalsIgnoreCase(\"-testTreebank\")) {\n        testTreebankPath = ArgUtils.getTreebankDescription(args, argIndex, \"-testTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n      } else if (args[argIndex].equalsIgnoreCase(\"-devTreebank\")) {\n        devTreebankPath = ArgUtils.getTreebankDescription(args, argIndex, \"-devTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n      } else if (args[argIndex].equalsIgnoreCase(\"-serializedPath\")) {\n        serializedPath = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-tlpp\")) {\n        tlppClass = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-continueTraining\")) {\n        continueTraining = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        remainingArgs.add(args[argIndex]);\n        ++argIndex;\n      }\n    }\n\n    String[] newArgs = new String[remainingArgs.size()];\n    newArgs = remainingArgs.toArray(newArgs);\n\n    if (trainTreebankPath == null && serializedPath == null) {\n      throw new IllegalArgumentException(\"Must specify a treebank to train from with -trainTreebank or a parser to load with -serializedPath\");\n    }\n\n    ShiftReduceParser parser = null;\n\n    if (trainTreebankPath != null) {\n      System.err.println(\"Training ShiftReduceParser\");\n      System.err.println(\"Initial arguments:\");\n      System.err.println(\"   \" + StringUtils.join(args));\n      if (continueTraining != null) {\n        parser = ShiftReduceParser.loadModel(continueTraining, ArrayUtils.concatenate(FORCE_TAGS, newArgs));\n      } else {\n        ShiftReduceOptions op = buildTrainingOptions(tlppClass, newArgs);\n        parser = new ShiftReduceParser(op);\n      }\n      parser.trainAndSave(trainTreebankPath, devTreebankPath, serializedPath);\n    }\n\n    if (serializedPath != null && parser == null) {\n      parser = ShiftReduceParser.loadModel(serializedPath, ArrayUtils.concatenate(FORCE_TAGS, newArgs));\n    }\n\n    //parser.outputStats();\n\n    if (testTreebankPath != null) {\n      System.err.println(\"Loading test trees from \" + testTreebankPath.first());\n      Treebank testTreebank = parser.op.tlpParams.memoryTreebank();\n      testTreebank.loadPath(testTreebankPath.first(), testTreebankPath.second());\n      System.err.println(\"Loaded \" + testTreebank.size() + \" trees\");\n\n      EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n      evaluator.testOnTreebank(testTreebank);\n\n      // System.err.println(\"Input tree: \" + tree);\n      // System.err.println(\"Debinarized tree: \" + query.getBestParse());\n      // System.err.println(\"Parsed binarized tree: \" + query.getBestBinarizedParse());\n      // System.err.println(\"Predicted transition sequence: \" + query.getBestTransitionSequence());\n    }\n  }","commit_id":"e52f626ac5a87fe6a3002180e4a6058483da8b18","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static void main(String[] args) {\n    List<String> remainingArgs = Generics.newArrayList();\n\n    String trainTreebankPath = null;\n    FileFilter trainTreebankFilter = null;\n    String testTreebankPath = null;\n    FileFilter testTreebankFilter = null;\n    String devTreebankPath = null;\n    FileFilter devTreebankFilter = null;\n\n    String serializedPath = null;\n\n    String tlppClass = null;\n\n    String continueTraining = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-trainTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-trainTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        trainTreebankPath = treebankDescription.first();\n        trainTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-testTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-testTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        testTreebankPath = treebankDescription.first();\n        testTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-devTreebank\")) {\n        Pair<String, FileFilter> treebankDescription = ArgUtils.getTreebankDescription(args, argIndex, \"-devTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n        devTreebankPath = treebankDescription.first();\n        devTreebankFilter = treebankDescription.second();\n      } else if (args[argIndex].equalsIgnoreCase(\"-serializedPath\")) {\n        serializedPath = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-tlpp\")) {\n        tlppClass = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-continueTraining\")) {\n        continueTraining = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        remainingArgs.add(args[argIndex]);\n        ++argIndex;\n      }\n    }\n\n    String[] newArgs = new String[remainingArgs.size()];\n    newArgs = remainingArgs.toArray(newArgs);\n\n    if (trainTreebankPath == null && serializedPath == null) {\n      throw new IllegalArgumentException(\"Must specify a treebank to train from with -trainTreebank or a parser to load with -serializedPath\");\n    }\n\n    ShiftReduceParser parser = null;\n\n    if (trainTreebankPath != null) {\n      System.err.println(\"Training ShiftReduceParser\");\n      System.err.println(\"Initial arguments:\");\n      System.err.println(\"   \" + StringUtils.join(args));\n      if (continueTraining != null) {\n        parser = ShiftReduceParser.loadModel(continueTraining, ArrayUtils.concatenate(FORCE_TAGS, newArgs));\n      } else {\n        ShiftReduceOptions op = buildTrainingOptions(tlppClass, newArgs);\n        parser = new ShiftReduceParser(op);\n      }\n      parser.trainAndSave(trainTreebankPath, trainTreebankFilter, devTreebankPath, devTreebankFilter, serializedPath);\n    }\n\n    if (serializedPath != null && parser == null) {\n      parser = ShiftReduceParser.loadModel(serializedPath, ArrayUtils.concatenate(FORCE_TAGS, newArgs));\n    }\n\n    //parser.outputStats();\n\n    if (testTreebankPath != null) {\n      System.err.println(\"Loading test trees from \" + testTreebankPath);\n      Treebank testTreebank = parser.op.tlpParams.memoryTreebank();\n      testTreebank.loadPath(testTreebankPath, testTreebankFilter);\n      System.err.println(\"Loaded \" + testTreebank.size() + \" trees\");\n\n      EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n      evaluator.testOnTreebank(testTreebank);\n\n      // System.err.println(\"Input tree: \" + tree);\n      // System.err.println(\"Debinarized tree: \" + query.getBestParse());\n      // System.err.println(\"Parsed binarized tree: \" + query.getBestBinarizedParse());\n      // System.err.println(\"Predicted transition sequence: \" + query.getBestTransitionSequence());\n    }\n  }","id":83237,"modified_method":"public static void main(String[] args) {\n    List<String> remainingArgs = Generics.newArrayList();\n\n    List<Pair<String, FileFilter>> trainTreebankPath = null;\n    Pair<String, FileFilter> testTreebankPath = null;\n    Pair<String, FileFilter> devTreebankPath = null;\n\n    String serializedPath = null;\n\n    String tlppClass = null;\n\n    String continueTraining = null;\n\n    for (int argIndex = 0; argIndex < args.length; ) {\n      if (args[argIndex].equalsIgnoreCase(\"-trainTreebank\")) {\n        if (trainTreebankPath == null) {\n          trainTreebankPath = Generics.newArrayList();\n        }\n        trainTreebankPath.add(ArgUtils.getTreebankDescription(args, argIndex, \"-trainTreebank\"));\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n      } else if (args[argIndex].equalsIgnoreCase(\"-testTreebank\")) {\n        testTreebankPath = ArgUtils.getTreebankDescription(args, argIndex, \"-testTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n      } else if (args[argIndex].equalsIgnoreCase(\"-devTreebank\")) {\n        devTreebankPath = ArgUtils.getTreebankDescription(args, argIndex, \"-devTreebank\");\n        argIndex = argIndex + ArgUtils.numSubArgs(args, argIndex) + 1;\n      } else if (args[argIndex].equalsIgnoreCase(\"-serializedPath\")) {\n        serializedPath = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-tlpp\")) {\n        tlppClass = args[argIndex + 1];\n        argIndex += 2;\n      } else if (args[argIndex].equalsIgnoreCase(\"-continueTraining\")) {\n        continueTraining = args[argIndex + 1];\n        argIndex += 2;\n      } else {\n        remainingArgs.add(args[argIndex]);\n        ++argIndex;\n      }\n    }\n\n    String[] newArgs = new String[remainingArgs.size()];\n    newArgs = remainingArgs.toArray(newArgs);\n\n    if (trainTreebankPath == null && serializedPath == null) {\n      throw new IllegalArgumentException(\"Must specify a treebank to train from with -trainTreebank or a parser to load with -serializedPath\");\n    }\n\n    ShiftReduceParser parser = null;\n\n    if (trainTreebankPath != null) {\n      System.err.println(\"Training ShiftReduceParser\");\n      System.err.println(\"Initial arguments:\");\n      System.err.println(\"   \" + StringUtils.join(args));\n      if (continueTraining != null) {\n        parser = ShiftReduceParser.loadModel(continueTraining, ArrayUtils.concatenate(FORCE_TAGS, newArgs));\n      } else {\n        ShiftReduceOptions op = buildTrainingOptions(tlppClass, newArgs);\n        parser = new ShiftReduceParser(op);\n      }\n      parser.trainAndSave(trainTreebankPath, devTreebankPath, serializedPath);\n    }\n\n    if (serializedPath != null && parser == null) {\n      parser = ShiftReduceParser.loadModel(serializedPath, ArrayUtils.concatenate(FORCE_TAGS, newArgs));\n    }\n\n    //parser.outputStats();\n\n    if (testTreebankPath != null) {\n      System.err.println(\"Loading test trees from \" + testTreebankPath.first());\n      Treebank testTreebank = parser.op.tlpParams.memoryTreebank();\n      testTreebank.loadPath(testTreebankPath.first(), testTreebankPath.second());\n      System.err.println(\"Loaded \" + testTreebank.size() + \" trees\");\n\n      EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n      evaluator.testOnTreebank(testTreebank);\n\n      // System.err.println(\"Input tree: \" + tree);\n      // System.err.println(\"Debinarized tree: \" + query.getBestParse());\n      // System.err.println(\"Parsed binarized tree: \" + query.getBestBinarizedParse());\n      // System.err.println(\"Predicted transition sequence: \" + query.getBestTransitionSequence());\n    }\n  }","commit_id":"11ea3740d7f4fe07af2f4efb9ccd48d463b84de6","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private void trainAndSave(String trainTreebankPath, FileFilter trainTreebankFilter,\n                            String devTreebankPath, FileFilter devTreebankFilter,\n                            String serializedPath) {\n    List<Tree> binarizedTrees = readBinarizedTreebank(trainTreebankPath, trainTreebankFilter);\n\n    int nThreads = op.trainOptions.trainingThreads;\n    nThreads = nThreads <= 0 ? Runtime.getRuntime().availableProcessors() : nThreads;      \n\n    MaxentTagger tagger = null;\n    if (op.testOptions.preTag) {\n      Timing retagTimer = new Timing();\n      tagger = new MaxentTagger(op.testOptions.taggerSerializedFile);\n      redoTags(binarizedTrees, tagger, nThreads);\n      retagTimer.done(\"Retagging\");\n    }\n\n    Timing transitionTimer = new Timing();\n    List<List<Transition>> transitionLists = createTransitionSequences(binarizedTrees);\n    for (List<Transition> transitions : transitionLists) {\n      transitionIndex.addAll(transitions);\n    }\n    transitionTimer.done(\"Converting trees into transition lists\");\n    System.err.println(\"Number of transitions: \" + transitionIndex.size());\n    \n    Random random = new Random(op.trainOptions.randomSeed);\n\n    Treebank devTreebank = null;\n    if (devTreebankPath != null) {\n      devTreebank = readTreebank(devTreebankPath, devTreebankFilter);\n    }\n\n    double bestScore = 0.0;\n    int bestIteration = 0;\n    PriorityQueue<ScoredObject<ShiftReduceParser>> bestModels = null;\n    if (op.trainOptions().averagedModels > 0) {\n      bestModels = new PriorityQueue<ScoredObject<ShiftReduceParser>>(op.trainOptions().averagedModels + 1, ScoredComparator.ASCENDING_COMPARATOR);\n    }\n\n    List<Integer> indices = Generics.newArrayList();\n    for (int i = 0; i < binarizedTrees.size(); ++i) {\n      indices.add(i);\n    }\n\n    Oracle oracle = null;\n    if (op.trainOptions().trainingMethod == ShiftReduceTrainOptions.TrainingMethod.ORACLE) {\n      oracle = new Oracle(binarizedTrees, op.compoundUnaries);\n    }\n\n    List<Update> updates = Generics.newArrayList();\n    MulticoreWrapper<Integer, Pair<Integer, Integer>> wrapper = null;\n    if (nThreads != 1) {\n      updates = Collections.synchronizedList(updates);\n      wrapper = new MulticoreWrapper<Integer, Pair<Integer, Integer>>(op.trainOptions.trainingThreads, new TrainTreeProcessor(binarizedTrees, transitionLists, updates, oracle));\n    }\n\n    IntCounter<String> featureFrequencies = null;\n    if (op.trainOptions().featureFrequencyCutoff > 1) {\n      featureFrequencies = new IntCounter<String>();\n    }\n\n    for (int iteration = 1; iteration <= op.trainOptions.trainingIterations; ++iteration) {\n      Timing trainingTimer = new Timing();\n      int numCorrect = 0;\n      int numWrong = 0;\n      Collections.shuffle(indices, random);\n      for (int start = 0; start < indices.size(); start += op.trainOptions.batchSize) {\n        int end = Math.min(start + op.trainOptions.batchSize, indices.size());\n        Triple<List<Update>, Integer, Integer> result = trainBatch(indices.subList(start, end), binarizedTrees, transitionLists, updates, oracle, wrapper);\n\n        numCorrect += result.second;\n        numWrong += result.third;\n\n        for (Update update : result.first) {\n          for (String feature : update.features) {\n            Weight weights = featureWeights.get(feature);\n            if (weights == null) {\n              weights = new Weight();\n              featureWeights.put(feature, weights);\n            }\n            weights.updateWeight(update.goldTransition, update.delta);\n            weights.updateWeight(update.predictedTransition, -update.delta);\n\n            if (featureFrequencies != null) {\n              featureFrequencies.incrementCount(feature, (update.goldTransition >= 0 && update.predictedTransition >= 0) ? 2 : 1);\n            }\n          }\n        }\n        updates.clear();\n      }\n      trainingTimer.done(\"Iteration \" + iteration);\n      System.err.println(\"While training, got \" + numCorrect + \" transitions correct and \" + numWrong + \" transitions wrong\");\n      outputStats();\n\n\n      double labelF1 = 0.0;\n      if (devTreebank != null) {\n        EvaluateTreebank evaluator = new EvaluateTreebank(op, null, this, tagger);\n        evaluator.testOnTreebank(devTreebank);\n        labelF1 = evaluator.getLBScore();\n        System.err.println(\"Label F1 after \" + iteration + \" iterations: \" + labelF1);\n        \n        if (labelF1 > bestScore) {\n          System.err.println(\"New best dev score (previous best \" + bestScore + \")\");\n          bestScore = labelF1;\n          bestIteration = iteration;\n        } else {\n          System.err.println(\"Failed to improve for \" + (iteration - bestIteration) + \" iteration(s) on previous best score of \" + bestScore);\n          if (op.trainOptions.stalledIterationLimit > 0 && (iteration - bestIteration >= op.trainOptions.stalledIterationLimit)) {\n            System.err.println(\"Failed to improve for too long, stopping training\");\n            break;\n          }\n        }\n        \n        if (bestModels != null) {\n          bestModels.add(new ScoredObject<ShiftReduceParser>(this.deepCopy(), labelF1));\n          if (bestModels.size() > op.trainOptions().averagedModels) {\n            bestModels.poll();\n          }\n        }\n      }\n      if (op.trainOptions().saveIntermediateModels && serializedPath != null && op.trainOptions.debugOutputFrequency > 0) {\n        String tempName = serializedPath.substring(0, serializedPath.length() - 7) + \"-\" + FILENAME.format(iteration) + \"-\" + NF.format(labelF1) + \".ser.gz\";\n        saveModel(tempName);\n        // TODO: we could save a cutoff version of the model,\n        // especially if we also get a dev set number for it, but that\n        // might be overkill\n      }\n    }\n\n    if (wrapper != null) {\n      wrapper.join();\n    }\n\n    if (bestModels != null) {\n      if (op.trainOptions().cvAveragedModels && devTreebank != null) {\n        List<ScoredObject<ShiftReduceParser>> models = Generics.newArrayList();\n        while (bestModels.size() > 0) {\n          models.add(bestModels.poll());\n        }\n        Collections.reverse(models);\n        double bestF1 = 0.0;\n        int bestSize = 0;\n        for (int i = 1; i <= models.size(); ++i) {\n          System.err.println(\"Testing with \" + i + \" models averaged together\");\n          ShiftReduceParser parser = averageScoredModels(models.subList(0, i));\n          EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n          evaluator.testOnTreebank(devTreebank);\n          double labelF1 = evaluator.getLBScore();\n          System.err.println(\"Label F1 for \" + i + \" models: \" + labelF1);\n          if (labelF1 > bestF1) {\n            bestF1 = labelF1;\n            bestSize = i;\n          }\n        }\n        copyWeights(averageScoredModels(models.subList(0, bestSize)));\n      } else {\n        copyWeights(ShiftReduceParser.averageScoredModels(bestModels));\n      }\n    }\n\n    // TODO: perhaps we should filter the features and then get dev\n    // set scores.  That way we can merge the models which are best\n    // after filtering.\n    if (featureFrequencies != null) {\n      filterFeatures(featureFrequencies.keysAbove(op.trainOptions().featureFrequencyCutoff));\n    }\n\n    condenseFeatures();\n\n    if (serializedPath != null) {\n      try {\n        IOUtils.writeObjectToFile(this, serializedPath);\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n  }","id":83238,"modified_method":"private void trainAndSave(List<Pair<String, FileFilter>> trainTreebankPath, \n                            Pair<String, FileFilter> devTreebankPath,\n                            String serializedPath) {\n    List<Tree> binarizedTrees = Generics.newArrayList();\n    for (Pair<String, FileFilter> treebank : trainTreebankPath) {\n      binarizedTrees.addAll(readBinarizedTreebank(treebank.first(), treebank.second()));\n    }\n\n    int nThreads = op.trainOptions.trainingThreads;\n    nThreads = nThreads <= 0 ? Runtime.getRuntime().availableProcessors() : nThreads;      \n\n    MaxentTagger tagger = null;\n    if (op.testOptions.preTag) {\n      Timing retagTimer = new Timing();\n      tagger = new MaxentTagger(op.testOptions.taggerSerializedFile);\n      redoTags(binarizedTrees, tagger, nThreads);\n      retagTimer.done(\"Retagging\");\n    }\n\n    Timing transitionTimer = new Timing();\n    List<List<Transition>> transitionLists = createTransitionSequences(binarizedTrees);\n    for (List<Transition> transitions : transitionLists) {\n      transitionIndex.addAll(transitions);\n    }\n    transitionTimer.done(\"Converting trees into transition lists\");\n    System.err.println(\"Number of transitions: \" + transitionIndex.size());\n    \n    Random random = new Random(op.trainOptions.randomSeed);\n\n    Treebank devTreebank = null;\n    if (devTreebankPath != null) {\n      devTreebank = readTreebank(devTreebankPath.first(), devTreebankPath.second());\n    }\n\n    double bestScore = 0.0;\n    int bestIteration = 0;\n    PriorityQueue<ScoredObject<ShiftReduceParser>> bestModels = null;\n    if (op.trainOptions().averagedModels > 0) {\n      bestModels = new PriorityQueue<ScoredObject<ShiftReduceParser>>(op.trainOptions().averagedModels + 1, ScoredComparator.ASCENDING_COMPARATOR);\n    }\n\n    List<Integer> indices = Generics.newArrayList();\n    for (int i = 0; i < binarizedTrees.size(); ++i) {\n      indices.add(i);\n    }\n\n    Oracle oracle = null;\n    if (op.trainOptions().trainingMethod == ShiftReduceTrainOptions.TrainingMethod.ORACLE) {\n      oracle = new Oracle(binarizedTrees, op.compoundUnaries);\n    }\n\n    List<Update> updates = Generics.newArrayList();\n    MulticoreWrapper<Integer, Pair<Integer, Integer>> wrapper = null;\n    if (nThreads != 1) {\n      updates = Collections.synchronizedList(updates);\n      wrapper = new MulticoreWrapper<Integer, Pair<Integer, Integer>>(op.trainOptions.trainingThreads, new TrainTreeProcessor(binarizedTrees, transitionLists, updates, oracle));\n    }\n\n    IntCounter<String> featureFrequencies = null;\n    if (op.trainOptions().featureFrequencyCutoff > 1) {\n      featureFrequencies = new IntCounter<String>();\n    }\n\n    for (int iteration = 1; iteration <= op.trainOptions.trainingIterations; ++iteration) {\n      Timing trainingTimer = new Timing();\n      int numCorrect = 0;\n      int numWrong = 0;\n      Collections.shuffle(indices, random);\n      for (int start = 0; start < indices.size(); start += op.trainOptions.batchSize) {\n        int end = Math.min(start + op.trainOptions.batchSize, indices.size());\n        Triple<List<Update>, Integer, Integer> result = trainBatch(indices.subList(start, end), binarizedTrees, transitionLists, updates, oracle, wrapper);\n\n        numCorrect += result.second;\n        numWrong += result.third;\n\n        for (Update update : result.first) {\n          for (String feature : update.features) {\n            Weight weights = featureWeights.get(feature);\n            if (weights == null) {\n              weights = new Weight();\n              featureWeights.put(feature, weights);\n            }\n            weights.updateWeight(update.goldTransition, update.delta);\n            weights.updateWeight(update.predictedTransition, -update.delta);\n\n            if (featureFrequencies != null) {\n              featureFrequencies.incrementCount(feature, (update.goldTransition >= 0 && update.predictedTransition >= 0) ? 2 : 1);\n            }\n          }\n        }\n        updates.clear();\n      }\n      trainingTimer.done(\"Iteration \" + iteration);\n      System.err.println(\"While training, got \" + numCorrect + \" transitions correct and \" + numWrong + \" transitions wrong\");\n      outputStats();\n\n\n      double labelF1 = 0.0;\n      if (devTreebank != null) {\n        EvaluateTreebank evaluator = new EvaluateTreebank(op, null, this, tagger);\n        evaluator.testOnTreebank(devTreebank);\n        labelF1 = evaluator.getLBScore();\n        System.err.println(\"Label F1 after \" + iteration + \" iterations: \" + labelF1);\n        \n        if (labelF1 > bestScore) {\n          System.err.println(\"New best dev score (previous best \" + bestScore + \")\");\n          bestScore = labelF1;\n          bestIteration = iteration;\n        } else {\n          System.err.println(\"Failed to improve for \" + (iteration - bestIteration) + \" iteration(s) on previous best score of \" + bestScore);\n          if (op.trainOptions.stalledIterationLimit > 0 && (iteration - bestIteration >= op.trainOptions.stalledIterationLimit)) {\n            System.err.println(\"Failed to improve for too long, stopping training\");\n            break;\n          }\n        }\n        \n        if (bestModels != null) {\n          bestModels.add(new ScoredObject<ShiftReduceParser>(this.deepCopy(), labelF1));\n          if (bestModels.size() > op.trainOptions().averagedModels) {\n            bestModels.poll();\n          }\n        }\n      }\n      if (op.trainOptions().saveIntermediateModels && serializedPath != null && op.trainOptions.debugOutputFrequency > 0) {\n        String tempName = serializedPath.substring(0, serializedPath.length() - 7) + \"-\" + FILENAME.format(iteration) + \"-\" + NF.format(labelF1) + \".ser.gz\";\n        saveModel(tempName);\n        // TODO: we could save a cutoff version of the model,\n        // especially if we also get a dev set number for it, but that\n        // might be overkill\n      }\n    }\n\n    if (wrapper != null) {\n      wrapper.join();\n    }\n\n    if (bestModels != null) {\n      if (op.trainOptions().cvAveragedModels && devTreebank != null) {\n        List<ScoredObject<ShiftReduceParser>> models = Generics.newArrayList();\n        while (bestModels.size() > 0) {\n          models.add(bestModels.poll());\n        }\n        Collections.reverse(models);\n        double bestF1 = 0.0;\n        int bestSize = 0;\n        for (int i = 1; i <= models.size(); ++i) {\n          System.err.println(\"Testing with \" + i + \" models averaged together\");\n          ShiftReduceParser parser = averageScoredModels(models.subList(0, i));\n          EvaluateTreebank evaluator = new EvaluateTreebank(parser.op, null, parser);\n          evaluator.testOnTreebank(devTreebank);\n          double labelF1 = evaluator.getLBScore();\n          System.err.println(\"Label F1 for \" + i + \" models: \" + labelF1);\n          if (labelF1 > bestF1) {\n            bestF1 = labelF1;\n            bestSize = i;\n          }\n        }\n        copyWeights(averageScoredModels(models.subList(0, bestSize)));\n      } else {\n        copyWeights(ShiftReduceParser.averageScoredModels(bestModels));\n      }\n    }\n\n    // TODO: perhaps we should filter the features and then get dev\n    // set scores.  That way we can merge the models which are best\n    // after filtering.\n    if (featureFrequencies != null) {\n      filterFeatures(featureFrequencies.keysAbove(op.trainOptions().featureFrequencyCutoff));\n    }\n\n    condenseFeatures();\n\n    if (serializedPath != null) {\n      try {\n        IOUtils.writeObjectToFile(this, serializedPath);\n      } catch (IOException e) {\n        throw new RuntimeIOException(e);\n      }\n    }\n  }","commit_id":"11ea3740d7f4fe07af2f4efb9ccd48d463b84de6","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Tokenizes the given <code>sentence<\/code> into words and analyzes it.\n   * \n   * @throws IOException\n   */\n  public AnalyzedSentence getAnalyzedSentence(final String sentence)\n      throws IOException {\n    final List<String> tokens = wordTokenizer.tokenize(sentence);\n    final Map<Integer, String> softHyphenTokens = new HashMap<Integer, String>();\n\n    //for softhyphens inside words, happens especially in OOo:\n    for (int i = 0; i < tokens.size(); i++) {\n      if (tokens.get(i).indexOf('\\u00ad') != -1) {\n        softHyphenTokens.put(i, tokens.get(i));\n        tokens.set(i, tokens.get(i).replaceAll(\"\\u00ad\", \"\"));\n      }\n    }\n    \n    final List<AnalyzedTokenReadings> aTokens = tagger.tag(tokens);\n    final int numTokens = aTokens.size();\n    int posFix = 0; \n    for (int i = 1; i < numTokens; i++) {\n      aTokens.get(i).setWhitespaceBefore(aTokens.get(i - 1).isWhitespace());\n      aTokens.get(i).setStartPos(aTokens.get(i).getStartPos() + posFix);\n      if (!softHyphenTokens.isEmpty()) {\n        if (softHyphenTokens.get(i) != null) {\n          aTokens.get(i).addReading(new AnalyzedToken(softHyphenTokens.get(i), null, aTokens.get(i).getStartPos()));\n          posFix += softHyphenTokens.get(i).length() - aTokens.get(i).getToken().length();\n        }\n      }\n    }\n        \n    final AnalyzedTokenReadings[] tokenArray = new AnalyzedTokenReadings[tokens\n        .size() + 1];\n    final AnalyzedToken[] startTokenArray = new AnalyzedToken[1];\n    int toArrayCount = 0;\n    final AnalyzedToken sentenceStartToken = new AnalyzedToken(\"\",\n        SENTENCE_START_TAGNAME, 0);\n    startTokenArray[0] = sentenceStartToken;\n    tokenArray[toArrayCount++] = new AnalyzedTokenReadings(startTokenArray);\n    int startPos = 0;\n    for (final AnalyzedTokenReadings posTag : aTokens) {\n      posTag.setStartPos(startPos);\n      tokenArray[toArrayCount++] = posTag;\n      startPos += posTag.getToken().length();\n    }\n\n    // add additional tags\n    int lastToken = toArrayCount - 1;\n    // make SENT_END appear at last not whitespace token\n    for (int i = 0; i < toArrayCount - 1; i++) {\n      if (!tokenArray[lastToken - i].isWhitespace()) {\n        lastToken -= i;\n        break;\n      }\n    }\n\n    tokenArray[lastToken].setSentEnd();\n\n    if (tokenArray.length == 2 && (tokenArray[0].isSentStart())\n        && tokenArray[1].isLinebreak()) {\n      tokenArray[lastToken].setParaEnd();\n    }\n\n    AnalyzedSentence finalSentence = new AnalyzedSentence(tokenArray);\n    // disambiguate assigned tags\n    finalSentence = disambiguator.disambiguate(finalSentence);\n\n    return finalSentence;\n  }","id":83239,"modified_method":"/**\n   * Tokenizes the given <code>sentence<\/code> into words and analyzes it.\n   * \n   * @throws IOException\n   */\n  public AnalyzedSentence getAnalyzedSentence(final String sentence)\n      throws IOException {\n    final List<String> tokens = wordTokenizer.tokenize(sentence);\n    final Map<Integer, String> softHyphenTokens = new HashMap<Integer, String>();\n\n    //for softhyphens inside words, happens especially in OOo:\n    for (int i = 0; i < tokens.size(); i++) {\n      if (tokens.get(i).indexOf('\\u00ad') != -1) {\n        softHyphenTokens.put(i, tokens.get(i));\n        tokens.set(i, tokens.get(i).replaceAll(\"\\u00ad\", \"\"));\n      }\n    }\n    \n    final List<AnalyzedTokenReadings> aTokens = tagger.tag(tokens);\n    final int numTokens = aTokens.size();\n    int posFix = 0; \n    for (int i = 1; i < numTokens; i++) {\n      aTokens.get(i).setWhitespaceBefore(aTokens.get(i - 1).isWhitespace());\n      aTokens.get(i).setStartPos(aTokens.get(i).getStartPos() + posFix);\n      if (!softHyphenTokens.isEmpty()) {\n        if (softHyphenTokens.get(i) != null) {\n          aTokens.get(i).addReading(new AnalyzedToken(softHyphenTokens.get(i), null, aTokens.get(i).getStartPos()));\n          posFix += softHyphenTokens.get(i).length() - aTokens.get(i).getToken().length();\n        }\n      }\n    }\n        \n    final AnalyzedTokenReadings[] tokenArray = new AnalyzedTokenReadings[tokens\n        .size() + 1];\n    final AnalyzedToken[] startTokenArray = new AnalyzedToken[1];\n    int toArrayCount = 0;\n    final AnalyzedToken sentenceStartToken = new AnalyzedToken(\"\",\n        SENTENCE_START_TAGNAME, 0);\n    startTokenArray[0] = sentenceStartToken;\n    tokenArray[toArrayCount++] = new AnalyzedTokenReadings(startTokenArray);\n    int startPos = 0;\n    for (final AnalyzedTokenReadings posTag : aTokens) {\n      posTag.setStartPos(startPos);\n      tokenArray[toArrayCount++] = posTag;\n      startPos += posTag.getToken().length();\n    }\n\n    // add additional tags\n    int lastToken = toArrayCount - 1;\n    // make SENT_END appear at last not whitespace token\n    for (int i = 0; i < toArrayCount - 1; i++) {\n      if (!tokenArray[lastToken - i].isWhitespace()) {\n        lastToken -= i;\n        break;\n      }\n    }\n\n    tokenArray[lastToken].setSentEnd();\n\n    if (tokenArray.length == lastToken + 1 && tokenArray[lastToken].isLinebreak()) {\n      tokenArray[lastToken].setParaEnd();\n    }\n\n    AnalyzedSentence finalSentence = new AnalyzedSentence(tokenArray);\n    // disambiguate assigned tags\n    finalSentence = disambiguator.disambiguate(finalSentence);\n\n    return finalSentence;\n  }","commit_id":"cffe843f56d4c046d94068757b8dba0e67931235","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final RuleMatch[] match(final AnalyzedSentence text) {\n    final List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();\n    final AnalyzedTokenReadings[] tokens = text.getTokens();\n    AnalyzedToken matchToken = null;\n\n    if (reachedEndOfParagraph) {\n      reset();\n    }\n\n    int ruleMatchIndex = getMatchesIndex();\n\n    int pos = 0;\n    for (int j = 0; j < startSymbols.length; j++) {\n      for (int i = 1; i < tokens.length; i++) {\n        final String token = tokens[i].getToken().trim();\n        boolean precededByWhitespace = true;\n        if (startSymbols[j].equals(endSymbols[j])) {\n          precededByWhitespace = tokens[i].isWhitespaceBefore()\n              || tokens[i - 1].getToken().matches(\"\\\\p{Punct}(?<!\\\\.)\");\n        }\n\n        boolean followedByWhitespace = true;\n        if (i < tokens.length - 1 && startSymbols[j].equals(endSymbols[j])) {\n          followedByWhitespace = tokens[i + 1].isWhitespace()\n              || tokens[i + 1].getToken().matches(\"\\\\p{Punct}\");\n        }\n\n        if (followedByWhitespace && precededByWhitespace) {\n          if (i == tokens.length) {\n            precededByWhitespace = false;\n          } else if (startSymbols[j].equals(endSymbols[j])) {\n            if (symbolCounter[j] > 0) {\n              precededByWhitespace = false;\n            } else {\n              followedByWhitespace = false;\n            }\n          }\n        }\n\n        boolean noException = true;\n\n        // exception for English inches, e.g., 20\"\n        if ((precededByWhitespace || followedByWhitespace) && i > 1\n            && ruleLang.equals(Language.ENGLISH) && token.equals(\"\\\"\")\n            && tokens[i - 1].getToken().matches(\"[\\\\d]+\")) {\n          noException = false;\n        }\n\n        // Exception for English plural saxon genetive\n        // TODO: add POS checking\n        if ((precededByWhitespace || followedByWhitespace)\n            && ruleLang.equals(Language.ENGLISH)\n            && \"'\".equals(token)\n            && i > 1\n            && noException\n            && (tokens[i - 1].getToken().charAt(\n                tokens[i - 1].getToken().length() - 1) == 's')) {\n          noException = false;\n        }\n\n        if (noException && precededByWhitespace\n            && token.equals(startSymbols[j])) {\n          symbolCounter[j]++;\n          pos = i;\n        } else if (noException && followedByWhitespace\n            && token.equals(endSymbols[j])) {\n          if (i > 1 && endSymbols[j].equals(\")\") && symbolCounter[j] == 0) {\n            // exception for bulletting: 1), 2), 3)...,\n            // II), 2') and 1a).\n            if (!(tokens[i - 1].getToken()\n                .matches(\"(?i)\\\\d{1,2}?[a-z']*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$\"))) {\n              symbolCounter[j]--;\n              pos = i;\n            }\n          } else {\n            symbolCounter[j]--;\n            pos = i;\n          }\n        }\n      }\n\n      for (int i = 0; i < symbolCounter.length; i++) {\n        if (symbolCounter[i] != 0) {\n          if (ruleMatchArray[i] != 0) {\n            if (isInMatches(ruleMatchArray[i] - 1)) {\n              setAsDeleted(ruleMatchArray[i] - 1);\n              ruleMatchArray[i] = 0;\n            } else {\n              ruleMatchIndex++;\n              ruleMatchArray[i] = ruleMatchIndex;\n              matchToken = tokens[pos].getAnalyzedToken(0);\n              final RuleMatch ruleMatch = new RuleMatch(this, matchToken\n                  .getStartPos(), matchToken.getStartPos() + 1, messages\n                  .getString(\"unpaired_brackets\"));\n              ruleMatches.add(ruleMatch);\n            }\n          } else {\n            ruleMatchIndex++;\n            ruleMatchArray[i] = ruleMatchIndex;\n            matchToken = tokens[pos].getAnalyzedToken(0);\n            final RuleMatch ruleMatch = new RuleMatch(this, matchToken\n                .getStartPos(), matchToken.getStartPos() + 1, messages\n                .getString(\"unpaired_brackets\"));\n            ruleMatches.add(ruleMatch);\n          }\n\n          symbolCounter[i] = 0;\n\n        }\n      }\n    }\n\n    if (tokens[tokens.length - 1].isParaEnd()) {\n      reachedEndOfParagraph = true;\n    }\n\n    return toRuleMatchArray(ruleMatches);\n  }","id":83240,"modified_method":"public final RuleMatch[] match(final AnalyzedSentence text) {\n    final List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();\n    final AnalyzedTokenReadings[] tokens = text.getTokens();\n    AnalyzedToken matchToken = null;\n\n    if (reachedEndOfParagraph) {\n      reset();\n    }\n\n    int ruleMatchIndex = getMatchesIndex();\n\n    int pos = 0;\n    for (int j = 0; j < startSymbols.length; j++) {\n      for (int i = 1; i < tokens.length; i++) {\n        final String token = tokens[i].getToken().trim();\n        boolean precededByWhitespace = true;\n        if (startSymbols[j].equals(endSymbols[j])) {\n          precededByWhitespace = tokens[i].isWhitespaceBefore()\n              || PUNCTUATION_NO_DOT.matcher(tokens[i - 1].getToken()).matches();\n        }\n\n        boolean followedByWhitespace = true;\n        if (i < tokens.length - 1 && startSymbols[j].equals(endSymbols[j])) {\n          followedByWhitespace = tokens[i + 1].isWhitespace()\n              || PUNCTUATION.matcher(tokens[i + 1].getToken()).matches();\n        }\n\n        if (followedByWhitespace && precededByWhitespace) {\n          if (i == tokens.length) {\n            precededByWhitespace = false;\n          } else if (startSymbols[j].equals(endSymbols[j])) {\n            if (symbolCounter[j] > 0) {\n              precededByWhitespace = false;\n            } else {\n              followedByWhitespace = false;\n            }\n          }\n        }\n\n        boolean noException = true;\n\n        if (ruleLang.equals(Language.ENGLISH) && i > 1) {\n\n          // exception for English inches, e.g., 20\"\n          if ((precededByWhitespace || followedByWhitespace)\n              && \"\\\"\".equals(token)\n              && NUMBER.matcher(tokens[i - 1].getToken()).matches()) {\n            noException = false;\n          }\n\n          // Exception for English plural saxon genetive\n          if ((precededByWhitespace || followedByWhitespace)\n              && \"'\".equals(token)\n              && noException\n              && (tokens[i - 1].getToken().charAt(\n                  tokens[i - 1].getToken().length() - 1) == 's')\n              && (tokens[i - 1].hasPosTag(\"NNS\") || tokens[i - 1].hasPosTag(\"NNPS\"))) {\n            noException = false;\n          }\n        }\n\n        if (noException && precededByWhitespace\n            && token.equals(startSymbols[j])) {\n          symbolCounter[j]++;\n          pos = i;\n        } else if (noException && followedByWhitespace\n            && token.equals(endSymbols[j])) {\n          if (i > 1 && endSymbols[j].equals(\")\") && symbolCounter[j] == 0) {\n            // exception for bullets: 1), 2), 3)...,\n            // II), 2') and 1a).\n            if (!NUMERALS.matcher(tokens[i - 1].getToken()).matches()) {\n              symbolCounter[j]--;\n              pos = i;\n            }\n          } else {\n            symbolCounter[j]--;\n            pos = i;\n          }\n        }\n      }\n\n      for (int i = 0; i < symbolCounter.length; i++) {\n        if (symbolCounter[i] != 0) {\n          if (ruleMatchArray[i] != 0 && isInMatches(ruleMatchArray[i] - 1)) {\n            setAsDeleted(ruleMatchArray[i] - 1);\n            ruleMatchArray[i] = 0;\n          } else {\n            ruleMatchIndex++;\n            ruleMatchArray[i] = ruleMatchIndex;\n            matchToken = tokens[pos].getAnalyzedToken(0);\n            final RuleMatch ruleMatch = new RuleMatch(this, matchToken\n                .getStartPos(), matchToken.getStartPos() + 1, messages\n                .getString(\"unpaired_brackets\"));\n            ruleMatches.add(ruleMatch);\n          }\n\n          symbolCounter[i] = 0;\n\n        }\n      }\n    }\n\n    if (tokens[tokens.length - 1].isParaEnd()) {\n      reachedEndOfParagraph = true;\n    }\n\n    return toRuleMatchArray(ruleMatches);\n  }","commit_id":"cffe843f56d4c046d94068757b8dba0e67931235","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void testRule() throws IOException {\n    UnpairedQuotesBracketsRule rule = new UnpairedQuotesBracketsRule(TestTools.getEnglishMessages(), Language.ENGLISH);\n    RuleMatch[] matches;\n    JLanguageTool langTool = new JLanguageTool(Language.ENGLISH);\n    // correct sentences:\n    matches = rule.match(langTool.getAnalyzedSentence(\"(This is a test sentence).\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"This is a word 'test'.\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"This is the joint presidents' declaration.\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"The screen is 20\\\" wide.\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"This is a [test] sentence...\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"The plight of Tamil refugees caused a surge of support from most of the Tamil political parties.[90]\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"(([20] [20] [20]))\"));\n    assertEquals(0, matches.length);\n    // numerical bullets\n    matches = rule.match(langTool.getAnalyzedSentence(\"We discussed this in Chapter 1).\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"We discussed this in section 1a).\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"We discussed this in section iv).\"));\n    assertEquals(0, matches.length);\n    // incorrect sentences:\n    matches = rule.match(langTool.getAnalyzedSentence(\"(This is a test sentence.\"));\n    assertEquals(1, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"(This is a test\u201d sentence.\"));\n    assertEquals(2, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"This is a {test sentence.\"));\n    assertEquals(1, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"This [is (a test} sentence.\"));\n    assertEquals(3, matches.length);\n  }","id":83241,"modified_method":"public void testRule() throws IOException {\n    UnpairedQuotesBracketsRule rule = new UnpairedQuotesBracketsRule(TestTools\n        .getEnglishMessages(), Language.ENGLISH);\n    RuleMatch[] matches;\n    JLanguageTool langTool = new JLanguageTool(Language.ENGLISH);\n    // correct sentences:\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"(This is a test sentence).\"));\n    assertEquals(0, matches.length);\n    matches = rule\n        .match(langTool.getAnalyzedSentence(\"This is a word 'test'.\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"This is the joint presidents' declaration.\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"The screen is 20\\\" wide.\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"This is a [test] sentence...\"));\n    assertEquals(0, matches.length);\n    matches = rule\n        .match(langTool\n            .getAnalyzedSentence(\"The plight of Tamil refugees caused a surge of support from most of the Tamil political parties.[90]\"));\n    assertEquals(0, matches.length);\n    matches = rule\n        .match(langTool\n            .getAnalyzedSentence(\"This is what he said: \\\"We believe in freedom. This is what we do.\\\"\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool.getAnalyzedSentence(\"(([20] [20] [20]))\"));\n    assertEquals(0, matches.length);\n    // numerical bullets\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"We discussed this in Chapter 1).\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"We discussed this in section 1a).\"));\n    assertEquals(0, matches.length);\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"We discussed this in section iv).\"));\n    assertEquals(0, matches.length);\n    // incorrect sentences:\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"(This is a test sentence.\"));\n    assertEquals(1, matches.length);\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"(This is a test\u201d sentence.\"));\n    assertEquals(2, matches.length);\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"This is a {test sentence.\"));\n    assertEquals(1, matches.length);\n    matches = rule.match(langTool\n        .getAnalyzedSentence(\"This [is (a test} sentence.\"));\n    assertEquals(3, matches.length);\n  }","commit_id":"cffe843f56d4c046d94068757b8dba0e67931235","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public boolean hasReading(GermanToken.Genus genus) {\n    if (ATreadings == null)\n      return false;\n    for (AnalyzedToken reading : ATreadings) {\n      AnalyzedGermanToken germanReading = (AnalyzedGermanToken) reading;\n      if (germanReading.getGenus() == genus)\n        return true;\n    }\n    return false;\n  }","id":83242,"modified_method":"public boolean hasReading(GermanToken.Genus genus) {\n    if (anTokReadings == null)\n      return false;\n    for (AnalyzedToken reading : anTokReadings) {\n      AnalyzedGermanToken germanReading = (AnalyzedGermanToken) reading;\n      if (germanReading.getGenus() == genus)\n        return true;\n    }\n    return false;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public boolean hasReading(GermanToken.Kasus kasus) {\n    if (ATreadings == null)\n      return false;\n    for (AnalyzedToken reading : ATreadings) {\n      AnalyzedGermanToken germanReading = (AnalyzedGermanToken) reading;\n      if (germanReading.getCasus() == kasus)\n        return true;\n    }\n    return false;\n  }","id":83243,"modified_method":"public boolean hasReading(GermanToken.Kasus kasus) {\n    if (anTokReadings == null)\n      return false;\n    for (AnalyzedToken reading : anTokReadings) {\n      AnalyzedGermanToken germanReading = (AnalyzedGermanToken) reading;\n      if (germanReading.getCasus() == kasus)\n        return true;\n    }\n    return false;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public boolean hasReading(GermanToken.Numerus numerus) {\n    if (ATreadings == null)\n      return false;\n    for (AnalyzedToken reading : ATreadings) {\n      AnalyzedGermanToken germanReading = (AnalyzedGermanToken) reading;\n      if (germanReading.getNumerus() == numerus)\n        return true;\n    }\n    return false;\n  }","id":83244,"modified_method":"public boolean hasReading(GermanToken.Numerus numerus) {\n    if (anTokReadings == null)\n      return false;\n    for (AnalyzedToken reading : anTokReadings) {\n      AnalyzedGermanToken germanReading = (AnalyzedGermanToken) reading;\n      if (germanReading.getNumerus() == numerus)\n        return true;\n    }\n    return false;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public boolean hasReadingOfType(POSType type) {\n    if (ATreadings == null)\n      return false;\n    for (AnalyzedToken reading : ATreadings) {\n      AnalyzedGermanToken germanReading = (AnalyzedGermanToken) reading;\n      if (germanReading.getType() == type)\n        return true;\n    }\n    return false;\n  }","id":83245,"modified_method":"public boolean hasReadingOfType(POSType type) {\n    if (anTokReadings == null)\n      return false;\n    for (AnalyzedToken reading : anTokReadings) {\n      AnalyzedGermanToken germanReading = (AnalyzedGermanToken) reading;\n      if (germanReading.getType() == type)\n        return true;\n    }\n    return false;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * @return a list of {@link AnalyzedGermanToken}s.\n   */\n  public List<AnalyzedGermanToken> getGermanReadings() {\n    List<AnalyzedGermanToken> l = new ArrayList<AnalyzedGermanToken>();\n    for (int i = 0; i < ATreadings.length; i++) {\n      l.add((AnalyzedGermanToken)ATreadings[i]);\n    }\n    return l;\n  }","id":83246,"modified_method":"/**\n   * @return a list of {@link AnalyzedGermanToken}s.\n   */\n  public List<AnalyzedGermanToken> getGermanReadings() {\n    List<AnalyzedGermanToken> l = new ArrayList<AnalyzedGermanToken>();\n    for (int i = 0; i < anTokReadings.length; i++) {\n      l.add((AnalyzedGermanToken)anTokReadings[i]);\n    }\n    return l;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public String toString() {\n    if (ATreadings == null)\n      return super.getAnalyzedToken(0).getToken() + \"[?]\";\n    else {\n      StringBuffer sb = new StringBuffer(super.getAnalyzedToken(0).getToken());\n      Set<String> printed = new HashSet<String>();\n      sb.append(\"[\");\n      for (AnalyzedToken reading : ATreadings) {\n        if (!printed.contains(reading.toString())) {\n          if (printed.size() > 0)\n            sb.append(\", \");\n          sb.append(reading.toString());\n        }\n        printed.add(reading.toString());\n      }\n      sb.append(\"]\");\n      return sb.toString();\n    }\n  }","id":83247,"modified_method":"public String toString() {\n    if (anTokReadings == null)\n      return super.getAnalyzedToken(0).getToken() + \"[?]\";\n    else {\n      StringBuffer sb = new StringBuffer(super.getAnalyzedToken(0).getToken());\n      Set<String> printed = new HashSet<String>();\n      sb.append(\"[\");\n      for (AnalyzedToken reading : anTokReadings) {\n        if (!printed.contains(reading.toString())) {\n          if (printed.size() > 0)\n            sb.append(\", \");\n          sb.append(reading.toString());\n        }\n        printed.add(reading.toString());\n      }\n      sb.append(\"]\");\n      return sb.toString();\n    }\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public AnalyzedTokenReadings(final AnalyzedToken[] r) {\n\t\tATreadings = r;\n\t\ttoken = ATreadings[0].getToken();\n\t\tthis.startPos = ATreadings[0].getStartPos();\n\t}","id":83248,"modified_method":"public AnalyzedTokenReadings(final AnalyzedToken[] r) {\n\t\tanTokReadings = r;\n\t\ttoken = anTokReadings[0].getToken();\n\t\tthis.startPos = anTokReadings[0].getStartPos();\n\t}","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public String toString() {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < ATreadings.length; i++) {\n      sb.append(ATreadings[i]);\n    }\n    return sb.toString();\n  }","id":83249,"modified_method":"public String toString() {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < anTokReadings.length; i++) {\n      sb.append(anTokReadings[i]);\n    }\n    return sb.toString();\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final List<AnalyzedToken> getReadings() {\n    return (List<AnalyzedToken>) Arrays.asList(ATreadings);\n  }","id":83250,"modified_method":"public final List<AnalyzedToken> getReadings() {\n    return (List<AnalyzedToken>) Arrays.asList(anTokReadings);\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final int getReadingsLength() {\n    return ATreadings.length;\n  }","id":83251,"modified_method":"public final int getReadingsLength() {\n    return anTokReadings.length;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public AnalyzedTokenReadings(final AnalyzedToken at) {\n\t\tATreadings = new AnalyzedToken[1];\n\t\tATreadings[0] = at;\n\t\ttoken = ATreadings[0].getToken();\n\t\tstartPos = at.getStartPos();\n\t}","id":83252,"modified_method":"public AnalyzedTokenReadings(final AnalyzedToken at) {\n\t\tanTokReadings = new AnalyzedToken[1];\n\t\tanTokReadings[0] = at;\n\t\ttoken = anTokReadings[0].getToken();\n\t\tstartPos = at.getStartPos();\n\t}","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final AnalyzedToken getAnalyzedToken(final int i) {\n\t\treturn ATreadings[i];\n\t}","id":83253,"modified_method":"public final AnalyzedToken getAnalyzedToken(final int i) {\n\t\treturn anTokReadings[i];\n\t}","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final boolean isSentStart() {\n    //helper method added after profiling\n   boolean isSE = false;\n   if (ATreadings[0].posTag!= null) {\n     isSE = ATreadings[0].posTag.equals(JLanguageTool.SENTENCE_START_TAGNAME);\n   }\n   return isSE;\n  }","id":83254,"modified_method":"public final boolean isSentStart() {\n    //helper method added after profiling\n   boolean isSE = false;\n   if (anTokReadings[0].posTag!= null) {\n     isSE = anTokReadings[0].posTag.equals(JLanguageTool.SENTENCE_START_TAGNAME);\n   }\n   return isSE;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"boolean exceptionValid() {\n    boolean eNext = false;\n    if (exceptionSet) {\n      Iterator<Element> it = exceptionList.iterator();    \n      while (it.hasNext()) {\n        eNext = eNext || it.next().exceptionValidNext;\n        if (eNext) {\n          break;\n        }\n      }\n    }\n      return eNext;\n  }","id":83255,"modified_method":"/** Tests if the exception is valid for next tokens \n   * (used to define exception scope). \n   * \n   * @author Marcin Milkowski\n   * \n   * @return boolean \n   * \n   */  \n  final boolean exceptionValid() {\n    boolean eNext = false;\n    if (exceptionSet) {\n      Iterator<Element> it = exceptionList.iterator();    \n      while (it.hasNext()) {\n        eNext = eNext || it.next().exceptionValidNext;\n        if (eNext) {\n          break;\n        }\n      }\n    }\n      return eNext;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"String getTokens() {\n    return stringToken;\n  }","id":83256,"modified_method":"final String getTokens() {\n    return stringToken;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void setPosException(String posToken, boolean regExp, boolean negation, boolean scope) {\n      Element posException = new Element(\"\", this.caseSensitive, regExp, false);   \n      posException.setPosElement(posToken, regExp, negation);\n      posException.exceptionValidNext=scope;\n      if (exceptionList == null) {\n        exceptionList = new ArrayList<Element>();\n      }\n      if (!exceptionSet) {\n        exceptionSet = true;  \n      }\n      exceptionList.add(posException);          \n  }","id":83257,"modified_method":"public final void setPosException(final String posToken, final boolean regExp, final boolean negation, final boolean scope) {\n      Element posException = new Element(\"\", this.caseSensitive, regExp, false);   \n      posException.setPosElement(posToken, regExp, negation);\n      posException.exceptionValidNext = scope;\n      if (exceptionList == null) {\n        exceptionList = new ArrayList<Element>();\n      }\n      if (!exceptionSet) {\n        exceptionSet = true;  \n      }\n      exceptionList.add(posException);          \n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public int getSkipNext() {\n    return skip;\n  }","id":83258,"modified_method":"public final int getSkipNext() {\n    return skip;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void setSkipNext(int i) {\n    skip = i;\n  }","id":83259,"modified_method":"public final void setSkipNext(int i) {\n    skip = i;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public String toString() {\n    if (posToken != null) {\n      return stringToken.concat(\"/\").concat(posToken);\n    } else {\n      return stringToken;\n    }\n  }","id":83260,"modified_method":"public final String toString() {\n    if (posToken != null) {\n      return stringToken.concat(\"/\").concat(posToken);\n    } else {\n      return stringToken;\n    }\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void setStringElement(String token)  {\n    this.stringToken = token;\n    if (!stringToken.equals(\"\") && stringRegExp) {\n    regToken = stringToken;\n    if (!caseSensitive) {\n      regToken = \"(?u)\".concat(stringToken);\n    }\n    p = Pattern.compile(regToken);\n    }\n  }","id":83261,"modified_method":"public final void setStringElement(final String token)  {\n    this.stringToken = token;\n    if (!stringToken.equals(\"\") && stringRegExp) {\n    regToken = stringToken;\n    if (!caseSensitive) {\n      regToken = \"(?u)\".concat(stringToken);\n    }\n    p = Pattern.compile(regToken);\n    }\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"boolean matchStringToken(AnalyzedToken token) {\n    \n    // if no string set\n    // defaulting to true\n\n    if (stringToken == null) {\n      return true;\n    }\n    if (stringToken.equals(\"\")) {\n      return true;\n    }\n\n    String testToken = null;\n    //enables using words with lemmas and without lemmas\n    //in the same regexp with inflected=\"yes\"\n    if (inflected) {\n      testToken = token.getLemma();\n      if (testToken==null) \n        testToken=token.getToken();\n    }\n    else\n      testToken = token.getToken();\n    \n        \n    if (!stringRegExp) {\n    if (caseSensitive) {\n        return stringToken.equals(testToken);\n      } else {\n        return stringToken.equalsIgnoreCase(testToken);\n      }\n    } else { \n        if (token.getToken() != null) {\n          if (p==null) {\n            p = Pattern.compile(regToken);\n          }\n          Matcher m = p.matcher(testToken);\n          return m.matches();\n        }\n      } \n      \n    return false;\n  }","id":83262,"modified_method":"final boolean matchStringToken(final AnalyzedToken token) {\n    \n    // if no string set\n    // defaulting to true\n\n    if (stringToken == null) {\n      return true;\n    }\n    if (stringToken.equals(\"\")) {\n      return true;\n    }\n\n    String testToken = null;\n    //enables using words with lemmas and without lemmas\n    //in the same regexp with inflected=\"yes\"\n    if (inflected) {\n      testToken = token.getLemma();\n      if (testToken == null) {\n        testToken = token.getToken();\n      }\n    } else {\n      testToken = token.getToken();\n    }\n    \n        \n    if (!stringRegExp) {\n    if (caseSensitive) {\n        return stringToken.equals(testToken);\n      } else {\n        return stringToken.equalsIgnoreCase(testToken);\n      }\n    } else { \n        if (token.getToken() != null) {\n          if (p == null) {\n            p = Pattern.compile(regToken);\n          }\n          Matcher m = p.matcher(testToken);\n          return m.matches();\n        }\n      } \n      \n    return false;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void setPosElement(String posToken, boolean regExp, boolean negation) {\n    this.posToken = posToken;\n    this.posNegation = negation;\n    posRegExp = regExp;\n    if (posRegExp) {\n      pPos = Pattern.compile(posToken);\n    }\n  }","id":83263,"modified_method":"public final void setPosElement(final String posToken, final boolean regExp, final boolean negation) {\n    this.posToken = posToken;\n    this.posNegation = negation;\n    posRegExp = regExp;\n    if (posRegExp) {\n      pPos = Pattern.compile(posToken);\n    }\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"boolean exceptionMatch(AnalyzedToken token) {\n    boolean exceptionMatched = false;\n    if (exceptionSet) {\n    Iterator<Element> it = exceptionList.iterator();    \n    while (it.hasNext()) {\n      Element testException =it.next();\n      exceptionMatched |= testException.match(token);\n      if (exceptionMatched) {\n        break;\n      }\n    }\n    }\n    return exceptionMatched;    \n  }","id":83264,"modified_method":"final boolean exceptionMatch(final AnalyzedToken token) {\n    boolean exceptionMatched = false;\n    if (exceptionSet) {\n    Iterator<Element> it = exceptionList.iterator();    \n    while (it.hasNext()) {\n      Element testException = it.next();\n      exceptionMatched |= testException.match(token);\n      if (exceptionMatched) {\n        break;\n      }\n    }\n    }\n    return exceptionMatched;    \n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public boolean isSentStart() {\n    boolean equals = false;\n    if (posToken != null) {\n      // not sure if this should be logical AND\n      equals = posToken.equals(JLanguageTool.SENTENCE_START_TAGNAME) && posNegation;\n    }\n    return equals;\n  }","id":83265,"modified_method":"public final boolean isSentStart() {\n    boolean equals = false;\n    if (posToken != null) {\n      // not sure if this should be logical AND\n      equals = posToken.equals(JLanguageTool.SENTENCE_START_TAGNAME) && posNegation;\n    }\n    return equals;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"boolean match(AnalyzedToken token) {\n    // this var is used to determine\n    // if calling matchStringToken\n    // has any sense - this method takes\n    // most time so it's best reduce the \n    // number it's being called\n    boolean testString = true;\n    if (stringToken == null) {\n      testString = false;\n    }\n    if (stringToken.equals(\"\")) {\n      testString = false;\n    }\n    if (testString) {\n    return (matchStringToken(token) != negation) && (matchPosToken(token) != posNegation);\n    } else {\n    return (true != negation) && (matchPosToken(token) != posNegation);  \n    }\n  }","id":83266,"modified_method":"final boolean match(final AnalyzedToken token) {\n    // this var is used to determine\n    // if calling matchStringToken\n    // has any sense - this method takes\n    // most time so it's best reduce the \n    // number it's being called\n    boolean testString = true;\n    if (stringToken == null) {\n      testString = false;\n    }\n    if (stringToken.equals(\"\")) {\n      testString = false;\n    }\n    if (testString) {\n    return (matchStringToken(token) != negation) && (matchPosToken(token) != posNegation);\n    } else {\n    return (true != negation) && (matchPosToken(token) != posNegation);  \n    }\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Negates the meaning of match().\n   */\n  void setNegation(boolean negation) {\n    this.negation = negation;\n  }","id":83267,"modified_method":"/**\n   * Negates the meaning of match().\n   */\n  final void setNegation(boolean negation) {\n    this.negation = negation;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public void setStringException(String token, boolean regExp, boolean inflected, boolean negation, boolean scope) {\n    Element stringException = new Element(token, this.caseSensitive, regExp, inflected);\n    stringException.setNegation(negation);\n    stringException.exceptionValidNext=scope;\n    if (exceptionList == null) {\n      exceptionList = new ArrayList<Element>();\n    }\n    if (!exceptionSet) {\n      exceptionSet = true;          \n    }\n      exceptionList.add(stringException);    \n  }","id":83268,"modified_method":"public final void setStringException(final String token, final boolean regExp, final boolean inflected, boolean negation, boolean scope) {\n    Element stringException = new Element(token, this.caseSensitive, regExp, inflected);\n    stringException.setNegation(negation);\n    stringException.exceptionValidNext = scope;\n    if (exceptionList == null) {\n      exceptionList = new ArrayList<Element>();\n    }\n    if (!exceptionSet) {\n      exceptionSet = true;          \n    }\n      exceptionList.add(stringException);    \n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"boolean matchPosToken(AnalyzedToken token) {\n    // if no POS set\n    // defaulting to true\n    if (posToken == null) {\n      return true;\n    }\n    boolean match = false;\n    if (!posRegExp) {\n      match = posToken.equals(token.getPOSTag());              \n    } else\n    // changed to match regexps\n    if (token.getPOSTag() != null) {\n      Matcher m = pPos.matcher(token.getPOSTag());\n      match = m.matches();                     \n    }\n    return match;\n  }","id":83269,"modified_method":"final boolean matchPosToken(final AnalyzedToken token) {\n    // if no POS set\n    // defaulting to true\n    if (posToken == null) {\n      return true;\n    }\n    boolean match = false;\n    if (!posRegExp) {\n      match = posToken.equals(token.getPOSTag());              \n    } else\n    // changed to match regexps\n    if (token.getPOSTag() != null) {\n      Matcher m = pPos.matcher(token.getPOSTag());\n      match = m.matches();                     \n    }\n    return match;\n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"boolean prevExceptionMatch(AnalyzedToken token) {\n    boolean exceptionMatched = false;\n    if (exceptionSet) {\n    Iterator<Element> it = exceptionList.iterator();    \n    while (it.hasNext()) {\n      Element testException =it.next();\n      if (testException.exceptionValidNext) {\n      exceptionMatched = exceptionMatched || testException.match(token);\n      }      \n      if (exceptionMatched) {\n        break;\n      }\n    }\n    }\n    return exceptionMatched;    \n  }","id":83270,"modified_method":"final boolean prevExceptionMatch(final AnalyzedToken token) {\n    boolean exceptionMatched = false;\n    if (exceptionSet) {\n    Iterator<Element> it = exceptionList.iterator();    \n    while (it.hasNext()) {\n      Element testException = it.next();\n      if (testException.exceptionValidNext) {\n      exceptionMatched = exceptionMatched || testException.match(token);\n      }      \n      if (exceptionMatched) {\n        break;\n      }\n    }\n    }\n    return exceptionMatched;    \n  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n\tpublic String getDescription() {\n\t\treturn \"Powtórzenia wyrazów w zdaniu (monotonia stylistyczna)\";\n\t}","id":83271,"modified_method":"@Override\n\tpublic final String getDescription() {\n\t\treturn \"Powtórzenia wyrazów w zdaniu (monotonia stylistyczna)\";\n\t}","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n\tpublic RuleMatch[] match(AnalyzedSentence text) {\n\t    List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();\n\t    AnalyzedTokenReadings[] tokens = text.getTokens();\n\t    boolean repetition = false;\n\t    //boolean hasLemma = true;\n\t    List<String> inflectedWords = new ArrayList<String>();\n\t    String prevLemma, curLemma;\n\t    int pos = 0;\n\t    for (int i = 0; i < tokens.length; i++) {\n\t      String token = tokens[i].getToken();\n\t      if (token.trim().equals(\"\")) {\n\t        // ignore\n\t      } else {\n\t        // avoid \"...\" etc. to be matched:\n\t        boolean isWord = true;\n\t        boolean hasLemma = true;\n\t        if (token.length() == 1) {\n\t          char c = token.charAt(0);\n\t\t  // Polish '\\u0347' is not classified as letter by isLetter\n\t          if (!Character.isLetter(c)) {\n\t            isWord = false;\n\t          }\n\t        }\n\t        for (int k = 0; k < tokens[i].getReadingsLength(); k++) {\n\t        \tString posTag = tokens[i].getAnalyzedToken(k).getPOSTag();\n\t        \tif (posTag != null) {\n\t        \tif (posTag.equals(\"\")) {\n\t        \t\tisWord = false;\n\t        \t\tbreak;\n\t        \t}\n           //too many false alarms here:     \n                String lemma = tokens[i].getAnalyzedToken(k).getLemma();\n                if (Pattern.matches(\"to|siebie|być|ani|albo|lub|czy|bądź|jako|zł|coraz|bardzo|ten|jak|mln|tys|swój|mój|twój|nasz|wasz|i\", lemma)) {\n                    isWord = false;\n                    break;\n                 }\n                \n\t        \tif (Pattern.matches(\"prep:.*|ppron.*\", posTag)) {\n\t        \t\tisWord = false;\n\t        \t\tbreak;\n\t        \t }\n                } else {\n                    hasLemma = false;\n                }\n                                       \t\t    \n\t        }\n\t        // Roman numbers regexp added\n\t        if (Pattern.matches(\"nie|&quot|&gt|&lt|&amp|[0-9].*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$\", tokens[i].getToken())) {\n\t        \tisWord = false;\n\t        }\n\t        \n\t        prevLemma = \"\";\n\t        if (isWord) {\n\t           for (int j=0; j <tokens[i].getReadingsLength(); j++) {\n\t        \t   if (hasLemma) {\n\t        \t   curLemma = tokens[i].getAnalyzedToken(j).getLemma();\n\t        \t   if (!prevLemma.equals(curLemma)) {\n\t        \t   if (inflectedWords.contains(curLemma)){\n\t        \t\t   repetition = true;\n      \t       \t   } else {\t        \t\t\t   \t           \n      \t       \t\t   inflectedWords.add(tokens[i].getAnalyzedToken(j).getLemma());\n      \t       \t   }\n\t        \t   }\n\t        \t   prevLemma = curLemma;\n\t        \t   } else {\n\t        \t\t   if (inflectedWords.contains(tokens[i].getToken())) {\n\t        \t\t\t   repetition = true;\n\t        \t\t   } else {\n\t        \t\t\t   inflectedWords.add(tokens[i].getToken());\n\t        \t\t   }\n\t        \t   }\n\t        \t   \n\t           }\n\t        }\n\t        \n\t         if (repetition) {\n\t          String msg = \"Powtórzony wyraz w zdaniu\";\n\t          RuleMatch ruleMatch = new RuleMatch(this, pos, pos+token.length(), msg);\n\t          ruleMatch.setSuggestedReplacement(tokens[i].getToken());\n\t          ruleMatches.add(ruleMatch);\n\t          repetition = false;\n\t        }\n\t      }\n\t      pos += token.length();\n\t    }\n\t    return toRuleMatchArray(ruleMatches);\n\t  }","id":83272,"modified_method":"@Override\n\tpublic RuleMatch[] match(final AnalyzedSentence text) {\n\t    List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();\n\t    AnalyzedTokenReadings[] tokens = text.getTokens();\n\t    boolean repetition = false;\n\t    //boolean hasLemma = true;\n\t    List<String> inflectedWords = new ArrayList<String>();\n\t    String prevLemma, curLemma;\n\t    int pos = 0;\n        Pattern pExc1 = Pattern.compile(\"to|siebie|być|ani|albo|lub|czy|bądź|jako|zł|coraz|bardzo|ten|jak|mln|tys|swój|mój|twój|nasz|wasz|i\");\n        Pattern pExc2 = Pattern.compile(\"prep:.*|ppron.*\");\n        // Roman numbers regexp added\n        Pattern pExc3 = Pattern.compile(\"nie|&quot|&gt|&lt|&amp|[0-9].*|M*(D?C{0,3}|C[DM])(L?X{0,3}|X[LC])(V?I{0,3}|I[VX])$\");\n        \n\t    for (int i = 0; i < tokens.length; i++) {\n\t      String token = tokens[i].getToken();\n\t      if (!token.trim().equals(\"\")) {\n\t        // avoid \"...\" etc. to be matched:\n\t        boolean isWord = true;\n\t        boolean hasLemma = true;\n\t        if (token.length() == 1) {\n\t          char c = token.charAt(0);\n\t\t  // Polish '\\u0347' is not classified as letter by isLetter\n\t          if (!Character.isLetter(c)) {\n\t            isWord = false;\n\t          }\n\t        }\n            int readingsLen = tokens[i].getReadingsLength();\n\t        for (int k = 0; k < readingsLen; k++) {\n\t        \tString posTag = tokens[i].getAnalyzedToken(k).getPOSTag();\n\t        \tif (posTag != null) {\n\t        \tif (posTag.equals(\"\")) {\n\t        \t\tisWord = false;\n\t        \t\tbreak;\n\t        \t}\n           //too many false alarms here:     \n                String lemma = tokens[i].getAnalyzedToken(k).getLemma();\n                Matcher m1 = pExc1.matcher(lemma);\n                if (m1.matches()) {\n                    isWord = false;\n                    break;\n                 }\n        \n                Matcher m2 = pExc2.matcher(posTag);\n                if (m2.matches()) {\n\t        \t\tisWord = false;\n\t        \t\tbreak;\n\t        \t }\n                } else {\n                    hasLemma = false;\n                }\n                                       \t\t    \n\t        }\n\n            Matcher m1 = pExc3.matcher(tokens[i].getToken());\n            if (m1.matches()) {\n                isWord = false;\n            }\n\t        \n\t        prevLemma = \"\";\n\t        if (isWord) {\n\t           for (int j = 0; j < readingsLen; j++) {\n\t        \t   if (hasLemma) {\n\t        \t   curLemma = tokens[i].getAnalyzedToken(j).getLemma();\n\t        \t   if (!prevLemma.equals(curLemma)) {\n\t        \t   if (inflectedWords.contains(curLemma)) {\n\t        \t\t   repetition = true;\n      \t       \t   } else {\t        \t\t\t   \t           \n      \t       \t\t   inflectedWords.add(tokens[i].getAnalyzedToken(j).getLemma());\n      \t       \t   }\n\t        \t   }\n\t        \t   prevLemma = curLemma;\n\t        \t   } else {\n\t        \t\t   if (inflectedWords.contains(tokens[i].getToken())) {\n\t        \t\t\t   repetition = true;\n\t        \t\t   } else {\n\t        \t\t\t   inflectedWords.add(tokens[i].getToken());\n\t        \t\t   }\n\t        \t   }\n\t        \t   \n\t           }\n\t        }\n\t        \n\t         if (repetition) {\n\t          String msg = \"Powtórzony wyraz w zdaniu\";\n\t          RuleMatch ruleMatch = new RuleMatch(this, pos, pos+token.length(), msg);\n\t          ruleMatch.setSuggestedReplacement(tokens[i].getToken());\n\t          ruleMatches.add(ruleMatch);\n\t          repetition = false;\n\t        }\n\t      }\n\t      pos += token.length();\n\t    }\n\t    return toRuleMatchArray(ruleMatches);\n\t  }","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n\tpublic String getId() {\n\t\treturn \"PL_WORD_REPEAT\";\n\t}","id":83273,"modified_method":"@Override\n\tpublic final String getId() {\n\t\treturn \"PL_WORD_REPEAT\";\n\t}","commit_id":"9723425249ebe1c97e60efc4b3b8b7c320d1d2d4","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n     * <p>getDayOfWeekIndex<\/p>\n     *\n     * @param dayName a {@link java.lang.String} object.\n     * @return a {@link java.lang.Integer} object.\n     */\n    public static Integer getDayOfWeekIndex(String dayName) {\n        createDayOfWeekMapping();\n        return (Integer)m_dayOfWeekMap.get(dayName);\n    }","id":83274,"modified_method":"/**\n     * <p>getDayOfWeekIndex<\/p>\n     *\n     * @param dayName a {@link java.lang.String} object.\n     * @return a {@link java.lang.Integer} object.\n     */\n    public static Integer getDayOfWeekIndex(final String dayName) {\n        if (dayName == null) return null;\n        return (Integer)m_dayOfWeekMap.get(dayName.toLowerCase());\n    }","commit_id":"9b6c272f7f8c3227f490cdbee7ea02290d6d5665","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>getEndOfSchedule<\/p>\n     *\n     * @param out a {@link org.opennms.netmgt.config.common.BasicSchedule} object.\n     * @return a {@link java.util.Calendar} object.\n     */\n    public static Calendar getEndOfSchedule(final BasicSchedule out) {\n        long curCalTime = System.currentTimeMillis();\n        Calendar cal = new GregorianCalendar();\n        cal.setTimeInMillis(curCalTime);\n        // check if day is part of outage\n        boolean inOutage = false;\n        Enumeration<Time> en = out.enumerateTime();\n        while (en.hasMoreElements() && !inOutage) {\n            Calendar outCalBegin = new GregorianCalendar();\n            Calendar outCalEnd = new GregorianCalendar();\n    \n            Time oTime = (Time) en.nextElement();\n    \n            String oTimeDay = oTime.getDay();\n            String begins = oTime.getBegins();\n            String ends = oTime.getEnds();\n    \n            if (oTimeDay != null) {\n                // see if outage time was specified as sunday/monday..\n                Integer dayInMap = getDayOfWeekIndex(oTimeDay);\n                if (dayInMap != null) {\n                    // check if value specified matches current date\n                    if (cal.get(Calendar.DAY_OF_WEEK) == dayInMap.intValue())\n                        inOutage = true;\n    \n                    outCalBegin.set(Calendar.DAY_OF_WEEK, dayInMap.intValue());\n                    outCalEnd.set(Calendar.DAY_OF_WEEK, dayInMap.intValue());\n                } // else see if outage time was specified as day of month\n                else {\n                    int intOTimeDay = (new Integer(oTimeDay)).intValue();\n    \n                    if (cal.get(Calendar.DAY_OF_MONTH) == intOTimeDay)\n                        inOutage = true;\n    \n                    outCalBegin.set(Calendar.DAY_OF_MONTH, intOTimeDay);\n                    outCalEnd.set(Calendar.DAY_OF_MONTH, intOTimeDay);\n                }\n            }\n    \n            // if time of day was specified and did not match, continue\n            if (oTimeDay != null && !inOutage) {\n                continue;\n            }\n            // set time in out calendars\n            setOutCalTime(outCalBegin, begins);\n            setOutCalTime(outCalEnd, ends);\n    \n            long outCalBeginTime = outCalBegin.getTime().getTime() / 1000 * 1000;\n            long outCalEndTime = (outCalEnd.getTime().getTime() / 1000 + 1) * 1000;\n    \n            if (curCalTime >= outCalBeginTime && curCalTime < outCalEndTime)\n                return outCalEnd;\n        }\n        return null; // Couldn't find a time period that matches\n    }","id":83275,"modified_method":"/**\n     * <p>getEndOfSchedule<\/p>\n     *\n     * @param out a {@link org.opennms.netmgt.config.common.BasicSchedule} object.\n     * @return a {@link java.util.Calendar} object.\n     */\n    public static Calendar getEndOfSchedule(final BasicSchedule out) {\n        final long curCalTime = System.currentTimeMillis();\n        final Calendar cal = new GregorianCalendar();\n        cal.setTimeInMillis(curCalTime);\n\n        // check if day is part of outage\n        boolean inOutage = false;\n        \n        final Enumeration<Time> en = out.enumerateTime();\n        while (en.hasMoreElements() && !inOutage) {\n            final Calendar outCalBegin = new GregorianCalendar();\n            final Calendar outCalEnd = new GregorianCalendar();\n\n            final Time oTime = en.nextElement();\n\n            final String oTimeDay = oTime.getDay();\n            final String begins = oTime.getBegins();\n            final String ends = oTime.getEnds();\n\n            if (oTimeDay != null) {\n                // see if outage time was specified as sunday/monday..\n                final Integer dayInMap = getDayOfWeekIndex(oTimeDay);\n                if (dayInMap != null) {\n                    // check if value specified matches current date\n                    if (cal.get(Calendar.DAY_OF_WEEK) == dayInMap.intValue()) inOutage = true;\n                    outCalBegin.set(Calendar.DAY_OF_WEEK, dayInMap.intValue());\n                    outCalEnd.set(Calendar.DAY_OF_WEEK, dayInMap.intValue());\n                }\n                // else see if outage time was specified as day of month\n                else {\n                    final int intOTimeDay = Integer.valueOf(oTimeDay).intValue();\n    \n                    if (cal.get(Calendar.DAY_OF_MONTH) == intOTimeDay) inOutage = true;\n    \n                    outCalBegin.set(Calendar.DAY_OF_MONTH, intOTimeDay);\n                    outCalEnd.set(Calendar.DAY_OF_MONTH, intOTimeDay);\n                }\n            }\n\n            // if time of day was specified and did not match, continue\n            if (oTimeDay != null && !inOutage) {\n                continue;\n            }\n\n            // set time in out calendars\n            setOutCalTime(outCalBegin, begins);\n            setOutCalTime(outCalEnd, ends);\n\n            final long outCalBeginTime = outCalBegin.getTime().getTime() / 1000 * 1000;\n            final long outCalEndTime = (outCalEnd.getTime().getTime() / 1000 + 1) * 1000;\n\n            if (curCalTime >= outCalBeginTime && curCalTime < outCalEndTime) return outCalEnd;\n        }\n        return null; // Couldn't find a time period that matches\n    }","commit_id":"9b6c272f7f8c3227f490cdbee7ea02290d6d5665","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * <p>isSpecific<\/p>\n     *\n     * @param time a {@link org.opennms.netmgt.config.common.Time} object.\n     * @return a boolean.\n     */\n    public static boolean isSpecific(final Time time) {\n        if (time.getDay() == null) {\n            if (time.getBegins().matches(\"^\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d .*$\")) {\n                return true;\n            } else if (time.getBegins().matches(\"^\\\\d\\\\d-...-\\\\d\\\\d\\\\d\\\\d .*$\")) {\n                return true;\n            }\n        }\n        return false;\n    }","id":83276,"modified_method":"/**\n     * <p>isSpecific<\/p>\n     *\n     * @param time a {@link org.opennms.netmgt.config.common.Time} object.\n     * @return a boolean.\n     */\n    public static boolean isSpecific(final Time time) {\n        if (time.getDay() == null) {\n            return SPECIFIC_DATE_PATTERN.matcher(time.getBegins()).matches();\n        }\n        return false;\n    }","commit_id":"9b6c272f7f8c3227f490cdbee7ea02290d6d5665","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n  public RuleMatch[] match(final AnalyzedSentence text) {\n    final List<RuleMatch> ruleMatches = new ArrayList<>();\n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    String prevToken = null;\n    for (int i = 0; i < tokens.length; i++) {\n      final String token = tokens[i].getToken();\n      if (tokens[i].isWhitespace()) {\n        // ignore\n        continue;\n      } \n      if (prevToken != null && !prevToken.equals(\"-\") && prevToken.indexOf(\"--\") == -1 \n          && prevToken.indexOf(\"\u2013-\") == -1    // first char is some special kind of dash, found in Wikipedia\n          && prevToken.endsWith(\"-\")) {\n        final char firstChar = token.charAt(0);\n        if (Character.isUpperCase(firstChar)) {\n          final String msg = \"Möglicherweise fehlt ein 'und' oder ein Komma, oder es wurde nach dem Wort \" +\n          \"ein überflüssiges Leerzeichen eingefügt. Eventuell haben Sie auch versehentlich einen Bindestrich statt eines Punktes eingefügt.\";\n          final RuleMatch ruleMatch = new RuleMatch(this, tokens[i-1].getStartPos(),\n              tokens[i-1].getStartPos()+prevToken.length()+1, msg);\n          ruleMatch.setSuggestedReplacement(tokens[i-1].getToken());\n          ruleMatches.add(ruleMatch);\n        }\n      }      \n      prevToken = token;\n    }\n    return toRuleMatchArray(ruleMatches);\n  }","id":83277,"modified_method":"@Override\n  public RuleMatch[] match(final AnalyzedSentence text) {\n    final List<RuleMatch> ruleMatches = new ArrayList<>();\n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    String prevToken = null;\n    for (int i = 0; i < tokens.length; i++) {\n      final String token = tokens[i].getToken();\n      if (tokens[i].isWhitespace()) {\n        // ignore\n        continue;\n      } \n      if (prevToken != null && !prevToken.equals(\"-\") && !prevToken.contains(\"--\") \n          && !prevToken.contains(\"\u2013-\")    // first char is some special kind of dash, found in Wikipedia\n          && prevToken.endsWith(\"-\")) {\n        final char firstChar = token.charAt(0);\n        if (Character.isUpperCase(firstChar)) {\n          final String msg = \"Möglicherweise fehlt ein 'und' oder ein Komma, oder es wurde nach dem Wort \" +\n          \"ein überflüssiges Leerzeichen eingefügt. Eventuell haben Sie auch versehentlich einen Bindestrich statt eines Punktes eingefügt.\";\n          final RuleMatch ruleMatch = new RuleMatch(this, tokens[i-1].getStartPos(),\n              tokens[i-1].getStartPos()+prevToken.length()+1, msg);\n          ruleMatch.setSuggestedReplacement(tokens[i-1].getToken());\n          ruleMatches.add(ruleMatch);\n        }\n      }      \n      prevToken = token;\n    }\n    return toRuleMatchArray(ruleMatches);\n  }","commit_id":"3eff567cdd2fe81832b1a81d63ce49b9ecb916aa","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public boolean ignore(final AnalyzedTokenReadings[] tokens, final int position) {\n    // Don't mark error for cases like:\n    // \"wie Honda und Samsung, die die Bezahlung ihrer Firmenchefs...\"\n    // \"Das Haus, in das das Kind läuft.\"\n    if (tokens[position - 1].getToken().length() == 3 && tokens[position - 1].getToken().charAt(0) == 'd') {\n      if (position >= 2 && \",\".equals(tokens[position - 2].getToken())) {\n        return true;\n      }\n      if (position >= 3 && \",\".equals(tokens[position - 3].getToken()) &&  tokens[position - 2].getToken().matches(\"ab|an|auf|bei|für|in|mit|nach|ohne|über|zu\")) {\n        return true;\n      }\n      return false;\n    }\n    // \"Warum fragen Sie sie nicht selbst?\"\n    if (position != 2 && tokens[position - 1].getToken().equals(\"Sie\") && tokens[position].getToken().equals(\"sie\") ||\n        tokens[position - 1].getToken().equals(\"sie\") && tokens[position].getToken().equals(\"Sie\")) {\n      return true;\n    }\n    return false;\n  }","id":83278,"modified_method":"@Override\n  public boolean ignore(final AnalyzedTokenReadings[] tokens, final int position) {\n    // Don't mark error for cases like:\n    // \"wie Honda und Samsung, die die Bezahlung ihrer Firmenchefs...\"\n    // \"Das Haus, in das das Kind läuft.\"\n    if (tokens[position - 1].getToken().length() == 3 && tokens[position - 1].getToken().charAt(0) == 'd') {\n      if (position >= 2 && \",\".equals(tokens[position - 2].getToken())) {\n        return true;\n      }\n      if (position >= 3 && \",\".equals(tokens[position - 3].getToken()) && PREPOSITIONS.matcher(tokens[position - 2].getToken()).matches()) {\n        return true;\n      }\n      return false;\n    }\n    // \"Warum fragen Sie sie nicht selbst?\"\n    if (position != 2 && tokens[position - 1].getToken().equals(\"Sie\") && tokens[position].getToken().equals(\"sie\") ||\n        tokens[position - 1].getToken().equals(\"sie\") && tokens[position].getToken().equals(\"Sie\")) {\n      return true;\n    }\n    return false;\n  }","commit_id":"3eff567cdd2fe81832b1a81d63ce49b9ecb916aa","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public final AnalyzedSentence replace(final AnalyzedSentence text)\n      throws IOException {\n\n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    AnalyzedTokenReadings[] whTokens = text.getTokens();\n    final int[] tokenPositions = new int[tokens.length + 1];\n\n    int tokenPos = 0;\n    int prevSkipNext = 0;\n    int skipNext = 0;\n    int matchPos = 0;\n    int skipShift = 0;\n    // this variable keeps the total number\n    // of tokens skipped - used to avoid\n    // that nextPos gets back to unmatched tokens...\n    int skipShiftTotal = 0;\n    int firstMatchToken = -1;\n    final int patternSize = patternElements.size();\n    Element elem = null, prevElement = null;\n    final boolean startWithSentStart = patternElements.get(0).isSentStart();\n    language.getUnifier().reset();\n    \n    AnalyzedTokenReadings[] unifiedTokens = null;\n    for (int i = 0; i < tokens.length; i++) {\n      boolean allElementsMatch = true;\n      // stop processing early\n      if (patternSize + i > tokens.length || startWithSentStart && i > 0) {\n        allElementsMatch = false;\n        break;\n      }\n      int matchingTokens = 0;\n      for (int k = 0; k < patternSize; k++) {\n        prevElement = elem;\n        elem = patternElements.get(k);\n        skipNext = elem.getSkipNext();\n        final int nextPos = tokenPos + k + skipShiftTotal;\n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n        boolean skipMatch = false, thisMatched = false, prevMatched = false;\n        boolean exceptionMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {\n          boolean matched = false;\n          final int numberOfReadings = tokens[m].getReadingsLength();\n          for (int l = 0; l < numberOfReadings; l++) {\n            final boolean lastReading = l + 1 == numberOfReadings;\n            final AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);\n            if (prevSkipNext > 0 && prevElement != null\n                && prevElement.isMatchedByScopeNextException(matchToken)) {\n              exceptionMatched = true;\n              prevMatched = true;\n            }\n            if (elem.isReferenceElement()) {\n              setupRef(firstMatchToken, elem, tokens);\n            }\n            if (elem.hasAndGroup()) {\n              for (final Element andElement : elem.getAndGroup()) {\n                if (andElement.isReferenceElement()) {\n                  setupRef(firstMatchToken, andElement, tokens);\n                }\n              }\n              if (l == 0) {\n                elem.setupAndGroup();\n              }\n            }\n            thisMatched |= elem.isMatchedCompletely(matchToken);\n            if (thisMatched && elem.isUnified()) {                           \n              thisMatched &= language.getUnifier().isUnified(matchToken,\n                  elem.getUniFeature(), elem.getUniType(), elem.isUniNegated(),\n                  lastReading);\n              if (thisMatched) {\n                unifiedTokens = language.getUnifier().getFinalUnified();\n              }\n            }\n            if (!elem.isUnified()) {                                              \n              language.getUnifier().reset();              \n            } \n            if (l + 1 == numberOfReadings && elem.hasAndGroup()) {\n              thisMatched &= elem.checkAndGroup(thisMatched);\n            }\n\n            exceptionMatched |= elem.isExceptionMatchedCompletely(matchToken);\n            if (elem.hasPreviousException() && m > 0) {\n              final int numReadings = tokens[m - 1].getReadingsLength();\n              for (int p = 0; p < numReadings; p++) {\n                final AnalyzedToken matchExceptionToken = tokens[m - 1]\n                    .getAnalyzedToken(p);\n                exceptionMatched |= elem\n                    .isMatchedByPreviousException(matchExceptionToken);\n              }\n            }\n            // Logical OR (cannot be AND):\n            if (thisMatched || exceptionMatched) {\n              matched = true;\n              matchPos = m;\n              skipShift = matchPos - nextPos;\n              tokenPositions[matchingTokens] = skipShift + 1;\n            }\n            skipMatch = (skipMatch || matched) && !exceptionMatched;\n          }\n\n          // disallow exceptions that should match only current tokens\n          if (!(thisMatched || prevMatched)) {\n            exceptionMatched = false;\n            skipMatch = false;\n          }\n          if (skipMatch) {\n            break;\n          }\n        }\n        allElementsMatch = skipMatch;\n        if (skipMatch) {\n          prevSkipNext = skipNext;\n          matchingTokens++;\n          if (firstMatchToken == -1) {\n            firstMatchToken = matchPos;\n          }\n          skipShiftTotal += skipShift;\n        } else {\n          prevSkipNext = 0;\n          skipShiftTotal = 0;\n          break;\n        }\n      }\n\n      tokenPos++;\n      if (allElementsMatch) {\n        whTokens = executeAction(text, whTokens, unifiedTokens,\n            firstMatchToken, matchingTokens, tokenPositions);\n      }\n      unifiedTokens = null;\n      firstMatchToken = -1;\n      skipShiftTotal = 0;\n      language.getUnifier().reset();\n    }\n\n    return new AnalyzedSentence(whTokens, text.getWhPositions());\n  }","id":83279,"modified_method":"/**\n   * Performs disambiguation on the source sentence.\n   * @param text\n   *      {@link #AnalyzedSentence} Sentence to be disambiguated.\n   * @return\n   *      {@link #AnalyzedSentence} \n   *      Disambiguated sentence (might be unchanged).\n   * @throws IOException\n   */\n  public final AnalyzedSentence replace(final AnalyzedSentence text)\n      throws IOException {\n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    AnalyzedTokenReadings[] whTokens = text.getTokens();\n    final int[] tokenPositions = new int[tokens.length + 1];\n    final int patternSize = patternElements.size();\n    Element elem = null;\n    final boolean startWithSentStart = patternElements.get(0).isSentStart();\n    for (int i = 0; i < tokens.length; i++) {\n      boolean allElementsMatch = true;\n      // stop processing early\n      if (patternSize + i > tokens.length || startWithSentStart && i > 0) {\n        allElementsMatch = false;\n        break;\n      }\n      unifiedTokens = null;\n      int matchingTokens = 0;\n      int skipShiftTotal = 0;\n      int firstMatchToken = -1;\n      int prevSkipNext = 0;\n      language.getUnifier().reset();\n      for (int k = 0; k < patternSize; k++) {\n        final Element prevElement = elem;\n        elem = patternElements.get(k);\n        setupRef(firstMatchToken, elem, tokens);\n        final int skipNext = elem.getSkipNext();\n        final int nextPos = i + k + skipShiftTotal;\n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n        prevMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {\n          allElementsMatch = testAllReadings(tokens, elem, prevElement, m,\n              firstMatchToken, prevSkipNext);\n          if (allElementsMatch) {\n            final int skipShift = m - nextPos;\n            tokenPositions[matchingTokens] = skipShift + 1;\n            prevSkipNext = skipNext;\n            matchingTokens++;\n            skipShiftTotal += skipShift;\n            if (firstMatchToken == -1) {\n              firstMatchToken = m;\n            }\n            break;\n          }\n        }\n        if (!allElementsMatch) {\n          break;\n        }\n      }\n      if (allElementsMatch) {\n        whTokens = executeAction(text, whTokens, unifiedTokens,\n            firstMatchToken, matchingTokens, tokenPositions);\n      }\n    }\n\n    return new AnalyzedSentence(whTokens, text.getWhPositions());\n  }","commit_id":"ed96627b50ffe7ca73405ddd0412561767ab3065","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void setupRef(final int firstMatchToken, final Element elem,\n      final AnalyzedTokenReadings[] tokens) {\n    final int refPos = firstMatchToken + elem.getMatch().getTokenRef();\n    if (refPos < tokens.length) {\n      elem.compile(tokens[refPos], language.getSynthesizer());\n    }\n  }","id":83280,"modified_method":"private void setupRef(final int firstMatchToken, final Element elem,\n      final AnalyzedTokenReadings[] tokens) {\n    if (elem.isReferenceElement()) {\n      final int refPos = firstMatchToken + elem.getMatch().getTokenRef();\n      if (refPos < tokens.length) {\n        elem.compile(tokens[refPos], language.getSynthesizer());\n      }\n    }\n  }","commit_id":"ed96627b50ffe7ca73405ddd0412561767ab3065","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence text,\n      final AnalyzedTokenReadings[] whiteTokens,\n      final AnalyzedTokenReadings[] unifiedTokens, final int firstMatchToken,\n      final int matchingTokens, final int[] tokenPositions) {\n    AnalyzedTokenReadings[] whTokens = whiteTokens.clone();\n    int correctedStPos = 0;\n    if (startPositionCorrection > 0) {\n      for (int l = 0; l <= startPositionCorrection; l++) {\n        correctedStPos += tokenPositions[l];\n      }\n      correctedStPos--;\n    }\n    int correctedEndPos = 0;\n    if (endPositionCorrection < 0) {\n      int l = 0;\n      while (l > endPositionCorrection) {\n        correctedEndPos -= tokenPositions[matchingTokens + l - 1];\n        l--;\n      }\n    }\n    final int fromPos = text.getOriginalPosition(firstMatchToken\n        + correctedStPos);\n    final int numRead = whTokens[fromPos].getReadingsLength();\n    boolean filtered = false;\n    switch (disAction) {\n    case UNIFY:\n      if (unifiedTokens != null) {\n        if (unifiedTokens.length == matchingTokens - startPositionCorrection\n            + endPositionCorrection) {\n          for (int i = 0; i < unifiedTokens.length; i++) {\n            whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos\n                + i)] = unifiedTokens[i];\n          }\n        }\n      }\n      break;\n    case REMOVE:\n      if (newTokenReadings != null) {\n        if (newTokenReadings.length == matchingTokens - startPositionCorrection\n            + endPositionCorrection) {\n          for (int i = 0; i < newTokenReadings.length; i++) {\n            whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos\n                + i)].removeReading(newTokenReadings[i]);\n          }\n        }\n      }\n      break;\n    case ADD:\n      if (newTokenReadings != null) {\n        if (newTokenReadings.length == matchingTokens - startPositionCorrection\n            + endPositionCorrection) {\n          for (int i = 0; i < newTokenReadings.length; i++) {\n            whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos\n                + i)].addReading(newTokenReadings[i]);\n          }\n        }\n      }\n      break;\n    case FILTER:\n      if (matchElement == null) { // same as REPLACE if using <match>\n        final Match tmpMatchToken = new Match(disambiguatedPOS, null, true,\n            disambiguatedPOS, null, Match.CaseConversion.NONE, false);\n        tmpMatchToken.setToken(whTokens[fromPos]);\n        whTokens[fromPos] = tmpMatchToken.filterReadings(whTokens[fromPos]);\n        filtered = true;\n      }\n    case REPLACE:\n    default:\n      if (!filtered) {\n        if (matchElement == null) {\n          String lemma = \"\";\n          for (int l = 0; l < numRead; l++) {\n            if (whTokens[fromPos].getAnalyzedToken(l).getPOSTag() != null\n                && (whTokens[fromPos].getAnalyzedToken(l).getPOSTag().equals(\n                    disambiguatedPOS) && (whTokens[fromPos].getAnalyzedToken(l)\n                    .getLemma() != null))) {\n              lemma = whTokens[fromPos].getAnalyzedToken(l).getLemma();\n            }\n          }\n          if (StringTools.isEmpty(lemma)) {\n            lemma = whTokens[fromPos].getAnalyzedToken(0).getLemma();\n          }\n\n          final AnalyzedTokenReadings toReplace = new AnalyzedTokenReadings(\n              new AnalyzedToken(whTokens[fromPos].getToken(), disambiguatedPOS,\n                  lemma, whTokens[fromPos].getStartPos()));\n          whTokens[fromPos] = toReplace;\n        } else {\n          // using the match element\n          matchElement.setToken(whTokens[fromPos]);\n          whTokens[fromPos] = matchElement.filterReadings(whTokens[fromPos]);\n        }\n      }\n    }\n    return whTokens;\n  }","id":83281,"modified_method":"private AnalyzedTokenReadings[] executeAction(final AnalyzedSentence text,\n      final AnalyzedTokenReadings[] whiteTokens,\n      final AnalyzedTokenReadings[] unifiedTokens, final int firstMatchToken,\n      final int matchingTokens, final int[] tokenPositions) {\n    final AnalyzedTokenReadings[] whTokens = whiteTokens.clone();\n    int correctedStPos = 0;\n    if (startPositionCorrection > 0) {\n      for (int l = 0; l <= startPositionCorrection; l++) {\n        correctedStPos += tokenPositions[l];\n      }\n      correctedStPos--;\n    }\n    int correctedEndPos = 0;\n    if (endPositionCorrection < 0) {\n      int l = 0;\n      while (l > endPositionCorrection) {\n        correctedEndPos -= tokenPositions[matchingTokens + l - 1];\n        l--;\n      }\n    }\n    final int fromPos = text.getOriginalPosition(firstMatchToken\n        + correctedStPos);\n    final int numRead = whTokens[fromPos].getReadingsLength();\n    boolean filtered = false;\n    switch (disAction) {\n    case UNIFY:\n      if (unifiedTokens != null) {\n        if (unifiedTokens.length == matchingTokens - startPositionCorrection\n            + endPositionCorrection) {\n          for (int i = 0; i < unifiedTokens.length; i++) {\n            whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos\n                + i)] = unifiedTokens[i];\n          }\n        }\n      }\n      break;\n    case REMOVE:\n      if (newTokenReadings != null) {\n        if (newTokenReadings.length == matchingTokens - startPositionCorrection\n            + endPositionCorrection) {\n          for (int i = 0; i < newTokenReadings.length; i++) {\n            whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos\n                + i)].removeReading(newTokenReadings[i]);\n          }\n        }\n      }\n      break;\n    case ADD:\n      if (newTokenReadings != null) {\n        if (newTokenReadings.length == matchingTokens - startPositionCorrection\n            + endPositionCorrection) {\n          for (int i = 0; i < newTokenReadings.length; i++) {\n            whTokens[text.getOriginalPosition(firstMatchToken + correctedStPos\n                + i)].addReading(newTokenReadings[i]);\n          }\n        }\n      }\n      break;\n    case FILTER:\n      if (matchElement == null) { // same as REPLACE if using <match>\n        final Match tmpMatchToken = new Match(disambiguatedPOS, null, true,\n            disambiguatedPOS, null, Match.CaseConversion.NONE, false);\n        tmpMatchToken.setToken(whTokens[fromPos]);\n        whTokens[fromPos] = tmpMatchToken.filterReadings(whTokens[fromPos]);\n        filtered = true;\n      }\n    case REPLACE:\n    default:\n      if (!filtered) {\n        if (matchElement == null) {\n          String lemma = \"\";\n          for (int l = 0; l < numRead; l++) {\n            if (whTokens[fromPos].getAnalyzedToken(l).getPOSTag() != null\n                && (whTokens[fromPos].getAnalyzedToken(l).getPOSTag().equals(\n                    disambiguatedPOS) && (whTokens[fromPos].getAnalyzedToken(l)\n                    .getLemma() != null))) {\n              lemma = whTokens[fromPos].getAnalyzedToken(l).getLemma();\n            }\n          }\n          if (StringTools.isEmpty(lemma)) {\n            lemma = whTokens[fromPos].getAnalyzedToken(0).getLemma();\n          }\n\n          final AnalyzedTokenReadings toReplace = new AnalyzedTokenReadings(\n              new AnalyzedToken(whTokens[fromPos].getToken(), disambiguatedPOS,\n                  lemma, whTokens[fromPos].getStartPos()));\n          whTokens[fromPos] = toReplace;\n        } else {\n          // using the match element\n          matchElement.setToken(whTokens[fromPos]);\n          whTokens[fromPos] = matchElement.filterReadings(whTokens[fromPos]);\n        }\n      }\n    }\n    return whTokens;\n  }","commit_id":"ed96627b50ffe7ca73405ddd0412561767ab3065","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void setupRef(final int firstMatchToken, final Element elem,\n      final AnalyzedTokenReadings[] tokens) {\n    final int refPos = firstMatchToken + elem.getMatch().getTokenRef();\n    if (refPos < tokens.length) {\n      elem.compile(tokens[refPos], language.getSynthesizer());\n    }\n  }","id":83282,"modified_method":"private void setupRef(final int firstMatchToken, final Element elem,\n      final AnalyzedTokenReadings[] tokens) {\n    if (elem.isReferenceElement()) {\n      final int refPos = firstMatchToken + elem.getMatch().getTokenRef();\n      if (refPos < tokens.length) {\n        elem.compile(tokens[refPos], language.getSynthesizer());\n      }\n    }\n  }","commit_id":"ed96627b50ffe7ca73405ddd0412561767ab3065","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private boolean testUnification(final boolean matched, final boolean lastReading,\n      final AnalyzedToken matchToken, final Element elem) {\n    boolean thisMatched = matched;\n    if (matched && elem.isUnified()) {\n      thisMatched &= language.getUnifier().isUnified(matchToken,\n          elem.getUniFeature(), elem.getUniType(), elem.isUniNegated(),\n          lastReading);\n    }\n    if (!elem.isUnified()) {\n      language.getUnifier().reset();\n    }\n    return thisMatched;\n  }","id":83283,"modified_method":"private boolean testUnificationAndGroups(final boolean matched,\n      final boolean lastReading, final AnalyzedToken matchToken,\n      final Element elem) {\n    boolean thisMatched = matched;\n    if (matched && elem.isUnified()) {\n      thisMatched &= language.getUnifier().isUnified(matchToken,\n          elem.getUniFeature(), elem.getUniType(), elem.isUniNegated(),\n          lastReading);\n    }\n    if (!elem.isUnified()) {\n      language.getUnifier().reset();\n    }\n    if (lastReading) {\n      thisMatched &= elem.checkAndGroup(thisMatched);\n    }\n    return thisMatched;\n  }","commit_id":"ed96627b50ffe7ca73405ddd0412561767ab3065","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public final RuleMatch[] match(final AnalyzedSentence text)\n      throws IOException {\n    final List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();\n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    final int[] tokenPositions = new int[tokens.length + 1];\n    int prevSkipNext = 0;\n    int skipNext = 0;\n    int matchPos = 0;\n    int skipShift = 0;\n    // this variable keeps the total number\n    // of tokens skipped - used to avoid\n    // that nextPos gets back to unmatched tokens...\n    int skipShiftTotal = 0;\n    int firstMatchToken = -1;\n    int lastMatchToken = -1;\n    final int patternSize = patternElements.size();\n    Element elem = null, prevElement = null;\n    final boolean sentStart = patternElements.get(0).isSentStart();\n    language.getUnifier().reset();\n    for (int i = 0; i < tokens.length; i++) {\n      // stop processing if rule is longer than the sentence\n      // or stop looking for sent_start\n      if (patternSize + i > tokens.length || sentStart && i > 0) {\n        break;\n      }\n      boolean allElementsMatch = false;\n      int matchingTokens = 0;\n      for (int k = 0; k < patternSize; k++) {\n        prevElement = elem;\n        elem = patternElements.get(k);\n        skipNext = translateElementNo(elem.getSkipNext());\n        final int nextPos = i + k + skipShiftTotal;\n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n        boolean thisMatched = false, prevMatched = false;\n        boolean exceptionMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {\n          final int numberOfReadings = tokens[m].getReadingsLength();\n          for (int l = 0; l < numberOfReadings; l++) {\n            final boolean lastReading = l + 1 == numberOfReadings;\n            final AnalyzedToken matchToken = tokens[m].getAnalyzedToken(l);\n            prevMatched |= prevSkipNext > 0 && prevElement != null\n                && prevElement.isMatchedByScopeNextException(matchToken);\n            if (elem.isReferenceElement()) {\n              setupRef(firstMatchToken, elem, tokens);\n            }\n            setupAndGroup(l, firstMatchToken, elem, tokens);\n            thisMatched |= elem.isMatchedCompletely(matchToken);\n            thisMatched &= testUnification(thisMatched, lastReading, \n                matchToken, elem);\n            if (lastReading) {\n              thisMatched &= elem.checkAndGroup(thisMatched);\n            }\n            exceptionMatched |= elem.isExceptionMatchedCompletely(matchToken);\n            if (!exceptionMatched && m > 0 && elem.hasPreviousException()) {\n              exceptionMatched |= elem.\n                isMatchedByPreviousException(tokens[m - 1]);\n            }\n            if (thisMatched) {\n              matchPos = m;\n              skipShift = matchPos - nextPos;\n              tokenPositions[matchingTokens] = skipShift + 1;\n            }\n            allElementsMatch = (allElementsMatch || thisMatched) && !(exceptionMatched || prevMatched);\n          }\n          // disallow exceptions that should match only current tokens\n          exceptionMatched &= thisMatched;\n          allElementsMatch &= thisMatched;\n          if (allElementsMatch) {\n            break;\n          }\n        }\n        if (allElementsMatch) {\n          prevSkipNext = skipNext;\n          matchingTokens++;\n          lastMatchToken = matchPos;\n          if (firstMatchToken == -1) {\n            firstMatchToken = matchPos;\n          }\n          skipShiftTotal += skipShift;\n        } else {\n          break;\n        }\n      }\n      //FIXME: this might be probably removed\n      if (firstMatchToken + matchingTokens >= tokens.length) {\n        matchingTokens = tokens.length - firstMatchToken;\n      }\n      if (firstMatchToken + skipShiftTotal + matchingTokens > tokens.length) {\n        allElementsMatch = false;\n      }\n      if (allElementsMatch) {\n        final RuleMatch rM = createRuleMatch(tokenPositions, tokens,\n            firstMatchToken, lastMatchToken, matchingTokens);\n        if (rM != null) {\n          ruleMatches.add(rM);\n        }\n      }\n      firstMatchToken = -1;\n      lastMatchToken = -1;\n      skipShiftTotal = 0;\n      prevSkipNext = 0;\n      language.getUnifier().reset();\n    }\n    return ruleMatches.toArray(new RuleMatch[ruleMatches.size()]);\n  }","id":83284,"modified_method":"@Override\n  public final RuleMatch[] match(final AnalyzedSentence text)\n      throws IOException {\n    final List<RuleMatch> ruleMatches = new ArrayList<RuleMatch>();\n    final AnalyzedTokenReadings[] tokens = text.getTokensWithoutWhitespace();\n    final int[] tokenPositions = new int[tokens.length + 1];\n    final int patternSize = patternElements.size();\n    Element elem = null;\n    final boolean sentStart = patternElements.get(0).isSentStart();\n    for (int i = 0; i < tokens.length; i++) {\n      // stop processing if rule is longer than the sentence\n      // or stop looking for sent_start\n      if (patternSize + i > tokens.length || sentStart && i > 0) {\n        break;\n      }\n      boolean allElementsMatch = false;\n      int firstMatchToken = -1;\n      int lastMatchToken = -1;\n      int matchingTokens = 0;\n      int prevSkipNext = 0;\n      // this variable keeps the total number\n      // of tokens skipped\n      int skipShiftTotal = 0;\n      language.getUnifier().reset();\n      for (int k = 0; k < patternSize; k++) {\n        final Element prevElement = elem;\n        elem = patternElements.get(k);\n        setupRef(firstMatchToken, elem, tokens);\n        final int skipNext = translateElementNo(elem.getSkipNext());\n        final int nextPos = i + k + skipShiftTotal;\n        if (nextPos >= tokens.length) {\n          allElementsMatch = false;\n          break;\n        }\n        prevMatched = false;\n        if (prevSkipNext + nextPos >= tokens.length || prevSkipNext < 0) { // SENT_END?\n          prevSkipNext = tokens.length - (nextPos + 1);\n        }\n        for (int m = nextPos; m <= nextPos + prevSkipNext; m++) {\n          allElementsMatch = testAllReadings(tokens, elem, prevElement, m,\n              firstMatchToken, prevSkipNext);\n          if (allElementsMatch) {\n            lastMatchToken = m;\n            final int skipShift = lastMatchToken - nextPos;\n            tokenPositions[matchingTokens] = skipShift + 1;\n            prevSkipNext = skipNext;\n            matchingTokens++;\n            skipShiftTotal += skipShift;\n            if (firstMatchToken == -1) {\n              firstMatchToken = lastMatchToken;\n            }\n            break;\n          }\n        }\n        if (!allElementsMatch) {\n          break;\n        }\n      }\n      // FIXME: this might be probably removed\n      if (firstMatchToken + matchingTokens >= tokens.length) {\n        matchingTokens = tokens.length - firstMatchToken;\n      }\n      if (firstMatchToken + skipShiftTotal + matchingTokens > tokens.length) {\n        allElementsMatch = false;\n      }\n      if (allElementsMatch) {\n        final RuleMatch rM = createRuleMatch(tokenPositions, tokens,\n            firstMatchToken, lastMatchToken, matchingTokens);\n        if (rM != null) {\n          ruleMatches.add(rM);\n        }\n      }\n    }\n    return ruleMatches.toArray(new RuleMatch[ruleMatches.size()]);\n  }","commit_id":"ed96627b50ffe7ca73405ddd0412561767ab3065","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"private void warnIfRegexpSyntax(final List<PatternRule> rules,\n      final Language lang) {\n    for (final PatternRule rule : rules) {\n      for (final Element element : rule.getElements()) {\n        if (!element.isRegularExpression()\n            && (element.getString()\n                .matches(\".*([\\\\[\\\\]\\\\*\\\\+\\\\|\\\\^]|\\\\(.+\\\\)|\\\\[.+\\\\]|\\\\{.+\\\\}).*\"))) {\n          System.err.println(\"The \" + lang.toString() + \" rule: \"\n              + rule.getId() + \" contains element \" + \"\\\"\" + element\n              + \"\\\" that is not marked as regular expression\"\n              + \" but probably is one.\");\n        }\n        if (element.isRegularExpression()\n            && (element.getString() == null || (!element.getString().matches(\n                \".*([\\\\[\\\\]\\\\*\\\\+\\\\|\\\\^]|\\\\(.+\\\\)|\\\\[.+\\\\]|\\\\{.+\\\\}).*\")))) {\n          System.err.println(\"The \" + lang.toString() + \" rule: \"\n              + rule.getId() + \" contains element \" + \"\\\"\" + element\n              + \"\\\" that is marked as regular expression\"\n              + \" but probably is not one.\");\n        }\n      }\n    }\n  }","id":83285,"modified_method":"private void warnIfRegexpSyntax(final List<PatternRule> rules,\n      final Language lang) {\n    for (final PatternRule rule : rules) {\n      for (final Element element : rule.getElements()) {\n        if (!element.isRegularExpression()\n            && (PROBABLE_REGEX.matcher(element.getString())\n                .matches())) {\n          System.err.println(\"The \" + lang.toString() + \" rule: \"\n              + rule.getId() + \" contains element \" + \"\\\"\" + element\n              + \"\\\" that is not marked as regular expression\"\n              + \" but probably is one.\");\n        }\n        if (element.isRegularExpression()\n            && (element.getString() == null || (!PROBABLE_REGEX.matcher(element.getString())\n                .matches()))) {\n          System.err.println(\"The \" + lang.toString() + \" rule: \"\n              + rule.getId() + \" contains element \" + \"\\\"\" + element\n              + \"\\\" that is marked as regular expression\"\n              + \" but probably is not one.\");\n        }\n      }\n    }\n  }","commit_id":"ed96627b50ffe7ca73405ddd0412561767ab3065","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/**\n   * Create a test jar for testing purpose for a given class\n   * name with specified code string.\n   *\n   * @param testDir the folder under which to store the test class\n   * @param className the test class name\n   * @param code the optional test class code, which can be null.\n   * If null, an empty class will be used\n   * @param folder the folder under which to store the generated jar\n   * @return the test jar file generated\n   */\n  public static File buildJar(String testDir,\n      String className, String code, String folder) throws Exception {\n    String javaCode = code != null ? code : \"public class \" + className + \" {}\";\n    Path srcDir = new Path(testDir, \"src\");\n    File srcDirPath = new File(srcDir.toString());\n    srcDirPath.mkdirs();\n    File sourceCodeFile = new File(srcDir.toString(), className + \".java\");\n    BufferedWriter bw = new BufferedWriter(new FileWriter(sourceCodeFile));\n    bw.write(javaCode);\n    bw.close();\n\n    // compile it by JavaCompiler\n    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n    ArrayList<String> srcFileNames = new ArrayList<String>();\n    srcFileNames.add(sourceCodeFile.toString());\n    StandardJavaFileManager fm = compiler.getStandardFileManager(null, null,\n      null);\n    Iterable<? extends JavaFileObject> cu =\n      fm.getJavaFileObjects(sourceCodeFile);\n    List<String> options = new ArrayList<String>();\n    options.add(\"-classpath\");\n    // only add hbase classes to classpath. This is a little bit tricky: assume\n    // the classpath is {hbaseSrc}/target/classes.\n    String currentDir = new File(\".\").getAbsolutePath();\n    String classpath = currentDir + File.separator + \"target\"+ File.separator\n      + \"classes\" + System.getProperty(\"path.separator\")\n      + System.getProperty(\"java.class.path\") + System.getProperty(\"path.separator\")\n      + System.getProperty(\"surefire.test.class.path\");\n\n    options.add(classpath);\n    LOG.debug(\"Setting classpath to: \" + classpath);\n\n    JavaCompiler.CompilationTask task = compiler.getTask(null, fm, null,\n      options, null, cu);\n    assertTrue(\"Compile file \" + sourceCodeFile + \" failed.\", task.call());\n\n    // build a jar file by the classes files\n    String jarFileName = className + \".jar\";\n    File jarFile = new File(folder, jarFileName);\n    if (!createJarArchive(jarFile,\n        new File[]{new File(srcDir.toString(), className + \".class\")})){\n      assertTrue(\"Build jar file failed.\", false);\n    }\n    return jarFile;\n  }","id":83286,"modified_method":"/**\n   * Create a test jar for testing purpose for a given class\n   * name with specified code string.\n   *\n   * @param testDir the folder under which to store the test class\n   * @param className the test class name\n   * @param code the optional test class code, which can be null.\n   * If null, an empty class will be used\n   * @param folder the folder under which to store the generated jar\n   * @return the test jar file generated\n   */\n  public static File buildJar(String testDir,\n      String className, String code, String folder) throws Exception {\n    String javaCode = code != null ? code : \"public class \" + className + \" {}\";\n    Path srcDir = new Path(testDir, \"src\");\n    File srcDirPath = new File(srcDir.toString());\n    srcDirPath.mkdirs();\n    File sourceCodeFile = new File(srcDir.toString(), className + \".java\");\n    BufferedWriter bw = new BufferedWriter(new FileWriter(sourceCodeFile));\n    bw.write(javaCode);\n    bw.close();\n\n    // compile it by JavaCompiler\n    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n    ArrayList<String> srcFileNames = new ArrayList<String>();\n    srcFileNames.add(sourceCodeFile.toString());\n    StandardJavaFileManager fm = compiler.getStandardFileManager(null, null,\n      null);\n    Iterable<? extends JavaFileObject> cu =\n      fm.getJavaFileObjects(sourceCodeFile);\n    List<String> options = new ArrayList<String>();\n    options.add(\"-classpath\");\n    // only add hbase classes to classpath. This is a little bit tricky: assume\n    // the classpath is {hbaseSrc}/target/classes.\n    String currentDir = new File(\".\").getAbsolutePath();\n    String classpath = currentDir + File.separator + \"target\"+ File.separator\n      + \"classes\" + System.getProperty(\"path.separator\")\n      + System.getProperty(\"java.class.path\") + System.getProperty(\"path.separator\")\n      + System.getProperty(\"surefire.test.class.path\");\n\n    options.add(classpath);\n    LOG.debug(\"Setting classpath to: \" + classpath);\n\n    JavaCompiler.CompilationTask task = compiler.getTask(null, fm, null,\n      options, null, cu);\n    assertTrue(\"Compile file \" + sourceCodeFile + \" failed.\", task.call());\n\n    // build a jar file by the classes files\n    String jarFileName = className + \".jar\";\n    File jarFile = new File(folder, jarFileName);\n    jarFile.getParentFile().mkdirs();\n    if (!createJarArchive(jarFile,\n        new File[]{new File(srcDir.toString(), className + \".class\")})){\n      assertTrue(\"Build jar file failed.\", false);\n    }\n    return jarFile;\n  }","commit_id":"6bff9ab3586607268a88fa91ac5ab9e5c4f0c71f","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Jar a list of files into a jar archive.\n   *\n   * @param archiveFile the target jar archive\n   * @param tobejared a list of files to be jared\n   */\n  private static boolean createJarArchive(File archiveFile, File[] tobeJared) {\n    try {\n      byte buffer[] = new byte[4096];\n      // Open archive file\n      FileOutputStream stream = new FileOutputStream(archiveFile);\n      JarOutputStream out = new JarOutputStream(stream, new Manifest());\n\n      for (int i = 0; i < tobeJared.length; i++) {\n        if (tobeJared[i] == null || !tobeJared[i].exists()\n            || tobeJared[i].isDirectory()) {\n          continue;\n        }\n\n        // Add archive entry\n        JarEntry jarAdd = new JarEntry(tobeJared[i].getName());\n        jarAdd.setTime(tobeJared[i].lastModified());\n        out.putNextEntry(jarAdd);\n\n        // Write file to archive\n        FileInputStream in = new FileInputStream(tobeJared[i]);\n        while (true) {\n          int nRead = in.read(buffer, 0, buffer.length);\n          if (nRead <= 0)\n            break;\n          out.write(buffer, 0, nRead);\n        }\n        in.close();\n      }\n      out.close();\n      stream.close();\n      LOG.info(\"Adding classes to jar file completed\");\n      return true;\n    } catch (Exception ex) {\n      LOG.error(\"Error: \" + ex.getMessage());\n      return false;\n    }\n  }","id":83287,"modified_method":"/**\n   * Jar a list of files into a jar archive.\n   *\n   * @param archiveFile the target jar archive\n   * @param tobejared a list of files to be jared\n   */\n  private static boolean createJarArchive(File archiveFile, File[] tobeJared) {\n    try {\n      byte buffer[] = new byte[BUFFER_SIZE];\n      // Open archive file\n      FileOutputStream stream = new FileOutputStream(archiveFile);\n      JarOutputStream out = new JarOutputStream(stream, new Manifest());\n\n      for (int i = 0; i < tobeJared.length; i++) {\n        if (tobeJared[i] == null || !tobeJared[i].exists()\n            || tobeJared[i].isDirectory()) {\n          continue;\n        }\n\n        // Add archive entry\n        JarEntry jarAdd = new JarEntry(tobeJared[i].getName());\n        jarAdd.setTime(tobeJared[i].lastModified());\n        out.putNextEntry(jarAdd);\n\n        // Write file to archive\n        FileInputStream in = new FileInputStream(tobeJared[i]);\n        while (true) {\n          int nRead = in.read(buffer, 0, buffer.length);\n          if (nRead <= 0)\n            break;\n          out.write(buffer, 0, nRead);\n        }\n        in.close();\n      }\n      out.close();\n      stream.close();\n      LOG.info(\"Adding classes to jar file completed\");\n      return true;\n    } catch (Exception ex) {\n      LOG.error(\"Error: \" + ex.getMessage());\n      return false;\n    }\n  }","commit_id":"6bff9ab3586607268a88fa91ac5ab9e5c4f0c71f","url":"https://github.com/apache/hbase"},{"original_method":"public static CoprocessorClassLoader getIfCached(final Path path) {\n    if (path == null) return null; // No class loader for null path\n    return classLoadersCache.get(path);\n  }","id":83288,"modified_method":"public static CoprocessorClassLoader getIfCached(final Path path) {\n    Preconditions.checkNotNull(path, \"The jar path is null!\");\n    return classLoadersCache.get(path);\n  }","commit_id":"6bff9ab3586607268a88fa91ac5ab9e5c4f0c71f","url":"https://github.com/apache/hbase"},{"original_method":"private void init(Path path, String pathPrefix,\n      Configuration conf) throws IOException {\n    if (path == null) {\n      throw new IOException(\"The jar path is null\");\n    }\n    if (!path.toString().endsWith(\".jar\")) {\n      throw new IOException(path.toString() + \": not a jar file?\");\n    }\n\n    // Copy the jar to the local filesystem\n    String parentDirPath =\n      conf.get(LOCAL_DIR_KEY, DEFAULT_LOCAL_DIR) + TMP_JARS_DIR;\n    File parentDir = new File(parentDirPath);\n    if (!parentDir.mkdirs() && !parentDir.isDirectory()) {\n      throw new RuntimeException(\"Failed to create local dir \" + parentDir.getPath()\n        + \", CoprocessorClassLoader failed to init\");\n    }\n\n    FileSystem fs = path.getFileSystem(conf);\n    File dst = new File(parentDir, \".\" + pathPrefix + \".\"\n      + path.getName() + \".\" + System.currentTimeMillis() + \".jar\");\n    fs.copyToLocalFile(path, new Path(dst.toString()));\n    dst.deleteOnExit();\n\n    addURL(dst.getCanonicalFile().toURI().toURL());\n\n    JarFile jarFile = new JarFile(dst.toString());\n    try {\n      Enumeration<JarEntry> entries = jarFile.entries();\n      while (entries.hasMoreElements()) {\n        JarEntry entry = entries.nextElement();\n        if (entry.getName().matches(\"[/]?lib/[^/]+\\\\.jar\")) {\n          File file = new File(parentDir, \".\" + pathPrefix + \".\" + path.getName()\n            + \".\" + System.currentTimeMillis() + \".\" + entry.getName().substring(5));\n          IOUtils.copyBytes(jarFile.getInputStream(entry), new FileOutputStream(file), conf, true);\n          file.deleteOnExit();\n          addURL(file.toURI().toURL());\n        }\n      }\n    } finally {\n      jarFile.close();\n    }\n  }","id":83289,"modified_method":"private void init(Path path, String pathPrefix,\n      Configuration conf) throws IOException {\n    // Copy the jar to the local filesystem\n    String parentDirStr =\n      conf.get(LOCAL_DIR_KEY, DEFAULT_LOCAL_DIR) + TMP_JARS_DIR;\n    synchronized (parentDirLockSet) {\n      if (!parentDirLockSet.contains(parentDirStr)) {\n        Path parentDir = new Path(parentDirStr);\n        FileSystem fs = parentDir.getFileSystem(conf);\n        fs.delete(parentDir, true); // it's ok if the dir doesn't exist now\n        parentDirLockSet.add(parentDirStr);\n        if (!fs.mkdirs(parentDir) && !fs.getFileStatus(parentDir).isDir()) {\n          throw new RuntimeException(\"Failed to create local dir \" + parentDirStr\n            + \", CoprocessorClassLoader failed to init\");\n        }\n      }\n    }\n\n    FileSystem fs = path.getFileSystem(conf);\n    File dst = new File(parentDirStr, \".\" + pathPrefix + \".\"\n      + path.getName() + \".\" + System.currentTimeMillis() + \".jar\");\n    fs.copyToLocalFile(path, new Path(dst.toString()));\n    dst.deleteOnExit();\n\n    addURL(dst.getCanonicalFile().toURI().toURL());\n\n    JarFile jarFile = new JarFile(dst.toString());\n    try {\n      Enumeration<JarEntry> entries = jarFile.entries();\n      while (entries.hasMoreElements()) {\n        JarEntry entry = entries.nextElement();\n        Matcher m = libJarPattern.matcher(entry.getName());\n        if (m.matches()) {\n          File file = new File(parentDirStr, \".\" + pathPrefix + \".\"\n            + path.getName() + \".\" + System.currentTimeMillis() + \".\" + m.group(1));\n          IOUtils.copyBytes(jarFile.getInputStream(entry),\n            new FileOutputStream(file), conf, true);\n          file.deleteOnExit();\n          addURL(file.toURI().toURL());\n        }\n      }\n    } finally {\n      jarFile.close();\n    }\n  }","commit_id":"6bff9ab3586607268a88fa91ac5ab9e5c4f0c71f","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Get a CoprocessorClassLoader for a coprocessor jar path from cache.\n   * If not in cache, create one.\n   *\n   * @param path the path to the coprocessor jar file to load classes from\n   * @param parent the parent class loader for exempted classes\n   * @param pathPrefix a prefix used in temp path name to store the jar file locally\n   * @param conf the configuration used to create the class loader, if needed\n   * @return a CoprocessorClassLoader for the coprocessor jar path\n   * @throws IOException\n   */\n  public static CoprocessorClassLoader getClassLoader(final Path path,\n      final ClassLoader parent, final String pathPrefix,\n      final Configuration conf) throws IOException {\n    CoprocessorClassLoader cl = getIfCached(path);\n    if (cl != null) {\n      LOG.debug(\"Found classloader \"+ cl + \"for \"+ path.toString());\n      return cl;\n    }\n\n    cl = AccessController.doPrivileged(new PrivilegedAction<CoprocessorClassLoader>() {\n      @Override\n      public CoprocessorClassLoader run() {\n        return new CoprocessorClassLoader(parent);\n      }\n    });\n\n    cl.init(path, pathPrefix, conf);\n\n    // Cache class loader as a weak value, will be GC'ed when no reference left\n    CoprocessorClassLoader prev = classLoadersCache.putIfAbsent(path, cl);\n    if (prev != null) {\n      // Lost update race, use already added class loader\n      cl = prev;\n    }\n    return cl;\n  }","id":83290,"modified_method":"/**\n   * Get a CoprocessorClassLoader for a coprocessor jar path from cache.\n   * If not in cache, create one.\n   *\n   * @param path the path to the coprocessor jar file to load classes from\n   * @param parent the parent class loader for exempted classes\n   * @param pathPrefix a prefix used in temp path name to store the jar file locally\n   * @param conf the configuration used to create the class loader, if needed\n   * @return a CoprocessorClassLoader for the coprocessor jar path\n   * @throws IOException\n   */\n  public static CoprocessorClassLoader getClassLoader(final Path path,\n      final ClassLoader parent, final String pathPrefix,\n      final Configuration conf) throws IOException {\n    CoprocessorClassLoader cl = getIfCached(path);\n    String pathStr = path.toString();\n    if (cl != null) {\n      LOG.debug(\"Found classloader \"+ cl + \" for \"+ pathStr);\n      return cl;\n    }\n\n    if (!pathStr.endsWith(\".jar\")) {\n      throw new IOException(pathStr + \": not a jar file?\");\n    }\n\n    Lock lock = locker.acquireLock(pathStr);\n    try {\n      cl = getIfCached(path);\n      if (cl != null) {\n        LOG.debug(\"Found classloader \"+ cl + \" for \"+ pathStr);\n        return cl;\n      }\n\n      cl = AccessController.doPrivileged(\n          new PrivilegedAction<CoprocessorClassLoader>() {\n        @Override\n        public CoprocessorClassLoader run() {\n          return new CoprocessorClassLoader(parent);\n        }\n      });\n\n      cl.init(path, pathPrefix, conf);\n\n      // Cache class loader as a weak value, will be GC'ed when no reference left\n      CoprocessorClassLoader prev = classLoadersCache.putIfAbsent(path, cl);\n      if (prev != null) {\n        // Lost update race, use already added class loader\n        LOG.warn(\"THIS SHOULD NOT HAPPEN, a class loader\"\n          +\" is already cached for \" + pathStr);\n        cl = prev;\n      }\n      return cl;\n    } finally {\n      lock.unlock();\n    }\n  }","commit_id":"6bff9ab3586607268a88fa91ac5ab9e5c4f0c71f","url":"https://github.com/apache/hbase"},{"original_method":"void loadingClassFromLibDirInJar(String libPrefix) throws Exception {\n    FileSystem fs = cluster.getFileSystem();\n\n    File innerJarFile1 = buildCoprocessorJar(cpName1);\n    File innerJarFile2 = buildCoprocessorJar(cpName2);\n    File outerJarFile = new File(TEST_UTIL.getDataTestDir().toString(), \"outer.jar\");\n\n    byte buffer[] = new byte[BUFFER_SIZE];\n    // TODO: code here and elsewhere in this file is duplicated w/TestClassFinder.\n    //       Some refactoring may be in order...\n    // Open archive file\n    FileOutputStream stream = new FileOutputStream(outerJarFile);\n    JarOutputStream out = new JarOutputStream(stream, new Manifest());\n\n    for (File jarFile: new File[] { innerJarFile1, innerJarFile2 }) {\n      // Add archive entry\n      JarEntry jarAdd = new JarEntry(libPrefix + jarFile.getName());\n      jarAdd.setTime(jarFile.lastModified());\n      out.putNextEntry(jarAdd);\n\n      // Write file to archive\n      FileInputStream in = new FileInputStream(jarFile);\n      while (true) {\n        int nRead = in.read(buffer, 0, buffer.length);\n        if (nRead <= 0)\n          break;\n        out.write(buffer, 0, nRead);\n      }\n      in.close();\n    }\n    out.close();\n    stream.close();\n    LOG.info(\"Adding jar file to outer jar file completed\");\n\n    // copy the jars into dfs\n    fs.copyFromLocalFile(new Path(outerJarFile.getPath()),\n      new Path(fs.getUri().toString() + Path.SEPARATOR));\n    String jarFileOnHDFS = fs.getUri().toString() + Path.SEPARATOR +\n      outerJarFile.getName();\n    assertTrue(\"Copy jar file to HDFS failed.\",\n      fs.exists(new Path(jarFileOnHDFS)));\n    LOG.info(\"Copied jar file to HDFS: \" + jarFileOnHDFS);\n\n    // create a table that references the coprocessors\n    HTableDescriptor htd = new HTableDescriptor(tableName);\n    htd.addFamily(new HColumnDescriptor(\"test\"));\n      // without configuration values\n    htd.setValue(\"COPROCESSOR$1\", jarFileOnHDFS.toString() + \"|\" + cpName1 +\n      \"|\" + Coprocessor.PRIORITY_USER);\n      // with configuration values\n    htd.setValue(\"COPROCESSOR$2\", jarFileOnHDFS.toString() + \"|\" + cpName2 +\n      \"|\" + Coprocessor.PRIORITY_USER + \"|k1=v1,k2=v2,k3=v3\");\n    HBaseAdmin admin = TEST_UTIL.getHBaseAdmin();\n    if (admin.tableExists(tableName)) {\n      if (admin.isTableEnabled(tableName)) {\n        admin.disableTable(tableName);\n      }\n      admin.deleteTable(tableName);\n    }\n    admin.createTable(htd);\n    waitForTable(htd.getName());\n\n    // verify that the coprocessors were loaded\n    boolean found1 = false, found2 = false, found2_k1 = false,\n        found2_k2 = false, found2_k3 = false;\n    MiniHBaseCluster hbase = TEST_UTIL.getHBaseCluster();\n    for (HRegion region:\n        hbase.getRegionServer(0).getOnlineRegionsLocalContext()) {\n      if (region.getRegionNameAsString().startsWith(tableName)) {\n        CoprocessorEnvironment env;\n        env = region.getCoprocessorHost().findCoprocessorEnvironment(cpName1);\n        if (env != null) {\n          found1 = true;\n        }\n        env = region.getCoprocessorHost().findCoprocessorEnvironment(cpName2);\n        if (env != null) {\n          found2 = true;\n          Configuration conf = env.getConfiguration();\n          found2_k1 = conf.get(\"k1\") != null;\n          found2_k2 = conf.get(\"k2\") != null;\n          found2_k3 = conf.get(\"k3\") != null;\n        }\n      }\n    }\n    assertTrue(\"Class \" + cpName1 + \" was missing on a region\", found1);\n    assertTrue(\"Class \" + cpName2 + \" was missing on a region\", found2);\n    assertTrue(\"Configuration key 'k1' was missing on a region\", found2_k1);\n    assertTrue(\"Configuration key 'k2' was missing on a region\", found2_k2);\n    assertTrue(\"Configuration key 'k3' was missing on a region\", found2_k3);\n  }","id":83291,"modified_method":"void loadingClassFromLibDirInJar(String libPrefix) throws Exception {\n    FileSystem fs = cluster.getFileSystem();\n\n    File innerJarFile1 = buildCoprocessorJar(cpName1);\n    File innerJarFile2 = buildCoprocessorJar(cpName2);\n    File outerJarFile = new File(TEST_UTIL.getDataTestDir().toString(), \"outer.jar\");\n\n    ClassLoaderTestHelper.addJarFilesToJar(\n      outerJarFile, libPrefix, innerJarFile1, innerJarFile2);\n\n    // copy the jars into dfs\n    fs.copyFromLocalFile(new Path(outerJarFile.getPath()),\n      new Path(fs.getUri().toString() + Path.SEPARATOR));\n    String jarFileOnHDFS = fs.getUri().toString() + Path.SEPARATOR +\n      outerJarFile.getName();\n    assertTrue(\"Copy jar file to HDFS failed.\",\n      fs.exists(new Path(jarFileOnHDFS)));\n    LOG.info(\"Copied jar file to HDFS: \" + jarFileOnHDFS);\n\n    // create a table that references the coprocessors\n    HTableDescriptor htd = new HTableDescriptor(tableName);\n    htd.addFamily(new HColumnDescriptor(\"test\"));\n      // without configuration values\n    htd.setValue(\"COPROCESSOR$1\", jarFileOnHDFS.toString() + \"|\" + cpName1 +\n      \"|\" + Coprocessor.PRIORITY_USER);\n      // with configuration values\n    htd.setValue(\"COPROCESSOR$2\", jarFileOnHDFS.toString() + \"|\" + cpName2 +\n      \"|\" + Coprocessor.PRIORITY_USER + \"|k1=v1,k2=v2,k3=v3\");\n    HBaseAdmin admin = TEST_UTIL.getHBaseAdmin();\n    if (admin.tableExists(tableName)) {\n      if (admin.isTableEnabled(tableName)) {\n        admin.disableTable(tableName);\n      }\n      admin.deleteTable(tableName);\n    }\n    admin.createTable(htd);\n    waitForTable(htd.getName());\n\n    // verify that the coprocessors were loaded\n    boolean found1 = false, found2 = false, found2_k1 = false,\n        found2_k2 = false, found2_k3 = false;\n    MiniHBaseCluster hbase = TEST_UTIL.getHBaseCluster();\n    for (HRegion region:\n        hbase.getRegionServer(0).getOnlineRegionsLocalContext()) {\n      if (region.getRegionNameAsString().startsWith(tableName)) {\n        CoprocessorEnvironment env;\n        env = region.getCoprocessorHost().findCoprocessorEnvironment(cpName1);\n        if (env != null) {\n          found1 = true;\n        }\n        env = region.getCoprocessorHost().findCoprocessorEnvironment(cpName2);\n        if (env != null) {\n          found2 = true;\n          Configuration conf = env.getConfiguration();\n          found2_k1 = conf.get(\"k1\") != null;\n          found2_k2 = conf.get(\"k2\") != null;\n          found2_k3 = conf.get(\"k3\") != null;\n        }\n      }\n    }\n    assertTrue(\"Class \" + cpName1 + \" was missing on a region\", found1);\n    assertTrue(\"Class \" + cpName2 + \" was missing on a region\", found2);\n    assertTrue(\"Configuration key 'k1' was missing on a region\", found2_k1);\n    assertTrue(\"Configuration key 'k2' was missing on a region\", found2_k2);\n    assertTrue(\"Configuration key 'k3' was missing on a region\", found2_k3);\n  }","commit_id":"6bff9ab3586607268a88fa91ac5ab9e5c4f0c71f","url":"https://github.com/apache/hbase"},{"original_method":"private void deleteClass(String className) throws Exception {\n    String jarFileName = className + \".jar\";\n    File file = new File(TEST_UTIL.getDataTestDir().toString(), jarFileName);\n    file.delete();\n    assertFalse(\"Should be deleted: \" + file.getPath(), file.exists());\n\n    file = new File(conf.get(\"hbase.dynamic.jars.dir\"), jarFileName);\n    file.delete();\n    assertFalse(\"Should be deleted: \" + file.getPath(), file.exists());\n\n    file = new File(localDirPath(), jarFileName);\n    file.delete();\n    assertFalse(\"Should be deleted: \" + file.getPath(), file.exists());\n  }","id":83292,"modified_method":"private void deleteClass(String className) throws Exception {\n    String jarFileName = className + \".jar\";\n    File file = new File(TEST_UTIL.getDataTestDir().toString(), jarFileName);\n    file.delete();\n    assertFalse(\"Should be deleted: \" + file.getPath(), file.exists());\n\n    file = new File(conf.get(\"hbase.dynamic.jars.dir\"), jarFileName);\n    file.delete();\n    assertFalse(\"Should be deleted: \" + file.getPath(), file.exists());\n\n    file = new File(ClassLoaderTestHelper.localDirPath(conf), jarFileName);\n    file.delete();\n    assertFalse(\"Should be deleted: \" + file.getPath(), file.exists());\n  }","commit_id":"6bff9ab3586607268a88fa91ac5ab9e5c4f0c71f","url":"https://github.com/apache/hbase"},{"original_method":"@Test\n  public void testLoadClassFromLocalPath() throws Exception {\n    ClassLoader parent = TestDynamicClassLoader.class.getClassLoader();\n    DynamicClassLoader classLoader = new DynamicClassLoader(conf, parent);\n\n    String className = \"TestLoadClassFromLocalPath\";\n    deleteClass(className);\n    try {\n      classLoader.loadClass(className);\n      fail(\"Should not be able to load class \" + className);\n    } catch (ClassNotFoundException cnfe) {\n      // expected, move on\n    }\n\n    try {\n      String folder = TEST_UTIL.getDataTestDir().toString();\n      ClassLoaderTestHelper.buildJar(folder, className, null, localDirPath());\n      classLoader.loadClass(className);\n    } catch (ClassNotFoundException cnfe) {\n      LOG.error(\"Should be able to load class \" + className, cnfe);\n      fail(cnfe.getMessage());\n    }\n  }","id":83293,"modified_method":"@Test\n  public void testLoadClassFromLocalPath() throws Exception {\n    ClassLoader parent = TestDynamicClassLoader.class.getClassLoader();\n    DynamicClassLoader classLoader = new DynamicClassLoader(conf, parent);\n\n    String className = \"TestLoadClassFromLocalPath\";\n    deleteClass(className);\n    try {\n      classLoader.loadClass(className);\n      fail(\"Should not be able to load class \" + className);\n    } catch (ClassNotFoundException cnfe) {\n      // expected, move on\n    }\n\n    try {\n      String folder = TEST_UTIL.getDataTestDir().toString();\n      ClassLoaderTestHelper.buildJar(\n        folder, className, null, ClassLoaderTestHelper.localDirPath(conf));\n      classLoader.loadClass(className);\n    } catch (ClassNotFoundException cnfe) {\n      LOG.error(\"Should be able to load class \" + className, cnfe);\n      fail(cnfe.getMessage());\n    }\n  }","commit_id":"6bff9ab3586607268a88fa91ac5ab9e5c4f0c71f","url":"https://github.com/apache/hbase"},{"original_method":"public EObject getIndexedJvmType(URI javaObjectURI, ResourceSet resourceSet) {\n\t\tif (resourceSet != null) {\n\t\t\tURI withoutFragment = javaObjectURI.trimFragment();\n\t\t\tif (resourceSet instanceof ResourceSetImpl \n\t\t\t\t&& ((ResourceSetImpl)resourceSet).getURIResourceMap() != null  \n\t\t\t\t&& ((ResourceSetImpl)resourceSet).getURIResourceMap().containsKey(withoutFragment)) {\n\t\t\t\treturn resourceSet.getEObject(javaObjectURI, true);\n\t\t\t}\n\t\t\tString fqn = withoutFragment.segment(withoutFragment.segmentCount() - 1);\n\t\t\tList<String> fqnSegments = Strings.split(fqn, '.');\n\t\t\tQualifiedName qualifiedName = QualifiedName.create(fqnSegments.toArray(new String[fqnSegments.size()]));\n\t\t\treturn getIndexedJvmType(qualifiedName, javaObjectURI.fragment(), resourceSet);\n\t\t}\n\t\treturn null;\n\t}","id":83294,"modified_method":"/**\n\t * Locate and resolve a {@link JvmType} in the context of the given resource set. It'll try to\n\t * decode the qualified name from the URI and find an instance with that name in the {@link IResourceDescriptions\n\t * index}. Short-circuits to a resource that is already available in the resource set.\n\t * \n\t * @param javaObjectURI\n\t *            the uri of the to-be-loaded instance. It is expected to be a Java-scheme URI. May not be\n\t *            <code>null<\/code>.\n\t * @param resourceSet\n\t *            the context resource set. May not be <code>null<\/code>.\n\t * @return the located instance. May be <code>null<\/code>.\n\t */\n\tpublic EObject getIndexedJvmType(URI javaObjectURI, ResourceSet resourceSet) {\n\t\tif (resourceSet != null) {\n\t\t\tURI withoutFragment = javaObjectURI.trimFragment();\n\t\t\tif (resourceSet instanceof ResourceSetImpl) {\n\t\t\t\t// if the resource uri is already available in the resource set, try to find it directly\n\t\t\t\tMap<URI, Resource> resourceMap = ((ResourceSetImpl) resourceSet).getURIResourceMap();\n\t\t\t\tif (resourceMap != null && resourceMap.containsKey(withoutFragment)) {\n\t\t\t\t\tEObject result = resourceSet.getEObject(javaObjectURI, true);\n\t\t\t\t\tif (result != null) {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString fqn = withoutFragment.segment(withoutFragment.segmentCount() - 1);\n\t\t\tList<String> fqnSegments = Strings.split(fqn, '.');\n\t\t\tQualifiedName qualifiedName = QualifiedName.create(fqnSegments);\n\t\t\treturn getIndexedJvmType(qualifiedName, javaObjectURI.fragment(), resourceSet);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"65b27cc523cbd9caed81376dd07cb3d31013548a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic Set<Binding> getGuiceBindingsRt(Grammar grammar) {\n\t\tif (!usesXbaseGrammar(grammar))\n\t\t\treturn emptySet();\n\t\tBindFactory config = new BindFactory()\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IEvaluationContext\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.DefaultEvaluationContext\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IExpressionInterpreter\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter\")\n\t\t\t\t.addTypeToType(IQualifiedNameConverter.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.XbaseQualifiedNameConverter\")\n\t\t\t\t.addTypeToType(IQualifiedNameProvider.class.getName(),\n\t\t\t\t\t\t\t\t\"org.eclipse.xtext.xbase.scoping.XbaseQualifiedNameProvider\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.typing.ITypeProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.typing.XbaseTypeProvider\")\n\t\t\t\t.addTypeToType(IValueConverterService.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.conversion.XbaseValueConverterService\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\t\"LinkingIScopeProvider\",\n\t\t\t\t\t\t\"binder.bind(\" + IScopeProvider.class.getName() + \".class).annotatedWith(\"\n\t\t\t\t\t\t\t\t+ LinkingScopeProviderBinding.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).to(org.eclipse.xtext.xbase.linking.XbaseLinkingScopeProvider.class)\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\tIScopeProvider.class.getName() + \"Delegate\",\n\t\t\t\t\t\t\"binder.bind(\"\n\t\t\t\t\t\t\t\t+ IScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).annotatedWith(Names.named(\"\n\t\t\t\t\t\t\t\t+ AbstractDeclarativeScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".NAMED_DELEGATE)).to(org.eclipse.xtext.xbase.scoping.XbaseImportedNamespaceScopeProvider.class)\")\n\t\t\t\t.addTypeToType(IScopeProvider.class.getCanonicalName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.scoping.XbaseScopeProvider\")\n\t\t\t\t.addTypeToType(ILinker.class.getCanonicalName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.linking.XbaseLazyLinker\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.common.types.util.TypeConformanceComputer\",\n\t\t\t\t\t\t\t\t\"org.eclipse.xtext.xbase.typing.XbaseTypeConformanceComputer\")\n\t\t\t\t.addTypeToType(XtextResource.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.resource.XbaseResource\")\n\t\t\t\t.addTypeToTypeEagerSingleton(\"org.eclipse.xtext.xbase.validation.JvmTypeReferencesValidator\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.validation.JvmTypeReferencesValidator\")\n\t\t\t\t// obsolete convenience bindings\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\")\n\t\t\t\t.addTypeToType(IDerivedStateComputer.class.getCanonicalName(), \"org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator\")\n\t\t\t\t.addTypeToType(IResourceDescription.Manager.class.getCanonicalName(), DerivedStateAwareResourceDescriptionManager.class.getCanonicalName())\n\t\t\t\t.addTypeToType(IGenerator.class.getCanonicalName(), \"org.eclipse.xtext.xbase.compiler.JvmModelGenerator\")\n\t\t\t\t.addTypeToInstance(\"org.eclipse.xtext.xtype.XtypeFactory\", \"org.eclipse.xtext.xtype.XtypeFactory.eINSTANCE\")\n\t\t\t\t.addTypeToType(TypeArgumentContextProvider.class.getCanonicalName(), \"org.eclipse.xtext.xbase.typing.XbaseTypeArgumentContextProvider\")\n\t\t\t\t.addTypeToType(IStratumBreakpointSupport.class.getName(), \"org.eclipse.xtext.xbase.debug.XbaseStratumBreakpointSupport\")\n\t\t\t\t.addTypeToType(LineSeparatorHarmonizer.class.getCanonicalName(), \"org.eclipse.xtext.xbase.compiler.output.TraceAwarePostProcessor\")\n\t\t\t\t.addTypeToType(IDefaultResourceDescriptionStrategy.class.getCanonicalName(), \"org.eclipse.xtext.xbase.resource.XbaseResourceDescriptionStrategy\");\n\t\t\n\t\tif (useInferredJvmModel) {\n\t\t\tconfig = config\n\t\t\t\t.addTypeToType(ILocationInFileProvider.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmLocationInFileProvider\")\n\t\t\t\t.addTypeToType(IGlobalScopeProvider.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmGlobalScopeProvider\");\n\t\t\tif(generateXtendInferrer) {\n\t\t\t\tconfig = config\n\t\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer\",\n\t\t\t\t\t\tgetJvmModelInferrerName(grammar, getNaming()));\n\t\t\t}\n\t\t} else {\n\t\t\tconfig = config.addTypeToType(ILocationInFileProvider.class.getName(),\n\t\t\t\t\t\"org.eclipse.xtext.xbase.resource.XbaseLocationInFileProvider\");\n\n\t\t}\n\t\treturn config.getBindings();\n\t}","id":83295,"modified_method":"@Override\n\tpublic Set<Binding> getGuiceBindingsRt(Grammar grammar) {\n\t\tif (!usesXbaseGrammar(grammar))\n\t\t\treturn emptySet();\n\t\tBindFactory config = new BindFactory()\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IEvaluationContext\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.DefaultEvaluationContext\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.interpreter.IExpressionInterpreter\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.interpreter.impl.XbaseInterpreter\")\n\t\t\t\t.addTypeToType(IQualifiedNameConverter.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.XbaseQualifiedNameConverter\")\n\t\t\t\t.addTypeToType(IQualifiedNameProvider.class.getName(),\n\t\t\t\t\t\t\t\t\"org.eclipse.xtext.xbase.scoping.XbaseQualifiedNameProvider\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.typing.ITypeProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.typing.XbaseTypeProvider\")\n\t\t\t\t.addTypeToType(IValueConverterService.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.conversion.XbaseValueConverterService\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\t\"LinkingIScopeProvider\",\n\t\t\t\t\t\t\"binder.bind(\" + IScopeProvider.class.getName() + \".class).annotatedWith(\"\n\t\t\t\t\t\t\t\t+ LinkingScopeProviderBinding.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).to(org.eclipse.xtext.xbase.linking.XbaseLinkingScopeProvider.class)\")\n\t\t\t\t.addConfiguredBinding(\n\t\t\t\t\t\tIScopeProvider.class.getName() + \"Delegate\",\n\t\t\t\t\t\t\"binder.bind(\"\n\t\t\t\t\t\t\t\t+ IScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".class).annotatedWith(Names.named(\"\n\t\t\t\t\t\t\t\t+ AbstractDeclarativeScopeProvider.class.getName()\n\t\t\t\t\t\t\t\t+ \".NAMED_DELEGATE)).to(org.eclipse.xtext.xbase.scoping.XbaseImportedNamespaceScopeProvider.class)\")\n\t\t\t\t.addTypeToType(IScopeProvider.class.getCanonicalName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.scoping.XbaseScopeProvider\")\n\t\t\t\t.addTypeToType(ILinker.class.getCanonicalName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.linking.XbaseLazyLinker\")\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.common.types.util.TypeConformanceComputer\",\n\t\t\t\t\t\t\t\t\"org.eclipse.xtext.xbase.typing.XbaseTypeConformanceComputer\")\n\t\t\t\t.addTypeToType(XtextResource.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.resource.XbaseResource\")\n\t\t\t\t.addTypeToTypeEagerSingleton(\"org.eclipse.xtext.xbase.validation.JvmTypeReferencesValidator\", \n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.validation.JvmTypeReferencesValidator\")\n\t\t\t\t// obsolete convenience bindings\n\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\",\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.featurecalls.IdentifiableSimpleNameProvider\")\n\t\t\t\t.addTypeToType(IDerivedStateComputer.class.getCanonicalName(), \"org.eclipse.xtext.xbase.jvmmodel.JvmModelAssociator\")\n\t\t\t\t.addTypeToType(IResourceDescription.Manager.class.getCanonicalName(), DerivedStateAwareResourceDescriptionManager.class.getCanonicalName())\n\t\t\t\t.addTypeToType(IGenerator.class.getCanonicalName(), \"org.eclipse.xtext.xbase.compiler.JvmModelGenerator\")\n\t\t\t\t.addTypeToInstance(\"org.eclipse.xtext.xtype.XtypeFactory\", \"org.eclipse.xtext.xtype.XtypeFactory.eINSTANCE\")\n\t\t\t\t.addTypeToType(TypeArgumentContextProvider.class.getCanonicalName(), \"org.eclipse.xtext.xbase.typing.XbaseTypeArgumentContextProvider\")\n\t\t\t\t.addTypeToType(IStratumBreakpointSupport.class.getName(), \"org.eclipse.xtext.xbase.debug.XbaseStratumBreakpointSupport\")\n\t\t\t\t.addTypeToType(LineSeparatorHarmonizer.class.getCanonicalName(), \"org.eclipse.xtext.xbase.compiler.output.TraceAwarePostProcessor\")\n\t\t\t\t.addTypeToType(IDefaultResourceDescriptionStrategy.class.getCanonicalName(), \"org.eclipse.xtext.xbase.resource.XbaseResourceDescriptionStrategy\");\n\t\t\n\t\tif (useInferredJvmModel) {\n\t\t\tconfig = config\n\t\t\t\t.addTypeToType(ILocationInFileProvider.class.getName(),\n\t\t\t\t\t\t\"org.eclipse.xtext.xbase.jvmmodel.JvmLocationInFileProvider\")\n\t\t\t\t.addTypeToType(IGlobalScopeProvider.class.getName(),\n\t\t\t\t\t\tTypesAwareDefaultGlobalScopeProvider.class.getName());\n\t\t\tif(generateXtendInferrer) {\n\t\t\t\tconfig = config\n\t\t\t\t\t.addTypeToType(\"org.eclipse.xtext.xbase.jvmmodel.IJvmModelInferrer\",\n\t\t\t\t\t\tgetJvmModelInferrerName(grammar, getNaming()));\n\t\t\t}\n\t\t} else {\n\t\t\tconfig = config.addTypeToType(ILocationInFileProvider.class.getName(),\n\t\t\t\t\t\"org.eclipse.xtext.xbase.resource.XbaseLocationInFileProvider\");\n\n\t\t}\n\t\treturn config.getBindings();\n\t}","commit_id":"65b27cc523cbd9caed81376dd07cb3d31013548a","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @param text\n\t *            to apply\n\t * @return the provided string with the first letter capitalized\n\t */\n\tprotected final String firstLetterCapitalized(String text) {\n\t\tif (text == null || text.length() == 0) {\n\t\t\treturn text;\n\t\t}\n\t\treturn text.substring(0, 1).toUpperCase() + text.substring(1, text.length());\n\t}","id":83296,"modified_method":"/**\n\t * @param text\n\t *            to apply\n\t * @return the provided string with the first letter capitalized\n\t */\n\tprotected final String firstLetterCapitalized(String text) {\n\t\treturn Strings.toFirstUpper(text);\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Concrete subclasses can override this to provide custom lookup behaviour\n\t * for <code>CrossReference<\/code>. This implementation delegates to the\n\t * injected LinkingService\n\t * \n\t * @return a list of <code>ICompletionProposal<\/code> matching the given\n\t *         assignment\n\t */\n\tprotected List<? extends ICompletionProposal> lookupCrossReference(CrossReference crossReference, EObject model,\n\t\t\tString prefix, int offset) {\n\n\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\tif (linkingService != null) {\n\t\t\tList<Pair<String, URI>> candidates = linkingService\n\t\t\t\t\t.getLinkCandidates(model, crossReference, prefix);\n\t\t\tfor (Pair<String, URI> candidate : candidates) {\n\t\t\t\tcompletionProposalList.add(createCompletionProposal(crossReference, model, candidate.getFirstElement(),\n\t\t\t\t\t\toffset));\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","id":83297,"modified_method":"/**\n\t * Concrete subclasses can override this to provide custom lookup behaviour for <code>CrossReference<\/code>. This\n\t * implementation delegates to the injected LinkingService\n\t * \n\t * @return a list of <code>ICompletionProposal<\/code> matching the given assignment\n\t */\n\tprotected List<? extends ICompletionProposal> lookupCrossReference(CrossReference crossReference, EObject model,\n\t\t\tString prefix, int offset) {\n\n\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\tif (linkingService != null) {\n\t\t\tList<EObject> candidates = linkingService.getLinkCandidates(model, crossReference, prefix);\n\t\t\tfor (EObject candidate : candidates) {\n\t\t\t\tcompletionProposalList.add(createCompletionProposal(crossReference, model, linkingNameService.getText(\n\t\t\t\t\t\tcandidate, crossReference), offset));\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"org.eclipse.xtext.generator.tests\");\n\t\tsuite.addTestSuite(org.eclipse.xtext.XtextGrammarTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.EcoreUtil2Tests.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.generator.resource.ResourceTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.grammarinheritance.InheritanceTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.grammarinheritance.ToEcoreTrafoTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.lexer.LexerErrorTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.lexer.LexerSLComment.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.metamodelreferencing.tests.MetamodelRefTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.metamodelreferencing.tests.MultiGenMMTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parseerrorhandling.ParseErrorHandlingTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parser.PartialParserReplaceTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parser.PartialParserTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parser.PartialParsingPerformanceTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parser.PartialParsingPointerTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parser.XtextParserTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.ASTChangeTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.CommentTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.EmptyModelTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.HiddenTokensTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.InvalidTokenTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.LengthOffsetLineTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.NodeContentAdapterTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.NodeModelTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.SerializeTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.reconstr.ComplexReconstrTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.reconstr.SimpleReconstrTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.reconstr.WhitespacePreservingCallbackTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.ParseTreeUtilTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.reference.CommentOnEofBug_234135_Test.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.reference.LeafNodeBug_234132_Test.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.resource.metamodel.Xtext2EcoreTransformerTests.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.resource.metamodel.TypeHierarchyHelperTests.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.crossrefs.CrossRefTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.crossrefs.LinkingErrorTest.class);\n\t\treturn suite;\n\t}","id":83298,"modified_method":"public static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"org.eclipse.xtext.generator.tests\");\n\t\tsuite.addTestSuite(org.eclipse.xtext.XtextGrammarTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.EcoreUtil2Tests.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.generator.resource.ResourceTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.grammarinheritance.InheritanceTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.grammarinheritance.ToEcoreTrafoTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.lexer.LexerErrorTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.lexer.LexerSLComment.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.metamodelreferencing.tests.MetamodelRefTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.metamodelreferencing.tests.MultiGenMMTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parseerrorhandling.ParseErrorHandlingTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parser.PartialParserReplaceTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parser.PartialParserTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parser.PartialParsingPerformanceTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parser.PartialParsingPointerTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parser.XtextParserTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.ASTChangeTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.CommentTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.EmptyModelTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.HiddenTokensTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.InvalidTokenTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.LengthOffsetLineTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.NodeContentAdapterTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.NodeModelTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.SerializeTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.reconstr.ComplexReconstrTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.reconstr.SimpleReconstrTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.reconstr.WhitespacePreservingCallbackTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.parsetree.ParseTreeUtilTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.reference.CommentOnEofBug_234135_Test.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.reference.LeafNodeBug_234132_Test.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.resource.metamodel.Xtext2EcoreTransformerTests.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.resource.metamodel.TypeHierarchyHelperTests.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.crossrefs.CrossRefTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.crossrefs.LinkingErrorTest.class);\n\t\tsuite.addTestSuite(org.eclipse.xtext.util.SimpleCacheTest.class);\n\t\treturn suite;\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testGetLinkCandidates02() throws Exception {\n\t\tEObject model = getModel(\"type TypeA extends TypeB type TypeB extends TypeA type AnotherType extends TypeA\");\n\t\t\n\t\tEObject context = (EObject) invokeWithXtend(\"types.first()\", model);\n\t\tParserRule prType = new LangAGrammarAccess().pr_Type();\n\t\tAssignment asExtends = (Assignment)((Group)prType.getAlternatives()).getAbstractTokens().get(1);\n\t\tCrossReference xref = (CrossReference) asExtends.getTerminal();\n\t\t\n\t\tList<Pair<String, URI>> candidates = linkingService.getLinkCandidates(context, xref, \"TypeA\");\n\t\tassertEquals(1, candidates.size());\n\t\tPair<String, URI> candidate = candidates.get(0);\n\t\tassertEquals(\"TypeA\", candidate.getFirstElement());\n\t\tassertEquals(model.eResource().getURI().appendFragment(\"TypeA\"), candidate.getSecondElement());\n\t}","id":83299,"modified_method":"public void testGetLinkCandidates02() throws Exception {\n\t\tEObject model = getModel(\"type TypeA extends TypeB type TypeB extends TypeA type AnotherType extends TypeA\");\n\n\t\tEObject context = (EObject) invokeWithXtend(\"types.first()\", model);\n\t\tParserRule prType = new LangAGrammarAccess().pr_Type();\n\t\tAssignment asExtends = (Assignment) ((Group) prType.getAlternatives()).getAbstractTokens().get(1);\n\t\tCrossReference xref = (CrossReference) asExtends.getTerminal();\n\n\t\tList<EObject> candidates = linkingService.getLinkCandidates(context, xref, \"TypeA\");\n\t\tassertEquals(1, candidates.size());\n\t\tEObject candidate = candidates.get(0);\n\t\tEStructuralFeature feature = candidate.eClass().getEStructuralFeature(\"name\");\n\t\tassertNotNull(feature);\n\t\tObject name = candidate.eGet(feature);\n\t\tassertNotNull(name);\n\t\tassertEquals(\"TypeA\", name);\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testGetLinkCandidates01() throws Exception {\n\t\tEObject model = getModel(\"type TypeA extends TypeB type TypeB extends TypeA type AnotherType extends TypeA\");\n\t\t\n\t\tassertWithXtend(\"3\", \"types.size\", model);\n\t\t\n\t\tEObject context = (EObject) invokeWithXtend(\"types.first()\", model);\n\t\tParserRule prType = new LangAGrammarAccess().pr_Type();\n\t\tAssignment asExtends = (Assignment)((Group)prType.getAlternatives()).getAbstractTokens().get(1);\n\t\tCrossReference xref = (CrossReference) asExtends.getTerminal();\n\t\t\n\t\tassertEquals(3, linkingService.getLinkCandidates(context, xref, \"\").size());\n\t\tassertEquals(2, linkingService.getLinkCandidates(context, xref, \"Type\").size());\n\t\tassertEquals(1, linkingService.getLinkCandidates(context, xref, \"TypeA\").size());\n\t\tassertEquals(0, linkingService.getLinkCandidates(context, xref, \"TypeC\").size());\n\t}","id":83300,"modified_method":"public void testGetLinkCandidates01() throws Exception {\n\t\tEObject model = getModel(\"type TypeA extends TypeB type TypeB extends TypeA type AnotherType extends TypeA\");\n\n\t\tassertWithXtend(\"3\", \"types.size\", model);\n\n\t\tEObject context = (EObject) invokeWithXtend(\"types.first()\", model);\n\t\tParserRule prType = new LangAGrammarAccess().pr_Type();\n\t\tAssignment asExtends = (Assignment) ((Group) prType.getAlternatives()).getAbstractTokens().get(1);\n\t\tCrossReference xref = (CrossReference) asExtends.getTerminal();\n\n\t\tassertEquals(3, linkingService.doGetLinkedObjects(context, xref, \"\", false).size());\n\t\tassertEquals(2, linkingService.doGetLinkedObjects(context, xref, \"Type\", false).size());\n\t\tassertEquals(1, linkingService.doGetLinkedObjects(context, xref, \"TypeA\", false).size());\n\t\tassertEquals(0, linkingService.doGetLinkedObjects(context, xref, \"TypeC\", false).size());\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\twith(LangAStandaloneSetup.class);\n\t\tlinkingService = ServiceRegistry.getService(ILangA.SCOPE, ILinkingService.class);\n\t}","id":83301,"modified_method":"@Override\n\tprotected void setUp() throws Exception {\n\t\tsuper.setUp();\n\t\twith(LangAStandaloneSetup.class);\n\t\tlinkingService = (XtextBuiltinLinkingService) ServiceRegistry.getService(ILangA.SCOPE, ILinkingService.class);\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"private boolean isLinked(AbstractNode lastCompleteNode) {\n\t\tEObject semanticModel = NodeUtil.getNearestSemanticObject(lastCompleteNode);\n\t\tCrossReference crossReference = (CrossReference) lastCompleteNode.getGrammarElement();\n\t\tEReference eReference = getReference(crossReference, semanticModel.eClass());\n\n\t\tList<EObject> referencedObjects = EcoreUtil2.getAllReferencedObjects(semanticModel, eReference);\n\t\t\n\t\tif (referencedObjects.isEmpty())\n\t\t\treturn false;\n\t\telse {\n\t\t\tList<URI> referencedURIs = EcoreUtil2.getURIs(referencedObjects);\n\t\t\tList<URI> linkCandidates = linkingService.getLinkedObjects(semanticModel, crossReference,\n\t\t\t\t\t(LeafNode) lastCompleteNode);\n\t\t\treturn !linkCandidates.isEmpty() && referencedURIs.containsAll(linkCandidates);\n\t\t}\n\t}","id":83302,"modified_method":"private boolean isLinked(AbstractNode lastCompleteNode) {\n\t\tEObject semanticModel = NodeUtil.getNearestSemanticObject(lastCompleteNode);\n\t\tCrossReference crossReference = (CrossReference) lastCompleteNode.getGrammarElement();\n\t\tEReference eReference = getReference(crossReference, semanticModel.eClass());\n\n\t\tList<EObject> referencedObjects = EcoreUtil2.getAllReferencedObjects(semanticModel, eReference);\n\n\t\tif (referencedObjects.isEmpty())\n\t\t\treturn false;\n\t\telse {\n\t\t\tList<EObject> linkCandidates = linkingService.getLinkedObjects(semanticModel, crossReference,\n\t\t\t\t\t(LeafNode) lastCompleteNode);\n\t\t\treturn !linkCandidates.isEmpty() && referencedObjects.containsAll(linkCandidates);\n\t\t}\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprivate List<XtextResource.Diagnostic> ensureIsLinked(EObject obj, LeafNode node, CrossReference ref) {\n\t\tList<XtextResource.Diagnostic> brokenLinks = new ArrayList<XtextResource.Diagnostic>();\n\t\tList<URI> links = linkingService.getLinkedObjects(obj, ref, (LeafNode) node);\n\t\t\n\t\tif (links == null || links.size() == 0) {\n\t\t\tbrokenLinks.add(createError(node));\n\t\t\treturn brokenLinks;\n\t\t}\n\n\t\tEReference eRef = getReference(ref, obj.eClass());\n\t\tif (eRef == null) {\n\t\t\tbrokenLinks.add(new XtextLinkingDiagnostic(node, \"Cannot find reference \" + ref));\n\t\t\treturn brokenLinks;\n\t\t}\n\t\t\n\t\tif (eRef.getUpperBound() >= 0 && links.size() > eRef.getUpperBound()) {\n\t\t\tbrokenLinks.add(new XtextLinkingDiagnostic(node, \"Too many matches (\" + links.size() + \") for \"\n\t\t\t\t\t+ node.getText() + \". Feature \" + eRef.getName() + \" can only hold \" + eRef.getUpperBound()\n\t\t\t\t\t+ \" reference(s).\"));\n\t\t\treturn brokenLinks;\n\t\t}\n\n\t\tif (eRef.getUpperBound() == 1) {\n\t\t\tURI uri = links.get(0);\n\t\t\tif (checker.exists(uri, obj)) {\n\t\t\t\tEObject proxy = createProxy(ref, uri);\n\t\t\t\tobj.eSet(eRef, proxy);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbrokenLinks.add(createError(node));\n\t\t\t}\n\t\t}\n\t\telse { // eRef.getUpperBound() == -1 || \n\t\t\t   // eRef.getUpperBound() < links.size\n\t\t\tfor (URI uri : links) {\n\t\t\t\tif (checker.exists(uri, obj)) {\n\t\t\t\t\tEObject proxy = createProxy(ref, uri);\n\t\t\t\t\t((EList<EObject>) obj.eGet(eRef)).add(proxy);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbrokenLinks.add(createError(node));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn brokenLinks;\n\t}","id":83303,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprivate List<XtextResource.Diagnostic> ensureIsLinked(EObject obj, LeafNode node, CrossReference ref) {\n\t\tList<XtextResource.Diagnostic> brokenLinks = new ArrayList<XtextResource.Diagnostic>();\n\t\tList<EObject> links = linkingService.getLinkedObjects(obj, ref, (LeafNode) node);\n\n\t\tif (links == null || links.size() == 0) {\n\t\t\tbrokenLinks.add(createError(node));\n\t\t\treturn brokenLinks;\n\t\t}\n\n\t\tEReference eRef = getReference(ref, obj.eClass());\n\t\tif (eRef == null) {\n\t\t\tbrokenLinks.add(new XtextLinkingDiagnostic(node, \"Cannot find reference \" + ref));\n\t\t\treturn brokenLinks;\n\t\t}\n\n\t\tif (eRef.getUpperBound() >= 0 && links.size() > eRef.getUpperBound()) {\n\t\t\tbrokenLinks.add(new XtextLinkingDiagnostic(node, \"Too many matches (\" + links.size() + \") for \"\n\t\t\t\t\t+ node.getText() + \". Feature \" + eRef.getName() + \" can only hold \" + eRef.getUpperBound()\n\t\t\t\t\t+ \" reference(s).\"));\n\t\t\treturn brokenLinks;\n\t\t}\n\n\t\tif (eRef.getUpperBound() == 1) {\n\t\t\tEObject link = links.get(0);\n\t\t\tobj.eSet(eRef, link);\n\t\t}\n\t\telse { // eRef.getUpperBound() == -1 || \n\t\t\t// eRef.getUpperBound() < links.size\n\t\t\t((EList<EObject>) obj.eGet(eRef)).addAll(links);\n\t\t}\n\t\treturn brokenLinks;\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testFragmentsWorkInBothDirections() throws Exception {\n\t\tEObject model = getModel(\"type A extends B type B extends A\");\n\t\tEObject typeA1 = (EObject) invokeWithXtend(\"types.first()\", model);\n\t\tEObject typeA2 = model.eResource().getEObject(\"A\");\n\t\tassertEquals(typeA1, typeA2);\n\t\tString uriFrament = model.eResource().getURIFragment(typeA1);\n\t\tassertEquals(\"A\", uriFrament);\n\t}","id":83304,"modified_method":"public void testFragmentsWorkInBothDirections() throws Exception {\n\t\tEObject model = getModel(\"type A extends B type B extends A\");\n\t\tEObject typeA1 = (EObject) invokeWithXtend(\"types.first()\", model);\n\t\tEObject typeA2 = model.eResource().getEObject(model.eResource().getURIFragment(typeA1));\n\t\tassertEquals(typeA1, typeA2);\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public String serializeCrossRef(IInstanceDescription container,\n\t\t\tCrossReference grammarElement, EObject target) {\n\t\tString r = fragmentProvider.getFragment(target);\n\t\tif (r == null)\n\t\t\tthrow new XtextSerializationException(container,\n\t\t\t\t\t\"Unable to create a string represenation for reference '\"\n\t\t\t\t\t\t\t+ grammarElement.getType().getName() + \"'.\");\n\t\treturn r;\n\t}","id":83305,"modified_method":"public String serializeCrossRef(IInstanceDescription container,\n\t\t\tCrossReference grammarElement, EObject target) {\n\t\tString r = nameService.getText(target, grammarElement);\n\t\tif (r == null)\n\t\t\tthrow new XtextSerializationException(container,\n\t\t\t\t\t\"Unable to create a string represenation for reference '\"\n\t\t\t\t\t\t\t+ grammarElement.getType().getName() + \"'.\");\n\t\treturn r;\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public static String notNull(Object o) {\n\t\tif (o == null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tString string = o.toString();\n\t\tif (string == null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\treturn string;\n\t}","id":83306,"modified_method":"public static String notNull(Object o) {\n\t\tString string = String.valueOf(o);\n\t\treturn string == null ? \"null\" : string;\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public String getFragment(EObject obj) {\n\t\tEClass eclass = obj.eClass();\n\t\t\n\t\tEStructuralFeature structuralFeature = eclass.getEStructuralFeature(\"name\");\n\t\tif (structuralFeature != null) {\n\t\t\tif (structuralFeature instanceof EAttribute) {\n\t\t\t\tEAttribute attribute = (EAttribute) structuralFeature;\n\t\t\t\tObject name = obj.eGet(attribute);\n\t\t\t\tif (name instanceof String) {\n\t\t\t\t\treturn (String) name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":83307,"modified_method":"public String getFragment(EObject obj) {\n\t\treturn null;\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<EObject> getObjectsInScope(EObject context) {\n\t\tList<EObject> result = new ArrayList<EObject>();\n\n\t\tTreeIterator<Object> iter = EcoreUtil.getAllContents(context.eResource().getResourceSet(), false);\n\t\twhile (iter.hasNext()) {\n\t\t\tObject o = iter.next();\n\t\t\tif (o instanceof EObject)\n\t\t\t\tresult.add((EObject) o);\n\t\t}\n\t\treturn result;\t\t\n\t}","id":83308,"modified_method":"public List<EObject> getObjectsInScope(EObject context) {\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"retrieving objects in scope of \" + context.toString());\n\t\t}\n\t\tResourceSet set = context.eResource().getResourceSet();\n\t\tList<EObject> result = null;\n\t\tfor (int i = 0; i < set.getResources().size(); i++) {\n\t\t\tResource r = set.getResources().get(i);\n\t\t\tif (result == null)\n\t\t\t\tresult = new ArrayList<EObject>(cache.get(r));\n\t\t\telse\n\t\t\t\tresult.addAll(cache.get(r));\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"found \" + result.size() + \" object(s) in scope of \" + context.toString());\n\t\t}\n\t\treturn result;\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<URI> getLinkedObjects(EObject context, CrossReference ref, LeafNode text) {\n\t\tList<URI> result = new ArrayList<URI>();\n\n\t\tfor (EObject o : getObjectsInScope(context))\n\t\t\tif (EcoreUtil2.getURIFragment(o).equals(text.getText()))\n\t\t\t\tresult.add(EcoreUtil2.getURI(o));\n\n\t\treturn result;\n\t}","id":83309,"modified_method":"public List<EObject> getLinkedObjects(EObject context, CrossReference ref, LeafNode text) {\n\t\treturn doGetLinkedObjects(context, ref, text.getText(), true);\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<Pair<String, URI>> getLinkCandidates(EObject context, CrossReference ref, String partialLinkText) {\n\t\tList<Pair<String, URI>> result = new ArrayList<Pair<String, URI>>();\n\n\t\tfor (EObject o : getObjectsInScope(context)) {\n\t\t\tif (isCandiateCompatibleFor(o, context, ref)) {\n\t\t\t\tURI uri = EcoreUtil2.getURI(o);\n\t\t\t\tString linktext = getLinkAsText(context, uri);\n\t\t\t\tif (isPartialLinkTextMatching(partialLinkText, linktext))\n\t\t\t\tresult.add(new Pair<String, URI>(linktext, uri));\n\t\t\t}\n\t\t}\n\n\t\tlogger.debug(\"result.size: \" + result.size());\n\n\t\treturn result;\n\t}","id":83310,"modified_method":"public List<EObject> getLinkCandidates(EObject context, CrossReference ref, String textFragment) {\n\t\treturn doGetLinkedObjects(context, ref, textFragment.trim(), false);\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public Set<IServiceRegistration> registrations() {\n\t\treturn scope(IXtextBuiltin.SCOPE)\n\t\t\t\t.with(IGrammarAccess.class, getIGrammarAccess())\n\t\t\t\t.with(IValueConverterService.class, getIValueConverterService())\n\t\t\t\t.with(ILinker.class, getILinker())\n\t\t\t\t.with(ILinkingService.class, getILinkingService())\n\t\t\t\t.with(ILinkingScopeService.class, getILinkingScopeService())\n\t\t\t\t.with(IURIChecker.class, getIURIChecker())\n\t\t\t\t.with(IFragmentProvider.class, getIFragmentProvider())\n\t\t\t\t.with(AntlrTokenDefProvider.class)\n\t\t\t\t.with(DefaultCrossReferenceSerializer.class)\n\t\t\t\t.registrations();\n\t}","id":83311,"modified_method":"public Set<IServiceRegistration> registrations() {\n\t\treturn scope(IXtextBuiltin.SCOPE)\n\t\t\t\t.with(IGrammarAccess.class, getIGrammarAccess())\n\t\t\t\t.with(IValueConverterService.class, getIValueConverterService())\n\t\t\t\t.with(ILinker.class, getILinker())\n\t\t\t\t.with(ILinkingService.class, getILinkingService())\n\t\t\t\t.with(ILinkingScopeService.class, getILinkingScopeService())\n\t\t\t\t.with(ILinkingNameService.class, getILinkingNameService())\n\t\t\t\t.with(IURIChecker.class, getIURIChecker())\n\t\t\t\t.with(IFragmentProvider.class, getIFragmentProvider())\n\t\t\t\t.with(AntlrTokenDefProvider.class)\n\t\t\t\t.with(DefaultCrossReferenceSerializer.class)\n\t\t\t\t.registrations();\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public void update(int offset, int replacedTextLength, String newText) {\n\t\tif (!isLoaded()) {\n\t\t\tthrow new IllegalStateException(\"You can't update an unloaded resource.\");\n\t\t}\n\t\ttry {\n\t\t\tisLoading = true;\n\t\t\tCompositeNode rootNode = parseResult.getRootNode();\n\n\t\t\tparseResult = parser.reparse(rootNode, offset, replacedTextLength, newText);\n\t\t\tclearOutput();\n\t\t\tif (parseResult != null) {\n\t\t\t\tif (parseResult.getRootASTElement() != null)\n\t\t\t\t\tgetContents().add(parseResult.getRootASTElement());\n\t\t\t\tif (parseResult.getRootNode() != rootNode) {\n\t\t\t\t\taddNodeContentAdapter();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdoLinking();\n\t\t} finally {\n\t\t\tisLoading = false;\n\t\t}\n\t}","id":83312,"modified_method":"public void update(int offset, int replacedTextLength, String newText) {\n\t\tif (!isLoaded()) {\n\t\t\tthrow new IllegalStateException(\"You can't update an unloaded resource.\");\n\t\t}\n\t\ttry {\n\t\t\tisLoading = true;\n\t\t\tCompositeNode rootNode = parseResult.getRootNode();\n\n\t\t\tparseResult = parser.reparse(rootNode, offset, replacedTextLength, newText);\n\t\t\tclearOutput();\n\t\t\tif (parseResult != null) {\n\t\t\t\tif (parseResult.getRootASTElement() != null)\n\t\t\t\t\tif (getContents().add(parseResult.getRootASTElement()))\n\t\t\t\t\t\treattachModificationTracker();\n\t\t\t\tif (parseResult.getRootNode() != rootNode) {\n\t\t\t\t\taddAdaptersToRoot();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdoLinking();\n\t\t\tsetModified(false);\n\t\t}\n\t\tfinally {\n\t\t\tisLoading = false;\n\t\t}\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public void reparse(String newContent) throws IOException {\n\t\tclearOutput();\n\t\tdoLoad(new StringInputStream(newContent), null);\n\t}","id":83313,"modified_method":"public void reparse(String newContent) throws IOException {\n\t\tclearOutput();\n\t\tdoLoad(new StringInputStream(newContent), null);\n\t\treattachModificationTracker();\n\t\tsetModified(false);\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void doLoad(InputStream inputStream, Map<?, ?> options) throws IOException {\n\t\tparseResult = parser.parse(inputStream, elementFactory);\n\t\tif (parseResult != null) {\n\t\t\tEObject rootElement = parseResult.getRootASTElement();\n\t\t\tif (rootElement != null) {\n\t\t\t\tgetContents().add(rootElement);\n\t\t\t}\n\t\t\taddNodeContentAdapter();\n\t\t}\n\t\tdoLinking();\n\t}","id":83314,"modified_method":"@Override\n\tprotected void doLoad(InputStream inputStream, Map<?, ?> options) throws IOException {\n\t\tparseResult = parser.parse(inputStream, elementFactory);\n\t\tif (parseResult != null) {\n\t\t\tEObject rootElement = parseResult.getRootASTElement();\n\t\t\tif (rootElement != null) {\n\t\t\t\tgetContents().add(rootElement);\n\t\t\t}\n\t\t\taddAdaptersToRoot();\n\t\t}\n\t\tdoLinking();\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic EObject getEObject(String uriFragment) {\n\t\tIterator<EObject> iter = EcoreUtil.getAllContents(parseResult.getRootASTElement(), false);\n\t\twhile (iter.hasNext()) {\n\t\t\tEObject object = (EObject) iter.next();\n\t\t\tString fragment = fragmentProvider.getFragment(object);\n\t\t\tif (fragment != null && fragment.equals(uriFragment))\n\t\t\t\treturn object;\n\t\t}\n\t\treturn super.getEObject(uriFragment);\n\t}","id":83315,"modified_method":"@Override\n\tpublic EObject getEObject(String uriFragment) {\n\t\tEObject result = (fragmentProvider != null) ? fragmentProvider.getEObject(this, uriFragment) : null;\n\n\t\tif (result == null)\n\t\t\tresult = super.getEObject(uriFragment);\n\n\t\treturn result;\n\t}","commit_id":"2fafafbeefc917387192dd2cf386f44d06c35a65","url":"https://github.com/eclipse/xtext"},{"original_method":"public static <T extends ENamedElement> T readEcoreElement(final ObjectInput in) throws IOException {\n    final URI uri = SerializationExtensions.readURI(in);\n    URI _trimFragment = uri.trimFragment();\n    String _string = _trimFragment.toString();\n    final EPackage ePackage = EPackage.Registry.INSTANCE.getEPackage(_string);\n    Resource _eResource = ePackage.eResource();\n    String _fragment = uri.fragment();\n    EObject _eObject = _eResource.getEObject(_fragment);\n    return ((T) _eObject);\n  }","id":83316,"modified_method":"public static <T extends ENamedElement> T readEcoreElement(final ObjectInput in) throws IOException {\n    final URI uri = SerializationExtensions.readURI(in);\n    URI _trimFragment = uri.trimFragment();\n    String _string = _trimFragment.toString();\n    final EPackage ePackage = EPackage.Registry.INSTANCE.getEPackage(_string);\n    Resource _eResource = null;\n    if (ePackage!=null) {\n      _eResource=ePackage.eResource();\n    }\n    EObject _eObject = null;\n    if (_eResource!=null) {\n      String _fragment = uri.fragment();\n      _eObject=_eResource.getEObject(_fragment);\n    }\n    return ((T) _eObject);\n  }","commit_id":"a0034ba4912b5d853d71627bd5cc61bc79d26fcd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JavaVersion getTargetJavaVersion(final XbaseGeneratorConfigurationState state, final Module module) {\n    JavaVersion _xblockexpression = null;\n    {\n      final String version = state.getTargetJavaVersion();\n      LanguageLevel _xifexpression = null;\n      boolean _or = false;\n      boolean _equals = Objects.equal(version, null);\n      if (_equals) {\n        _or = true;\n      } else {\n        boolean _equals_1 = version.equals(\"Module default\");\n        _or = _equals_1;\n      }\n      if (_or) {\n        LanguageLevel _xblockexpression_1 = null;\n        {\n          final Computable<LanguageLevel> _function = new Computable<LanguageLevel>() {\n            @Override\n            public LanguageLevel compute() {\n              return EffectiveLanguageLevelUtil.getEffectiveLanguageLevel(module);\n            }\n          };\n          final Computable<LanguageLevel> action = _function;\n          Application _application = ApplicationManager.getApplication();\n          _xblockexpression_1 = _application.<LanguageLevel>runReadAction(action);\n        }\n        _xifexpression = _xblockexpression_1;\n      } else {\n        LanguageLevel[] _values = LanguageLevel.values();\n        final Function1<LanguageLevel, Boolean> _function = new Function1<LanguageLevel, Boolean>() {\n          @Override\n          public Boolean apply(final LanguageLevel it) {\n            String _presentableText = it.getPresentableText();\n            return Boolean.valueOf(Objects.equal(_presentableText, version));\n          }\n        };\n        _xifexpression = IterableExtensions.<LanguageLevel>findFirst(((Iterable<LanguageLevel>)Conversions.doWrapArray(_values)), _function);\n      }\n      final LanguageLevel languageLevel = _xifexpression;\n      JavaVersion _switchResult = null;\n      if (languageLevel != null) {\n        switch (languageLevel) {\n          case JDK_1_3:\n          case JDK_1_4:\n            JavaVersion _xblockexpression_2 = null;\n            {\n              Class<? extends XbaseGeneratorConfigProvider> _class = this.getClass();\n              Logger _instance = Logger.getInstance(_class);\n              String _shortName = this.languageInfo.getShortName();\n              String _plus = (_shortName + \" requires Java language level 1.5 or higher. Using Java 1.5.\");\n              _instance.warn(_plus);\n              _xblockexpression_2 = JavaVersion.JAVA5;\n            }\n            _switchResult = _xblockexpression_2;\n            break;\n          case JDK_1_5:\n            _switchResult = JavaVersion.JAVA5;\n            break;\n          case JDK_1_6:\n            _switchResult = JavaVersion.JAVA6;\n            break;\n          case JDK_1_7:\n            _switchResult = JavaVersion.JAVA7;\n            break;\n          default:\n            _switchResult = JavaVersion.JAVA8;\n            break;\n        }\n      } else {\n        _switchResult = JavaVersion.JAVA8;\n      }\n      _xblockexpression = _switchResult;\n    }\n    return _xblockexpression;\n  }","id":83317,"modified_method":"protected JavaVersion getTargetJavaVersion(final XbaseGeneratorConfigurationState state, final Module module) {\n    JavaVersion _xblockexpression = null;\n    {\n      final String version = state.getTargetJavaVersion();\n      LanguageLevel _xifexpression = null;\n      boolean _or = false;\n      boolean _equals = Objects.equal(version, null);\n      if (_equals) {\n        _or = true;\n      } else {\n        boolean _equals_1 = version.equals(\"Module default\");\n        _or = _equals_1;\n      }\n      if (_or) {\n        LanguageLevel _xblockexpression_1 = null;\n        {\n          final Computable<LanguageLevel> _function = new Computable<LanguageLevel>() {\n            @Override\n            public LanguageLevel compute() {\n              return EffectiveLanguageLevelUtil.getEffectiveLanguageLevel(module);\n            }\n          };\n          final Computable<LanguageLevel> action = _function;\n          Application _application = ApplicationManager.getApplication();\n          _xblockexpression_1 = _application.<LanguageLevel>runReadAction(action);\n        }\n        _xifexpression = _xblockexpression_1;\n      } else {\n        LanguageLevel[] _values = LanguageLevel.values();\n        final Function1<LanguageLevel, Boolean> _function = new Function1<LanguageLevel, Boolean>() {\n          @Override\n          public Boolean apply(final LanguageLevel it) {\n            String _presentableText = it.getPresentableText();\n            return Boolean.valueOf(Objects.equal(_presentableText, version));\n          }\n        };\n        _xifexpression = IterableExtensions.<LanguageLevel>findFirst(((Iterable<LanguageLevel>)Conversions.doWrapArray(_values)), _function);\n      }\n      final LanguageLevel languageLevel = _xifexpression;\n      JavaVersion _switchResult = null;\n      if (languageLevel != null) {\n        switch (languageLevel) {\n          case JDK_1_3:\n          case JDK_1_4:\n            JavaVersion _xblockexpression_2 = null;\n            {\n              String _shortName = this.languageInfo.getShortName();\n              String _plus = (_shortName + \" requires Java language level 1.5 or higher. Using Java 1.5.\");\n              XbaseGeneratorConfigProvider.LOG.warn(_plus);\n              _xblockexpression_2 = JavaVersion.JAVA5;\n            }\n            _switchResult = _xblockexpression_2;\n            break;\n          case JDK_1_5:\n            _switchResult = JavaVersion.JAVA5;\n            break;\n          case JDK_1_6:\n            _switchResult = JavaVersion.JAVA6;\n            break;\n          case JDK_1_7:\n            _switchResult = JavaVersion.JAVA7;\n            break;\n          default:\n            _switchResult = JavaVersion.JAVA8;\n            break;\n        }\n      } else {\n        _switchResult = JavaVersion.JAVA8;\n      }\n      _xblockexpression = _switchResult;\n    }\n    return _xblockexpression;\n  }","commit_id":"a0034ba4912b5d853d71627bd5cc61bc79d26fcd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void build() {\n    if (this.disposed) {\n      return;\n    }\n    boolean _isReadyToBeBuilt = this.isReadyToBeBuilt();\n    boolean _not = (!_isReadyToBeBuilt);\n    if (_not) {\n      XtextAutoBuilderComponent.LOG.info(\"Project not yet initialized, wait some more\");\n      final Runnable _function = new Runnable() {\n        @Override\n        public void run() {\n          XtextAutoBuilderComponent.this.build();\n        }\n      };\n      this.alarm.addRequest(_function, 500);\n    } else {\n      final ArrayList<BuildEvent> allEvents = CollectionLiterals.<BuildEvent>newArrayList();\n      if (XtextAutoBuilderComponent.TEST_MODE) {\n        this.queue.drainTo(allEvents);\n        this.internalBuild(allEvents, null);\n      } else {\n        ProgressManager _instance = ProgressManager.getInstance();\n        _instance.run(new Task.Backgroundable(this.project, \"Auto-building Xtext resources\") {\n          @Override\n          public void run(final ProgressIndicator indicator) {\n            synchronized (XtextAutoBuilderComponent.BUILD_MONITOR) {\n              XtextAutoBuilderComponent.this.queue.drainTo(allEvents);\n              XtextAutoBuilderComponent.this.internalBuild(allEvents, indicator);\n            }\n          }\n        });\n      }\n    }\n  }","id":83318,"modified_method":"protected void build() {\n    if (this.disposed) {\n      return;\n    }\n    boolean _isReadyToBeBuilt = this.isReadyToBeBuilt();\n    boolean _not = (!_isReadyToBeBuilt);\n    if (_not) {\n      XtextAutoBuilderComponent.LOG.info(\"Project not yet initialized, wait some more\");\n      final Runnable _function = new Runnable() {\n        @Override\n        public void run() {\n          XtextAutoBuilderComponent.this.build();\n        }\n      };\n      this.alarm.addRequest(_function, 500);\n    } else {\n      final ArrayList<BuildEvent> allEvents = CollectionLiterals.<BuildEvent>newArrayList();\n      if (XtextAutoBuilderComponent.TEST_MODE) {\n        this.queue.drainTo(allEvents);\n        this.internalBuild(allEvents, null);\n      } else {\n        ProgressManager _instance = ProgressManager.getInstance();\n        _instance.run(new Task.Backgroundable(this.project, \"Code Generation...\") {\n          @Override\n          public void run(final ProgressIndicator indicator) {\n            indicator.setIndeterminate(true);\n            synchronized (XtextAutoBuilderComponent.BUILD_MONITOR) {\n              XtextAutoBuilderComponent.this.queue.drainTo(allEvents);\n              XtextAutoBuilderComponent.this.internalBuild(allEvents, indicator);\n            }\n          }\n        });\n      }\n    }\n  }","commit_id":"a0034ba4912b5d853d71627bd5cc61bc79d26fcd","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public void loadState(final XtextAutoBuilderComponentState state) {\n    try {\n      ChunkedResourceDescriptions _decodeIndex = this.codec.decodeIndex(state);\n      this.chunkedResourceDescriptions = _decodeIndex;\n      Map<String, Source2GeneratedMapping> _decodeModuleToGenerated = this.codec.decodeModuleToGenerated(state);\n      this.moduleName2GeneratedMapping = _decodeModuleToGenerated;\n    } catch (final Throwable _t) {\n      if (_t instanceof IOException) {\n        final IOException exc = (IOException)_t;\n        XtextAutoBuilderComponent.LOG.error(\"Error loading XtextAutoBuildComponentState \", exc);\n        ChunkedResourceDescriptions _get = this.chunkedResourceDescriptionsProvider.get();\n        this.chunkedResourceDescriptions = _get;\n        this.moduleName2GeneratedMapping.clear();\n        this.doCleanBuild();\n      } else {\n        throw Exceptions.sneakyThrow(_t);\n      }\n    }\n  }","id":83319,"modified_method":"@Override\n  public void loadState(final XtextAutoBuilderComponentState state) {\n    try {\n      Map<String, Object> _extensionToFactoryMap = this.resourceServiceProviderRegistry.getExtensionToFactoryMap();\n      final Set<String> installedNow = _extensionToFactoryMap.keySet();\n      final Set<String> installedLastTime = this.codec.decodeInstalledLanguages(state);\n      boolean _equals = installedNow.equals(installedLastTime);\n      boolean _not = (!_equals);\n      if (_not) {\n        XtextAutoBuilderComponent.LOG.info(\"Different Xtext plugins than last time. Reindexing project.\");\n        ChunkedResourceDescriptions _get = this.chunkedResourceDescriptionsProvider.get();\n        this.chunkedResourceDescriptions = _get;\n        this.moduleName2GeneratedMapping.clear();\n        this.doCleanBuild();\n      } else {\n        boolean _isDebugEnabled = XtextAutoBuilderComponent.LOG.isDebugEnabled();\n        if (_isDebugEnabled) {\n          XtextAutoBuilderComponent.LOG.debug(\"Loading persisted index state.\");\n        }\n        ChunkedResourceDescriptions _decodeIndex = this.codec.decodeIndex(state);\n        this.chunkedResourceDescriptions = _decodeIndex;\n        Map<String, Source2GeneratedMapping> _decodeModuleToGenerated = this.codec.decodeModuleToGenerated(state);\n        this.moduleName2GeneratedMapping = _decodeModuleToGenerated;\n      }\n    } catch (final Throwable _t) {\n      if (_t instanceof Exception) {\n        final Exception exc = (Exception)_t;\n        XtextAutoBuilderComponent.LOG.error(\"Error loading XtextAutoBuildComponentState \", exc);\n        ChunkedResourceDescriptions _get_1 = this.chunkedResourceDescriptionsProvider.get();\n        this.chunkedResourceDescriptions = _get_1;\n        this.moduleName2GeneratedMapping.clear();\n        this.doCleanBuild();\n      } else {\n        throw Exceptions.sneakyThrow(_t);\n      }\n    }\n  }","commit_id":"a0034ba4912b5d853d71627bd5cc61bc79d26fcd","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public XtextAutoBuilderComponentState getState() {\n    return this.codec.encode(this.chunkedResourceDescriptions, this.moduleName2GeneratedMapping);\n  }","id":83320,"modified_method":"@Override\n  public XtextAutoBuilderComponentState getState() {\n    return this.codec.encode(this.resourceServiceProviderRegistry, this.chunkedResourceDescriptions, this.moduleName2GeneratedMapping);\n  }","commit_id":"a0034ba4912b5d853d71627bd5cc61bc79d26fcd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void doRunBuild() {\n    if (XtextAutoBuilderComponent.TEST_MODE) {\n      if ((!this.avoidBuildInTestMode)) {\n        Project _project = this.getProject();\n        PsiManager _instance = PsiManager.getInstance(_project);\n        PsiModificationTracker _modificationTracker = _instance.getModificationTracker();\n        ((PsiModificationTrackerImpl) _modificationTracker).incCounter();\n        this.build();\n      }\n    } else {\n      this.alarm.cancelAllRequests();\n      final Procedure1<XtextAutoBuilderComponent.MutableCancelIndicator> _function = new Procedure1<XtextAutoBuilderComponent.MutableCancelIndicator>() {\n        @Override\n        public void apply(final XtextAutoBuilderComponent.MutableCancelIndicator it) {\n          it.canceled = true;\n        }\n      };\n      IterableExtensions.<XtextAutoBuilderComponent.MutableCancelIndicator>forEach(this.cancelIndicators, _function);\n      final Runnable _function_1 = new Runnable() {\n        @Override\n        public void run() {\n          XtextAutoBuilderComponent.this.build();\n        }\n      };\n      this.alarm.addRequest(_function_1, 200);\n    }\n  }","id":83321,"modified_method":"protected void doRunBuild() {\n    if (XtextAutoBuilderComponent.TEST_MODE) {\n      if ((!this.avoidBuildInTestMode)) {\n        Project _project = this.getProject();\n        PsiManager _instance = PsiManager.getInstance(_project);\n        PsiModificationTracker _modificationTracker = _instance.getModificationTracker();\n        ((PsiModificationTrackerImpl) _modificationTracker).incCounter();\n        this.build();\n      }\n    } else {\n      this.alarm.cancelAllRequests();\n      final Procedure1<XtextAutoBuilderComponent.MutableCancelIndicator> _function = new Procedure1<XtextAutoBuilderComponent.MutableCancelIndicator>() {\n        @Override\n        public void apply(final XtextAutoBuilderComponent.MutableCancelIndicator it) {\n          it.canceled = true;\n        }\n      };\n      IterableExtensions.<XtextAutoBuilderComponent.MutableCancelIndicator>forEach(this.cancelIndicators, _function);\n      final Runnable _function_1 = new Runnable() {\n        @Override\n        public void run() {\n          XtextAutoBuilderComponent.this.build();\n        }\n      };\n      Application _application = ApplicationManager.getApplication();\n      ModalityState _defaultModalityState = _application.getDefaultModalityState();\n      this.alarm.addRequest(_function_1, 200, _defaultModalityState);\n    }\n  }","commit_id":"a0034ba4912b5d853d71627bd5cc61bc79d26fcd","url":"https://github.com/eclipse/xtext"},{"original_method":"public XtextAutoBuilderComponentState encode(final ChunkedResourceDescriptions index, final Map<String, Source2GeneratedMapping> module2GeneratedMapping) {\n      final Element indexData = this.toXml(index, \"xtextIndex\");\n      final Element module2generatedData = this.toXml(module2GeneratedMapping, \"module2generated\");\n      return new XtextAutoBuilderComponentState(indexData, module2generatedData);\n    }","id":83322,"modified_method":"public XtextAutoBuilderComponentState encode(final IResourceServiceProvider.Registry registry, final ChunkedResourceDescriptions index, final Map<String, Source2GeneratedMapping> module2GeneratedMapping) {\n      Element _element = new Element(\"installedLanguages\");\n      Map<String, Object> _extensionToFactoryMap = registry.getExtensionToFactoryMap();\n      Set<String> _keySet = _extensionToFactoryMap.keySet();\n      List<String> _list = IterableExtensions.<String>toList(_keySet);\n      List<String> _sort = IterableExtensions.<String>sort(_list);\n      String _join = IterableExtensions.join(_sort, this.SEP);\n      final Element installedLanguages = _element.addContent(_join);\n      final Element indexData = this.toXml(index, \"xtextIndex\");\n      final Element module2generatedData = this.toXml(module2GeneratedMapping, \"module2generated\");\n      return new XtextAutoBuilderComponentState(installedLanguages, indexData, module2generatedData);\n    }","commit_id":"a0034ba4912b5d853d71627bd5cc61bc79d26fcd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected XtextAutoBuilderComponentState(final Element index, final Element module2generated) {\n    this.index = index;\n    this.module2generated = module2generated;\n  }","id":83323,"modified_method":"protected XtextAutoBuilderComponentState(final Element installedLanguages, final Element index, final Element module2generated) {\n    this.installedLanguages = installedLanguages;\n    this.index = index;\n    this.module2generated = module2generated;\n  }","commit_id":"a0034ba4912b5d853d71627bd5cc61bc79d26fcd","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testIndex() {\n    try {\n      final HashMap<String, ResourceDescriptionsData> map = CollectionLiterals.<String, ResourceDescriptionsData>newHashMap();\n      IntegerRange _upTo = new IntegerRange(0, 1);\n      for (final Integer j : _upTo) {\n        {\n          final XtextResourceSet rs = new XtextResourceSet();\n          final ArrayList<IResourceDescription> descriptions = CollectionLiterals.<IResourceDescription>newArrayList();\n          IntegerRange _upTo_1 = new IntegerRange(0, 1);\n          for (final Integer i : _upTo_1) {\n            {\n              StringConcatenation _builder = new StringConcatenation();\n              _builder.append(\"entity Foo1{}\");\n              _builder.newLine();\n              URI _createURI = URI.createURI(((\"Foo\" + i) + \".indextestlanguage\"));\n              EObject _parse = this._parseHelper.parse(_builder, _createURI, rs);\n              final Resource r = _parse.eResource();\n              IResourceDescription _resourceDescription = this._manager.getResourceDescription(r);\n              descriptions.add(_resourceDescription);\n            }\n          }\n          ResourceDescriptionsData _resourceDescriptionsData = new ResourceDescriptionsData(descriptions);\n          map.put((\"module\" + j), _resourceDescriptionsData);\n        }\n      }\n      final ChunkedResourceDescriptions index = new ChunkedResourceDescriptions(map);\n      Map<String, Source2GeneratedMapping> _emptyMap = CollectionLiterals.<String, Source2GeneratedMapping>emptyMap();\n      final XtextAutoBuilderComponentState state = this._codec.encode(index, _emptyMap);\n      final ChunkedResourceDescriptions _index = this._codec.decodeIndex(state);\n      Iterable<IResourceDescription> _allResourceDescriptions = index.getAllResourceDescriptions();\n      int _size = IterableExtensions.size(_allResourceDescriptions);\n      Iterable<IResourceDescription> _allResourceDescriptions_1 = _index.getAllResourceDescriptions();\n      int _size_1 = IterableExtensions.size(_allResourceDescriptions_1);\n      Assert.assertEquals(_size, _size_1);\n      Iterable<IResourceDescription> _allResourceDescriptions_2 = index.getAllResourceDescriptions();\n      for (final IResourceDescription desc : _allResourceDescriptions_2) {\n        URI _uRI = desc.getURI();\n        IResourceDescription _resourceDescription = _index.getResourceDescription(_uRI);\n        IResourceDescription.Delta _createDelta = this._manager.createDelta(desc, _resourceDescription);\n        boolean _haveEObjectDescriptionsChanged = _createDelta.haveEObjectDescriptionsChanged();\n        Assert.assertFalse(_haveEObjectDescriptionsChanged);\n      }\n      ResourceDescriptionsData _container = _index.getContainer(\"module1\");\n      final Iterable<IResourceDescription> _module0 = _container.getAllResourceDescriptions();\n      final Function1<IResourceDescription, String> _function = new Function1<IResourceDescription, String>() {\n        @Override\n        public String apply(final IResourceDescription it) {\n          URI _uRI = it.getURI();\n          String _lastSegment = _uRI.lastSegment();\n          return _lastSegment.toString();\n        }\n      };\n      Iterable<String> _map = IterableExtensions.<IResourceDescription, String>map(_module0, _function);\n      Set<String> _set = IterableExtensions.<String>toSet(_map);\n      Assert.assertEquals(Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet(\"Foo0.indextestlanguage\", \"Foo1.indextestlanguage\")), _set);\n      ResourceDescriptionsData _container_1 = _index.getContainer(\"module1\");\n      final Iterable<IResourceDescription> _module1 = _container_1.getAllResourceDescriptions();\n      final Function1<IResourceDescription, String> _function_1 = new Function1<IResourceDescription, String>() {\n        @Override\n        public String apply(final IResourceDescription it) {\n          URI _uRI = it.getURI();\n          String _lastSegment = _uRI.lastSegment();\n          return _lastSegment.toString();\n        }\n      };\n      Iterable<String> _map_1 = IterableExtensions.<IResourceDescription, String>map(_module1, _function_1);\n      Set<String> _set_1 = IterableExtensions.<String>toSet(_map_1);\n      Assert.assertEquals(Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet(\"Foo0.indextestlanguage\", \"Foo1.indextestlanguage\")), _set_1);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":83324,"modified_method":"@Test\n  public void testIndex() {\n    try {\n      final HashMap<String, ResourceDescriptionsData> map = CollectionLiterals.<String, ResourceDescriptionsData>newHashMap();\n      IntegerRange _upTo = new IntegerRange(0, 1);\n      for (final Integer j : _upTo) {\n        {\n          final XtextResourceSet rs = new XtextResourceSet();\n          final ArrayList<IResourceDescription> descriptions = CollectionLiterals.<IResourceDescription>newArrayList();\n          IntegerRange _upTo_1 = new IntegerRange(0, 1);\n          for (final Integer i : _upTo_1) {\n            {\n              StringConcatenation _builder = new StringConcatenation();\n              _builder.append(\"entity Foo1{}\");\n              _builder.newLine();\n              URI _createURI = URI.createURI(((\"Foo\" + i) + \".indextestlanguage\"));\n              EObject _parse = this._parseHelper.parse(_builder, _createURI, rs);\n              final Resource r = _parse.eResource();\n              IResourceDescription _resourceDescription = this._manager.getResourceDescription(r);\n              descriptions.add(_resourceDescription);\n            }\n          }\n          ResourceDescriptionsData _resourceDescriptionsData = new ResourceDescriptionsData(descriptions);\n          map.put((\"module\" + j), _resourceDescriptionsData);\n        }\n      }\n      final ChunkedResourceDescriptions index = new ChunkedResourceDescriptions(map);\n      ResourceServiceProviderRegistryImpl _resourceServiceProviderRegistryImpl = new ResourceServiceProviderRegistryImpl();\n      Map<String, Source2GeneratedMapping> _emptyMap = CollectionLiterals.<String, Source2GeneratedMapping>emptyMap();\n      final XtextAutoBuilderComponentState state = this._codec.encode(_resourceServiceProviderRegistryImpl, index, _emptyMap);\n      final ChunkedResourceDescriptions _index = this._codec.decodeIndex(state);\n      Iterable<IResourceDescription> _allResourceDescriptions = index.getAllResourceDescriptions();\n      int _size = IterableExtensions.size(_allResourceDescriptions);\n      Iterable<IResourceDescription> _allResourceDescriptions_1 = _index.getAllResourceDescriptions();\n      int _size_1 = IterableExtensions.size(_allResourceDescriptions_1);\n      Assert.assertEquals(_size, _size_1);\n      Iterable<IResourceDescription> _allResourceDescriptions_2 = index.getAllResourceDescriptions();\n      for (final IResourceDescription desc : _allResourceDescriptions_2) {\n        URI _uRI = desc.getURI();\n        IResourceDescription _resourceDescription = _index.getResourceDescription(_uRI);\n        IResourceDescription.Delta _createDelta = this._manager.createDelta(desc, _resourceDescription);\n        boolean _haveEObjectDescriptionsChanged = _createDelta.haveEObjectDescriptionsChanged();\n        Assert.assertFalse(_haveEObjectDescriptionsChanged);\n      }\n      ResourceDescriptionsData _container = _index.getContainer(\"module1\");\n      final Iterable<IResourceDescription> _module0 = _container.getAllResourceDescriptions();\n      final Function1<IResourceDescription, String> _function = new Function1<IResourceDescription, String>() {\n        @Override\n        public String apply(final IResourceDescription it) {\n          URI _uRI = it.getURI();\n          String _lastSegment = _uRI.lastSegment();\n          return _lastSegment.toString();\n        }\n      };\n      Iterable<String> _map = IterableExtensions.<IResourceDescription, String>map(_module0, _function);\n      Set<String> _set = IterableExtensions.<String>toSet(_map);\n      Assert.assertEquals(Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet(\"Foo0.indextestlanguage\", \"Foo1.indextestlanguage\")), _set);\n      ResourceDescriptionsData _container_1 = _index.getContainer(\"module1\");\n      final Iterable<IResourceDescription> _module1 = _container_1.getAllResourceDescriptions();\n      final Function1<IResourceDescription, String> _function_1 = new Function1<IResourceDescription, String>() {\n        @Override\n        public String apply(final IResourceDescription it) {\n          URI _uRI = it.getURI();\n          String _lastSegment = _uRI.lastSegment();\n          return _lastSegment.toString();\n        }\n      };\n      Iterable<String> _map_1 = IterableExtensions.<IResourceDescription, String>map(_module1, _function_1);\n      Set<String> _set_1 = IterableExtensions.<String>toSet(_map_1);\n      Assert.assertEquals(Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet(\"Foo0.indextestlanguage\", \"Foo1.indextestlanguage\")), _set_1);\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"a0034ba4912b5d853d71627bd5cc61bc79d26fcd","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testSource2GeneratedMap() {\n    final Source2GeneratedMapping s2g0 = new Source2GeneratedMapping();\n    URI _createURI = URI.createURI(\"foo\");\n    URI _createURI_1 = URI.createURI(\"foo_\");\n    s2g0.addSource2Generated(_createURI, _createURI_1);\n    URI _createURI_2 = URI.createURI(\"foo\");\n    URI _createURI_3 = URI.createURI(\"baz_\");\n    s2g0.addSource2Generated(_createURI_2, _createURI_3);\n    URI _createURI_4 = URI.createURI(\"bar\");\n    URI _createURI_5 = URI.createURI(\"bar_\");\n    s2g0.addSource2Generated(_createURI_4, _createURI_5);\n    URI _createURI_6 = URI.createURI(\"bar\");\n    URI _createURI_7 = URI.createURI(\"baz_\");\n    s2g0.addSource2Generated(_createURI_6, _createURI_7);\n    final Source2GeneratedMapping s2g1 = new Source2GeneratedMapping();\n    URI _createURI_8 = URI.createURI(\"foobar\");\n    URI _createURI_9 = URI.createURI(\"foobar_\");\n    s2g1.addSource2Generated(_createURI_8, _createURI_9);\n    URI _createURI_10 = URI.createURI(\"foobar\");\n    URI _createURI_11 = URI.createURI(\"foobar2_\");\n    s2g1.addSource2Generated(_createURI_10, _createURI_11);\n    Pair<String, Source2GeneratedMapping> _mappedTo = Pair.<String, Source2GeneratedMapping>of(\"module0\", s2g0);\n    Pair<String, Source2GeneratedMapping> _mappedTo_1 = Pair.<String, Source2GeneratedMapping>of(\"module1\", s2g1);\n    final Map<String, Source2GeneratedMapping> map = Collections.<String, Source2GeneratedMapping>unmodifiableMap(CollectionLiterals.<String, Source2GeneratedMapping>newHashMap(_mappedTo, _mappedTo_1));\n    ChunkedResourceDescriptions _chunkedResourceDescriptions = new ChunkedResourceDescriptions();\n    final XtextAutoBuilderComponentState state = this._codec.encode(_chunkedResourceDescriptions, map);\n    final Map<String, Source2GeneratedMapping> decodedState = this._codec.decodeModuleToGenerated(state);\n    Set<String> _keySet = decodedState.keySet();\n    int _size = _keySet.size();\n    Assert.assertEquals(2, _size);\n    final Source2GeneratedMapping _s2g0 = decodedState.get(\"module0\");\n    Assert.assertNotNull(_s2g0);\n    URI _createURI_12 = URI.createURI(\"foo_\");\n    URI _createURI_13 = URI.createURI(\"bar_\");\n    URI _createURI_14 = URI.createURI(\"baz_\");\n    List<URI> _allGenerated = _s2g0.getAllGenerated();\n    Set<URI> _set = IterableExtensions.<URI>toSet(_allGenerated);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_12, _createURI_13, _createURI_14)), _set);\n    URI _createURI_15 = URI.createURI(\"foo_\");\n    URI _createURI_16 = URI.createURI(\"baz_\");\n    URI _createURI_17 = URI.createURI(\"foo\");\n    List<URI> _generated = _s2g0.getGenerated(_createURI_17);\n    Set<URI> _set_1 = IterableExtensions.<URI>toSet(_generated);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_15, _createURI_16)), _set_1);\n    URI _createURI_18 = URI.createURI(\"bar_\");\n    URI _createURI_19 = URI.createURI(\"baz_\");\n    URI _createURI_20 = URI.createURI(\"bar\");\n    List<URI> _generated_1 = _s2g0.getGenerated(_createURI_20);\n    Set<URI> _set_2 = IterableExtensions.<URI>toSet(_generated_1);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_18, _createURI_19)), _set_2);\n    URI _createURI_21 = URI.createURI(\"foo\");\n    URI _createURI_22 = URI.createURI(\"foo_\");\n    List<URI> _source = _s2g0.getSource(_createURI_22);\n    Set<URI> _set_3 = IterableExtensions.<URI>toSet(_source);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_21)), _set_3);\n    URI _createURI_23 = URI.createURI(\"bar\");\n    URI _createURI_24 = URI.createURI(\"bar_\");\n    List<URI> _source_1 = _s2g0.getSource(_createURI_24);\n    Set<URI> _set_4 = IterableExtensions.<URI>toSet(_source_1);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_23)), _set_4);\n    URI _createURI_25 = URI.createURI(\"foo\");\n    URI _createURI_26 = URI.createURI(\"bar\");\n    URI _createURI_27 = URI.createURI(\"baz_\");\n    List<URI> _source_2 = _s2g0.getSource(_createURI_27);\n    Set<URI> _set_5 = IterableExtensions.<URI>toSet(_source_2);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_25, _createURI_26)), _set_5);\n    final Source2GeneratedMapping _s2g1 = decodedState.get(\"module1\");\n    Assert.assertNotNull(_s2g1);\n    URI _createURI_28 = URI.createURI(\"foobar_\");\n    URI _createURI_29 = URI.createURI(\"foobar2_\");\n    List<URI> _allGenerated_1 = _s2g1.getAllGenerated();\n    Set<URI> _set_6 = IterableExtensions.<URI>toSet(_allGenerated_1);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_28, _createURI_29)), _set_6);\n    URI _createURI_30 = URI.createURI(\"foobar_\");\n    URI _createURI_31 = URI.createURI(\"foobar2_\");\n    URI _createURI_32 = URI.createURI(\"foobar\");\n    List<URI> _generated_2 = _s2g1.getGenerated(_createURI_32);\n    Set<URI> _set_7 = IterableExtensions.<URI>toSet(_generated_2);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_30, _createURI_31)), _set_7);\n    URI _createURI_33 = URI.createURI(\"foobar\");\n    URI _createURI_34 = URI.createURI(\"foobar_\");\n    List<URI> _source_3 = _s2g1.getSource(_createURI_34);\n    Set<URI> _set_8 = IterableExtensions.<URI>toSet(_source_3);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_33)), _set_8);\n    URI _createURI_35 = URI.createURI(\"foobar\");\n    URI _createURI_36 = URI.createURI(\"foobar2_\");\n    List<URI> _source_4 = _s2g1.getSource(_createURI_36);\n    Set<URI> _set_9 = IterableExtensions.<URI>toSet(_source_4);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_35)), _set_9);\n  }","id":83325,"modified_method":"@Test\n  public void testSource2GeneratedMap() {\n    final Source2GeneratedMapping s2g0 = new Source2GeneratedMapping();\n    URI _createURI = URI.createURI(\"foo\");\n    URI _createURI_1 = URI.createURI(\"foo_\");\n    s2g0.addSource2Generated(_createURI, _createURI_1);\n    URI _createURI_2 = URI.createURI(\"foo\");\n    URI _createURI_3 = URI.createURI(\"baz_\");\n    s2g0.addSource2Generated(_createURI_2, _createURI_3);\n    URI _createURI_4 = URI.createURI(\"bar\");\n    URI _createURI_5 = URI.createURI(\"bar_\");\n    s2g0.addSource2Generated(_createURI_4, _createURI_5);\n    URI _createURI_6 = URI.createURI(\"bar\");\n    URI _createURI_7 = URI.createURI(\"baz_\");\n    s2g0.addSource2Generated(_createURI_6, _createURI_7);\n    final Source2GeneratedMapping s2g1 = new Source2GeneratedMapping();\n    URI _createURI_8 = URI.createURI(\"foobar\");\n    URI _createURI_9 = URI.createURI(\"foobar_\");\n    s2g1.addSource2Generated(_createURI_8, _createURI_9);\n    URI _createURI_10 = URI.createURI(\"foobar\");\n    URI _createURI_11 = URI.createURI(\"foobar2_\");\n    s2g1.addSource2Generated(_createURI_10, _createURI_11);\n    Pair<String, Source2GeneratedMapping> _mappedTo = Pair.<String, Source2GeneratedMapping>of(\"module0\", s2g0);\n    Pair<String, Source2GeneratedMapping> _mappedTo_1 = Pair.<String, Source2GeneratedMapping>of(\"module1\", s2g1);\n    final Map<String, Source2GeneratedMapping> map = Collections.<String, Source2GeneratedMapping>unmodifiableMap(CollectionLiterals.<String, Source2GeneratedMapping>newHashMap(_mappedTo, _mappedTo_1));\n    ResourceServiceProviderRegistryImpl _resourceServiceProviderRegistryImpl = new ResourceServiceProviderRegistryImpl();\n    ChunkedResourceDescriptions _chunkedResourceDescriptions = new ChunkedResourceDescriptions();\n    final XtextAutoBuilderComponentState state = this._codec.encode(_resourceServiceProviderRegistryImpl, _chunkedResourceDescriptions, map);\n    final Map<String, Source2GeneratedMapping> decodedState = this._codec.decodeModuleToGenerated(state);\n    Set<String> _keySet = decodedState.keySet();\n    int _size = _keySet.size();\n    Assert.assertEquals(2, _size);\n    final Source2GeneratedMapping _s2g0 = decodedState.get(\"module0\");\n    Assert.assertNotNull(_s2g0);\n    URI _createURI_12 = URI.createURI(\"foo_\");\n    URI _createURI_13 = URI.createURI(\"bar_\");\n    URI _createURI_14 = URI.createURI(\"baz_\");\n    List<URI> _allGenerated = _s2g0.getAllGenerated();\n    Set<URI> _set = IterableExtensions.<URI>toSet(_allGenerated);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_12, _createURI_13, _createURI_14)), _set);\n    URI _createURI_15 = URI.createURI(\"foo_\");\n    URI _createURI_16 = URI.createURI(\"baz_\");\n    URI _createURI_17 = URI.createURI(\"foo\");\n    List<URI> _generated = _s2g0.getGenerated(_createURI_17);\n    Set<URI> _set_1 = IterableExtensions.<URI>toSet(_generated);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_15, _createURI_16)), _set_1);\n    URI _createURI_18 = URI.createURI(\"bar_\");\n    URI _createURI_19 = URI.createURI(\"baz_\");\n    URI _createURI_20 = URI.createURI(\"bar\");\n    List<URI> _generated_1 = _s2g0.getGenerated(_createURI_20);\n    Set<URI> _set_2 = IterableExtensions.<URI>toSet(_generated_1);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_18, _createURI_19)), _set_2);\n    URI _createURI_21 = URI.createURI(\"foo\");\n    URI _createURI_22 = URI.createURI(\"foo_\");\n    List<URI> _source = _s2g0.getSource(_createURI_22);\n    Set<URI> _set_3 = IterableExtensions.<URI>toSet(_source);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_21)), _set_3);\n    URI _createURI_23 = URI.createURI(\"bar\");\n    URI _createURI_24 = URI.createURI(\"bar_\");\n    List<URI> _source_1 = _s2g0.getSource(_createURI_24);\n    Set<URI> _set_4 = IterableExtensions.<URI>toSet(_source_1);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_23)), _set_4);\n    URI _createURI_25 = URI.createURI(\"foo\");\n    URI _createURI_26 = URI.createURI(\"bar\");\n    URI _createURI_27 = URI.createURI(\"baz_\");\n    List<URI> _source_2 = _s2g0.getSource(_createURI_27);\n    Set<URI> _set_5 = IterableExtensions.<URI>toSet(_source_2);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_25, _createURI_26)), _set_5);\n    final Source2GeneratedMapping _s2g1 = decodedState.get(\"module1\");\n    Assert.assertNotNull(_s2g1);\n    URI _createURI_28 = URI.createURI(\"foobar_\");\n    URI _createURI_29 = URI.createURI(\"foobar2_\");\n    List<URI> _allGenerated_1 = _s2g1.getAllGenerated();\n    Set<URI> _set_6 = IterableExtensions.<URI>toSet(_allGenerated_1);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_28, _createURI_29)), _set_6);\n    URI _createURI_30 = URI.createURI(\"foobar_\");\n    URI _createURI_31 = URI.createURI(\"foobar2_\");\n    URI _createURI_32 = URI.createURI(\"foobar\");\n    List<URI> _generated_2 = _s2g1.getGenerated(_createURI_32);\n    Set<URI> _set_7 = IterableExtensions.<URI>toSet(_generated_2);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_30, _createURI_31)), _set_7);\n    URI _createURI_33 = URI.createURI(\"foobar\");\n    URI _createURI_34 = URI.createURI(\"foobar_\");\n    List<URI> _source_3 = _s2g1.getSource(_createURI_34);\n    Set<URI> _set_8 = IterableExtensions.<URI>toSet(_source_3);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_33)), _set_8);\n    URI _createURI_35 = URI.createURI(\"foobar\");\n    URI _createURI_36 = URI.createURI(\"foobar2_\");\n    List<URI> _source_4 = _s2g1.getSource(_createURI_36);\n    Set<URI> _set_9 = IterableExtensions.<URI>toSet(_source_4);\n    Assert.assertEquals(Collections.<URI>unmodifiableSet(CollectionLiterals.<URI>newHashSet(_createURI_35)), _set_9);\n  }","commit_id":"a0034ba4912b5d853d71627bd5cc61bc79d26fcd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JComponent createNorthPanel() {\n    myNameField = new EditorTextField(\"\");\n\n    String qualifiedName = getQualifiedName();\n    myTfPackage = new PackageNameReferenceEditorCombo(qualifiedName, myProject, RECENTS_KEY, RefactoringBundle.message(\"choose.destination.package\"));\n    myTfPackage.setTextFieldPreferredWidth(Math.max(qualifiedName.length() + 5, 40));\n    myPackageLabel.setText(RefactoringBundle.message(\"destination.package\"));\n    myPackageLabel.setLabelFor(myTfPackage);\n    if (myDoClone) {\n      myTfPackage.setVisible(false);\n      myPackageLabel.setVisible(false);\n    }\n\n    final JLabel label = new JLabel(RefactoringBundle.message(\"target.destination.folder\"));\n    final boolean isMultipleSourceRoots = ProjectRootManager.getInstance(myProject).getContentSourceRoots().length > 1;\n    myDestinationCB.setVisible(!myDoClone && isMultipleSourceRoots);\n    label.setVisible(!myDoClone && isMultipleSourceRoots);\n    label.setLabelFor(myDestinationCB);\n\n    return FormBuilder.createFormBuilder()\n      .addComponent(myInformationLabel)\n      .addLabeledComponent(RefactoringBundle.message(\"copy.files.new.name.label\"), myNameField, UIUtil.LARGE_VGAP)\n      .addLabeledComponent(myPackageLabel, myTfPackage)\n      .addLabeledComponent(label, myDestinationCB)\n      .getPanel();\n  }","id":83326,"modified_method":"protected JComponent createNorthPanel() {\n    myNameField = new EditorTextField(\"\");\n\n    String qualifiedName = getQualifiedName();\n    myTfPackage = new PackageNameReferenceEditorCombo(qualifiedName, myProject, RECENTS_KEY, RefactoringBundle.message(\"choose.destination.package\"));\n    myTfPackage.setTextFieldPreferredWidth(Math.max(qualifiedName.length() + 5, 40));\n    myPackageLabel.setText(RefactoringBundle.message(\"destination.package\"));\n    myPackageLabel.setLabelFor(myTfPackage);\n    if (myDoClone) {\n      myTfPackage.setVisible(false);\n      myPackageLabel.setVisible(false);\n    }\n\n    final JLabel label = new JLabel(RefactoringBundle.message(\"target.destination.folder\"));\n    final boolean isMultipleSourceRoots = ProjectRootManager.getInstance(myProject).getContentSourceRoots().length > 1;\n    myDestinationCB.setVisible(!myDoClone && isMultipleSourceRoots);\n    label.setVisible(!myDoClone && isMultipleSourceRoots);\n    label.setLabelFor(myDestinationCB);\n\n    final JPanel panel = new JPanel(new BorderLayout());\n    panel.add(myOpenInEditorCb, BorderLayout.EAST);\n    return FormBuilder.createFormBuilder()\n      .addComponent(myInformationLabel)\n      .addLabeledComponent(RefactoringBundle.message(\"copy.files.new.name.label\"), myNameField, UIUtil.LARGE_VGAP)\n      .addLabeledComponent(myPackageLabel, myTfPackage)\n      .addLabeledComponent(label, myDestinationCB)\n      .addComponent(panel)\n      .getPanel();\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doOKAction(){\n    final String packageName = myTfPackage.getText();\n    final String className = getClassName();\n\n    final String[] errorString = new String[1];\n    final PsiManager manager = PsiManager.getInstance(myProject);\n    final PsiNameHelper nameHelper = JavaPsiFacade.getInstance(manager.getProject()).getNameHelper();\n    if (packageName.length() > 0 && !nameHelper.isQualifiedName(packageName)) {\n      errorString[0] = RefactoringBundle.message(\"invalid.target.package.name.specified\");\n    } else if (className != null && className.isEmpty()) {\n      errorString[0] = RefactoringBundle.message(\"no.class.name.specified\");\n    } else {\n      if (!nameHelper.isIdentifier(className)) {\n        errorString[0] = RefactoringMessageUtil.getIncorrectIdentifierMessage(className);\n      }\n      else if (!myDoClone) {\n        try {\n          final PackageWrapper targetPackage = new PackageWrapper(manager, packageName);\n          myDestination = myDestinationCB.selectDirectory(targetPackage, false);\n          if (myDestination == null) return;\n        }\n        catch (IncorrectOperationException e) {\n          errorString[0] = e.getMessage();\n        }\n      }\n      RecentsManager.getInstance(myProject).registerRecentEntry(RECENTS_KEY, packageName);\n    }\n\n    if (errorString[0] != null) {\n      if (errorString[0].length() > 0) {\n        Messages.showMessageDialog(myProject, errorString[0], RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n      }\n      myNameField.requestFocusInWindow();\n      return;\n    }\n    super.doOKAction();\n  }","id":83327,"modified_method":"protected void doOKAction(){\n    final String packageName = myTfPackage.getText();\n    final String className = getClassName();\n\n    final String[] errorString = new String[1];\n    final PsiManager manager = PsiManager.getInstance(myProject);\n    final PsiNameHelper nameHelper = JavaPsiFacade.getInstance(manager.getProject()).getNameHelper();\n    if (packageName.length() > 0 && !nameHelper.isQualifiedName(packageName)) {\n      errorString[0] = RefactoringBundle.message(\"invalid.target.package.name.specified\");\n    } else if (className != null && className.isEmpty()) {\n      errorString[0] = RefactoringBundle.message(\"no.class.name.specified\");\n    } else {\n      if (!nameHelper.isIdentifier(className)) {\n        errorString[0] = RefactoringMessageUtil.getIncorrectIdentifierMessage(className);\n      }\n      else if (!myDoClone) {\n        try {\n          final PackageWrapper targetPackage = new PackageWrapper(manager, packageName);\n          myDestination = myDestinationCB.selectDirectory(targetPackage, false);\n          if (myDestination == null) return;\n        }\n        catch (IncorrectOperationException e) {\n          errorString[0] = e.getMessage();\n        }\n      }\n      RecentsManager.getInstance(myProject).registerRecentEntry(RECENTS_KEY, packageName);\n    }\n\n    if (errorString[0] != null) {\n      if (errorString[0].length() > 0) {\n        Messages.showMessageDialog(myProject, errorString[0], RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n      }\n      myNameField.requestFocusInWindow();\n      return;\n    }\n    CopyFilesOrDirectoriesDialog.saveOpenInEditorState(myOpenInEditorCb.isSelected());\n    super.doOKAction();\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void copyClassesImpl(final String copyClassName,\n                                      final Project project,\n                                      final Map<PsiFile, PsiClass[]> classes,\n                                      final HashMap<PsiFile, String> map,\n                                      final Object targetDirectory,\n                                      final PsiDirectory defaultTargetDirectory,\n                                      final String commandName,\n                                      final boolean selectInActivePanel) {\n    final boolean[] result = new boolean[] {false};\n    Runnable command = new Runnable() {\n      public void run() {\n        final Runnable action = new Runnable() {\n          public void run() {\n            try {\n              PsiDirectory target;\n              if (targetDirectory instanceof PsiDirectory) {\n                target = (PsiDirectory)targetDirectory;\n              } else {\n                target = ((MoveDestination)targetDirectory).getTargetDirectory(defaultTargetDirectory);\n              }\n              PsiElement newElement = doCopyClasses(classes, map, copyClassName, target, project);\n              if (newElement != null) {\n                CopyHandler.updateSelectionInActiveProjectView(newElement, project, selectInActivePanel);\n                EditorHelper.openInEditor(newElement);\n\n                result[0] = true;\n              }\n            }\n            catch (final IncorrectOperationException ex) {\n              ApplicationManager.getApplication().invokeLater(new Runnable() {\n                public void run() {\n                  Messages.showMessageDialog(project, ex.getMessage(), RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n                }\n              });\n            }\n          }\n        };\n        ApplicationManager.getApplication().runWriteAction(action);\n      }\n    };\n    CommandProcessor processor = CommandProcessor.getInstance();\n    processor.executeCommand(project, command, commandName, null);\n\n    if (result[0]) {\n      ToolWindowManager.getInstance(project).invokeLater(new Runnable() {\n        public void run() {\n          ToolWindowManager.getInstance(project).activateEditorComponent();\n        }\n      });\n    }\n  }","id":83328,"modified_method":"private static void copyClassesImpl(final String copyClassName,\n                                      final Project project,\n                                      final Map<PsiFile, PsiClass[]> classes,\n                                      final HashMap<PsiFile, String> map,\n                                      final Object targetDirectory,\n                                      final PsiDirectory defaultTargetDirectory,\n                                      final String commandName,\n                                      final boolean selectInActivePanel, \n                                      final boolean openInEditor) {\n    final boolean[] result = new boolean[] {false};\n    Runnable command = new Runnable() {\n      public void run() {\n        final Runnable action = new Runnable() {\n          public void run() {\n            try {\n              PsiDirectory target;\n              if (targetDirectory instanceof PsiDirectory) {\n                target = (PsiDirectory)targetDirectory;\n              } else {\n                target = ((MoveDestination)targetDirectory).getTargetDirectory(defaultTargetDirectory);\n              }\n              PsiElement newElement = doCopyClasses(classes, map, copyClassName, target, project);\n              if (newElement != null) {\n                CopyHandler.updateSelectionInActiveProjectView(newElement, project, selectInActivePanel);\n                if (openInEditor) EditorHelper.openInEditor(newElement);\n\n                result[0] = true;\n              }\n            }\n            catch (final IncorrectOperationException ex) {\n              ApplicationManager.getApplication().invokeLater(new Runnable() {\n                public void run() {\n                  Messages.showMessageDialog(project, ex.getMessage(), RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n                }\n              });\n            }\n          }\n        };\n        ApplicationManager.getApplication().runWriteAction(action);\n      }\n    };\n    CommandProcessor processor = CommandProcessor.getInstance();\n    processor.executeCommand(project, command, commandName, null);\n\n    if (result[0]) {\n      ToolWindowManager.getInstance(project).invokeLater(new Runnable() {\n        public void run() {\n          ToolWindowManager.getInstance(project).activateEditorComponent();\n        }\n      });\n    }\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doClone(PsiElement element) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.copyClass\");\n    PsiClass[] classes = getTopLevelClasses(element);\n    if (classes == null) {\n      CopyFilesOrDirectoriesHandler.doCloneFile(element);\n      return;\n    }\n    Project project = element.getProject();\n\n    CopyClassDialog dialog = new CopyClassDialog(classes[0], null, project, true);\n    dialog.setTitle(RefactoringBundle.message(\"copy.handler.clone.class\"));\n    dialog.show();\n    if (dialog.isOK()) {\n      String className = dialog.getClassName();\n      PsiDirectory targetDirectory = element.getContainingFile().getContainingDirectory();\n      copyClassesImpl(className, project, Collections.singletonMap(classes[0].getContainingFile(), classes), null, targetDirectory,\n                      targetDirectory, RefactoringBundle.message(\"copy.handler.clone.class\"), true);\n    }\n  }","id":83329,"modified_method":"public void doClone(PsiElement element) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.copyClass\");\n    PsiClass[] classes = getTopLevelClasses(element);\n    if (classes == null) {\n      CopyFilesOrDirectoriesHandler.doCloneFile(element);\n      return;\n    }\n    Project project = element.getProject();\n\n    CopyClassDialog dialog = new CopyClassDialog(classes[0], null, project, true);\n    dialog.setTitle(RefactoringBundle.message(\"copy.handler.clone.class\"));\n    dialog.show();\n    if (dialog.isOK()) {\n      String className = dialog.getClassName();\n      PsiDirectory targetDirectory = element.getContainingFile().getContainingDirectory();\n      copyClassesImpl(className, project, Collections.singletonMap(classes[0].getContainingFile(), classes), null, targetDirectory,\n                      targetDirectory, RefactoringBundle.message(\"copy.handler.clone.class\"), true, true);\n    }\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doCopy(PsiElement[] elements, PsiDirectory defaultTargetDirectory) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.copyClass\");\n    final HashMap<PsiFile, String> relativePathsMap = new HashMap<PsiFile, String>();\n    final Map<PsiFile, PsiClass[]> classes = convertToTopLevelClasses(elements, false, \"\", relativePathsMap);\n    assert classes != null;\n    if (defaultTargetDirectory == null) {\n      final PsiFile psiFile = classes.keySet().iterator().next();\n      defaultTargetDirectory = psiFile.getContainingDirectory();\n      LOG.assertTrue(defaultTargetDirectory != null, psiFile);\n    } else {\n      Project project = defaultTargetDirectory.getProject();\n      VirtualFile sourceRootForFile = ProjectRootManager.getInstance(project).getFileIndex()\n        .getSourceRootForFile(defaultTargetDirectory.getVirtualFile());\n      if (sourceRootForFile == null) {\n        final List<PsiElement> files = new ArrayList<PsiElement>();\n        for (int i = 0, elementsLength = elements.length; i < elementsLength; i++) {\n          PsiFile containingFile = elements[i].getContainingFile();\n          if (containingFile != null) {\n            files.add(containingFile);\n          } else if (elements[i] instanceof PsiDirectory) {\n            files.add(elements[i]);\n          }\n        }\n        CopyFilesOrDirectoriesHandler.copyAsFiles(files.toArray(new PsiElement[files.size()]), defaultTargetDirectory, project);\n        return;\n      }\n    }\n    Project project = defaultTargetDirectory.getProject();\n    Object targetDirectory = null;\n    String className = null;\n    if (copyOneClass(classes)) {\n      final String commonPath = ArrayUtil.find(elements, classes.values().iterator().next()) == -1 ? normalizeRelativeMap(relativePathsMap) : null;\n      CopyClassDialog dialog = new CopyClassDialog(classes.values().iterator().next()[0], defaultTargetDirectory, project, false){\n        @Override\n        protected String getQualifiedName() {\n          if (commonPath != null && !commonPath.isEmpty()) {\n            return StringUtil.getQualifiedName(super.getQualifiedName(), commonPath.replaceAll(\"/\", \".\"));\n          }\n          return super.getQualifiedName();\n        }\n      };\n      dialog.setTitle(RefactoringBundle.message(\"copy.handler.copy.class\"));\n      dialog.show();\n      if (dialog.isOK()) {\n        targetDirectory = dialog.getTargetDirectory();\n        className = dialog.getClassName();\n        if (className == null || className.length() == 0) return;\n      }\n    } else {\n      if (ApplicationManager.getApplication().isUnitTestMode()) {\n        targetDirectory = defaultTargetDirectory;\n      } else {\n        defaultTargetDirectory = CopyFilesOrDirectoriesHandler.resolveDirectory(defaultTargetDirectory);\n        if (defaultTargetDirectory == null) return;\n        PsiElement[] files = PsiUtilCore.toPsiFileArray(classes.keySet());\n        if (classes.keySet().size() == 1) {\n          //do not choose a new name for a file when multiple classes exist in one file\n          final PsiClass[] psiClasses = classes.values().iterator().next();\n          if (psiClasses != null) {\n            files = psiClasses;\n          }\n        }\n        final CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(files, defaultTargetDirectory, project, false);\n        dialog.show();\n        if (dialog.isOK()) {\n          targetDirectory = dialog.getTargetDirectory();\n          className = dialog.getNewName();\n        }\n      }\n    }\n    if (targetDirectory != null) {\n      copyClassesImpl(className, project, classes, relativePathsMap, targetDirectory, defaultTargetDirectory, RefactoringBundle.message(\n        \"copy.handler.copy.class\"), false);\n    }\n  }","id":83330,"modified_method":"public void doCopy(PsiElement[] elements, PsiDirectory defaultTargetDirectory) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.copyClass\");\n    final HashMap<PsiFile, String> relativePathsMap = new HashMap<PsiFile, String>();\n    final Map<PsiFile, PsiClass[]> classes = convertToTopLevelClasses(elements, false, \"\", relativePathsMap);\n    assert classes != null;\n    if (defaultTargetDirectory == null) {\n      final PsiFile psiFile = classes.keySet().iterator().next();\n      defaultTargetDirectory = psiFile.getContainingDirectory();\n      LOG.assertTrue(defaultTargetDirectory != null, psiFile);\n    } else {\n      Project project = defaultTargetDirectory.getProject();\n      VirtualFile sourceRootForFile = ProjectRootManager.getInstance(project).getFileIndex()\n        .getSourceRootForFile(defaultTargetDirectory.getVirtualFile());\n      if (sourceRootForFile == null) {\n        final List<PsiElement> files = new ArrayList<PsiElement>();\n        for (int i = 0, elementsLength = elements.length; i < elementsLength; i++) {\n          PsiFile containingFile = elements[i].getContainingFile();\n          if (containingFile != null) {\n            files.add(containingFile);\n          } else if (elements[i] instanceof PsiDirectory) {\n            files.add(elements[i]);\n          }\n        }\n        CopyFilesOrDirectoriesHandler.copyAsFiles(files.toArray(new PsiElement[files.size()]), defaultTargetDirectory, project);\n        return;\n      }\n    }\n    Project project = defaultTargetDirectory.getProject();\n    Object targetDirectory = null;\n    String className = null;\n    boolean openInEditor = true;\n    if (copyOneClass(classes)) {\n      final String commonPath = ArrayUtil.find(elements, classes.values().iterator().next()) == -1 ? normalizeRelativeMap(relativePathsMap) : null;\n      CopyClassDialog dialog = new CopyClassDialog(classes.values().iterator().next()[0], defaultTargetDirectory, project, false){\n        @Override\n        protected String getQualifiedName() {\n          if (commonPath != null && !commonPath.isEmpty()) {\n            return StringUtil.getQualifiedName(super.getQualifiedName(), commonPath.replaceAll(\"/\", \".\"));\n          }\n          return super.getQualifiedName();\n        }\n      };\n      dialog.setTitle(RefactoringBundle.message(\"copy.handler.copy.class\"));\n      dialog.show();\n      if (dialog.isOK()) {\n        openInEditor = dialog.openInEditor();\n        targetDirectory = dialog.getTargetDirectory();\n        className = dialog.getClassName();\n        if (className == null || className.length() == 0) return;\n      }\n    } else {\n      if (ApplicationManager.getApplication().isUnitTestMode()) {\n        targetDirectory = defaultTargetDirectory;\n      } else {\n        defaultTargetDirectory = CopyFilesOrDirectoriesHandler.resolveDirectory(defaultTargetDirectory);\n        if (defaultTargetDirectory == null) return;\n        PsiElement[] files = PsiUtilCore.toPsiFileArray(classes.keySet());\n        if (classes.keySet().size() == 1) {\n          //do not choose a new name for a file when multiple classes exist in one file\n          final PsiClass[] psiClasses = classes.values().iterator().next();\n          if (psiClasses != null) {\n            files = psiClasses;\n          }\n        }\n        final CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(files, defaultTargetDirectory, project, false);\n        dialog.show();\n        if (dialog.isOK()) {\n          targetDirectory = dialog.getTargetDirectory();\n          className = dialog.getNewName();\n          openInEditor = dialog.openInEditor();\n        }\n      }\n    }\n    if (targetDirectory != null) {\n      copyClassesImpl(className, project, classes, relativePathsMap, targetDirectory, defaultTargetDirectory, RefactoringBundle.message(\n        \"copy.handler.copy.class\"), false, openInEditor);\n    }\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doOKAction() {\n    if (myShowNewNameField) {\n      String newName = getNewName();\n\n      if (newName.length() == 0) {\n        Messages.showMessageDialog(myProject, RefactoringBundle.message(\"no.new.name.specified\"), RefactoringBundle.message(\"error.title\"),\n                                   Messages.getErrorIcon());\n        return;\n      }\n      \n      if (myFileCopy && !PathUtil.isValidFileName(newName)) {\n        Messages.showErrorDialog(myNewNameField, \"Name is not a valid file name\");\n        return;\n      }\n    }\n\n    if (myShowDirectoryField) {\n      final String targetDirectoryName = myTargetDirectoryField.getChildComponent().getText();\n\n      if (targetDirectoryName.length() == 0) {\n        Messages.showMessageDialog(myProject, RefactoringBundle.message(\"no.target.directory.specified\"),\n                                   RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n        return;\n      }\n\n      RecentsManager.getInstance(myProject).registerRecentEntry(RECENT_KEYS, targetDirectoryName);\n\n      CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n        @Override\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                myTargetDirectory =\n                  DirectoryUtil.mkdirs(PsiManager.getInstance(myProject), targetDirectoryName.replace(File.separatorChar, '/'));\n              }\n              catch (IncorrectOperationException e) {\n              }\n            }\n          });\n        }\n      }, RefactoringBundle.message(\"create.directory\"), null);\n\n      if (myTargetDirectory == null) {\n        Messages\n          .showMessageDialog(myProject, RefactoringBundle.message(\"cannot.create.directory\"), RefactoringBundle.message(\"error.title\"),\n                             Messages.getErrorIcon());\n        return;\n      }\n    }\n\n    super.doOKAction();\n  }","id":83331,"modified_method":"@Override\n  protected void doOKAction() {\n    if (myShowNewNameField) {\n      String newName = getNewName();\n\n      if (newName.length() == 0) {\n        Messages.showMessageDialog(myProject, RefactoringBundle.message(\"no.new.name.specified\"), RefactoringBundle.message(\"error.title\"),\n                                   Messages.getErrorIcon());\n        return;\n      }\n      \n      if (myFileCopy && !PathUtil.isValidFileName(newName)) {\n        Messages.showErrorDialog(myNewNameField, \"Name is not a valid file name\");\n        return;\n      }\n    }\n\n    if (myShowDirectoryField) {\n      final String targetDirectoryName = myTargetDirectoryField.getChildComponent().getText();\n\n      if (targetDirectoryName.length() == 0) {\n        Messages.showMessageDialog(myProject, RefactoringBundle.message(\"no.target.directory.specified\"),\n                                   RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n        return;\n      }\n\n      RecentsManager.getInstance(myProject).registerRecentEntry(RECENT_KEYS, targetDirectoryName);\n      saveOpenInEditorState(myOpenFilesInEditor.isSelected());\n\n      CommandProcessor.getInstance().executeCommand(myProject, new Runnable() {\n        @Override\n        public void run() {\n          ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            @Override\n            public void run() {\n              try {\n                myTargetDirectory =\n                  DirectoryUtil.mkdirs(PsiManager.getInstance(myProject), targetDirectoryName.replace(File.separatorChar, '/'));\n              }\n              catch (IncorrectOperationException e) {\n              }\n            }\n          });\n        }\n      }, RefactoringBundle.message(\"create.directory\"), null);\n\n      if (myTargetDirectory == null) {\n        Messages\n          .showMessageDialog(myProject, RefactoringBundle.message(\"cannot.create.directory\"), RefactoringBundle.message(\"error.title\"),\n                             Messages.getErrorIcon());\n        return;\n      }\n    }\n\n    super.doOKAction();\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CopyFilesOrDirectoriesDialog(PsiElement[] elements, PsiDirectory defaultTargetDirectory, Project project, boolean doClone) {\n    super(project, true);\n    myProject = project;\n    myShowDirectoryField = !doClone;\n    myShowNewNameField = elements.length == 1;\n\n    if (doClone && elements.length != 1) {\n      throw new IllegalArgumentException(\"wrong number of elements to clone: \" + elements.length);\n    }\n\n    setTitle(doClone ?\n             RefactoringBundle.message(\"copy.files.clone.title\") :\n             RefactoringBundle.message(\"copy.files.copy.title\"));\n    init();\n\n    if (elements.length == 1) {\n      String text;\n      if (elements[0] instanceof PsiFile) {\n        PsiFile file = (PsiFile)elements[0];\n        String url = shortenPath(file.getVirtualFile());\n        text = doClone ?\n               RefactoringBundle.message(\"copy.files.clone.file.0\", url) :\n               RefactoringBundle.message(\"copy.files.copy.file.0\", url);\n        final String fileName = file.getName();\n        myNewNameField.setText(fileName);\n        final int dotIdx = fileName.lastIndexOf(\".\");\n        if (dotIdx > -1) {\n          myNewNameField.select(0, dotIdx);\n          myNewNameField.putClientProperty(DialogWrapperPeerImpl.HAVE_INITIAL_SELECTION, true);\n        }\n        myFileCopy = true;\n      }\n      else {\n        PsiDirectory directory = (PsiDirectory)elements[0];\n        String url = shortenPath(directory.getVirtualFile());\n        text = doClone ?\n               RefactoringBundle.message(\"copy.files.clone.directory.0\", url) :\n               RefactoringBundle.message(\"copy.files.copy.directory.0\", url);\n        myNewNameField.setText(directory.getName());\n      }\n      myInformationLabel.setText(text);\n    }\n    else {\n      setMultipleElementCopyLabel(elements);\n    }\n\n    if (myShowDirectoryField) {\n      myTargetDirectoryField.getChildComponent()\n        .setText(defaultTargetDirectory == null ? \"\" : defaultTargetDirectory.getVirtualFile().getPresentableUrl());\n    }\n    validateOKButton();\n  }","id":83332,"modified_method":"public CopyFilesOrDirectoriesDialog(PsiElement[] elements, PsiDirectory defaultTargetDirectory, Project project, boolean doClone) {\n    super(project, true);\n    myProject = project;\n    myShowDirectoryField = !doClone;\n    myShowNewNameField = elements.length == 1;\n\n    if (doClone && elements.length != 1) {\n      throw new IllegalArgumentException(\"wrong number of elements to clone: \" + elements.length);\n    }\n\n    setTitle(doClone ?\n             RefactoringBundle.message(\"copy.files.clone.title\") :\n             RefactoringBundle.message(\"copy.files.copy.title\"));\n    init();\n\n    if (elements.length == 1) {\n      String text;\n      if (elements[0] instanceof PsiFile) {\n        PsiFile file = (PsiFile)elements[0];\n        String url = shortenPath(file.getVirtualFile());\n        text = doClone ?\n               RefactoringBundle.message(\"copy.files.clone.file.0\", url) :\n               RefactoringBundle.message(\"copy.files.copy.file.0\", url);\n        final String fileName = file.getName();\n        myNewNameField.setText(fileName);\n        final int dotIdx = fileName.lastIndexOf(\".\");\n        if (dotIdx > -1) {\n          myNewNameField.select(0, dotIdx);\n          myNewNameField.putClientProperty(DialogWrapperPeerImpl.HAVE_INITIAL_SELECTION, true);\n        }\n        myFileCopy = true;\n      }\n      else {\n        PsiDirectory directory = (PsiDirectory)elements[0];\n        String url = shortenPath(directory.getVirtualFile());\n        text = doClone ?\n               RefactoringBundle.message(\"copy.files.clone.directory.0\", url) :\n               RefactoringBundle.message(\"copy.files.copy.directory.0\", url);\n        myNewNameField.setText(directory.getName());\n      }\n      myInformationLabel.setText(text);\n    }\n    else {\n      setMultipleElementCopyLabel(elements);\n    }\n\n    boolean allBinary = true;\n    for (PsiElement element : elements) {\n      if (!(element.getContainingFile() instanceof PsiBinaryFile)) {\n        allBinary = false;\n        break;\n      }\n    }\n    if (allBinary) {\n      myOpenFilesInEditor.setVisible(false);\n    }\n    if (myShowDirectoryField) {\n      myTargetDirectoryField.getChildComponent()\n        .setText(defaultTargetDirectory == null ? \"\" : defaultTargetDirectory.getVirtualFile().getPresentableUrl());\n    }\n    validateOKButton();\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected JComponent createNorthPanel() {\n    myInformationLabel = JBLabelDecorator.createJBLabelDecorator().setBold(true);\n    final FormBuilder formBuilder = FormBuilder.createFormBuilder().addComponent(myInformationLabel).addVerticalGap(\n      UIUtil.LARGE_VGAP - UIUtil.DEFAULT_VGAP);\n    DocumentListener documentListener = new DocumentAdapter() {\n      @Override\n      public void textChanged(DocumentEvent event) {\n        validateOKButton();\n      }\n    };\n\n    if (myShowNewNameField) {\n      myNewNameField = new JTextField();\n      myNewNameField.getDocument().addDocumentListener(documentListener);\n      formBuilder.addLabeledComponent(RefactoringBundle.message(\"copy.files.new.name.label\"), myNewNameField);\n    }\n\n    if (myShowDirectoryField) {\n      myTargetDirectoryField = new TextFieldWithHistoryWithBrowseButton();\n      myTargetDirectoryField.setTextFieldPreferredWidth(MAX_PATH_LENGTH);\n      final List<String> recentEntries = RecentsManager.getInstance(myProject).getRecentEntries(RECENT_KEYS);\n      if (recentEntries != null) {\n        myTargetDirectoryField.getChildComponent().setHistory(recentEntries);\n      }\n      final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n      myTargetDirectoryField.addBrowseFolderListener(RefactoringBundle.message(\"select.target.directory\"),\n                                                     RefactoringBundle.message(\"the.file.will.be.copied.to.this.directory\"),\n                                                     myProject, descriptor,\n                                                     TextComponentAccessor.TEXT_FIELD_WITH_HISTORY_WHOLE_TEXT);\n      myTargetDirectoryField.getChildComponent().addDocumentListener(new DocumentAdapter() {\n        @Override\n        protected void textChanged(DocumentEvent e) {\n          validateOKButton();\n        }\n      });\n      formBuilder.addLabeledComponent(RefactoringBundle.message(\"copy.files.to.directory.label\"), myTargetDirectoryField);\n\n      String shortcutText =\n        KeymapUtil.getFirstKeyboardShortcutText(ActionManager.getInstance().getAction(IdeActions.ACTION_CODE_COMPLETION));\n      formBuilder.addTooltip(RefactoringBundle.message(\"path.completion.shortcut\", shortcutText));\n    }\n\n    return formBuilder.getPanel();\n  }","id":83333,"modified_method":"@Override\n  protected JComponent createNorthPanel() {\n    myInformationLabel = JBLabelDecorator.createJBLabelDecorator().setBold(true);\n    final FormBuilder formBuilder = FormBuilder.createFormBuilder().addComponent(myInformationLabel).addVerticalGap(\n      UIUtil.LARGE_VGAP - UIUtil.DEFAULT_VGAP);\n    DocumentListener documentListener = new DocumentAdapter() {\n      @Override\n      public void textChanged(DocumentEvent event) {\n        validateOKButton();\n      }\n    };\n\n    if (myShowNewNameField) {\n      myNewNameField = new JTextField();\n      myNewNameField.getDocument().addDocumentListener(documentListener);\n      formBuilder.addLabeledComponent(RefactoringBundle.message(\"copy.files.new.name.label\"), myNewNameField);\n    }\n\n    if (myShowDirectoryField) {\n      myTargetDirectoryField = new TextFieldWithHistoryWithBrowseButton();\n      myTargetDirectoryField.setTextFieldPreferredWidth(MAX_PATH_LENGTH);\n      final List<String> recentEntries = RecentsManager.getInstance(myProject).getRecentEntries(RECENT_KEYS);\n      if (recentEntries != null) {\n        myTargetDirectoryField.getChildComponent().setHistory(recentEntries);\n      }\n      final FileChooserDescriptor descriptor = FileChooserDescriptorFactory.createSingleFolderDescriptor();\n      myTargetDirectoryField.addBrowseFolderListener(RefactoringBundle.message(\"select.target.directory\"),\n                                                     RefactoringBundle.message(\"the.file.will.be.copied.to.this.directory\"),\n                                                     myProject, descriptor,\n                                                     TextComponentAccessor.TEXT_FIELD_WITH_HISTORY_WHOLE_TEXT);\n      myTargetDirectoryField.getChildComponent().addDocumentListener(new DocumentAdapter() {\n        @Override\n        protected void textChanged(DocumentEvent e) {\n          validateOKButton();\n        }\n      });\n      formBuilder.addLabeledComponent(RefactoringBundle.message(\"copy.files.to.directory.label\"), myTargetDirectoryField);\n\n      String shortcutText =\n        KeymapUtil.getFirstKeyboardShortcutText(ActionManager.getInstance().getAction(IdeActions.ACTION_CODE_COMPLETION));\n      formBuilder.addTooltip(RefactoringBundle.message(\"path.completion.shortcut\", shortcutText));\n    }\n\n    final JPanel wrapper = new JPanel(new BorderLayout());\n    wrapper.add(myOpenFilesInEditor, BorderLayout.EAST);\n    formBuilder.addComponent(wrapper);\n    return formBuilder.getPanel();\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void doCloneFile(PsiElement element) {\n    PsiDirectory targetDirectory;\n    if (element instanceof PsiDirectory) {\n      targetDirectory = ((PsiDirectory)element).getParentDirectory();\n    }\n    else  {\n      targetDirectory = ((PsiFile)element).getContainingDirectory();\n    }\n\n    PsiElement[] elements = {element};\n    CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(elements, null, element.getProject(), true);\n    dialog.show();\n    if (dialog.isOK()) {\n      String newName = dialog.getNewName();\n      copyImpl(elements, newName, targetDirectory, true);\n    }\n  }","id":83334,"modified_method":"public static void doCloneFile(PsiElement element) {\n    PsiDirectory targetDirectory;\n    if (element instanceof PsiDirectory) {\n      targetDirectory = ((PsiDirectory)element).getParentDirectory();\n    }\n    else  {\n      targetDirectory = ((PsiFile)element).getContainingDirectory();\n    }\n\n    PsiElement[] elements = {element};\n    CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(elements, null, element.getProject(), true);\n    dialog.show();\n    if (dialog.isOK()) {\n      String newName = dialog.getNewName();\n      copyImpl(elements, newName, targetDirectory, true, true);\n    }\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void copyAsFiles(PsiElement[] elements, PsiDirectory defaultTargetDirectory, Project project) {\n    PsiDirectory targetDirectory = null;\n    String newName = null;\n\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      targetDirectory = defaultTargetDirectory;\n    }\n    else {\n      CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(elements, defaultTargetDirectory, project, false);\n      dialog.show();\n      if (dialog.isOK()) {\n        newName = elements.length == 1 ? dialog.getNewName() : null;\n        targetDirectory = dialog.getTargetDirectory();\n      }\n    }\n\n    if (targetDirectory != null) {\n      try {\n        for (PsiElement element : elements) {\n          PsiFileSystemItem psiElement = (PsiFileSystemItem)element;\n          if (psiElement.isDirectory()) {\n            MoveFilesOrDirectoriesUtil.checkIfMoveIntoSelf(psiElement, targetDirectory);\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        CommonRefactoringUtil.showErrorHint(project, null, e.getMessage(), CommonBundle.getErrorTitle(), null);\n        return;\n      }\n      copyImpl(elements, newName, targetDirectory, false);\n    }\n  }","id":83335,"modified_method":"public static void copyAsFiles(PsiElement[] elements, PsiDirectory defaultTargetDirectory, Project project) {\n    PsiDirectory targetDirectory = null;\n    String newName = null;\n    boolean openInEditor = true;\n\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      targetDirectory = defaultTargetDirectory;\n    }\n    else {\n      CopyFilesOrDirectoriesDialog dialog = new CopyFilesOrDirectoriesDialog(elements, defaultTargetDirectory, project, false);\n      dialog.show();\n      if (dialog.isOK()) {\n        newName = elements.length == 1 ? dialog.getNewName() : null;\n        targetDirectory = dialog.getTargetDirectory();\n        openInEditor = dialog.openInEditor();\n      }\n    }\n\n    if (targetDirectory != null) {\n      try {\n        for (PsiElement element : elements) {\n          PsiFileSystemItem psiElement = (PsiFileSystemItem)element;\n          if (psiElement.isDirectory()) {\n            MoveFilesOrDirectoriesUtil.checkIfMoveIntoSelf(psiElement, targetDirectory);\n          }\n        }\n      }\n      catch (IncorrectOperationException e) {\n        CommonRefactoringUtil.showErrorHint(project, null, e.getMessage(), CommonBundle.getErrorTitle(), null);\n        return;\n      }\n      copyImpl(elements, newName, targetDirectory, false, openInEditor);\n    }\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   *\n   * @param elements\n   * @param newName can be not null only if elements.length == 1\n   * @param targetDirectory\n   */\n  private static void copyImpl(@NotNull final PsiElement[] elements,\n                               @Nullable final String newName,\n                               @NotNull final PsiDirectory targetDirectory,\n                               final boolean doClone) {\n    if (doClone && elements.length != 1) {\n      throw new IllegalArgumentException(\"invalid number of elements to clone:\" + elements.length);\n    }\n\n    if (newName != null && elements.length != 1) {\n      throw new IllegalArgumentException(\"no new name should be set; number of elements is: \" + elements.length);\n    }\n\n    final Project project = targetDirectory.getProject();\n    Runnable command = new Runnable() {\n      @Override\n      public void run() {\n        final Runnable action = new Runnable() {\n          @Override\n          public void run() {\n            try {\n              PsiFile firstFile = null;\n              final int[] choice = elements.length > 1 || elements[0] instanceof PsiDirectory ? new int[]{-1} : null;\n              for (PsiElement element : elements) {\n                PsiFile f = copyToDirectory((PsiFileSystemItem)element, newName, targetDirectory, choice);\n                if (firstFile == null) {\n                  firstFile = f;\n                }\n              }\n\n              if (firstFile != null) {\n                CopyHandler.updateSelectionInActiveProjectView(firstFile, project, doClone);\n                if (!(firstFile instanceof PsiBinaryFile)){\n                  EditorHelper.openInEditor(firstFile);\n                  ApplicationManager.getApplication().invokeLater(new Runnable() {\n                                  @Override\n                                  public void run() {\n                                    ToolWindowManager.getInstance(project).activateEditorComponent();\n                                  }\n                                });\n                }\n              }\n            }\n            catch (final IncorrectOperationException ex) {\n              ApplicationManager.getApplication().invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                  Messages.showMessageDialog(project, ex.getMessage(), RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n                }\n              });\n            }\n            catch (final IOException ex) {\n              ApplicationManager.getApplication().invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                  Messages.showMessageDialog(project, ex.getMessage(), RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n                }\n              });\n            }\n          }\n        };\n        ApplicationManager.getApplication().runWriteAction(action);\n      }\n    };\n    CommandProcessor.getInstance().executeCommand(project, command, doClone ?\n                                                                    RefactoringBundle.message(\"copy,handler.clone.files.directories\") :\n                                                                    RefactoringBundle.message(\"copy.handler.copy.files.directories\"), null);\n  }","id":83336,"modified_method":"/**\n   *\n   * @param elements\n   * @param newName can be not null only if elements.length == 1\n   * @param targetDirectory\n   * @param openInEditor\n   */\n  private static void copyImpl(@NotNull final PsiElement[] elements,\n                               @Nullable final String newName,\n                               @NotNull final PsiDirectory targetDirectory,\n                               final boolean doClone, \n                               final boolean openInEditor) {\n    if (doClone && elements.length != 1) {\n      throw new IllegalArgumentException(\"invalid number of elements to clone:\" + elements.length);\n    }\n\n    if (newName != null && elements.length != 1) {\n      throw new IllegalArgumentException(\"no new name should be set; number of elements is: \" + elements.length);\n    }\n\n    final Project project = targetDirectory.getProject();\n    Runnable command = new Runnable() {\n      @Override\n      public void run() {\n        final Runnable action = new Runnable() {\n          @Override\n          public void run() {\n            try {\n              PsiFile firstFile = null;\n              final int[] choice = elements.length > 1 || elements[0] instanceof PsiDirectory ? new int[]{-1} : null;\n              for (PsiElement element : elements) {\n                PsiFile f = copyToDirectory((PsiFileSystemItem)element, newName, targetDirectory, choice);\n                if (firstFile == null) {\n                  firstFile = f;\n                }\n              }\n\n              if (firstFile != null) {\n                CopyHandler.updateSelectionInActiveProjectView(firstFile, project, doClone);\n                if (!(firstFile instanceof PsiBinaryFile) && openInEditor){\n                  EditorHelper.openInEditor(firstFile);\n                  ApplicationManager.getApplication().invokeLater(new Runnable() {\n                                  @Override\n                                  public void run() {\n                                    ToolWindowManager.getInstance(project).activateEditorComponent();\n                                  }\n                                });\n                }\n              }\n            }\n            catch (final IncorrectOperationException ex) {\n              ApplicationManager.getApplication().invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                  Messages.showMessageDialog(project, ex.getMessage(), RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n                }\n              });\n            }\n            catch (final IOException ex) {\n              ApplicationManager.getApplication().invokeLater(new Runnable() {\n                @Override\n                public void run() {\n                  Messages.showMessageDialog(project, ex.getMessage(), RefactoringBundle.message(\"error.title\"), Messages.getErrorIcon());\n                }\n              });\n            }\n          }\n        };\n        ApplicationManager.getApplication().runWriteAction(action);\n      }\n    };\n    CommandProcessor.getInstance().executeCommand(project, command, doClone ?\n                                                                    RefactoringBundle.message(\"copy,handler.clone.files.directories\") :\n                                                                    RefactoringBundle.message(\"copy.handler.copy.files.directories\"), null);\n  }","commit_id":"4965dc1be43cca31ef29b8710fe3e5668e3e437b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PhoneGapSettings.State getState() {\n      PhoneGapSettings.State state = new PhoneGapSettings.State();\n      state.executablePath = myExecutablePath.getText();\n      state.repositoriesList = myRepositoryStore.getRepositories();\n      return state;\n    }","id":83337,"modified_method":"private PhoneGapSettings.State getState() {\n      PhoneGapSettings.State state = new PhoneGapSettings.State();\n      state.executablePath = myExecutablePath.getText();\n      state.repositoriesList = myRepositoryStore.getRepositories();\n      state.isExcludePlatformFolder = myExcludePlatformsCheckBox.isSelected();\n      return state;\n    }","commit_id":"3dd302e8570fd19762159a6030d9d8e2de765037","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Nullable\n  @Override\n  public JComponent createComponent() {\n\n    if (myWrapper == null) {\n      myExecutablePath = PhoneGapUtil.createPhoneGapExecutableTextField(myProject);\n      myWorkingDirectory = PhoneGapUtil.createPhoneGapWorkingDirectoryField(myProject);\n      myVersion = new JBLabel();\n      myUIController = new UIController();\n      myRepositoryStore = new RepositoryStore();\n      myUIController.reset(mySettings.getState());\n      phoneGapPluginsView = new PhoneGapPluginsView(myProject);\n      JPanel panel = FormBuilder.createFormBuilder()\n        .addLabeledComponent(PhoneGapBundle.message(\"phonegap.conf.executable.name\"), myExecutablePath)\n        .addLabeledComponent(PhoneGapBundle.message(\"phonegap.conf.version.name\"), myVersion)\n        .addLabeledComponent(PhoneGapBundle.message(\"phonegap.conf.work.dir.name\"), myWorkingDirectory)\n        .addComponent(phoneGapPluginsView.getPanel()).getPanel();\n      myWrapper = new JPanel(new BorderLayout());\n      myWrapper.add(panel, BorderLayout.NORTH);\n\n      setupListeners();\n\n      phoneGapPluginsView\n        .setupService(myExecutablePath.getText(), myWorkingDirectory.getText(), myRepositoryStore, getVersionCallback());\n    }\n\n    return myWrapper;\n  }","id":83338,"modified_method":"@Nullable\n  @Override\n  public JComponent createComponent() {\n\n    if (myWrapper == null) {\n      myExecutablePath = PhoneGapUtil.createPhoneGapExecutableTextField(myProject);\n      myWorkingDirectory = PhoneGapUtil.createPhoneGapWorkingDirectoryField(myProject);\n      myVersion = new JBLabel();\n      myUIController = new UIController();\n      myExcludePlatformsCheckBox = new JCheckBox(PhoneGapBundle.message(\"phonegap.conf.exclude.platforms\"));\n      myRepositoryStore = new RepositoryStore();\n      myUIController.reset(mySettings.getState());\n      phoneGapPluginsView = new PhoneGapPluginsView(myProject);\n      JPanel panel = FormBuilder.createFormBuilder()\n        .addLabeledComponent(PhoneGapBundle.message(\"phonegap.conf.executable.name\"), myExecutablePath)\n        .addLabeledComponent(PhoneGapBundle.message(\"phonegap.conf.version.name\"), myVersion)\n        .addLabeledComponent(PhoneGapBundle.message(\"phonegap.conf.work.dir.name\"), myWorkingDirectory)\n        .addComponent(myExcludePlatformsCheckBox)\n        .addComponent(phoneGapPluginsView.getPanel()).getPanel();\n      myWrapper = new JPanel(new BorderLayout());\n      myWrapper.add(panel, BorderLayout.NORTH);\n\n      setupListeners();\n\n      phoneGapPluginsView\n        .setupService(myExecutablePath.getText(), myWorkingDirectory.getText(), myRepositoryStore, getVersionCallback());\n    }\n\n    return myWrapper;\n  }","commit_id":"3dd302e8570fd19762159a6030d9d8e2de765037","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void reset(PhoneGapSettings.State state) {\n      PhoneGapUtil.setFieldWithHistoryWithBrowseButtonPath(myExecutablePath, state.getExecutablePath());\n      myRepositoryStore.reset(state.repositoriesList);\n    }","id":83339,"modified_method":"public void reset(PhoneGapSettings.State state) {\n      PhoneGapUtil.setFieldWithHistoryWithBrowseButtonPath(myExecutablePath, state.getExecutablePath());\n      myRepositoryStore.reset(state.repositoriesList);\n      myExcludePlatformsCheckBox.setSelected(state.isExcludePlatformFolder);\n    }","commit_id":"3dd302e8570fd19762159a6030d9d8e2de765037","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  /*\n   * All issues - open and closed\n   */\n  public static List<GithubIssue> getIssuesQueried(@NotNull GithubConnection connection,\n                                                   @NotNull String user,\n                                                   @NotNull String repo,\n                                                   @Nullable String query,\n                                                   boolean withClosed) throws IOException {\n    try {\n      String state = withClosed ? \"\" : \" state:open\";\n      query = URLEncoder.encode(\"repo:\" + user + \"/\" + repo + \" \" + query + state, CharsetToolkit.UTF8);\n      String path = \"/search/issues?q=\" + query;\n\n      //TODO: Use bodyHtml for issues - GitHub does not support this feature for SearchApi yet\n      JsonElement result = connection.getRequest(path, ACCEPT_V3_JSON);\n\n      return createDataFromRaw(fromJson(result, GithubIssuesSearchResultRaw.class), GithubIssuesSearchResult.class).getIssues();\n    }\n    catch (GithubConfusingException e) {\n      e.setDetails(\"Can't get queried issues: \" + user + \"/\" + repo + \" - \" + query);\n      throw e;\n    }\n  }","id":83340,"modified_method":"@NotNull\n  /*\n   * All issues - open and closed\n   */\n  public static List<GithubIssue> getIssuesQueried(@NotNull GithubConnection connection,\n                                                   @NotNull String user,\n                                                   @NotNull String repo,\n                                                   @Nullable String assignedUser,\n                                                   @Nullable String query,\n                                                   boolean withClosed) throws IOException {\n    try {\n      String state = withClosed ? \"\" : \" state:open\";\n      String assignee = StringUtil.isEmptyOrSpaces(assignedUser) ? \"\" : \" assignee:\" + assignedUser;\n      query = URLEncoder.encode(\"repo:\" + user + \"/\" + repo + state + assignee + \" \" + query, CharsetToolkit.UTF8);\n      String path = \"/search/issues?q=\" + query;\n\n      //TODO: Use bodyHtml for issues - GitHub does not support this feature for SearchApi yet\n      JsonElement result = connection.getRequest(path, ACCEPT_V3_JSON);\n\n      return createDataFromRaw(fromJson(result, GithubIssuesSearchResultRaw.class), GithubIssuesSearchResult.class).getIssues();\n    }\n    catch (GithubConfusingException e) {\n      e.setDetails(\"Can't get queried issues: \" + user + \"/\" + repo + \" - \" + query);\n      throw e;\n    }\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testQueriedIssues1() throws Exception {\n    List<GithubIssue> result = GithubApiUtil.getIssuesQueried(new GithubConnection(myAuth), myLogin2, REPO_NAME, \"abracadabra\", true);\n    List<Long> issues = ContainerUtil.map(result, new Function<GithubIssue, Long>() {\n      @Override\n      public Long fun(GithubIssue githubIssue) {\n        return githubIssue.getNumber();\n      }\n    });\n\n    List<Long> expected = Arrays.asList(10L, 12L);\n\n    assertTrue(Comparing.haveEqualElements(issues, expected));\n  }","id":83341,"modified_method":"public void testQueriedIssues1() throws Exception {\n    List<GithubIssue> result = GithubApiUtil.getIssuesQueried(new GithubConnection(myAuth), myLogin2, REPO_NAME, null, \"abracadabra\", true);\n    List<Long> issues = ContainerUtil.map(result, new Function<GithubIssue, Long>() {\n      @Override\n      public Long fun(GithubIssue githubIssue) {\n        return githubIssue.getNumber();\n      }\n    });\n\n    List<Long> expected = Arrays.asList(10L, 12L);\n\n    assertTrue(Comparing.haveEqualElements(issues, expected));\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testQueriedIssues3() throws Exception {\n    List<GithubIssue> result = GithubApiUtil.getIssuesQueried(new GithubConnection(myAuth), myLogin2, REPO_NAME, \"abracadabra\", false);\n    List<Long> issues = ContainerUtil.map(result, new Function<GithubIssue, Long>() {\n      @Override\n      public Long fun(GithubIssue githubIssue) {\n        return githubIssue.getNumber();\n      }\n    });\n\n    List<Long> expected = Arrays.asList(10L);\n\n    assertTrue(Comparing.haveEqualElements(issues, expected));\n  }","id":83342,"modified_method":"public void testQueriedIssues3() throws Exception {\n    List<GithubIssue> result = GithubApiUtil.getIssuesQueried(new GithubConnection(myAuth), myLogin2, REPO_NAME, null, \"abracadabra\", false);\n    List<Long> issues = ContainerUtil.map(result, new Function<GithubIssue, Long>() {\n      @Override\n      public Long fun(GithubIssue githubIssue) {\n        return githubIssue.getNumber();\n      }\n    });\n\n    List<Long> expected = Arrays.asList(10L);\n\n    assertTrue(Comparing.haveEqualElements(issues, expected));\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testQueriedIssues2() throws Exception {\n    List<GithubIssue> result = GithubApiUtil.getIssuesQueried(new GithubConnection(myAuth), myLogin2, REPO_NAME, \"commentary\", true);\n    List<Long> issues = ContainerUtil.map(result, new Function<GithubIssue, Long>() {\n      @Override\n      public Long fun(GithubIssue githubIssue) {\n        return githubIssue.getNumber();\n      }\n    });\n\n    List<Long> expected = Arrays.asList(11L);\n\n    assertTrue(Comparing.haveEqualElements(issues, expected));\n  }","id":83343,"modified_method":"public void testQueriedIssues2() throws Exception {\n    List<GithubIssue> result = GithubApiUtil.getIssuesQueried(new GithubConnection(myAuth), myLogin2, REPO_NAME, null, \"commentary\", true);\n    List<Long> issues = ContainerUtil.map(result, new Function<GithubIssue, Long>() {\n      @Override\n      public Long fun(GithubIssue githubIssue) {\n        return githubIssue.getNumber();\n      }\n    });\n\n    List<Long> expected = Arrays.asList(11L);\n\n    assertTrue(Comparing.haveEqualElements(issues, expected));\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Task[] getIssues(@Nullable String query, int max, boolean withClosed) throws Exception {\n    GithubConnection connection = getConnection();\n\n    try {\n      List<GithubIssue> issues;\n      if (StringUtil.isEmptyOrSpaces(query)) {\n        if (StringUtil.isEmptyOrSpaces(myUser)) {\n          myUser = GithubApiUtil.getCurrentUser(connection).getLogin();\n        }\n        issues = GithubApiUtil.getIssuesAssigned(connection, getRepoAuthor(), getRepoName(), myUser, max, withClosed);\n      }\n      else {\n        issues = GithubApiUtil.getIssuesQueried(connection, getRepoAuthor(), getRepoName(), query, withClosed);\n      }\n\n      return ContainerUtil.map2Array(issues, Task.class, new Function<GithubIssue, Task>() {\n        @Override\n        public Task fun(GithubIssue issue) {\n          return createTask(issue);\n        }\n      });\n    }\n    finally {\n      connection.close();\n    }\n  }","id":83344,"modified_method":"@NotNull\n  private Task[] getIssues(@Nullable String query, int max, boolean withClosed) throws Exception {\n    GithubConnection connection = getConnection();\n\n    try {\n      String assigned = null;\n      if (myAssignedIssuesOnly) {\n        if (StringUtil.isEmptyOrSpaces(myUser)) {\n          myUser = GithubApiUtil.getCurrentUser(connection).getLogin();\n        }\n        assigned = myUser;\n      }\n\n      List<GithubIssue> issues;\n      if (StringUtil.isEmptyOrSpaces(query)) {\n        // search queries have way smaller request number limit\n        issues =\n          GithubApiUtil.getIssuesAssigned(connection, getRepoAuthor(), getRepoName(), assigned, max, withClosed);\n      }\n      else {\n        issues =\n          GithubApiUtil.getIssuesQueried(connection, getRepoAuthor(), getRepoName(), assigned, query, withClosed);\n      }\n\n      return ContainerUtil.map2Array(issues, Task.class, new Function<GithubIssue, Task>() {\n        @Override\n        public Task fun(GithubIssue issue) {\n          return createTask(issue);\n        }\n      });\n    }\n    finally {\n      connection.close();\n    }\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GithubRepository(GithubRepository other) {\n    super(other);\n    setRepoName(other.myRepoName);\n    setRepoAuthor(other.myRepoAuthor);\n    setToken(other.myToken);\n  }","id":83345,"modified_method":"public GithubRepository(GithubRepository other) {\n    super(other);\n    setRepoName(other.myRepoName);\n    setRepoAuthor(other.myRepoAuthor);\n    setToken(other.myToken);\n    setAssignedIssuesOnly(other.myAssignedIssuesOnly);\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (!super.equals(o)) return false;\n    if (!(o instanceof GithubRepository)) return false;\n\n    GithubRepository that = (GithubRepository)o;\n    if (!Comparing.equal(getRepoAuthor(), that.getRepoAuthor())) return false;\n    if (!Comparing.equal(getRepoName(), that.getRepoName())) return false;\n    if (!Comparing.equal(getToken(), that.getToken())) return false;\n\n    return true;\n  }","id":83346,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (!super.equals(o)) return false;\n    if (!(o instanceof GithubRepository)) return false;\n\n    GithubRepository that = (GithubRepository)o;\n    if (!Comparing.equal(getRepoAuthor(), that.getRepoAuthor())) return false;\n    if (!Comparing.equal(getRepoName(), that.getRepoName())) return false;\n    if (!Comparing.equal(getToken(), that.getToken())) return false;\n    if (!Comparing.equal(isAssignedIssuesOnly(), that.isAssignedIssuesOnly())) return false;\n\n    return true;\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public CancellableConnection createCancellableConnection() {\n    return new CancellableConnection() {\n      private final GithubConnection myConnection = new GithubConnection(getAuthData(), false);\n\n      @Override\n      protected void doTest() throws Exception {\n        try {\n          GithubApiUtil.getIssuesQueried(myConnection, getRepoAuthor(), getRepoName(), \"\", false);\n        }\n        catch (GithubOperationCanceledException ignore) {\n        }\n      }\n\n      @Override\n      public void cancel() {\n        myConnection.abort();\n      }\n    };\n  }","id":83347,"modified_method":"@NotNull\n  @Override\n  public CancellableConnection createCancellableConnection() {\n    return new CancellableConnection() {\n      private final GithubConnection myConnection = new GithubConnection(getAuthData(), false);\n\n      @Override\n      protected void doTest() throws Exception {\n        try {\n          GithubApiUtil.getIssuesQueried(myConnection, getRepoAuthor(), getRepoName(), null, null, false);\n        }\n        catch (GithubOperationCanceledException ignore) {\n        }\n      }\n\n      @Override\n      public void cancel() {\n        myConnection.abort();\n      }\n    };\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GithubRepositoryEditor(final Project project, final GithubRepository repository, Consumer<GithubRepository> changeListener) {\n    super(project, repository, changeListener);\n    myUrlLabel.setVisible(false);\n    myUsernameLabel.setVisible(false);\n    myUserNameText.setVisible(false);\n    myPasswordLabel.setVisible(false);\n    myPasswordText.setVisible(false);\n    myUseHttpAuthenticationCheckBox.setVisible(false);\n\n    myRepoAuthor.setText(repository.getRepoAuthor());\n    myRepoName.setText(repository.getRepoName());\n    myToken.setText(repository.getToken());\n\n    DocumentListener buttonUpdater = new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        updateTokenButton();\n      }\n    };\n\n    myURLText.getDocument().addDocumentListener(buttonUpdater);\n    myRepoAuthor.getDocument().addDocumentListener(buttonUpdater);\n    myRepoName.getDocument().addDocumentListener(buttonUpdater);\n  }","id":83348,"modified_method":"public GithubRepositoryEditor(final Project project, final GithubRepository repository, Consumer<GithubRepository> changeListener) {\n    super(project, repository, changeListener);\n    myUrlLabel.setVisible(false);\n    myUsernameLabel.setVisible(false);\n    myUserNameText.setVisible(false);\n    myPasswordLabel.setVisible(false);\n    myPasswordText.setVisible(false);\n    myUseHttpAuthenticationCheckBox.setVisible(false);\n\n    myRepoAuthor.setText(repository.getRepoAuthor());\n    myRepoName.setText(repository.getRepoName());\n    myToken.setText(repository.getToken());\n    myToken.setText(repository.getToken());\n    myAssignedIssuesOnly.setSelected(repository.isAssignedIssuesOnly());\n\n    DocumentListener buttonUpdater = new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        updateTokenButton();\n      }\n    };\n\n    myURLText.getDocument().addDocumentListener(buttonUpdater);\n    myRepoAuthor.getDocument().addDocumentListener(buttonUpdater);\n    myRepoName.getDocument().addDocumentListener(buttonUpdater);\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  protected JComponent createCustomPanel() {\n    myHostLabel = new JBLabel(\"Host:\", SwingConstants.RIGHT);\n\n    JPanel myHostPanel = new JPanel(new BorderLayout(5, 0));\n    myHostPanel.add(myURLText, BorderLayout.CENTER);\n    myHostPanel.add(myShareUrlCheckBox, BorderLayout.EAST);\n\n    myRepositoryLabel = new JBLabel(\"Repository:\", SwingConstants.RIGHT);\n    myRepoAuthor = new MyTextField(\"Repository Owner\");\n    myRepoName = new MyTextField(\"Repository Name\");\n    myRepoAuthor.setPreferredSize(\"SomelongNickname\");\n    myRepoName.setPreferredSize(\"SomelongReponame-with-suffixes\");\n\n    JPanel myRepoPanel = new JPanel(new GridBagLayout());\n    GridBag bag = new GridBag().setDefaultWeightX(1).setDefaultFill(GridBagConstraints.HORIZONTAL);\n    myRepoPanel.add(myRepoAuthor, bag.nextLine().next());\n    myRepoPanel.add(new JLabel(\"/\"), bag.next().fillCellNone().insets(0, 5, 0, 5).weightx(0));\n    myRepoPanel.add(myRepoName, bag.next());\n\n    myTokenLabel = new JBLabel(\"API Token:\", SwingConstants.RIGHT);\n    myToken = new MyTextField(\"OAuth2 token\");\n    myTokenButton = new JButton(\"Create API token\");\n    myTokenButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        generateToken();\n        doApply();\n      }\n    });\n\n    JPanel myTokenPanel = new JPanel();\n    myTokenPanel.setLayout(new BorderLayout(5, 5));\n    myTokenPanel.add(myToken, BorderLayout.CENTER);\n    myTokenPanel.add(myTokenButton, BorderLayout.EAST);\n\n    installListener(myRepoAuthor);\n    installListener(myRepoName);\n    installListener(myToken);\n\n    return FormBuilder.createFormBuilder().setAlignLabelOnRight(true).addLabeledComponent(myHostLabel, myHostPanel)\n      .addLabeledComponent(myRepositoryLabel, myRepoPanel).addLabeledComponent(myTokenLabel, myTokenPanel).getPanel();\n  }","id":83349,"modified_method":"@Nullable\n  @Override\n  protected JComponent createCustomPanel() {\n    myHostLabel = new JBLabel(\"Host:\", SwingConstants.RIGHT);\n\n    JPanel myHostPanel = new JPanel(new BorderLayout(5, 0));\n    myHostPanel.add(myURLText, BorderLayout.CENTER);\n    myHostPanel.add(myShareUrlCheckBox, BorderLayout.EAST);\n\n    myRepositoryLabel = new JBLabel(\"Repository:\", SwingConstants.RIGHT);\n    myRepoAuthor = new MyTextField(\"Repository Owner\");\n    myRepoName = new MyTextField(\"Repository Name\");\n    myRepoAuthor.setPreferredSize(\"SomelongNickname\");\n    myRepoName.setPreferredSize(\"SomelongReponame-with-suffixes\");\n\n    JPanel myRepoPanel = new JPanel(new GridBagLayout());\n    GridBag bag = new GridBag().setDefaultWeightX(1).setDefaultFill(GridBagConstraints.HORIZONTAL);\n    myRepoPanel.add(myRepoAuthor, bag.nextLine().next());\n    myRepoPanel.add(new JLabel(\"/\"), bag.next().fillCellNone().insets(0, 5, 0, 5).weightx(0));\n    myRepoPanel.add(myRepoName, bag.next());\n\n    myTokenLabel = new JBLabel(\"API Token:\", SwingConstants.RIGHT);\n    myToken = new MyTextField(\"OAuth2 token\");\n    myTokenButton = new JButton(\"Create API token\");\n    myTokenButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        generateToken();\n        doApply();\n      }\n    });\n\n    JPanel myTokenPanel = new JPanel();\n    myTokenPanel.setLayout(new BorderLayout(5, 5));\n    myTokenPanel.add(myToken, BorderLayout.CENTER);\n    myTokenPanel.add(myTokenButton, BorderLayout.EAST);\n\n    myAssignedIssuesOnly = new JBCheckBox(\"Assigned Issues Only\");\n\n    installListener(myRepoAuthor);\n    installListener(myRepoName);\n    installListener(myToken);\n    installListener(myAssignedIssuesOnly);\n\n    return FormBuilder.createFormBuilder()\n      .setAlignLabelOnRight(true)\n      .addLabeledComponent(myHostLabel, myHostPanel)\n      .addLabeledComponent(myRepositoryLabel, myRepoPanel)\n      .addLabeledComponent(myTokenLabel, myTokenPanel)\n      .addComponent(myAssignedIssuesOnly)\n      .getPanel();\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setAnchor(@Nullable final JComponent anchor) {\n    super.setAnchor(anchor);\n    myHostLabel.setAnchor(anchor);\n    myRepositoryLabel.setAnchor(anchor);\n    myTokenLabel.setAnchor(anchor);\n  }","id":83350,"modified_method":"@Override\n  public void setAnchor(@Nullable final JComponent anchor) {\n    super.setAnchor(anchor);\n    myHostLabel.setAnchor(anchor);\n    myRepositoryLabel.setAnchor(anchor);\n    myTokenLabel.setAnchor(anchor);\n    myAssignedIssuesOnly.setAnchor(anchor);\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void apply() {\n    myRepository.setRepoName(getRepoName());\n    myRepository.setRepoAuthor(getRepoAuthor());\n    myRepository.setToken(getToken());\n    super.apply();\n  }","id":83351,"modified_method":"@Override\n  public void apply() {\n    myRepository.setRepoName(getRepoName());\n    myRepository.setRepoAuthor(getRepoAuthor());\n    myRepository.setToken(getToken());\n    myRepository.setAssignedIssuesOnly(isAssignedIssuesOnly());\n    super.apply();\n  }","commit_id":"27f9596267554246804e27838337eb602ade4531","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Class<DatumWriter<?>> load(CacheKey key) throws Exception {\n      ClassDefinition classDef = new DatumWriterGenerator().generate(key.getType(), key.getSchema());\n\n      ClassLoader typeClassloader = key.getType().getRawType().getClassLoader();\n      ByteCodeClassLoader classloader = classloaders.get(typeClassloader);\n      if (classloader == null) {\n        classloader = new ByteCodeClassLoader(typeClassloader == null ? Thread.currentThread().getContextClassLoader()\n                                                : typeClassloader);\n        classloaders.put(typeClassloader, classloader);\n      }\n\n      return (Class<DatumWriter<?>>) classloader.addClass(classDef).loadClass(classDef.getClassName());\n    }","id":83352,"modified_method":"@Override\n    public Class<DatumWriter<?>> load(CacheKey key) throws Exception {\n      ClassDefinition classDef = new DatumWriterGenerator().generate(key.getType(), key.getSchema());\n\n      ClassLoader typeClassloader = getClassLoader(key.getType());\n      ByteCodeClassLoader classloader = classloaders.get(typeClassloader);\n      if (classloader == null) {\n        classloader = new ByteCodeClassLoader(typeClassloader);\n        classloaders.put(key.getType(), classloader);\n      }\n\n      return (Class<DatumWriter<?>>) classloader.addClass(classDef).loadClass(classDef.getClassName());\n    }","commit_id":"1890e4b270fb0448ce16b57d0049261dae9096c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void removeApplication(AuthToken token, ProgramId identifier) throws AppFabricServiceException {\n    try {\n      Preconditions.checkNotNull(identifier, \"No application id provided.\");\n\n      Id.Account accountId = Id.Account.from(identifier.getAccountId());\n      final Id.Application appId = Id.Application.from(accountId, identifier.getApplicationId());\n\n      // Check if all are stopped.\n      Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.getApplication().equals(appId);\n        }\n      }, Type.values()), \"There are program still running for application \" + appId.getId());\n\n      Location appArchive = store.getApplicationArchiveLocation(appId);\n      Preconditions.checkNotNull(appArchive, \"Could not find the location of application\", appId.getId());\n      appArchive.delete();\n      deleteMetrics(identifier.getAccountId(), identifier.getApplicationId());\n      store.removeApplication(appId);\n    } catch (Throwable  throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(\"Fail to delete program \" + throwable.getMessage());\n    }\n  }","id":83353,"modified_method":"@Override\n  public void removeApplication(AuthToken token, ProgramId identifier) throws AppFabricServiceException {\n    try {\n      Preconditions.checkNotNull(identifier, \"No application id provided.\");\n\n      Id.Account accountId = Id.Account.from(identifier.getAccountId());\n      final Id.Application appId = Id.Application.from(accountId, identifier.getApplicationId());\n\n      // Check if all are stopped.\n      checkAnyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.getApplication().equals(appId);\n        }\n      }, Type.values());\n\n      Location appArchive = store.getApplicationArchiveLocation(appId);\n      Preconditions.checkNotNull(appArchive, \"Could not find the location of application\", appId.getId());\n      appArchive.delete();\n      deleteMetrics(identifier.getAccountId(), identifier.getApplicationId());\n      store.removeApplication(appId);\n    } catch (Throwable  throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(\"Fail to delete program \" + throwable.getMessage());\n    }\n  }","commit_id":"1890e4b270fb0448ce16b57d0049261dae9096c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void reset(AuthToken token, String account) throws AppFabricServiceException {\n    final Id.Account accountId;\n    try {\n      Preconditions.checkNotNull(account);\n      accountId = Id.Account.from(account);\n\n      // Check if any program is still running\n      Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.getAccountId().equals(accountId.getId());\n        }\n      }, Type.values()), \"There are programs still running on the Reactor. Please stop them first.\");\n\n      deleteMetrics(account);\n      // delete all meta data\n      store.removeAll(accountId);\n      // delete queues data\n      queueAdmin.dropAll();\n\n      LOG.info(\"Deleting all data for account '\" + account + \"'.\");\n      dataSetAccessor.dropAll(DataSetAccessor.Namespace.USER);\n      // NOTE: there could be services running at the moment that rely on the system datasets to be available\n      dataSetAccessor.truncateAll(DataSetAccessor.Namespace.SYSTEM);\n\n      LOG.info(\"All data for account '\" + account + \"' deleted.\");\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(String.format(UserMessages.getMessage(UserErrors.RESET_FAIL),\n                                                        throwable.getMessage()));\n    }\n  }","id":83354,"modified_method":"@Override\n  public void reset(AuthToken token, String account) throws AppFabricServiceException {\n    final Id.Account accountId;\n    try {\n      Preconditions.checkNotNull(account);\n      accountId = Id.Account.from(account);\n\n      // Check if any program is still running\n      checkAnyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.getAccountId().equals(accountId.getId());\n        }\n      }, Type.values());\n\n      deleteMetrics(account);\n      // delete all meta data\n      store.removeAll(accountId);\n      // delete queues data\n      queueAdmin.dropAll();\n\n      LOG.info(\"Deleting all data for account '\" + account + \"'.\");\n      dataSetAccessor.dropAll(DataSetAccessor.Namespace.USER);\n      // NOTE: there could be services running at the moment that rely on the system datasets to be available\n      dataSetAccessor.truncateAll(DataSetAccessor.Namespace.SYSTEM);\n\n      LOG.info(\"All data for account '\" + account + \"' deleted.\");\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(String.format(UserMessages.getMessage(UserErrors.RESET_FAIL),\n                                                        throwable.getMessage()));\n    }\n  }","commit_id":"1890e4b270fb0448ce16b57d0049261dae9096c1","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Check if any program that satisfy the given {@link Predicate} is running\n   * @param predicate Get call on each running {@link Id.Program}.\n   * @param types Types of program to check\n   * @return true if any of the running program satisfy the predicate, false otherwise.\n   */\n  private boolean anyRunning(Predicate<Id.Program> predicate, Type...types) {\n    for (Type type : types) {\n      for (Map.Entry<RunId, ProgramRuntimeService.RuntimeInfo> entry :  runtimeService.list(type).entrySet()) {\n        if (predicate.apply(entry.getValue().getProgramId())) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":83355,"modified_method":"/**\n   * Check if any program that satisfy the given {@link Predicate} is running\n   * @param predicate Get call on each running {@link Id.Program}.\n   * @param types Types of program to check\n   * @throws IllegalStateException if a program is running as defined by the predicate.\n   */\n  private void checkAnyRunning(Predicate<Id.Program> predicate, Type... types) {\n    for (Type type : types) {\n      for (Map.Entry<RunId, ProgramRuntimeService.RuntimeInfo> entry :  runtimeService.list(type).entrySet()) {\n        Id.Program programId = entry.getValue().getProgramId();\n        if (predicate.apply(programId)) {\n          throw new IllegalStateException(String.format(\"Program still running: %s %s %s %s\",\n                                                        programId.getApplicationId(), type, programId.getId(),\n                                                        entry.getValue().getController().getRunId()));\n        }\n      }\n    }\n  }","commit_id":"1890e4b270fb0448ce16b57d0049261dae9096c1","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Deletes a program specified by {@code ProgramId}.\n   *\n   * @param identifier of a flow.\n   * @throws AppFabricServiceException when there is an issue deactivating the flow.\n   */\n  @Override\n  public void remove(AuthToken token, ProgramId identifier) throws AppFabricServiceException {\n    try {\n      Preconditions.checkNotNull(identifier, \"No application id provided.\");\n\n\n      Id.Program programId = Id.Program.from(identifier.getAccountId(),\n                                             identifier.getApplicationId(),\n                                             identifier.getFlowId());\n\n      // Make sure it is not running\n      Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.equals(programId);\n        }\n      }, Type.values()), \"Program still running for application %s, %s.\",\n                               programId.getApplication(), programId.getId());\n\n\n      Type programType = entityTypeToType(identifier);\n      for (Map.Entry<RunId, ProgramRuntimeService.RuntimeInfo> entry : runtimeService.list(programType).entrySet()) {\n        Preconditions.checkState(!programId.equals(entry.getValue().getProgramId()),\n                                 \"Program still running: application=%s, type=%s, program=%s\",\n                                 programId.getApplication(), programType, programId.getId());\n      }\n      // Delete the program from store.\n      store.remove(programId);\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(\"Fail to delete program \" + throwable.getMessage());\n    }\n  }","id":83356,"modified_method":"/**\n   * Deletes a program specified by {@code ProgramId}.\n   *\n   * @param identifier of a flow.\n   * @throws AppFabricServiceException when there is an issue deactivating the flow.\n   */\n  @Override\n  public void remove(AuthToken token, ProgramId identifier) throws AppFabricServiceException {\n    try {\n      Preconditions.checkNotNull(identifier, \"No application id provided.\");\n\n\n      Id.Program programId = Id.Program.from(identifier.getAccountId(),\n                                             identifier.getApplicationId(),\n                                             identifier.getFlowId());\n\n      // Make sure it is not running\n      checkAnyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.equals(programId);\n        }\n      }, Type.values());\n\n      Type programType = entityTypeToType(identifier);\n      for (Map.Entry<RunId, ProgramRuntimeService.RuntimeInfo> entry : runtimeService.list(programType).entrySet()) {\n        Preconditions.checkState(!programId.equals(entry.getValue().getProgramId()),\n                                 \"Program still running: application=%s, type=%s, program=%s\",\n                                 programId.getApplication(), programType, programId.getId());\n      }\n      // Delete the program from store.\n      store.remove(programId);\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(\"Fail to delete program \" + throwable.getMessage());\n    }\n  }","commit_id":"1890e4b270fb0448ce16b57d0049261dae9096c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGenerator() throws InterruptedException, IOException, TimeoutException {\n    ApplicationManager applicationManager = deployApplication(GenSinkApp2.class);\n\n    try {\n      applicationManager.startFlow(\"GenSinkFlow\");\n\n      // Check the flowlet metrics\n      RuntimeMetrics genMetrics = RuntimeStats.getFlowletMetrics(\"GenSinkApp\",\n                                                                 \"GenSinkFlow\",\n                                                                 \"GenFlowlet\");\n\n      RuntimeMetrics sinkMetrics = RuntimeStats.getFlowletMetrics(\"GenSinkApp\",\n                                                                  \"GenSinkFlow\",\n                                                                  \"SinkFlowlet\");\n      sinkMetrics.waitForProcessed(99, 5, TimeUnit.SECONDS);\n      Assert.assertEquals(0L, sinkMetrics.getException());\n\n      Assert.assertEquals(1L, genMetrics.getException());\n\n    } finally {\n      applicationManager.stopAll();\n      clear();\n    }\n  }","id":83357,"modified_method":"@Test\n  public void testGenerator() throws InterruptedException, IOException, TimeoutException {\n    ApplicationManager applicationManager = deployApplication(GenSinkApp2.class);\n\n    try {\n      applicationManager.startFlow(\"GenSinkFlow\");\n\n      // Check the flowlet metrics\n      RuntimeMetrics genMetrics = RuntimeStats.getFlowletMetrics(\"GenSinkApp\",\n                                                                 \"GenSinkFlow\",\n                                                                 \"GenFlowlet\");\n\n      RuntimeMetrics sinkMetrics = RuntimeStats.getFlowletMetrics(\"GenSinkApp\",\n                                                                  \"GenSinkFlow\",\n                                                                  \"SinkFlowlet\");\n      sinkMetrics.waitForProcessed(99, 5, TimeUnit.SECONDS);\n      Assert.assertEquals(0L, sinkMetrics.getException());\n\n      Assert.assertEquals(1L, genMetrics.getException());\n\n    } finally {\n      applicationManager.stopAll();\n      TimeUnit.SECONDS.sleep(1);\n      clear();\n    }\n  }","commit_id":"1890e4b270fb0448ce16b57d0049261dae9096c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 360000)\n  public void testApp() throws InterruptedException, IOException, TimeoutException, OperationException {\n    ApplicationManager applicationManager = deployApplication(WordCountApp2.class);\n\n    try {\n      applicationManager.startFlow(\"WordCountFlow\");\n\n      // Send some inputs to streams\n      StreamWriter streamWriter = applicationManager.getStreamWriter(\"text\");\n      for (int i = 0; i < 100; i++) {\n        streamWriter.send(ImmutableMap.of(\"title\", \"title \" + i), \"testing message \" + i);\n      }\n\n      // Check the flowlet metrics\n      RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WordCountApp\",\n                                                                     \"WordCountFlow\",\n                                                                     \"CountByField\");\n      flowletMetrics.waitForProcessed(500, 5, TimeUnit.SECONDS);\n      Assert.assertEquals(0L, flowletMetrics.getException());\n\n      // Query the result\n      ProcedureManager procedureManager = applicationManager.startProcedure(\"WordFrequency\");\n      ProcedureClient procedureClient = procedureManager.getClient();\n\n      // Verify the query result\n      Type resultType = new TypeToken<Map<String, Long>>(){}.getType();\n      Gson gson = new Gson();\n      Map<String, Long> result = gson.fromJson(procedureClient.query(\"wordfreq\",\n                                                                     ImmutableMap.of(\"word\", \"text:testing\")),\n                                               resultType);\n\n      Assert.assertEquals(100L, result.get(\"text:testing\").longValue());\n\n      // Verify by looking into dataset\n      MyKeyValueTable mydataset = applicationManager.getDataSet(\"mydataset\");\n\n      Assert.assertEquals(100L, Longs.fromByteArray(mydataset.read(\"title:title\".getBytes(Charsets.UTF_8))));\n\n      // check the metrics\n      RuntimeMetrics procedureMetrics = RuntimeStats.getProcedureMetrics(\"WordCountApp\", \"WordFrequency\");\n      procedureMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n      Assert.assertEquals(0L, procedureMetrics.getException());\n\n      // Run mapreduce job\n      MapReduceManager mrManager = applicationManager.startMapReduce(\"countTotal\");\n      mrManager.waitForFinish(120L, TimeUnit.SECONDS);\n\n      long totalCount = Long.valueOf(procedureClient.query(\"total\", Collections.<String, String>emptyMap()));\n      // every event has 5 tokens\n      Assert.assertEquals(5 * 100L, totalCount);\n\n    } finally {\n      applicationManager.stopAll();\n      clear();\n    }\n  }","id":83358,"modified_method":"@Test(timeout = 360000)\n  public void testApp() throws InterruptedException, IOException, TimeoutException, OperationException {\n    ApplicationManager applicationManager = deployApplication(WordCountApp2.class);\n\n    try {\n      applicationManager.startFlow(\"WordCountFlow\");\n\n      // Send some inputs to streams\n      StreamWriter streamWriter = applicationManager.getStreamWriter(\"text\");\n      for (int i = 0; i < 100; i++) {\n        streamWriter.send(ImmutableMap.of(\"title\", \"title \" + i), \"testing message \" + i);\n      }\n\n      // Check the flowlet metrics\n      RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WordCountApp\",\n                                                                     \"WordCountFlow\",\n                                                                     \"CountByField\");\n      flowletMetrics.waitForProcessed(500, 5, TimeUnit.SECONDS);\n      Assert.assertEquals(0L, flowletMetrics.getException());\n\n      // Query the result\n      ProcedureManager procedureManager = applicationManager.startProcedure(\"WordFrequency\");\n      ProcedureClient procedureClient = procedureManager.getClient();\n\n      // Verify the query result\n      Type resultType = new TypeToken<Map<String, Long>>(){}.getType();\n      Gson gson = new Gson();\n      Map<String, Long> result = gson.fromJson(procedureClient.query(\"wordfreq\",\n                                                                     ImmutableMap.of(\"word\", \"text:testing\")),\n                                               resultType);\n\n      Assert.assertEquals(100L, result.get(\"text:testing\").longValue());\n\n      // Verify by looking into dataset\n      MyKeyValueTable mydataset = applicationManager.getDataSet(\"mydataset\");\n\n      Assert.assertEquals(100L, Longs.fromByteArray(mydataset.read(\"title:title\".getBytes(Charsets.UTF_8))));\n\n      // check the metrics\n      RuntimeMetrics procedureMetrics = RuntimeStats.getProcedureMetrics(\"WordCountApp\", \"WordFrequency\");\n      procedureMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n      Assert.assertEquals(0L, procedureMetrics.getException());\n\n      // Run mapreduce job\n      MapReduceManager mrManager = applicationManager.startMapReduce(\"countTotal\");\n      mrManager.waitForFinish(120L, TimeUnit.SECONDS);\n\n      long totalCount = Long.valueOf(procedureClient.query(\"total\", Collections.<String, String>emptyMap()));\n      // every event has 5 tokens\n      Assert.assertEquals(5 * 100L, totalCount);\n\n    } finally {\n      applicationManager.stopAll();\n      TimeUnit.SECONDS.sleep(1);\n      clear();\n    }\n  }","commit_id":"1890e4b270fb0448ce16b57d0049261dae9096c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 240000)\n  public void testMultiInput() throws InterruptedException, IOException, TimeoutException {\n    ApplicationManager applicationManager = deployApplication(JoinMultiStreamApp.class);\n    try {\n      applicationManager.startFlow(\"JoinMultiFlow\");\n\n      StreamWriter s1 = applicationManager.getStreamWriter(\"s1\");\n      StreamWriter s2 = applicationManager.getStreamWriter(\"s2\");\n      StreamWriter s3 = applicationManager.getStreamWriter(\"s3\");\n\n      s1.send(\"testing 1\");\n      s2.send(\"testing 2\");\n      s3.send(\"testing 3\");\n\n      RuntimeMetrics terminalMetrics = RuntimeStats.getFlowletMetrics(\"JoinMulti\", \"JoinMultiFlow\", \"Terminal\");\n\n      terminalMetrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n      TimeUnit.SECONDS.sleep(1);\n\n      ProcedureManager queryManager = applicationManager.startProcedure(\"Query\");\n      Gson gson = new Gson();\n\n      ProcedureClient client = queryManager.getClient();\n      Assert.assertEquals(\"testing 1\",\n                          gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input1\")), String.class));\n      Assert.assertEquals(\"testing 2\",\n                          gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input2\")), String.class));\n      Assert.assertEquals(\"testing 3\",\n                          gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input3\")), String.class));\n\n    } finally {\n      applicationManager.stopAll();\n      clear();\n    }\n  }","id":83359,"modified_method":"@Test(timeout = 240000)\n  public void testMultiInput() throws InterruptedException, IOException, TimeoutException {\n    ApplicationManager applicationManager = deployApplication(JoinMultiStreamApp.class);\n    try {\n      applicationManager.startFlow(\"JoinMultiFlow\");\n\n      StreamWriter s1 = applicationManager.getStreamWriter(\"s1\");\n      StreamWriter s2 = applicationManager.getStreamWriter(\"s2\");\n      StreamWriter s3 = applicationManager.getStreamWriter(\"s3\");\n\n      s1.send(\"testing 1\");\n      s2.send(\"testing 2\");\n      s3.send(\"testing 3\");\n\n      RuntimeMetrics terminalMetrics = RuntimeStats.getFlowletMetrics(\"JoinMulti\", \"JoinMultiFlow\", \"Terminal\");\n\n      terminalMetrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n      TimeUnit.SECONDS.sleep(1);\n\n      ProcedureManager queryManager = applicationManager.startProcedure(\"Query\");\n      Gson gson = new Gson();\n\n      ProcedureClient client = queryManager.getClient();\n      Assert.assertEquals(\"testing 1\",\n                          gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input1\")), String.class));\n      Assert.assertEquals(\"testing 2\",\n                          gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input2\")), String.class));\n      Assert.assertEquals(\"testing 3\",\n                          gson.fromJson(client.query(\"get\", ImmutableMap.of(\"key\", \"input3\")), String.class));\n\n    } finally {\n      applicationManager.stopAll();\n      // Sleep a second before clear. There is a race between removal of RuntimeInfo\n      // in the AbstractProgramRuntimeService class and the clear() method, which loops all RuntimeInfo.\n      // The reason for the race is because removal is done through callback.\n      TimeUnit.SECONDS.sleep(1);\n      clear();\n    }\n  }","commit_id":"1890e4b270fb0448ce16b57d0049261dae9096c1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (!GithubUtil.testGitExecutable(project)){\n      return;\n    }\n    final VirtualFile root = project.getBaseDir();\n    // Check if git is already initialized and presence of remote branch\n    final boolean gitDetected = GitUtil.isUnderGit(root);\n    if (gitDetected) {\n      try {\n        final List<GitDeprecatedRemote> gitRemotes = GitDeprecatedRemote.list(project, root);\n        if (!gitRemotes.isEmpty()) {\n          Messages.showErrorDialog(project, \"Project is already under git with configured remote\", \"Cannot create new GitHub repository\");\n          return;\n        }\n      }\n      catch (VcsException e2) {\n        Messages.showErrorDialog(project, \"Error happened during git operation: \" + e2.getMessage(), \"Cannot create new GitHub repository\");\n        return;\n      }\n    }\n\n    BasicAction.saveAll();\n    final List<RepositoryInfo> availableRepos = GithubUtil.getAvailableRepos(project, true);\n    if (availableRepos == null){\n      return;\n    }\n    final HashSet<String> names = new HashSet<String>();\n    for (RepositoryInfo info : availableRepos) {\n      names.add(info.getName());\n    }\n\n    final GithubSettings settings = GithubSettings.getInstance();\n    final String password = settings.getPassword();\n    final boolean privateRepoAllowed;\n    try {\n      privateRepoAllowed = GithubUtil.accessToGithubWithModalProgress(project, new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          ProgressManager.getInstance().getProgressIndicator().setText(\"Trying to login to GitHub\");\n          return GithubUtil.isPrivateRepoAllowed(settings.getHost(), settings.getLogin(), password);\n        }\n      });\n    }\n    catch (GithubUtil.CancelledException ex) {\n      return;\n    }\n    final GithubShareDialog shareDialog = new GithubShareDialog(project, names, privateRepoAllowed);\n    shareDialog.show();\n    if (!shareDialog.isOK()) {\n      return;\n    }\n\n    final boolean isPrivate = shareDialog.isPrivate();\n    final String name = shareDialog.getRepositoryName();\n    final String description = shareDialog.getDescription();\n    try {\n      LOG.info(\"Creating GitHub repository\");\n      final String escapedDescription = JDOMUtil.escapeText(description, true, true).replace(\"&#\", \"%\");\n      GithubUtil.doREST(settings.getHost(), settings.getLogin(), settings.getPassword(),\n                        \"/repos/create?name=\" + name + \"&public=\" + (isPrivate ? \"0\" : \"1\") + \"&description=\" + escapedDescription, true).releaseConnection();\n      LOG.info(\"Successfully created GitHub repository\");\n    }\n    catch (final Exception e1) {\n      Messages.showErrorDialog(e1.getMessage(), \"Failed to create new GitHub repository\");\n      return;\n    }\n    bindToGithub(project, root, gitDetected, settings.getLogin(), name);\n    Notifications.Bus.notify(new Notification(\"github\", \"Success\", \"Successfully created project ''\" + name + \"'' on github\",\n                                              NotificationType.INFORMATION));\n  }","id":83360,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (!GithubUtil.testGitExecutable(project)){\n      return;\n    }\n    final VirtualFile root = project.getBaseDir();\n    // Check if git is already initialized and presence of remote branch\n    final boolean gitDetected = GitUtil.isUnderGit(root);\n    if (gitDetected) {\n      try {\n        final List<GitDeprecatedRemote> gitRemotes = GitDeprecatedRemote.list(project, root);\n        if (!gitRemotes.isEmpty()) {\n          Messages.showErrorDialog(project, \"Project is already under git with configured remote\", \"Cannot create new GitHub repository\");\n          return;\n        }\n      }\n      catch (VcsException e2) {\n        Messages.showErrorDialog(project, \"Error happened during git operation: \" + e2.getMessage(), \"Cannot create new GitHub repository\");\n        return;\n      }\n    }\n\n    BasicAction.saveAll();\n    final List<RepositoryInfo> availableRepos = GithubUtil.getAvailableRepos(project, true);\n    if (availableRepos == null){\n      return;\n    }\n    final HashSet<String> names = new HashSet<String>();\n    for (RepositoryInfo info : availableRepos) {\n      names.add(info.getName());\n    }\n\n    final GithubSettings settings = GithubSettings.getInstance();\n    final String password = settings.getPassword();\n    final Boolean privateRepoAllowed = GithubUtil.accessToGithubWithModalProgress(project, new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Trying to login to GitHub\");\n        return GithubUtil.isPrivateRepoAllowed(settings.getHost(), settings.getLogin(), password);\n      }\n    });\n    if (privateRepoAllowed == null) {\n      return;\n    }\n    final GithubShareDialog shareDialog = new GithubShareDialog(project, names, privateRepoAllowed);\n    shareDialog.show();\n    if (!shareDialog.isOK()) {\n      return;\n    }\n\n    final boolean isPrivate = shareDialog.isPrivate();\n    final String name = shareDialog.getRepositoryName();\n    final String description = shareDialog.getDescription();\n    try {\n      LOG.info(\"Creating GitHub repository\");\n      final String escapedDescription = JDOMUtil.escapeText(description, true, true).replace(\"&#\", \"%\");\n      GithubUtil.doREST(settings.getHost(), settings.getLogin(), settings.getPassword(),\n                        \"/repos/create?name=\" + name + \"&public=\" + (isPrivate ? \"0\" : \"1\") + \"&description=\" + escapedDescription, true).releaseConnection();\n      LOG.info(\"Successfully created GitHub repository\");\n    }\n    catch (final Exception e1) {\n      Messages.showErrorDialog(e1.getMessage(), \"Failed to create new GitHub repository\");\n      return;\n    }\n    bindToGithub(project, root, gitDetected, settings.getLogin(), name);\n    Notifications.Bus.notify(new Notification(\"github\", \"Success\", \"Successfully created project ''\" + name + \"'' on github\",\n                                              NotificationType.INFORMATION));\n  }","commit_id":"c423dc43dc01c086505c0eeb102bf9ef8933d4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (project == null || !GithubUtil.testGitExecutable(project)){\n      return;\n    }\n    final VirtualFile root = project.getBaseDir();\n    // Check if git is already initialized and presence of remote branch\n    final boolean gitDetected = GitUtil.isUnderGit(root);\n    if (gitDetected) {\n      try {\n        final List<GitDeprecatedRemote> gitRemotes = GitDeprecatedRemote.list(project, root);\n        if (!gitRemotes.isEmpty()) {\n          Messages.showErrorDialog(project, \"Project is already under git with configured remote\", \"Cannot create new GitHub repository\");\n          return;\n        }\n      }\n      catch (VcsException e2) {\n        Messages.showErrorDialog(project, \"Error happened during git operation: \" + e2.getMessage(), \"Cannot create new GitHub repository\");\n        return;\n      }\n    }\n\n    BasicAction.saveAll();\n    try {\n      final List<RepositoryInfo> availableRepos = GithubUtil.getAvailableRepos(project);\n      if (availableRepos == null){\n        return;\n      }\n      final HashSet<String> names = new HashSet<String>();\n      for (RepositoryInfo info : availableRepos) {\n        names.add(info.getName());\n      }\n\n      final GithubSettings settings = GithubSettings.getInstance();\n      final String password = settings.getPassword();\n      final Boolean privateRepoAllowed =\n        GithubUtil.accessToGithubWithModalProgress(project, new ThrowableComputable<Boolean, IOException>() {\n        @Override\n        public Boolean compute() throws IOException {\n          ProgressManager.getInstance().getProgressIndicator().setText(\"Trying to login to GitHub\");\n          return GithubUtil.isPrivateRepoAllowed(settings.getHost(), settings.getLogin(), password);\n        }\n      });\n      if (privateRepoAllowed == null) {\n        return;\n      }\n      final GithubShareDialog shareDialog = new GithubShareDialog(project, names, privateRepoAllowed);\n      shareDialog.show();\n      if (!shareDialog.isOK()) {\n        return;\n      }\n\n      final boolean isPrivate = shareDialog.isPrivate();\n      final String name = shareDialog.getRepositoryName();\n      final String description = shareDialog.getDescription();\n      LOG.info(\"Creating GitHub repository\");\n      boolean repositoryCreated =\n        createGithubRepository(settings.getHost(), settings.getLogin(), settings.getPassword(), name, description, isPrivate);\n      if (repositoryCreated) {\n        LOG.info(\"Successfully created GitHub repository\");\n      }\n      else {\n        Messages.showErrorDialog(project, \"Failed to create new GitHub repository\", \"Create GitHub Repository\");\n        return;\n      }\n      bindToGithub(project, root, gitDetected, settings.getLogin(), name);\n    }\n    catch (final Exception e1) {\n      Messages.showErrorDialog(e1.getMessage(), \"Failed to create new GitHub repository\");\n    }\n  }","id":83361,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final Project project = e.getData(PlatformDataKeys.PROJECT);\n    if (project == null || !GithubUtil.testGitExecutable(project)){\n      return;\n    }\n    final VirtualFile root = project.getBaseDir();\n    // Check if git is already initialized and presence of remote branch\n    final boolean gitDetected = GitUtil.isUnderGit(root);\n    if (gitDetected) {\n      try {\n        final List<GitDeprecatedRemote> gitRemotes = GitDeprecatedRemote.list(project, root);\n        if (!gitRemotes.isEmpty()) {\n          Messages.showErrorDialog(project, \"Project is already under git with configured remote\", \"Cannot create new GitHub repository\");\n          return;\n        }\n      }\n      catch (VcsException e2) {\n        Messages.showErrorDialog(project, \"Error happened during git operation: \" + e2.getMessage(), \"Cannot create new GitHub repository\");\n        return;\n      }\n    }\n\n    BasicAction.saveAll();\n    try {\n      final List<RepositoryInfo> availableRepos = GithubUtil.getAvailableRepos(project);\n      if (availableRepos == null){\n        return;\n      }\n      final HashSet<String> names = new HashSet<String>();\n      for (RepositoryInfo info : availableRepos) {\n        names.add(info.getName());\n      }\n\n      final GithubSettings settings = GithubSettings.getInstance();\n      final String password = settings.getPassword();\n      final Boolean privateRepoAllowed =\n        GithubUtil.accessToGithubWithModalProgress(project, settings.getHost(), new ThrowableComputable<Boolean, IOException>() {\n        @Override\n        public Boolean compute() throws IOException {\n          ProgressManager.getInstance().getProgressIndicator().setText(\"Trying to login to GitHub\");\n          return GithubUtil.isPrivateRepoAllowed(settings.getHost(), settings.getLogin(), password);\n        }\n      });\n      if (privateRepoAllowed == null) {\n        return;\n      }\n      final GithubShareDialog shareDialog = new GithubShareDialog(project, names, privateRepoAllowed);\n      shareDialog.show();\n      if (!shareDialog.isOK()) {\n        return;\n      }\n\n      final boolean isPrivate = shareDialog.isPrivate();\n      final String name = shareDialog.getRepositoryName();\n      final String description = shareDialog.getDescription();\n      LOG.info(\"Creating GitHub repository\");\n      boolean repositoryCreated =\n        createGithubRepository(settings.getHost(), settings.getLogin(), settings.getPassword(), name, description, isPrivate);\n      if (repositoryCreated) {\n        LOG.info(\"Successfully created GitHub repository\");\n      }\n      else {\n        Messages.showErrorDialog(project, \"Failed to create new GitHub repository\", \"Create GitHub Repository\");\n        return;\n      }\n      bindToGithub(project, root, gitDetected, settings.getLogin(), name);\n    }\n    catch (final Exception e1) {\n      Messages.showErrorDialog(e1.getMessage(), \"Failed to create new GitHub repository\");\n    }\n  }","commit_id":"1f9da6f1a181c82f61634cf996479da7b198f16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean askIfShouldProceed(final String host) {\n    final String BACK_TO_SAFETY = \"No, I don't trust\";\n    final String RISK = \"Proceed anyway\";\n\n    final Ref<Integer> choice = new Ref<Integer>(-1);\n    ApplicationManager.getApplication().invokeAndWait(new Runnable() {\n      @Override\n      public void run() {\n        choice.set(Messages.showDialog(\"The security certificate of \" + host + \" is not trusted. Do you want to proceed anyway?\",\n                                       \"Not Trusted Certificate\", new String[]{BACK_TO_SAFETY, RISK}, 0, Messages.getErrorIcon()));\n      }\n    }, ModalityState.defaultModalityState());\n    return choice.get() == 1;\n  }","id":83362,"modified_method":"@CalledInAwt\n  public boolean askIfShouldProceed(final String host) {\n    final String BACK_TO_SAFETY = \"No, I don't trust\";\n    final String TRUST = \"Proceed anyway\";\n    int choice = Messages.showDialog(\"The security certificate of \" + host + \" is not trusted. Do you want to proceed anyway?\",\n                                   \"Not Trusted Certificate\", new String[] { BACK_TO_SAFETY, TRUST }, 0, Messages.getErrorIcon());\n    boolean trust = (choice == 1);\n    if (trust) {\n      saveToTrusted(host);\n    }\n    return trust;\n  }","commit_id":"1f9da6f1a181c82f61634cf996479da7b198f16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static HttpMethod handleCertificateExceptionAndRetry(@NotNull IOException e, @NotNull String host,\n                                                               @NotNull HttpClient client, @NotNull URI uri,\n                                                               @NotNull ThrowableConvertor<String, HttpMethod, IOException> methodCreator)\n                                                               throws IOException {\n    if (!(e.getCause() instanceof ValidatorException)) {\n      throw e;\n    }\n\n    boolean proceed = isTrusted(host) || askIfShouldProceed(host);\n    if (proceed) {\n      // creating a special configuration that allows connections to non-trusted HTTPS hosts\n      // see the javadoc to EasySSLProtocolSocketFactory for details\n      Protocol easyHttps = new Protocol(\"https\", (ProtocolSocketFactory)new EasySSLProtocolSocketFactory(), 443);\n      HostConfiguration hc = new HostConfiguration();\n      hc.setHost(host, 443, easyHttps);\n      String relativeUri = new URI(uri.getPathQuery(), false).getURI();\n      // it is important to use relative URI here, otherwise our custom protocol won't work.\n      // we have to recreate the method, because HttpMethod#setUri won't overwrite the host,\n      // and changing host by hands (HttpMethodBase#setHostConfiguration) is deprecated.\n      HttpMethod method = methodCreator.convert(relativeUri);\n      client.executeMethod(hc, method);\n      saveToTrusted(host);\n      return method;\n    }\n    return null;\n  }","id":83363,"modified_method":"@Nullable\n  private static HttpMethod handleCertificateExceptionAndRetry(@NotNull IOException e, @NotNull String host,\n                                                               @NotNull HttpClient client, @NotNull URI uri,\n                                                               @NotNull ThrowableConvertor<String, HttpMethod, IOException> methodCreator)\n                                                               throws IOException {\n    if (!isCertificateException(e)) {\n      throw e;\n    }\n\n    if (isTrusted(host)) {\n      // creating a special configuration that allows connections to non-trusted HTTPS hosts\n      // see the javadoc to EasySSLProtocolSocketFactory for details\n      Protocol easyHttps = new Protocol(\"https\", (ProtocolSocketFactory)new EasySSLProtocolSocketFactory(), 443);\n      HostConfiguration hc = new HostConfiguration();\n      hc.setHost(host, 443, easyHttps);\n      String relativeUri = new URI(uri.getPathQuery(), false).getURI();\n      // it is important to use relative URI here, otherwise our custom protocol won't work.\n      // we have to recreate the method, because HttpMethod#setUri won't overwrite the host,\n      // and changing host by hands (HttpMethodBase#setHostConfiguration) is deprecated.\n      HttpMethod method = methodCreator.convert(relativeUri);\n      client.executeMethod(hc, method);\n      return method;\n    }\n    throw e;\n  }","commit_id":"1f9da6f1a181c82f61634cf996479da7b198f16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean checkCredentials(Project project, final String url, final String login, final String password) throws IOException {\n    if (StringUtil.isEmptyOrSpaces(url) || StringUtil.isEmptyOrSpaces(login) || StringUtil.isEmptyOrSpaces(password)){\n      return false;\n    }\n    return accessToGithubWithModalProgress(project, new ThrowableComputable<Boolean, IOException>() {\n      @Override\n      public Boolean compute() throws IOException {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Trying to login to GitHub\");\n        return testConnection(url, login, password);\n      }\n    });\n  }","id":83364,"modified_method":"public static boolean checkCredentials(Project project, final String url, final String login, final String password) throws IOException {\n    if (StringUtil.isEmptyOrSpaces(url) || StringUtil.isEmptyOrSpaces(login) || StringUtil.isEmptyOrSpaces(password)){\n      return false;\n    }\n    Boolean result = accessToGithubWithModalProgress(project, url, new ThrowableComputable<Boolean, IOException>() {\n      @Override\n      public Boolean compute() throws IOException {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Trying to login to GitHub\");\n        return testConnection(url, login, password);\n      }\n    });\n    return result == null ? false : result;\n  }","commit_id":"1f9da6f1a181c82f61634cf996479da7b198f16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @deprecated TODO Use background progress\n   */\n  @Deprecated\n  public static <T> T accessToGithubWithModalProgress(@NotNull final Project project,\n                                                      @NotNull final ThrowableComputable<T, IOException> computable) throws IOException {\n    final Ref<T> result = new Ref<T>();\n    final Ref<IOException> exception = new Ref<IOException>();\n    ProgressManager.getInstance().run(new Task.Modal(project, \"Access to GitHub\", true) {\n      public void run(@NotNull ProgressIndicator indicator) {\n        try {\n          result.set(computable.compute());\n        }\n        catch (IOException e) {\n          exception.set(e);\n        }\n      }\n    });\n    if (exception.isNull()) {\n      return result.get();\n    }\n    throw exception.get();\n  }","id":83365,"modified_method":"private static <T> T doAccessToGithubWithModalProgress(@NotNull final Project project,\n                                                         @NotNull final ThrowableComputable<T, IOException> computable) throws IOException {\n    final Ref<T> result = new Ref<T>();\n    final Ref<IOException> exception = new Ref<IOException>();\n    ProgressManager.getInstance().run(new Task.Modal(project, \"Access to GitHub\", true) {\n      public void run(@NotNull ProgressIndicator indicator) {\n        try {\n          result.set(computable.compute());\n        }\n        catch (IOException e) {\n          exception.set(e);\n        }\n      }\n    });\n    if (exception.isNull()) {\n      return result.get();\n    }\n    throw exception.get();\n  }","commit_id":"1f9da6f1a181c82f61634cf996479da7b198f16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Shows GitHub login settings if credentials are wrong or empty and return the list of all the watched repos by user\n   *\n   * @param project\n   * @return\n   */\n  @Nullable\n  public static List<RepositoryInfo> getAvailableRepos(final Project project) throws IOException {\n    while (!checkCredentials(project)){\n      final GithubLoginDialog dialog = new GithubLoginDialog(project);\n      dialog.show();\n      if (!dialog.isOK()){\n        return null;\n      }\n    }\n    // Otherwise our credentials are valid and they are successfully stored in settings\n    final GithubSettings settings = GithubSettings.getInstance();\n    final String validPassword = settings.getPassword();\n    return accessToGithubWithModalProgress(project, new ThrowableComputable<List<RepositoryInfo>, IOException>() {\n      @Override\n      public List<RepositoryInfo> compute() throws IOException {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Extracting info about available repositories\");\n        return getAvailableRepos(settings.getHost(), settings.getLogin(), validPassword);\n      }\n    });\n  }","id":83366,"modified_method":"/**\n   * Shows GitHub login settings if credentials are wrong or empty and return the list of all the watched repos by user\n   *\n   * @param project\n   * @return\n   */\n  @Nullable\n  public static List<RepositoryInfo> getAvailableRepos(final Project project) throws IOException {\n    while (!checkCredentials(project)){\n      final GithubLoginDialog dialog = new GithubLoginDialog(project);\n      dialog.show();\n      if (!dialog.isOK()){\n        return null;\n      }\n    }\n    // Otherwise our credentials are valid and they are successfully stored in settings\n    final GithubSettings settings = GithubSettings.getInstance();\n    final String validPassword = settings.getPassword();\n    return accessToGithubWithModalProgress(project, settings.getHost(), new ThrowableComputable<List<RepositoryInfo>, IOException>() {\n      @Override\n      public List<RepositoryInfo> compute() throws IOException {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Extracting info about available repositories\");\n        return getAvailableRepos(settings.getHost(), settings.getLogin(), validPassword);\n      }\n    });\n  }","commit_id":"1f9da6f1a181c82f61634cf996479da7b198f16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Shows GitHub login settings if credentials are wrong or empty and return the list of all the watched repos by user\n   * @param project\n   * @return\n   */\n  @Nullable\n  public static RepositoryInfo getDetailedRepositoryInfo(final Project project, final String owner, final String name) throws IOException {\n    final GithubSettings settings = GithubSettings.getInstance();\n    final String password = settings.getPassword();\n    final Boolean validCredentials = accessToGithubWithModalProgress(project, new ThrowableComputable<Boolean, IOException>() {\n      @Override\n      public Boolean compute() throws IOException {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Trying to login to GitHub\");\n        return testConnection(settings.getHost(), settings.getLogin(), password);\n      }\n    });\n    if (validCredentials == null) {\n      return null;\n    }\n    if (!validCredentials){\n      final GithubLoginDialog dialog = new GithubLoginDialog(project);\n      dialog.show();\n      if (!dialog.isOK()) {\n        return null;\n      }\n    }\n    // Otherwise our credentials are valid and they are successfully stored in settings\n    final String validPassword = settings.getPassword();\n    return accessToGithubWithModalProgress(project, new ThrowableComputable<RepositoryInfo, IOException>() {\n      @Nullable\n      @Override\n      public RepositoryInfo compute() {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Extracting detailed info about repository ''\" + name + \"''\");\n        return getDetailedRepoInfo(settings.getHost(), settings.getLogin(), validPassword, owner, name);\n      }\n    });\n  }","id":83367,"modified_method":"/**\n   * Shows GitHub login settings if credentials are wrong or empty and return the list of all the watched repos by user\n   * @param project\n   * @return\n   */\n  @Nullable\n  public static RepositoryInfo getDetailedRepositoryInfo(final Project project, final String owner, final String name) throws IOException {\n    final GithubSettings settings = GithubSettings.getInstance();\n    final String password = settings.getPassword();\n    final Boolean validCredentials = accessToGithubWithModalProgress(project, settings.getHost(),\n                                                                     new ThrowableComputable<Boolean, IOException>() {\n      @Override\n      public Boolean compute() throws IOException {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Trying to login to GitHub\");\n        return testConnection(settings.getHost(), settings.getLogin(), password);\n      }\n    });\n    if (validCredentials == null) {\n      return null;\n    }\n    if (!validCredentials){\n      final GithubLoginDialog dialog = new GithubLoginDialog(project);\n      dialog.show();\n      if (!dialog.isOK()) {\n        return null;\n      }\n    }\n    // Otherwise our credentials are valid and they are successfully stored in settings\n    final String validPassword = settings.getPassword();\n    return accessToGithubWithModalProgress(project, settings.getHost(), new ThrowableComputable<RepositoryInfo, IOException>() {\n      @Nullable\n      @Override\n      public RepositoryInfo compute() {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Extracting detailed info about repository ''\" + name + \"''\");\n        return getDetailedRepoInfo(settings.getHost(), settings.getLogin(), validPassword, owner, name);\n      }\n    });\n  }","commit_id":"1f9da6f1a181c82f61634cf996479da7b198f16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Shows GitHub login settings if credentials are wrong or empty and return the list of all the watched repos by user\n   * @param project\n   * @return\n   */\n  @Nullable\n  public static List<RepositoryInfo> getAvailableRepos(final Project project, final boolean ownOnly) {\n    while (!checkCredentials(project)){\n      final GithubLoginDialog dialog = new GithubLoginDialog(project);\n      dialog.show();\n      if (!dialog.isOK()){\n        return null;\n      }\n    }\n    // Otherwise our credentials are valid and they are successfully stored in settings\n    try {\n      final GithubSettings settings = GithubSettings.getInstance();\n      final String validPassword = settings.getPassword();\n      return accessToGithubWithModalProgress(project, new Computable<List<RepositoryInfo>>() {\n        @Override\n        public List<RepositoryInfo> compute() {\n          ProgressManager.getInstance().getProgressIndicator().setText(\"Extracting info about available repositories\");\n          return getAvailableRepos(settings.getHost(), settings.getLogin(), validPassword, ownOnly);\n        }\n      });\n    }\n    catch (CancelledException e) {\n      return null;\n    }\n  }","id":83368,"modified_method":"/**\n   * Shows GitHub login settings if credentials are wrong or empty and return the list of all the watched repos by user\n   * @param project\n   * @return\n   */\n  @Nullable\n  public static List<RepositoryInfo> getAvailableRepos(final Project project, final boolean ownOnly) {\n    while (!checkCredentials(project)){\n      final GithubLoginDialog dialog = new GithubLoginDialog(project);\n      dialog.show();\n      if (!dialog.isOK()){\n        return null;\n      }\n    }\n    // Otherwise our credentials are valid and they are successfully stored in settings\n    final GithubSettings settings = GithubSettings.getInstance();\n    final String validPassword = settings.getPassword();\n    return accessToGithubWithModalProgress(project, new Computable<List<RepositoryInfo>>() {\n      @Override\n      public List<RepositoryInfo> compute() {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Extracting info about available repositories\");\n        return getAvailableRepos(settings.getHost(), settings.getLogin(), validPassword, ownOnly);\n      }\n    });\n  }","commit_id":"7ff4ca271c307b8a7e7a334538c90147577339ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Shows GitHub login settings if credentials are wrong or empty and return the list of all the watched repos by user\n   * @param project\n   * @return\n   */\n  @Nullable\n  public static RepositoryInfo getDetailedRepositoryInfo(final Project project, final String owner, final String name) {\n    final GithubSettings settings = GithubSettings.getInstance();\n    final String password = settings.getPassword();\n    final boolean validCredentials;\n    try {\n      validCredentials = accessToGithubWithModalProgress(project, new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          ProgressManager.getInstance().getProgressIndicator().setText(\"Trying to login to GitHub\");\n          return testConnection(settings.getHost(), settings.getLogin(), password);\n        }\n      });\n    }\n    catch (CancelledException e) {\n      return null;\n    }\n    if (!validCredentials){\n      final GithubLoginDialog dialog = new GithubLoginDialog(project);\n      dialog.show();\n      if (!dialog.isOK()) {\n        return null;\n      }\n    }\n    // Otherwise our credentials are valid and they are successfully stored in settings\n    try {\n      final String validPassword = settings.getPassword();\n      return accessToGithubWithModalProgress(project, new Computable<RepositoryInfo>() {\n        @Override\n        public RepositoryInfo compute() {\n          ProgressManager.getInstance().getProgressIndicator().setText(\"Extracting detailed info about repository ''\" + name + \"''\");\n          return getDetailedRepoInfo(settings.getHost(), settings.getLogin(), validPassword, owner, name);\n        }\n      });\n    }\n    catch (CancelledException e) {\n      return null;\n    }\n  }","id":83369,"modified_method":"/**\n   * Shows GitHub login settings if credentials are wrong or empty and return the list of all the watched repos by user\n   * @param project\n   * @return\n   */\n  @Nullable\n  public static RepositoryInfo getDetailedRepositoryInfo(final Project project, final String owner, final String name) {\n    final GithubSettings settings = GithubSettings.getInstance();\n    final String password = settings.getPassword();\n    final Boolean validCredentials = accessToGithubWithModalProgress(project, new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Trying to login to GitHub\");\n        return testConnection(settings.getHost(), settings.getLogin(), password);\n      }\n    });\n    if (validCredentials == null) {\n      return null;\n    }\n    if (!validCredentials){\n      final GithubLoginDialog dialog = new GithubLoginDialog(project);\n      dialog.show();\n      if (!dialog.isOK()) {\n        return null;\n      }\n    }\n    // Otherwise our credentials are valid and they are successfully stored in settings\n    final String validPassword = settings.getPassword();\n    return accessToGithubWithModalProgress(project, new Computable<RepositoryInfo>() {\n      @Override\n      public RepositoryInfo compute() {\n        ProgressManager.getInstance().getProgressIndicator().setText(\"Extracting detailed info about repository ''\" + name + \"''\");\n        return getDetailedRepoInfo(settings.getHost(), settings.getLogin(), validPassword, owner, name);\n      }\n    });\n  }","commit_id":"7ff4ca271c307b8a7e7a334538c90147577339ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void accessToGithubWithModalProgress(final Project project, final Runnable runnable) throws CancelledException {\n    ProgressManager.getInstance().run(new Task.Modal(project, \"Access to GitHub\", true) {\n      public void run(@NotNull ProgressIndicator indicator) {\n        runnable.run();\n      }\n\n      @Override\n      public void onCancel() {\n        throw new CancelledException();\n      }\n    });\n  }","id":83370,"modified_method":"public static void accessToGithubWithModalProgress(final Project project, final Runnable runnable) {\n    ProgressManager.getInstance().run(new Task.Modal(project, \"Access to GitHub\", true) {\n      public void run(@NotNull ProgressIndicator indicator) {\n        runnable.run();\n      }\n    });\n  }","commit_id":"7ff4ca271c307b8a7e7a334538c90147577339ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static <T> T accessToGithubWithModalProgress(final Project project, final Computable<T> computable) throws CancelledException {\n    final Ref<T> result = new Ref<T>();\n    ProgressManager.getInstance().run(new Task.Modal(project, \"Access to GitHub\", true) {\n      public void run(@NotNull ProgressIndicator indicator) {\n        result.set(computable.compute());\n      }\n\n      @Override\n      public void onCancel() {\n        throw new CancelledException();\n      }\n    });\n    return result.get();\n  }","id":83371,"modified_method":"public static <T> T accessToGithubWithModalProgress(final Project project, final Computable<T> computable) {\n    final Ref<T> result = new Ref<T>();\n    ProgressManager.getInstance().run(new Task.Modal(project, \"Access to GitHub\", true) {\n      public void run(@NotNull ProgressIndicator indicator) {\n        result.set(computable.compute());\n      }\n    });\n    return result.get();\n  }","commit_id":"7ff4ca271c307b8a7e7a334538c90147577339ae","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void _createStartupCommand(final ModuleChunk chunk, final ArrayList<String> commandLine, final String outputPath) throws IOException {\n    final ProjectJdk jdk = getJdkForStartupCommand(chunk);\n    final String versionString = jdk.getVersionString();\n    if (versionString == null || \"\".equals(versionString)) {\n      throw new IllegalArgumentException(\n        \"Cannot determine version for JDK \" + jdk.getName() + \".\\nUpdate JDK configuration.\\n\");\n    }\n    final boolean isVersion1_0 = isOfVersion(versionString, \"1.0\");\n    final boolean isVersion1_1 = isOfVersion(versionString, \"1.1\");\n    final boolean isVersion1_4 = isOfVersion(versionString, \"1.4\");\n    final boolean isVersion1_5 = isOfVersion(versionString, \"1.5\") || isOfVersion(versionString, \"5.0\");\n\n    final JavacSettings javacSettings = JavacSettings.getInstance(myProject);\n\n    final String vmExePath = jdk.getVMExecutablePath();\n\n    commandLine.add(vmExePath);\n    if (isVersion1_1 || isVersion1_0) {\n      commandLine.add(\"-mx\" + javacSettings.MAXIMUM_HEAP_SIZE + \"m\");\n    }\n    else {\n      commandLine.add(\"-Xmx\" + javacSettings.MAXIMUM_HEAP_SIZE + \"m\");\n    }\n    commandLine.add(\"-classpath\");\n\n    if (isVersion1_0) {\n      commandLine.add(jdk.getToolsPath()); //  do not use JavacRunner for jdk 1.0\n    }\n    else {\n      commandLine.add(jdk.getToolsPath() + File.pathSeparator + PathUtilEx.getIdeaRtJarPath());\n      commandLine.add(com.intellij.rt.compiler.JavacRunner.class.getName());\n      commandLine.add(\"\\\"\" + versionString + \"\\\"\");\n    }\n\n    if (isOfVersion(versionString, \"1.2\") || isVersion1_1 || isVersion1_0) {\n      commandLine.add(\"sun.tools.javac.Main\");\n    }\n    else {\n      commandLine.add(\"com.sun.tools.javac.Main\");\n    }\n\n    final LanguageLevel applicableLanguageLevel = getApplicableLanguageLevel(versionString);\n    if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_5)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.5\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_4)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.4\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_3)) {\n      if (isVersion1_4 || isVersion1_5) {\n        commandLine.add(\"-source\");\n        commandLine.add(\"1.3\");\n      }\n    }\n\n    commandLine.add(\"-verbose\");\n    commandLine.add(\"-classpath\");\n\n    // must include output path to classpath, otherwise javac will compile all dependent files no matter were they compiled before or not\n    final String cp = chunk.getCompilationClasspath();\n    if (isVersion1_0) {\n      commandLine.add(jdk.getToolsPath() + File.pathSeparator + cp);\n    }\n    else {\n      File cpFile = FileUtil.createTempFile(\"javac_cp\", \".tmp\");\n      cpFile.deleteOnExit();\n      myTempFiles.add(cpFile);\n      PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(cpFile)));\n      writer.println(cp);\n      writer.close();\n      commandLine.add(\"@\" + cpFile.getAbsolutePath());\n    }\n\n    LOG.info(\"compiling module chunk\" + chunk + \"; classpath=\\\"\" + cp + \"\\\"\");\n\n    if (!isVersion1_1 && !isVersion1_0) {\n      commandLine.add(\"-sourcepath\");\n      // this way we tell the compiler that the sourcepath is \"empty\". However, javac thinks that sourcepath is 'new File(\"\")'\n      // this may cause problems if we have java code in IDEA working directory\n      commandLine.add(\"\\\"\\\"\");\n    }\n\n    commandLine.add(\"-d\");\n    commandLine.add(outputPath.replace('/', File.separatorChar));\n\n    StringTokenizer tokenizer = new StringTokenizer(javacSettings.getOptionsString(), \" \");\n    while (tokenizer.hasMoreTokens()) {\n      String token = tokenizer.nextToken();\n      if (isVersion1_0) {\n        if (\"-deprecation\".equals(token)) {\n          continue; // not supported for this version\n        }\n      }\n      commandLine.add(token);\n    }\n\n    final VirtualFile[] files = chunk.getFilesToCompile();\n\n    if (isVersion1_0) {\n      for (int i = 0; i < files.length; i++) {\n        VirtualFile file = files[i];\n        String path = file.getPath();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding path for compilation \" + path);\n        }\n        commandLine.add(CompilerUtil.quotePath(path));\n      }\n    }\n    else {\n      File sourcesFile = FileUtil.createTempFile(\"javac\", \".tmp\");\n      sourcesFile.deleteOnExit();\n      myTempFiles.add(sourcesFile);\n      PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(sourcesFile)));\n      for (int i = 0; i < files.length; i++) {\n        final VirtualFile file = files[i];\n        // Important: should use \"/\" slashes!\n        // but not for JDK 1.5 - see SCR 36673\n        final String path = isVersion1_5? file.getPath().replace('/', File.separatorChar) : file.getPath();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding path for compilation \" + path);\n        }\n        writer.println(isVersion1_1? path : CompilerUtil.quotePath(path));\n      }\n      writer.close();\n      commandLine.add(\"@\" + sourcesFile.getAbsolutePath());\n    }\n  }","id":83372,"modified_method":"private void _createStartupCommand(final ModuleChunk chunk, final ArrayList<String> commandLine, final String outputPath) throws IOException {\n    final ProjectJdk jdk = getJdkForStartupCommand(chunk);\n    final String versionString = jdk.getVersionString();\n    if (versionString == null || \"\".equals(versionString)) {\n      throw new IllegalArgumentException(\n        \"Cannot determine version for JDK \" + jdk.getName() + \".\\nUpdate JDK configuration.\\n\");\n    }\n    final boolean isVersion1_0 = isOfVersion(versionString, \"1.0\");\n    final boolean isVersion1_1 = isOfVersion(versionString, \"1.1\");\n    final boolean isVersion1_2 = isOfVersion(versionString, \"1.2\");\n    final boolean isVersion1_3 = isOfVersion(versionString, \"1.3\");\n    final boolean isVersion1_4 = isOfVersion(versionString, \"1.4\");\n    final boolean isVersion1_5 = isOfVersion(versionString, \"1.5\") || isOfVersion(versionString, \"5.0\");\n\n    final JavacSettings javacSettings = JavacSettings.getInstance(myProject);\n\n    final String vmExePath = jdk.getVMExecutablePath();\n\n    commandLine.add(vmExePath);\n    if (isVersion1_1 || isVersion1_0) {\n      commandLine.add(\"-mx\" + javacSettings.MAXIMUM_HEAP_SIZE + \"m\");\n    }\n    else {\n      commandLine.add(\"-Xmx\" + javacSettings.MAXIMUM_HEAP_SIZE + \"m\");\n    }\n    commandLine.add(\"-classpath\");\n\n    if (isVersion1_0) {\n      commandLine.add(jdk.getToolsPath()); //  do not use JavacRunner for jdk 1.0\n    }\n    else {\n      commandLine.add(jdk.getToolsPath() + File.pathSeparator + PathUtilEx.getIdeaRtJarPath());\n      commandLine.add(com.intellij.rt.compiler.JavacRunner.class.getName());\n      commandLine.add(\"\\\"\" + versionString + \"\\\"\");\n    }\n\n    if (isVersion1_2 || isVersion1_1 || isVersion1_0) {\n      commandLine.add(\"sun.tools.javac.Main\");\n    }\n    else {\n      commandLine.add(\"com.sun.tools.javac.Main\");\n    }\n\n    final LanguageLevel applicableLanguageLevel = getApplicableLanguageLevel(versionString);\n    if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_5)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.5\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_4)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.4\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_3)) {\n      if (isVersion1_4 || isVersion1_5) {\n        commandLine.add(\"-source\");\n        commandLine.add(\"1.3\");\n      }\n    }\n\n    commandLine.add(\"-verbose\");\n    commandLine.add(\"-classpath\");\n\n    // must include output path to classpath, otherwise javac will compile all dependent files no matter were they compiled before or not\n    final String cp = chunk.getCompilationClasspath();\n    if (isVersion1_0) {\n      commandLine.add(jdk.getToolsPath() + File.pathSeparator + cp);\n    }\n    else {\n      File cpFile = FileUtil.createTempFile(\"javac_cp\", \".tmp\");\n      cpFile.deleteOnExit();\n      myTempFiles.add(cpFile);\n      PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(cpFile)));\n      writer.println(cp);\n      writer.close();\n      commandLine.add(\"@\" + cpFile.getAbsolutePath());\n    }\n\n    LOG.info(\"compiling module chunk\" + chunk + \"; classpath=\\\"\" + cp + \"\\\"\");\n\n    if (!isVersion1_1 && !isVersion1_0) {\n      commandLine.add(\"-sourcepath\");\n      // this way we tell the compiler that the sourcepath is \"empty\". However, javac thinks that sourcepath is 'new File(\"\")'\n      // this may cause problems if we have java code in IDEA working directory\n      commandLine.add(\"\\\"\\\"\");\n    }\n\n    commandLine.add(\"-d\");\n    commandLine.add(outputPath.replace('/', File.separatorChar));\n\n    StringTokenizer tokenizer = new StringTokenizer(javacSettings.getOptionsString(), \" \");\n    while (tokenizer.hasMoreTokens()) {\n      String token = tokenizer.nextToken();\n      if (isVersion1_0) {\n        if (\"-deprecation\".equals(token)) {\n          continue; // not supported for this version\n        }\n      }\n      if (isVersion1_0 || isVersion1_1 || isVersion1_2 || isVersion1_3 || isVersion1_4) {\n        if (\"-Xlint\".equals(token)) {\n          continue; // not supported in these versions\n        }\n      }\n      commandLine.add(token);\n    }\n\n    final VirtualFile[] files = chunk.getFilesToCompile();\n\n    if (isVersion1_0) {\n      for (int i = 0; i < files.length; i++) {\n        VirtualFile file = files[i];\n        String path = file.getPath();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding path for compilation \" + path);\n        }\n        commandLine.add(CompilerUtil.quotePath(path));\n      }\n    }\n    else {\n      File sourcesFile = FileUtil.createTempFile(\"javac\", \".tmp\");\n      sourcesFile.deleteOnExit();\n      myTempFiles.add(sourcesFile);\n      PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(sourcesFile)));\n      for (int i = 0; i < files.length; i++) {\n        final VirtualFile file = files[i];\n        // Important: should use \"/\" slashes!\n        // but not for JDK 1.5 - see SCR 36673\n        final String path = isVersion1_5? file.getPath().replace('/', File.separatorChar) : file.getPath();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Adding path for compilation \" + path);\n        }\n        writer.println(isVersion1_1? path : CompilerUtil.quotePath(path));\n      }\n      writer.close();\n      commandLine.add(\"@\" + sourcesFile.getAbsolutePath());\n    }\n  }","commit_id":"31540293deb6052e5e69a908f6ae2701b3334e38","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addCommandLineOptions(@NonNls final ArrayList<String> commandLine,\n                                    final ModuleChunk chunk,\n                                    final String outputPath,\n                                    final EclipseCompilerSettings compilerSettings,\n                                    final boolean useTempFile) throws IOException {\n    final ProjectJdk jdk = chunk.getJdk();\n    final String versionString = jdk.getVersionString();\n    if (versionString == null || \"\".equals(versionString)) {\n      throw new IllegalArgumentException(CompilerBundle.message(\"javac.error.unknown.jdk.version\", jdk.getName()));\n    }\n\n    final LanguageLevel applicableLanguageLevel = getApplicableLanguageLevel(versionString);\n    if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_5)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.5\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_4)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.4\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_3)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.3\");\n    }\n\n    final String bootCp = chunk.getCompilationBootClasspath();\n\n    final String classPath = chunk.getCompilationClasspath();\n\n    commandLine.add(\"-bootclasspath\");\n    // important: need to quote boot classpath if path to jdk contain spaces\n    commandLine.add(CompilerUtil.quotePath(bootCp));\n\n    commandLine.add(\"-classpath\");\n    commandLine.add(classPath);\n\n    commandLine.add(\"-d\");\n    commandLine.add(outputPath.replace('/', File.separatorChar));\n\n    commandLine.add(\"-verbose\");\n    StringTokenizer tokenizer = new StringTokenizer(compilerSettings.getOptionsString(), \" \");\n    while (tokenizer.hasMoreTokens()) {\n      commandLine.add(tokenizer.nextToken());\n    }\n\n    final VirtualFile[] files = chunk.getFilesToCompile();\n\n    if (useTempFile) {\n      File sourcesFile = FileUtil.createTempFile(\"javac\", \".tmp\");\n      sourcesFile.deleteOnExit();\n      myTempFiles.add(sourcesFile);\n      final PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(sourcesFile)));\n      try {\n        for (final VirtualFile file : files) {\n          // Important: should use \"/\" slashes!\n          // but not for JDK 1.5 - see SCR 36673\n          final String path = file.getPath().replace('/', File.separatorChar);\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding path for compilation \" + path);\n          }\n          writer.println(CompilerUtil.quotePath(path));\n        }\n      }\n      finally {\n        writer.close();\n      }\n      commandLine.add(\"@\" + sourcesFile.getAbsolutePath());\n    }\n    else {\n      for (VirtualFile file : files) {\n        commandLine.add(file.getPath());\n      }\n    }\n  }","id":83373,"modified_method":"public void addCommandLineOptions(@NonNls final ArrayList<String> commandLine,\n                                    final ModuleChunk chunk,\n                                    final String outputPath,\n                                    final EclipseCompilerSettings compilerSettings,\n                                    final boolean useTempFile,\n                                    boolean quoteBootClasspath) throws IOException {\n    final ProjectJdk jdk = chunk.getJdk();\n    final String versionString = jdk.getVersionString();\n    if (versionString == null || \"\".equals(versionString)) {\n      throw new IllegalArgumentException(CompilerBundle.message(\"javac.error.unknown.jdk.version\", jdk.getName()));\n    }\n\n    final LanguageLevel applicableLanguageLevel = getApplicableLanguageLevel(versionString);\n    if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_5)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.5\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_4)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.4\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_3)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.3\");\n    }\n\n    final String bootCp = chunk.getCompilationBootClasspath();\n\n    final String classPath = chunk.getCompilationClasspath();\n\n    commandLine.add(\"-bootclasspath\");\n    // important: need to quote boot classpath if path to jdk contain spaces\n    commandLine.add(quoteBootClasspath ? CompilerUtil.quotePath(bootCp) : bootCp);\n\n    commandLine.add(\"-classpath\");\n    commandLine.add(classPath);\n\n    commandLine.add(\"-d\");\n    commandLine.add(outputPath.replace('/', File.separatorChar));\n\n    commandLine.add(\"-verbose\");\n    StringTokenizer tokenizer = new StringTokenizer(compilerSettings.getOptionsString(), \" \");\n    while (tokenizer.hasMoreTokens()) {\n      commandLine.add(tokenizer.nextToken());\n    }\n\n    final VirtualFile[] files = chunk.getFilesToCompile();\n\n    if (useTempFile) {\n      File sourcesFile = FileUtil.createTempFile(\"javac\", \".tmp\");\n      sourcesFile.deleteOnExit();\n      myTempFiles.add(sourcesFile);\n      final PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(sourcesFile)));\n      try {\n        for (final VirtualFile file : files) {\n          // Important: should use \"/\" slashes!\n          // but not for JDK 1.5 - see SCR 36673\n          final String path = file.getPath().replace('/', File.separatorChar);\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding path for compilation \" + path);\n          }\n          writer.println(CompilerUtil.quotePath(path));\n        }\n      }\n      finally {\n        writer.close();\n      }\n      commandLine.add(\"@\" + sourcesFile.getAbsolutePath());\n    }\n    else {\n      for (VirtualFile file : files) {\n        commandLine.add(file.getPath());\n      }\n    }\n  }","commit_id":"02f8b17fc670e18f6bcc02be93e2ff45ec5dd921","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createStartupCommand(final ModuleChunk chunk,\n                                    @NonNls final ArrayList<String> commandLine,\n                                    final String outputPath,\n                                    final boolean useTempFile) throws IOException {\n    EclipseCompilerSettings compilerSettings = EclipseCompilerSettings.getInstance(myProject);\n\n    final String vmExePath = ProjectJdkTable.getInstance().getInternalJdk().getVMExecutablePath();\n    commandLine.add(vmExePath);\n    commandLine.add(\"-Xmx\" + compilerSettings.MAXIMUM_HEAP_SIZE + \"m\");\n\n    CompilerUtil.addLocaleOptions(commandLine, false);\n\n    commandLine.add(\"-classpath\");\n    commandLine.add(PATH_TO_COMPILER_JAR);\n    commandLine.add(getCompilerClass());\n\n    addCommandLineOptions(commandLine, chunk, outputPath, compilerSettings, useTempFile);\n  }","id":83374,"modified_method":"private void createStartupCommand(final ModuleChunk chunk,\n                                    @NonNls final ArrayList<String> commandLine,\n                                    final String outputPath,\n                                    final boolean useTempFile) throws IOException {\n    EclipseCompilerSettings compilerSettings = EclipseCompilerSettings.getInstance(myProject);\n\n    final String vmExePath = ProjectJdkTable.getInstance().getInternalJdk().getVMExecutablePath();\n    commandLine.add(vmExePath);\n    commandLine.add(\"-Xmx\" + compilerSettings.MAXIMUM_HEAP_SIZE + \"m\");\n\n    CompilerUtil.addLocaleOptions(commandLine, false);\n\n    commandLine.add(\"-classpath\");\n    commandLine.add(PATH_TO_COMPILER_JAR);\n    commandLine.add(getCompilerClass());\n\n    addCommandLineOptions(commandLine, chunk, outputPath, compilerSettings, useTempFile, true);\n  }","commit_id":"02f8b17fc670e18f6bcc02be93e2ff45ec5dd921","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private LanguageLevel getApplicableLanguageLevel(String versionString) {\n    LanguageLevel languageLevel = ProjectRootManagerEx.getInstanceEx(myProject).getLanguageLevel();\n\n    if (LanguageLevel.JDK_1_5.equals(languageLevel)) {\n      if (!(isOfVersion(versionString, \"1.5\") || isOfVersion(versionString, \"5.0\"))) {\n        languageLevel = LanguageLevel.JDK_1_4;\n      }\n    }\n\n    if (LanguageLevel.JDK_1_4.equals(languageLevel)) {\n      if (!isOfVersion(versionString, \"1.4\") && !isOfVersion(versionString, \"1.5\") && !isOfVersion(versionString, \"5.0\")) {\n        languageLevel = LanguageLevel.JDK_1_3;\n      }\n    }\n\n    return languageLevel;\n  }","id":83375,"modified_method":"private LanguageLevel getApplicableLanguageLevel(String versionString) {\n    LanguageLevel languageLevel = ProjectRootManagerEx.getInstanceEx(myProject).getLanguageLevel();\n\n    if (LanguageLevel.JDK_1_5.equals(languageLevel)) {\n      if (!isOfVersion(versionString, \"1.5\") && !isOfVersion(versionString, \"5.0\") && !isOfVersion(versionString, \"1.6.\")) {\n        languageLevel = LanguageLevel.JDK_1_4;\n      }\n    }\n\n    if (LanguageLevel.JDK_1_4.equals(languageLevel)) {\n      if (!isOfVersion(versionString, \"1.4\") && !isOfVersion(versionString, \"1.5\") && !isOfVersion(versionString, \"5.0\") && !isOfVersion(versionString, \"1.6.\")) {\n        languageLevel = LanguageLevel.JDK_1_3;\n      }\n    }\n\n    return languageLevel;\n  }","commit_id":"02f8b17fc670e18f6bcc02be93e2ff45ec5dd921","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public Process launchProcess(final ModuleChunk chunk, final String outputDir, final CompileContext compileContext) throws IOException {\n    @NonNls final ArrayList<String> commandLine = new ArrayList<String>();\n    myEclipseExternalCompiler.addCommandLineOptions(commandLine, chunk, outputDir, EclipseCompilerSettings.getInstance(myProject), false);\n\n    Process process = new Process() {\n      public OutputStream getOutputStream() {\n        throw new UnsupportedOperationException();\n      }\n\n      public InputStream getInputStream() {\n        return null;\n      }\n\n      public InputStream getErrorStream() {\n        return null;\n      }\n\n      public void destroy() {\n      }\n\n      public int waitFor() {\n        try {\n          commandLine.remove(\"-verbose\");\n          String[] finalCmds = commandLine.toArray(new String[commandLine.size()]);\n          myEclipseCompilerDriver.parseCommandLineAndCompile(finalCmds);\n          myExitCode = 0;\n          return myExitCode;\n        }\n        catch (Exception e) {\n          LOG.error(e);\n          myExitCode = -1;\n          return -1;\n        }\n      }\n\n      public int exitValue() {\n        return myExitCode;\n      }\n    };\n    return process;\n  }","id":83376,"modified_method":"@NotNull\n  public Process launchProcess(final ModuleChunk chunk, final String outputDir, final CompileContext compileContext) throws IOException {\n    @NonNls final ArrayList<String> commandLine = new ArrayList<String>();\n    myEclipseExternalCompiler.addCommandLineOptions(commandLine, chunk, outputDir, EclipseCompilerSettings.getInstance(myProject), false, false);\n\n    Process process = new Process() {\n      public OutputStream getOutputStream() {\n        throw new UnsupportedOperationException();\n      }\n\n      public InputStream getInputStream() {\n        return null;\n      }\n\n      public InputStream getErrorStream() {\n        return null;\n      }\n\n      public void destroy() {\n      }\n\n      public int waitFor() {\n        try {\n          commandLine.remove(\"-verbose\");\n          String[] finalCmds = commandLine.toArray(new String[commandLine.size()]);\n          myEclipseCompilerDriver.parseCommandLineAndCompile(finalCmds);\n          myExitCode = 0;\n          return myExitCode;\n        }\n        catch (Exception e) {\n          LOG.error(e);\n          myExitCode = -1;\n          return -1;\n        }\n      }\n\n      public int exitValue() {\n        return myExitCode;\n      }\n    };\n    return process;\n  }","commit_id":"02f8b17fc670e18f6bcc02be93e2ff45ec5dd921","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void addSourceCommandLineSwitch(final ProjectJdk jdk, LanguageLevel chunkLanguageLevel, @NonNls final List<String> commandLine) {\n    final String versionString = jdk.getVersionString();\n    if (versionString == null || \"\".equals(versionString)) {\n      throw new IllegalArgumentException(CompilerBundle.message(\"javac.error.unknown.jdk.version\", jdk.getName()));\n    }\n\n    final LanguageLevel applicableLanguageLevel = getApplicableLanguageLevel(versionString, chunkLanguageLevel);\n    if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_5)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.5\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_4)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.4\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_3)) {\n      if (isOfVersion(versionString, \"1.4\") || isOfVersion(versionString, \"1.5\")) {\n        //noinspection HardCodedStringLiteral\n        commandLine.add(\"-source\");\n        commandLine.add(\"1.3\");\n      }\n    }\n  }","id":83377,"modified_method":"public static void addSourceCommandLineSwitch(final ProjectJdk jdk, LanguageLevel chunkLanguageLevel, @NonNls final List<String> commandLine) {\n    final String versionString = jdk.getVersionString();\n    if (versionString == null || \"\".equals(versionString)) {\n      throw new IllegalArgumentException(CompilerBundle.message(\"javac.error.unknown.jdk.version\", jdk.getName()));\n    }\n\n    final LanguageLevel applicableLanguageLevel = getApplicableLanguageLevel(versionString, chunkLanguageLevel);\n    if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_5)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.5\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_4)) {\n      commandLine.add(\"-source\");\n      commandLine.add(\"1.4\");\n    }\n    else if (applicableLanguageLevel.equals(LanguageLevel.JDK_1_3)) {\n      if (!(isOfVersion(versionString, \"1.3\") || isOfVersion(versionString, \"1.2\") || isOfVersion(versionString, \"1.1\"))) {\n        //noinspection HardCodedStringLiteral\n        commandLine.add(\"-source\");\n        commandLine.add(\"1.3\");\n      }\n    }\n  }","commit_id":"5cff788af714d9aeb89331d9852897934a1191af","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     *  Pick a responsive floodfill close to the key, but not the one we sent to\n     */\n    private Hash pickTarget() {\n        Hash rkey = getContext().routingKeyGenerator().getRoutingKey(_key);\n        FloodfillPeerSelector sel = (FloodfillPeerSelector)_facade.getPeerSelector();\n        boolean isKeyCert = false;\n        if (!_isRouterInfo) {\n            LeaseSet ls = _facade.lookupLeaseSetLocally(_key);\n            if (ls != null &&\n                ls.getDestination().getCertificate().getCertificateType() == Certificate.CERTIFICATE_TYPE_KEY)\n                isKeyCert = true;\n        }\n        if (isKeyCert) {\n            while (true) {\n                List<Hash> peers = sel.selectFloodfillParticipants(rkey, 1, _ignore, _facade.getKBuckets());\n                if (peers.isEmpty())\n                    break;\n                Hash peer = peers.get(0);\n                RouterInfo ri = _facade.lookupRouterInfoLocally(peer);\n                if (ri != null && StoreJob.supportsKeyCerts(ri))\n                    return peer;\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(getJobId() + \": Skipping verify w/ router that doesn't support key certs \" + peer);\n                _ignore.add(peer);\n            }\n        } else {\n            List<Hash> peers = sel.selectFloodfillParticipants(rkey, 1, _ignore, _facade.getKBuckets());\n            if (!peers.isEmpty())\n                return peers.get(0);\n        }\n        \n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"No other peers to verify floodfill with, using the one we sent to\");\n        return _sentTo;\n    }","id":83378,"modified_method":"/**\n     *  Pick a responsive floodfill close to the key, but not the one we sent to\n     */\n    private Hash pickTarget() {\n        Hash rkey = getContext().routingKeyGenerator().getRoutingKey(_key);\n        FloodfillPeerSelector sel = (FloodfillPeerSelector)_facade.getPeerSelector();\n        Certificate keyCert = null;\n        if (!_isRouterInfo) {\n            LeaseSet ls = _facade.lookupLeaseSetLocally(_key);\n            if (ls != null) {\n                Certificate cert = ls.getDestination().getCertificate();\n                if (cert.getCertificateType() == Certificate.CERTIFICATE_TYPE_KEY)\n                    keyCert = cert;\n            }\n        }\n        if (keyCert != null) {\n            while (true) {\n                List<Hash> peers = sel.selectFloodfillParticipants(rkey, 1, _ignore, _facade.getKBuckets());\n                if (peers.isEmpty())\n                    break;\n                Hash peer = peers.get(0);\n                RouterInfo ri = _facade.lookupRouterInfoLocally(peer);\n                if (ri != null && StoreJob.supportsCert(ri, keyCert))\n                    return peer;\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(getJobId() + \": Skipping verify w/ router that doesn't support key certs \" + peer);\n                _ignore.add(peer);\n            }\n        } else {\n            List<Hash> peers = sel.selectFloodfillParticipants(rkey, 1, _ignore, _facade.getKBuckets());\n            if (!peers.isEmpty())\n                return peers.get(0);\n        }\n        \n        if (_log.shouldLog(Log.WARN))\n            _log.warn(\"No other peers to verify floodfill with, using the one we sent to\");\n        return _sentTo;\n    }","commit_id":"efebecfc676a40ddef1073f61f0b805d640b5df1","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Does he support key certs (assumed with a non-DSA key)?\n     * @since 0.9.12\n     */\n    public static boolean supportsKeyCerts(RouterInfo ri) {\n        String v = ri.getOption(\"router.version\");\n        if (v == null)\n            return false;\n        return VersionComparator.comp(v, MIN_KEYCERT_VERSION) >= 0;\n    }","id":83379,"modified_method":"/**\n     * Does this router understand this cert?\n     * @return true if not a key cert\n     * @since 0.9.12\n     */\n    public static boolean supportsCert(RouterInfo ri, Certificate cert) {\n        if (cert.getCertificateType() != Certificate.CERTIFICATE_TYPE_KEY)\n            return true;\n        SigType type;\n        try {\n            type = cert.toKeyCertificate().getSigType();\n        } catch (DataFormatException dfe) {\n            return false;\n        }\n        if (type == null)\n            return false;\n        String v = ri.getOption(\"router.version\");\n        if (v == null)\n            return false;\n        String since = type.getSupportedSince();\n        return VersionComparator.comp(v, since) >= 0;\n    }","commit_id":"efebecfc676a40ddef1073f61f0b805d640b5df1","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Send a series of searches to the next available peers as selected by\n     * the routing table, but making sure no more than PARALLELIZATION are outstanding\n     * at any time\n     *\n     * Caller should synchronize to enforce parallelization limits and prevent dups\n     */\n    private synchronized void continueSending() { \n        if (_state.completed()) return;\n        int toCheck = getParallelization() - _state.getPending().size();\n        if (toCheck <= 0) {\n            // too many already pending\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(getJobId() + \": Too many store messages pending\");\n            return;\n        } \n        if (toCheck > getParallelization())\n            toCheck = getParallelization();\n\n        // We are going to send the RouterInfo directly, rather than through a lease,\n        // so select a floodfill peer we are already connected to.\n        // This will help minimize active connections for floodfill peers and allow\n        // the network to scale.\n        // Perhaps the ultimate solution is to send RouterInfos through a lease also.\n        List<Hash> closestHashes;\n        //if (_state.getData() instanceof RouterInfo) \n        //    closestHashes = getMostReliableRouters(_state.getTarget(), toCheck, _state.getAttempted());\n        //else\n        //    closestHashes = getClosestRouters(_state.getTarget(), toCheck, _state.getAttempted());\n        closestHashes = getClosestFloodfillRouters(_state.getTarget(), toCheck, _state.getAttempted());\n        if ( (closestHashes == null) || (closestHashes.isEmpty()) ) {\n            if (_state.getPending().isEmpty()) {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(getJobId() + \": No more peers left and none pending\");\n                fail();\n            } else {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(getJobId() + \": No more peers left but some are pending, so keep waiting\");\n                return;\n            }\n        } else {\n            //_state.addPending(closestHashes);\n            int queued = 0;\n            int skipped = 0;\n            for (Hash peer : closestHashes) {\n                DatabaseEntry ds = _facade.getDataStore().get(peer);\n                if ( (ds == null) || !(ds.getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO) ) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(getJobId() + \": Error selecting closest hash that wasnt a router! \" + peer + \" : \" + ds);\n                    _state.addSkipped(peer);\n                    skipped++;\n                } else if (_state.getData().getType() == DatabaseEntry.KEY_TYPE_LEASESET &&\n                           ((LeaseSet)_state.getData()).getDestination().getCertificate().getCertificateType() == Certificate.CERTIFICATE_TYPE_KEY &&\n                           !supportsKeyCerts((RouterInfo)ds)) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(getJobId() + \": Skipping router that doesn't support key certs \" + peer);\n                    _state.addSkipped(peer);\n                    skipped++;\n                } else if (_state.getData().getType() == DatabaseEntry.KEY_TYPE_LEASESET &&\n                           ((LeaseSet)_state.getData()).getLeaseCount() > 6 &&\n                           !supportsBigLeaseSets((RouterInfo)ds)) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(getJobId() + \": Skipping router that doesn't support big leasesets \" + peer);\n                    _state.addSkipped(peer);\n                    skipped++;\n                } else {\n                    int peerTimeout = _facade.getPeerTimeout(peer);\n\n                    //PeerProfile prof = getContext().profileOrganizer().getProfile(peer);\n                    //if (prof != null && prof.getIsExpandedDB()) {\n                    //    RateStat failing = prof.getDBHistory().getFailedLookupRate();\n                    //    Rate failed = failing.getRate(60*60*1000);\n                    //}\n\n                    //long failedCount = failed.getCurrentEventCount()+failed.getLastEventCount();\n                    //if (failedCount > 10) {\n                    //    _state.addSkipped(peer);\n                    //    continue;\n                    //}\n                    //\n                    //if (failed.getCurrentEventCount() + failed.getLastEventCount() > avg) {\n                    //    _state.addSkipped(peer);\n                    //}\n                    \n                    // we don't want to filter out peers based on our local banlist, as that opens an avenue for\n                    // manipulation (since a peer can get us to banlist them, and that\n                    // in turn would let them assume that a netDb store received didn't come from us)\n                    //if (getContext().banlist().isBanlisted(((RouterInfo)ds).getIdentity().calculateHash())) {\n                    //    _state.addSkipped(peer);\n                    //} else {\n                    //\n                    // ERR: see hidden mode comments in HandleDatabaseLookupMessageJob\n                    // // Do not store to hidden nodes\n                    // if (!((RouterInfo)ds).isHidden()) {\n                       if (_log.shouldLog(Log.INFO))\n                           _log.info(getJobId() + \": Continue sending key \" + _state.getTarget() +\n                                     \" after \" + _state.getAttempted().size() + \" tries to \" + closestHashes);\n                        _state.addPending(peer);\n                        sendStore((RouterInfo)ds, peerTimeout);\n                        queued++;\n                    //}\n                }\n            }\n            if (queued == 0 && _state.getPending().isEmpty()) {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(getJobId() + \": No more peers left after skipping \" + skipped + \" and none pending\");\n                // queue a job to go around again rather than recursing\n                getContext().jobQueue().addJob(new WaitJob(getContext()));\n            }\n        }\n    }","id":83380,"modified_method":"/**\n     * Send a series of searches to the next available peers as selected by\n     * the routing table, but making sure no more than PARALLELIZATION are outstanding\n     * at any time\n     *\n     * Caller should synchronize to enforce parallelization limits and prevent dups\n     */\n    private synchronized void continueSending() { \n        if (_state.completed()) return;\n        int toCheck = getParallelization() - _state.getPending().size();\n        if (toCheck <= 0) {\n            // too many already pending\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(getJobId() + \": Too many store messages pending\");\n            return;\n        } \n        if (toCheck > getParallelization())\n            toCheck = getParallelization();\n\n        // We are going to send the RouterInfo directly, rather than through a lease,\n        // so select a floodfill peer we are already connected to.\n        // This will help minimize active connections for floodfill peers and allow\n        // the network to scale.\n        // Perhaps the ultimate solution is to send RouterInfos through a lease also.\n        List<Hash> closestHashes;\n        //if (_state.getData() instanceof RouterInfo) \n        //    closestHashes = getMostReliableRouters(_state.getTarget(), toCheck, _state.getAttempted());\n        //else\n        //    closestHashes = getClosestRouters(_state.getTarget(), toCheck, _state.getAttempted());\n        closestHashes = getClosestFloodfillRouters(_state.getTarget(), toCheck, _state.getAttempted());\n        if ( (closestHashes == null) || (closestHashes.isEmpty()) ) {\n            if (_state.getPending().isEmpty()) {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(getJobId() + \": No more peers left and none pending\");\n                fail();\n            } else {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(getJobId() + \": No more peers left but some are pending, so keep waiting\");\n                return;\n            }\n        } else {\n            //_state.addPending(closestHashes);\n            int queued = 0;\n            int skipped = 0;\n            for (Hash peer : closestHashes) {\n                DatabaseEntry ds = _facade.getDataStore().get(peer);\n                if ( (ds == null) || !(ds.getType() == DatabaseEntry.KEY_TYPE_ROUTERINFO) ) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(getJobId() + \": Error selecting closest hash that wasnt a router! \" + peer + \" : \" + ds);\n                    _state.addSkipped(peer);\n                    skipped++;\n                } else if (_state.getData().getType() == DatabaseEntry.KEY_TYPE_LEASESET &&\n                           !supportsCert((RouterInfo)ds,\n                                         ((LeaseSet)_state.getData()).getDestination().getCertificate())) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(getJobId() + \": Skipping router that doesn't support key certs \" + peer);\n                    _state.addSkipped(peer);\n                    skipped++;\n                } else if (_state.getData().getType() == DatabaseEntry.KEY_TYPE_LEASESET &&\n                           ((LeaseSet)_state.getData()).getLeaseCount() > 6 &&\n                           !supportsBigLeaseSets((RouterInfo)ds)) {\n                    if (_log.shouldLog(Log.INFO))\n                        _log.info(getJobId() + \": Skipping router that doesn't support big leasesets \" + peer);\n                    _state.addSkipped(peer);\n                    skipped++;\n                } else {\n                    int peerTimeout = _facade.getPeerTimeout(peer);\n\n                    //PeerProfile prof = getContext().profileOrganizer().getProfile(peer);\n                    //if (prof != null && prof.getIsExpandedDB()) {\n                    //    RateStat failing = prof.getDBHistory().getFailedLookupRate();\n                    //    Rate failed = failing.getRate(60*60*1000);\n                    //}\n\n                    //long failedCount = failed.getCurrentEventCount()+failed.getLastEventCount();\n                    //if (failedCount > 10) {\n                    //    _state.addSkipped(peer);\n                    //    continue;\n                    //}\n                    //\n                    //if (failed.getCurrentEventCount() + failed.getLastEventCount() > avg) {\n                    //    _state.addSkipped(peer);\n                    //}\n                    \n                    // we don't want to filter out peers based on our local banlist, as that opens an avenue for\n                    // manipulation (since a peer can get us to banlist them, and that\n                    // in turn would let them assume that a netDb store received didn't come from us)\n                    //if (getContext().banlist().isBanlisted(((RouterInfo)ds).getIdentity().calculateHash())) {\n                    //    _state.addSkipped(peer);\n                    //} else {\n                    //\n                    // ERR: see hidden mode comments in HandleDatabaseLookupMessageJob\n                    // // Do not store to hidden nodes\n                    // if (!((RouterInfo)ds).isHidden()) {\n                       if (_log.shouldLog(Log.INFO))\n                           _log.info(getJobId() + \": Continue sending key \" + _state.getTarget() +\n                                     \" after \" + _state.getAttempted().size() + \" tries to \" + closestHashes);\n                        _state.addPending(peer);\n                        sendStore((RouterInfo)ds, peerTimeout);\n                        queued++;\n                    //}\n                }\n            }\n            if (queued == 0 && _state.getPending().isEmpty()) {\n                if (_log.shouldLog(Log.INFO))\n                    _log.info(getJobId() + \": No more peers left after skipping \" + skipped + \" and none pending\");\n                // queue a job to go around again rather than recursing\n                getContext().jobQueue().addJob(new WaitJob(getContext()));\n            }\n        }\n    }","commit_id":"efebecfc676a40ddef1073f61f0b805d640b5df1","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n    @DB\n    public String uploadCertificate(UploadCustomCertificateCmd cmd) {\n        if (cmd.getPrivateKey() != null && cmd.getAlias() != null) {\n            throw new InvalidParameterValueException(\"Can't change the alias for private key certification\");\n        }\n\n        if (cmd.getPrivateKey() == null) {\n            if (cmd.getAlias() == null) {\n                throw new InvalidParameterValueException(\"alias can't be empty, if it's a certification chain\");\n            }\n\n            if (cmd.getCertIndex() == null) {\n                throw new InvalidParameterValueException(\"index can't be empty, if it's a certifciation chain\");\n            }\n        }\n\n        if (cmd.getPrivateKey() != null && !_ksMgr.validateCertificate(cmd.getCertificate(), cmd.getPrivateKey(), cmd.getDomainSuffix())) {\n            throw new InvalidParameterValueException(\"Failed to pass certificate validation check\");\n        }\n\n        if (cmd.getPrivateKey() != null) {\n            _ksMgr.saveCertificate(ConsoleProxyManager.CERTIFICATE_NAME, cmd.getCertificate(), cmd.getPrivateKey(), cmd.getDomainSuffix());\n        } else {\n            _ksMgr.saveCertificate(cmd.getAlias(), cmd.getCertificate(), cmd.getCertIndex(), cmd.getDomainSuffix());\n        }\n\n        _consoleProxyMgr.setManagementState(ConsoleProxyManagementState.ResetSuspending);\n        return \"Certificate has been updated, we will stop all running console proxy VMs to propagate the new certificate, please give a few minutes for console access service to be up again\";\n    }","id":83381,"modified_method":"@Override\n    @DB\n    public String uploadCertificate(UploadCustomCertificateCmd cmd) {\n        if (cmd.getPrivateKey() != null && cmd.getAlias() != null) {\n            throw new InvalidParameterValueException(\"Can't change the alias for private key certification\");\n        }\n\n        if (cmd.getPrivateKey() == null) {\n            if (cmd.getAlias() == null) {\n                throw new InvalidParameterValueException(\"alias can't be empty, if it's a certification chain\");\n            }\n\n            if (cmd.getCertIndex() == null) {\n                throw new InvalidParameterValueException(\"index can't be empty, if it's a certifciation chain\");\n            }\n        }\n\n        String certificate = cmd.getCertificate();\n        String key = cmd.getPrivateKey();\n        try {\n            if (certificate != null)\n                certificate = URLDecoder.decode(certificate, \"UTF-8\");\n            if (key != null)\n                key = URLDecoder.decode(key, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n        } finally {\n        }\n\n        if (cmd.getPrivateKey() != null && !_ksMgr.validateCertificate(certificate, key, cmd.getDomainSuffix())) {\n            throw new InvalidParameterValueException(\"Failed to pass certificate validation check\");\n        }\n\n        if (cmd.getPrivateKey() != null) {\n            _ksMgr.saveCertificate(ConsoleProxyManager.CERTIFICATE_NAME, certificate, key, cmd.getDomainSuffix());\n        } else {\n            _ksMgr.saveCertificate(cmd.getAlias(), certificate, cmd.getCertIndex(), cmd.getDomainSuffix());\n        }\n\n        _consoleProxyMgr.setManagementState(ConsoleProxyManagementState.ResetSuspending);\n        List<SecondaryStorageVmVO> alreadyRunning = _secStorageVmDao.getSecStorageVmListInStates(null, State.Running, State.Migrating, State.Starting);\n        for (SecondaryStorageVmVO ssVmVm : alreadyRunning)\n            _secStorageVmMgr.rebootSecStorageVm(ssVmVm.getId());\n        return \"Certificate has been updated, we will stop all running console proxy VMs and secondary storage VMs to propagate the new certificate, please give a few minutes for console access service to be up again\";\n    }","commit_id":"d2a751fb1e619aa58412a4d22d97d11b6812f0fa","url":"https://github.com/apache/cloudstack"},{"original_method":"public static Map<ProtectionDomain, PermissionCollection> load( InputStream policyStream, PropertyEvaluator evaluator ) throws PolicyException\n    {\n        Map<ProtectionDomain, PermissionCollection> pdMappings = new HashMap<ProtectionDomain, PermissionCollection>();\n        KeyStore keystore = null;\n        \n        try\n        {\n            PolicyFileScanner loader = new PolicyFileScanner();\n            \n            Collection<GrantEntry> grantEntries = new ArrayList<GrantEntry>();\n            List<KeystoreEntry> keystoreEntries = new ArrayList<KeystoreEntry>();\n            \n            loader.scanStream( new InputStreamReader(policyStream), grantEntries, keystoreEntries );\n            \n            for ( Iterator<KeystoreEntry> i = keystoreEntries.iterator(); i.hasNext();)\n            {\n                keystore = resolveKeyStore( i.next(), evaluator );\n            }\n            \n            for ( Iterator<GrantEntry> i = grantEntries.iterator(); i.hasNext(); )\n            {\n                GrantEntry grant = i.next();\n                \n                Permissions permissions = processPermissions( grant.permissions, keystore, evaluator );\n                \n                ProtectionDomain pd;\n                \n                if ( grant.codebase == null ) // these are hereby known as global permissions (no codebase associated)\n                {\n                    pd = new ProtectionDomain( null, permissions );\n                }\n                else\n                {\n                    CodeSource codeSource = resolveToCodeSource( grant.codebase, evaluator );    \n                    pd = new ProtectionDomain( codeSource, permissions );\n                }                                \n                pdMappings.put( pd, null );                                        \n            }      \n            \n            return pdMappings;\n        }\n        catch ( Exception e )\n        {\n            throw new PolicyException( e );\n        }\n    }","id":83382,"modified_method":"public static Map<ProtectionDomain, PermissionCollection> load( InputStream policyStream, PropertyEvaluator evaluator ) throws PolicyException\n    {\n        Map<ProtectionDomain, PermissionCollection> pdMappings = new HashMap<ProtectionDomain, PermissionCollection>();\n        KeyStore keystore = null;\n        \n        try\n        {\n            PolicyFileScanner loader = new PolicyFileScanner();\n            \n            Collection<GrantEntry> grantEntries = new ArrayList<GrantEntry>();\n            List<KeystoreEntry> keystoreEntries = new ArrayList<KeystoreEntry>();\n            \n            loader.scanStream( new InputStreamReader(policyStream), grantEntries, keystoreEntries );\n            \n            for ( Iterator<KeystoreEntry> i = keystoreEntries.iterator(); i.hasNext();)\n            {\n                keystore = resolveKeyStore( i.next(), evaluator );\n                \n                if ( keystore != null )\n                {\n                    // we only process the first valid keystore\n                    break;\n                }\n            }\n            \n            for ( Iterator<GrantEntry> i = grantEntries.iterator(); i.hasNext(); )\n            {\n                GrantEntry grant = i.next();\n                \n                Permissions permissions = processPermissions( grant, keystore, evaluator );\n                \n                ProtectionDomain pd;\n                \n                if ( grant.codebase == null ) // these are hereby known as global permissions (no codebase associated)\n                {\n                    pd = new ProtectionDomain( null, permissions );\n                }\n                else\n                {\n                    Certificate[] certs = resolveToCertificates( keystore, grant.signers );\n                    Principal[] principals = resolvePrincipals( keystore, grant.principals );\n                    CodeSource codeSource = resolveToCodeSource( grant.codebase, certs, evaluator );    \n                    pd = new ProtectionDomain( codeSource, permissions, Thread.currentThread().getContextClassLoader(),principals );\n                    //System.out.println( pd.toString() );\n                }                                \n                pdMappings.put( pd, null );                                        \n            }      \n            \n            return pdMappings;\n        }\n        catch ( Exception e )\n        {\n            throw new PolicyException( e );\n        }\n    }","commit_id":"62ff473a501db282c893899987441f66f2313145","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private static CodeSource resolveToCodeSource( String codeBase, PropertyEvaluator evaluator ) throws PolicyException\n    {\n        try\n        {   \n            URL url = new URL( evaluator.evaluate(codeBase) ); \n            Certificate[] cert = null;\n            return new CodeSource( url, cert); //TODO support certificates\n        }\n        catch ( Exception e )\n        {\n            throw new PolicyException( e );\n        }      \n    }","id":83383,"modified_method":"private static CodeSource resolveToCodeSource( String codeBase, Certificate[] signers, PropertyEvaluator evaluator ) throws PolicyException\n    {\n        try\n        {   \n            URL url = new URL( evaluator.evaluate(codeBase) ); \n            \n            return new CodeSource( url, signers);\n        }\n        catch ( Exception e )\n        {\n            throw new PolicyException( e );\n        }      \n    }","commit_id":"62ff473a501db282c893899987441f66f2313145","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * resolve signers into an array of certificates using a given keystore\n     * \n     * @param keyStore\n     * @param signers\n     * @return\n     * @throws Exception\n     */\n    private static Certificate[] resolveToCertificates( KeyStore keyStore, String signers ) throws PolicyException\n    {\n        StringTokenizer strTok = new StringTokenizer( signers, \",\");\n        \n        Certificate[] certificates = new Certificate[strTok.countTokens()];\n        \n        for ( int i = 0; strTok.hasMoreTokens(); ++i )\n        {\n            try\n            {\n                certificates[i] = keyStore.getCertificate( strTok.nextToken().trim() );\n            }\n            catch ( KeyStoreException kse )\n            {\n                throw new PolicyException( kse );\n            }\n        }\n        \n        return certificates;\n    }","id":83384,"modified_method":"/**\n     * resolve signers into an array of certificates using a given keystore\n     * \n     * @param keyStore\n     * @param signers\n     * @return\n     * @throws Exception\n     */\n    private static Certificate[] resolveToCertificates( KeyStore keyStore, String signers ) throws PolicyException\n    {               \n        if ( keyStore == null )\n        {\n            Certificate[] certs = null;\n            return certs;\n        }\n                \n        Set<Certificate> certificateSet = new HashSet<Certificate>();       \n        StringTokenizer strTok = new StringTokenizer( signers, \",\");\n        \n        for ( int i = 0; strTok.hasMoreTokens(); ++i )\n        {\n            try\n            {               \n                Certificate certificate = keyStore.getCertificate( strTok.nextToken().trim() );\n                \n                if ( certificate != null )\n                {\n                    certificateSet.add( certificate );\n                }               \n            }\n            catch ( KeyStoreException kse )\n            {\n                throw new PolicyException( kse );\n            }\n        }\n        \n        return certificateSet.toArray( new Certificate[certificateSet.size()]);\n    }","commit_id":"62ff473a501db282c893899987441f66f2313145","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private static Permissions processPermissions( Collection<PermissionEntry> collection, KeyStore keystore, PropertyEvaluator evaluator ) throws PolicyException\n    {\n        Permissions permissions = new Permissions();\n        \n        for ( Iterator<PermissionEntry> i = collection.iterator(); i.hasNext(); )\n        {\n            PermissionEntry perm = i.next();           \n            \n            Class clazz;\n            try \n            {\n                clazz = Class.forName( perm.klass );\n                \n                // if we have perm.signers then we need to validate against the class certificates\n                if ( perm.signers != null )\n                {\n                    if ( validate( resolveToCertificates( keystore, perm.signers ), (Certificate[]) clazz.getSigners() ))\n                    {\n                       permissions.add( resolveToPermission( clazz, perm, evaluator ) );\n                    }                   \n                }\n                else\n                {\n                    permissions.add( resolveToPermission( clazz, perm, evaluator ) );\n                }\n            } \n            catch ( Exception e ) \n            {\n                throw new PolicyException( e );\n            }\n        }\n        \n        return permissions;\n    }","id":83385,"modified_method":"private static Permissions processPermissions( GrantEntry grant, KeyStore keystore, PropertyEvaluator evaluator ) throws PolicyException\n    {\n        Collection<PermissionEntry> collection = grant.permissions;\n        Permissions permissions = new Permissions();\n        \n        for ( Iterator<PermissionEntry> i = collection.iterator(); i.hasNext(); )\n        {\n            PermissionEntry perm = i.next();           \n            \n            Class clazz;\n            try \n            {\n                clazz = Class.forName( perm.klass );\n                \n                // if we have perm.signers then we need to validate against the class certificates\n                if ( perm.signers != null )\n                {\n                    if ( validate( resolveToCertificates( keystore, perm.signers ), (Certificate[]) clazz.getSigners() ))\n                    {\n                       permissions.add( resolveToPermission( clazz, perm, evaluator ) );\n                    }                   \n                }\n                else\n                {\n                    permissions.add( resolveToPermission( clazz, perm, evaluator ) );\n                }\n            } \n            catch ( Exception e ) \n            {\n                throw new PolicyException( e );\n            }\n        }\n        \n        return permissions;\n    }","commit_id":"62ff473a501db282c893899987441f66f2313145","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private static KeyStore resolveKeyStore( KeystoreEntry entry, PropertyEvaluator evaluator ) throws PolicyException\n    {\n        try \n        {\n            KeyStore keyStore = KeyStore.getInstance( entry.type );\n            \n            URL keyStoreLocation = new URL ( entry.url );\n            \n            InputStream istream = keyStoreLocation.openStream();\n            \n            keyStore.load( istream, null );\n            \n            return keyStore;\n        }\n        catch ( KeyStoreException kse )\n        {\n            throw new PolicyException( kse );\n        }\n        catch ( MalformedURLException me )\n        {\n            throw new PolicyException( me );\n        }\n        catch ( IOException ioe )\n        {\n            throw new PolicyException( ioe );\n        }\n        catch ( NoSuchAlgorithmException e )\n        {\n            throw new PolicyException( e );\n        }\n        catch ( CertificateException ce )\n        {\n            throw new PolicyException( ce );\n        }       \n    }","id":83386,"modified_method":"private static KeyStore resolveKeyStore( KeystoreEntry entry, PropertyEvaluator evaluator ) throws PolicyException\n    {\n        KeyStore keyStore = null;\n        \n        try \n        {           \n            keyStore = KeyStore.getInstance( entry.type );\n            \n            URL keyStoreLocation = new URL ( evaluator.evaluate( entry.url ) );\n            InputStream istream = keyStoreLocation.openStream();\n            \n            keyStore.load( istream, null );\n        }\n        catch ( Exception e )\n        {\n            e.printStackTrace();\n            //throw new PolicyException( kse );\n        }\n        \n        return keyStore;\n    }","commit_id":"62ff473a501db282c893899987441f66f2313145","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * validate that all permission certs are present in the class certs\n     * \n     * @param permCerts\n     * @param classCerts\n     * @return true if the permissions match up\n     */\n    private static boolean validate( Certificate[] permCerts, Certificate[] classCerts )\n    {\n        for ( int i = 0; i < permCerts.length; ++i )\n        {\n            boolean found = false;           \n            for ( int j = 0; j < classCerts.length; ++j )\n            {\n                if ( permCerts[i].equals( classCerts[j] ) )\n                {\n                    found = true;\n                    break;\n                }\n            }\n            // if we didn't find the permCert in the classCerts then we don't match up\n            if ( found == false )\n            {\n                return false;\n            }\n        }\n        // we found all the permCerts in classCerts so return true\n        return true;\n    }","id":83387,"modified_method":"/**\n     * validate that all permission certs are present in the class certs\n     * \n     * @param permCerts\n     * @param classCerts\n     * @return true if the permissions match up\n     */\n    private static boolean validate( Certificate[] permCerts, Certificate[] classCerts )\n    {\n        if ( classCerts == null )\n        {\n            return false;\n        }\n        \n        for ( int i = 0; i < permCerts.length; ++i )\n        {\n            boolean found = false;           \n            for ( int j = 0; j < classCerts.length; ++j )\n            {\n                if ( permCerts[i].equals( classCerts[j] ) )\n                {\n                    found = true;\n                    break;\n                }\n            }\n            // if we didn't find the permCert in the classCerts then we don't match up\n            if ( found == false )\n            {\n                return false;\n            }\n        }\n        \n        // we found all the permCerts in classCerts so return true\n        return true;\n    }","commit_id":"62ff473a501db282c893899987441f66f2313145","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public PermissionCollection getPermissions( ProtectionDomain domain )\n    {     \n        PermissionCollection perms = new Permissions();\n\n        for ( Iterator<ProtectionDomain> i = pdMapping.keySet().iterator(); i.hasNext(); )\n        {\n            ProtectionDomain pd = (ProtectionDomain) i.next();\n            \n            if ( pd.getCodeSource() == null || pd.getCodeSource().implies( domain.getCodeSource() ) )\n            {         \n                // gather dynamic permissions\n                if ( pdMapping.get( pd ) != null )\n                {\n                    for ( Enumeration<Permission> e = pdMapping.get( pd ).elements(); e.hasMoreElements(); )\n                    {\n                        perms.add( e.nextElement() );\n                    }\n                }\n                \n                // gather static permissions\n                if ( pd.getPermissions() != null )\n                {\n                    for ( Enumeration<Permission> e = pd.getPermissions().elements(); e.hasMoreElements(); )\n                    {\n                        perms.add( e.nextElement() );\n                    }\n                }\n            }\n        }\n        \n        return perms;\n    }","id":83388,"modified_method":"public PermissionCollection getPermissions( ProtectionDomain domain )\n    {     \n        PermissionCollection perms = new Permissions();\n\n        for ( Iterator<ProtectionDomain> i = pdMapping.keySet().iterator(); i.hasNext(); )\n        {\n            ProtectionDomain pd = (ProtectionDomain) i.next();\n            \n            if ( pd.getCodeSource() == null || pd.getCodeSource().implies( domain.getCodeSource() ) && pd.getPrincipals() == null || validate( pd.getPrincipals(), domain.getPrincipals() ) )\n            {         \n                // gather dynamic permissions\n                if ( pdMapping.get( pd ) != null )\n                {\n                    for ( Enumeration<Permission> e = pdMapping.get( pd ).elements(); e.hasMoreElements(); )\n                    {\n                        perms.add( e.nextElement() );\n                    }\n                }\n                \n                // gather static permissions\n                if ( pd.getPermissions() != null )\n                {\n                    for ( Enumeration<Permission> e = pd.getPermissions().elements(); e.hasMoreElements(); )\n                    {\n                        perms.add( e.nextElement() );\n                    }\n                }\n            }\n        }\n        \n        return perms;\n    }","commit_id":"62ff473a501db282c893899987441f66f2313145","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * returns the value of it exists in this map, otherwise consults the System properties\n     * \n     * @param name\n     * @return\n     */\n    public String getSystemProperty(String name)\n    {       \n        \n        System.out.println(\"Prop: \" + name + \" \" + System.getProperty(name));\n        \n        if (containsKey(name))\n            return get(name);\n        return System.getProperty(name);\n    }","id":83389,"modified_method":"/**\n     * returns the value of it exists in this map, otherwise consults the System properties\n     * \n     * @param name\n     * @return\n     */\n    public String getSystemProperty(String name)\n    {       \n        \n        //System.out.println(\"Prop: \" + name + \" \" + System.getProperty(name));\n        \n        if (containsKey(name))\n            return get(name);\n        return System.getProperty(name);\n    }","commit_id":"62ff473a501db282c893899987441f66f2313145","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public FranticSalvage(UUID ownerId) {\n        super(ownerId, 6, \"Frantic Salvage\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{3}{W}\");\n        this.expansionSetCode = \"MBS\";\n\n        this.color.setWhite(true);\n\n        this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));\n        this.getSpellAbility().addEffect(new DrawCardControllerEffect(1));\n        this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(0, 0, new FilterArtifactCard(\"artifact cards from your graveyard\")));\n    }","id":83390,"modified_method":"public FranticSalvage(UUID ownerId) {\n        super(ownerId, 6, \"Frantic Salvage\", Rarity.COMMON, new CardType[]{CardType.INSTANT}, \"{3}{W}\");\n        this.expansionSetCode = \"MBS\";\n\n        this.color.setWhite(true);\n\n        this.getSpellAbility().addEffect(new PutOnLibraryTargetEffect(true));\n        this.getSpellAbility().addEffect(new DrawCardControllerEffect(1));\n        this.getSpellAbility().addTarget(new TargetCardInYourGraveyard(0, Integer.MAX_VALUE, new FilterArtifactCard(\"artifact cards from your graveyard\")));\n    }","commit_id":"f405c7dd0d4e309574266e52feef0e2c709cbd07","url":"https://github.com/magefree/mage"},{"original_method":"public HuntersFeast(UUID ownerId) {\n\t\tsuper(ownerId, 182, \"Hunters' Feast\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{3}{G}\");\n\t\tthis.expansionSetCode = \"M11\";\n\t\tthis.color.setGreen(true);\n\t\tthis.getSpellAbility().addTarget(new TargetPlayer(0));\n\t\tthis.getSpellAbility().addEffect(new GainLifeTargetEffect(6));\n\t}","id":83391,"modified_method":"public HuntersFeast(UUID ownerId) {\n\t\tsuper(ownerId, 182, \"Hunters' Feast\", Rarity.COMMON, new CardType[]{CardType.SORCERY}, \"{3}{G}\");\n\t\tthis.expansionSetCode = \"M11\";\n\t\tthis.color.setGreen(true);\n\t\tthis.getSpellAbility().addTarget(new TargetPlayer(0, Integer.MAX_VALUE, false));\n\t\tthis.getSpellAbility().addEffect(new GainLifeTargetEffect(6));\n\t}","commit_id":"f405c7dd0d4e309574266e52feef0e2c709cbd07","url":"https://github.com/magefree/mage"},{"original_method":"public InameDeathAspectEffect() {\r\n\t\tsuper(new TargetCardInLibrary(0, 0, filter), Constants.Outcome.Neutral);\r\n\t\tstaticText = \"search your library for any number of Spirit cards and put them into your graveyard. If you do, shuffle your library\";\r\n    }","id":83392,"modified_method":"public InameDeathAspectEffect() {\r\n\t\tsuper(new TargetCardInLibrary(0, Integer.MAX_VALUE, filter), Constants.Outcome.Neutral);\r\n\t\tstaticText = \"search your library for any number of Spirit cards and put them into your graveyard. If you do, shuffle your library\";\r\n    }","commit_id":"f405c7dd0d4e309574266e52feef0e2c709cbd07","url":"https://github.com/magefree/mage"},{"original_method":"public InameLifeAspect(UUID ownerId) {\r\n        super(ownerId, 215, \"Iname, Life Aspect\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{4}{G}{G}\");\r\n        this.expansionSetCode = \"CHK\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Spirit\");\r\n        this.color.setGreen(true);\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(4);\r\n        Ability ability = new DiesTriggeredAbility(new ExileSourceEffect(), true);\r\n        ability.addEffect(new ReturnToHandTargetEffect());\r\n        ability.addTarget(new TargetCardInYourGraveyard(0, 0, filter));\r\n        this.addAbility(ability);\r\n    }","id":83393,"modified_method":"public InameLifeAspect(UUID ownerId) {\r\n        super(ownerId, 215, \"Iname, Life Aspect\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{4}{G}{G}\");\r\n        this.expansionSetCode = \"CHK\";\r\n        this.supertype.add(\"Legendary\");\r\n        this.subtype.add(\"Spirit\");\r\n        this.color.setGreen(true);\r\n        this.power = new MageInt(4);\r\n        this.toughness = new MageInt(4);\r\n        Ability ability = new DiesTriggeredAbility(new ExileSourceEffect(), true);\r\n        ability.addEffect(new ReturnToHandTargetEffect());\r\n        ability.addTarget(new TargetCardInYourGraveyard(0, Integer.MAX_VALUE, filter));\r\n        this.addAbility(ability);\r\n    }","commit_id":"f405c7dd0d4e309574266e52feef0e2c709cbd07","url":"https://github.com/magefree/mage"},{"original_method":"public JaceMemoryAdept(UUID ownerId) {\r\n\t\tsuper(ownerId, 58, \"Jace, Memory Adept\", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, \"{3}{U}{U}\");\r\n\t\tthis.expansionSetCode = \"M12\";\r\n\t\tthis.supertype.add(\"Jace\");\r\n\r\n\t\tthis.color.setBlue(true);\r\n\r\n\t\tthis.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.LOYALTY.createInstance(4))));\r\n\r\n\t\t// +1: Draw a card. Target player puts the top card of his or her library into his or her graveyard.\r\n\t\tLoyaltyAbility ability1 = new LoyaltyAbility(new DrawCardControllerEffect(1), 1);\r\n\t\tability1.addEffect(new PutLibraryIntoGraveTargetEffect(1));\r\n\t\tability1.addTarget(new TargetPlayer());\r\n\t\tthis.addAbility(ability1);\r\n\r\n\t\t// 0: Target player puts the top ten cards of his or her library into his or her graveyard.\r\n\t\tLoyaltyAbility ability2 = new LoyaltyAbility(new PutLibraryIntoGraveTargetEffect(10), 0);\r\n\t\tability2.addTarget(new TargetPlayer());\r\n\t\tthis.addAbility(ability2);\r\n\r\n\t\t// -7: Any number of target players each draw twenty cards.\r\n\t\tLoyaltyAbility ability3 = new LoyaltyAbility(new JaceMemoryAdeptEffect(20), -7);\r\n\t\tability3.addTarget(new TargetPlayer(0)); //any number\r\n\t\tthis.addAbility(ability3);\r\n\t}","id":83394,"modified_method":"public JaceMemoryAdept(UUID ownerId) {\r\n\t\tsuper(ownerId, 58, \"Jace, Memory Adept\", Rarity.MYTHIC, new CardType[]{CardType.PLANESWALKER}, \"{3}{U}{U}\");\r\n\t\tthis.expansionSetCode = \"M12\";\r\n\t\tthis.supertype.add(\"Jace\");\r\n\r\n\t\tthis.color.setBlue(true);\r\n\r\n\t\tthis.addAbility(new EntersBattlefieldAbility(new AddCountersSourceEffect(CounterType.LOYALTY.createInstance(4))));\r\n\r\n\t\t// +1: Draw a card. Target player puts the top card of his or her library into his or her graveyard.\r\n\t\tLoyaltyAbility ability1 = new LoyaltyAbility(new DrawCardControllerEffect(1), 1);\r\n\t\tability1.addEffect(new PutLibraryIntoGraveTargetEffect(1));\r\n\t\tability1.addTarget(new TargetPlayer());\r\n\t\tthis.addAbility(ability1);\r\n\r\n\t\t// 0: Target player puts the top ten cards of his or her library into his or her graveyard.\r\n\t\tLoyaltyAbility ability2 = new LoyaltyAbility(new PutLibraryIntoGraveTargetEffect(10), 0);\r\n\t\tability2.addTarget(new TargetPlayer());\r\n\t\tthis.addAbility(ability2);\r\n\r\n\t\t// -7: Any number of target players each draw twenty cards.\r\n\t\tLoyaltyAbility ability3 = new LoyaltyAbility(new JaceMemoryAdeptEffect(20), -7);\r\n\t\tability3.addTarget(new TargetPlayer(0, Integer.MAX_VALUE, false)); //any number\r\n\t\tthis.addAbility(ability3);\r\n\t}","commit_id":"f405c7dd0d4e309574266e52feef0e2c709cbd07","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        TargetSpell target = new TargetSpell(new FilterSpell(\"spell to exile\"));\n        while(game.getPlayer(source.getControllerId()).choose(Outcome.Exile, target, source.getSourceId(), game)){\n            game.getStack().getSpell(target.getFirstTarget()).moveToExile(null, null, source.getId(), game);\n            target.clearChosen();\n        }\n        return true;\n    }","id":83395,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        int affectedTargets = 0;\n\t\tif (targetPointer.getTargets(source).size() > 0) {\n\t\t\tfor (UUID spellId : targetPointer.getTargets(source)) {\n\t\t\t\tSpell spell = game.getStack().getSpell(spellId);\n\t\t\t\tif (spell != null) {\n\t\t\t\t\tspell.moveToExile(null, null, source.getId(), game);\n\t\t\t\t\taffectedTargets++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn affectedTargets > 0;\n    }","commit_id":"f405c7dd0d4e309574266e52feef0e2c709cbd07","url":"https://github.com/magefree/mage"},{"original_method":"public MindbreakTrap(UUID ownerId) {\n        super(ownerId, 57, \"Mindbreak Trap\", Rarity.MYTHIC, new CardType[]{CardType.INSTANT}, \"{2}{U}{U}\");\n        this.expansionSetCode = \"ZEN\";\n        this.subtype.add(\"Trap\");\n\n        this.color.setBlue(true);\n\n        // If an opponent cast three or more spells this turn, you may pay {0} rather than pay Mindbreak Trap's mana cost.\n        this.getSpellAbility().addAlternativeCost(\n                new MindbreakTrapAlternativeCost());\n        this.addWatcher(new MindbreakTrapWatcher());\n        // Exile any number of target spells.\n        this.getSpellAbility().addEffect(new MindbreakEffect());\n    }","id":83396,"modified_method":"public MindbreakTrap(UUID ownerId) {\n        super(ownerId, 57, \"Mindbreak Trap\", Rarity.MYTHIC, new CardType[]{CardType.INSTANT}, \"{2}{U}{U}\");\n        this.expansionSetCode = \"ZEN\";\n        this.subtype.add(\"Trap\");\n\n        this.color.setBlue(true);\n\n        // If an opponent cast three or more spells this turn, you may pay {0} rather than pay Mindbreak Trap's mana cost.\n        this.getSpellAbility().addAlternativeCost(\n                new MindbreakTrapAlternativeCost());\n        this.addWatcher(new MindbreakTrapWatcher());\n        // Exile any number of target spells.\n        this.getSpellAbility().addTarget(new TargetSpell(0, Integer.MAX_VALUE, filter));\n        this.getSpellAbility().addEffect(new MindbreakEffect());\n    }","commit_id":"f405c7dd0d4e309574266e52feef0e2c709cbd07","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            Card spellCard = game.getStack().getSpell(source.getSourceId()).getCard();\n            if (spellCard != null) {\n                Player owner = game.getPlayer(spellCard.getOwnerId());\n                if (owner != null) {\n                    controller.moveCardToLibraryWithInfo(spellCard, source.getSourceId(), game, Zone.STACK, true, true);\n                    owner.shuffleLibrary(game);\n                }\n            }\n            return true;\n        }\n        return false;\n    }","id":83397,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            Spell spell = game.getStack().getSpell(source.getSourceId());\n            if (spell != null) {\n                Card spellCard = spell.getCard();\n                if (spellCard != null) {\n                    Player owner = game.getPlayer(spellCard.getOwnerId());\n                    if (owner != null) {\n                        controller.moveCardToLibraryWithInfo(spellCard, source.getSourceId(), game, Zone.STACK, true, true);\n                        owner.shuffleLibrary(game);\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"42cf7f1f4e7087cca0bf09f5bc8e4cbef9876ceb","url":"https://github.com/magefree/mage"},{"original_method":"public Burnout(UUID ownerId) {\n        super(ownerId, 101, \"Burnout\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{R}\");\n        this.expansionSetCode = \"ALL\";\n\n        // Counter target instant spell if it's blue.\n        this.getSpellAbility().addTarget(new TargetSpell(filter));\n        this.getSpellAbility().addEffect(new BurnoutCounterTargetEffect());\n\n        // Draw a card at the beginning of the next turn's upkeep.\n        this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(\n                new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1), Duration.OneUse), false));\n    }","id":83398,"modified_method":"public Burnout(UUID ownerId) {\n        super(ownerId, 101, \"Burnout\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{R}\");\n        this.expansionSetCode = \"ALL\";\n\n        // Counter target instant spell if it's blue.\n        Effect effect = new BurnoutCounterTargetEffect();\n        effect.setText(\"Counter target instant spell if it's blue\");\n        this.getSpellAbility().addTarget(new TargetSpell(filter));\n        this.getSpellAbility().addEffect(effect);\n\n        // Draw a card at the beginning of the next turn's upkeep.\n        this.getSpellAbility().addEffect(new CreateDelayedTriggeredAbilityEffect(\n                new AtTheBeginOfNextUpkeepDelayedTriggeredAbility(new DrawCardSourceControllerEffect(1), Duration.OneUse), false));\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        if(game.getStack().getSpell(source.getFirstTarget()).getColor(game).isBlue()){\n            game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);\n        }\n        return true;\n    }","id":83399,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Spell targetSpell = game.getStack().getSpell(source.getFirstTarget());\n        if(targetSpell != null && targetSpell.getColor(game).isBlue()){\n            game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);\n        }\n        return true;\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"public CaveSense(UUID ownerId) {\n        super(ownerId, 179, \"Cave Sense\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{1}{R}\");\n        this.expansionSetCode = \"MMQ\";\n        this.subtype.add(\"Aura\");\n\n        // Enchant creature\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\n        this.addAbility(ability);\n        \n        // Enchanted creature gets +1/+1 and has mountainwalk.\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 1)));\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(new MountainwalkAbility(), AttachmentType.AURA)));\n    }","id":83400,"modified_method":"public CaveSense(UUID ownerId) {\n        super(ownerId, 179, \"Cave Sense\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{1}{R}\");\n        this.expansionSetCode = \"MMQ\";\n        this.subtype.add(\"Aura\");\n\n        // Enchant creature\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\n        this.addAbility(ability);\n        \n        // Enchanted creature gets +1/+1 and has mountainwalk.\n        Effect effect = new GainAbilityAttachedEffect(new MountainwalkAbility(), AttachmentType.AURA);\n        effect.setText(\"and has mountainwalk\");\n        ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 1));\n        ability.addEffect(effect);\n        this.addAbility(ability);\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        for (Cost cost : source.getCosts()) {\n            if (cost instanceof SacrificeTargetCost) {\n                Permanent sacrificedCreature = ((SacrificeTargetCost) cost).getPermanents().get(0);\n                Permanent sourceCreature = game.getPermanent(source.getSourceId());\n                if (sacrificedCreature.hasSubtype(\"Thrull\") && sourceCreature != null) {\n                    sourceCreature.addCounters(CounterType.P1P0.createInstance(), game);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":83401,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        for (Cost cost : source.getCosts()) {\n            if (cost instanceof SacrificeTargetCost) {\n                Permanent sacrificedCreature = ((SacrificeTargetCost) cost).getPermanents().get(0);\n                Permanent sourceCreature = game.getPermanent(source.getSourceId());\n                if (sacrificedCreature.hasSubtype(\"Thrull\") && sourceCreature != null) {\n                    sourceCreature.addCounters(CounterType.P1P0.createInstance(), game);\n                    return true;\n                }\n            }\n        }\n        return true;\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        for (Cost cost : source.getCosts()) {\r\n            if (cost instanceof SacrificeTargetCost) {\r\n                Permanent sacrificedCreature = ((SacrificeTargetCost) cost).getPermanents().get(0);\r\n                Permanent sourceCreature = game.getPermanent(source.getSourceId());\r\n                if (sacrificedCreature.hasSubtype(\"Human\") && sourceCreature != null) {\r\n                    sourceCreature.addCounters(CounterType.P1P1.createInstance(), game);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":83402,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        for (Cost cost : source.getCosts()) {\n            if (cost instanceof SacrificeTargetCost) {\n                Permanent sacrificedCreature = ((SacrificeTargetCost) cost).getPermanents().get(0);\n                Permanent sourceCreature = game.getPermanent(source.getSourceId());\n                if (sacrificedCreature.hasSubtype(\"Human\") && sourceCreature != null) {\n                    sourceCreature.addCounters(CounterType.P1P1.createInstance(), game);\n                    return true;\n                }\n            }\n        }\n        return true;\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"public HauntedCrossroads(UUID ownerId) {\n        super(ownerId, 138, \"Haunted Crossroads\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{B}\");\n        this.expansionSetCode = \"MMQ\";\n\n        // {B}: Put target creature card from your graveyard on top of your library.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutOnLibraryTargetEffect(true), new ManaCostsImpl(\"{B}\"));\n        ability.addTarget(new TargetCardInGraveyard(new FilterCreatureCard(\"creature card from your graveyard\")));\n        this.addAbility(ability);\n    }","id":83403,"modified_method":"public HauntedCrossroads(UUID ownerId) {\n        super(ownerId, 138, \"Haunted Crossroads\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{B}\");\n        this.expansionSetCode = \"MMQ\";\n\n        // {B}: Put target creature card from your graveyard on top of your library.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new PutOnLibraryTargetEffect(true), new ManaCostsImpl(\"{B}\"));\n        ability.addTarget(new TargetCardInYourGraveyard(new FilterCreatureCard(\"creature card from your graveyard\")));\n        this.addAbility(ability);\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Permanent permanent = game.getPermanent(getTargetPointer().getFirst(game, source));\r\n        if (permanent != null && controller != null) {\r\n            permanent.destroy(source.getSourceId(), game, false);\r\n            if (permanent.getSupertype().contains(\"Snow\")) {\r\n                Player player = game.getPlayer(permanent.getControllerId());\r\n                if (player != null) {\r\n                    player.damage(1, source.getSourceId(), game, false, true);\r\n                }                \r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":83404,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        Permanent permanent = game.getPermanent(getTargetPointer().getFirst(game, source));\n        if (permanent != null && controller != null) {\n            permanent.destroy(source.getSourceId(), game, false);\n            if (permanent.getSupertype().contains(\"Snow\")) {\n                controller.damage(1, source.getSourceId(), game, false, true);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        if(game.getStack().getSpell(source.getFirstTarget()).getColor(game).isBlue()){\r\n            game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);\r\n        }\r\n        return true;\r\n    }","id":83405,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Spell targetSpell = game.getStack().getSpell(source.getFirstTarget());\n        if(targetSpell != null && targetSpell.getColor(game).isBlue()){\n            game.getStack().counter(source.getFirstTarget(), source.getSourceId(), game);\n        }\n        return true;\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"public ScarwoodHag(UUID ownerId) {\n        super(ownerId, 49, \"Scarwood Hag\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{1}{G}\");\n        this.expansionSetCode = \"DRK\";\n        this.subtype.add(\"Hag\");\n        this.power = new MageInt(1);\n        this.toughness = new MageInt(1);\n\n        // {G}{G}{G}{G}, {tap}: Target creature gains forestwalk until end of turn.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,\n                new GainAbilityTargetEffect(new ForestwalkAbility(false), Duration.EndOfTurn),\n                new ManaCostsImpl(\"{G}{G}{G}{G}\"));\n        ability.addCost(new TapSourceCost());\n        ability.addTarget(new TargetCreaturePermanent());\n        this.addAbility(ability);\n\n        // {tap}: Target creature loses forestwalk until end of turn.\n        ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,\n                new LoseAbilityTargetEffect(new ForestwalkAbility(false), Duration.EndOfTurn),\n                new TapSourceCost());\n        ability.addTarget(new TargetCreaturePermanent());\n        this.addAbility(ability);\n    }","id":83406,"modified_method":"public ScarwoodHag(UUID ownerId) {\n        super(ownerId, 49, \"Scarwood Hag\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{1}{G}\");\n        this.expansionSetCode = \"DRK\";\n        this.subtype.add(\"Hag\");\n        this.power = new MageInt(1);\n        this.toughness = new MageInt(1);\n\n        // {G}{G}{G}{G}, {tap}: Target creature gains forestwalk until end of turn.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,\n                new GainAbilityTargetEffect(new ForestwalkAbility(false), Duration.EndOfTurn),\n                new ManaCostsImpl(\"{G}{G}{G}{G}\"));\n        ability.addCost(new TapSourceCost());\n        ability.addTarget(new TargetCreaturePermanent());\n        this.addAbility(ability);\n\n        // {tap}: Target creature loses forestwalk until end of turn.\n        Effect effect = new LoseAbilityTargetEffect(new ForestwalkAbility(true), Duration.EndOfTurn);\n        effect.setText(\"Target creature loses forestwalk until end of turn\");\n        ability = new SimpleActivatedAbility(Zone.BATTLEFIELD,\n                effect,\n                new TapSourceCost());\n        ability.addTarget(new TargetCreaturePermanent());\n        this.addAbility(ability);\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        Permanent permanent = game.getPermanent(getTargetPointer().getFirst(game, source));\n        if (permanent != null && controller != null) {\n            permanent.destroy(source.getSourceId(), game, false);\n            if (permanent.getSupertype().contains(\"Snow\")) {\n                Player player = game.getPlayer(source.getControllerId());\n                if (player != null) {\n                    player.gainLife(1, game);\n                }\n            }\n            return true;\n        }\n        return false;\n    }","id":83407,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player controller = game.getPlayer(source.getControllerId());\n        Permanent permanent = game.getPermanent(getTargetPointer().getFirst(game, source));\n        if (permanent != null && controller != null) {\n            permanent.destroy(source.getSourceId(), game, false);\n            if (permanent.getSupertype().contains(\"Snow\")) {\n                controller.gainLife(1, game);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"public TigerClaws(UUID ownerId) {\n        super(ownerId, 279, \"Tiger Claws\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{G}\");\n        this.expansionSetCode = \"MMQ\";\n        this.subtype.add(\"Aura\");\n\n        // Flash\n        this.addAbility(FlashAbility.getInstance());\n        \n        // Enchant creature\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\n        this.addAbility(ability);\n        \n        // Enchanted creature gets +1/+1 and has trample.\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 1)));\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.AURA)));\n    }","id":83408,"modified_method":"public TigerClaws(UUID ownerId) {\n        super(ownerId, 279, \"Tiger Claws\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{G}\");\n        this.expansionSetCode = \"MMQ\";\n        this.subtype.add(\"Aura\");\n\n        // Flash\n        this.addAbility(FlashAbility.getInstance());\n        \n        // Enchant creature\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\n        this.addAbility(ability);\n        \n        // Enchanted creature gets +1/+1 and has trample.\n        Effect effect = new GainAbilityAttachedEffect(TrampleAbility.getInstance(), AttachmentType.AURA);\n        effect.setText(\"and has trample\");\n        ability = new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEnchantedEffect(1, 1));\n        ability.addEffect(effect);\n        this.addAbility(ability);\n    }","commit_id":"3c8c439d19b27c41b35f7b367fce0c5c627c926e","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public JetTypeInfo visitConstantExpression(JetConstantExpression expression, ExpressionTypingContext context) {\n        ASTNode node = expression.getNode();\n        IElementType elementType = node.getElementType();\n        String text = node.getText();\n        KotlinBuiltIns builtIns = KotlinBuiltIns.getInstance();\n        CompileTimeConstantResolver compileTimeConstantResolver = context.getCompileTimeConstantResolver();\n\n        if (context.expectedType == UNKNOWN_EXPECTED_TYPE) {\n            if (elementType == JetNodeTypes.INTEGER_CONSTANT) {\n                Long longValue = CompileTimeConstantResolver.parseLongValue(text);\n                if (longValue != null) {\n                    return createNumberValueTypeInfo(IntegerValueTypeConstructor.create(longValue), longValue, context.dataFlowInfo);\n                }\n            }\n            else if (elementType == JetNodeTypes.FLOAT_CONSTANT) {\n                Double doubleValue = CompileTimeConstantResolver.parseDoubleValue(text);\n                if (doubleValue != null) {\n                    return createNumberValueTypeInfo(DoubleValueTypeConstructor.create(doubleValue), doubleValue, context.dataFlowInfo);\n                }\n            }\n        }\n\n        CompileTimeConstant<?> value;\n        if (elementType == JetNodeTypes.INTEGER_CONSTANT) {\n            value = compileTimeConstantResolver.getIntegerValue(text, context.expectedType);\n        }\n        else if (elementType == JetNodeTypes.FLOAT_CONSTANT) {\n            value = compileTimeConstantResolver.getFloatValue(text, context.expectedType);\n        }\n        else if (elementType == JetNodeTypes.BOOLEAN_CONSTANT) {\n            value = compileTimeConstantResolver.getBooleanValue(text, context.expectedType);\n        }\n        else if (elementType == JetNodeTypes.CHARACTER_CONSTANT) {\n            value = compileTimeConstantResolver.getCharValue(text, context.expectedType);\n        }\n        else if (elementType == JetNodeTypes.NULL) {\n            value = compileTimeConstantResolver.getNullValue(context.expectedType);\n        }\n        else {\n            throw new IllegalArgumentException(\"Unsupported constant: \" + expression);\n        }\n        if (value instanceof ErrorValue) {\n            ErrorValue errorValue = (ErrorValue) value;\n            context.trace.report(ERROR_COMPILE_TIME_VALUE.on(node.getPsi(), errorValue.getMessage()));\n            return JetTypeInfo.create(getDefaultType(elementType), context.dataFlowInfo);\n        }\n        else {\n            context.trace.record(BindingContext.COMPILE_TIME_VALUE, expression, value);\n            return DataFlowUtils.checkType(value.getType(builtIns), expression, context, context.dataFlowInfo);\n        }\n    }","id":83409,"modified_method":"@Override\n    public JetTypeInfo visitConstantExpression(JetConstantExpression expression, ExpressionTypingContext context) {\n        IElementType elementType = expression.getNode().getElementType();\n        String text = expression.getNode().getText();\n        KotlinBuiltIns builtIns = KotlinBuiltIns.getInstance();\n        CompileTimeConstantResolver compileTimeConstantResolver = context.getCompileTimeConstantResolver();\n\n        if (context.expectedType == UNKNOWN_EXPECTED_TYPE) {\n            if (elementType == JetNodeTypes.INTEGER_CONSTANT) {\n                Long longValue = CompileTimeConstantResolver.parseLongValue(text);\n                if (longValue != null) {\n                    return createNumberValueTypeInfo(IntegerValueTypeConstructor.create(longValue), longValue, context.dataFlowInfo);\n                }\n            }\n            else if (elementType == JetNodeTypes.FLOAT_CONSTANT) {\n                Double doubleValue = CompileTimeConstantResolver.parseDoubleValue(text);\n                if (doubleValue != null) {\n                    return createNumberValueTypeInfo(DoubleValueTypeConstructor.create(doubleValue), doubleValue, context.dataFlowInfo);\n                }\n            }\n        }\n\n        CompileTimeConstant<?> value = compileTimeConstantResolver.getCompileTimeConstant(expression, context.expectedType);\n        if (value instanceof ErrorValue) {\n            if (context.expectedType != UNKNOWN_EXPECTED_TYPE) {\n                context.trace.report(ERROR_COMPILE_TIME_VALUE.on(expression, ((ErrorValue) value).getMessage()));\n            }\n            return JetTypeInfo.create(getDefaultType(elementType), context.dataFlowInfo);\n        }\n        context.trace.record(BindingContext.COMPILE_TIME_VALUE, expression, value);\n        return DataFlowUtils.checkType(value.getType(builtIns), expression, context, context.dataFlowInfo);\n    }","commit_id":"f2746b835ea00c30e883031f62abd1f644eb6751","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public <D extends CallableDescriptor> JetType completeNestedCallsInference(\n            @NotNull CallCandidateResolutionContext<D> context\n    ) {\n        ResolvedCallImpl<D> resolvedCall = context.candidateCall;\n        ConstraintSystem constraintSystem = context.candidateCall.getConstraintSystem();\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : resolvedCall.getValueArguments().entrySet()) {\n            ValueParameterDescriptor parameterDescriptor = entry.getKey();\n            ResolvedValueArgument resolvedArgument = entry.getValue();\n\n            for (ValueArgument argument : resolvedArgument.getArguments()) {\n                JetExpression expression = argument.getArgumentExpression();\n                if (expression == null) continue;\n\n                JetType effectiveExpectedType = getEffectiveExpectedType(parameterDescriptor, argument);\n                JetType expectedType = constraintSystem != null\n                                       ? constraintSystem.getCurrentSubstitutor().substitute(effectiveExpectedType, Variance.INVARIANT)\n                                       : effectiveExpectedType;\n\n                JetVisitor<JetExpression, Void> selectorExpressionFinder = new JetVisitor<JetExpression, Void>() {\n                    @Override\n                    public JetExpression visitQualifiedExpression(JetQualifiedExpression expression, Void data) {\n                        JetExpression selector = expression.getSelectorExpression();\n                        return selector != null ? selector.accept(this, null) : null;\n                    }\n\n                    @Override\n                    public JetExpression visitExpression(JetExpression expression, Void data) {\n                        return expression;\n                    }\n                };\n                JetExpression selectorExpression = expression.accept(selectorExpressionFinder, null);\n\n                CallCandidateResolutionContext<FunctionDescriptor> storedContextForArgument =\n                        context.resolutionResultsCache.getDeferredComputation(CallKey.create(Call.CallType.DEFAULT, selectorExpression));\n                //todo assert storedContextForArgument != null\n                if (storedContextForArgument == null) {\n                    PsiElement parent = expression.getParent();\n                    if (parent instanceof JetWhenExpression && expression == ((JetWhenExpression) parent).getSubjectExpression()\n                        || (expression instanceof JetFunctionLiteralExpression)) {\n                        continue;\n                    }\n                    JetType type = context.trace.get(BindingContext.EXPRESSION_TYPE, expression);\n                    DataFlowInfo dataFlowInfoForValueArgument = resolvedCall.getDataFlowInfoForValueArgument(argument);\n                    ResolutionContext<?> newContext = context.replaceExpectedType(expectedType);\n                    if (dataFlowInfoForValueArgument != null) {\n                        newContext = newContext.replaceDataFlowInfo(dataFlowInfoForValueArgument);\n                    }\n                    if (type != null && !type.getConstructor().isDenotable()) {\n                        if (type.getConstructor() instanceof NumberValueTypeConstructor) {\n                            NumberValueTypeConstructor constructor = (NumberValueTypeConstructor) type.getConstructor();\n                            type = ConstantUtils.updateConstantValueType(constructor, expectedType, expression, context);\n                        }\n                    }\n                    DataFlowUtils.checkType(type, expression, newContext);\n                    continue;\n                }\n\n                CallCandidateResolutionContext<FunctionDescriptor> contextForArgument =\n                        storedContextForArgument.replaceResolveMode(ResolveMode.TOP_LEVEL_CALL).replaceBindingTrace(context.trace).replaceExpectedType(expectedType);\n                JetType type;\n                if (contextForArgument.candidateCall.hasIncompleteTypeParameters()) {\n                    type = completeTypeInferenceDependentOnExpectedTypeForCall(contextForArgument, true);\n                }\n                else {\n                    type = completeNestedCallsInference(contextForArgument);\n                    checkValueArgumentTypes(contextForArgument);\n                }\n\n                DataFlowUtils.checkType(type, expression, contextForArgument);\n            }\n        }\n        recordReferenceForInvokeFunction(context);\n        return resolvedCall.getResultingDescriptor().getReturnType();\n    }","id":83410,"modified_method":"@Nullable\n    public <D extends CallableDescriptor> JetType completeNestedCallsInference(\n            @NotNull CallCandidateResolutionContext<D> context\n    ) {\n        ResolvedCallImpl<D> resolvedCall = context.candidateCall;\n        ConstraintSystem constraintSystem = context.candidateCall.getConstraintSystem();\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : resolvedCall.getValueArguments().entrySet()) {\n            ValueParameterDescriptor parameterDescriptor = entry.getKey();\n            ResolvedValueArgument resolvedArgument = entry.getValue();\n\n            for (ValueArgument argument : resolvedArgument.getArguments()) {\n                JetExpression expression = argument.getArgumentExpression();\n                if (expression == null) continue;\n\n                JetType effectiveExpectedType = getEffectiveExpectedType(parameterDescriptor, argument);\n                JetType expectedType = constraintSystem != null\n                                       ? constraintSystem.getCurrentSubstitutor().substitute(effectiveExpectedType, Variance.INVARIANT)\n                                       : effectiveExpectedType;\n\n                JetVisitor<JetExpression, Void> selectorExpressionFinder = new JetVisitor<JetExpression, Void>() {\n                    @Override\n                    public JetExpression visitQualifiedExpression(JetQualifiedExpression expression, Void data) {\n                        JetExpression selector = expression.getSelectorExpression();\n                        return selector != null ? selector.accept(this, null) : null;\n                    }\n\n                    @Override\n                    public JetExpression visitExpression(JetExpression expression, Void data) {\n                        return expression;\n                    }\n                };\n                JetExpression selectorExpression = expression.accept(selectorExpressionFinder, null);\n\n                CallCandidateResolutionContext<FunctionDescriptor> storedContextForArgument =\n                        context.resolutionResultsCache.getDeferredComputation(CallKey.create(Call.CallType.DEFAULT, selectorExpression));\n                //todo assert storedContextForArgument != null\n                if (storedContextForArgument == null) {\n                    PsiElement parent = expression.getParent();\n                    if (parent instanceof JetWhenExpression && expression == ((JetWhenExpression) parent).getSubjectExpression()\n                        || (expression instanceof JetFunctionLiteralExpression)) {\n                        continue;\n                    }\n                    JetType type = context.trace.get(BindingContext.EXPRESSION_TYPE, expression);\n                    DataFlowInfo dataFlowInfoForValueArgument = resolvedCall.getDataFlowInfoForValueArgument(argument);\n                    ResolutionContext<?> newContext = context.replaceExpectedType(expectedType);\n                    if (dataFlowInfoForValueArgument != null) {\n                        newContext = newContext.replaceDataFlowInfo(dataFlowInfoForValueArgument);\n                    }\n                    if (type != null && !type.getConstructor().isDenotable()) {\n                        if (type.getConstructor() instanceof NumberValueTypeConstructor) {\n                            NumberValueTypeConstructor constructor = (NumberValueTypeConstructor) type.getConstructor();\n                            type = ConstantUtils.updateConstantValueType(constructor, expectedType, expression, context);\n                        }\n                    }\n                    if (expression instanceof JetConstantExpression && !KotlinBuiltIns.getInstance().isUnit(expectedType)) {\n                        CompileTimeConstant<?> value =\n                                new CompileTimeConstantResolver().getCompileTimeConstant((JetConstantExpression) expression, expectedType);\n                        if (value instanceof ErrorValue) {\n                            context.trace.report(ERROR_COMPILE_TIME_VALUE.on(expression, ((ErrorValue) value).getMessage()));\n                        }\n                    }\n                    else {\n                        DataFlowUtils.checkType(type, expression, newContext);\n                    }\n                    continue;\n                }\n\n                CallCandidateResolutionContext<FunctionDescriptor> contextForArgument =\n                        storedContextForArgument.replaceResolveMode(ResolveMode.TOP_LEVEL_CALL).replaceBindingTrace(context.trace).replaceExpectedType(expectedType);\n                JetType type;\n                if (contextForArgument.candidateCall.hasIncompleteTypeParameters()) {\n                    type = completeTypeInferenceDependentOnExpectedTypeForCall(contextForArgument, true);\n                }\n                else {\n                    type = completeNestedCallsInference(contextForArgument);\n                    checkValueArgumentTypes(contextForArgument);\n                }\n\n                DataFlowUtils.checkType(type, expression, contextForArgument);\n            }\n        }\n        recordReferenceForInvokeFunction(context);\n        return resolvedCall.getResultingDescriptor().getReturnType();\n    }","commit_id":"f2746b835ea00c30e883031f62abd1f644eb6751","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private ArtifactRepository getLocalRepository(MavenBuildInformation mavenBuildInformation, MavenProject parent, MavenProject pom) {\n        \n        if (mavenBuildInformation.isMaven3OrLater()) {\n            return parent.getProjectBuildingRequest().getLocalRepository();\n        } else if (mavenBuildInformation.isAtLeastMavenVersion(\"2.2\")) {\n            // principally this should also work with Maven 2.1, but it's not tested, so err on the safe side\n            return getArtifactRepositoryMaven21(pom);\n        } else if (mavenBuildInformation.isAtLeastMavenVersion(\"2.0\")) {\n         // Maven 2.0 has no corresponding mechanism\n            return null;\n\t\t} else {\n\t\t    LOGGER.warning(\"Unknown Maven version: \"+mavenBuildInformation.getMavenVersion());\n\t\t    return null;\n\t\t}\n\t}","id":83411,"modified_method":"private ArtifactRepository getLocalRepository(MavenBuildInformation mavenBuildInformation, MavenProject pom) {\n        if (mavenBuildInformation.isMaven3OrLater()) {\n            return pom.getProjectBuildingRequest().getLocalRepository();\n        } else if (mavenBuildInformation.isAtLeastMavenVersion(\"2.2\")) {\n            // principally this should also work with Maven 2.1, but it's not tested, so err on the safe side\n            return getArtifactRepositoryMaven21(pom);\n        } else if (mavenBuildInformation.isAtLeastMavenVersion(\"2.0\")) {\n         // Maven 2.0 has no corresponding mechanism\n            return null;\n\t\t} else {\n\t\t    LOGGER.warning(\"Unknown Maven version: \"+mavenBuildInformation.getMavenVersion());\n\t\t    return null;\n\t\t}\n\t}","commit_id":"0c4fe2ddbac2963c0b633fe27bb1a6016134da50","url":"https://github.com/kohsuke/hudson"},{"original_method":"private void recordParents(MavenBuildProxy build, MavenProject pom, BuildListener listener) throws IOException, InterruptedException {\n\t\tMavenProject parent = getParent(pom, listener);\n\t\twhile (parent != null) {\n\t\t\tFile parentFile = parent.getFile();\n\n\t\t\tif (parentFile == null) {\n\t\t\t\t// Parent artifact contains no actual file, so we resolve against\n\t\t\t\t// the local repository\n\t\t\t\tArtifactRepository localRepository = getLocalRepository(build.getMavenBuildInformation(), parent, pom);\n\t\t\t\tif (localRepository != null) {\n\t\t\t\t    Artifact parentArtifact = getArtifact(parent);\n\t\t\t\t\t// Don't use ArtifactRepository.find(), for compatibility with Maven 2.x\n\t\t\t\t    if (parentArtifact != null) {\n\t\t\t\t        parentFile = new File(localRepository.getBasedir(),\n\t\t\t\t\t\t\tlocalRepository.pathOf(parentArtifact));\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (parentFile != null) {\n    \t\t\t// we need to include the artifact Id for poms as well, otherwise a\n    \t\t\t// project with the same groupId would override its parent's\n    \t\t\t// fingerprint\n    \t\t\trecord(parent.getGroupId() + \":\" + parent.getArtifactId(),\n    \t\t\t\t\tparentFile, used);\n\t\t\t}\n\t\t\tparent = getParent(parent, listener);\n\t\t}\n\t}","id":83412,"modified_method":"private void recordParents(MavenBuildProxy build, MavenProject pom, BuildListener listener) throws IOException, InterruptedException {\n        Map<String,String> modelParents = build.getMavenBuildInformation().modelParents;\n        ArtifactRepository localRepository = getLocalRepository(build.getMavenBuildInformation(), pom);\n        if (localRepository == null) {\n            listener.error(\"Could not find local repository for \" + build.getMavenBuildInformation().getMavenVersion());\n            return;\n        }\n\t\tString parent = modelParents.get(pom.getId());\n\t\twhile (parent != null) {\n            String[] parts = parent.split(\":\");\n            assert parts.length == 4 : parent;\n            // Maven 2.x lacks DefaultArtifact constructor with String version and ArtifactRepository.find:\n            Artifact parentArtifact = new DefaultArtifact(parts[0], parts[1], VersionRange.createFromVersion(parts[3]), null, parts[2], null, new DefaultArtifactHandler(parts[2]));\n            File parentFile = new File(localRepository.getBasedir(), localRepository.pathOf(parentArtifact));\n            // we need to include the artifact Id for poms as well, otherwise a project with the same groupId would override its parent's fingerprint\n            record(parts[0] + \":\" + parts[1], parentFile, used);\n\t\t\tparent = modelParents.get(parent);\n\t\t}\n\t}","commit_id":"0c4fe2ddbac2963c0b633fe27bb1a6016134da50","url":"https://github.com/kohsuke/hudson"},{"original_method":"private void parsePoms(BuildListener listener, PrintStream logger, EnvVars envVars, MavenInstallation mvn, String mavenVersion) throws IOException, InterruptedException {\n            logger.println(\"Parsing POMs\");\n\n            List<PomInfo> poms;\n            try {\n                poms = getModuleRoot().act(new PomParser(listener, mvn, mavenVersion, envVars, MavenModuleSetBuild.this));\n            } catch (IOException e) {\n                if (project.isIncrementalBuild()) {\n                    // If POM parsing failed we should do a full build next time.\n                    // Otherwise only the modules which have a SCM change for the next build might\n                    // be build next time.\n                    getActions().add(new NeedsFullBuildAction());\n                }\n                \n                if (e.getCause() instanceof AbortException)\n                    throw (AbortException) e.getCause();\n                throw e;\n            } catch (MavenExecutionException e) {\n                // Maven failed to parse POM\n                e.getCause().printStackTrace(listener.error(Messages.MavenModuleSetBuild_FailedToParsePom()));\n                if (project.isIncrementalBuild()) {\n                    getActions().add(new NeedsFullBuildAction());\n                }\n                throw new AbortException();\n            }\n            \n            boolean needsDependencyGraphRecalculation = false;\n\n            // update the module list\n            Map<ModuleName,MavenModule> modules = project.modules;\n            synchronized(modules) {\n                Map<ModuleName,MavenModule> old = new HashMap<ModuleName, MavenModule>(modules);\n                List<MavenModule> sortedModules = new ArrayList<MavenModule>();\n\n                modules.clear();\n                if(debug)\n                    logger.println(\"Root POM is \"+poms.get(0).name);\n                project.reconfigure(poms.get(0));\n                for (PomInfo pom : poms) {\n                    MavenModule mm = old.get(pom.name);\n                    if(mm!=null) {// found an existing matching module\n                        if(debug)\n                            logger.println(\"Reconfiguring \"+mm);\n                        if (!mm.isSameModule(pom)) {\n                            needsDependencyGraphRecalculation = true;\n                        }\n                        mm.reconfigure(pom);\n                        modules.put(pom.name,mm);\n                    } else {// this looks like a new module\n                        logger.println(Messages.MavenModuleSetBuild_DiscoveredModule(pom.name,pom.displayName));\n                        mm = new MavenModule(project,pom,getNumber());\n                        mm.onCreatedFromScratch();\n                        modules.put(mm.getModuleName(),mm);\n                        needsDependencyGraphRecalculation = true;\n                    }\n                    sortedModules.add(mm);\n                    mm.save();\n                }\n                // at this point the list contains all the live modules\n                project.sortedActiveModules = sortedModules;\n\n                // remaining modules are no longer active.\n                old.keySet().removeAll(modules.keySet());\n                for (MavenModule om : old.values()) {\n                    if(debug)\n                        logger.println(\"Disabling \"+om);\n                    om.makeDisabled(true);\n                    needsDependencyGraphRecalculation = true;\n                }\n                modules.putAll(old);\n            }\n\n            // we might have added new modules\n            if (needsDependencyGraphRecalculation) {\n                logger.println(\"Modules changed, recalculating dependency graph\");\n                Jenkins.getInstance().rebuildDependencyGraph();\n            }\n\n            // module builds must start with this build's number\n            for (MavenModule m : modules.values())\n                m.updateNextBuildNumber(getNumber());\n        }","id":83413,"modified_method":"private void parsePoms(BuildListener listener, PrintStream logger, EnvVars envVars, MavenInstallation mvn, String mavenVersion, MavenBuildInformation mavenBuildInformation) throws IOException, InterruptedException {\n            logger.println(\"Parsing POMs\");\n\n            List<PomInfo> poms;\n            try {\n                PomParser.Result result = getModuleRoot().act(new PomParser(listener, mvn, mavenVersion, envVars, MavenModuleSetBuild.this));\n                poms = result.infos;\n                mavenBuildInformation.modelParents.putAll(result.modelParents);\n            } catch (IOException e) {\n                if (project.isIncrementalBuild()) {\n                    // If POM parsing failed we should do a full build next time.\n                    // Otherwise only the modules which have a SCM change for the next build might\n                    // be build next time.\n                    getActions().add(new NeedsFullBuildAction());\n                }\n                \n                if (e.getCause() instanceof AbortException)\n                    throw (AbortException) e.getCause();\n                throw e;\n            } catch (MavenExecutionException e) {\n                // Maven failed to parse POM\n                e.getCause().printStackTrace(listener.error(Messages.MavenModuleSetBuild_FailedToParsePom()));\n                if (project.isIncrementalBuild()) {\n                    getActions().add(new NeedsFullBuildAction());\n                }\n                throw new AbortException();\n            }\n            \n            boolean needsDependencyGraphRecalculation = false;\n\n            // update the module list\n            Map<ModuleName,MavenModule> modules = project.modules;\n            synchronized(modules) {\n                Map<ModuleName,MavenModule> old = new HashMap<ModuleName, MavenModule>(modules);\n                List<MavenModule> sortedModules = new ArrayList<MavenModule>();\n\n                modules.clear();\n                if(debug)\n                    logger.println(\"Root POM is \"+poms.get(0).name);\n                project.reconfigure(poms.get(0));\n                for (PomInfo pom : poms) {\n                    MavenModule mm = old.get(pom.name);\n                    if(mm!=null) {// found an existing matching module\n                        if(debug)\n                            logger.println(\"Reconfiguring \"+mm);\n                        if (!mm.isSameModule(pom)) {\n                            needsDependencyGraphRecalculation = true;\n                        }\n                        mm.reconfigure(pom);\n                        modules.put(pom.name,mm);\n                    } else {// this looks like a new module\n                        logger.println(Messages.MavenModuleSetBuild_DiscoveredModule(pom.name,pom.displayName));\n                        mm = new MavenModule(project,pom,getNumber());\n                        mm.onCreatedFromScratch();\n                        modules.put(mm.getModuleName(),mm);\n                        needsDependencyGraphRecalculation = true;\n                    }\n                    sortedModules.add(mm);\n                    mm.save();\n                }\n                // at this point the list contains all the live modules\n                project.sortedActiveModules = sortedModules;\n\n                // remaining modules are no longer active.\n                old.keySet().removeAll(modules.keySet());\n                for (MavenModule om : old.values()) {\n                    if(debug)\n                        logger.println(\"Disabling \"+om);\n                    om.makeDisabled(true);\n                    needsDependencyGraphRecalculation = true;\n                }\n                modules.putAll(old);\n            }\n\n            // we might have added new modules\n            if (needsDependencyGraphRecalculation) {\n                logger.println(\"Modules changed, recalculating dependency graph\");\n                Jenkins.getInstance().rebuildDependencyGraph();\n            }\n\n            // module builds must start with this build's number\n            for (MavenModule m : modules.values())\n                m.updateNextBuildNumber(getNumber());\n        }","commit_id":"0c4fe2ddbac2963c0b633fe27bb1a6016134da50","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected Result doRun(final BuildListener listener) throws Exception {\n            \n        \tResult r = null;\n        \tPrintStream logger = listener.getLogger();\n\n            try {\n            \t\n                EnvVars envVars = getEnvironment(listener);\n                MavenInstallation mvn = project.getMaven();\n                if(mvn==null)\n                    throw new AbortException(Messages.MavenModuleSetBuild_NoMavenConfigured());\n\n                mvn = mvn.forEnvironment(envVars).forNode(Computer.currentComputer().getNode(), listener);\n                \n                MavenInformation mavenInformation = getModuleRoot().act( new MavenVersionCallable( mvn.getHome() ));\n                \n                String mavenVersion = mavenInformation.getVersion();\n                \n                MavenBuildInformation mavenBuildInformation = new MavenBuildInformation( mavenVersion );\n                \n                setMavenVersionUsed( mavenVersion );\n\n                LOGGER.fine(getFullDisplayName()+\" is building with mavenVersion \" + mavenVersion + \" from file \" + mavenInformation.getVersionResourcePath());\n                \n                if(!project.isAggregatorStyleBuild()) {\n                    parsePoms(listener, logger, envVars, mvn, mavenVersion);\n                    // start module builds\n                    logger.println(\"Triggering \"+project.getRootModule().getModuleName());\n                    project.getRootModule().scheduleBuild(new UpstreamCause((Run<?,?>)MavenModuleSetBuild.this));\n                } else {\n                    // do builds here\n                    try {\n                        List<BuildWrapper> wrappers = new ArrayList<BuildWrapper>();\n                        for (BuildWrapper w : project.getBuildWrappersList())\n                            wrappers.add(w);\n                        ParametersAction parameters = getAction(ParametersAction.class);\n                        if (parameters != null)\n                            parameters.createBuildWrappers(MavenModuleSetBuild.this,wrappers);\n\n                        for( BuildWrapper w : wrappers) {\n                            Environment e = w.setUp(MavenModuleSetBuild.this, launcher, listener);\n                            if(e==null){\n                                setResult(r = Result.FAILURE);\n                                return r;\n                            }\n                            buildEnvironments.add(e);\n                            e.buildEnvVars(envVars); // #3502: too late for getEnvironment to do this\n                        }\n                        \n                    \t// run pre build steps\n                    \tif(!preBuild(listener,project.getPrebuilders())\n                        || !preBuild(listener,project.getPostbuilders())\n                        || !preBuild(listener,project.getPublishers())){\n                    \t\tsetResult(r = FAILURE);\n                            return r;\n                    \t}\n\n                    \tif(!build(listener,project.getPrebuilders().toList())){\n                    \t\tsetResult(r = FAILURE);\n                            return r;\n            \t\t\t}\n\n                        parsePoms(listener, logger, envVars, mvn, mavenVersion); // #5428 : do pre-build *before* parsing pom\n                        SplittableBuildListener slistener = new SplittableBuildListener(listener);\n                        proxies = new HashMap<ModuleName, ProxyImpl2>();\n                        List<ModuleName> changedModules = new ArrayList<ModuleName>();\n                        \n                        if (project.isIncrementalBuild() && !getChangeSet().isEmptySet()) {\n                            changedModules.addAll(getUnbuildModulesSinceLastSuccessfulBuild());\n                        }\n\n                        for (MavenModule m : project.sortedActiveModules) {\n                            MavenBuild mb = m.newBuild();\n                            // JENKINS-8418\n                            mb.setBuiltOnStr( getBuiltOnStr() );\n                            // Check if incrementalBuild is selected and that there are changes -\n                            // we act as if incrementalBuild is not set if there are no changes.\n                            if (!MavenModuleSetBuild.this.getChangeSet().isEmptySet()\n                                && project.isIncrementalBuild()) {\n                                //If there are changes for this module, add it.\n                                // Also add it if we've never seen this module before,\n                                // or if the previous build of this module failed or was unstable.\n                                if ((mb.getPreviousBuiltBuild() == null) ||\n                                    (!getChangeSetFor(m).isEmpty()) \n                                    || (mb.getPreviousBuiltBuild().getResult().isWorseThan(Result.SUCCESS))) {\n                                    changedModules.add(m.getModuleName());\n                                }\n                            }\n\n                            mb.setWorkspace(getModuleRoot().child(m.getRelativePath()));\n                            proxies.put(m.getModuleName(), mb.new ProxyImpl2(MavenModuleSetBuild.this,slistener));\n                        }\n\n                        // run the complete build here\n\n                        // figure out the root POM location.\n                        // choice of module root ('ws' in this method) is somewhat arbitrary\n                        // when multiple CVS/SVN modules are checked out, so also check\n                        // the path against the workspace root if that seems like what the user meant (see issue #1293)\n                        String rootPOM = project.getRootPOM(envVars); // JENKINS-13822\n                        FilePath pom = getModuleRoot().child(rootPOM);\n                        FilePath parentLoc = getWorkspace().child(rootPOM);\n                        if(!pom.exists() && parentLoc.exists())\n                            pom = parentLoc;\n\n                        \n                        final ProcessCache.MavenProcess process;\n                        \n                        boolean maven3orLater = mavenBuildInformation.isMaven3OrLater(); \n                        if ( maven3orLater )\n                        {\n                            LOGGER.fine( \"using maven 3 \" + mavenVersion );\n                            process =\n                                MavenBuild.mavenProcessCache.get( launcher.getChannel(), slistener,\n                                                                  new Maven3ProcessFactory( project, launcher, envVars, getMavenOpts(listener, envVars),\n                                                                                            pom.getParent() ) );\n                        }\n                        else\n                        {\n                            LOGGER.fine( \"using maven 2 \" + mavenVersion );\n                            process =\n                                MavenBuild.mavenProcessCache.get( launcher.getChannel(), slistener,\n                                                                  new MavenProcessFactory( project, launcher, envVars,getMavenOpts(listener, envVars),\n                                                                                           pom.getParent() ) );\n                        }\n                        ArgumentListBuilder margs = new ArgumentListBuilder().add(\"-B\").add(\"-f\", pom.getRemote());\n                        FilePath localRepo = project.getLocalRepository().locate(MavenModuleSetBuild.this);\n                        if(localRepo!=null)\n                            margs.add(\"-Dmaven.repo.local=\"+localRepo.getRemote());\n\n                        FilePath remoteSettings = SettingsProvider.getSettingsFilePath(project.getSettings(), MavenModuleSetBuild.this, listener);\n                        if (remoteSettings != null)\n                            margs.add(\"-s\" , remoteSettings.getRemote());\n\n                        FilePath remoteGlobalSettings = GlobalSettingsProvider.getSettingsFilePath(project.getGlobalSettings(), MavenModuleSetBuild.this, listener);\n                        if (remoteGlobalSettings != null)\n                            margs.add(\"-gs\" , remoteGlobalSettings.getRemote());\n                        \n                        // If incrementalBuild is set\n                        // and the previous build didn't specify that we need a full build\n                        // and we're on Maven 2.1 or later\n                        // and there's at least one module listed in changedModules,\n                        // then do the Maven incremental build commands.\n                        // If there are no changed modules, we're building everything anyway.\n                        boolean maven2_1orLater = new ComparableVersion (mavenVersion).compareTo( new ComparableVersion (\"2.1\") ) >= 0;\n                        boolean needsFullBuild = getPreviousCompletedBuild() != null &&\n                            getPreviousCompletedBuild().getAction(NeedsFullBuildAction.class) != null;\n                        if (project.isIncrementalBuild()) {\n                            if (!needsFullBuild && maven2_1orLater && !changedModules.isEmpty()) {\n                                margs.add(\"-amd\");\n                                margs.add(\"-pl\", Util.join(changedModules, \",\"));\n                            } else {\n                                if (LOGGER.isLoggable(Level.FINE)) {\n                                    LOGGER.fine(String.format(\"Skipping incremental build: needsFullBuild=%s, maven2.1orLater=%s, changedModulesEmpty?=%s\",\n                                            needsFullBuild, maven2_1orLater, changedModules.isEmpty()));\n                                }\n                            }\n                        }\n\n\n                        \n                        final List<MavenArgumentInterceptorAction> argInterceptors = this.getBuild().getActions(MavenArgumentInterceptorAction.class);\n                        \n\t\t\t\t\t\t// find the correct maven goals and options, there might by an action overruling the defaults\n                        String goals = project.getGoals(); // default\n                        for (MavenArgumentInterceptorAction mavenArgInterceptor : argInterceptors) {\n                        \tfinal String goalsAndOptions = mavenArgInterceptor.getGoalsAndOptions((MavenModuleSetBuild)this.getBuild());\n\t\t\t\t\t\t\tif(StringUtils.isNotBlank(goalsAndOptions)){\n                        \t\tgoals = goalsAndOptions;\n                                // only one interceptor is allowed to overwrite the whole \"goals and options\" string\n                        \t\tbreak;\n                        \t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmargs.addTokenized(envVars.expand(goals));\n\n\t\t\t\t\t\t// enable the interceptors to change the whole command argument list\n\t\t\t\t\t\t// all available interceptors are allowed to modify the argument list\n\t\t\t\t\t\tfor (MavenArgumentInterceptorAction mavenArgInterceptor : argInterceptors) {\n\t\t\t\t\t\t\tfinal ArgumentListBuilder newMargs = mavenArgInterceptor.intercept(margs, (MavenModuleSetBuild)this.getBuild());\n\t\t\t\t\t\t\tif (newMargs != null) {\n\t\t\t\t\t\t\t\tmargs = newMargs;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}                        \n                        \n                        final AbstractMavenBuilder builder;\n                        if (maven3orLater) {\n                            builder =\n                                new Maven3Builder( slistener, proxies, project.sortedActiveModules, margs.toList(), envVars, mavenBuildInformation );\n                        } else {\n                            builder = \n                                new Maven2Builder(slistener, proxies, project.sortedActiveModules, margs.toList(), envVars, mavenBuildInformation);\n                        }\n                        \n                        MavenProbeAction mpa=null;\n                        try {\n                            mpa = new MavenProbeAction(project,process.channel);\n                            addAction(mpa);\n                            r = process.call(builder);\n                            return r;\n                        } finally {\n                            builder.end(launcher);\n                            getActions().remove(mpa);\n                            process.discard();\n                        }                            \n                        \n                    } catch (InterruptedException e) {\n                        r = Executor.currentExecutor().abortResult();\n                        throw e;\n                    } finally {\n            \t\t\t// only run post build steps if requested...\n                        if (r==null || r.isBetterOrEqualTo(project.getRunPostStepsIfResult())) {\n                            if(!build(listener,project.getPostbuilders().toList())){\n                                r = FAILURE;\n            \t\t\t\t}\n            \t\t\t}\n            \t\t\t\n                        if (r != null) {\n                            setResult(r);\n                        }\n\n                        // tear down in reverse order\n                        boolean failed=false;\n                        for( int i=buildEnvironments.size()-1; i>=0; i-- ) {\n                            if (!buildEnvironments.get(i).tearDown(MavenModuleSetBuild.this,listener)) {\n                                failed=true;\n                            }                    \n                        }\n                        // WARNING The return in the finally clause will trump any return before\n                        if (failed) return Result.FAILURE;\n                    }\n                }\n                \n                \n                return r;\n            } catch (AbortException e) {\n                if(e.getMessage()!=null)\n                    listener.error(e.getMessage());\n                return Result.FAILURE;\n            } catch (InterruptedIOException e) {\n                e.printStackTrace(listener.error(\"Aborted Maven execution for InterruptedIOException\"));\n                return Executor.currentExecutor().abortResult();\n            } catch (IOException e) {\n                e.printStackTrace(listener.error(Messages.MavenModuleSetBuild_FailedToParsePom()));\n                return Result.FAILURE;\n            } catch (RunnerAbortedException e) {\n                return Result.FAILURE;\n            } catch (RuntimeException e) {\n                // bug in the code.\n                e.printStackTrace(listener.error(\"Processing failed due to a bug in the code. Please report this to jenkinsci-users@googlegroups.com\"));\n                logger.println(\"project=\"+project);\n                logger.println(\"project.getModules()=\"+project.getModules());\n                logger.println(\"project.getRootModule()=\"+project.getRootModule());\n                throw e;\n            } finally {\n            }\n        }","id":83414,"modified_method":"protected Result doRun(final BuildListener listener) throws Exception {\n            \n        \tResult r = null;\n        \tPrintStream logger = listener.getLogger();\n\n            try {\n            \t\n                EnvVars envVars = getEnvironment(listener);\n                MavenInstallation mvn = project.getMaven();\n                if(mvn==null)\n                    throw new AbortException(Messages.MavenModuleSetBuild_NoMavenConfigured());\n\n                mvn = mvn.forEnvironment(envVars).forNode(Computer.currentComputer().getNode(), listener);\n                \n                MavenInformation mavenInformation = getModuleRoot().act( new MavenVersionCallable( mvn.getHome() ));\n                \n                String mavenVersion = mavenInformation.getVersion();\n                \n                MavenBuildInformation mavenBuildInformation = new MavenBuildInformation( mavenVersion );\n                \n                setMavenVersionUsed( mavenVersion );\n\n                LOGGER.fine(getFullDisplayName()+\" is building with mavenVersion \" + mavenVersion + \" from file \" + mavenInformation.getVersionResourcePath());\n                \n                if(!project.isAggregatorStyleBuild()) {\n                    parsePoms(listener, logger, envVars, mvn, mavenVersion, mavenBuildInformation);\n                    // start module builds\n                    logger.println(\"Triggering \"+project.getRootModule().getModuleName());\n                    project.getRootModule().scheduleBuild(new UpstreamCause((Run<?,?>)MavenModuleSetBuild.this));\n                } else {\n                    // do builds here\n                    try {\n                        List<BuildWrapper> wrappers = new ArrayList<BuildWrapper>();\n                        for (BuildWrapper w : project.getBuildWrappersList())\n                            wrappers.add(w);\n                        ParametersAction parameters = getAction(ParametersAction.class);\n                        if (parameters != null)\n                            parameters.createBuildWrappers(MavenModuleSetBuild.this,wrappers);\n\n                        for( BuildWrapper w : wrappers) {\n                            Environment e = w.setUp(MavenModuleSetBuild.this, launcher, listener);\n                            if(e==null){\n                                setResult(r = Result.FAILURE);\n                                return r;\n                            }\n                            buildEnvironments.add(e);\n                            e.buildEnvVars(envVars); // #3502: too late for getEnvironment to do this\n                        }\n                        \n                    \t// run pre build steps\n                    \tif(!preBuild(listener,project.getPrebuilders())\n                        || !preBuild(listener,project.getPostbuilders())\n                        || !preBuild(listener,project.getPublishers())){\n                    \t\tsetResult(r = FAILURE);\n                            return r;\n                    \t}\n\n                    \tif(!build(listener,project.getPrebuilders().toList())){\n                    \t\tsetResult(r = FAILURE);\n                            return r;\n            \t\t\t}\n\n                        parsePoms(listener, logger, envVars, mvn, mavenVersion, mavenBuildInformation); // #5428 : do pre-build *before* parsing pom\n                        SplittableBuildListener slistener = new SplittableBuildListener(listener);\n                        proxies = new HashMap<ModuleName, ProxyImpl2>();\n                        List<ModuleName> changedModules = new ArrayList<ModuleName>();\n                        \n                        if (project.isIncrementalBuild() && !getChangeSet().isEmptySet()) {\n                            changedModules.addAll(getUnbuildModulesSinceLastSuccessfulBuild());\n                        }\n\n                        for (MavenModule m : project.sortedActiveModules) {\n                            MavenBuild mb = m.newBuild();\n                            // JENKINS-8418\n                            mb.setBuiltOnStr( getBuiltOnStr() );\n                            // Check if incrementalBuild is selected and that there are changes -\n                            // we act as if incrementalBuild is not set if there are no changes.\n                            if (!MavenModuleSetBuild.this.getChangeSet().isEmptySet()\n                                && project.isIncrementalBuild()) {\n                                //If there are changes for this module, add it.\n                                // Also add it if we've never seen this module before,\n                                // or if the previous build of this module failed or was unstable.\n                                if ((mb.getPreviousBuiltBuild() == null) ||\n                                    (!getChangeSetFor(m).isEmpty()) \n                                    || (mb.getPreviousBuiltBuild().getResult().isWorseThan(Result.SUCCESS))) {\n                                    changedModules.add(m.getModuleName());\n                                }\n                            }\n\n                            mb.setWorkspace(getModuleRoot().child(m.getRelativePath()));\n                            proxies.put(m.getModuleName(), mb.new ProxyImpl2(MavenModuleSetBuild.this,slistener));\n                        }\n\n                        // run the complete build here\n\n                        // figure out the root POM location.\n                        // choice of module root ('ws' in this method) is somewhat arbitrary\n                        // when multiple CVS/SVN modules are checked out, so also check\n                        // the path against the workspace root if that seems like what the user meant (see issue #1293)\n                        String rootPOM = project.getRootPOM(envVars); // JENKINS-13822\n                        FilePath pom = getModuleRoot().child(rootPOM);\n                        FilePath parentLoc = getWorkspace().child(rootPOM);\n                        if(!pom.exists() && parentLoc.exists())\n                            pom = parentLoc;\n\n                        \n                        final ProcessCache.MavenProcess process;\n                        \n                        boolean maven3orLater = mavenBuildInformation.isMaven3OrLater(); \n                        if ( maven3orLater )\n                        {\n                            LOGGER.fine( \"using maven 3 \" + mavenVersion );\n                            process =\n                                MavenBuild.mavenProcessCache.get( launcher.getChannel(), slistener,\n                                                                  new Maven3ProcessFactory( project, launcher, envVars, getMavenOpts(listener, envVars),\n                                                                                            pom.getParent() ) );\n                        }\n                        else\n                        {\n                            LOGGER.fine( \"using maven 2 \" + mavenVersion );\n                            process =\n                                MavenBuild.mavenProcessCache.get( launcher.getChannel(), slistener,\n                                                                  new MavenProcessFactory( project, launcher, envVars,getMavenOpts(listener, envVars),\n                                                                                           pom.getParent() ) );\n                        }\n                        ArgumentListBuilder margs = new ArgumentListBuilder().add(\"-B\").add(\"-f\", pom.getRemote());\n                        FilePath localRepo = project.getLocalRepository().locate(MavenModuleSetBuild.this);\n                        if(localRepo!=null)\n                            margs.add(\"-Dmaven.repo.local=\"+localRepo.getRemote());\n\n                        FilePath remoteSettings = SettingsProvider.getSettingsFilePath(project.getSettings(), MavenModuleSetBuild.this, listener);\n                        if (remoteSettings != null)\n                            margs.add(\"-s\" , remoteSettings.getRemote());\n\n                        FilePath remoteGlobalSettings = GlobalSettingsProvider.getSettingsFilePath(project.getGlobalSettings(), MavenModuleSetBuild.this, listener);\n                        if (remoteGlobalSettings != null)\n                            margs.add(\"-gs\" , remoteGlobalSettings.getRemote());\n                        \n                        // If incrementalBuild is set\n                        // and the previous build didn't specify that we need a full build\n                        // and we're on Maven 2.1 or later\n                        // and there's at least one module listed in changedModules,\n                        // then do the Maven incremental build commands.\n                        // If there are no changed modules, we're building everything anyway.\n                        boolean maven2_1orLater = new ComparableVersion (mavenVersion).compareTo( new ComparableVersion (\"2.1\") ) >= 0;\n                        boolean needsFullBuild = getPreviousCompletedBuild() != null &&\n                            getPreviousCompletedBuild().getAction(NeedsFullBuildAction.class) != null;\n                        if (project.isIncrementalBuild()) {\n                            if (!needsFullBuild && maven2_1orLater && !changedModules.isEmpty()) {\n                                margs.add(\"-amd\");\n                                margs.add(\"-pl\", Util.join(changedModules, \",\"));\n                            } else {\n                                if (LOGGER.isLoggable(Level.FINE)) {\n                                    LOGGER.fine(String.format(\"Skipping incremental build: needsFullBuild=%s, maven2.1orLater=%s, changedModulesEmpty?=%s\",\n                                            needsFullBuild, maven2_1orLater, changedModules.isEmpty()));\n                                }\n                            }\n                        }\n\n\n                        \n                        final List<MavenArgumentInterceptorAction> argInterceptors = this.getBuild().getActions(MavenArgumentInterceptorAction.class);\n                        \n\t\t\t\t\t\t// find the correct maven goals and options, there might by an action overruling the defaults\n                        String goals = project.getGoals(); // default\n                        for (MavenArgumentInterceptorAction mavenArgInterceptor : argInterceptors) {\n                        \tfinal String goalsAndOptions = mavenArgInterceptor.getGoalsAndOptions((MavenModuleSetBuild)this.getBuild());\n\t\t\t\t\t\t\tif(StringUtils.isNotBlank(goalsAndOptions)){\n                        \t\tgoals = goalsAndOptions;\n                                // only one interceptor is allowed to overwrite the whole \"goals and options\" string\n                        \t\tbreak;\n                        \t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmargs.addTokenized(envVars.expand(goals));\n\n\t\t\t\t\t\t// enable the interceptors to change the whole command argument list\n\t\t\t\t\t\t// all available interceptors are allowed to modify the argument list\n\t\t\t\t\t\tfor (MavenArgumentInterceptorAction mavenArgInterceptor : argInterceptors) {\n\t\t\t\t\t\t\tfinal ArgumentListBuilder newMargs = mavenArgInterceptor.intercept(margs, (MavenModuleSetBuild)this.getBuild());\n\t\t\t\t\t\t\tif (newMargs != null) {\n\t\t\t\t\t\t\t\tmargs = newMargs;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}                        \n                        \n                        final AbstractMavenBuilder builder;\n                        if (maven3orLater) {\n                            builder =\n                                new Maven3Builder( slistener, proxies, project.sortedActiveModules, margs.toList(), envVars, mavenBuildInformation );\n                        } else {\n                            builder = \n                                new Maven2Builder(slistener, proxies, project.sortedActiveModules, margs.toList(), envVars, mavenBuildInformation);\n                        }\n                        \n                        MavenProbeAction mpa=null;\n                        try {\n                            mpa = new MavenProbeAction(project,process.channel);\n                            addAction(mpa);\n                            r = process.call(builder);\n                            return r;\n                        } finally {\n                            builder.end(launcher);\n                            getActions().remove(mpa);\n                            process.discard();\n                        }                            \n                        \n                    } catch (InterruptedException e) {\n                        r = Executor.currentExecutor().abortResult();\n                        throw e;\n                    } finally {\n            \t\t\t// only run post build steps if requested...\n                        if (r==null || r.isBetterOrEqualTo(project.getRunPostStepsIfResult())) {\n                            if(!build(listener,project.getPostbuilders().toList())){\n                                r = FAILURE;\n            \t\t\t\t}\n            \t\t\t}\n            \t\t\t\n                        if (r != null) {\n                            setResult(r);\n                        }\n\n                        // tear down in reverse order\n                        boolean failed=false;\n                        for( int i=buildEnvironments.size()-1; i>=0; i-- ) {\n                            if (!buildEnvironments.get(i).tearDown(MavenModuleSetBuild.this,listener)) {\n                                failed=true;\n                            }                    \n                        }\n                        // WARNING The return in the finally clause will trump any return before\n                        if (failed) return Result.FAILURE;\n                    }\n                }\n                \n                \n                return r;\n            } catch (AbortException e) {\n                if(e.getMessage()!=null)\n                    listener.error(e.getMessage());\n                return Result.FAILURE;\n            } catch (InterruptedIOException e) {\n                e.printStackTrace(listener.error(\"Aborted Maven execution for InterruptedIOException\"));\n                return Executor.currentExecutor().abortResult();\n            } catch (IOException e) {\n                e.printStackTrace(listener.error(Messages.MavenModuleSetBuild_FailedToParsePom()));\n                return Result.FAILURE;\n            } catch (RunnerAbortedException e) {\n                return Result.FAILURE;\n            } catch (RuntimeException e) {\n                // bug in the code.\n                e.printStackTrace(listener.error(\"Processing failed due to a bug in the code. Please report this to jenkinsci-users@googlegroups.com\"));\n                logger.println(\"project=\"+project);\n                logger.println(\"project.getModules()=\"+project.getModules());\n                logger.println(\"project.getRootModule()=\"+project.getRootModule());\n                throw e;\n            } finally {\n            }\n        }","commit_id":"0c4fe2ddbac2963c0b633fe27bb1a6016134da50","url":"https://github.com/kohsuke/hudson"},{"original_method":"public List<PomInfo> invoke(File ws, VirtualChannel channel) throws IOException {\n            File pom;\n            \n            PrintStream logger = listener.getLogger();\n\n            if (IOUtils.isAbsolute(rootPOM)) {\n                pom = new File(rootPOM);\n            } else {\n                // choice of module root ('ws' in this method) is somewhat arbitrary\n                // when multiple CVS/SVN modules are checked out, so also check\n                // the path against the workspace root if that seems like what the user meant (see issue #1293)\n                pom = new File(ws, rootPOM);\n                File parentLoc = new File(ws.getParentFile(),rootPOM);\n                if(!pom.exists() && parentLoc.exists())\n                    pom = parentLoc;\n            }\n\n            if(!pom.exists())\n                throw new AbortException(Messages.MavenModuleSetBuild_NoSuchPOMFile(pom));\n\n            if (rootPOM.startsWith(\"../\") || rootPOM.startsWith(\"..\\\\\")) {\n                File wsp = new File(workspaceProper);\n                               \n                if (!ws.equals(wsp)) {\n                    rootPOMRelPrefix = ws.getCanonicalPath().substring(wsp.getCanonicalPath().length()+1)+\"/\";\n                } else {\n                    rootPOMRelPrefix = wsp.getName() + \"/\";\n                }\n            } else {\n                rootPOMRelPrefix = \"\";\n            }            \n            \n            if(verbose)\n                logger.println(\"Parsing \"\n\t\t\t       + (nonRecursive ? \"non-recursively \" : \"recursively \")\n\t\t\t       + pom);\n\t    \n            File settingsLoc;\n\n            if (alternateSettings == null) {\n                settingsLoc = null;\n            } else if (IOUtils.isAbsolute(alternateSettings)) {\n                settingsLoc = new File(alternateSettings);\n            } else {\n                // Check for settings.xml first in the workspace proper, and then in the current directory,\n                // which is getModuleRoot().\n                // This is backwards from the order the root POM logic uses, but it's to be consistent with the Maven execution logic.\n                settingsLoc = new File(workspaceProper, alternateSettings);\n                File mrSettingsLoc = new File(workspaceProper, alternateSettings);\n                if (!settingsLoc.exists() && mrSettingsLoc.exists())\n                    settingsLoc = mrSettingsLoc;\n            }\n            if (debug)\n            {\n                logger.println(Messages.MavenModuleSetBuild_SettinsgXmlAndPrivateRepository(settingsLoc,privateRepository));\n            }\n            if ((settingsLoc != null) && (!settingsLoc.exists())) {\n                throw new AbortException(Messages.MavenModuleSetBuild_NoSuchAlternateSettings(settingsLoc.getAbsolutePath()));\n            }\n\n            try {\n                MavenEmbedderRequest mavenEmbedderRequest = new MavenEmbedderRequest( listener, mavenHome.getHomeDir(),\n                                                                                      profiles, properties,\n                                                                                      privateRepository, settingsLoc );\n                mavenEmbedderRequest.setTransferListener( new SimpleTransferListener(listener) );\n                mavenEmbedderRequest.setUpdateSnapshots( this.updateSnapshots );\n                \n                mavenEmbedderRequest.setProcessPlugins( this.processPlugins );\n                mavenEmbedderRequest.setResolveDependencies( this.resolveDependencies );\n                if (globalSettings != null) {\n                    mavenEmbedderRequest.setGlobalSettings( new File(globalSettings) );\n                }\n                \n                // FIXME handle 3.1 level when version will be here : no rush :-)\n                // or made something configurable tru the ui ?\n                ReactorReader reactorReader = null;\n                boolean maven3OrLater = MavenUtil.maven3orLater(mavenVersion);\n                if (maven3OrLater) {\n                    mavenEmbedderRequest.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );\n                } else {\n                    reactorReader = new ReactorReader( new HashMap<String, MavenProject>(), new File(workspaceProper) );\n                    mavenEmbedderRequest.setWorkspaceReader( reactorReader );\n                }\n                \n                \n                if (this.mavenValidationLevel >= 0) {\n                    mavenEmbedderRequest.setValidationLevel( this.mavenValidationLevel );\n                }\n                \n                //mavenEmbedderRequest.setClassLoader( MavenEmbedderUtils.buildClassRealm( mavenHome.getHomeDir(), null, null ) );\n                \n                MavenEmbedder embedder = MavenUtil.createEmbedder( mavenEmbedderRequest );\n                \n                MavenProject rootProject = null;\n                \n                List<MavenProject> mps = new ArrayList<MavenProject>(0);\n                if (maven3OrLater) {\n                    mps = embedder.readProjects( pom,!this.nonRecursive );\n\n                } else {\n                    // http://issues.jenkins-ci.org/browse/HUDSON-8390\n                    // we cannot read maven projects in one time for backward compatibility\n                    // but we have to use a ReactorReader to get some pom with bad inheritence configured\n                    MavenProject mavenProject = embedder.readProject( pom );\n                    rootProject = mavenProject;\n                    mps.add( mavenProject );\n                    reactorReader.addProject( mavenProject );\n                    if (!this.nonRecursive) {\n                        readChilds( mavenProject, embedder, mps, reactorReader );\n                    }\n                }\n                Map<String,MavenProject> canonicalPaths = new HashMap<String, MavenProject>( mps.size() );\n                for(MavenProject mp : mps) {\n                    // Projects are indexed by POM path and not module path because\n                    // Maven allows to have several POMs with different names in the same directory\n                    canonicalPaths.put( mp.getFile().getCanonicalPath(), mp );\n                }                \n                //MavenUtil.resolveModules(embedder,mp,getRootPath(rootPOMRelPrefix),relPath,listener,nonRecursive);\n\n                if(verbose) {\n                    for (Entry<String,MavenProject> e : canonicalPaths.entrySet())\n                        logger.printf(\"Discovered %s at %s\\n\",e.getValue().getId(),e.getKey());\n                }\n\n                Set<PomInfo> infos = new LinkedHashSet<PomInfo>();\n                \n                if (maven3OrLater) {\n                    for (MavenProject mp : mps) {\n                        if (mp.isExecutionRoot()) {\n                            rootProject = mp;\n                            continue;\n                        }\n                    }\n                }\n                // if rootProject is null but no reason :-) use the first one\n                if (rootProject == null) {\n                    rootProject = mps.get( 0 );\n                }\n                toPomInfo(rootProject,null,canonicalPaths,infos);\n\n                for (PomInfo pi : infos)\n                    pi.cutCycle();\n\n                return new ArrayList<PomInfo>(infos);\n            } catch (MavenEmbedderException e) {\n                throw new MavenExecutionException(e);\n            } catch (ProjectBuildingException e) {\n                throw new MavenExecutionException(e);\n            }\n        }","id":83415,"modified_method":"public Result invoke(File ws, VirtualChannel channel) throws IOException {\n            File pom;\n            \n            PrintStream logger = listener.getLogger();\n\n            if (IOUtils.isAbsolute(rootPOM)) {\n                pom = new File(rootPOM);\n            } else {\n                // choice of module root ('ws' in this method) is somewhat arbitrary\n                // when multiple CVS/SVN modules are checked out, so also check\n                // the path against the workspace root if that seems like what the user meant (see issue #1293)\n                pom = new File(ws, rootPOM);\n                File parentLoc = new File(ws.getParentFile(),rootPOM);\n                if(!pom.exists() && parentLoc.exists())\n                    pom = parentLoc;\n            }\n\n            if(!pom.exists())\n                throw new AbortException(Messages.MavenModuleSetBuild_NoSuchPOMFile(pom));\n\n            if (rootPOM.startsWith(\"../\") || rootPOM.startsWith(\"..\\\\\")) {\n                File wsp = new File(workspaceProper);\n                               \n                if (!ws.equals(wsp)) {\n                    rootPOMRelPrefix = ws.getCanonicalPath().substring(wsp.getCanonicalPath().length()+1)+\"/\";\n                } else {\n                    rootPOMRelPrefix = wsp.getName() + \"/\";\n                }\n            } else {\n                rootPOMRelPrefix = \"\";\n            }            \n            \n            if(verbose)\n                logger.println(\"Parsing \"\n\t\t\t       + (nonRecursive ? \"non-recursively \" : \"recursively \")\n\t\t\t       + pom);\n\t    \n            File settingsLoc;\n\n            if (alternateSettings == null) {\n                settingsLoc = null;\n            } else if (IOUtils.isAbsolute(alternateSettings)) {\n                settingsLoc = new File(alternateSettings);\n            } else {\n                // Check for settings.xml first in the workspace proper, and then in the current directory,\n                // which is getModuleRoot().\n                // This is backwards from the order the root POM logic uses, but it's to be consistent with the Maven execution logic.\n                settingsLoc = new File(workspaceProper, alternateSettings);\n                File mrSettingsLoc = new File(workspaceProper, alternateSettings);\n                if (!settingsLoc.exists() && mrSettingsLoc.exists())\n                    settingsLoc = mrSettingsLoc;\n            }\n            if (debug)\n            {\n                logger.println(Messages.MavenModuleSetBuild_SettinsgXmlAndPrivateRepository(settingsLoc,privateRepository));\n            }\n            if ((settingsLoc != null) && (!settingsLoc.exists())) {\n                throw new AbortException(Messages.MavenModuleSetBuild_NoSuchAlternateSettings(settingsLoc.getAbsolutePath()));\n            }\n\n            try {\n                MavenEmbedderRequest mavenEmbedderRequest = new MavenEmbedderRequest( listener, mavenHome.getHomeDir(),\n                                                                                      profiles, properties,\n                                                                                      privateRepository, settingsLoc );\n                mavenEmbedderRequest.setTransferListener( new SimpleTransferListener(listener) );\n                mavenEmbedderRequest.setUpdateSnapshots( this.updateSnapshots );\n                \n                mavenEmbedderRequest.setProcessPlugins( this.processPlugins );\n                mavenEmbedderRequest.setResolveDependencies( this.resolveDependencies );\n                if (globalSettings != null) {\n                    mavenEmbedderRequest.setGlobalSettings( new File(globalSettings) );\n                }\n                \n                // FIXME handle 3.1 level when version will be here : no rush :-)\n                // or made something configurable tru the ui ?\n                ReactorReader reactorReader = null;\n                boolean maven3OrLater = MavenUtil.maven3orLater(mavenVersion);\n                if (maven3OrLater) {\n                    mavenEmbedderRequest.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MAVEN_3_0 );\n                } else {\n                    reactorReader = new ReactorReader( new HashMap<String, MavenProject>(), new File(workspaceProper) );\n                    mavenEmbedderRequest.setWorkspaceReader( reactorReader );\n                }\n                \n                \n                if (this.mavenValidationLevel >= 0) {\n                    mavenEmbedderRequest.setValidationLevel( this.mavenValidationLevel );\n                }\n                \n                //mavenEmbedderRequest.setClassLoader( MavenEmbedderUtils.buildClassRealm( mavenHome.getHomeDir(), null, null ) );\n                \n                MavenEmbedder embedder = MavenUtil.createEmbedder( mavenEmbedderRequest );\n                \n                MavenProject rootProject = null;\n                \n                List<MavenProject> mps = new ArrayList<MavenProject>(0);\n                if (maven3OrLater) {\n                    mps = embedder.readProjects( pom,!this.nonRecursive );\n\n                } else {\n                    // http://issues.jenkins-ci.org/browse/HUDSON-8390\n                    // we cannot read maven projects in one time for backward compatibility\n                    // but we have to use a ReactorReader to get some pom with bad inheritence configured\n                    MavenProject mavenProject = embedder.readProject( pom );\n                    rootProject = mavenProject;\n                    mps.add( mavenProject );\n                    reactorReader.addProject( mavenProject );\n                    if (!this.nonRecursive) {\n                        readChilds( mavenProject, embedder, mps, reactorReader );\n                    }\n                }\n                Map<String,MavenProject> canonicalPaths = new HashMap<String, MavenProject>( mps.size() );\n                Map<String,String> modelParents = new HashMap<String,String>();\n                for(MavenProject mp : mps) {\n                    // Projects are indexed by POM path and not module path because\n                    // Maven allows to have several POMs with different names in the same directory\n                    canonicalPaths.put( mp.getFile().getCanonicalPath(), mp );\n                    while (true) {\n                        String k = mp.getId();\n                        if (modelParents.containsKey(k)) {\n                            break;\n                        }\n                        MavenProject mpp = mp.getParent();\n                        if (mpp == null) {\n                            break;\n                        }\n                        modelParents.put(k, mpp.getId());\n                        mp = mpp;\n                    }\n                }                \n                //MavenUtil.resolveModules(embedder,mp,getRootPath(rootPOMRelPrefix),relPath,listener,nonRecursive);\n\n                if(verbose) {\n                    for (Entry<String,MavenProject> e : canonicalPaths.entrySet())\n                        logger.printf(\"Discovered %s at %s\\n\",e.getValue().getId(),e.getKey());\n                }\n\n                Set<PomInfo> infos = new LinkedHashSet<PomInfo>();\n                \n                if (maven3OrLater) {\n                    for (MavenProject mp : mps) {\n                        if (mp.isExecutionRoot()) {\n                            rootProject = mp;\n                            continue;\n                        }\n                    }\n                }\n                // if rootProject is null but no reason :-) use the first one\n                if (rootProject == null) {\n                    rootProject = mps.get( 0 );\n                }\n                toPomInfo(rootProject,null,canonicalPaths,infos);\n\n                for (PomInfo pi : infos)\n                    pi.cutCycle();\n\n                return new Result(new ArrayList<PomInfo>(infos), modelParents);\n            } catch (MavenEmbedderException e) {\n                throw new MavenExecutionException(e);\n            } catch (ProjectBuildingException e) {\n                throw new MavenExecutionException(e);\n            }\n        }","commit_id":"0c4fe2ddbac2963c0b633fe27bb1a6016134da50","url":"https://github.com/kohsuke/hudson"},{"original_method":"public PomParser(BuildListener listener, MavenInstallation mavenHome, String mavenVersion, EnvVars envVars, MavenModuleSetBuild build) {\n            // project cannot be shipped to the remote JVM, so all the relevant properties need to be captured now.\n            MavenModuleSet project = build.getProject();\n            this.listener = listener;\n            this.mavenHome = mavenHome;\n            this.rootPOM = project.getRootPOM(envVars); // JENKINS-13822\n            this.profiles = project.getProfiles();\n            this.properties = project.getMavenProperties();\n            this.updateSnapshots = isUpdateSnapshots(project.getGoals());\n            ParametersDefinitionProperty parametersDefinitionProperty = project.getProperty( ParametersDefinitionProperty.class );\n            if (parametersDefinitionProperty != null && parametersDefinitionProperty.getParameterDefinitions() != null) {\n                for (ParameterDefinition parameterDefinition : parametersDefinitionProperty.getParameterDefinitions()) {\n                    // those must used as env var\n                    if (parameterDefinition instanceof StringParameterDefinition) {\n                        this.properties.put( \"env.\" + parameterDefinition.getName(), ((StringParameterDefinition)parameterDefinition).getDefaultValue() );\n                    }\n                }\n            }\n            if (envVars != null && !envVars.isEmpty()) {\n                for (Entry<String,String> entry : envVars.entrySet()) {\n                    if (entry.getKey() != null && entry.getValue() != null) {\n                        this.properties.put( \"env.\" + entry.getKey(), entry.getValue() );\n                    }\n                }\n            }\n            \n            this.nonRecursive = project.isNonRecursive();\n\n            this.workspaceProper = build.getWorkspace().getRemote();\n            LOGGER.fine(\"Workspace is \" + workspaceProper);\n            FilePath localRepo = project.getLocalRepository().locate(build);\n            if (localRepo!=null) {\n                this.privateRepository = localRepo.getRemote();\n            } else {\n                this.privateRepository = null;\n            }\n            \n            this.alternateSettings = SettingsProvider.getSettingsRemotePath(project.getSettings(), build, listener);\n            this.globalSettings = GlobalSettingsProvider.getSettingsRemotePath(project.getGlobalSettings(), build, listener);\n            \n            this.mavenVersion = mavenVersion;\n            this.resolveDependencies = project.isResolveDependencies();\n            this.processPlugins = project.isProcessPlugins();\n            \n            this.moduleRootPath = \n                project.getScm().getModuleRoot( build.getWorkspace(), project.getLastBuild() ).getRemote();\n            \n            this.mavenValidationLevel = project.getMavenValidationLevel();\n        }","id":83416,"modified_method":"PomParser(BuildListener listener, MavenInstallation mavenHome, String mavenVersion, EnvVars envVars, MavenModuleSetBuild build) {\n            // project cannot be shipped to the remote JVM, so all the relevant properties need to be captured now.\n            MavenModuleSet project = build.getProject();\n            this.listener = listener;\n            this.mavenHome = mavenHome;\n            this.rootPOM = project.getRootPOM(envVars); // JENKINS-13822\n            this.profiles = project.getProfiles();\n            this.properties = project.getMavenProperties();\n            this.updateSnapshots = isUpdateSnapshots(project.getGoals());\n            ParametersDefinitionProperty parametersDefinitionProperty = project.getProperty( ParametersDefinitionProperty.class );\n            if (parametersDefinitionProperty != null && parametersDefinitionProperty.getParameterDefinitions() != null) {\n                for (ParameterDefinition parameterDefinition : parametersDefinitionProperty.getParameterDefinitions()) {\n                    // those must used as env var\n                    if (parameterDefinition instanceof StringParameterDefinition) {\n                        this.properties.put( \"env.\" + parameterDefinition.getName(), ((StringParameterDefinition)parameterDefinition).getDefaultValue() );\n                    }\n                }\n            }\n            if (envVars != null && !envVars.isEmpty()) {\n                for (Entry<String,String> entry : envVars.entrySet()) {\n                    if (entry.getKey() != null && entry.getValue() != null) {\n                        this.properties.put( \"env.\" + entry.getKey(), entry.getValue() );\n                    }\n                }\n            }\n            \n            this.nonRecursive = project.isNonRecursive();\n\n            this.workspaceProper = build.getWorkspace().getRemote();\n            LOGGER.fine(\"Workspace is \" + workspaceProper);\n            FilePath localRepo = project.getLocalRepository().locate(build);\n            if (localRepo!=null) {\n                this.privateRepository = localRepo.getRemote();\n            } else {\n                this.privateRepository = null;\n            }\n            \n            this.alternateSettings = SettingsProvider.getSettingsRemotePath(project.getSettings(), build, listener);\n            this.globalSettings = GlobalSettingsProvider.getSettingsRemotePath(project.getGlobalSettings(), build, listener);\n            \n            this.mavenVersion = mavenVersion;\n            this.resolveDependencies = project.isResolveDependencies();\n            this.processPlugins = project.isProcessPlugins();\n            \n            this.moduleRootPath = \n                project.getScm().getModuleRoot( build.getWorkspace(), project.getLastBuild() ).getRemote();\n            \n            this.mavenValidationLevel = project.getMavenValidationLevel();\n        }","commit_id":"0c4fe2ddbac2963c0b633fe27bb1a6016134da50","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected void doTest(@NotNull String testFile) throws IOException {\n        String fileText = FileUtil.loadFile(new File(testFile), true);\n\n        JetFile psiFile = JetPsiFactory.createFile(getProject(), fileText);\n        Collection<JetFile> files = Lists.newArrayList(psiFile);\n\n        final ModuleDescriptorImpl lazyModule = AnalyzerFacadeForJVM.createJavaModule(\"<lazy module>\");\n        lazyModule.addFragmentProvider(DependencyKind.BUILT_INS, KotlinBuiltIns.getInstance().getBuiltInsModule().getPackageFragmentProvider());\n        LockBasedStorageManagerWithExceptionTracking storageManager = LockBasedStorageManagerWithExceptionTracking.create();\n        final ResolveSession resolveSession = new ResolveSession(getProject(), storageManager, lazyModule,\n                                                                 new FileBasedDeclarationProviderFactory(storageManager, files),\n                                                                 new BindingTraceContext());\n\n        final List<DeclarationDescriptor> descriptors = new ArrayList<DeclarationDescriptor>();\n        psiFile.accept(new JetVisitorVoid() {\n            @Override\n            public void visitJetFile(@NotNull JetFile file) {\n                FqName fqName = file.getPackageDirective().getFqName();\n                if (!fqName.isRoot()) {\n                    PackageViewDescriptor packageDescriptor = lazyModule.getPackage(fqName);\n                    descriptors.add(packageDescriptor);\n                }\n                file.acceptChildren(this);\n            }\n\n            @Override\n            public void visitClassObject(@NotNull JetClassObject classObject) {\n                classObject.acceptChildren(this);\n            }\n\n            @Override\n            public void visitParameter(@NotNull JetParameter parameter) {\n                PsiElement declaringElement = parameter.getParent().getParent();\n                if (declaringElement instanceof JetFunctionType) {\n                    return;\n                }\n                if (declaringElement instanceof JetNamedFunction) {\n                    JetNamedFunction jetNamedFunction = (JetNamedFunction) declaringElement;\n                    FunctionDescriptor functionDescriptor = (FunctionDescriptor) getDescriptor(jetNamedFunction, resolveSession);\n                    addCorrespondingParameterDescriptor(functionDescriptor, parameter);\n                }\n                else if (declaringElement instanceof JetClass) {\n                    // Primary constructor parameter\n                    JetClass jetClass = (JetClass) declaringElement;\n                    ClassDescriptor classDescriptor = (ClassDescriptor) getDescriptor(jetClass, resolveSession);\n                    addCorrespondingParameterDescriptor(classDescriptor.getConstructors().iterator().next(), parameter);\n                }\n                else {\n                    super.visitParameter(parameter);\n                }\n            }\n\n            private void addCorrespondingParameterDescriptor(FunctionDescriptor functionDescriptor, JetParameter parameter) {\n                for (ValueParameterDescriptor valueParameterDescriptor : functionDescriptor.getValueParameters()) {\n                    if (valueParameterDescriptor.getName().equals(parameter.getNameAsName())) {\n                        descriptors.add(valueParameterDescriptor);\n                    }\n                }\n                parameter.acceptChildren(this);\n            }\n\n            @Override\n            public void visitPropertyAccessor(@NotNull JetPropertyAccessor accessor) {\n                JetProperty parent = (JetProperty) accessor.getParent();\n                PropertyDescriptor propertyDescriptor = (PropertyDescriptor) getDescriptor(parent, resolveSession);\n                if (accessor.isGetter()) {\n                    descriptors.add(propertyDescriptor.getGetter());\n                }\n                else {\n                    descriptors.add(propertyDescriptor.getSetter());\n                }\n                accessor.acceptChildren(this);\n            }\n\n            @Override\n            public void visitAnonymousInitializer(@NotNull JetClassInitializer initializer) {\n                initializer.acceptChildren(this);\n            }\n\n            @Override\n            public void visitDeclaration(@NotNull JetDeclaration element) {\n                DeclarationDescriptor descriptor = getDescriptor(element, resolveSession);\n                descriptors.add(descriptor);\n                if (descriptor instanceof ClassDescriptor) {\n                    descriptors.addAll(((ClassDescriptor) descriptor).getConstructors());\n                }\n                element.acceptChildren(this);\n            }\n\n            @Override\n            public void visitJetElement(@NotNull JetElement element) {\n                element.acceptChildren(this);\n            }\n        });\n\n        StringBuilder renderedDescriptors = new StringBuilder();\n        for (DeclarationDescriptor descriptor : descriptors) {\n            if (renderedDescriptors.length() != 0) {\n                renderedDescriptors.append(\"\\n\");\n            }\n            renderedDescriptors.append(DescriptorRenderer.TEXT.render(descriptor));\n        }\n\n        Document document = new DocumentImpl(psiFile.getText());\n        assertEquals(JetTestUtils.getLastCommentedLines(document), renderedDescriptors.toString());\n    }","id":83417,"modified_method":"protected void doTest(@NotNull String testFile) throws IOException {\n        String fileText = FileUtil.loadFile(new File(testFile), true);\n\n        JetFile psiFile = JetPsiFactory.createFile(getProject(), fileText);\n        Collection<JetFile> files = Lists.newArrayList(psiFile);\n\n        final ModuleDescriptorImpl lazyModule = AnalyzerFacadeForJVM.createJavaModule(\"<lazy module>\");\n        lazyModule.addFragmentProvider(DependencyKind.BUILT_INS, KotlinBuiltIns.getInstance().getBuiltInsModule().getPackageFragmentProvider());\n        LockBasedStorageManagerWithExceptionTracking storageManager = LockBasedStorageManagerWithExceptionTracking.create();\n        final ResolveSession resolveSession = new InjectorForLazyResolve(\n                getProject(), storageManager, lazyModule,\n                new FileBasedDeclarationProviderFactory(storageManager, files),\n                new BindingTraceContext()).getResolveSession();\n\n        final List<DeclarationDescriptor> descriptors = new ArrayList<DeclarationDescriptor>();\n        psiFile.accept(new JetVisitorVoid() {\n            @Override\n            public void visitJetFile(@NotNull JetFile file) {\n                FqName fqName = file.getPackageDirective().getFqName();\n                if (!fqName.isRoot()) {\n                    PackageViewDescriptor packageDescriptor = lazyModule.getPackage(fqName);\n                    descriptors.add(packageDescriptor);\n                }\n                file.acceptChildren(this);\n            }\n\n            @Override\n            public void visitClassObject(@NotNull JetClassObject classObject) {\n                classObject.acceptChildren(this);\n            }\n\n            @Override\n            public void visitParameter(@NotNull JetParameter parameter) {\n                PsiElement declaringElement = parameter.getParent().getParent();\n                if (declaringElement instanceof JetFunctionType) {\n                    return;\n                }\n                if (declaringElement instanceof JetNamedFunction) {\n                    JetNamedFunction jetNamedFunction = (JetNamedFunction) declaringElement;\n                    FunctionDescriptor functionDescriptor = (FunctionDescriptor) getDescriptor(jetNamedFunction, resolveSession);\n                    addCorrespondingParameterDescriptor(functionDescriptor, parameter);\n                }\n                else if (declaringElement instanceof JetClass) {\n                    // Primary constructor parameter\n                    JetClass jetClass = (JetClass) declaringElement;\n                    ClassDescriptor classDescriptor = (ClassDescriptor) getDescriptor(jetClass, resolveSession);\n                    addCorrespondingParameterDescriptor(classDescriptor.getConstructors().iterator().next(), parameter);\n                }\n                else {\n                    super.visitParameter(parameter);\n                }\n            }\n\n            private void addCorrespondingParameterDescriptor(FunctionDescriptor functionDescriptor, JetParameter parameter) {\n                for (ValueParameterDescriptor valueParameterDescriptor : functionDescriptor.getValueParameters()) {\n                    if (valueParameterDescriptor.getName().equals(parameter.getNameAsName())) {\n                        descriptors.add(valueParameterDescriptor);\n                    }\n                }\n                parameter.acceptChildren(this);\n            }\n\n            @Override\n            public void visitPropertyAccessor(@NotNull JetPropertyAccessor accessor) {\n                JetProperty parent = (JetProperty) accessor.getParent();\n                PropertyDescriptor propertyDescriptor = (PropertyDescriptor) getDescriptor(parent, resolveSession);\n                if (accessor.isGetter()) {\n                    descriptors.add(propertyDescriptor.getGetter());\n                }\n                else {\n                    descriptors.add(propertyDescriptor.getSetter());\n                }\n                accessor.acceptChildren(this);\n            }\n\n            @Override\n            public void visitAnonymousInitializer(@NotNull JetClassInitializer initializer) {\n                initializer.acceptChildren(this);\n            }\n\n            @Override\n            public void visitDeclaration(@NotNull JetDeclaration element) {\n                DeclarationDescriptor descriptor = getDescriptor(element, resolveSession);\n                descriptors.add(descriptor);\n                if (descriptor instanceof ClassDescriptor) {\n                    descriptors.addAll(((ClassDescriptor) descriptor).getConstructors());\n                }\n                element.acceptChildren(this);\n            }\n\n            @Override\n            public void visitJetElement(@NotNull JetElement element) {\n                element.acceptChildren(this);\n            }\n        });\n\n        StringBuilder renderedDescriptors = new StringBuilder();\n        for (DeclarationDescriptor descriptor : descriptors) {\n            if (renderedDescriptors.length() != 0) {\n                renderedDescriptors.append(\"\\n\");\n            }\n            renderedDescriptors.append(DescriptorRenderer.TEXT.render(descriptor));\n        }\n\n        Document document = new DocumentImpl(psiFile.getText());\n        assertEquals(JetTestUtils.getLastCommentedLines(document), renderedDescriptors.toString());\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static ResolveSession getLazyResolveSession(Collection<JetFile> files, Config config) {\n        LockBasedStorageManagerWithExceptionTracking storageManager = LockBasedStorageManagerWithExceptionTracking.create();\n        FileBasedDeclarationProviderFactory declarationProviderFactory = new FileBasedDeclarationProviderFactory(\n                storageManager, Config.withJsLibAdded(files, config), Predicates.<FqName>alwaysFalse());\n        ModuleDescriptorImpl module = createJsModule(\"<lazy module>\");\n        module.addFragmentProvider(DependencyKind.BUILT_INS, KotlinBuiltIns.getInstance().getBuiltInsModule().getPackageFragmentProvider());\n        return new ResolveSession(config.getProject(), storageManager, module, declarationProviderFactory, new BindingTraceContext());\n    }","id":83418,"modified_method":"@NotNull\n    public static ResolveSession getLazyResolveSession(Collection<JetFile> files, Config config) {\n        LockBasedStorageManagerWithExceptionTracking storageManager = LockBasedStorageManagerWithExceptionTracking.create();\n        FileBasedDeclarationProviderFactory declarationProviderFactory = new FileBasedDeclarationProviderFactory(\n                storageManager, Config.withJsLibAdded(files, config), Predicates.<FqName>alwaysFalse());\n        ModuleDescriptorImpl module = createJsModule(\"<lazy module>\");\n        module.addFragmentProvider(DependencyKind.BUILT_INS, KotlinBuiltIns.getInstance().getBuiltInsModule().getPackageFragmentProvider());\n\n        return new InjectorForLazyResolve(\n                config.getProject(),\n                storageManager,\n                module,\n                declarationProviderFactory,\n                new BindingTraceContext()).getResolveSession();\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static DependencyInjectorGenerator generateInjectorForLazyResolve() throws IOException {\n        DependencyInjectorGenerator generator = new DependencyInjectorGenerator();\n        generator.addParameter(Project.class);\n        generator.addParameter(ResolveSession.class);\n        generator.addParameter(ModuleDescriptor.class);\n        generator.addPublicField(DescriptorResolver.class);\n        generator.addPublicField(ExpressionTypingServices.class);\n        generator.addPublicField(TypeResolver.class);\n        generator.addPublicField(ScopeProvider.class);\n        generator.addPublicField(AnnotationResolver.class);\n        generator.addPublicField(QualifiedExpressionResolver.class);\n        generator.addPublicField(JetImportsFactory.class);\n        generator.addField(CallResolverExtensionProvider.class);\n        generator.addField(false, PlatformToKotlinClassMap.class, null, new GivenExpression(\"moduleDescriptor.getPlatformToKotlinClassMap()\"));\n        generator.addField(false, StorageManager.class, null, new GivenExpression(\"resolveSession.getStorageManager()\"));\n        generator.configure(\"compiler/frontend/src\", \"org.jetbrains.jet.di\", \"InjectorForLazyResolve\", GenerateInjectors.class);\n        return generator;\n    }","id":83419,"modified_method":"private static DependencyInjectorGenerator generateInjectorForLazyResolve() throws IOException {\n        DependencyInjectorGenerator generator = new DependencyInjectorGenerator();\n\n        generator.addParameter(Project.class);\n        generator.addParameter(LockBasedStorageManagerWithExceptionTracking.class);\n        generator.addParameter(ModuleDescriptorImpl.class);\n        generator.addParameter(DeclarationProviderFactory.class);\n        generator.addParameter(BindingTrace.class);\n\n        generator.addPublicField(ResolveSession.class);\n\n        generator.addField(CallResolverExtensionProvider.class);\n        generator.addField(false, PlatformToKotlinClassMap.class, null, new GivenExpression(\"moduleDescriptor.getPlatformToKotlinClassMap()\"));\n\n        generator.configure(\"compiler/frontend/src\", \"org.jetbrains.jet.di\", \"InjectorForLazyResolve\", GenerateInjectors.class);\n        return generator;\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private static JetNamedDeclaration getSourcePropertyOrFunction(@NotNull JetNamedDeclaration decompiledDeclaration) {\n        String memberNameAsString = decompiledDeclaration.getName();\n        assert memberNameAsString != null;\n        Name memberName = Name.identifier(memberNameAsString);\n\n        PsiElement decompiledContainer = decompiledDeclaration.getParent();\n\n        Collection<JetNamedDeclaration> candidates;\n        if (decompiledContainer instanceof JetFile) {\n            candidates = getInitialTopLevelCandidates(decompiledDeclaration);\n        }\n        else if (decompiledContainer instanceof JetClassBody) {\n            JetClassOrObject decompiledClassOrObject = (JetClassOrObject) decompiledContainer.getParent();\n            JetClassOrObject sourceClassOrObject = getSourceClassOrObject(decompiledClassOrObject);\n\n            //noinspection unchecked\n            candidates = sourceClassOrObject == null\n                         ? Collections.<JetNamedDeclaration>emptyList()\n                         : getInitialMemberCandidates(sourceClassOrObject, memberName, (Class<JetNamedDeclaration>) decompiledDeclaration.getClass());\n\n            if (candidates.isEmpty()) {\n                if (decompiledDeclaration instanceof JetProperty && sourceClassOrObject instanceof JetClass) {\n                    return findSpecialProperty(memberName, (JetClass) sourceClassOrObject);\n                }\n            }\n        }\n        else {\n            throw new IllegalStateException(\"Unexpected container of decompiled declaration: \"\n                                            + decompiledContainer.getClass().getSimpleName());\n        }\n\n        if (!forceResolve) {\n            candidates = filterByReceiverPresenceAndParametersCount(decompiledDeclaration, candidates);\n\n            if (candidates.size() <= 1) {\n                return candidates.isEmpty() ? null : candidates.iterator().next();\n            }\n\n            if (!haveRenamesInImports(getContainingFiles(candidates))) {\n                candidates = filterByReceiverAndParameterTypes(decompiledDeclaration, candidates);\n\n                if (candidates.size() <= 1) {\n                    return candidates.isEmpty() ? null : candidates.iterator().next();\n                }\n            }\n        }\n\n        Project project = decompiledDeclaration.getProject();\n        LockBasedStorageManagerWithExceptionTracking storageManager = LockBasedStorageManagerWithExceptionTracking.create();\n        FileBasedDeclarationProviderFactory providerFactory = new FileBasedDeclarationProviderFactory(storageManager, getContainingFiles(candidates),\n                new Predicate<FqName>() {\n                    @Override\n                    public boolean apply(@Nullable FqName fqName) {\n                        return KotlinBuiltIns.BUILT_INS_PACKAGE_FQ_NAME.equals(fqName);\n                    }\n                });\n        ModuleDescriptorImpl moduleDescriptor = new ModuleDescriptorImpl(Name.special(\"<library module>\"),\n                                                                         AnalyzerFacadeForJVM.DEFAULT_IMPORTS,\n                                                                         PlatformToKotlinClassMap.EMPTY);\n\n        moduleDescriptor.addFragmentProvider(DependencyKind.BUILT_INS, KotlinBuiltIns.getInstance().getBuiltInsModule().getPackageFragmentProvider());\n\n        KotlinCodeAnalyzer analyzer = new ResolveSession(\n                project,\n                storageManager,\n                moduleDescriptor,\n                providerFactory,\n                new BindingTraceContext());\n\n        for (JetNamedDeclaration candidate : candidates) {\n            //noinspection unchecked\n            CallableDescriptor candidateDescriptor = (CallableDescriptor) analyzer.resolveToDescriptor(candidate);\n            if (receiversMatch(decompiledDeclaration, candidateDescriptor)\n                    && valueParametersTypesMatch(decompiledDeclaration, candidateDescriptor)\n                    && typeParametersMatch((JetTypeParameterListOwner) decompiledDeclaration, candidateDescriptor.getTypeParameters())) {\n                return candidate;\n            }\n        }\n\n        return null;\n    }","id":83420,"modified_method":"@Nullable\n    private static JetNamedDeclaration getSourcePropertyOrFunction(@NotNull JetNamedDeclaration decompiledDeclaration) {\n        String memberNameAsString = decompiledDeclaration.getName();\n        assert memberNameAsString != null;\n        Name memberName = Name.identifier(memberNameAsString);\n\n        PsiElement decompiledContainer = decompiledDeclaration.getParent();\n\n        Collection<JetNamedDeclaration> candidates;\n        if (decompiledContainer instanceof JetFile) {\n            candidates = getInitialTopLevelCandidates(decompiledDeclaration);\n        }\n        else if (decompiledContainer instanceof JetClassBody) {\n            JetClassOrObject decompiledClassOrObject = (JetClassOrObject) decompiledContainer.getParent();\n            JetClassOrObject sourceClassOrObject = getSourceClassOrObject(decompiledClassOrObject);\n\n            //noinspection unchecked\n            candidates = sourceClassOrObject == null\n                         ? Collections.<JetNamedDeclaration>emptyList()\n                         : getInitialMemberCandidates(sourceClassOrObject, memberName, (Class<JetNamedDeclaration>) decompiledDeclaration.getClass());\n\n            if (candidates.isEmpty()) {\n                if (decompiledDeclaration instanceof JetProperty && sourceClassOrObject instanceof JetClass) {\n                    return findSpecialProperty(memberName, (JetClass) sourceClassOrObject);\n                }\n            }\n        }\n        else {\n            throw new IllegalStateException(\"Unexpected container of decompiled declaration: \"\n                                            + decompiledContainer.getClass().getSimpleName());\n        }\n\n        if (!forceResolve) {\n            candidates = filterByReceiverPresenceAndParametersCount(decompiledDeclaration, candidates);\n\n            if (candidates.size() <= 1) {\n                return candidates.isEmpty() ? null : candidates.iterator().next();\n            }\n\n            if (!haveRenamesInImports(getContainingFiles(candidates))) {\n                candidates = filterByReceiverAndParameterTypes(decompiledDeclaration, candidates);\n\n                if (candidates.size() <= 1) {\n                    return candidates.isEmpty() ? null : candidates.iterator().next();\n                }\n            }\n        }\n\n        Project project = decompiledDeclaration.getProject();\n        LockBasedStorageManagerWithExceptionTracking storageManager = LockBasedStorageManagerWithExceptionTracking.create();\n        FileBasedDeclarationProviderFactory providerFactory = new FileBasedDeclarationProviderFactory(storageManager, getContainingFiles(candidates),\n                new Predicate<FqName>() {\n                    @Override\n                    public boolean apply(@Nullable FqName fqName) {\n                        return KotlinBuiltIns.BUILT_INS_PACKAGE_FQ_NAME.equals(fqName);\n                    }\n                });\n        ModuleDescriptorImpl moduleDescriptor = new ModuleDescriptorImpl(Name.special(\"<library module>\"),\n                                                                         AnalyzerFacadeForJVM.DEFAULT_IMPORTS,\n                                                                         PlatformToKotlinClassMap.EMPTY);\n\n        moduleDescriptor.addFragmentProvider(DependencyKind.BUILT_INS, KotlinBuiltIns.getInstance().getBuiltInsModule().getPackageFragmentProvider());\n\n        KotlinCodeAnalyzer analyzer = new InjectorForLazyResolve(\n                project,\n                storageManager,\n                moduleDescriptor,\n                providerFactory,\n                new BindingTraceContext()).getResolveSession();\n\n        for (JetNamedDeclaration candidate : candidates) {\n            //noinspection unchecked\n            CallableDescriptor candidateDescriptor = (CallableDescriptor) analyzer.resolveToDescriptor(candidate);\n            if (receiversMatch(decompiledDeclaration, candidateDescriptor)\n                    && valueParametersTypesMatch(decompiledDeclaration, candidateDescriptor)\n                    && typeParametersMatch((JetTypeParameterListOwner) decompiledDeclaration, candidateDescriptor.getTypeParameters())) {\n                return candidate;\n            }\n        }\n\n        return null;\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public AnnotationResolver getAnnotationResolver() {\n        return injector.getAnnotationResolver();\n    }","id":83421,"modified_method":"@NotNull\n    public AnnotationResolver getAnnotationResolver() {\n        return annotationResolve;\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public JetImportsFactory getJetImportsFactory() {\n        return injector.getJetImportsFactory();\n    }","id":83422,"modified_method":"@NotNull\n    public JetImportsFactory getJetImportsFactory() {\n        return jetImportFactory;\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public ScopeProvider getScopeProvider() {\n        return injector.getScopeProvider();\n    }","id":83423,"modified_method":"@NotNull\n    public ScopeProvider getScopeProvider() {\n        return scopeProvider;\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public QualifiedExpressionResolver getQualifiedExpressionResolver() {\n        return injector.getQualifiedExpressionResolver();\n    }","id":83424,"modified_method":"@NotNull\n    public QualifiedExpressionResolver getQualifiedExpressionResolver() {\n        return qualifiedExpressionResolver;\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public DescriptorResolver getDescriptorResolver() {\n        return injector.getDescriptorResolver();\n    }","id":83425,"modified_method":"@NotNull\n    public DescriptorResolver getDescriptorResolver() {\n        return descriptorResolver;\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public TypeResolver getTypeResolver() {\n        return injector.getTypeResolver();\n    }","id":83426,"modified_method":"@NotNull\n    public TypeResolver getTypeResolver() {\n        return typeResolver;\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ResolveSession(\n            @NotNull Project project,\n            @NotNull LockBasedStorageManagerWithExceptionTracking storageManager,\n            @NotNull ModuleDescriptorImpl rootDescriptor,\n            @NotNull DeclarationProviderFactory declarationProviderFactory,\n            @NotNull BindingTrace delegationTrace\n    ) {\n        LockBasedLazyResolveStorageManager lockBasedLazyResolveStorageManager = new LockBasedLazyResolveStorageManager(storageManager);\n        this.storageManager = lockBasedLazyResolveStorageManager;\n        this.exceptionTracker = storageManager.getTracker();\n        this.trace = lockBasedLazyResolveStorageManager.createSafeTrace(delegationTrace);\n        this.injector = new InjectorForLazyResolve(project, this, rootDescriptor);\n        this.module = rootDescriptor;\n\n        this.classifierAliases = NO_ALIASES;\n        this.specialClasses = Predicates.alwaysFalse();\n\n        this.packages = storageManager.createMemoizedFunctionWithNullableValues(new MemoizedFunctionToNullable<FqName, LazyPackageDescriptor>() {\n            @Nullable\n            @Override\n            public LazyPackageDescriptor invoke(FqName fqName) {\n                return createPackage(fqName);\n            }\n        });\n\n        this.declarationProviderFactory = declarationProviderFactory;\n\n        this.packageFragmentProvider = new PackageFragmentProvider() {\n            @NotNull\n            @Override\n            public List<PackageFragmentDescriptor> getPackageFragments(@NotNull FqName fqName) {\n                return ContainerUtil.<PackageFragmentDescriptor>createMaybeSingletonList(getPackageFragment(fqName));\n            }\n\n            @NotNull\n            @Override\n            public Collection<FqName> getSubPackagesOf(@NotNull FqName fqName) {\n                LazyPackageDescriptor packageDescriptor = getPackageFragment(fqName);\n                if (packageDescriptor == null) {\n                    return Collections.emptyList();\n                }\n                return packageDescriptor.getDeclarationProvider().getAllDeclaredPackages();\n            }\n        };\n\n        // TODO: parameter modification\n        rootDescriptor.addFragmentProvider(DependencyKind.SOURCES, packageFragmentProvider);\n    }","id":83427,"modified_method":"@Deprecated\n    public ResolveSession(\n            @NotNull Project project,\n            @NotNull LockBasedStorageManagerWithExceptionTracking storageManager,\n            @NotNull ModuleDescriptorImpl rootDescriptor,\n            @NotNull DeclarationProviderFactory declarationProviderFactory,\n            @NotNull BindingTrace delegationTrace\n    ) {\n        LockBasedLazyResolveStorageManager lockBasedLazyResolveStorageManager = new LockBasedLazyResolveStorageManager(storageManager);\n        this.storageManager = lockBasedLazyResolveStorageManager;\n        this.exceptionTracker = storageManager.getTracker();\n        this.trace = lockBasedLazyResolveStorageManager.createSafeTrace(delegationTrace);\n        this.module = rootDescriptor;\n\n        this.classifierAliases = NO_ALIASES;\n        this.specialClasses = Predicates.alwaysFalse();\n\n        this.packages = storageManager.createMemoizedFunctionWithNullableValues(new MemoizedFunctionToNullable<FqName, LazyPackageDescriptor>() {\n            @Nullable\n            @Override\n            public LazyPackageDescriptor invoke(FqName fqName) {\n                return createPackage(fqName);\n            }\n        });\n\n        this.declarationProviderFactory = declarationProviderFactory;\n\n        this.packageFragmentProvider = new PackageFragmentProvider() {\n            @NotNull\n            @Override\n            public List<PackageFragmentDescriptor> getPackageFragments(@NotNull FqName fqName) {\n                return ContainerUtil.<PackageFragmentDescriptor>createMaybeSingletonList(getPackageFragment(fqName));\n            }\n\n            @NotNull\n            @Override\n            public Collection<FqName> getSubPackagesOf(@NotNull FqName fqName) {\n                LazyPackageDescriptor packageDescriptor = getPackageFragment(fqName);\n                if (packageDescriptor == null) {\n                    return Collections.emptyList();\n                }\n                return packageDescriptor.getDeclarationProvider().getAllDeclaredPackages();\n            }\n        };\n\n        // TODO: parameter modification\n        rootDescriptor.addFragmentProvider(DependencyKind.SOURCES, packageFragmentProvider);\n    }","commit_id":"f526129ca494cdf2dac2f427f41509f8e47aad3e","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static HighlightInfo checkApplicability(PsiAnnotation annotation) {\n    if (!(annotation.getParent() instanceof PsiModifierList)) return null;\n    PsiElement owner = annotation.getParent().getParent();\n    PsiJavaCodeReferenceElement nameRef = annotation.getNameReferenceElement();\n    if (nameRef != null) {\n      PsiElement resolved = nameRef.resolve();\n      if (resolved instanceof PsiClass && ((PsiClass)resolved).isAnnotationType()) {\n        PsiClass annotationType = (PsiClass)resolved;\n        PsiAnnotation metaAnnotation = annotationType.getModifierList().findAnnotation(\"java.lang.annotation.Target\");\n        if (metaAnnotation != null) {\n          PsiNameValuePair[] attributes = metaAnnotation.getParameterList().getAttributes();\n          if (attributes.length >= 1) {\n            PsiField elementType = getElementType(owner);\n            if (elementType != null) {\n              PsiAnnotationMemberValue value = attributes[0].getValue();\n              if (value instanceof PsiArrayInitializerMemberValue) {\n                PsiAnnotationMemberValue[] initializers = ((PsiArrayInitializerMemberValue)value).getInitializers();\n                for (PsiAnnotationMemberValue initializer : initializers) {\n                  if (initializer instanceof PsiReferenceExpression) {\n                    PsiReferenceExpression refExpr = (PsiReferenceExpression)initializer;\n                    if (refExpr.isReferenceTo(elementType)) return null;\n                  }\n                }\n                return formatNotApplicableError(elementType, nameRef);\n              }\n              else if (value instanceof PsiReferenceExpression) {\n                if (!((PsiReferenceExpression)value).isReferenceTo(elementType)) {\n                  return formatNotApplicableError(elementType, nameRef);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }","id":83428,"modified_method":"public static HighlightInfo checkApplicability(PsiAnnotation annotation) {\n    if (!(annotation.getParent() instanceof PsiModifierList)) return null;\n    PsiElement owner = annotation.getParent().getParent();\n    PsiJavaCodeReferenceElement nameRef = annotation.getNameReferenceElement();\n    if (nameRef != null) {\n      PsiElement resolved = nameRef.resolve();\n      if (resolved instanceof PsiClass && ((PsiClass)resolved).isAnnotationType()) {\n        PsiClass annotationType = (PsiClass)resolved;\n        PsiAnnotation metaAnnotation = annotationType.getModifierList().findAnnotation(\"java.lang.annotation.Target\");\n        if (metaAnnotation != null) {\n          PsiNameValuePair[] attributes = metaAnnotation.getParameterList().getAttributes();\n          if (attributes.length >= 1) {\n            PsiField[] elementTypeFields = getElementTypeFields(owner);\n            if (elementTypeFields == null) return null;\n            LOG.assertTrue(elementTypeFields.length > 0);\n            for (PsiField field : elementTypeFields) {\n              PsiAnnotationMemberValue value = attributes[0].getValue();\n              if (value instanceof PsiArrayInitializerMemberValue) {\n                PsiAnnotationMemberValue[] initializers = ((PsiArrayInitializerMemberValue)value).getInitializers();\n                for (PsiAnnotationMemberValue initializer : initializers) {\n                  if (initializer instanceof PsiReferenceExpression) {\n                    PsiReferenceExpression refExpr = (PsiReferenceExpression)initializer;\n                    if (refExpr.isReferenceTo(field)) return null;\n                  }\n                }\n              }\n              else if (value instanceof PsiReferenceExpression) {\n                if (((PsiReferenceExpression)value).isReferenceTo(field)) return null;\n              }\n            }\n            return formatNotApplicableError(elementTypeFields[0], nameRef);\n          }\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"53ed5d33e0ae6a8ceea03b27fc16b93f78010c65","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiField getElementType(PsiElement owner) {\n    PsiManager manager = owner.getManager();\n    PsiClass elementTypeClass = manager.findClass(\"java.lang.annotation.ElementType\", owner.getResolveScope());\n    if (elementTypeClass == null) return null;\n\n    if (owner instanceof PsiClass) {\n      if (((PsiClass)owner).isAnnotationType()) {\n        return elementTypeClass.findFieldByName(\"ANNOTATION_TYPE\", false);\n      }\n      else {\n        return elementTypeClass.findFieldByName(\"TYPE\", false);\n      }\n    } else if (owner instanceof PsiMethod) {\n      if (((PsiMethod)owner).isConstructor()) {\n        return elementTypeClass.findFieldByName(\"CONSTRUCTOR\", false);\n      }\n      else {\n        return elementTypeClass.findFieldByName(\"METHOD\", false);\n      }\n    } else if (owner instanceof PsiField) {\n      return elementTypeClass.findFieldByName(\"FIELD\", false);\n    } else if (owner instanceof PsiParameter) {\n      return elementTypeClass.findFieldByName(\"PARAMETER\", false);\n    } else if (owner instanceof PsiLocalVariable) {\n      return elementTypeClass.findFieldByName(\"LOCAL_VARIABLE\", false);\n    } else if (owner instanceof PsiPackage) {\n      return elementTypeClass.findFieldByName(\"PACKAGE\", false);\n    }\n\n    return null;\n  }","id":83429,"modified_method":"private static PsiField[] getElementTypeFields(PsiElement owner) {\n    PsiManager manager = owner.getManager();\n    PsiClass elementTypeClass = manager.findClass(\"java.lang.annotation.ElementType\", owner.getResolveScope());\n    if (elementTypeClass == null) return null;\n\n    if (owner instanceof PsiClass) {\n      if (((PsiClass)owner).isAnnotationType()) {\n        return getFields(elementTypeClass, \"ANNOTATION_TYPE\", \"TYPE\");\n      }\n      else {\n        return getFields(elementTypeClass, \"TYPE\");\n      }\n    }\n    else if (owner instanceof PsiMethod) {\n      if (((PsiMethod)owner).isConstructor()) {\n        return getFields(elementTypeClass, \"CONSTRUCTOR\");\n      }\n      else {\n        return getFields(elementTypeClass, \"METHOD\");\n      }\n    }\n    else if (owner instanceof PsiField) {\n      return getFields(elementTypeClass, \"FIELD\");\n    }\n    else if (owner instanceof PsiParameter) {\n      return getFields(elementTypeClass, \"PARAMETER\");\n    }\n    else if (owner instanceof PsiLocalVariable) {\n      return getFields(elementTypeClass, \"LOCAL_VARIABLE\");\n    }\n    else if (owner instanceof PsiPackage) {\n      return getFields(elementTypeClass, \"PACKAGE\");\n    }\n\n    return null;\n  }","commit_id":"53ed5d33e0ae6a8ceea03b27fc16b93f78010c65","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static XmlTag find(String subTag, String withValue, String forTag, XmlTag insideRoot) {\n    final XmlTag[] forTags = insideRoot.findSubTags(forTag);\n    \n    for (XmlTag tag : forTags) {\n      final XmlTag[] allTags = tag.findSubTags(subTag);\n      \n      for (int j = 0; j < allTags.length; j++) {\n        XmlTag curTag = allTags[j];\n        if (curTag.getName().equals(subTag) && curTag.getValue().getTrimmedText().equalsIgnoreCase(withValue)) {\n          return tag;\n        }\n      }\n    }\n\n    return null;\n  }","id":83430,"modified_method":"public static XmlTag find(String subTag, String withValue, String forTag, XmlTag insideRoot) {\n    final XmlTag[] forTags = insideRoot.findSubTags(forTag);\n    \n    for (XmlTag tag : forTags) {\n      final XmlTag[] allTags = tag.findSubTags(subTag);\n\n      for (XmlTag curTag : allTags) {\n        if (curTag.getName().equals(subTag) && curTag.getValue().getTrimmedText().equalsIgnoreCase(withValue)) {\n          return tag;\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"52f1727401c4566b72abd4e4327dbd7c9bc3888a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String generateDocumentDTD(XmlDocument doc) {\n    final StringBuffer buffer = new StringBuffer();\n    final Map<String,List<String>> tags = new HashMap<String, List<String>>();\n    final Map<String,List<MyAttributeInfo>> attributes = new HashMap<String, List<MyAttributeInfo>>();\n    computeTag(doc.getRootTag(), tags, attributes);\n    final Iterator<String> iter = tags.keySet().iterator();\n    while (iter.hasNext()) {\n      final String tagName = iter.next();\n      buffer.append(generateElementDTD(tagName, tags.get(tagName), attributes.get(tagName)));\n    }\n    return buffer.toString();\n  }","id":83431,"modified_method":"public static String generateDocumentDTD(XmlDocument doc) {\n    final StringBuffer buffer = new StringBuffer();\n    final Map<String,List<String>> tags = new HashMap<String, List<String>>();\n    final Map<String,List<MyAttributeInfo>> attributes = new HashMap<String, List<MyAttributeInfo>>();\n    final XmlTag rootTag = doc.getRootTag();\n    computeTag(rootTag, tags, attributes);\n    \n    // For supporting not welformed XML\n    for(PsiElement element = rootTag != null ? rootTag.getNextSibling():null; \n        element != null; \n        element = element.getNextSibling()\n    ) {\n      if (element instanceof XmlTag) {\n        computeTag((XmlTag)element, tags, attributes);\n      }\n    }\n    \n    final Iterator<String> iter = tags.keySet().iterator();\n    while (iter.hasNext()) {\n      final String tagName = iter.next();\n      buffer.append(generateElementDTD(tagName, tags.get(tagName), attributes.get(tagName)));\n    }\n    return buffer.toString();\n  }","commit_id":"52f1727401c4566b72abd4e4327dbd7c9bc3888a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String validate(PsiElement context) {\n    final WebModuleProperties properties = ((JspFile)context.getContainingFile()).getWebModuleProperties();\n\n    if(properties != null) {\n      final TagExtraInfo info = getExtraInfo(properties);\n      if (info == null) return null;\n      //final JspToken end = getEndToken(context);\n      //if (end == null) return false;\n\n      try {\n        //info.getVariableInfo(JspImplUtil.getTagData((XmlTag)context));\n        if (info.isValid(JspImplUtil.getTagData((XmlTag)context))) return null;\n      }\n      catch (Throwable e) {\n        return \"Exception during TEI processing occured: \" + e.getMessage();\n      }\n\n      return \"Wrong Tag Data\";\n    }\n    return null;\n  }","id":83432,"modified_method":"public void validate(PsiElement context,ValidationHost host) {\n    final WebModuleProperties properties = ((JspFile)context.getContainingFile()).getWebModuleProperties();\n\n    if(properties != null) {\n      final TagExtraInfo info = getExtraInfo(properties);\n      if (info == null) return;\n      //final JspToken end = getEndToken(context);\n      //if (end == null) return false;\n\n      try {\n        //info.getVariableInfo(JspImplUtil.getTagData((XmlTag)context));\n        if (info.isValid(JspImplUtil.getTagData((XmlTag)context))) return;\n      }\n      catch (Throwable e) {\n        host.addMessage(context,\"Exception during TEI processing occured: \" + e.getMessage(),ValidationHost.ERROR);\n      }\n\n      host.addMessage(context,\"Wrong Tag Data\",ValidationHost.ERROR);\n    }\n  }","commit_id":"e1c26aa583f4269634e993091800c0718eb0d734","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkTagByDescriptor(final XmlTag tag) {\n    String name = tag.getName();\n\n    XmlElementDescriptor elementDescriptor;\n\n    if (tag.getParent() instanceof XmlTag) {\n      XmlTag parentTag = (XmlTag)tag.getParent();\n      elementDescriptor = parentTag.getDescriptor();\n      if (elementDescriptor == null) { return; }\n\n      elementDescriptor = elementDescriptor.getElementDescriptor(tag);\n      \n      if (elementDescriptor instanceof AnyXmlElementDescriptor) {\n        elementDescriptor = tag.getDescriptor();\n      }\n      if (elementDescriptor == null) {\n        addElementsForTag(tag, \"Element \" + name + \" is not allowed here\", myResult, HighlightInfoType.WRONG_REF, null);\n        return;\n      }\n    }\n    else {\n      //root tag\n      elementDescriptor = tag.getDescriptor();\n\n     if (elementDescriptor == null) {\n       addElementsForTag(tag, \"Element \" + name + \" must be declared\", myResult, HighlightInfoType.WRONG_REF, null);\n       return;\n      }\n    }\n\n    final XmlAttributeDescriptor[] attributeDescriptors = elementDescriptor.getAttributesDescriptors();\n    Set<String> requiredAttributes = null;\n\n    for (int i = 0; i < attributeDescriptors.length; i++) {\n      XmlAttributeDescriptor attribute = attributeDescriptors[i];\n      if (attribute != null && attribute.isRequired()) {\n        if (requiredAttributes == null) {\n          requiredAttributes = new HashSet<String>();\n        }\n        requiredAttributes.add(attribute.getDefaultName());\n      }\n    }\n\n    if (requiredAttributes != null) {\n      for (Iterator<String> iterator = requiredAttributes.iterator(); iterator.hasNext();) {\n        final String attrName = iterator.next();\n\n        if (tag.getAttribute(attrName, XmlUtil.ALL_NAMESPACE) == null) {\n          addElementsForTag(\n            tag,\n            \"Element \" + name + \" doesn't have required attribute\",\n            myResult,\n            HighlightInfoType.WRONG_REF,\n            new IntentionAction() {\n              public String getText() {\n                return \"Insert Required Attribute\";\n              }\n\n              public String getFamilyName() {\n                return \"Insert Required Attribute\";\n              }\n\n              public boolean isAvailable(Project project, Editor editor, PsiFile file) {\n                return true;\n              }\n\n              public void invoke(final Project project, final Editor editor, final PsiFile file) {\n                ASTNode treeElement = SourceTreeToPsiMap.psiElementToTree(tag);\n                PsiElement anchor = SourceTreeToPsiMap.treeElementToPsi(\n                  XmlChildRole.EMPTY_TAG_END_FINDER.findChild(treeElement)\n                );\n\n                if (anchor==null) {\n                  anchor = SourceTreeToPsiMap.treeElementToPsi(\n                    XmlChildRole.START_TAG_END_FINDER.findChild(treeElement)\n                  );\n                }\n\n                if (anchor == null) return;\n\n                final Template template = TemplateManager.getInstance(project).createTemplate(\"\",\"\");\n                template.addTextSegment(\" \"+ attrName + \"=\\\"\");\n\n                Expression expression = new Expression() {\n                  TextResult result = new TextResult(\"\");\n                  public Result calculateResult(ExpressionContext context) {\n                    return result;\n                  }\n\n                  public Result calculateQuickResult(ExpressionContext context) {\n                    return null;\n                  }\n\n                  public LookupItem[] calculateLookupItems(ExpressionContext context) {\n                    return new LookupItem[0];\n                  }\n                };\n                template.addVariable(\"name\",expression,expression,true);\n                template.addTextSegment(\"\\\"\");\n\n                final PsiElement anchor1 = anchor;\n\n                final Runnable runnable = new Runnable() {\n                  public void run() {\n                    ApplicationManager.getApplication().runWriteAction(\n                      new Runnable() {\n                        public void run() {\n                          int textOffset = anchor1.getTextOffset();\n                          editor.getCaretModel().moveToOffset(textOffset);\n                          TemplateManager.getInstance(project).startTemplate(editor, template, null);\n                        }\n                      }\n                    );\n                  }\n                };\n\n                if (!ApplicationManager.getApplication().isUnitTestMode()) {\n                  Runnable commandRunnable = new Runnable() {\n                    public void run() {\n                      CommandProcessor.getInstance().executeCommand(\n                        project,\n                        runnable,\n                        getText(),\n                        getFamilyName()\n                      );\n                    }\n                  };\n\n                  ApplicationManager.getApplication().invokeLater(commandRunnable);\n                }\n                else {\n                  runnable.run();\n                }\n              }\n\n              public boolean startInWriteAction() {\n                return true;\n              }\n            }\n          );\n          return;\n        }\n      }\n    }\n\n    if (elementDescriptor instanceof Validator) {\n      final String s = ((Validator)elementDescriptor).validate(tag);\n      if (s!=null && s.length() > 0) {\n        myResult.add(HighlightInfo.createHighlightInfo(HighlightInfoType.WRONG_REF,tag,s));\n      }\n    }\n  }","id":83433,"modified_method":"private void checkTagByDescriptor(final XmlTag tag) {\n    String name = tag.getName();\n\n    XmlElementDescriptor elementDescriptor;\n\n    if (tag.getParent() instanceof XmlTag) {\n      XmlTag parentTag = (XmlTag)tag.getParent();\n      elementDescriptor = parentTag.getDescriptor();\n      if (elementDescriptor == null) { return; }\n\n      elementDescriptor = elementDescriptor.getElementDescriptor(tag);\n      \n      if (elementDescriptor instanceof AnyXmlElementDescriptor) {\n        elementDescriptor = tag.getDescriptor();\n      }\n      if (elementDescriptor == null) {\n        addElementsForTag(tag, \"Element \" + name + \" is not allowed here\", myResult, HighlightInfoType.WRONG_REF, null);\n        return;\n      }\n    }\n    else {\n      //root tag\n      elementDescriptor = tag.getDescriptor();\n\n     if (elementDescriptor == null) {\n       addElementsForTag(tag, \"Element \" + name + \" must be declared\", myResult, HighlightInfoType.WRONG_REF, null);\n       return;\n      }\n    }\n\n    final XmlAttributeDescriptor[] attributeDescriptors = elementDescriptor.getAttributesDescriptors();\n    Set<String> requiredAttributes = null;\n\n    for (int i = 0; i < attributeDescriptors.length; i++) {\n      XmlAttributeDescriptor attribute = attributeDescriptors[i];\n      if (attribute != null && attribute.isRequired()) {\n        if (requiredAttributes == null) {\n          requiredAttributes = new HashSet<String>();\n        }\n        requiredAttributes.add(attribute.getDefaultName());\n      }\n    }\n\n    if (requiredAttributes != null) {\n      for (Iterator<String> iterator = requiredAttributes.iterator(); iterator.hasNext();) {\n        final String attrName = iterator.next();\n\n        if (tag.getAttribute(attrName, XmlUtil.ALL_NAMESPACE) == null) {\n          addElementsForTag(\n            tag,\n            \"Element \" + name + \" doesn't have required attribute\",\n            myResult,\n            HighlightInfoType.WRONG_REF,\n            new IntentionAction() {\n              public String getText() {\n                return \"Insert Required Attribute\";\n              }\n\n              public String getFamilyName() {\n                return \"Insert Required Attribute\";\n              }\n\n              public boolean isAvailable(Project project, Editor editor, PsiFile file) {\n                return true;\n              }\n\n              public void invoke(final Project project, final Editor editor, final PsiFile file) {\n                ASTNode treeElement = SourceTreeToPsiMap.psiElementToTree(tag);\n                PsiElement anchor = SourceTreeToPsiMap.treeElementToPsi(\n                  XmlChildRole.EMPTY_TAG_END_FINDER.findChild(treeElement)\n                );\n\n                if (anchor==null) {\n                  anchor = SourceTreeToPsiMap.treeElementToPsi(\n                    XmlChildRole.START_TAG_END_FINDER.findChild(treeElement)\n                  );\n                }\n\n                if (anchor == null) return;\n\n                final Template template = TemplateManager.getInstance(project).createTemplate(\"\",\"\");\n                template.addTextSegment(\" \"+ attrName + \"=\\\"\");\n\n                Expression expression = new Expression() {\n                  TextResult result = new TextResult(\"\");\n                  public Result calculateResult(ExpressionContext context) {\n                    return result;\n                  }\n\n                  public Result calculateQuickResult(ExpressionContext context) {\n                    return null;\n                  }\n\n                  public LookupItem[] calculateLookupItems(ExpressionContext context) {\n                    return new LookupItem[0];\n                  }\n                };\n                template.addVariable(\"name\",expression,expression,true);\n                template.addTextSegment(\"\\\"\");\n\n                final PsiElement anchor1 = anchor;\n\n                final Runnable runnable = new Runnable() {\n                  public void run() {\n                    ApplicationManager.getApplication().runWriteAction(\n                      new Runnable() {\n                        public void run() {\n                          int textOffset = anchor1.getTextOffset();\n                          editor.getCaretModel().moveToOffset(textOffset);\n                          TemplateManager.getInstance(project).startTemplate(editor, template, null);\n                        }\n                      }\n                    );\n                  }\n                };\n\n                if (!ApplicationManager.getApplication().isUnitTestMode()) {\n                  Runnable commandRunnable = new Runnable() {\n                    public void run() {\n                      CommandProcessor.getInstance().executeCommand(\n                        project,\n                        runnable,\n                        getText(),\n                        getFamilyName()\n                      );\n                    }\n                  };\n\n                  ApplicationManager.getApplication().invokeLater(commandRunnable);\n                }\n                else {\n                  runnable.run();\n                }\n              }\n\n              public boolean startInWriteAction() {\n                return true;\n              }\n            }\n          );\n          return;\n        }\n      }\n    }\n\n    if (elementDescriptor instanceof Validator) {\n      ((Validator)elementDescriptor).validate(tag,this);\n    }\n  }","commit_id":"e1c26aa583f4269634e993091800c0718eb0d734","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitXmlDocument(XmlDocument document) {\n    if (!(document.getRootTag() instanceof HtmlTag) &&\n        document.getContainingFile().getFileType() != StdFileTypes.JSPX\n        ) {\n      runJaxpValidation(document, myResult);\n    }\n  }","id":83434,"modified_method":"public void visitXmlDocument(XmlDocument document) {\n    final XmlTag rootTag = document.getRootTag();\n    final XmlNSDescriptor nsDescriptor = (rootTag!=null)?rootTag.getNSDescriptor(rootTag.getNamespace(), false):null;\n\n    if (nsDescriptor instanceof Validator) {\n      ((Validator)nsDescriptor).validate(document, this);\n    }\n  }","commit_id":"e1c26aa583f4269634e993091800c0718eb0d734","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public XmlTag createTagFromText(String text) throws IncorrectOperationException {\n    return ((XmlFile)createFileFromText(\"dummy.xml\", text)).getDocument().getRootTag();\n  }","id":83435,"modified_method":"@NotNull\n  public XmlTag createTagFromText(String text) throws IncorrectOperationException {\n    final XmlTag tag = ((XmlFile)createFileFromText(\"dummy.xml\", text)).getDocument().getRootTag();\n    if (tag == null) throw new IncorrectOperationException(\"Incorrect tag text\");\n    return tag;\n  }","commit_id":"561d40a990f2c6e230a45ca71e33ff77b170fae2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TestFile getTestWorkDir() {\n        return getDistribution().getTestWorkDir();\n    }","id":83436,"modified_method":"public TestFile getTestWorkDir() {\n        return getTemporaryFolder().getTestWorkDir();\n    }","commit_id":"187eee6fafcff3938b4b94ac72b85c29d054cde1","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Returns a scratch-pad directory for the current test. This directory is not shared with any other tests.\n     */\n    public TestFile getTestWorkDir() {\n        return temporaryFolder.getDir();\n    }","id":83437,"modified_method":"private TestFile getTestWorkDir() {\n        return testWorkDirProvider.getTestWorkDir();\n    }","commit_id":"187eee6fafcff3938b4b94ac72b85c29d054cde1","url":"https://github.com/gradle/gradle"},{"original_method":"public GradleDistributionExecuter executer() {\n        return new GradleDistributionExecuter(this);\n    }","id":83438,"modified_method":"public GradleDistributionExecuter executer() {\n        return new GradleDistributionExecuter(this, testWorkDirProvider);\n    }","commit_id":"187eee6fafcff3938b4b94ac72b85c29d054cde1","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Returns a previous version of Gradle.\n     *\n     * @param version The Gradle version\n     * @return An executer\n     */\n    public BasicGradleDistribution previousVersion(String version) {\n        if (version.equals(this.getVersion())) {\n            return this;\n        }\n        return new PreviousGradleVersionExecuter(this, version);\n    }","id":83439,"modified_method":"/**\n     * Returns a previous version of Gradle.\n     *\n     * @param version The Gradle version\n     * @return An executer\n     */\n    public BasicGradleDistribution previousVersion(String version) {\n        if (version.equals(this.getVersion())) {\n            return this;\n        }\n        return new PreviousGradleVersionExecuter(version, getPreviousVersionsDir().file(version));\n    }","commit_id":"187eee6fafcff3938b4b94ac72b85c29d054cde1","url":"https://github.com/gradle/gradle"},{"original_method":"private TestFile getTmpDir() {\n        return dist.getTestWorkDir().file(\"tmp\");\n    }","id":83440,"modified_method":"private TestFile getTmpDir() {\n        return new TestFile(getWorkingDir(), \"tmp\");\n    }","commit_id":"187eee6fafcff3938b4b94ac72b85c29d054cde1","url":"https://github.com/gradle/gradle"},{"original_method":"protected GradleExecuter configureExecuter() {\n        if (!workingDirSet) {\n            inDirectory(dist.getTestWorkDir());\n        }\n        if (!gradleUserHomeDirSet) {\n            withGradleUserHomeDir(dist.getUserHomeDir());\n        }\n        if (getDaemonIdleTimeoutSecs() == null) {\n            if (dist.isUsingIsolatedDaemons() || getDaemonBaseDir() != null) {\n                withDaemonIdleTimeoutSecs(20);\n            } else {\n                withDaemonIdleTimeoutSecs(DEFAULT_DAEMON_IDLE_TIMEOUT_SECS);\n            }\n        }\n        if (getDaemonBaseDir() == null) {\n            withDaemonBaseDir(dist.getDaemonBaseDir());\n        }\n\n        if (!getClass().desiredAssertionStatus()) {\n            throw new RuntimeException(\"Assertions must be enabled when running integration tests.\");\n        }\n\n        GradleExecuter gradleExecuter = createExecuter(executerType);\n        configureExecuter(gradleExecuter);\n        try {\n            gradleExecuter.assertCanExecute();\n        } catch (AssertionError assertionError) {\n            gradleExecuter = new ForkingGradleExecuter(dist.getGradleHomeDir());\n            configureExecuter(gradleExecuter);\n        }\n\n        return gradleExecuter;\n    }","id":83441,"modified_method":"protected GradleExecuter configureExecuter() {\n        if (!workingDirSet) {\n            inDirectory(testWorkDirProvider.getTestWorkDir());\n        }\n        if (!gradleUserHomeDirSet) {\n            withGradleUserHomeDir(dist.getUserHomeDir());\n        }\n        if (getDaemonIdleTimeoutSecs() == null) {\n            if (dist.isUsingIsolatedDaemons() || getDaemonBaseDir() != null) {\n                withDaemonIdleTimeoutSecs(20);\n            } else {\n                withDaemonIdleTimeoutSecs(DEFAULT_DAEMON_IDLE_TIMEOUT_SECS);\n            }\n        }\n        if (getDaemonBaseDir() == null) {\n            withDaemonBaseDir(dist.getDaemonBaseDir());\n        }\n\n        if (!getClass().desiredAssertionStatus()) {\n            throw new RuntimeException(\"Assertions must be enabled when running integration tests.\");\n        }\n\n        GradleExecuter gradleExecuter = createExecuter(executerType);\n        configureExecuter(gradleExecuter);\n        try {\n            gradleExecuter.assertCanExecute();\n        } catch (AssertionError assertionError) {\n            gradleExecuter = new ForkingGradleExecuter(dist.getGradleHomeDir());\n            configureExecuter(gradleExecuter);\n        }\n\n        return gradleExecuter;\n    }","commit_id":"187eee6fafcff3938b4b94ac72b85c29d054cde1","url":"https://github.com/gradle/gradle"},{"original_method":"public Statement apply(final Statement base, FrameworkMethod method, final Object target) {\n        return new Statement() {\n            @Override\n            public void evaluate() throws Throwable {\n                dist = RuleHelper.getField(target, GradleDistribution.class);\n                try {\n                    base.evaluate();\n                } finally {\n                    SwingUtilities.invokeAndWait(new Runnable() {\n                        public void run() {\n                            for (JFrame frame : frames) {\n                                frame.dispose();\n                            }\n                        }\n                    });\n                }\n            }\n        };\n    }","id":83442,"modified_method":"public Statement apply(final Statement base, FrameworkMethod method, final Object target) {\n        return new Statement() {\n            @Override\n            public void evaluate() throws Throwable {\n                dist = RuleHelper.getField(target, GradleDistribution.class);\n                testWorkDirProvider = RuleHelper.getField(target, TestWorkDirProvider.class);\n                try {\n                    base.evaluate();\n                } finally {\n                    SwingUtilities.invokeAndWait(new Runnable() {\n                        public void run() {\n                            for (JFrame frame : frames) {\n                                frame.dispose();\n                            }\n                        }\n                    });\n                }\n            }\n        };\n    }","commit_id":"187eee6fafcff3938b4b94ac72b85c29d054cde1","url":"https://github.com/gradle/gradle"},{"original_method":"public DualPaneUIVersion1 createDualPaneUI() {\n        TestSingleDualPaneUIInteractionVersion1 testSingleDualPaneUIInteractionVersion1 = new TestSingleDualPaneUIInteractionVersion1(new TestAlternateUIInteractionVersion1(), new TestSettingsNodeVersion1());\n        DualPaneUIVersion1 dualPane;\n        try {\n            dualPane = UIFactory.createDualPaneUI(getClass().getClassLoader(), dist.getGradleHomeDir(), testSingleDualPaneUIInteractionVersion1, false);\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n\n        //make sure we got something\n        Assert.assertNotNull(dualPane);\n\n        dualPane.setCurrentDirectory(dist.getTestWorkDir());\n        dualPane.addCommandLineArgumentAlteringListener(new ExtraTestCommandLineOptionsListener(dist.getUserHomeDir()));\n\n        return dualPane;\n    }","id":83443,"modified_method":"public DualPaneUIVersion1 createDualPaneUI() {\n        TestSingleDualPaneUIInteractionVersion1 testSingleDualPaneUIInteractionVersion1 = new TestSingleDualPaneUIInteractionVersion1(new TestAlternateUIInteractionVersion1(), new TestSettingsNodeVersion1());\n        DualPaneUIVersion1 dualPane;\n        try {\n            dualPane = UIFactory.createDualPaneUI(getClass().getClassLoader(), dist.getGradleHomeDir(), testSingleDualPaneUIInteractionVersion1, false);\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n\n        //make sure we got something\n        Assert.assertNotNull(dualPane);\n\n        dualPane.setCurrentDirectory(testWorkDirProvider.getTestWorkDir());\n        dualPane.addCommandLineArgumentAlteringListener(new ExtraTestCommandLineOptionsListener(dist.getUserHomeDir()));\n\n        return dualPane;\n    }","commit_id":"187eee6fafcff3938b4b94ac72b85c29d054cde1","url":"https://github.com/gradle/gradle"},{"original_method":"public SinglePaneUIVersion1 createSinglePaneUI() {\n        TestSingleDualPaneUIInteractionVersion1 testSingleDualPaneUIInteractionVersion1 = new TestSingleDualPaneUIInteractionVersion1(new TestAlternateUIInteractionVersion1(), new TestSettingsNodeVersion1());\n        SinglePaneUIVersion1 singlePane;\n        try {\n            singlePane = UIFactory.createSinglePaneUI(getClass().getClassLoader(), dist.getGradleHomeDir(), testSingleDualPaneUIInteractionVersion1, false);\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n\n        //make sure we got something\n        Assert.assertNotNull(singlePane);\n\n        singlePane.setCurrentDirectory(dist.getTestWorkDir());\n        singlePane.addCommandLineArgumentAlteringListener(new ExtraTestCommandLineOptionsListener(dist.getUserHomeDir()));\n\n        return singlePane;\n    }","id":83444,"modified_method":"public SinglePaneUIVersion1 createSinglePaneUI() {\n        TestSingleDualPaneUIInteractionVersion1 testSingleDualPaneUIInteractionVersion1 = new TestSingleDualPaneUIInteractionVersion1(new TestAlternateUIInteractionVersion1(), new TestSettingsNodeVersion1());\n        SinglePaneUIVersion1 singlePane;\n        try {\n            singlePane = UIFactory.createSinglePaneUI(getClass().getClassLoader(), dist.getGradleHomeDir(), testSingleDualPaneUIInteractionVersion1, false);\n        } catch (Exception e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n\n        //make sure we got something\n        Assert.assertNotNull(singlePane);\n\n        singlePane.setCurrentDirectory(testWorkDirProvider.getTestWorkDir());\n        singlePane.addCommandLineArgumentAlteringListener(new ExtraTestCommandLineOptionsListener(dist.getUserHomeDir()));\n\n        return singlePane;\n    }","commit_id":"187eee6fafcff3938b4b94ac72b85c29d054cde1","url":"https://github.com/gradle/gradle"},{"original_method":"public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n        dist = RuleHelper.getField(target, GradleDistribution.class);\n        final String sampleName = getSampleName(method);\n        sampleDir = sampleName == null ? null : dist.getTestWorkDir().file(sampleName);\n\n        return new Statement() {\n            @Override\n            public void evaluate() throws Throwable {\n                if (sampleName != null) {\n                    TestFile srcDir = dist.getSamplesDir().file(sampleName).assertIsDir();\n                    logger.debug(\"Copying sample '{}' to test directory.\", sampleName);\n                    srcDir.copyTo(sampleDir);\n                } else {\n                    logger.debug(\"No sample specified for this test, skipping.\");\n                }\n                base.evaluate();\n            }\n        };\n    }","id":83445,"modified_method":"public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n        final GradleDistribution dist = RuleHelper.getField(target, GradleDistribution.class);\n        final TestWorkDirProvider testWorkDirProvider = RuleHelper.getField(target, TestWorkDirProvider.class);\n\n        final String sampleName = getSampleName(method);\n        sampleDir = sampleName == null ? null : testWorkDirProvider.getTestWorkDir().file(sampleName);\n\n        return new Statement() {\n            @Override\n            public void evaluate() throws Throwable {\n                if (sampleName != null) {\n                    TestFile srcDir = dist.getSamplesDir().file(sampleName).assertIsDir();\n                    logger.debug(\"Copying sample '{}' to test directory.\", sampleName);\n                    srcDir.copyTo(sampleDir);\n                } else {\n                    logger.debug(\"No sample specified for this test, skipping.\");\n                }\n                base.evaluate();\n            }\n        };\n    }","commit_id":"187eee6fafcff3938b4b94ac72b85c29d054cde1","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Will create a {@link org.mule.api.transformer.DataType} object from an object instance. This method will check\n     * if the object o is a {@link org.mule.api.MuleMessage} instance and will take the type from the message payload\n     * and check if a mime type is set on the message and used that when constructing the {@link org.mule.api.transformer.DataType}\n     * object.\n     *\n     * @param o an object instance.  This can be a {@link org.mule.api.MuleMessage}, a collection, a proxy instance or any other\n     *          object\n     * @return a data type that represents the object type.\n     */\n    public DataType createFromObject(Object o)\n    {\n        Class type = o.getClass();\n        String mime = null;\n        if (o instanceof MuleMessage)\n        {\n            MuleMessage mm = (MuleMessage) o;\n            type = mm.getPayload().getClass();\n            //TODO better mime handling, see MULE-4639\n//            mime = mm.getStringProperty(\"Content-Type\", null);\n//            if(mime!=null)\n//            {\n//                int i = mime.indexOf(\";\");\n//                mime = (i >-1 ? mime.substring(0, i) : mime);\n//            }\n        }\n        return create(type, mime);\n    }","id":83446,"modified_method":"/**\n     * Will create a {@link org.mule.api.transformer.DataType} object from an object instance. This method will check\n     * if the object o is a {@link org.mule.api.MuleMessage} instance and will take the type from the message payload\n     * and check if a mime type is set on the message and used that when constructing the {@link org.mule.api.transformer.DataType}\n     * object.\n     *\n     * @param o an object instance.  This can be a {@link org.mule.api.MuleMessage}, a collection, a proxy instance or any other\n     *          object\n     * @return a data type that represents the object type.\n     */\n    public DataType createFromObject(Object o)\n    {\n        Class type = o.getClass();\n        String mime = null;\n        if (o instanceof MuleMessage)\n        {\n            MuleMessage mm = (MuleMessage) o;\n            type = mm.getPayload().getClass();\n            //TODO better mime handling, see MULE-4639\n            mime = mm.getStringProperty(\"Content-Type\", null);\n            if(mime!=null)\n            {\n                int i = mime.indexOf(\";\");\n                mime = (i >-1 ? mime.substring(0, i) : mime);\n            }\n        }\n        if(mime==null)\n        {\n            mime = MimeTypes.ANY;\n        }\n\n        return create(type, mime);\n    }","commit_id":"c44f63e08db4b819539f9b61b60fc8a3bb83e5bb","url":"https://github.com/mulesoft/mule"},{"original_method":"public DataType create(Class type)\n    {\n        return create(type, (String) null);\n    }","id":83447,"modified_method":"public DataType create(Class type)\n    {\n        return create(type, MimeTypes.ANY);\n    }","commit_id":"c44f63e08db4b819539f9b61b60fc8a3bb83e5bb","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testCollectionTypes() throws Exception\n    {\n        DataTypeFactory factory = new DataTypeFactory();\n        DataType dt = factory.create(List.class);\n        DataType dt2 = factory.create(List.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertEquals(dt, dt2);\n\n        dt2 = factory.create(ArrayList.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        //Check mime type matching\n        dt2 = factory.create(ArrayList.class, \"application/list+java\");\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        dt.setMimeType(\"*/*\");\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        dt = factory.create(List.class);\n        dt2 = factory.create(Set.class);\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n    }","id":83448,"modified_method":"public void testCollectionTypes() throws Exception\n    {\n        DataTypeFactory factory = new DataTypeFactory();\n        DataType dt = factory.create(List.class);\n        DataType dt2 = factory.create(List.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertEquals(dt, dt2);\n\n        dt2 = factory.create(ArrayList.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        //Check mime type matching\n        dt2 = factory.create(ArrayList.class, \"application/list+java\");\n\n        //Will match because the default mime type is '*/*'        \n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        dt.setMimeType(MimeTypes.BINARY);\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        dt = factory.create(List.class);\n        dt2 = factory.create(Set.class);\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n    }","commit_id":"c44f63e08db4b819539f9b61b60fc8a3bb83e5bb","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSimpleTypes() throws Exception\n    {\n        DataTypeFactory factory = new DataTypeFactory();\n        DataType dt = factory.create(Exception.class);\n        DataType dt2 = factory.create(Exception.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertEquals(dt, dt2);\n\n        dt2 = factory.create(IOException.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        //Check mime type matching\n        dt2 = factory.create(IOException.class, \"application/exception+java\");\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        dt.setMimeType(\"*/*\");\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        dt = factory.create(Exception.class);\n        dt2 = factory.create(String.class);\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n    }","id":83449,"modified_method":"public void testSimpleTypes() throws Exception\n    {\n        DataTypeFactory factory = new DataTypeFactory();\n        DataType dt = factory.create(Exception.class);\n        DataType dt2 = factory.create(Exception.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertEquals(dt, dt2);\n\n        dt2 = factory.create(IOException.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        //Check mime type matching\n        dt2 = factory.create(IOException.class, \"application/exception+java\");\n\n        //Will match because the default mime type is '*/*'\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        dt.setMimeType(MimeTypes.BINARY);\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        dt = factory.create(Exception.class);\n        dt2 = factory.create(String.class);\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n    }","commit_id":"c44f63e08db4b819539f9b61b60fc8a3bb83e5bb","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testGenericCollectionTypes() throws Exception\n    {\n        DataTypeFactory factory = new DataTypeFactory();\n        DataType dt = factory.create(List.class, Exception.class);\n        DataType dt2 = factory.create(List.class, Exception.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertEquals(dt, dt2);\n\n        dt2 = factory.create(ArrayList.class, IOException.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        //Check mime type matching\n        dt2 = factory.create(ArrayList.class, IOException.class, \"application/list+java\");\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        dt.setMimeType(\"*/*\");\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        //Test Generic Item types don't match\n        dt = factory.create(List.class, Exception.class);\n        dt2 = factory.create(List.class, String.class);\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n    }","id":83450,"modified_method":"public void testGenericCollectionTypes() throws Exception\n    {\n        DataTypeFactory factory = new DataTypeFactory();\n        DataType dt = factory.create(List.class, Exception.class);\n        DataType dt2 = factory.create(List.class, Exception.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertEquals(dt, dt2);\n\n        dt2 = factory.create(ArrayList.class, IOException.class);\n\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        //Check mime type matching\n        dt2 = factory.create(ArrayList.class, IOException.class, \"application/list+java\");\n\n        //Will match because the default mime type is '*/*'\n        assertTrue(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        dt.setMimeType(MimeTypes.BINARY);\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n\n        //Test Generic Item types don't match\n        dt = factory.create(List.class, Exception.class);\n        dt2 = factory.create(List.class, String.class);\n\n        assertFalse(dt.isCompatibleWith(dt2));\n        assertFalse(dt.equals(dt2));\n    }","commit_id":"c44f63e08db4b819539f9b61b60fc8a3bb83e5bb","url":"https://github.com/mulesoft/mule"},{"original_method":"public SimpleDataType(Class type, String mimeType)\n    {\n        this.type = type;\n        this.mimeType = mimeType;\n    }","id":83451,"modified_method":"public SimpleDataType(Class type, String mimeType)\n    {\n        this.type = type;\n        this.mimeType = (mimeType==null?ANY_MIME_TYPE:mimeType);\n    }","commit_id":"c44f63e08db4b819539f9b61b60fc8a3bb83e5bb","url":"https://github.com/mulesoft/mule"},{"original_method":"public void setMimeType(String mimeType)\n    {\n        this.mimeType = mimeType;\n    }","id":83452,"modified_method":"public void setMimeType(String mimeType)\n    {\n        this.mimeType = (mimeType==null?ANY_MIME_TYPE:mimeType);\n    }","commit_id":"c44f63e08db4b819539f9b61b60fc8a3bb83e5bb","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public void visitConditionalExpression(@NotNull PsiConditionalExpression expression) {\n      neverNull = expressionIsNeverNull(expression.getThenExpression()) &&\n                  expressionIsNeverNull(expression.getElseExpression());\n    }","id":83453,"modified_method":"@Override\n    public void visitConditionalExpression(@NotNull PsiConditionalExpression expression) {\n      final PsiExpression condition = expression.getCondition();\n      final PsiExpression thenExpression = expression.getThenExpression();\n      final PsiExpression elseExpression = expression.getElseExpression();\n      if (canTrunkImpossibleBrunch(condition, elseExpression)) {\n        neverNull = expressionIsNeverNull(thenExpression);\n        return;\n      }\n\n      neverNull = expressionIsNeverNull(thenExpression) ||\n                  expressionIsNeverNull(elseExpression);\n    }","commit_id":"76c393a14521c0a56a26c7aa6241f6a7132f6529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitConditionalExpression(@NotNull PsiConditionalExpression expression) {\n      sometimesNull = expressionIsSometimesNull(expression.getThenExpression()) ||\n                      expressionIsSometimesNull(expression.getElseExpression());\n    }","id":83454,"modified_method":"@Override\n    public void visitConditionalExpression(@NotNull PsiConditionalExpression expression) {\n      final PsiExpression condition = expression.getCondition();\n      final PsiExpression thenExpression = expression.getThenExpression();\n      final PsiExpression elseExpression = expression.getElseExpression();\n      if (canTrunkImpossibleBrunch(condition, elseExpression)) {\n        sometimesNull = expressionIsSometimesNull(thenExpression);\n        return;\n      }\n\n      sometimesNull = expressionIsSometimesNull(thenExpression) ||\n                      expressionIsSometimesNull(elseExpression);\n    }","commit_id":"76c393a14521c0a56a26c7aa6241f6a7132f6529","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkReferences(PsiExpression expression,\n                                 PsiElement context) {\n      if (!(expression instanceof PsiReferenceExpression)) {\n        return;\n      }\n      final PsiReferenceExpression referenceExpression =\n        (PsiReferenceExpression)expression;\n      final PsiElement target = referenceExpression.resolve();\n      if (!(target instanceof PsiVariable)) {\n        return;\n      }\n      final PsiVariable variable = (PsiVariable)target;\n      if (VariableAccessUtils.variableIsUsed(variable, context)) {\n        return;\n      }\n      registerError(referenceExpression);\n    }","id":83455,"modified_method":"private void checkVariableUsage(PsiReferenceExpression referenceExpression,\n                                    PsiElement thenContext, PsiElement elseContext) {\n      if (thenContext == null || elseContext == null) {\n        return;\n      }\n      final PsiElement target = referenceExpression.resolve();\n      if (!(target instanceof PsiVariable)) {\n        return;\n      }\n      final PsiVariable variable = (PsiVariable)target;\n      if (contextExits(thenContext) || VariableAccessUtils.variableIsAssigned(variable, thenContext)) {\n        return;\n      }\n      if (contextExits(elseContext) || VariableAccessUtils.variableIsUsed(variable, elseContext)) {\n        return;\n      }\n      registerError(referenceExpression);\n    }","commit_id":"f48576a9ef14cee5ae8a5bccf587f5c79a76cb14","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitIfStatement(PsiIfStatement statement) {\n      super.visitIfStatement(statement);\n      final PsiExpression condition = statement.getCondition();\n      if (!(condition instanceof PsiBinaryExpression)) {\n        return;\n      }\n      final PsiBinaryExpression binaryExpression =\n        (PsiBinaryExpression)condition;\n      final PsiExpression rhs = binaryExpression.getROperand();\n      if (rhs == null) {\n        return;\n      }\n      final PsiExpression lhs = binaryExpression.getLOperand();\n      final IElementType tokenType =\n        binaryExpression.getOperationTokenType();\n      if (tokenType == JavaTokenType.EQEQ) {\n        final PsiStatement thenBranch = statement.getThenBranch();\n        if (contextExits(thenBranch)) {\n          return;\n        }\n        final PsiStatement elseBranch = statement.getElseBranch();\n        if (contextExits(elseBranch)) {\n          return;\n        }\n        checkReferences(rhs, lhs, elseBranch);\n      }\n      else if (tokenType == JavaTokenType.NE) {\n        final PsiStatement thenBranch = statement.getThenBranch();\n        if (contextExits(thenBranch)) {\n          return;\n        }\n        checkReferences(rhs, lhs, thenBranch);\n      }\n    }","id":83456,"modified_method":"@Override\n    public void visitIfStatement(PsiIfStatement statement) {\n      super.visitIfStatement(statement);\n      final PsiExpression condition = statement.getCondition();\n      if (!(condition instanceof PsiBinaryExpression)) {\n        return;\n      }\n      final PsiBinaryExpression binaryExpression = (PsiBinaryExpression)condition;\n      final PsiReferenceExpression referenceExpression = extractVariableReference(binaryExpression);\n      if (referenceExpression == null) {\n        return;\n      }\n      final IElementType tokenType = binaryExpression.getOperationTokenType();\n      if (tokenType == JavaTokenType.EQEQ) {\n        checkVariableUsage(referenceExpression, statement.getThenBranch(), statement.getElseBranch());\n      }\n      else if (tokenType == JavaTokenType.NE) {\n        checkVariableUsage(referenceExpression, statement.getElseBranch(), statement.getThenBranch());\n      }\n    }","commit_id":"f48576a9ef14cee5ae8a5bccf587f5c79a76cb14","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean contextExits(PsiElement context) {\n      if (context instanceof PsiBlockStatement) {\n        final PsiBlockStatement blockStatement =\n          (PsiBlockStatement)context;\n        final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();\n        final PsiStatement[] statements = codeBlock.getStatements();\n        if (statements.length == 0) {\n          return true;\n        }\n        final PsiStatement lastStatement =\n          statements[statements.length - 1];\n        return statementExits(lastStatement);\n      }\n      else {\n        return statementExits(context);\n      }\n    }","id":83457,"modified_method":"private static boolean contextExits(PsiElement context) {\n      if (context instanceof PsiBlockStatement) {\n        final PsiBlockStatement blockStatement = (PsiBlockStatement)context;\n        final PsiCodeBlock codeBlock = blockStatement.getCodeBlock();\n        final PsiStatement[] statements = codeBlock.getStatements();\n        if (statements.length == 0) {\n          return false;\n        }\n        final PsiStatement lastStatement = statements[statements.length - 1];\n        return statementExits(lastStatement);\n      }\n      else {\n        return statementExits(context);\n      }\n    }","commit_id":"f48576a9ef14cee5ae8a5bccf587f5c79a76cb14","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitConditionalExpression(\n      PsiConditionalExpression expression) {\n      super.visitConditionalExpression(expression);\n      final PsiExpression condition = expression.getCondition();\n      if (!(condition instanceof PsiBinaryExpression)) {\n        return;\n      }\n      final PsiBinaryExpression binaryExpression =\n        (PsiBinaryExpression)condition;\n      final PsiExpression rhs = binaryExpression.getROperand();\n      if (rhs == null) {\n        return;\n      }\n      final PsiExpression lhs = binaryExpression.getLOperand();\n      final IElementType tokenType =\n        binaryExpression.getOperationTokenType();\n      if (tokenType == JavaTokenType.EQEQ) {\n        final PsiExpression elseBranch = expression.getElseExpression();\n        checkReferences(rhs, lhs, elseBranch);\n      }\n      else if (tokenType == JavaTokenType.NE) {\n        final PsiExpression thenBranch = expression.getThenExpression();\n        checkReferences(rhs, lhs, thenBranch);\n      }\n    }","id":83458,"modified_method":"@Override\n    public void visitConditionalExpression(PsiConditionalExpression expression) {\n      super.visitConditionalExpression(expression);\n      final PsiExpression condition = expression.getCondition();\n      if (!(condition instanceof PsiBinaryExpression)) {\n        return;\n      }\n      final PsiBinaryExpression binaryExpression = (PsiBinaryExpression)condition;\n      final PsiReferenceExpression referenceExpression = extractVariableReference(binaryExpression);\n      if (referenceExpression == null) {\n        return;\n      }\n      final IElementType tokenType = binaryExpression.getOperationTokenType();\n      if (tokenType == JavaTokenType.EQEQ) {\n        checkVariableUsage(referenceExpression, expression.getThenExpression(), expression.getElseExpression());\n      }\n      else if (tokenType == JavaTokenType.NE) {\n        checkVariableUsage(referenceExpression, expression.getElseExpression(), expression.getThenExpression());\n      }\n    }","commit_id":"f48576a9ef14cee5ae8a5bccf587f5c79a76cb14","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StorageTier(TachyonConf tachyonConf, int tierAlias) {\n    mTierAlias = tierAlias;\n    int level = tierAlias - 1;\n    String tierDirPathConf =\n        String.format(Constants.WORKER_TIERED_STORAGE_LEVEL_DIRS_PATH_FORMAT, level);\n    String[] dirPaths = tachyonConf.get(tierDirPathConf, \"/mnt/ramdisk\").split(\",\");\n\n    String tierDirCapacityConf =\n        String.format(Constants.WORKER_TIERED_STORAGE_LEVEL_DIRS_QUOTA_FORMAT, level);\n    String[] dirQuotas = tachyonConf.get(tierDirCapacityConf, \"0\").split(\",\");\n\n    mDirs = new ArrayList<StorageDir>(dirPaths.length);\n\n    for (int i = 0; i < dirPaths.length; i ++) {\n      int index = i >= dirQuotas.length ? dirQuotas.length - 1 : i;\n      long capacity = CommonUtils.parseSpaceSize(dirQuotas[index]);\n      mDirs.add(new StorageDir(this, i, capacity, dirPaths[i]));\n    }\n  }","id":83459,"modified_method":"public StorageTier(TachyonConf tachyonConf, int tierLevel, int tierAlias) {\n    mTierAlias = tierAlias;\n    mTierLevel = tierLevel;\n    String tierDirPathConf =\n        String.format(Constants.WORKER_TIERED_STORAGE_LEVEL_DIRS_PATH_FORMAT, mTierLevel);\n    String[] dirPaths = tachyonConf.get(tierDirPathConf, \"/mnt/ramdisk\").split(\",\");\n\n    String tierDirCapacityConf =\n        String.format(Constants.WORKER_TIERED_STORAGE_LEVEL_DIRS_QUOTA_FORMAT, mTierLevel);\n    String[] dirQuotas = tachyonConf.get(tierDirCapacityConf, \"0\").split(\",\");\n\n    mDirs = new ArrayList<StorageDir>(dirPaths.length);\n\n    for (int i = 0; i < dirPaths.length; i ++) {\n      int index = i >= dirQuotas.length ? dirQuotas.length - 1 : i;\n      long capacity = CommonUtils.parseSpaceSize(dirQuotas[index]);\n      mDirs.add(new StorageDir(this, i, capacity, dirPaths[i]));\n    }\n  }","commit_id":"03e3f5c12fa4ce0e14fb5bd1c3af54b9ea4fba53","url":"https://github.com/amplab/tachyon"},{"original_method":"public Optional<BlockMeta> getBlockMeta(long blockId) {\n    for (StorageDir dir : mDirs) {\n      Optional<BlockMeta> optionalBlock = dir.getBlockMeta(blockId);\n      if (optionalBlock.isPresent()) {\n        return optionalBlock;\n      }\n    }\n    return Optional.absent();\n  }","id":83460,"modified_method":"/**\n   * Returns the BlockMeta for a given blockId.\n   *\n   * @param blockId the ID of the block\n   * @return BlockMeta\n   * @throws IOException if no BlockMeta for this blockId is found in this StorageDir\n   */\n  public BlockMeta getBlockMeta(long blockId) throws IOException {\n    for (StorageDir dir : mDirs) {\n      if (dir.hasBlockMeta(blockId)) {\n        return dir.getBlockMeta(blockId);\n      }\n    }\n    throw new IOException(\"Cannot get blockId \" + blockId + \" in tier \" + this);\n  }","commit_id":"03e3f5c12fa4ce0e14fb5bd1c3af54b9ea4fba53","url":"https://github.com/amplab/tachyon"},{"original_method":"protected boolean isAvailableImpl(int offset) {\n    PsiReferenceExpression ref = getMethodCall().getMethodExpression();\n    String name = ref.getReferenceName();\n\n    if (name == null || !ref.getManager().getNameHelper().isIdentifier(name)) return false;\n\n    setText(QuickFixBundle.message(\"create.method.from.usage.text\", name));\n    return true;\n  }","id":83461,"modified_method":"protected boolean isAvailableImpl(int offset) {\n    final PsiMethodCallExpression call = getMethodCall();\n    if (call == null) return false;\n    PsiReferenceExpression ref = call.getMethodExpression();\n    String name = ref.getReferenceName();\n\n    if (name == null || !ref.getManager().getNameHelper().isIdentifier(name)) return false;\n\n    setText(QuickFixBundle.message(\"create.method.from.usage.text\", name));\n    return true;\n  }","commit_id":"9b0d85464d6b392c5e556660f5e920385f68aa5e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected PsiElement getElement() {\n    if (!getMethodCall().isValid() || !getMethodCall().getManager().isInProject(getMethodCall())) return null;\n    return getMethodCall();\n  }","id":83462,"modified_method":"protected PsiElement getElement() {\n    final PsiMethodCallExpression call = getMethodCall();\n    if (call == null || !call.getManager().isInProject(call)) return null;\n    return call;\n  }","commit_id":"9b0d85464d6b392c5e556660f5e920385f68aa5e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void invokeImpl(PsiClass targetClass) {\n    PsiManager psiManager = getMethodCall().getManager();\n    final Project project = psiManager.getProject();\n    PsiReferenceExpression ref = getMethodCall().getMethodExpression();\n\n    if (isValidElement(getMethodCall())) {\n      return;\n    }\n\n    PsiClass parentClass = PsiTreeUtil.getParentOfType(getMethodCall(), PsiClass.class);\n    PsiMember enclosingContext = PsiTreeUtil.getParentOfType(getMethodCall(),\n      PsiMethod.class,\n      PsiField.class,\n      PsiClassInitializer.class);\n\n    if (targetClass == null) {\n      return;\n    }\n\n    final PsiFile targetFile = targetClass.getContainingFile();\n\n    String methodName = ref.getReferenceName();\n\n    try {\n      PsiElementFactory factory = psiManager.getElementFactory();\n\n      PsiMethod method = factory.createMethod(methodName, PsiType.VOID);\n\n      if (targetClass.equals(parentClass)) {\n        method = (PsiMethod) targetClass.addAfter(method, enclosingContext);\n      } else {\n        PsiElement anchor = enclosingContext;\n\n        while (anchor != null && anchor.getParent() != null && !anchor.getParent().equals(targetClass)) {\n          anchor = anchor.getParent();\n        }\n\n        if (anchor != null && anchor.getParent() == null) anchor = null;\n\n        if (anchor != null) {\n          method = (PsiMethod) targetClass.addAfter(method, anchor);\n        } else {\n          method = (PsiMethod) targetClass.add(method);\n        }\n      }\n\n      PsiCodeBlock body = method.getBody();\n      assert body != null;\n      if (targetClass.isInterface()) {\n        body.delete();\n      }\n\n      setupVisibility(parentClass, targetClass, method.getModifierList());\n\n      if (shouldCreateStaticMember(getMethodCall().getMethodExpression(), enclosingContext, targetClass) && !targetClass.isInterface()) {\n        method.getModifierList().setModifierProperty(PsiModifier.STATIC, true);\n      }\n\n      final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n      final Document document = documentManager.getDocument(targetFile);\n\n\n      method = CodeInsightUtil.forcePsiPostprocessAndRestoreElement(method);\n      body = method.getBody();\n      TemplateBuilder builder = new TemplateBuilder(method);\n\n      targetClass = method.getContainingClass();\n      final ExpectedTypeInfo[] expectedTypes = CreateFromUsageUtils.guessExpectedTypes(getMethodCall(), true);\n      final PsiSubstitutor substitutor = getTargetSubstitutor(getMethodCall());\n      final PsiElement context = PsiTreeUtil.getParentOfType(getMethodCall(), PsiClass.class, PsiMethod.class);\n\n      CreateFromUsageUtils.setupMethodParameters(method, builder, getMethodCall().getArgumentList(), substitutor);\n      new GuessTypeParameters(factory).setupTypeElement(method.getReturnTypeElement(), expectedTypes, substitutor, builder, context, targetClass);\n      builder.setEndVariableAfter(targetClass.isInterface() ? method : body.getLBrace());\n      method = CodeInsightUtil.forcePsiPostprocessAndRestoreElement(method);\n\n      RangeMarker rangeMarker = document.createRangeMarker(method.getTextRange());\n      final Editor newEditor = positionCursor(project, targetFile, method);\n      Template template = builder.buildTemplate();\n      newEditor.getCaretModel().moveToOffset(rangeMarker.getStartOffset());\n      newEditor.getDocument().deleteString(rangeMarker.getStartOffset(), rangeMarker.getEndOffset());\n\n      if (!targetClass.isInterface()) {\n        startTemplate(newEditor, template, project, new TemplateEditingAdapter() {\n          public void templateFinished(Template template) {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                PsiDocumentManager.getInstance(project).commitDocument(newEditor.getDocument());\n                final int offset = newEditor.getCaretModel().getOffset();\n                PsiMethod method = PsiTreeUtil.findElementOfClassAtOffset(targetFile, offset - 1, PsiMethod.class, false);\n\n                if (method != null) {\n                  try {\n                    CreateFromUsageUtils.setupMethodBody(method);\n                  } catch (IncorrectOperationException e) {\n                    LOG.error(e);\n                  }\n\n                  CreateFromUsageUtils.setupEditor(method, newEditor);\n                }\n              }\n            });\n          }\n        });\n      } else {\n        startTemplate(newEditor, template, project);\n      }\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":83463,"modified_method":"protected void invokeImpl(PsiClass targetClass) {\n    PsiMethodCallExpression expression = getMethodCall();\n    if (expression == null) return;\n    PsiManager psiManager = expression.getManager();\n    final Project project = psiManager.getProject();\n    PsiReferenceExpression ref = expression.getMethodExpression();\n\n    if (isValidElement(expression)) {\n      return;\n    }\n\n    PsiClass parentClass = PsiTreeUtil.getParentOfType(expression, PsiClass.class);\n    PsiMember enclosingContext = PsiTreeUtil.getParentOfType(expression,\n      PsiMethod.class,\n      PsiField.class,\n      PsiClassInitializer.class);\n\n    if (targetClass == null) {\n      return;\n    }\n\n    final PsiFile targetFile = targetClass.getContainingFile();\n\n    String methodName = ref.getReferenceName();\n\n    try {\n      PsiElementFactory factory = psiManager.getElementFactory();\n\n      PsiMethod method = factory.createMethod(methodName, PsiType.VOID);\n\n      if (targetClass.equals(parentClass)) {\n        method = (PsiMethod) targetClass.addAfter(method, enclosingContext);\n      } else {\n        PsiElement anchor = enclosingContext;\n\n        while (anchor != null && anchor.getParent() != null && !anchor.getParent().equals(targetClass)) {\n          anchor = anchor.getParent();\n        }\n\n        if (anchor != null && anchor.getParent() == null) anchor = null;\n\n        if (anchor != null) {\n          method = (PsiMethod) targetClass.addAfter(method, anchor);\n        } else {\n          method = (PsiMethod) targetClass.add(method);\n        }\n      }\n\n      PsiCodeBlock body = method.getBody();\n      assert body != null;\n      if (targetClass.isInterface()) {\n        body.delete();\n      }\n\n      setupVisibility(parentClass, targetClass, method.getModifierList());\n\n      if (shouldCreateStaticMember(expression.getMethodExpression(), enclosingContext, targetClass) && !targetClass.isInterface()) {\n        method.getModifierList().setModifierProperty(PsiModifier.STATIC, true);\n      }\n\n      final PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);\n      final Document document = documentManager.getDocument(targetFile);\n\n\n      method = CodeInsightUtil.forcePsiPostprocessAndRestoreElement(method);\n      body = method.getBody();\n      TemplateBuilder builder = new TemplateBuilder(method);\n\n      targetClass = method.getContainingClass();\n      final ExpectedTypeInfo[] expectedTypes = CreateFromUsageUtils.guessExpectedTypes(expression, true);\n      final PsiSubstitutor substitutor = getTargetSubstitutor(expression);\n      final PsiElement context = PsiTreeUtil.getParentOfType(expression, PsiClass.class, PsiMethod.class);\n\n      CreateFromUsageUtils.setupMethodParameters(method, builder, expression.getArgumentList(), substitutor);\n      new GuessTypeParameters(factory).setupTypeElement(method.getReturnTypeElement(), expectedTypes, substitutor, builder, context, targetClass);\n      builder.setEndVariableAfter(targetClass.isInterface() ? method : body.getLBrace());\n      method = CodeInsightUtil.forcePsiPostprocessAndRestoreElement(method);\n\n      RangeMarker rangeMarker = document.createRangeMarker(method.getTextRange());\n      final Editor newEditor = positionCursor(project, targetFile, method);\n      Template template = builder.buildTemplate();\n      newEditor.getCaretModel().moveToOffset(rangeMarker.getStartOffset());\n      newEditor.getDocument().deleteString(rangeMarker.getStartOffset(), rangeMarker.getEndOffset());\n\n      if (!targetClass.isInterface()) {\n        startTemplate(newEditor, template, project, new TemplateEditingAdapter() {\n          public void templateFinished(Template template) {\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              public void run() {\n                PsiDocumentManager.getInstance(project).commitDocument(newEditor.getDocument());\n                final int offset = newEditor.getCaretModel().getOffset();\n                PsiMethod method = PsiTreeUtil.findElementOfClassAtOffset(targetFile, offset - 1, PsiMethod.class, false);\n\n                if (method != null) {\n                  try {\n                    CreateFromUsageUtils.setupMethodBody(method);\n                  } catch (IncorrectOperationException e) {\n                    LOG.error(e);\n                  }\n\n                  CreateFromUsageUtils.setupEditor(method, newEditor);\n                }\n              }\n            });\n          }\n        });\n      } else {\n        startTemplate(newEditor, template, project);\n      }\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"0760fc6b2dee81fc1a38bc0d0048ee7c1bbe5402","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiMethodCallExpression getMethodCall() {\n    return (PsiMethodCallExpression)myMethodCall.getElement();\n  }","id":83464,"modified_method":"@Nullable\n  private PsiMethodCallExpression getMethodCall() {\n    return (PsiMethodCallExpression)myMethodCall.getElement();\n  }","commit_id":"0760fc6b2dee81fc1a38bc0d0048ee7c1bbe5402","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HashMap getItemScores(Long publishedId, Long itemId, String which)\n  {\n    try {\n      ArrayList scores = (ArrayList)\n        getTotalScores(publishedId.toString(), which);\n      HashMap map = new HashMap();\n      List list = new ArrayList();\n      Iterator iter = scores.iterator();\n      while (iter.hasNext())\n      {\n        AssessmentGradingData data = (AssessmentGradingData) iter.next();\n        List temp = null;\n        if (itemId.equals(new Long(0)))\n          temp = getHibernateTemplate().find(\"from ItemGradingData a where a.assessmentGrading.assessmentGradingId=? order by agentId ASC, submittedDate DESC\", data.getAssessmentGradingId(), Hibernate.LONG);\n        else\n        {\n          Object[] objects = new Object[2];\n          objects[0] = data.getAssessmentGradingId();\n          objects[1] = itemId;\n          Type[] types = new Type[2];\n          types[0] = Hibernate.LONG;\n          types[1] = Hibernate.LONG;\n          temp = getHibernateTemplate().find(\"from ItemGradingData a where a.assessmentGrading.assessmentGradingId=? and a.publishedItem.itemId=? order by agentId ASC, submittedDate DESC\", objects, types);\n\n          // To avoid lazy loading, load them with the objects that have\n          // the sections filled in already from total scores\n          Iterator tmp = temp.iterator();\n          while (tmp.hasNext())\n          {\n            ItemGradingData idata = (ItemGradingData) tmp.next();\n            idata.setAssessmentGrading(data);\n          }\n        }\n        list.addAll(temp);\n      }\n      iter = list.iterator();\n      while (iter.hasNext())\n      {\n        ItemGradingData data = (ItemGradingData) iter.next();\n        ArrayList thisone = (ArrayList)\n          map.get(data.getPublishedItem().getItemId());\n        if (thisone == null)\n          thisone = new ArrayList();\n        thisone.add(data);\n        map.put(data.getPublishedItem().getItemId(), thisone);\n      }\n      return map;\n    } catch (Exception e) {\n      e.printStackTrace();\n      return new HashMap();\n    }\n  }","id":83465,"modified_method":"public HashMap getItemScores(Long publishedId, final Long itemId, String which)\n  {\n    try {\n      ArrayList scores = (ArrayList)\n        getTotalScores(publishedId.toString(), which);\n      HashMap map = new HashMap();\n      List list = new ArrayList();\n                                             \n      // make final for callback to access\n      final Iterator iter = scores.iterator();\n      \n      HibernateCallback hcb = new HibernateCallback()\n      {\n        public Object doInHibernate(Session session) throws HibernateException,\n          SQLException\n        {\n          Criteria criteria = session.createCriteria(ItemGradingData.class);\n          Disjunction disjunction = Expression.disjunction();\n                                                                                                 \n          /** make list from AssessmentGradingData ids */\n          List gradingIdList = new ArrayList();\n          while (iter.hasNext()){            \n            AssessmentGradingData data = (AssessmentGradingData) iter.next();\n            gradingIdList.add(data.getAssessmentGradingId());                               \n          }\n          \n          /** create or disjunctive expression for (in clauses) */\n          List tempList;\n  \t\t  for (int i = 0; i < gradingIdList.size(); i += 50){\n  \t\t    if (i + 50 > gradingIdList.size()){\n  \t          tempList = gradingIdList.subList(i, gradingIdList.size());\n  \t          disjunction.add(Expression.in(\"assessmentGrading.assessmentGradingId\", tempList));      \n  \t\t    }\n  \t\t    else{\n  \t\t      tempList = gradingIdList.subList(i, i + 50);\n  \t\t      disjunction.add(Expression.in(\"assessmentGrading.assessmentGradingId\", tempList));\n  \t\t    }\n  \t\t  }                                                          \n          \n          Criterion pubCriterion = Expression.eq(\"publishedItem.itemId\", itemId);          \n          \n          /** create logical and between the pubCriterion and the disjunction criterion */\n          criteria.add(Expression.and(pubCriterion, disjunction));\n                       \n          criteria.addOrder(Order.asc(\"agentId\"));\n          criteria.addOrder(Order.desc(\"submittedDate\"));                    \n          return criteria.list();\n        }\n      };\n      List temp = (List) getHibernateTemplate().execute(hcb);\n        \n      Iterator iter2 = temp.iterator();\n      while (iter2.hasNext())\n      {\n        ItemGradingData data = (ItemGradingData) iter2.next();\n        ArrayList thisone = (ArrayList)\n          map.get(data.getPublishedItem().getItemId());\n        if (thisone == null)\n          thisone = new ArrayList();\n        thisone.add(data);\n        map.put(data.getPublishedItem().getItemId(), thisone);\n      }\n      return map;\n    } catch (Exception e) {\n      e.printStackTrace();\n      return new HashMap();\n    }\n  }","commit_id":"ef8d2e7a4ed09729b76c3fac67e5f5bff506c302","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public List<AcademicSession> getAcademicSessions() {\n\t\treturn getHibernateTemplate().findByNamedQuery(\"findAcademicSessions\");\n\t}","id":83466,"modified_method":"public List <AcademicSession> getAcademicSessions() {\n\t    return (List <AcademicSession>) getHibernateTemplate().execute(new HibernateCallback() {\n\t\t@Override\n\t\tpublic List <AcademicSession> doInHibernate(Session session) {\n\t\t    Query query = session.getNamedQuery(\"findAcademicSessions\");\n\t\t    query.setCacheable(true);\n\t\t    return query.list();\n\t\t}\n\t    });\n\n\t}","commit_id":"319b9c817cb96f37c9ccaf256ac44ade431ee49a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public List<AcademicSession> getCurrentAcademicSessions() {\n\t\treturn getHibernateTemplate().findByNamedQuery(\"findCurrentAcademicSessions\");\n\t}","id":83467,"modified_method":"public List <AcademicSession> getCurrentAcademicSessions() {\n\t    return (List <AcademicSession>) getHibernateTemplate().execute(new HibernateCallback() {\n\t\t@Override\n\t\tpublic List <AcademicSession> doInHibernate(Session session) {\n\t\t    Query query = session.getNamedQuery(\"findCurrentAcademicSessions\");\n\t\t    query.setCacheable(true);\n\t\t    return query.list();\n\t\t}\n\t    });\n\t}","commit_id":"319b9c817cb96f37c9ccaf256ac44ade431ee49a","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void checkWithoutTermStatistics(int numDocs, String[] values, int[] freq, int[][] pos, int[][] startOffset, int[][] endOffset,\n            int i) throws IOException {\n        TermVectorsRequestBuilder resp = client().prepareTermVectors(\"test\", \"type1\", Integer.toString(i)).setPayloads(true).setOffsets(true)\n                .setPositions(true).setTermStatistics(false).setFieldStatistics(true).setSelectedFields();\n        assertThat(resp.request().termStatistics(), equalTo(false));\n        TermVectorsResponse response = resp.execute().actionGet();\n        assertThat(\"doc id: \" + i + \" doesn't exists but should\", response.isExists(), equalTo(true));\n        Fields fields = response.getFields();\n        assertThat(fields.size(), equalTo(1));\n        Terms terms = fields.terms(\"field\");\n        assertThat(terms.size(), equalTo(8l));\n        assertThat(terms.getSumTotalTermFreq(), Matchers.equalTo((long) (9 * numDocs)));\n        assertThat(terms.getDocCount(), Matchers.equalTo(numDocs));\n        assertThat(terms.getSumDocFreq(), equalTo((long) numDocs * values.length));\n        TermsEnum iterator = terms.iterator(null);\n        for (int j = 0; j < values.length; j++) {\n            String string = values[j];\n            BytesRef next = iterator.next();\n            assertThat(next, Matchers.notNullValue());\n            assertThat(\"expected \" + string, string, equalTo(next.utf8ToString()));\n            assertThat(next, Matchers.notNullValue());\n\n            assertThat(\"expected ttf of \" + string, -1, equalTo((int) iterator.totalTermFreq()));\n\n            DocsAndPositionsEnum docsAndPositions = iterator.docsAndPositions(null, null);\n            assertThat(docsAndPositions.nextDoc(), equalTo(0));\n            assertThat(freq[j], equalTo(docsAndPositions.freq()));\n            assertThat(iterator.docFreq(), equalTo(-1));\n            int[] termPos = pos[j];\n            int[] termStartOffset = startOffset[j];\n            int[] termEndOffset = endOffset[j];\n            assertThat(termPos.length, equalTo(freq[j]));\n            assertThat(termStartOffset.length, equalTo(freq[j]));\n            assertThat(termEndOffset.length, equalTo(freq[j]));\n            for (int k = 0; k < freq[j]; k++) {\n                int nextPosition = docsAndPositions.nextPosition();\n                assertThat(\"term: \" + string, nextPosition, equalTo(termPos[k]));\n                assertThat(\"term: \" + string, docsAndPositions.startOffset(), equalTo(termStartOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.endOffset(), equalTo(termEndOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.getPayload(), equalTo(new BytesRef(\"word\")));\n            }\n        }\n        assertThat(iterator.next(), Matchers.nullValue());\n\n        XContentBuilder xBuilder = XContentFactory.jsonBuilder();\n        xBuilder.startObject();\n        response.toXContent(xBuilder, null);\n        xBuilder.endObject();\n        BytesStream bytesStream = xBuilder.bytesStream();\n        String utf8 = bytesStream.bytes().toUtf8();\n        String expectedString = \"{\\\"_index\\\":\\\"test\\\",\\\"_type\\\":\\\"type1\\\",\\\"_id\\\":\\\"\"\n                + i\n                + \"\\\",\\\"_version\\\":1,\\\"found\\\":true,\\\"term_vectors\\\":{\\\"field\\\":{\\\"field_statistics\\\":{\\\"sum_doc_freq\\\":120,\\\"doc_count\\\":15,\\\"sum_ttf\\\":135},\\\"terms\\\":{\\\"brown\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":2,\\\"start_offset\\\":10,\\\"end_offset\\\":15,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"dog\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":8,\\\"start_offset\\\":40,\\\"end_offset\\\":43,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"fox\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":3,\\\"start_offset\\\":16,\\\"end_offset\\\":19,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"jumps\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":4,\\\"start_offset\\\":20,\\\"end_offset\\\":25,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"lazy\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":7,\\\"start_offset\\\":35,\\\"end_offset\\\":39,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"over\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":5,\\\"start_offset\\\":26,\\\"end_offset\\\":30,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"quick\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":1,\\\"start_offset\\\":4,\\\"end_offset\\\":9,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"the\\\":{\\\"term_freq\\\":2,\\\"tokens\\\":[{\\\"position\\\":0,\\\"start_offset\\\":0,\\\"end_offset\\\":3,\\\"payload\\\":\\\"d29yZA==\\\"},{\\\"position\\\":6,\\\"start_offset\\\":31,\\\"end_offset\\\":34,\\\"payload\\\":\\\"d29yZA==\\\"}]}}}}}\";\n        assertThat(utf8, equalTo(expectedString));\n\n    }","id":83468,"modified_method":"private void checkWithoutTermStatistics(int numDocs, String[] values, int[] freq, int[][] pos, int[][] startOffset, int[][] endOffset,\n            int i) throws IOException {\n        TermVectorsRequestBuilder resp = client().prepareTermVectors(\"test\", \"type1\", Integer.toString(i)).setPayloads(true).setOffsets(true)\n                .setPositions(true).setTermStatistics(false).setFieldStatistics(true).setSelectedFields();\n        assertThat(resp.request().termStatistics(), equalTo(false));\n        TermVectorsResponse response = resp.execute().actionGet();\n        assertThat(\"doc id: \" + i + \" doesn't exists but should\", response.isExists(), equalTo(true));\n        Fields fields = response.getFields();\n        assertThat(fields.size(), equalTo(1));\n        Terms terms = fields.terms(\"field\");\n        assertThat(terms.size(), equalTo(8l));\n        assertThat(terms.getSumTotalTermFreq(), Matchers.equalTo((long) (9 * numDocs)));\n        assertThat(terms.getDocCount(), Matchers.equalTo(numDocs));\n        assertThat(terms.getSumDocFreq(), equalTo((long) numDocs * values.length));\n        TermsEnum iterator = terms.iterator(null);\n        for (int j = 0; j < values.length; j++) {\n            String string = values[j];\n            BytesRef next = iterator.next();\n            assertThat(next, Matchers.notNullValue());\n            assertThat(\"expected \" + string, string, equalTo(next.utf8ToString()));\n            assertThat(next, Matchers.notNullValue());\n\n            assertThat(\"expected ttf of \" + string, -1, equalTo((int) iterator.totalTermFreq()));\n\n            DocsAndPositionsEnum docsAndPositions = iterator.docsAndPositions(null, null);\n            assertThat(docsAndPositions.nextDoc(), equalTo(0));\n            assertThat(freq[j], equalTo(docsAndPositions.freq()));\n            assertThat(iterator.docFreq(), equalTo(-1));\n            int[] termPos = pos[j];\n            int[] termStartOffset = startOffset[j];\n            int[] termEndOffset = endOffset[j];\n            assertThat(termPos.length, equalTo(freq[j]));\n            assertThat(termStartOffset.length, equalTo(freq[j]));\n            assertThat(termEndOffset.length, equalTo(freq[j]));\n            for (int k = 0; k < freq[j]; k++) {\n                int nextPosition = docsAndPositions.nextPosition();\n                assertThat(\"term: \" + string, nextPosition, equalTo(termPos[k]));\n                assertThat(\"term: \" + string, docsAndPositions.startOffset(), equalTo(termStartOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.endOffset(), equalTo(termEndOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.getPayload(), equalTo(new BytesRef(\"word\")));\n            }\n        }\n        assertThat(iterator.next(), Matchers.nullValue());\n\n        XContentBuilder xBuilder = XContentFactory.jsonBuilder();\n        xBuilder.startObject();\n        response.toXContent(xBuilder, null);\n        xBuilder.endObject();\n        BytesStream bytesStream = xBuilder.bytesStream();\n        String utf8 = bytesStream.bytes().toUtf8().replaceFirst(\"\\\"took\\\":\\\\d+,\", \"\");;\n        String expectedString = \"{\\\"_index\\\":\\\"test\\\",\\\"_type\\\":\\\"type1\\\",\\\"_id\\\":\\\"\"\n                + i\n                + \"\\\",\\\"_version\\\":1,\\\"found\\\":true,\\\"term_vectors\\\":{\\\"field\\\":{\\\"field_statistics\\\":{\\\"sum_doc_freq\\\":120,\\\"doc_count\\\":15,\\\"sum_ttf\\\":135},\\\"terms\\\":{\\\"brown\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":2,\\\"start_offset\\\":10,\\\"end_offset\\\":15,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"dog\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":8,\\\"start_offset\\\":40,\\\"end_offset\\\":43,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"fox\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":3,\\\"start_offset\\\":16,\\\"end_offset\\\":19,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"jumps\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":4,\\\"start_offset\\\":20,\\\"end_offset\\\":25,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"lazy\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":7,\\\"start_offset\\\":35,\\\"end_offset\\\":39,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"over\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":5,\\\"start_offset\\\":26,\\\"end_offset\\\":30,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"quick\\\":{\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":1,\\\"start_offset\\\":4,\\\"end_offset\\\":9,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"the\\\":{\\\"term_freq\\\":2,\\\"tokens\\\":[{\\\"position\\\":0,\\\"start_offset\\\":0,\\\"end_offset\\\":3,\\\"payload\\\":\\\"d29yZA==\\\"},{\\\"position\\\":6,\\\"start_offset\\\":31,\\\"end_offset\\\":34,\\\"payload\\\":\\\"d29yZA==\\\"}]}}}}}\";\n        assertThat(utf8, equalTo(expectedString));\n\n    }","commit_id":"455a85dc3b9a3adf3f9562405fe6778a0701565b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void checkAllInfo(int numDocs, String[] values, int[] freq, int[][] pos, int[][] startOffset, int[][] endOffset, int i)\n            throws IOException {\n        TermVectorsRequestBuilder resp = client().prepareTermVectors(\"test\", \"type1\", Integer.toString(i)).setPayloads(true).setOffsets(true)\n                .setPositions(true).setFieldStatistics(true).setTermStatistics(true).setSelectedFields();\n        assertThat(resp.request().fieldStatistics(), equalTo(true));\n        TermVectorsResponse response = resp.execute().actionGet();\n        assertThat(\"doc id: \" + i + \" doesn't exists but should\", response.isExists(), equalTo(true));\n        Fields fields = response.getFields();\n        assertThat(fields.size(), equalTo(1));\n        Terms terms = fields.terms(\"field\");\n        assertThat(terms.size(), equalTo(8l));\n        assertThat(terms.getSumTotalTermFreq(), Matchers.equalTo((long) (9 * numDocs)));\n        assertThat(terms.getDocCount(), Matchers.equalTo(numDocs));\n        assertThat(terms.getSumDocFreq(), equalTo((long) numDocs * values.length));\n        TermsEnum iterator = terms.iterator(null);\n        for (int j = 0; j < values.length; j++) {\n            String string = values[j];\n            BytesRef next = iterator.next();\n            assertThat(next, Matchers.notNullValue());\n            assertThat(\"expected \" + string, string, equalTo(next.utf8ToString()));\n            assertThat(next, Matchers.notNullValue());\n            if (string.equals(\"the\")) {\n                assertThat(\"expected ttf of \" + string, numDocs * 2, equalTo((int) iterator.totalTermFreq()));\n            } else {\n                assertThat(\"expected ttf of \" + string, numDocs, equalTo((int) iterator.totalTermFreq()));\n            }\n\n            DocsAndPositionsEnum docsAndPositions = iterator.docsAndPositions(null, null);\n            assertThat(docsAndPositions.nextDoc(), equalTo(0));\n            assertThat(freq[j], equalTo(docsAndPositions.freq()));\n            assertThat(iterator.docFreq(), equalTo(numDocs));\n            int[] termPos = pos[j];\n            int[] termStartOffset = startOffset[j];\n            int[] termEndOffset = endOffset[j];\n            assertThat(termPos.length, equalTo(freq[j]));\n            assertThat(termStartOffset.length, equalTo(freq[j]));\n            assertThat(termEndOffset.length, equalTo(freq[j]));\n            for (int k = 0; k < freq[j]; k++) {\n                int nextPosition = docsAndPositions.nextPosition();\n                assertThat(\"term: \" + string, nextPosition, equalTo(termPos[k]));\n                assertThat(\"term: \" + string, docsAndPositions.startOffset(), equalTo(termStartOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.endOffset(), equalTo(termEndOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.getPayload(), equalTo(new BytesRef(\"word\")));\n            }\n        }\n        assertThat(iterator.next(), Matchers.nullValue());\n\n        XContentBuilder xBuilder = XContentFactory.jsonBuilder();\n        xBuilder.startObject();\n        response.toXContent(xBuilder, ToXContent.EMPTY_PARAMS);\n        xBuilder.endObject();\n        BytesStream bytesStream = xBuilder.bytesStream();\n        String utf8 = bytesStream.bytes().toUtf8();\n        String expectedString = \"{\\\"_index\\\":\\\"test\\\",\\\"_type\\\":\\\"type1\\\",\\\"_id\\\":\\\"\"\n                + i\n                + \"\\\",\\\"_version\\\":1,\\\"found\\\":true,\\\"term_vectors\\\":{\\\"field\\\":{\\\"field_statistics\\\":{\\\"sum_doc_freq\\\":120,\\\"doc_count\\\":15,\\\"sum_ttf\\\":135},\\\"terms\\\":{\\\"brown\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":2,\\\"start_offset\\\":10,\\\"end_offset\\\":15,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"dog\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":8,\\\"start_offset\\\":40,\\\"end_offset\\\":43,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"fox\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":3,\\\"start_offset\\\":16,\\\"end_offset\\\":19,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"jumps\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":4,\\\"start_offset\\\":20,\\\"end_offset\\\":25,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"lazy\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":7,\\\"start_offset\\\":35,\\\"end_offset\\\":39,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"over\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":5,\\\"start_offset\\\":26,\\\"end_offset\\\":30,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"quick\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":1,\\\"start_offset\\\":4,\\\"end_offset\\\":9,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"the\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":30,\\\"term_freq\\\":2,\\\"tokens\\\":[{\\\"position\\\":0,\\\"start_offset\\\":0,\\\"end_offset\\\":3,\\\"payload\\\":\\\"d29yZA==\\\"},{\\\"position\\\":6,\\\"start_offset\\\":31,\\\"end_offset\\\":34,\\\"payload\\\":\\\"d29yZA==\\\"}]}}}}}\";\n        assertThat(utf8, equalTo(expectedString));\n    }","id":83469,"modified_method":"private void checkAllInfo(int numDocs, String[] values, int[] freq, int[][] pos, int[][] startOffset, int[][] endOffset, int i)\n            throws IOException {\n        TermVectorsRequestBuilder resp = client().prepareTermVectors(\"test\", \"type1\", Integer.toString(i)).setPayloads(true).setOffsets(true)\n                .setPositions(true).setFieldStatistics(true).setTermStatistics(true).setSelectedFields();\n        assertThat(resp.request().fieldStatistics(), equalTo(true));\n        TermVectorsResponse response = resp.execute().actionGet();\n        assertThat(\"doc id: \" + i + \" doesn't exists but should\", response.isExists(), equalTo(true));\n        Fields fields = response.getFields();\n        assertThat(fields.size(), equalTo(1));\n        Terms terms = fields.terms(\"field\");\n        assertThat(terms.size(), equalTo(8l));\n        assertThat(terms.getSumTotalTermFreq(), Matchers.equalTo((long) (9 * numDocs)));\n        assertThat(terms.getDocCount(), Matchers.equalTo(numDocs));\n        assertThat(terms.getSumDocFreq(), equalTo((long) numDocs * values.length));\n        TermsEnum iterator = terms.iterator(null);\n        for (int j = 0; j < values.length; j++) {\n            String string = values[j];\n            BytesRef next = iterator.next();\n            assertThat(next, Matchers.notNullValue());\n            assertThat(\"expected \" + string, string, equalTo(next.utf8ToString()));\n            assertThat(next, Matchers.notNullValue());\n            if (string.equals(\"the\")) {\n                assertThat(\"expected ttf of \" + string, numDocs * 2, equalTo((int) iterator.totalTermFreq()));\n            } else {\n                assertThat(\"expected ttf of \" + string, numDocs, equalTo((int) iterator.totalTermFreq()));\n            }\n\n            DocsAndPositionsEnum docsAndPositions = iterator.docsAndPositions(null, null);\n            assertThat(docsAndPositions.nextDoc(), equalTo(0));\n            assertThat(freq[j], equalTo(docsAndPositions.freq()));\n            assertThat(iterator.docFreq(), equalTo(numDocs));\n            int[] termPos = pos[j];\n            int[] termStartOffset = startOffset[j];\n            int[] termEndOffset = endOffset[j];\n            assertThat(termPos.length, equalTo(freq[j]));\n            assertThat(termStartOffset.length, equalTo(freq[j]));\n            assertThat(termEndOffset.length, equalTo(freq[j]));\n            for (int k = 0; k < freq[j]; k++) {\n                int nextPosition = docsAndPositions.nextPosition();\n                assertThat(\"term: \" + string, nextPosition, equalTo(termPos[k]));\n                assertThat(\"term: \" + string, docsAndPositions.startOffset(), equalTo(termStartOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.endOffset(), equalTo(termEndOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.getPayload(), equalTo(new BytesRef(\"word\")));\n            }\n        }\n        assertThat(iterator.next(), Matchers.nullValue());\n\n        XContentBuilder xBuilder = XContentFactory.jsonBuilder();\n        xBuilder.startObject();\n        response.toXContent(xBuilder, ToXContent.EMPTY_PARAMS);\n        xBuilder.endObject();\n        BytesStream bytesStream = xBuilder.bytesStream();\n        String utf8 = bytesStream.bytes().toUtf8().replaceFirst(\"\\\"took\\\":\\\\d+,\", \"\");;\n        String expectedString = \"{\\\"_index\\\":\\\"test\\\",\\\"_type\\\":\\\"type1\\\",\\\"_id\\\":\\\"\"\n                + i\n                + \"\\\",\\\"_version\\\":1,\\\"found\\\":true,\\\"term_vectors\\\":{\\\"field\\\":{\\\"field_statistics\\\":{\\\"sum_doc_freq\\\":120,\\\"doc_count\\\":15,\\\"sum_ttf\\\":135},\\\"terms\\\":{\\\"brown\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":2,\\\"start_offset\\\":10,\\\"end_offset\\\":15,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"dog\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":8,\\\"start_offset\\\":40,\\\"end_offset\\\":43,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"fox\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":3,\\\"start_offset\\\":16,\\\"end_offset\\\":19,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"jumps\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":4,\\\"start_offset\\\":20,\\\"end_offset\\\":25,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"lazy\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":7,\\\"start_offset\\\":35,\\\"end_offset\\\":39,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"over\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":5,\\\"start_offset\\\":26,\\\"end_offset\\\":30,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"quick\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":1,\\\"start_offset\\\":4,\\\"end_offset\\\":9,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"the\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":30,\\\"term_freq\\\":2,\\\"tokens\\\":[{\\\"position\\\":0,\\\"start_offset\\\":0,\\\"end_offset\\\":3,\\\"payload\\\":\\\"d29yZA==\\\"},{\\\"position\\\":6,\\\"start_offset\\\":31,\\\"end_offset\\\":34,\\\"payload\\\":\\\"d29yZA==\\\"}]}}}}}\";\n        assertThat(utf8, equalTo(expectedString));\n    }","commit_id":"455a85dc3b9a3adf3f9562405fe6778a0701565b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void checkWithoutFieldStatistics(int numDocs, String[] values, int[] freq, int[][] pos, int[][] startOffset, int[][] endOffset,\n            int i) throws IOException {\n        TermVectorsRequestBuilder resp = client().prepareTermVectors(\"test\", \"type1\", Integer.toString(i)).setPayloads(true).setOffsets(true)\n                .setPositions(true).setTermStatistics(true).setFieldStatistics(false).setSelectedFields();\n        TermVectorsResponse response = resp.execute().actionGet();\n        assertThat(\"doc id: \" + i + \" doesn't exists but should\", response.isExists(), equalTo(true));\n        Fields fields = response.getFields();\n        assertThat(fields.size(), equalTo(1));\n        Terms terms = fields.terms(\"field\");\n        assertThat(terms.size(), equalTo(8l));\n        assertThat(terms.getSumTotalTermFreq(), Matchers.equalTo((long) -1));\n        assertThat(terms.getDocCount(), Matchers.equalTo(-1));\n        assertThat(terms.getSumDocFreq(), equalTo((long) -1));\n        TermsEnum iterator = terms.iterator(null);\n        for (int j = 0; j < values.length; j++) {\n            String string = values[j];\n            BytesRef next = iterator.next();\n            assertThat(next, Matchers.notNullValue());\n            assertThat(\"expected \" + string, string, equalTo(next.utf8ToString()));\n            assertThat(next, Matchers.notNullValue());\n            if (string.equals(\"the\")) {\n                assertThat(\"expected ttf of \" + string, numDocs * 2, equalTo((int) iterator.totalTermFreq()));\n            } else {\n                assertThat(\"expected ttf of \" + string, numDocs, equalTo((int) iterator.totalTermFreq()));\n            }\n\n            DocsAndPositionsEnum docsAndPositions = iterator.docsAndPositions(null, null);\n            assertThat(docsAndPositions.nextDoc(), equalTo(0));\n            assertThat(freq[j], equalTo(docsAndPositions.freq()));\n            assertThat(iterator.docFreq(), equalTo(numDocs));\n            int[] termPos = pos[j];\n            int[] termStartOffset = startOffset[j];\n            int[] termEndOffset = endOffset[j];\n            assertThat(termPos.length, equalTo(freq[j]));\n            assertThat(termStartOffset.length, equalTo(freq[j]));\n            assertThat(termEndOffset.length, equalTo(freq[j]));\n            for (int k = 0; k < freq[j]; k++) {\n                int nextPosition = docsAndPositions.nextPosition();\n                assertThat(\"term: \" + string, nextPosition, equalTo(termPos[k]));\n                assertThat(\"term: \" + string, docsAndPositions.startOffset(), equalTo(termStartOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.endOffset(), equalTo(termEndOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.getPayload(), equalTo(new BytesRef(\"word\")));\n            }\n        }\n        assertThat(iterator.next(), Matchers.nullValue());\n\n        XContentBuilder xBuilder = XContentFactory.jsonBuilder();\n        xBuilder.startObject();\n        response.toXContent(xBuilder, null);\n        xBuilder.endObject();\n        BytesStream bytesStream = xBuilder.bytesStream();\n        String utf8 = bytesStream.bytes().toUtf8();\n        String expectedString = \"{\\\"_index\\\":\\\"test\\\",\\\"_type\\\":\\\"type1\\\",\\\"_id\\\":\\\"\"\n                + i\n                + \"\\\",\\\"_version\\\":1,\\\"found\\\":true,\\\"term_vectors\\\":{\\\"field\\\":{\\\"terms\\\":{\\\"brown\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":2,\\\"start_offset\\\":10,\\\"end_offset\\\":15,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"dog\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":8,\\\"start_offset\\\":40,\\\"end_offset\\\":43,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"fox\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":3,\\\"start_offset\\\":16,\\\"end_offset\\\":19,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"jumps\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":4,\\\"start_offset\\\":20,\\\"end_offset\\\":25,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"lazy\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":7,\\\"start_offset\\\":35,\\\"end_offset\\\":39,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"over\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":5,\\\"start_offset\\\":26,\\\"end_offset\\\":30,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"quick\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":1,\\\"start_offset\\\":4,\\\"end_offset\\\":9,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"the\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":30,\\\"term_freq\\\":2,\\\"tokens\\\":[{\\\"position\\\":0,\\\"start_offset\\\":0,\\\"end_offset\\\":3,\\\"payload\\\":\\\"d29yZA==\\\"},{\\\"position\\\":6,\\\"start_offset\\\":31,\\\"end_offset\\\":34,\\\"payload\\\":\\\"d29yZA==\\\"}]}}}}}\";\n        assertThat(utf8, equalTo(expectedString));\n\n    }","id":83470,"modified_method":"private void checkWithoutFieldStatistics(int numDocs, String[] values, int[] freq, int[][] pos, int[][] startOffset, int[][] endOffset,\n            int i) throws IOException {\n        TermVectorsRequestBuilder resp = client().prepareTermVectors(\"test\", \"type1\", Integer.toString(i)).setPayloads(true).setOffsets(true)\n                .setPositions(true).setTermStatistics(true).setFieldStatistics(false).setSelectedFields();\n        TermVectorsResponse response = resp.execute().actionGet();\n        assertThat(\"doc id: \" + i + \" doesn't exists but should\", response.isExists(), equalTo(true));\n        Fields fields = response.getFields();\n        assertThat(fields.size(), equalTo(1));\n        Terms terms = fields.terms(\"field\");\n        assertThat(terms.size(), equalTo(8l));\n        assertThat(terms.getSumTotalTermFreq(), Matchers.equalTo((long) -1));\n        assertThat(terms.getDocCount(), Matchers.equalTo(-1));\n        assertThat(terms.getSumDocFreq(), equalTo((long) -1));\n        TermsEnum iterator = terms.iterator(null);\n        for (int j = 0; j < values.length; j++) {\n            String string = values[j];\n            BytesRef next = iterator.next();\n            assertThat(next, Matchers.notNullValue());\n            assertThat(\"expected \" + string, string, equalTo(next.utf8ToString()));\n            assertThat(next, Matchers.notNullValue());\n            if (string.equals(\"the\")) {\n                assertThat(\"expected ttf of \" + string, numDocs * 2, equalTo((int) iterator.totalTermFreq()));\n            } else {\n                assertThat(\"expected ttf of \" + string, numDocs, equalTo((int) iterator.totalTermFreq()));\n            }\n\n            DocsAndPositionsEnum docsAndPositions = iterator.docsAndPositions(null, null);\n            assertThat(docsAndPositions.nextDoc(), equalTo(0));\n            assertThat(freq[j], equalTo(docsAndPositions.freq()));\n            assertThat(iterator.docFreq(), equalTo(numDocs));\n            int[] termPos = pos[j];\n            int[] termStartOffset = startOffset[j];\n            int[] termEndOffset = endOffset[j];\n            assertThat(termPos.length, equalTo(freq[j]));\n            assertThat(termStartOffset.length, equalTo(freq[j]));\n            assertThat(termEndOffset.length, equalTo(freq[j]));\n            for (int k = 0; k < freq[j]; k++) {\n                int nextPosition = docsAndPositions.nextPosition();\n                assertThat(\"term: \" + string, nextPosition, equalTo(termPos[k]));\n                assertThat(\"term: \" + string, docsAndPositions.startOffset(), equalTo(termStartOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.endOffset(), equalTo(termEndOffset[k]));\n                assertThat(\"term: \" + string, docsAndPositions.getPayload(), equalTo(new BytesRef(\"word\")));\n            }\n        }\n        assertThat(iterator.next(), Matchers.nullValue());\n\n        XContentBuilder xBuilder = XContentFactory.jsonBuilder();\n        xBuilder.startObject();\n        response.toXContent(xBuilder, null);\n        xBuilder.endObject();\n        BytesStream bytesStream = xBuilder.bytesStream();\n        String utf8 = bytesStream.bytes().toUtf8().replaceFirst(\"\\\"took\\\":\\\\d+,\", \"\");;\n        String expectedString = \"{\\\"_index\\\":\\\"test\\\",\\\"_type\\\":\\\"type1\\\",\\\"_id\\\":\\\"\"\n                + i\n                + \"\\\",\\\"_version\\\":1,\\\"found\\\":true,\\\"term_vectors\\\":{\\\"field\\\":{\\\"terms\\\":{\\\"brown\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":2,\\\"start_offset\\\":10,\\\"end_offset\\\":15,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"dog\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":8,\\\"start_offset\\\":40,\\\"end_offset\\\":43,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"fox\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":3,\\\"start_offset\\\":16,\\\"end_offset\\\":19,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"jumps\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":4,\\\"start_offset\\\":20,\\\"end_offset\\\":25,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"lazy\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":7,\\\"start_offset\\\":35,\\\"end_offset\\\":39,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"over\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":5,\\\"start_offset\\\":26,\\\"end_offset\\\":30,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"quick\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":15,\\\"term_freq\\\":1,\\\"tokens\\\":[{\\\"position\\\":1,\\\"start_offset\\\":4,\\\"end_offset\\\":9,\\\"payload\\\":\\\"d29yZA==\\\"}]},\\\"the\\\":{\\\"doc_freq\\\":15,\\\"ttf\\\":30,\\\"term_freq\\\":2,\\\"tokens\\\":[{\\\"position\\\":0,\\\"start_offset\\\":0,\\\"end_offset\\\":3,\\\"payload\\\":\\\"d29yZA==\\\"},{\\\"position\\\":6,\\\"start_offset\\\":31,\\\"end_offset\\\":34,\\\"payload\\\":\\\"d29yZA==\\\"}]}}}}}\";\n        assertThat(utf8, equalTo(expectedString));\n\n    }","commit_id":"455a85dc3b9a3adf3f9562405fe6778a0701565b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Constructs a new term vector request for a document that will be fetch\n     * from the provided index. Use {@link #type(String)} and\n     * {@link #id(String)} to specify the document to load.\n     */\n    public TermVectorsRequest(TermVectorsRequest other) {\n        super(other.index());\n        this.id = other.id();\n        this.type = other.type();\n        this.flagsEnum = other.getFlags().clone();\n        this.preference = other.preference();\n        this.routing = other.routing();\n        if (other.selectedFields != null) {\n            this.selectedFields = new HashSet<>(other.selectedFields);\n        }\n        this.realtime = other.realtime();\n    }","id":83471,"modified_method":"/**\n     * Constructs a new term vector request for a document that will be fetch\n     * from the provided index. Use {@link #type(String)} and\n     * {@link #id(String)} to specify the document to load.\n     */\n    public TermVectorsRequest(TermVectorsRequest other) {\n        super(other.index());\n        this.id = other.id();\n        this.type = other.type();\n        if (this.doc != null) {\n            this.doc = other.doc().copyBytesArray();\n        }\n        this.flagsEnum = other.getFlags().clone();\n        this.preference = other.preference();\n        this.routing = other.routing();\n        if (other.selectedFields != null) {\n            this.selectedFields = new HashSet<>(other.selectedFields);\n        }\n        if (other.perFieldAnalyzer != null) {\n            this.perFieldAnalyzer = new HashMap<>(other.perFieldAnalyzer);\n        }\n        this.realtime = other.realtime();\n        this.version = other.version();\n        this.versionType = VersionType.fromValue(other.versionType().getValue());\n        this.startTime = other.startTime();\n    }","commit_id":"455a85dc3b9a3adf3f9562405fe6778a0701565b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeString(index);\n        out.writeString(type);\n        out.writeString(id);\n        out.writeVLong(docVersion);\n        final boolean docExists = isExists();\n        out.writeBoolean(docExists);\n        out.writeBoolean(hasTermVectors());\n        if (hasTermVectors()) {\n            out.writeBytesReference(headerRef);\n            out.writeBytesReference(termVectors);\n        }\n    }","id":83472,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        out.writeString(index);\n        out.writeString(type);\n        out.writeString(id);\n        out.writeVLong(docVersion);\n        final boolean docExists = isExists();\n        out.writeBoolean(docExists);\n        out.writeBoolean(artificial);\n        out.writeVLong(tookInMillis);\n        out.writeBoolean(hasTermVectors());\n        if (hasTermVectors()) {\n            out.writeBytesReference(headerRef);\n            out.writeBytesReference(termVectors);\n        }\n    }","commit_id":"455a85dc3b9a3adf3f9562405fe6778a0701565b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        assert index != null;\n        assert type != null;\n        assert id != null;\n        builder.field(FieldStrings._INDEX, index);\n        builder.field(FieldStrings._TYPE, type);\n        if (!isArtificial()) {\n            builder.field(FieldStrings._ID, id);\n        }\n        builder.field(FieldStrings._VERSION, docVersion);\n        builder.field(FieldStrings.FOUND, isExists());\n        if (!isExists()) {\n            return builder;\n        }\n        builder.startObject(FieldStrings.TERM_VECTORS);\n        final CharsRefBuilder spare = new CharsRefBuilder();\n        Fields theFields = getFields();\n        Iterator<String> fieldIter = theFields.iterator();\n        while (fieldIter.hasNext()) {\n            buildField(builder, spare, theFields, fieldIter);\n        }\n        builder.endObject();\n        return builder;\n    }","id":83473,"modified_method":"@Override\n    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n        assert index != null;\n        assert type != null;\n        assert id != null;\n        builder.field(FieldStrings._INDEX, index);\n        builder.field(FieldStrings._TYPE, type);\n        if (!isArtificial()) {\n            builder.field(FieldStrings._ID, id);\n        }\n        builder.field(FieldStrings._VERSION, docVersion);\n        builder.field(FieldStrings.FOUND, isExists());\n        builder.field(FieldStrings.TOOK, tookInMillis);\n        if (!isExists()) {\n            return builder;\n        }\n        builder.startObject(FieldStrings.TERM_VECTORS);\n        final CharsRefBuilder spare = new CharsRefBuilder();\n        Fields theFields = getFields();\n        Iterator<String> fieldIter = theFields.iterator();\n        while (fieldIter.hasNext()) {\n            buildField(builder, spare, theFields, fieldIter);\n        }\n        builder.endObject();\n        return builder;\n    }","commit_id":"455a85dc3b9a3adf3f9562405fe6778a0701565b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        index = in.readString();\n        type = in.readString();\n        id = in.readString();\n        docVersion = in.readVLong();\n        exists = in.readBoolean();\n        if (in.readBoolean()) {\n            headerRef = in.readBytesReference();\n            termVectors = in.readBytesReference();\n        }\n    }","id":83474,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        index = in.readString();\n        type = in.readString();\n        id = in.readString();\n        docVersion = in.readVLong();\n        exists = in.readBoolean();\n        artificial = in.readBoolean();\n        tookInMillis = in.readVLong();\n        if (in.readBoolean()) {\n            headerRef = in.readBytesReference();\n            termVectors = in.readBytesReference();\n        }\n    }","commit_id":"455a85dc3b9a3adf3f9562405fe6778a0701565b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doExecute(final MultiTermVectorsRequest request, final ActionListener<MultiTermVectorsResponse> listener) {\n        ClusterState clusterState = clusterService.state();\n\n        clusterState.blocks().globalBlockedRaiseException(ClusterBlockLevel.READ);\n\n        final AtomicArray<MultiTermVectorsItemResponse> responses = new AtomicArray<>(request.requests.size());\n\n        Map<ShardId, MultiTermVectorsShardRequest> shardRequests = new HashMap<>();\n        for (int i = 0; i < request.requests.size(); i++) {\n            TermVectorsRequest termVectorsRequest = request.requests.get(i);\n            termVectorsRequest.routing(clusterState.metaData().resolveIndexRouting(termVectorsRequest.routing(), termVectorsRequest.index()));\n            if (!clusterState.metaData().hasConcreteIndex(termVectorsRequest.index())) {\n                responses.set(i, new MultiTermVectorsItemResponse(null, new MultiTermVectorsResponse.Failure(termVectorsRequest.index(),\n                        termVectorsRequest.type(), termVectorsRequest.id(), \"[\" + termVectorsRequest.index() + \"] missing\")));\n                continue;\n            }\n            String concreteSingleIndex = clusterState.metaData().concreteSingleIndex(termVectorsRequest.index(), termVectorsRequest.indicesOptions());\n            if (termVectorsRequest.routing() == null && clusterState.getMetaData().routingRequired(concreteSingleIndex, termVectorsRequest.type())) {\n                responses.set(i, new MultiTermVectorsItemResponse(null, new MultiTermVectorsResponse.Failure(concreteSingleIndex, termVectorsRequest.type(), termVectorsRequest.id(),\n                        \"routing is required for [\" + concreteSingleIndex + \"]/[\" + termVectorsRequest.type() + \"]/[\" + termVectorsRequest.id() + \"]\")));\n                continue;\n            }\n            ShardId shardId = clusterService.operationRouting().getShards(clusterState, concreteSingleIndex,\n                    termVectorsRequest.type(), termVectorsRequest.id(), termVectorsRequest.routing(), null).shardId();\n            MultiTermVectorsShardRequest shardRequest = shardRequests.get(shardId);\n            if (shardRequest == null) {\n                shardRequest = new MultiTermVectorsShardRequest(request, shardId.index().name(), shardId.id());\n                shardRequest.preference(request.preference);\n\n                shardRequests.put(shardId, shardRequest);\n            }\n            shardRequest.add(i, termVectorsRequest);\n        }\n        \n        if (shardRequests.size() == 0) {\n            // only failures..\n            listener.onResponse(new MultiTermVectorsResponse(responses.toArray(new MultiTermVectorsItemResponse[responses.length()])));\n        }\n        \n        final AtomicInteger counter = new AtomicInteger(shardRequests.size());\n        for (final MultiTermVectorsShardRequest shardRequest : shardRequests.values()) {\n            shardAction.execute(shardRequest, new ActionListener<MultiTermVectorsShardResponse>() {\n                @Override\n                public void onResponse(MultiTermVectorsShardResponse response) {\n                    for (int i = 0; i < response.locations.size(); i++) {\n                        responses.set(response.locations.get(i), new MultiTermVectorsItemResponse(response.responses.get(i),\n                                response.failures.get(i)));\n                    }\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    // create failures for all relevant requests\n                    String message = ExceptionsHelper.detailedMessage(e);\n                    for (int i = 0; i < shardRequest.locations.size(); i++) {\n                        TermVectorsRequest termVectorsRequest = shardRequest.requests.get(i);\n                        responses.set(shardRequest.locations.get(i), new MultiTermVectorsItemResponse(null,\n                                new MultiTermVectorsResponse.Failure(shardRequest.index(), termVectorsRequest.type(),\n                                        termVectorsRequest.id(), message)));\n                    }\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                private void finishHim() {\n                    listener.onResponse(new MultiTermVectorsResponse(\n                            responses.toArray(new MultiTermVectorsItemResponse[responses.length()])));\n                }\n            });\n        }\n    }","id":83475,"modified_method":"@Override\n    protected void doExecute(final MultiTermVectorsRequest request, final ActionListener<MultiTermVectorsResponse> listener) {\n        ClusterState clusterState = clusterService.state();\n\n        clusterState.blocks().globalBlockedRaiseException(ClusterBlockLevel.READ);\n\n        final AtomicArray<MultiTermVectorsItemResponse> responses = new AtomicArray<>(request.requests.size());\n\n        Map<ShardId, MultiTermVectorsShardRequest> shardRequests = new HashMap<>();\n        for (int i = 0; i < request.requests.size(); i++) {\n            TermVectorsRequest termVectorsRequest = request.requests.get(i);\n            termVectorsRequest.startTime = System.currentTimeMillis();\n            termVectorsRequest.routing(clusterState.metaData().resolveIndexRouting(termVectorsRequest.routing(), termVectorsRequest.index()));\n            if (!clusterState.metaData().hasConcreteIndex(termVectorsRequest.index())) {\n                responses.set(i, new MultiTermVectorsItemResponse(null, new MultiTermVectorsResponse.Failure(termVectorsRequest.index(),\n                        termVectorsRequest.type(), termVectorsRequest.id(), \"[\" + termVectorsRequest.index() + \"] missing\")));\n                continue;\n            }\n            String concreteSingleIndex = clusterState.metaData().concreteSingleIndex(termVectorsRequest.index(), termVectorsRequest.indicesOptions());\n            if (termVectorsRequest.routing() == null && clusterState.getMetaData().routingRequired(concreteSingleIndex, termVectorsRequest.type())) {\n                responses.set(i, new MultiTermVectorsItemResponse(null, new MultiTermVectorsResponse.Failure(concreteSingleIndex, termVectorsRequest.type(), termVectorsRequest.id(),\n                        \"routing is required for [\" + concreteSingleIndex + \"]/[\" + termVectorsRequest.type() + \"]/[\" + termVectorsRequest.id() + \"]\")));\n                continue;\n            }\n            ShardId shardId = clusterService.operationRouting().getShards(clusterState, concreteSingleIndex,\n                    termVectorsRequest.type(), termVectorsRequest.id(), termVectorsRequest.routing(), null).shardId();\n            MultiTermVectorsShardRequest shardRequest = shardRequests.get(shardId);\n            if (shardRequest == null) {\n                shardRequest = new MultiTermVectorsShardRequest(request, shardId.index().name(), shardId.id());\n                shardRequest.preference(request.preference);\n                shardRequests.put(shardId, shardRequest);\n            }\n            shardRequest.add(i, termVectorsRequest);\n        }\n        \n        if (shardRequests.size() == 0) {\n            // only failures..\n            listener.onResponse(new MultiTermVectorsResponse(responses.toArray(new MultiTermVectorsItemResponse[responses.length()])));\n        }\n        \n        final AtomicInteger counter = new AtomicInteger(shardRequests.size());\n        for (final MultiTermVectorsShardRequest shardRequest : shardRequests.values()) {\n            shardAction.execute(shardRequest, new ActionListener<MultiTermVectorsShardResponse>() {\n                @Override\n                public void onResponse(MultiTermVectorsShardResponse response) {\n                    for (int i = 0; i < response.locations.size(); i++) {\n                        responses.set(response.locations.get(i), new MultiTermVectorsItemResponse(response.responses.get(i),\n                                response.failures.get(i)));\n                    }\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    // create failures for all relevant requests\n                    String message = ExceptionsHelper.detailedMessage(e);\n                    for (int i = 0; i < shardRequest.locations.size(); i++) {\n                        TermVectorsRequest termVectorsRequest = shardRequest.requests.get(i);\n                        responses.set(shardRequest.locations.get(i), new MultiTermVectorsItemResponse(null,\n                                new MultiTermVectorsResponse.Failure(shardRequest.index(), termVectorsRequest.type(),\n                                        termVectorsRequest.id(), message)));\n                    }\n                    if (counter.decrementAndGet() == 0) {\n                        finishHim();\n                    }\n                }\n\n                private void finishHim() {\n                    listener.onResponse(new MultiTermVectorsResponse(\n                            responses.toArray(new MultiTermVectorsItemResponse[responses.length()])));\n                }\n            });\n        }\n    }","commit_id":"455a85dc3b9a3adf3f9562405fe6778a0701565b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected MultiTermVectorsShardResponse shardOperation(MultiTermVectorsShardRequest request, ShardId shardId) throws ElasticsearchException {\n        MultiTermVectorsShardResponse response = new MultiTermVectorsShardResponse();\n        for (int i = 0; i < request.locations.size(); i++) {\n            TermVectorsRequest termVectorsRequest = request.requests.get(i);\n            try {\n                IndexService indexService = indicesService.indexServiceSafe(request.index());\n                IndexShard indexShard = indexService.shardSafe(shardId.id());\n                TermVectorsResponse termVectorsResponse = indexShard.termVectorsService().getTermVectors(termVectorsRequest, shardId.getIndex());\n                response.add(request.locations.get(i), termVectorsResponse);\n            } catch (Throwable t) {\n                if (TransportActions.isShardNotAvailableException(t)) {\n                    throw (ElasticsearchException) t;\n                } else {\n                    logger.debug(\"{} failed to execute multi term vectors for [{}]/[{}]\", t, shardId, termVectorsRequest.type(), termVectorsRequest.id());\n                    response.add(request.locations.get(i),\n                            new MultiTermVectorsResponse.Failure(request.index(), termVectorsRequest.type(), termVectorsRequest.id(), ExceptionsHelper.detailedMessage(t)));\n                }\n            }\n        }\n\n        return response;\n    }","id":83476,"modified_method":"@Override\n    protected MultiTermVectorsShardResponse shardOperation(MultiTermVectorsShardRequest request, ShardId shardId) throws ElasticsearchException {\n        MultiTermVectorsShardResponse response = new MultiTermVectorsShardResponse();\n        for (int i = 0; i < request.locations.size(); i++) {\n            TermVectorsRequest termVectorsRequest = request.requests.get(i);\n            try {\n                IndexService indexService = indicesService.indexServiceSafe(request.index());\n                IndexShard indexShard = indexService.shardSafe(shardId.id());\n                TermVectorsResponse termVectorsResponse = indexShard.termVectorsService().getTermVectors(termVectorsRequest, shardId.getIndex());\n                termVectorsResponse.updateTookInMillis(termVectorsRequest.startTime());\n                response.add(request.locations.get(i), termVectorsResponse);\n            } catch (Throwable t) {\n                if (TransportActions.isShardNotAvailableException(t)) {\n                    throw (ElasticsearchException) t;\n                } else {\n                    logger.debug(\"{} failed to execute multi term vectors for [{}]/[{}]\", t, shardId, termVectorsRequest.type(), termVectorsRequest.id());\n                    response.add(request.locations.get(i),\n                            new MultiTermVectorsResponse.Failure(request.index(), termVectorsRequest.type(), termVectorsRequest.id(), ExceptionsHelper.detailedMessage(t)));\n                }\n            }\n        }\n\n        return response;\n    }","commit_id":"455a85dc3b9a3adf3f9562405fe6778a0701565b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected TermVectorsResponse shardOperation(TermVectorsRequest request, ShardId shardId) throws ElasticsearchException {\n        IndexService indexService = indicesService.indexServiceSafe(shardId.getIndex());\n        IndexShard indexShard = indexService.shardSafe(shardId.id());\n        return indexShard.termVectorsService().getTermVectors(request, shardId.getIndex());\n    }","id":83477,"modified_method":"@Override\n    protected TermVectorsResponse shardOperation(TermVectorsRequest request, ShardId shardId) throws ElasticsearchException {\n        IndexService indexService = indicesService.indexServiceSafe(shardId.getIndex());\n        IndexShard indexShard = indexService.shardSafe(shardId.id());\n        TermVectorsResponse response = indexShard.termVectorsService().getTermVectors(request, shardId.getIndex());\n        response.updateTookInMillis(request.startTime());\n        return response;\n    }","commit_id":"455a85dc3b9a3adf3f9562405fe6778a0701565b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n  public SVNInfo doInfo(SVNURL url, SVNRevision pegRevision, SVNRevision revision) throws SVNException {\n    List<String> parameters = new ArrayList<String>();\n\n    fillParameters(url.toDecodedString(), pegRevision, revision, SVNDepth.EMPTY, parameters);\n    CommandExecutor command;\n    try {\n      command = execute(myVcs, SvnTarget.fromURL(url), SvnCommandName.info, parameters, null);\n    }\n    catch (SvnBindException e) {\n      SVNErrorCode code = e.contains(SVNErrorCode.RA_ILLEGAL_URL) ? SVNErrorCode.RA_ILLEGAL_URL : SVNErrorCode.IO_ERROR;\n\n      throw new SVNException(SVNErrorMessage.create(code, e), e);\n    }\n\n    CollectInfoHandler handler = new CollectInfoHandler();\n    parseResult(handler, null, command.getOutput());\n    return handler.getInfo();\n  }","id":83478,"modified_method":"@Override\n  public SVNInfo doInfo(SVNURL url, SVNRevision pegRevision, SVNRevision revision) throws SVNException {\n    CommandExecutor command;\n    try {\n      command = execute(myVcs, SvnTarget.fromURL(url), SvnCommandName.info,\n                        buildParameters(url.toDecodedString(), pegRevision, revision, SVNDepth.EMPTY), null);\n    }\n    catch (SvnBindException e) {\n      throw createError(e.contains(SVNErrorCode.RA_ILLEGAL_URL) ? SVNErrorCode.RA_ILLEGAL_URL : SVNErrorCode.IO_ERROR, e);\n    }\n\n    return parseResult(null, command.getOutput());\n  }","commit_id":"ab74ce336de4615f9b984c97f7753efb18fb7e68","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void fillParameters(String path, SVNRevision pegRevision, SVNRevision revision, SVNDepth depth, List<String> parameters) {\n    CommandUtil.put(parameters, depth);\n    CommandUtil.put(parameters, revision);\n    CommandUtil.put(parameters, path, pegRevision);\n    parameters.add(\"--xml\");\n  }","id":83479,"modified_method":"@NotNull\n  private static List<String> buildParameters(@NotNull String path,\n                                              @Nullable SVNRevision pegRevision,\n                                              @Nullable SVNRevision revision,\n                                              @Nullable SVNDepth depth) {\n    List<String> parameters = ContainerUtil.newArrayList();\n\n    CommandUtil.put(parameters, depth);\n    CommandUtil.put(parameters, revision);\n    CommandUtil.put(parameters, path, pegRevision);\n    parameters.add(\"--xml\");\n\n    return parameters;\n  }","commit_id":"ab74ce336de4615f9b984c97f7753efb18fb7e68","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String execute(@NotNull List<String> parameters, @NotNull File path) throws SVNException {\n    // workaround: separately capture command output - used in exception handling logic to overcome svn 1.8 issue (see below)\n    final ProcessOutput output = new ProcessOutput();\n    LineCommandListener listener = new LineCommandAdapter() {\n      @Override\n      public void onLineAvailable(String line, Key outputType) {\n        if (outputType == ProcessOutputTypes.STDOUT) {\n          output.appendStdout(line);\n        }\n      }\n    };\n\n    try {\n      CommandExecutor command = execute(myVcs, SvnTarget.fromFile(path), SvnCommandName.info, parameters, listener);\n\n      return command.getOutput();\n    }\n    catch (VcsException e) {\n      final String text = e.getMessage();\n      final boolean notEmpty = !StringUtil.isEmptyOrSpaces(text);\n      if (notEmpty && text.contains(\"W155010\")) {\n        // if \"svn info\" is executed for several files at once, then this warning could be printed only for some files, but info for other\n        // files should be parsed from output\n        return output.getStdout();\n      }\n      // not a working copy exception\n      // \"E155007: '' is not a working copy\"\n      if (notEmpty && text.contains(\"is not a working copy\")) {\n        if (StringUtil.isNotEmpty(output.getStdout())) {\n          // TODO: Seems not reproducible in 1.8.4\n          // workaround: as in subversion 1.8 \"svn info\" on a working copy root outputs such error for parent folder,\n          // if there are files with conflicts.\n          // but the requested info is still in the output except root closing tag\n          return output.getStdout() + \"<\/info>\";\n        } else {\n          throw new SVNException(SVNErrorMessage.create(SVNErrorCode.WC_NOT_WORKING_COPY, e), e);\n        }\n      // svn: E200009: Could not display info for all targets because some targets don't exist\n      } else if (notEmpty && text.contains(\"some targets don't exist\")) {\n        throw new SVNException(SVNErrorMessage.create(SVNErrorCode.ILLEGAL_TARGET, e), e);\n      } else if (notEmpty && text.contains(String.valueOf(SVNErrorCode.WC_UPGRADE_REQUIRED.getCode()))) {\n        throw new SVNException(SVNErrorMessage.create(SVNErrorCode.WC_UPGRADE_REQUIRED, e), e);\n      } else if (notEmpty &&\n                 (text.contains(\"upgrade your Subversion client\") ||\n                  text.contains(String.valueOf(SVNErrorCode.WC_UNSUPPORTED_FORMAT.getCode())))) {\n        throw new SVNException(SVNErrorMessage.create(SVNErrorCode.WC_UNSUPPORTED_FORMAT, e), e);\n      }\n      throw new SVNException(SVNErrorMessage.create(SVNErrorCode.IO_ERROR, e), e);\n    }\n  }","id":83480,"modified_method":"private String execute(@NotNull List<String> parameters, @NotNull File path) throws SVNException {\n    // workaround: separately capture command output - used in exception handling logic to overcome svn 1.8 issue (see below)\n    final ProcessOutput output = new ProcessOutput();\n    LineCommandListener listener = new LineCommandAdapter() {\n      @Override\n      public void onLineAvailable(String line, Key outputType) {\n        if (outputType == ProcessOutputTypes.STDOUT) {\n          output.appendStdout(line);\n        }\n      }\n    };\n\n    try {\n      CommandExecutor command = execute(myVcs, SvnTarget.fromFile(path), SvnCommandName.info, parameters, listener);\n\n      return command.getOutput();\n    }\n    catch (VcsException e) {\n      final String text = e.getMessage();\n      final boolean notEmpty = !StringUtil.isEmptyOrSpaces(text);\n      if (notEmpty && text.contains(\"W155010\")) {\n        // if \"svn info\" is executed for several files at once, then this warning could be printed only for some files, but info for other\n        // files should be parsed from output\n        return output.getStdout();\n      }\n      // not a working copy exception\n      // \"E155007: '' is not a working copy\"\n      if (notEmpty && text.contains(\"is not a working copy\")) {\n        if (StringUtil.isNotEmpty(output.getStdout())) {\n          // TODO: Seems not reproducible in 1.8.4\n          // workaround: as in subversion 1.8 \"svn info\" on a working copy root outputs such error for parent folder,\n          // if there are files with conflicts.\n          // but the requested info is still in the output except root closing tag\n          return output.getStdout() + \"<\/info>\";\n        } else {\n          throw createError(SVNErrorCode.WC_NOT_WORKING_COPY, e);\n        }\n      // svn: E200009: Could not display info for all targets because some targets don't exist\n      } else if (notEmpty && text.contains(\"some targets don't exist\")) {\n        throw createError(SVNErrorCode.ILLEGAL_TARGET, e);\n      } else if (notEmpty && text.contains(String.valueOf(SVNErrorCode.WC_UPGRADE_REQUIRED.getCode()))) {\n        throw createError(SVNErrorCode.WC_UPGRADE_REQUIRED, e);\n      } else if (notEmpty &&\n                 (text.contains(\"upgrade your Subversion client\") ||\n                  text.contains(String.valueOf(SVNErrorCode.WC_UNSUPPORTED_FORMAT.getCode())))) {\n        throw createError(SVNErrorCode.WC_UNSUPPORTED_FORMAT, e);\n      }\n      throw createError(SVNErrorCode.IO_ERROR, e);\n    }\n  }","commit_id":"ab74ce336de4615f9b984c97f7753efb18fb7e68","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void parseResult(@NotNull final ISVNInfoHandler handler, @Nullable File base, @Nullable String result) throws SVNException {\n    if (StringUtil.isEmptyOrSpaces(result)) {\n      return;\n    }\n\n    final SvnInfoHandler[] infoHandler = new SvnInfoHandler[1];\n    infoHandler[0] = new SvnInfoHandler(base, new Consumer<SVNInfo>() {\n      @Override\n      public void consume(SVNInfo info) {\n        try {\n          handler.handleInfo(info);\n        }\n        catch (SVNException e) {\n          throw new SvnExceptionWrapper(e);\n        }\n      }\n    });\n\n    try {\n      SAXParser parser = SAXParserFactory.newInstance().newSAXParser();\n\n      parser.parse(new ByteArrayInputStream(result.trim().getBytes(CharsetToolkit.UTF8_CHARSET)), infoHandler[0]);\n    }\n    catch (SvnExceptionWrapper e) {\n      LOG.info(\"info output \" + result);\n      throw (SVNException) e.getCause();\n    } catch (IOException e) {\n      LOG.info(\"info output \" + result);\n      throw new SVNException(SVNErrorMessage.create(SVNErrorCode.IO_ERROR, e), e);\n    }\n    catch (ParserConfigurationException e) {\n      LOG.info(\"info output \" + result);\n      throw new SVNException(SVNErrorMessage.create(SVNErrorCode.IO_ERROR, e), e);\n    }\n    catch (SAXException e) {\n      LOG.info(\"info output \" + result);\n      throw new SVNException(SVNErrorMessage.create(SVNErrorCode.IO_ERROR, e), e);\n    }\n  }","id":83481,"modified_method":"private static void parseResult(@NotNull final ISVNInfoHandler handler, @Nullable File base, @Nullable String result) throws SVNException {\n    if (StringUtil.isEmptyOrSpaces(result)) {\n      return;\n    }\n\n    final SvnInfoHandler infoHandler = new SvnInfoHandler(base, new Consumer<SVNInfo>() {\n      @Override\n      public void consume(SVNInfo info) {\n        try {\n          handler.handleInfo(info);\n        }\n        catch (SVNException e) {\n          throw new SvnExceptionWrapper(e);\n        }\n      }\n    });\n\n    parseResult(result, infoHandler);\n  }","commit_id":"ab74ce336de4615f9b984c97f7753efb18fb7e68","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public SVNInfo doInfo(File path, SVNRevision revision) throws SVNException {\n    File base = path.isDirectory() ? path : path.getParentFile();\n    base = CommandUtil.correctUpToExistingParent(base);\n    if (base == null) {\n      // very unrealistic\n      throw new SVNException(SVNErrorMessage.create(SVNErrorCode.IO_ERROR, \"Can not find existing parent file\"));\n    }\n    CollectInfoHandler handler = new CollectInfoHandler();\n    issueCommand(path, SVNRevision.UNDEFINED, revision, SVNDepth.EMPTY, null, handler, base);\n    return handler.getInfo();\n  }","id":83482,"modified_method":"@Override\n  public SVNInfo doInfo(File path, SVNRevision revision) throws SVNException {\n    File base = path.isDirectory() ? path : path.getParentFile();\n    base = CommandUtil.correctUpToExistingParent(base);\n    if (base == null) {\n      // very unrealistic\n      throw new SVNException(SVNErrorMessage.create(SVNErrorCode.IO_ERROR, \"Can not find existing parent file\"));\n    }\n\n    return parseResult(base, execute(buildParameters(path.getAbsolutePath(), SVNRevision.UNDEFINED, revision, SVNDepth.EMPTY), path));\n  }","commit_id":"ab74ce336de4615f9b984c97f7753efb18fb7e68","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void setDefaultDebtRemediationFunctionFields(Rules.Rule.Builder ruleResponse, RuleDto ruleDto, Set<String> fieldsToReturn) {\n    if (shouldReturnField(fieldsToReturn, FIELD_DEFAULT_DEBT_REM_FUNCTION)) {\n      DebtRemediationFunction defaultDebtRemediationFunction = defaultDebtRemediationFunction(ruleDto);\n      if (defaultDebtRemediationFunction != null) {\n        String gapMultiplier = defaultDebtRemediationFunction.gapMultiplier();\n        if (gapMultiplier != null) {\n          ruleResponse.setDefaultRemFnGapMultiplier(gapMultiplier);\n          // Set deprecated field\n          ruleResponse.setDefaultDebtRemFnCoeff(gapMultiplier);\n        }\n        String baseEffort = defaultDebtRemediationFunction.baseEffort();\n        if (baseEffort != null) {\n          ruleResponse.setDefaultRemFnBaseEffort(baseEffort);\n          // Set deprecated field\n          ruleResponse.setDefaultDebtRemFnOffset(baseEffort);\n        }\n        if (defaultDebtRemediationFunction.type() != null) {\n          ruleResponse.setDefaultRemFnType(defaultDebtRemediationFunction.type().name());\n          // Set deprecated field\n          ruleResponse.setDefaultDebtRemFnType(defaultDebtRemediationFunction.type().name());\n        }\n      }\n    }\n  }","id":83483,"modified_method":"private static void setDefaultDebtRemediationFunctionFields(Rules.Rule.Builder ruleResponse, RuleDto ruleDto, Set<String> fieldsToReturn) {\n    if (shouldReturnField(fieldsToReturn, FIELD_DEFAULT_DEBT_REM_FUNCTION) || shouldReturnField(fieldsToReturn, FIELD_DEFAULT_REM_FUNCTION)) {\n      DebtRemediationFunction defaultDebtRemediationFunction = defaultDebtRemediationFunction(ruleDto);\n      if (defaultDebtRemediationFunction != null) {\n        String gapMultiplier = defaultDebtRemediationFunction.gapMultiplier();\n        if (gapMultiplier != null) {\n          ruleResponse.setDefaultRemFnGapMultiplier(gapMultiplier);\n          // Set deprecated field\n          ruleResponse.setDefaultDebtRemFnCoeff(gapMultiplier);\n        }\n        String baseEffort = defaultDebtRemediationFunction.baseEffort();\n        if (baseEffort != null) {\n          ruleResponse.setDefaultRemFnBaseEffort(baseEffort);\n          // Set deprecated field\n          ruleResponse.setDefaultDebtRemFnOffset(baseEffort);\n        }\n        if (defaultDebtRemediationFunction.type() != null) {\n          ruleResponse.setDefaultRemFnType(defaultDebtRemediationFunction.type().name());\n          // Set deprecated field\n          ruleResponse.setDefaultDebtRemFnType(defaultDebtRemediationFunction.type().name());\n        }\n      }\n    }\n  }","commit_id":"155d3d07c1e888a7cd51c57dceb58188e06635e7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static boolean ruleToOverloaded(RuleDto rule) {\n    return rule.getRemediationFunction() != null;\n  }","id":83484,"modified_method":"private static boolean isRemediationFunctionOverloaded(RuleDto rule) {\n    return rule.getRemediationFunction() != null;\n  }","commit_id":"155d3d07c1e888a7cd51c57dceb58188e06635e7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void setIsDebtOverloaded(Rules.Rule.Builder ruleResponse, RuleDto ruleDto, Set<String> fieldsToReturn) {\n    if (shouldReturnField(fieldsToReturn, FIELD_DEBT_OVERLOADED)) {\n      ruleResponse.setDebtOverloaded(ruleToOverloaded(ruleDto));\n    }\n  }","id":83485,"modified_method":"private static void setIsRemediationFunctionOverloaded(Rules.Rule.Builder ruleResponse, RuleDto ruleDto, Set<String> fieldsToReturn) {\n    if (shouldReturnField(fieldsToReturn, FIELD_DEBT_OVERLOADED) || shouldReturnField(fieldsToReturn, FIELD_REM_FUNCTION_OVERLOADED)) {\n      ruleResponse.setDebtOverloaded(isRemediationFunctionOverloaded(ruleDto));\n      ruleResponse.setRemFnOverloaded(isRemediationFunctionOverloaded(ruleDto));\n    }\n  }","commit_id":"155d3d07c1e888a7cd51c57dceb58188e06635e7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void setEffortToFixDescription(Rules.Rule.Builder ruleResponse, RuleDto ruleDto, Set<String> fieldsToReturn) {\n    if (shouldReturnField(fieldsToReturn, FIELD_EFFORT_TO_FIX_DESCRIPTION) && ruleDto.getGapDescription() != null) {\n      ruleResponse.setEffortToFixDescription(ruleDto.getGapDescription());\n      ruleResponse.setGapDescription(ruleDto.getGapDescription());\n    }\n  }","id":83486,"modified_method":"private static void setEffortToFixDescription(Rules.Rule.Builder ruleResponse, RuleDto ruleDto, Set<String> fieldsToReturn) {\n    if ((shouldReturnField(fieldsToReturn, FIELD_EFFORT_TO_FIX_DESCRIPTION) || shouldReturnField(fieldsToReturn, FIELD_GAP_DESCRIPTION))\n      && ruleDto.getGapDescription() != null) {\n      ruleResponse.setEffortToFixDescription(ruleDto.getGapDescription());\n      ruleResponse.setGapDescription(ruleDto.getGapDescription());\n    }\n  }","commit_id":"155d3d07c1e888a7cd51c57dceb58188e06635e7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Convert a RuleDto to WsRule. If fieldsToReturn is empty all the fields are returned\n   */\n  public Rules.Rule toWsRule(RuleDto ruleDto, SearchResult result, Set<String> fieldsToReturn) {\n    Rules.Rule.Builder ruleResponse = Rules.Rule.newBuilder();\n\n    // Mandatory fields\n    ruleResponse.setKey(ruleDto.getKey().toString());\n    Common.RuleType type = Common.RuleType.valueOf(ruleDto.getType());\n    ruleResponse.setType(type);\n\n    // Optional fields\n    setRepository(ruleResponse, ruleDto, fieldsToReturn);\n    setName(ruleResponse, ruleDto, fieldsToReturn);\n    setStatus(ruleResponse, ruleDto, fieldsToReturn);\n    setTags(ruleResponse, ruleDto, fieldsToReturn);\n    setSysTags(ruleResponse, ruleDto, fieldsToReturn);\n    setParams(ruleResponse, ruleDto, result, fieldsToReturn);\n    setCreatedAt(ruleResponse, ruleDto, fieldsToReturn);\n    setDescriptionFields(ruleResponse, ruleDto, fieldsToReturn);\n    setNotesFields(ruleResponse, ruleDto, fieldsToReturn);\n    setSeverity(ruleResponse, ruleDto, fieldsToReturn);\n    setInternalKey(ruleResponse, ruleDto, fieldsToReturn);\n    setLanguage(ruleResponse, ruleDto, fieldsToReturn);\n    setLanguageName(ruleResponse, ruleDto, fieldsToReturn);\n    setIsTemplate(ruleResponse, ruleDto, fieldsToReturn);\n    setTemplateKey(ruleResponse, ruleDto, result, fieldsToReturn);\n    setDebtRemediationFunctionFields(ruleResponse, ruleDto, fieldsToReturn);\n    setDefaultDebtRemediationFunctionFields(ruleResponse, ruleDto, fieldsToReturn);\n    setIsDebtOverloaded(ruleResponse, ruleDto, fieldsToReturn);\n    setEffortToFixDescription(ruleResponse, ruleDto, fieldsToReturn);\n\n    return ruleResponse.build();\n  }","id":83487,"modified_method":"/**\n   * Convert a RuleDto to WsRule. If fieldsToReturn is empty all the fields are returned\n   */\n  public Rules.Rule toWsRule(RuleDto ruleDto, SearchResult result, Set<String> fieldsToReturn) {\n    Rules.Rule.Builder ruleResponse = Rules.Rule.newBuilder();\n\n    // Mandatory fields\n    ruleResponse.setKey(ruleDto.getKey().toString());\n    Common.RuleType type = Common.RuleType.valueOf(ruleDto.getType());\n    ruleResponse.setType(type);\n\n    // Optional fields\n    setRepository(ruleResponse, ruleDto, fieldsToReturn);\n    setName(ruleResponse, ruleDto, fieldsToReturn);\n    setStatus(ruleResponse, ruleDto, fieldsToReturn);\n    setTags(ruleResponse, ruleDto, fieldsToReturn);\n    setSysTags(ruleResponse, ruleDto, fieldsToReturn);\n    setParams(ruleResponse, ruleDto, result, fieldsToReturn);\n    setCreatedAt(ruleResponse, ruleDto, fieldsToReturn);\n    setDescriptionFields(ruleResponse, ruleDto, fieldsToReturn);\n    setNotesFields(ruleResponse, ruleDto, fieldsToReturn);\n    setSeverity(ruleResponse, ruleDto, fieldsToReturn);\n    setInternalKey(ruleResponse, ruleDto, fieldsToReturn);\n    setLanguage(ruleResponse, ruleDto, fieldsToReturn);\n    setLanguageName(ruleResponse, ruleDto, fieldsToReturn);\n    setIsTemplate(ruleResponse, ruleDto, fieldsToReturn);\n    setTemplateKey(ruleResponse, ruleDto, result, fieldsToReturn);\n    setDebtRemediationFunctionFields(ruleResponse, ruleDto, fieldsToReturn);\n    setDefaultDebtRemediationFunctionFields(ruleResponse, ruleDto, fieldsToReturn);\n    setIsRemediationFunctionOverloaded(ruleResponse, ruleDto, fieldsToReturn);\n    setEffortToFixDescription(ruleResponse, ruleDto, fieldsToReturn);\n\n    return ruleResponse.build();\n  }","commit_id":"155d3d07c1e888a7cd51c57dceb58188e06635e7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void setDebtRemediationFunctionFields(Rules.Rule.Builder ruleResponse, RuleDto ruleDto, Set<String> fieldsToReturn) {\n    if (shouldReturnField(fieldsToReturn, FIELD_DEBT_REM_FUNCTION)) {\n      DebtRemediationFunction debtRemediationFunction = debtRemediationFunction(ruleDto);\n      if (debtRemediationFunction != null) {\n        if (debtRemediationFunction.type() != null) {\n          ruleResponse.setRemFnType(debtRemediationFunction.type().name());\n          // Set deprecated field\n          ruleResponse.setDebtRemFnType(debtRemediationFunction.type().name());\n        }\n        String gapMultiplier = debtRemediationFunction.gapMultiplier();\n        if (gapMultiplier != null) {\n          ruleResponse.setRemFnGapMultiplier(gapMultiplier);\n          // Set deprecated field\n          ruleResponse.setDebtRemFnCoeff(gapMultiplier);\n        }\n        String baseEffort = debtRemediationFunction.baseEffort();\n        if (baseEffort != null) {\n          ruleResponse.setRemFnBaseEffort(baseEffort);\n          // Set deprecated field\n          ruleResponse.setDebtRemFnOffset(baseEffort);\n        }\n      }\n    }\n  }","id":83488,"modified_method":"private static void setDebtRemediationFunctionFields(Rules.Rule.Builder ruleResponse, RuleDto ruleDto, Set<String> fieldsToReturn) {\n    if (shouldReturnField(fieldsToReturn, FIELD_DEBT_REM_FUNCTION) || shouldReturnField(fieldsToReturn, FIELD_REM_FUNCTION)) {\n      DebtRemediationFunction debtRemediationFunction = debtRemediationFunction(ruleDto);\n      if (debtRemediationFunction != null) {\n        if (debtRemediationFunction.type() != null) {\n          ruleResponse.setRemFnType(debtRemediationFunction.type().name());\n          // Set deprecated field\n          ruleResponse.setDebtRemFnType(debtRemediationFunction.type().name());\n        }\n        String gapMultiplier = debtRemediationFunction.gapMultiplier();\n        if (gapMultiplier != null) {\n          ruleResponse.setRemFnGapMultiplier(gapMultiplier);\n          // Set deprecated field\n          ruleResponse.setDebtRemFnCoeff(gapMultiplier);\n        }\n        String baseEffort = debtRemediationFunction.baseEffort();\n        if (baseEffort != null) {\n          ruleResponse.setRemFnBaseEffort(baseEffort);\n          // Set deprecated field\n          ruleResponse.setDebtRemFnOffset(baseEffort);\n        }\n      }\n    }\n  }","commit_id":"155d3d07c1e888a7cd51c57dceb58188e06635e7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void doDefinition(WebService.NewAction action) {\n    action.setDescription(\"Search for a collection of relevant rules matching a specified query.<br/>\" +\n      \"Since 5.5, following fields in the response have been deprecated :\" +\n      \"<ul><li>\\\"effortToFixDescription\\\" becomes \\\"gapDescription\\\"<\/li>\" +\n      \"<li>\\\"debtRemFnCoeff\\\" becomes \\\"remFnGapMultiplier\\\"<\/li>\" +\n      \"<li>\\\"defaultDebtRemFnCoeff\\\" becomes \\\"defaultRemFnGapMultiplier\\\"<\/li>\" +\n      \"<li>\\\"debtRemFnOffset\\\" becomes \\\"remFnBaseEffort\\\"<\/li>\" +\n      \"<li>\\\"defaultDebtRemFnOffset\\\" becomes \\\"defaultRemFnBaseEffort\\\"<\/li><\/ul>\")\n      .setResponseExample(Resources.getResource(getClass(), \"example-search.json\"))\n      .setSince(\"4.4\")\n      .setHandler(this);\n\n    // Rule-specific search parameters\n    defineRuleSearchParameters(action);\n  }","id":83489,"modified_method":"protected void doDefinition(WebService.NewAction action) {\n    action.setDescription(\"Search for a collection of relevant rules matching a specified query.<br/>\" +\n      \"Since 5.5, following fields in the response have been deprecated :\" +\n      \"<ul>\" +\n      \"<li>\\\"effortToFixDescription\\\" becomes \\\"gapDescription\\\"<\/li>\" +\n      \"<li>\\\"debtRemFnCoeff\\\" becomes \\\"remFnGapMultiplier\\\"<\/li>\" +\n      \"<li>\\\"defaultDebtRemFnCoeff\\\" becomes \\\"defaultRemFnGapMultiplier\\\"<\/li>\" +\n      \"<li>\\\"debtRemFnOffset\\\" becomes \\\"remFnBaseEffort\\\"<\/li>\" +\n      \"<li>\\\"defaultDebtRemFnOffset\\\" becomes \\\"defaultRemFnBaseEffort\\\"<\/li>\" +\n      \"<li>\\\"debtOverloaded\\\" becomes \\\"remFnOverloaded\\\"<\/li>\" +\n      \"<\/ul>\")\n      .setResponseExample(Resources.getResource(getClass(), \"example-search.json\"))\n      .setSince(\"4.4\")\n      .setHandler(this);\n\n    // Rule-specific search parameters\n    defineRuleSearchParameters(action);\n  }","commit_id":"155d3d07c1e888a7cd51c57dceb58188e06635e7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(ACTION)\n      .addPagingParams(100, org.sonar.server.es.SearchOptions.MAX_LIMIT)\n      .setHandler(this);\n\n    Collection<String> possibleFacets = possibleFacets();\n    WebService.NewParam paramFacets = action.createParam(Param.FACETS)\n      .setDescription(\"Comma-separated list of the facets to be computed. No facet is computed by default.\")\n      .setPossibleValues(possibleFacets);\n    if (possibleFacets != null && possibleFacets.size() > 1) {\n      Iterator<String> it = possibleFacets.iterator();\n      paramFacets.setExampleValue(String.format(\"%s,%s\", it.next(), it.next()));\n    }\n\n    WebService.NewParam paramFields = action.createParam(Param.FIELDS)\n      .setDescription(\"Comma-separated list of the fields to be returned in response. All the fields are returned by default, except actives.\")\n      .setPossibleValues(OPTIONAL_FIELDS);\n    Iterator<String> it = OPTIONAL_FIELDS.iterator();\n    paramFields.setExampleValue(String.format(\"%s,%s\", it.next(), it.next()));\n\n    doDefinition(action);\n  }","id":83490,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(ACTION)\n      .addPagingParams(100, org.sonar.server.es.SearchOptions.MAX_LIMIT)\n      .setHandler(this);\n\n    Collection<String> possibleFacets = possibleFacets();\n    WebService.NewParam paramFacets = action.createParam(Param.FACETS)\n      .setDescription(\"Comma-separated list of the facets to be computed. No facet is computed by default.\")\n      .setPossibleValues(possibleFacets);\n    if (possibleFacets != null && possibleFacets.size() > 1) {\n      Iterator<String> it = possibleFacets.iterator();\n      paramFacets.setExampleValue(String.format(\"%s,%s\", it.next(), it.next()));\n    }\n\n    WebService.NewParam paramFields = action.createParam(Param.FIELDS)\n      .setDescription(\"Comma-separated list of the fields to be returned in response. All the fields are returned by default, except actives.\" +\n        \"Since 5.5, following fields have been deprecated :\" +\n        \"<ul>\" +\n        \"<li>\\\"defaultDebtRemFn\\\" becomes \\\"defaultRemFn\\\"<\/li>\" +\n        \"<li>\\\"debtRemFn\\\" becomes \\\"remFn\\\"<\/li>\" +\n        \"<li>\\\"effortToFixDescription\\\" becomes \\\"gapDescription\\\"<\/li>\" +\n        \"<li>\\\"debtOverloaded\\\" becomes \\\"remFnOverloaded\\\"<\/li>\" +\n        \"<\/ul>\")\n      .setPossibleValues(OPTIONAL_FIELDS);\n    Iterator<String> it = OPTIONAL_FIELDS.iterator();\n    paramFields.setExampleValue(String.format(\"%s,%s\", it.next(), it.next()));\n\n    doDefinition(action);\n  }","commit_id":"155d3d07c1e888a7cd51c57dceb58188e06635e7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller\n      .createAction(\"show\")\n      .setDescription(\"Get detailed information about a rule\" +\n        \"Since 5.5, following fields in the response have been deprecated :\" +\n        \"<ul><li>\\\"effortToFixDescription\\\" becomes \\\"gapDescription\\\"<\/li>\" +\n        \"<li>\\\"debtRemFnCoeff\\\" becomes \\\"remFnGapMultiplier\\\"<\/li>\" +\n        \"<li>\\\"defaultDebtRemFnCoeff\\\" becomes \\\"defaultRemFnGapMultiplier\\\"<\/li>\" +\n        \"<li>\\\"debtRemFnOffset\\\" becomes \\\"remFnBaseEffort\\\"<\/li>\" +\n        \"<li>\\\"defaultDebtRemFnOffset\\\" becomes \\\"defaultRemFnBaseEffort\\\"<\/li><\/ul>\")\n      .setSince(\"4.2\")\n      .setResponseExample(Resources.getResource(getClass(), \"example-show.json\"))\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_KEY)\n      .setDescription(\"Rule key\")\n      .setRequired(true)\n      .setExampleValue(\"javascript:EmptyBlock\");\n\n    action\n      .createParam(PARAM_ACTIVES)\n      .setDescription(\"Show rule's activations for all profiles (\\\"active rules\\\")\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(false);\n  }","id":83491,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller\n      .createAction(\"show\")\n      .setDescription(\"Get detailed information about a rule\" +\n        \"Since 5.5, following fields in the response have been deprecated :\" +\n        \"<ul>\" +\n        \"<li>\\\"effortToFixDescription\\\" becomes \\\"gapDescription\\\"<\/li>\" +\n        \"<li>\\\"debtRemFnCoeff\\\" becomes \\\"remFnGapMultiplier\\\"<\/li>\" +\n        \"<li>\\\"defaultDebtRemFnCoeff\\\" becomes \\\"defaultRemFnGapMultiplier\\\"<\/li>\" +\n        \"<li>\\\"debtRemFnOffset\\\" becomes \\\"remFnBaseEffort\\\"<\/li>\" +\n        \"<li>\\\"defaultDebtRemFnOffset\\\" becomes \\\"defaultRemFnBaseEffort\\\"<\/li>\" +\n        \"<li>\\\"debtOverloaded\\\" becomes \\\"remFnOverloaded\\\"<\/li>\" +\n        \"<\/ul>\")\n      .setSince(\"4.2\")\n      .setResponseExample(Resources.getResource(getClass(), \"example-show.json\"))\n      .setHandler(this);\n\n    action\n      .createParam(PARAM_KEY)\n      .setDescription(\"Rule key\")\n      .setRequired(true)\n      .setExampleValue(\"javascript:EmptyBlock\");\n\n    action\n      .createParam(PARAM_ACTIVES)\n      .setDescription(\"Show rule's activations for all profiles (\\\"active rules\\\")\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(false);\n  }","commit_id":"155d3d07c1e888a7cd51c57dceb58188e06635e7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * Load vanity paths Search for all nodes inheriting the sling:VanityPath\n     * mixin\n     */\n    private Collection<String> loadVanityPaths(final ResourceResolver resolver, final Map<String, List<MapEntry>> entryMap) {\n        // sling:VanityPath (uppercase V) is the mixin name\n        // sling:vanityPath (lowercase) is the property name\n        final Set<String> targetPaths = new HashSet<String>();\n        final String queryString = \"SELECT sling:vanityPath, sling:redirect, sling:redirectStatus FROM sling:VanityPath WHERE sling:vanityPath IS NOT NULL ORDER BY sling:vanityOrder DESC\";\n        final Iterator<Resource> i = resolver.findResources(queryString, \"sql\");\n\n        final Set<String> processedVanityPaths = new HashSet<String>();\n\n        while (i.hasNext()) {\n            final Resource resource = i.next();\n\n            // ignore system tree\n            if (resource.getPath().startsWith(JCR_SYSTEM_PREFIX)) {\n                log.debug(\"loadVanityPaths: Ignoring {}\", resource);\n                continue;\n            }\n\n            // require properties\n            final ValueMap props = resource.adaptTo(ValueMap.class);\n            if (props == null) {\n                log.debug(\"loadVanityPaths: Ignoring {} without properties\", resource);\n                continue;\n            }\n\n            // url is ignoring scheme and host.port and the path is\n            // what is stored in the sling:vanityPath property\n            final String[] pVanityPaths = props.get(\"sling:vanityPath\", new String[0]);\n            for (final String pVanityPath : pVanityPaths) {\n                final String[] result = this.getVanityPathDefinition(pVanityPath);\n                if (result != null) {\n                    final String url = result[0] + result[1];\n\n                    if ( !processedVanityPaths.contains(url) ) {\n                        processedVanityPaths.add(url);\n                        // redirect target is the node providing the\n                        // sling:vanityPath\n                        // property (or its parent if the node is called\n                        // jcr:content)\n                        final String redirect;\n                        if (resource.getName().equals(\"jcr:content\")) {\n                            redirect = resource.getParent().getPath();\n                        } else {\n                            redirect = resource.getPath();\n                        }\n\n                        // whether the target is attained by a 302/FOUND or by an\n                        // internal redirect is defined by the sling:redirect\n                        // property\n                        final int status = props.get(\"sling:redirect\", false) ? props.get(\n                                        PROP_REDIRECT_EXTERNAL_REDIRECT_STATUS, HttpServletResponse.SC_FOUND)\n                                        : -1;\n\n                        final String checkPath = result[1];\n                        // 1. entry with exact match\n                        this.addEntry(entryMap, checkPath, new MapEntry(url + \"$\", status, false, redirect + \".html\"));\n\n                        // 2. entry with match supporting selectors and extension\n                        this.addEntry(entryMap, checkPath, new MapEntry(url + \"(\\\\..*)\", status, false, redirect + \"$1\"));\n\n                        // 3. keep the path to return\n                        targetPaths.add(redirect);\n                    }\n                }\n            }\n        }\n        return targetPaths;\n    }","id":83492,"modified_method":"/**\n     * Load vanity paths Search for all nodes inheriting the sling:VanityPath\n     * mixin\n     */\n    private Collection<String> loadVanityPaths(final ResourceResolver resolver, final Map<String, List<MapEntry>> entryMap) {\n        // sling:VanityPath (uppercase V) is the mixin name\n        // sling:vanityPath (lowercase) is the property name\n        final Set<String> targetPaths = new HashSet<String>();\n        final String queryString = \"SELECT sling:vanityPath, sling:redirect, sling:redirectStatus FROM sling:VanityPath WHERE sling:vanityPath IS NOT NULL ORDER BY sling:vanityOrder DESC\";\n        final Iterator<Resource> i = resolver.findResources(queryString, \"sql\");\n\n        final Set<String> processedVanityPaths = new HashSet<String>();\n\n        while (i.hasNext()) {\n            final Resource resource = i.next();\n\n            // ignore system tree\n            if (resource.getPath().startsWith(JCR_SYSTEM_PREFIX)) {\n                log.debug(\"loadVanityPaths: Ignoring {}\", resource);\n                continue;\n            }\n\n            // require properties\n            final ValueMap props = resource.adaptTo(ValueMap.class);\n            if (props == null) {\n                log.debug(\"loadVanityPaths: Ignoring {} without properties\", resource);\n                continue;\n            }\n\n            // url is ignoring scheme and host.port and the path is\n            // what is stored in the sling:vanityPath property\n            final String[] pVanityPaths = props.get(\"sling:vanityPath\", new String[0]);\n            for (final String pVanityPath : pVanityPaths) {\n                final String[] result = this.getVanityPathDefinition(pVanityPath);\n                if (result != null) {\n                    final String url = result[0] + result[1];\n\n                    if ( !processedVanityPaths.contains(url) ) {\n                        processedVanityPaths.add(url);\n                        // redirect target is the node providing the\n                        // sling:vanityPath\n                        // property (or its parent if the node is called\n                        // jcr:content)\n                        final Resource redirectTarget;\n                        if (resource.getName().equals(\"jcr:content\")) {\n                            redirectTarget = resource.getParent();\n                        } else {\n                            redirectTarget = resource;\n                        }\n                        final String redirect = redirectTarget.getPath();\n                        final String redirectName = redirectTarget.getName();\n\n                        // whether the target is attained by a 302/FOUND or by an\n                        // internal redirect is defined by the sling:redirect\n                        // property\n                        final int status = props.get(\"sling:redirect\", false) ? props.get(\n                                        PROP_REDIRECT_EXTERNAL_REDIRECT_STATUS, HttpServletResponse.SC_FOUND)\n                                        : -1;\n\n                        final String checkPath = result[1];\n\n                        if (redirectName.indexOf('.') > -1) {\n                            // 1. entry with exact match\n                            this.addEntry(entryMap, checkPath, new MapEntry(url + \"$\", status, false, redirect));\n\n                            final int idx = redirectName.lastIndexOf('.');\n                            final String extension = redirectName.substring(idx + 1);\n\n                            // 2. entry with extension\n                            this.addEntry(entryMap, checkPath, new MapEntry(url + \"\\\\.\" + extension, status, false, redirect));\n                        } else {\n                            // 1. entry with exact match\n                            this.addEntry(entryMap, checkPath, new MapEntry(url + \"$\", status, false, redirect + \".html\"));\n\n                            // 2. entry with match supporting selectors and extension\n                            this.addEntry(entryMap, checkPath, new MapEntry(url + \"(\\\\..*)\", status, false, redirect + \"$1\"));\n                        }\n                        // 3. keep the path to return\n                        targetPaths.add(redirect);\n                    }\n                }\n            }\n        }\n        return targetPaths;\n    }","commit_id":"bb7008845bb2f776b91ac169c98824e8e13637e2","url":"https://github.com/apache/sling"},{"original_method":"@Override\n  public void add(OIdentifiable identifiable) {\n    addEntry(identifiable);\n\n    size++;\n    contentWasChanged = true;\n\n    fireCollectionChangedEvent(\n        new OMultiValueChangeEvent<OIdentifiable, OIdentifiable>(OMultiValueChangeEvent.OChangeType.ADD, identifiable,\n            identifiable));\n  }","id":83493,"modified_method":"@Override\n  public void add(final OIdentifiable identifiable) {\n    if (identifiable == null)\n      throw new NullPointerException(\"Impossible to add a null identifiable in a ridbag\");\n\n    addEntry(identifiable);\n\n    size++;\n    contentWasChanged = true;\n\n    fireCollectionChangedEvent(\n        new OMultiValueChangeEvent<OIdentifiable, OIdentifiable>(OMultiValueChangeEvent.OChangeType.ADD, identifiable,\n            identifiable));\n  }","commit_id":"132b83277ff8ab07edf9a79aa029a92bfb3b80ae","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void addEntry(final OIdentifiable identifiable) {\n    if (identifiable == null)\n      throw new NullPointerException(\"Impossible to add a null identifiable in a ridbag\");\n    if (entries.length == entriesLength) {\n      if (entriesLength == 0) {\n        final int cfgValue = OGlobalConfiguration.RID_BAG_EMBEDDED_TO_SBTREEBONSAI_THRESHOLD.getValueAsInteger();\n        entries = new Object[cfgValue > 0 ? Math.min(cfgValue, 40) : 40];\n      } else {\n        final Object[] oldEntries = entries;\n        entries = new Object[entries.length << 1];\n        System.arraycopy(oldEntries, 0, entries, 0, oldEntries.length);\n      }\n    }\n    if (this.owner != null)\n      ORecordInternal.track(this.owner, identifiable);\n\n    entries[entriesLength] = identifiable;\n    entriesLength++;\n  }","id":83494,"modified_method":"private void addEntry(final OIdentifiable identifiable) {\n    if (entries.length == entriesLength) {\n      if (entriesLength == 0) {\n        final int cfgValue = OGlobalConfiguration.RID_BAG_EMBEDDED_TO_SBTREEBONSAI_THRESHOLD.getValueAsInteger();\n        entries = new Object[cfgValue > 0 ? Math.min(cfgValue, 40) : 40];\n      } else {\n        final Object[] oldEntries = entries;\n        entries = new Object[entries.length << 1];\n        System.arraycopy(oldEntries, 0, entries, 0, oldEntries.length);\n      }\n    }\n    if (this.owner != null)\n      ORecordInternal.track(this.owner, identifiable);\n\n    entries[entriesLength] = identifiable;\n    entriesLength++;\n  }","commit_id":"132b83277ff8ab07edf9a79aa029a92bfb3b80ae","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public int serialize(byte[] stream, int offset, UUID ownerUuid) {\n    if (!deserialized) {\n      System.arraycopy(serializedContent, 0, stream, offset, serializedContent.length);\n\n      if (contentWasChanged) {\n        OIntegerSerializer.INSTANCE.serializeLiteral(size, stream, offset);\n        offset += serializedContent.length;\n      } else {\n        offset += serializedContent.length;\n        return offset;\n      }\n\n    } else {\n      OIntegerSerializer.INSTANCE.serializeLiteral(size, stream, offset);\n      offset += OIntegerSerializer.INT_SIZE;\n    }\n\n    final int totEntries = entries.length;\n    for (int i = 0; i < totEntries; ++i) {\n      final Object entry = entries[i];\n      if (entry instanceof OIdentifiable) {\n        OIdentifiable link = (OIdentifiable) entry;\n        if (link.getIdentity().isTemporary())\n          link = link.getRecord();\n\n        OLinkSerializer.INSTANCE.serialize(link, stream, offset);\n        offset += OLinkSerializer.RID_SIZE;\n      }\n    }\n\n    return offset;\n  }","id":83495,"modified_method":"@Override\n  public int serialize(byte[] stream, int offset, UUID ownerUuid) {\n    if (!deserialized) {\n      System.arraycopy(serializedContent, 0, stream, offset, serializedContent.length);\n\n      if (contentWasChanged) {\n        OIntegerSerializer.INSTANCE.serializeLiteral(size, stream, offset);\n        offset += serializedContent.length;\n      } else {\n        offset += serializedContent.length;\n        return offset;\n      }\n\n    } else {\n      OIntegerSerializer.INSTANCE.serializeLiteral(size, stream, offset);\n      offset += OIntegerSerializer.INT_SIZE;\n    }\n\n    final int totEntries = entries.length;\n    for (int i = 0; i < totEntries; ++i) {\n      final Object entry = entries[i];\n      if (entry instanceof OIdentifiable) {\n        OIdentifiable link = (OIdentifiable) entry;\n        final ORID rid = link.getIdentity();\n        if (link.getIdentity().isTemporary())\n          link = link.getRecord();\n\n        if( link == null )\n          throw new OSerializationException(\"Found null entry in ridbag with rid=\"+rid);\n\n        OLinkSerializer.INSTANCE.serialize(link, stream, offset);\n        offset += OLinkSerializer.RID_SIZE;\n      }\n    }\n\n    return offset;\n  }","commit_id":"132b83277ff8ab07edf9a79aa029a92bfb3b80ae","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void doDeserialization() {\n    if (deserialized)\n      return;\n\n    int offset = 0;\n    int entriesSize = OIntegerSerializer.INSTANCE.deserializeLiteral(serializedContent, offset);\n    offset += OIntegerSerializer.INT_SIZE;\n\n    for (int i = 0; i < entriesSize; i++) {\n      ORID rid = OLinkSerializer.INSTANCE.deserialize(serializedContent, offset);\n      offset += OLinkSerializer.RID_SIZE;\n\n      OIdentifiable identifiable;\n      if (rid.isTemporary())\n        identifiable = rid.getRecord();\n      else\n        identifiable = rid;\n\n      addEntry(identifiable);\n    }\n\n    deserialized = true;\n  }","id":83496,"modified_method":"private void doDeserialization() {\n    if (deserialized)\n      return;\n\n    int offset = 0;\n    int entriesSize = OIntegerSerializer.INSTANCE.deserializeLiteral(serializedContent, offset);\n    offset += OIntegerSerializer.INT_SIZE;\n\n    for (int i = 0; i < entriesSize; i++) {\n      ORID rid = OLinkSerializer.INSTANCE.deserialize(serializedContent, offset);\n      offset += OLinkSerializer.RID_SIZE;\n\n      OIdentifiable identifiable;\n      if (rid.isTemporary())\n        identifiable = rid.getRecord();\n      else\n        identifiable = rid;\n\n      if( identifiable == null )\n        OLogManager.instance().warn(this, \"Found null reference during ridbag deserialization (rid=%s)\", rid);\n      else\n        addEntry(identifiable);\n    }\n\n    deserialized = true;\n  }","commit_id":"132b83277ff8ab07edf9a79aa029a92bfb3b80ae","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public CCCreateLesson() {\n    super(EduNames.LESSON_TITLED, TITLE, PlatformIcons.DIRECTORY_CLOSED_ICON);\n  }","id":83497,"modified_method":"public CCCreateLesson() {\n    super(EduNames.LESSON_TITLED, TITLE, EducationalIcons.Lesson);\n  }","commit_id":"a78b93e36104ed7b184d03a7cd9a696cce6bdf85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CCCreateTask() {\n    super(EduNames.TASK_TITLED, TITLE, PlatformIcons.DIRECTORY_CLOSED_ICON);\n  }","id":83498,"modified_method":"public CCCreateTask() {\n    super(EduNames.TASK_TITLED, TITLE, EducationalIcons.Task);\n  }","commit_id":"a78b93e36104ed7b184d03a7cd9a696cce6bdf85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void updateImpl(PresentationData data) {\n    //TODO:change presentable name for files with suffix _answer\n\n    String valueName = myValue.getName();\n    final CCProjectService service = CCProjectService.getInstance(myProject);\n    final Course course = service.getCourse();\n    if (course == null) return;\n    if (myProject.getBaseDir().equals(myValue.getVirtualFile())) {\n      data.clearText();\n      data.addText(valueName, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      data.addText(\" (\" + course.getName() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      return;\n    }\n    final Lesson lesson = course.getLesson(valueName);\n    if (lesson != null) {\n      data.clearText();\n      data.addText(valueName, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      data.addText(\" (\" + lesson.getName() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      return;\n    }\n    else {\n      final PsiDirectory parentDir = myValue.getParentDirectory();\n      if (parentDir != null) {\n        final Lesson parentLesson = course.getLesson(parentDir.getName());\n        if (parentLesson != null) {\n          final Task task = parentLesson.getTask(valueName);\n          if (task != null) {\n            data.clearText();\n            data.addText(valueName, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n            data.addText(\" (\" + task.getName() + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n            return;\n          }\n        }\n      }\n    }\n    data.setPresentableText(valueName);\n  }","id":83499,"modified_method":"@Override\n  protected void updateImpl(PresentationData data) {\n    String valueName = myValue.getName();\n    final CCProjectService service = CCProjectService.getInstance(myProject);\n    final Course course = service.getCourse();\n    if (course == null) return;\n    if (myProject.getBaseDir().equals(myValue.getVirtualFile())) {\n      data.clearText();\n      data.addText(course.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      data.addText(\" (\" + valueName + \")\", SimpleTextAttributes.GRAYED_ATTRIBUTES);\n      return;\n    }\n    final Lesson lesson = course.getLesson(valueName);\n    if (lesson != null) {\n      data.clearText();\n      data.setIcon(EducationalIcons.Lesson);\n      data.addText(lesson.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n      return;\n    }\n    else {\n      final PsiDirectory parentDir = myValue.getParentDirectory();\n      if (parentDir != null) {\n        final Lesson parentLesson = course.getLesson(parentDir.getName());\n        if (parentLesson != null) {\n          final Task task = parentLesson.getTask(valueName);\n          if (task != null) {\n            data.clearText();\n            data.setIcon(EducationalIcons.Task);\n            data.addText(task.getName(), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n            return;\n          }\n        }\n      }\n    }\n    data.setPresentableText(valueName);\n  }","commit_id":"a78b93e36104ed7b184d03a7cd9a696cce6bdf85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setStudyAttributes(Lesson lesson, PresentationData data, String additionalName) {\n    StudyStatus taskStatus = StudyTaskManager.getInstance(myProject).getStatus(lesson);\n    switch (taskStatus) {\n      case Unchecked: {\n        updatePresentation(data, additionalName, JBColor.BLACK, InteractiveLearningIcons.Lesson);\n        break;\n      }\n      case Solved: {\n        updatePresentation(data, additionalName, new JBColor(new Color(0, 134, 0), new Color(98, 150, 85)), InteractiveLearningIcons.LessonCompl);\n        break;\n      }\n      case Failed: {\n        updatePresentation(data, additionalName, JBColor.RED, InteractiveLearningIcons.Lesson);\n      }\n    }\n  }","id":83500,"modified_method":"private void setStudyAttributes(Lesson lesson, PresentationData data, String additionalName) {\n    StudyStatus taskStatus = StudyTaskManager.getInstance(myProject).getStatus(lesson);\n    switch (taskStatus) {\n      case Unchecked: {\n        updatePresentation(data, additionalName, JBColor.BLACK, EducationalIcons.Lesson);\n        break;\n      }\n      case Solved: {\n        updatePresentation(data, additionalName, new JBColor(new Color(0, 134, 0), new Color(98, 150, 85)), InteractiveLearningIcons.LessonCompl);\n        break;\n      }\n      case Failed: {\n        updatePresentation(data, additionalName, JBColor.RED, EducationalIcons.Lesson);\n      }\n    }\n  }","commit_id":"a78b93e36104ed7b184d03a7cd9a696cce6bdf85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setStudyAttributes(Task task, PresentationData data, String additionalName) {\n    StudyStatus taskStatus = StudyTaskManager.getInstance(myProject).getStatus(task);\n    switch (taskStatus) {\n      case Unchecked: {\n        updatePresentation(data, additionalName, JBColor.BLACK, InteractiveLearningIcons.Task);\n        break;\n      }\n      case Solved: {\n        updatePresentation(data, additionalName, new JBColor(new Color(0, 134, 0), new Color(98, 150, 85)),\n                           InteractiveLearningIcons.TaskCompl);\n        break;\n      }\n      case Failed: {\n        updatePresentation(data, additionalName, JBColor.RED, InteractiveLearningIcons.TaskProbl);\n      }\n    }\n  }","id":83501,"modified_method":"private void setStudyAttributes(Task task, PresentationData data, String additionalName) {\n    StudyStatus taskStatus = StudyTaskManager.getInstance(myProject).getStatus(task);\n    switch (taskStatus) {\n      case Unchecked: {\n        updatePresentation(data, additionalName, JBColor.BLACK, EducationalIcons.Task);\n        break;\n      }\n      case Solved: {\n        updatePresentation(data, additionalName, new JBColor(new Color(0, 134, 0), new Color(98, 150, 85)),\n                           InteractiveLearningIcons.TaskCompl);\n        break;\n      }\n      case Failed: {\n        updatePresentation(data, additionalName, JBColor.RED, InteractiveLearningIcons.TaskProbl);\n      }\n    }\n  }","commit_id":"a78b93e36104ed7b184d03a7cd9a696cce6bdf85","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void init(ExtendletConfig config) {\n\t\t_webctx = config.getExtendletContext();\n\t\t_cache = new ResourceCache(new DSPLoader(), 131);\n\t\t_cache.setMaxSize(1000).setLifetime(60*60*1000); //1hr\n\t\t_cache.setCheckPeriod(60*60*1000); //1hr\n\t}","id":83502,"modified_method":"public void init(ExtendletConfig config) {\n\t\t_webctx = config.getExtendletContext();\n\t\t_cache = new ResourceCache(new DSPLoader(), 131);\n\t\t_cache.setMaxSize(1000);\n\t\t_cache.setLifetime(60*60*1000); //1hr\n\t\t_cache.setCheckPeriod(60*60*1000); //1hr\n\t}","commit_id":"0adfff283fd9dc9f1192c5a150ba288f80f1513d","url":"https://github.com/zkoss/zk"},{"original_method":"private final ResourceCache getCache() {\n\t\tResourceCache cache = (ResourceCache)_ctx.getAttribute(ATTR_PAGE_CACHE);\n\t\tif (cache == null) {\n\t\t\tsynchronized (InterpreterServlet.class) {\n\t\t\t\tcache = (ResourceCache)_ctx.getAttribute(ATTR_PAGE_CACHE);\n\t\t\t\tif (cache == null) {\n\t\t\t\t\tcache = new ResourceCache(new MyLoader(), 29);\n\t\t\t\t\tcache.setMaxSize(500).setLifetime(60*60*1000); //1hr\n\t\t\t\t\t_ctx.setAttribute(ATTR_PAGE_CACHE, cache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t}","id":83503,"modified_method":"private final ResourceCache getCache() {\n\t\tResourceCache cache = (ResourceCache)_ctx.getAttribute(ATTR_PAGE_CACHE);\n\t\tif (cache == null) {\n\t\t\tsynchronized (InterpreterServlet.class) {\n\t\t\t\tcache = (ResourceCache)_ctx.getAttribute(ATTR_PAGE_CACHE);\n\t\t\t\tif (cache == null) {\n\t\t\t\t\tcache = new ResourceCache(new MyLoader(), 29);\n\t\t\t\t\tcache.setMaxSize(500);\n\t\t\t\t\tcache.setLifetime(60*60*1000); //1hr\n\t\t\t\t\t_ctx.setAttribute(ATTR_PAGE_CACHE, cache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t}","commit_id":"0adfff283fd9dc9f1192c5a150ba288f80f1513d","url":"https://github.com/zkoss/zk"},{"original_method":"private static final ResourceCache getCache(ServletContext ctx) {\n\t\tResourceCache cache = (ResourceCache)ctx.getAttribute(ATTR_PAGE_CACHE);\n\t\tif (cache == null) {\n\t\t\tsynchronized (ResourceCaches.class) {\n\t\t\t\tcache = (ResourceCache)ctx.getAttribute(ATTR_PAGE_CACHE);\n\t\t\t\tif (cache == null) {\n\t\t\t\t\tcache = new ResourceCache(new ContentLoader(ctx), 29);\n\t\t\t\t\tcache.setMaxSize(500).setLifetime(60*60*1000); //1hr\n\t\t\t\t\tctx.setAttribute(ATTR_PAGE_CACHE, cache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t}","id":83504,"modified_method":"private static final ResourceCache getCache(ServletContext ctx) {\n\t\tResourceCache cache = (ResourceCache)ctx.getAttribute(ATTR_PAGE_CACHE);\n\t\tif (cache == null) {\n\t\t\tsynchronized (ResourceCaches.class) {\n\t\t\t\tcache = (ResourceCache)ctx.getAttribute(ATTR_PAGE_CACHE);\n\t\t\t\tif (cache == null) {\n\t\t\t\t\tcache = new ResourceCache(new ContentLoader(ctx), 29);\n\t\t\t\t\tcache.setMaxSize(500);\n\t\t\t\t\tcache.setLifetime(60*60*1000); //1hr\n\t\t\t\t\tctx.setAttribute(ATTR_PAGE_CACHE, cache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t}","commit_id":"0adfff283fd9dc9f1192c5a150ba288f80f1513d","url":"https://github.com/zkoss/zk"},{"original_method":"/** Locates a page based on the specified Locale. It never returns null.\n\t *\n\t * <p>If an URI contains \"*\", it will be replaced with a proper Locale.\n\t * For example, if the current Locale is zh_TW and the resource is\n\t * named \"ab*.cd\", then it searches \"ab_zh_TW.cd\", \"ab_zh.cd\" and\n\t * then \"ab.cd\", until any of them is found.\n\t *\n\t * <blockquote>Note: \"*\" must be right before \".\", or the last character.\n\t * For example, \"ab*.cd\" and \"ab*\" are both correct, while\n\t * \"ab*cd\" and \"ab*\\/cd\" are ignored.<\/blockquote>\n\t *\n\t * <p>If an URI contains two \"*\", the first \"*\" will be replaced with\n\t * a browser code and the second with a proper locale.\n\t * The browser code depends on what browser\n\t * the user are used to visit the web site.\n\t * Currently, the code for Internet Explorer is \"ie\", Safari is \"saf\",\n\t * Opera is \"opr\" and all others are \"moz\".\n\t * Thus, in the above example, if the resource is named \"ab**.cd\"\n\t * and Firefox is used, then it searches \"abmoz_zh_TW.cd\", \"abmoz_zh.cd\"\n\t * and then \"abmoz.cd\", until any of them is found.\n\t *\n\t * <p>Note: it assumes the path as name_lang_cn_var.ext where\n\t * \".ext\" is optional. Example, my_zh_tw.html.jsp.\n\t *\n\t * <p>Note: unlike {@link Encodes#encodeURL(ServletContext, ServletRequest, ServletResponse, String)},\n\t * it always locates the Locale, without handling \"*\".\n\t *\n\t * @param ctx the servlet context to locate pages\n\t * @param pgpath the page path excluding servlet name. It is OK to have\n\t * the query string. It might contain \"*\" for current browser code and Locale.\n\t * @param locator the locator used to locate resource. If null, ctx\n\t * is assumed.\n\t * @return pgpath if the original one matches; others if locale matches;\n\t * never null\n\t */\n\tpublic static final String locate(ServletContext ctx,\n\tServletRequest request, String pgpath, Locator locator)\n\tthrows ServletException {\n\t\tif (isUniversalURL(pgpath))\n\t\t\treturn pgpath;\n\n\t\tfinal int jquest = pgpath.indexOf('?');\n\t\tfinal int f = pgpath.indexOf('*');\n\t\tif (f < 0 || (jquest >= 0 && f > jquest)) return pgpath;\n\t\t\t//optimize the case that no \"*\" at all\n\n\t\tfinal String qstr;\n\t\tif (jquest >= 0) {\n\t\t\tqstr = pgpath.substring(jquest);\n\t\t\tpgpath = pgpath.substring(0, jquest);\n\t\t} else {\n\t\t\tqstr = null;\n\t\t}\n\n\t\t//by browser?\n\t\tint l = pgpath.lastIndexOf('*');\n\t\tif (l > f) { //two '*'\n\t\t\tfinal String bc = Servlets.isExplorer(request) ? \"ie\":\n\t\t\t\tServlets.isSafari(request) ? \"saf\":\n\t\t\t\tServlets.isOpera(request) ? \"opr\": \"moz\";\n\t\t\tl += bc.length() - 1;\n\t\t\tpgpath = pgpath.substring(0, f) + bc + pgpath.substring(f + 1);\n\t\t}\n\n\t\t//remove \"*\"\n\t\tpgpath = pgpath.substring(0, l) + pgpath.substring(l + 1); //remove\n\n\t\t//by locale? 1) before the first dot, 2) the last char if no dot\n\t\tboolean byLocale = l == pgpath.length()\n\t\t|| (pgpath.charAt(l) == '.' && pgpath.indexOf('/', l + 1) < 0);\n\t\tif (byLocale) {\n\t\t\t//make sure no dot before it\n\t\t\tfor (int j = l; --j >= 0;) {\n\t\t\t\tfinal char cc = pgpath.charAt(j);\n\t\t\t\tif (cc == '.') {\n\t\t\t\t\tbyLocale = false;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (cc == '/') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!byLocale)\n\t\t\treturn qstr != null ? pgpath + qstr: pgpath; //not by locale\n\n\n\t\tfinal String PGPATH_CACHE = \"s_pgpath_cache\";\n\t\tMap map = (Map)ctx.getAttribute(PGPATH_CACHE);\n\t\tif (map == null) {\n\t\t\tmap = Collections.synchronizedMap( //10 min\n\t\t\t\tnew CacheMap(53).setMaxSize(500).setLifetime(10*60*1000));\n\t\t\tctx.setAttribute(PGPATH_CACHE, map);\n\t\t}\n\n\t\tfinal Locale locale = Locales.getCurrent();\n\t\tfinal URIIndex index = new URIIndex(pgpath, locale);\n\n\t\tString uri = (String)map.get(index);\n\t\tif (uri == null) {\n\t\t\tfinal Locators.URLLocation loc =\n\t\t\t\tLocators.locate(pgpath, locale,\n\t\t\t\t\tlocator != null ? locator: new ServletContextLocator(ctx));\n\t\t\turi = loc != null ? loc.file: pgpath;\n\t\t\tmap.put(index, uri);\n\t\t}\n\n\t\treturn qstr != null ? uri + qstr: uri;\n\t}","id":83505,"modified_method":"/** Locates a page based on the specified Locale. It never returns null.\n\t *\n\t * <p>If an URI contains \"*\", it will be replaced with a proper Locale.\n\t * For example, if the current Locale is zh_TW and the resource is\n\t * named \"ab*.cd\", then it searches \"ab_zh_TW.cd\", \"ab_zh.cd\" and\n\t * then \"ab.cd\", until any of them is found.\n\t *\n\t * <blockquote>Note: \"*\" must be right before \".\", or the last character.\n\t * For example, \"ab*.cd\" and \"ab*\" are both correct, while\n\t * \"ab*cd\" and \"ab*\\/cd\" are ignored.<\/blockquote>\n\t *\n\t * <p>If an URI contains two \"*\", the first \"*\" will be replaced with\n\t * a browser code and the second with a proper locale.\n\t * The browser code depends on what browser\n\t * the user are used to visit the web site.\n\t * Currently, the code for Internet Explorer is \"ie\", Safari is \"saf\",\n\t * Opera is \"opr\" and all others are \"moz\".\n\t * Thus, in the above example, if the resource is named \"ab**.cd\"\n\t * and Firefox is used, then it searches \"abmoz_zh_TW.cd\", \"abmoz_zh.cd\"\n\t * and then \"abmoz.cd\", until any of them is found.\n\t *\n\t * <p>Note: it assumes the path as name_lang_cn_var.ext where\n\t * \".ext\" is optional. Example, my_zh_tw.html.jsp.\n\t *\n\t * <p>Note: unlike {@link Encodes#encodeURL(ServletContext, ServletRequest, ServletResponse, String)},\n\t * it always locates the Locale, without handling \"*\".\n\t *\n\t * @param ctx the servlet context to locate pages\n\t * @param pgpath the page path excluding servlet name. It is OK to have\n\t * the query string. It might contain \"*\" for current browser code and Locale.\n\t * @param locator the locator used to locate resource. If null, ctx\n\t * is assumed.\n\t * @return pgpath if the original one matches; others if locale matches;\n\t * never null\n\t */\n\tpublic static final String locate(ServletContext ctx,\n\tServletRequest request, String pgpath, Locator locator)\n\tthrows ServletException {\n\t\tif (isUniversalURL(pgpath))\n\t\t\treturn pgpath;\n\n\t\tfinal int jquest = pgpath.indexOf('?');\n\t\tfinal int f = pgpath.indexOf('*');\n\t\tif (f < 0 || (jquest >= 0 && f > jquest)) return pgpath;\n\t\t\t//optimize the case that no \"*\" at all\n\n\t\tfinal String qstr;\n\t\tif (jquest >= 0) {\n\t\t\tqstr = pgpath.substring(jquest);\n\t\t\tpgpath = pgpath.substring(0, jquest);\n\t\t} else {\n\t\t\tqstr = null;\n\t\t}\n\n\t\t//by browser?\n\t\tint l = pgpath.lastIndexOf('*');\n\t\tif (l > f) { //two '*'\n\t\t\tfinal String bc = Servlets.isExplorer(request) ? \"ie\":\n\t\t\t\tServlets.isSafari(request) ? \"saf\":\n\t\t\t\tServlets.isOpera(request) ? \"opr\": \"moz\";\n\t\t\tl += bc.length() - 1;\n\t\t\tpgpath = pgpath.substring(0, f) + bc + pgpath.substring(f + 1);\n\t\t}\n\n\t\t//remove \"*\"\n\t\tpgpath = pgpath.substring(0, l) + pgpath.substring(l + 1); //remove\n\n\t\t//by locale? 1) before the first dot, 2) the last char if no dot\n\t\tboolean byLocale = l == pgpath.length()\n\t\t|| (pgpath.charAt(l) == '.' && pgpath.indexOf('/', l + 1) < 0);\n\t\tif (byLocale) {\n\t\t\t//make sure no dot before it\n\t\t\tfor (int j = l; --j >= 0;) {\n\t\t\t\tfinal char cc = pgpath.charAt(j);\n\t\t\t\tif (cc == '.') {\n\t\t\t\t\tbyLocale = false;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (cc == '/') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!byLocale)\n\t\t\treturn qstr != null ? pgpath + qstr: pgpath; //not by locale\n\n\n\t\tfinal String PGPATH_CACHE = \"s_pgpath_cache\";\n\t\tMap map = (Map)ctx.getAttribute(PGPATH_CACHE);\n\t\tif (map == null) {\n\t\t\tmap = Collections.synchronizedMap( //10 min\n\t\t\t\tnew CacheMap(500, 10*60*1000));\n\t\t\tctx.setAttribute(PGPATH_CACHE, map);\n\t\t}\n\n\t\tfinal Locale locale = Locales.getCurrent();\n\t\tfinal URIIndex index = new URIIndex(pgpath, locale);\n\n\t\tString uri = (String)map.get(index);\n\t\tif (uri == null) {\n\t\t\tfinal Locators.URLLocation loc =\n\t\t\t\tLocators.locate(pgpath, locale,\n\t\t\t\t\tlocator != null ? locator: new ServletContextLocator(ctx));\n\t\t\turi = loc != null ? loc.file: pgpath;\n\t\t\tmap.put(index, uri);\n\t\t}\n\n\t\treturn qstr != null ? uri + qstr: uri;\n\t}","commit_id":"0adfff283fd9dc9f1192c5a150ba288f80f1513d","url":"https://github.com/zkoss/zk"},{"original_method":"@Before\n  public void setupServer() throws Exception {\n    server = new InMemoryZookeeper();\n  }","id":83506,"modified_method":"@Before\n  public void setupServer() throws Exception {\n    server = new InMemoryZookeeper();\n    System.out.println(\"Server started on \" + server.getConnectionString());\n  }","commit_id":"36f226c7479ee894b6647507a846b8724da78df1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n    public void testRandom() throws Exception {\n      ServiceDiscoveryClient client = null;\n      try {\n        client = new ServiceDiscoveryClient(server.getConnectionString());\n        ServiceDiscoveryClient.ServicePayload payload = new ServiceDiscoveryClient.ServicePayload();\n        payload.add(\"A1\", \"1\");\n        payload.add(\"A2\", \"2\");\n        client.register(\"flow-manager\", \"localhost\",8080, payload);\n        client.register(\"flow-manager\", \"localhost\",8081, payload);\n        int count = client.getProviderCount(\"flow-manager\");\n        Assert.assertTrue(count == 2);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n        ProviderStrategy<ServiceDiscoveryClient.ServicePayload> strategy =\n          new RandomStrategy<ServiceDiscoveryClient.ServicePayload>();\n        ServiceDiscoveryClient.ServiceProvider provider = client.getServiceProvider(\"flow-manager\");\n        int[] stats = new int[] { 0, 0};\n        int trials = 10000;\n        for(int i = 0; i < trials; ++i) {\n          ServiceInstance<ServiceDiscoveryClient.ServicePayload> instance = strategy.getInstance(provider);\n          int k = instance.getPort() - 8080;\n          stats[k]++;\n        }\n        int sum = stats[0] + stats[1];\n        int diff = Math.abs(stats[0] - stats[1]);\n        Assert.assertTrue(diff < (trials*0.20));  /** is 20% tolerance ok */\n        Assert.assertTrue(sum == 10000);\n      } finally {\n        if(client != null) {\n          Closeables.closeQuietly(client);\n        }\n      }\n    }","id":83507,"modified_method":"@Test\n    public void testRandom() throws Exception {\n      ServiceDiscoveryClient client = null;\n      try {\n        client = new ServiceDiscoveryClient(server.getConnectionString());\n        ServicePayload payload = new ServicePayload();\n        payload.add(\"A1\", \"1\");\n        payload.add(\"A2\", \"2\");\n        client.register(\"flow-manager\", \"localhost\",8080, payload);\n        client.register(\"flow-manager\", \"localhost\",8081, payload);\n        int count = client.getProviderCount(\"flow-manager\");\n        Assert.assertTrue(count == 2);\n        try {\n          Thread.sleep(2000);\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n        ProviderStrategy<ServicePayload> strategy =\n          new RandomStrategy<ServicePayload>();\n        ServiceDiscoveryClient.ServiceProvider provider = client.getServiceProvider(\"flow-manager\");\n        int[] stats = new int[] { 0, 0};\n        int trials = 10000;\n        for(int i = 0; i < trials; ++i) {\n          ServiceInstance<ServicePayload> instance = strategy.getInstance(provider);\n          int k = instance.getPort() - 8080;\n          stats[k]++;\n        }\n        int sum = stats[0] + stats[1];\n        int diff = Math.abs(stats[0] - stats[1]);\n        Assert.assertTrue(diff < (trials*0.20));  /** is 20% tolerance ok */\n        Assert.assertTrue(sum == 10000);\n      } finally {\n        if(client != null) {\n          Closeables.closeQuietly(client);\n        }\n      }\n    }","commit_id":"36f226c7479ee894b6647507a846b8724da78df1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testRegistration() throws Exception {\n    ServiceDiscoveryClient client = new ServiceDiscoveryClient(server.getConnectionString());\n    try {\n      ServiceDiscoveryClient.ServicePayload payload =\n        new ServiceDiscoveryClient.ServicePayload();\n      payload.add(\"A1\", \"1\");\n      payload.add(\"A1\", \"2\");\n\n      client.register(\"flow-manager\", \"localhost\", 8080, payload);\n      client.register(\"flow-manager\", \"localhost\",8081, payload);\n      client.register(\"flow-manager\", \"localhost\",8082, payload);\n      int count = client.getProviderCount(\"flow-manager\");\n      Assert.assertEquals(3, count);\n      client.register(\"flow-manager\", \"localhost\",8083, payload);\n      Assert.assertEquals(4, client.getProviderCount(\"flow-manager\"));\n\n      // Same should not increase count, but it does, so we have to be careful.\n      client.register(\"flow-manager\", \"localhost\",8083, payload);\n      Assert.assertEquals(5, client.getProviderCount(\"flow-manager\"));\n    } finally {\n      client.close();\n    }\n  }","id":83508,"modified_method":"@Test\n  public void testRegistration() throws Exception {\n    ServiceDiscoveryClient client = new ServiceDiscoveryClient(server.getConnectionString());\n    try {\n      ServicePayload payload = new ServicePayload();\n      payload.add(\"A1\", \"1\");\n      payload.add(\"A1\", \"2\");\n\n      client.register(\"flow-manager\", \"localhost\", 8080, payload);\n      client.register(\"flow-manager\", \"localhost\",8081, payload);\n      client.register(\"flow-manager\", \"localhost\",8082, payload);\n      int count = client.getProviderCount(\"flow-manager\");\n      Assert.assertEquals(3, count);\n      client.register(\"flow-manager\", \"localhost\",8083, payload);\n      Assert.assertEquals(4, client.getProviderCount(\"flow-manager\"));\n\n      // Same should not increase count, but it does, so we have to be careful.\n      client.register(\"flow-manager\", \"localhost\",8083, payload);\n      Assert.assertEquals(5, client.getProviderCount(\"flow-manager\"));\n    } finally {\n      client.close();\n    }\n  }","commit_id":"36f226c7479ee894b6647507a846b8724da78df1","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Deserialize a byte array into an instance\n   *\n   * @param bytes the bytes\n   * @return service instance\n   * @throws Exception any errors\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public ServiceInstance<ServiceDiscoveryClient.ServicePayload> deserialize(byte[] bytes) throws Exception {\n    ServiceInstance<ServiceDiscoveryClient.ServicePayload> payload;\n    payload = gson.fromJson(new String(bytes), ServiceInstance.class);\n    return payload;\n  }","id":83509,"modified_method":"/**\n   * Deserialize a byte array into an instance\n   *\n   * @param bytes the bytes\n   * @return service instance\n   * @throws Exception any errors\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public ServiceInstance<ServicePayload> deserialize(byte[] bytes) throws Exception {\n    return gson.fromJson(new String(bytes), ServiceInstance.class);\n  }","commit_id":"36f226c7479ee894b6647507a846b8724da78df1","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Serialize an instance into bytes\n   *\n   * @param instance the instance\n   * @return byte array representing the instance\n   * @throws Exception any errors\n   */\n  @Override\n  public byte[] serialize(ServiceInstance<ServiceDiscoveryClient.ServicePayload> instance) throws Exception {\n    return gson.toJson(instance).getBytes();\n  }","id":83510,"modified_method":"/**\n   * Serialize an instance into bytes\n   *\n   * @param instance the instance\n   * @return byte array representing the instance\n   * @throws Exception any errors\n   */\n  @Override\n  public byte[] serialize(ServiceInstance<ServicePayload> instance) throws Exception {\n    return gson.toJson(instance).getBytes();\n  }","commit_id":"36f226c7479ee894b6647507a846b8724da78df1","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<QueryResult> previewResults(QueryHandle handle)\n    throws ExploreException, HandleNotFoundException, SQLException {\n    // TODO add synchronization to this thing?\n    OperationInfo operationInfo = getOperationInfo(handle);\n    File previewFile = operationInfo.getPreviewFile();\n    if (previewFile != null) {\n      try {\n        Reader reader = new FileReader(previewFile);\n        List<QueryResult> queries;\n        try {\n          queries = GSON.fromJson(reader, new TypeToken<List<QueryResult>>() { }.getType());\n        } finally {\n          try {\n            reader.close();\n          } catch (IOException e) {\n            LOG.error(\"Could not close preview file for handle {}\", handle, e);\n            throw Throwables.propagate(e);\n          }\n        }\n        return queries;\n      } catch (FileNotFoundException e) {\n        LOG.error(\"Could not retrieve preview result file {}\", previewFile, e);\n        throw new ExploreException(e);\n      }\n    }\n\n    try {\n      // Create preview results for query\n      previewFile = new File(previewsDir, handle.getHandle());\n      FileWriter fileWriter = new FileWriter(previewFile);\n      List<QueryResult> results = nextResults(handle, PREVIEW_COUNT);\n      GSON.toJson(results, fileWriter);\n      operationInfo.setPreviewFile(previewFile);\n      fileWriter.close();\n      return results;\n    } catch (IOException e) {\n      LOG.error(\"Could not write preview results into file\", e);\n      throw new ExploreException(e);\n    }\n  }","id":83511,"modified_method":"@Override\n  public List<QueryResult> previewResults(QueryHandle handle)\n    throws ExploreException, HandleNotFoundException, SQLException {\n    // TODO add synchronization to this thing?\n    if (inactiveHandleCache.getIfPresent(handle) != null) {\n      throw new HandleNotFoundException(\"Query is inactive.\", true);\n    }\n\n    OperationInfo operationInfo = getOperationInfo(handle);\n    File previewFile = operationInfo.getPreviewFile();\n    if (previewFile != null) {\n      try {\n        Reader reader = new FileReader(previewFile);\n        try {\n          return GSON.fromJson(reader, new TypeToken<List<QueryResult>>() { }.getType());\n        } finally {\n          Closeables.closeQuietly(reader);\n        }\n      } catch (FileNotFoundException e) {\n        LOG.error(\"Could not retrieve preview result file {}\", previewFile, e);\n        throw new ExploreException(e);\n      }\n    }\n\n    FileWriter fileWriter = null;\n    try {\n      // Create preview results for query\n      previewFile = new File(previewsDir, handle.getHandle());\n      fileWriter = new FileWriter(previewFile);\n      List<QueryResult> results = nextResults(handle, PREVIEW_COUNT);\n      GSON.toJson(results, fileWriter);\n      operationInfo.setPreviewFile(previewFile);\n      return results;\n    } catch (IOException e) {\n      LOG.error(\"Could not write preview results into file\", e);\n      throw new ExploreException(e);\n    } finally {\n      if (fileWriter != null) {\n        Closeables.closeQuietly(fileWriter);\n      }\n    }\n  }","commit_id":"0dbc4a3958e65f374df9379be83e5493854cded7","url":"https://github.com/caskdata/cdap"},{"original_method":"protected BaseHiveExploreService(TransactionSystemClient txClient, DatasetFramework datasetFramework,\n                                   CConfiguration cConf, Configuration hConf, HiveConf hiveConf) {\n    this.cConf = cConf;\n    this.hConf = hConf;\n    this.hiveConf = hiveConf;\n\n    this.previewsDir = Files.createTempDir();\n\n    this.scheduledExecutorService =\n      Executors.newSingleThreadScheduledExecutor(Threads.createDaemonThreadFactory(\"explore-handle-timeout\"));\n\n    this.activeHandleCache =\n      CacheBuilder.newBuilder()\n        .expireAfterWrite(cConf.getLong(Constants.Explore.ACTIVE_OPERATION_TIMEOUT_SECS), TimeUnit.SECONDS)\n        .removalListener(new ActiveOperationRemovalHandler(this, scheduledExecutorService))\n        .build();\n    this.inactiveHandleCache =\n      CacheBuilder.newBuilder()\n        .expireAfterWrite(cConf.getLong(Constants.Explore.INACTIVE_OPERATION_TIMEOUT_SECS), TimeUnit.SECONDS)\n        .build();\n\n    this.cliService = new CLIService();\n\n    this.txClient = txClient;\n    ContextManager.saveContext(datasetFramework);\n\n    cleanupJobSchedule = cConf.getLong(Constants.Explore.CLEANUP_JOB_SCHEDULE_SECS);\n\n    LOG.info(\"Active handle timeout = {} secs\", cConf.getLong(Constants.Explore.ACTIVE_OPERATION_TIMEOUT_SECS));\n    LOG.info(\"Inactive handle timeout = {} secs\", cConf.getLong(Constants.Explore.INACTIVE_OPERATION_TIMEOUT_SECS));\n    LOG.info(\"Cleanup job schedule = {} secs\", cleanupJobSchedule);\n  }","id":83512,"modified_method":"protected BaseHiveExploreService(TransactionSystemClient txClient, DatasetFramework datasetFramework,\n                                   CConfiguration cConf, Configuration hConf, HiveConf hiveConf, File previewsDir) {\n    this.cConf = cConf;\n    this.hConf = hConf;\n    this.hiveConf = hiveConf;\n    this.previewsDir = previewsDir;\n\n    this.scheduledExecutorService =\n      Executors.newSingleThreadScheduledExecutor(Threads.createDaemonThreadFactory(\"explore-handle-timeout\"));\n\n    this.activeHandleCache =\n      CacheBuilder.newBuilder()\n        .expireAfterWrite(cConf.getLong(Constants.Explore.ACTIVE_OPERATION_TIMEOUT_SECS), TimeUnit.SECONDS)\n        .removalListener(new ActiveOperationRemovalHandler(this, scheduledExecutorService))\n        .build();\n    this.inactiveHandleCache =\n      CacheBuilder.newBuilder()\n        .expireAfterWrite(cConf.getLong(Constants.Explore.INACTIVE_OPERATION_TIMEOUT_SECS), TimeUnit.SECONDS)\n        .build();\n\n    this.cliService = new CLIService();\n\n    this.txClient = txClient;\n    ContextManager.saveContext(datasetFramework);\n\n    cleanupJobSchedule = cConf.getLong(Constants.Explore.CLEANUP_JOB_SCHEDULE_SECS);\n\n    LOG.info(\"Active handle timeout = {} secs\", cConf.getLong(Constants.Explore.ACTIVE_OPERATION_TIMEOUT_SECS));\n    LOG.info(\"Inactive handle timeout = {} secs\", cConf.getLong(Constants.Explore.INACTIVE_OPERATION_TIMEOUT_SECS));\n    LOG.info(\"Cleanup job schedule = {} secs\", cleanupJobSchedule);\n  }","commit_id":"0dbc4a3958e65f374df9379be83e5493854cded7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    protected void configure() {\n      // Current version of hive used in Singlenode is Hive 13\n      bind(ExploreService.class).annotatedWith(Names.named(\"explore.service.impl\")).to(Hive13ExploreService.class);\n      bind(ExploreService.class).toProvider(ExploreServiceProvider.class).in(Scopes.SINGLETON);\n      expose(ExploreService.class);\n\n      bind(boolean.class).annotatedWith(Names.named(\"explore.inmemory\")).toInstance(isInMemory);\n    }","id":83513,"modified_method":"@Override\n    protected void configure() {\n      // Current version of hive used in Singlenode is Hive 13\n      bind(ExploreService.class).annotatedWith(Names.named(\"explore.service.impl\")).to(Hive13ExploreService.class);\n      bind(ExploreService.class).toProvider(ExploreServiceProvider.class).in(Scopes.SINGLETON);\n      expose(ExploreService.class);\n\n      bind(boolean.class).annotatedWith(Names.named(\"explore.inmemory\")).toInstance(isInMemory);\n\n      bind(File.class).annotatedWith(Names.named(Constants.Explore.PREVIEWS_DIR_NAME))\n        .toProvider(PreviewsDirProvider.class);\n    }","commit_id":"0dbc4a3958e65f374df9379be83e5493854cded7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    protected void configure() {\n      try {\n        setupClasspath();\n\n        // Set local tmp dir to an absolute location in the twill runnable otherwise Hive complains\n        System.setProperty(HiveConf.ConfVars.LOCALSCRATCHDIR.toString(),\n                           new File(HiveConf.ConfVars.LOCALSCRATCHDIR.defaultVal).getAbsolutePath());\n        LOG.info(\"Setting {} to {}\", HiveConf.ConfVars.LOCALSCRATCHDIR.toString(),\n                 System.getProperty(HiveConf.ConfVars.LOCALSCRATCHDIR.toString()));\n\n\n        // We don't support security in Hive Server.\n        System.setProperty(\"hive.server2.authentication\", \"NONE\");\n        System.setProperty(\"hive.server2.enable.doAs\", \"false\");\n        System.setProperty(\"hive.server2.enable.impersonation\", \"false\");\n\n      } catch (Throwable e) {\n        throw Throwables.propagate(e);\n      }\n    }","id":83514,"modified_method":"@Override\n    protected void configure() {\n      try {\n        setupClasspath();\n\n        // Set local tmp dir to an absolute location in the twill runnable otherwise Hive complains\n        System.setProperty(HiveConf.ConfVars.LOCALSCRATCHDIR.toString(),\n                           new File(HiveConf.ConfVars.LOCALSCRATCHDIR.defaultVal).getAbsolutePath());\n        LOG.info(\"Setting {} to {}\", HiveConf.ConfVars.LOCALSCRATCHDIR.toString(),\n                 System.getProperty(HiveConf.ConfVars.LOCALSCRATCHDIR.toString()));\n\n\n        // We don't support security in Hive Server.\n        System.setProperty(\"hive.server2.authentication\", \"NONE\");\n        System.setProperty(\"hive.server2.enable.doAs\", \"false\");\n        System.setProperty(\"hive.server2.enable.impersonation\", \"false\");\n\n        File previewDir = Files.createTempDir();\n        LOG.info(\"Storing preview files in {}\", previewDir.getAbsolutePath());\n        bind(File.class).annotatedWith(Names.named(Constants.Explore.PREVIEWS_DIR_NAME)).toInstance(previewDir);\n      } catch (Throwable e) {\n        throw Throwables.propagate(e);\n      }\n    }","commit_id":"0dbc4a3958e65f374df9379be83e5493854cded7","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void previewResultsTest() throws Exception {\n    datasetFramework.addInstance(\"keyStructValueTable\", \"my_table_2\", DatasetProperties.EMPTY);\n    datasetFramework.addInstance(\"keyStructValueTable\", \"my_table_3\", DatasetProperties.EMPTY);\n    datasetFramework.addInstance(\"keyStructValueTable\", \"my_table_4\", DatasetProperties.EMPTY);\n    datasetFramework.addInstance(\"keyStructValueTable\", \"my_table_5\", DatasetProperties.EMPTY);\n    datasetFramework.addInstance(\"keyStructValueTable\", \"my_table_6\", DatasetProperties.EMPTY);\n\n    try {\n      QueryHandle handle = exploreService.execute(\"show tables\");\n      QueryStatus status = waitForCompletionStatus(handle, 200, TimeUnit.MILLISECONDS, 50);\n      Assert.assertEquals(QueryStatus.OpStatus.FINISHED, status.getStatus());\n\n      List<QueryResult> firstPreview = exploreService.previewResults(handle);\n      Assert.assertEquals(ImmutableList.of(\n        new QueryResult(ImmutableList.<Object>of(\"my_table\")),\n        new QueryResult(ImmutableList.<Object>of(\"my_table_2\")),\n        new QueryResult(ImmutableList.<Object>of(\"my_table_3\")),\n        new QueryResult(ImmutableList.<Object>of(\"my_table_4\")),\n        new QueryResult(ImmutableList.<Object>of(\"my_table_5\"))\n      ), firstPreview);\n\n\n      List<QueryResult> endResults = exploreService.nextResults(handle, 100);\n      Assert.assertEquals(ImmutableList.of(\n        new QueryResult(ImmutableList.<Object>of(\"my_table_6\"))\n      ), endResults);\n\n      List<QueryResult> secondPreview = exploreService.previewResults(handle);\n      Assert.assertEquals(firstPreview, secondPreview);\n\n      Assert.assertEquals(ImmutableList.of(), exploreService.nextResults(handle, 100));\n\n      try {\n        // All results are fetched, query should be inactive now\n        exploreService.previewResults(handle);\n        Assert.fail();\n      } catch (HandleNotFoundException e) {\n        // Expected exception\n      }\n\n    } finally {\n      datasetFramework.deleteInstance(\"my_table_2\");\n      datasetFramework.deleteInstance(\"my_table_3\");\n      datasetFramework.deleteInstance(\"my_table_4\");\n      datasetFramework.deleteInstance(\"my_table_5\");\n      datasetFramework.deleteInstance(\"my_table_6\");\n    }\n  }","id":83515,"modified_method":"@Test\n  public void previewResultsTest() throws Exception {\n    datasetFramework.addInstance(\"keyStructValueTable\", \"my_table_2\", DatasetProperties.EMPTY);\n    datasetFramework.addInstance(\"keyStructValueTable\", \"my_table_3\", DatasetProperties.EMPTY);\n    datasetFramework.addInstance(\"keyStructValueTable\", \"my_table_4\", DatasetProperties.EMPTY);\n    datasetFramework.addInstance(\"keyStructValueTable\", \"my_table_5\", DatasetProperties.EMPTY);\n    datasetFramework.addInstance(\"keyStructValueTable\", \"my_table_6\", DatasetProperties.EMPTY);\n\n    try {\n      QueryHandle handle = exploreService.execute(\"show tables\");\n      QueryStatus status = waitForCompletionStatus(handle, 200, TimeUnit.MILLISECONDS, 50);\n      Assert.assertEquals(QueryStatus.OpStatus.FINISHED, status.getStatus());\n\n      List<QueryResult> firstPreview = exploreService.previewResults(handle);\n      Assert.assertEquals(ImmutableList.of(\n        new QueryResult(ImmutableList.<Object>of(\"my_table\")),\n        new QueryResult(ImmutableList.<Object>of(\"my_table_2\")),\n        new QueryResult(ImmutableList.<Object>of(\"my_table_3\")),\n        new QueryResult(ImmutableList.<Object>of(\"my_table_4\")),\n        new QueryResult(ImmutableList.<Object>of(\"my_table_5\"))\n      ), firstPreview);\n\n\n      List<QueryResult> endResults = exploreService.nextResults(handle, 100);\n      Assert.assertEquals(ImmutableList.of(\n        new QueryResult(ImmutableList.<Object>of(\"my_table_6\"))\n      ), endResults);\n\n      List<QueryResult> secondPreview = exploreService.previewResults(handle);\n      Assert.assertEquals(firstPreview, secondPreview);\n\n      Assert.assertEquals(ImmutableList.of(), exploreService.nextResults(handle, 100));\n\n      try {\n        // All results are fetched, query should be inactive now\n        exploreService.previewResults(handle);\n        Assert.fail(\"HandleNotFoundException expected - query should be inactive.\");\n      } catch (HandleNotFoundException e) {\n        Assert.assertTrue(e.isInactive());\n        // Expected exception\n      }\n\n    } finally {\n      datasetFramework.deleteInstance(\"my_table_2\");\n      datasetFramework.deleteInstance(\"my_table_3\");\n      datasetFramework.deleteInstance(\"my_table_4\");\n      datasetFramework.deleteInstance(\"my_table_5\");\n      datasetFramework.deleteInstance(\"my_table_6\");\n    }\n  }","commit_id":"0dbc4a3958e65f374df9379be83e5493854cded7","url":"https://github.com/caskdata/cdap"},{"original_method":"public <T> T decodeResponseContent(TypeToken<T> type) {\n    JsonReader jsonReader = new JsonReader(new InputStreamReader\n                                             (new ChannelBufferInputStream(content), Charsets.UTF_8));\n    T response = GSON.fromJson(jsonReader, type.getType());\n    return response;\n  }","id":83516,"modified_method":"public <T> T decodeResponseContent(TypeToken<T> type) {\n    JsonReader jsonReader = new JsonReader(new InputStreamReader\n                                             (new ChannelBufferInputStream(content), Charsets.UTF_8));\n    return GSON.fromJson(jsonReader, type.getType());\n  }","commit_id":"7646ace4d0f2384ab2928f9737ee62f1425fcf34","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void sendJson(HttpResponseStatus status, Object object, Type type) {\n    sendJson(status, object, type, gson.get());\n  }","id":83517,"modified_method":"@Override\n  public void sendJson(HttpResponseStatus status, Object object, Type type) {\n    sendJson(status, object, type, GSON);\n  }","commit_id":"7646ace4d0f2384ab2928f9737ee62f1425fcf34","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Serializes the object of type T into JSON and returns a byte array representing JSON.\n   * @param object instance of type T\n   * @return byte array of JSON for object of type T.\n   * @throws JSONSerializationException\n   */\n  public final byte[] serialize(T object) throws JSONSerializationException {\n    try {\n      String json = gson.toJson((T) object);\n      return json.getBytes();\n    } catch (Exception e) {\n      throw new JSONSerializationException(e.getMessage());\n    }\n  }","id":83518,"modified_method":"/**\n   * Serializes the object of type T into JSON and returns a byte array representing JSON.\n   * @param object instance of type T\n   * @return byte array of JSON for object of type T.\n   * @throws JSONSerializationException\n   */\n  public final byte[] serialize(T object) throws JSONSerializationException {\n    try {\n      return gson.toJson(object).getBytes(UTF8);\n    } catch (Exception e) {\n      throw new JSONSerializationException(e.getMessage());\n    }\n  }","commit_id":"b929cd79b1ff27478d23e46f803bfcb0ddd2926a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Deserializes the byte array of JSON into the object of type T\n   * @param object instance of type T\n   * @param clazz specifying the type of object T\n   * @return Object instance of type T\n   * @throws JSONSerializationException\n   */\n  public final <T> T deserialize(byte[] object, Class<T> clazz) throws JSONSerializationException {\n    try {\n      T o = gson.fromJson(new String(object), clazz);\n      return o;\n    } catch (JsonSyntaxException e) {\n      throw new JSONSerializationException(e.getMessage());\n    }\n  }","id":83519,"modified_method":"/**\n   * Deserializes the byte array of JSON into the object of type T\n   * @param object instance of type T\n   * @param clazz specifying the type of object T\n   * @return Object instance of type T\n   * @throws JSONSerializationException\n   */\n  public final <T> T deserialize(byte[] object, Class<T> clazz) throws JSONSerializationException {\n    try {\n      return gson.fromJson(new String(object, UTF8), clazz);\n    } catch (JsonSyntaxException e) {\n      throw new JSONSerializationException(e.getMessage());\n    }\n  }","commit_id":"b929cd79b1ff27478d23e46f803bfcb0ddd2926a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Deserialize a byte array into an instance\n   *\n   * @param bytes the bytes\n   * @return service instance\n   * @throws Exception any errors\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public ServiceInstance<ServicePayload> deserialize(byte[] bytes) throws Exception {\n    return gson.fromJson(new String(bytes, UTF8), ServiceInstance.class);\n  }","id":83520,"modified_method":"/**\n   * Deserialize a byte array into an instance\n   *\n   * @param bytes the bytes\n   * @return service instance\n   * @throws Exception any errors\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public ServiceInstance<ServicePayload> deserialize(byte[] bytes) throws Exception {\n    return serializer.deserialize(bytes, ServiceInstance.class);\n  }","commit_id":"b929cd79b1ff27478d23e46f803bfcb0ddd2926a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Serialize an instance into bytes\n   *\n   * @param instance the instance\n   * @return byte array representing the instance\n   * @throws Exception any errors\n   */\n  @Override\n  public byte[] serialize(ServiceInstance<ServicePayload> instance) throws Exception {\n    return gson.toJson(instance).getBytes(UTF8);\n  }","id":83521,"modified_method":"/**\n   * Serialize an instance into bytes\n   *\n   * @param instance the instance\n   * @return byte array representing the instance\n   * @throws Exception any errors\n   */\n  @Override\n  public byte[] serialize(ServiceInstance<ServicePayload> instance) throws Exception {\n    return serializer.serialize(instance);\n  }","commit_id":"b929cd79b1ff27478d23e46f803bfcb0ddd2926a","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n     * @todo Add license files in META-INF directory.\n     */\n    public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        MavenProject project = (MavenProject)request.getParameter(\"project\");\n\n        String manifest = (String) request.getParameter( \"manifest\" );\n\n        File basedir = new File( (String) request.getParameter( \"basedir\" ) );\n\n        String outputDirectory = (String) request.getParameter( \"outputDirectory\" );\n\n        String jarName = (String) request.getParameter( \"jarName\" );\n\n        boolean compress = new Boolean( (String) request.getParameter( \"compress\" ) ).booleanValue();\n\n        boolean index = new Boolean( (String) request.getParameter( \"index\" ) ).booleanValue();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n\n        File jarFile = new File( basedir, jarName + \".jar\" );\n\n        JarArchiver archiver = new JarArchiver();\n        archiver.addDirectory( new File( outputDirectory ), new String[] { \"**/**\" }, new String[] { \"**/package.html\" } );\n        archiver.addFile( project.getFile(), \"META-INF/maven/pom.xml\" );\n\n        if (manifest != null && ! \"\".equals( manifest ) )\n        {\n            File manifestFile = new File( manifest );\n            archiver.setManifest( manifestFile );\n        }\n\n        // Configure the jar\n        archiver.addConfiguredManifest( getManifest( request ) );\n\n        archiver.setCompress( compress );\n        archiver.setIndex( index );\n        archiver.setDestFile( jarFile );\n\n        // create archive\n        archiver.createArchive();\n    }","id":83522,"modified_method":"/**\n     * @todo Add license files in META-INF directory.\n     */\n    public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        File basedir = new File( (String) request.getParameter( \"basedir\" ) );\n\n        String outputDirectory = (String) request.getParameter( \"outputDirectory\" );\n\n        String jarName = (String) request.getParameter( \"jarName\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        File jarFile = new File( basedir, jarName + \".jar\" );\n\n        MavenArchiver archiver = new MavenArchiver();\n\n        archiver.setOutputFile( jarFile );\n\n        archiver.getArchiver().addDirectory( new File( outputDirectory ), new String[] { \"**/**\" }, new String[] { \"**/package.html\" } );\n\n        // create archive\n        archiver.createArchive( request );\n    }","commit_id":"bd142577bdd4aae2666a55fa1f7103852e628f2e","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n        request.getLog().info(\"war\");\n\n    }","id":83523,"modified_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        parseRequest( request );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( \"inplace\".equals( mode ) )\n        {\n            generateInPlaceWebapp();\n        }\n        else\n        {\n            generateExplodedWebapp();\n\n            if ( ! \"exploded\".equals( mode ) )\n            {\n                //generate war file\n                request.getLog().info( \"Generating war \" + warFile.getAbsolutePath() );\n\n                MavenArchiver archiver = new MavenArchiver();\n\n                //archiver.setArchiver( new WarArchiver() );\n\n                archiver.setOutputFile( warFile );\n\n                archiver.getArchiver().addDirectory( webappDirectory, new String[] { \"**/**\" }, null );\n\n                // create archive\n                archiver.createArchive( request );\n            }\n        }\n    }","commit_id":"bd142577bdd4aae2666a55fa1f7103852e628f2e","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#execute()\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        File destDir = this.destDir;\n\n        if ( destDir == null )\n        {\n            destDir = outputDirectory;\n        }\n\n        // The JAR does not operate in aggregation mode - individual Javadoc JARs are always distributed.\n        aggregate = false;\n\n        ArtifactHandler artifactHandler = project.getArtifact().getArtifactHandler();\n        if ( !\"java\".equals( artifactHandler.getLanguage() ) )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Not executing Javadoc as the project is not a Java classpath-capable package\" );\n            }\n        }\n        else\n        {\n            try\n            {\n                executeReport( Locale.getDefault() );\n\n                if ( destDir.exists() )\n                {\n                    File outputFile = generateArchive( destDir, finalName + \"-javadoc.jar\" );\n\n                    if ( !attach )\n                    {\n                        if ( getLog().isInfoEnabled() )\n                        {\n                            getLog().info( \"NOT adding javadoc to attached artifacts list.\" );\n                        }\n                    }\n                    else\n                    {\n                        // TODO: these introduced dependencies on the project are going to become problematic - can we export it\n                        //  through metadata instead?\n                        projectHelper.attachArtifact( project, \"javadoc\", \"javadoc\", outputFile );\n                    }\n                }\n            }\n            catch ( ArchiverException e )\n            {\n                throw new MojoExecutionException( \"Error while creating archive:\" + e.getMessage(), e );\n            }\n            catch ( IOException e )\n            {\n                throw new MojoExecutionException( \"Error while creating archive:\" + e.getMessage(), e );\n            }\n            catch ( MavenReportException e )\n            {\n                throw new MojoExecutionException( \"Error while creating archive:\" + e.getMessage(), e );\n            }\n        }\n    }","id":83524,"modified_method":"/**\n     * @see org.apache.maven.reporting.AbstractMavenReport#execute()\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        File destDir = this.destDir;\n        if ( destDir == null )\n        {\n            destDir = outputDirectory;\n        }\n\n        // The JAR does not operate in aggregation mode - individual Javadoc JARs are always distributed.\n        aggregate = false;\n\n        ArtifactHandler artifactHandler = project.getArtifact().getArtifactHandler();\n        if ( !\"java\".equals( artifactHandler.getLanguage() ) )\n        {\n            if ( getLog().isInfoEnabled() )\n            {\n                getLog().info( \"Not executing Javadoc as the project is not a Java classpath-capable package\" );\n            }\n\n            return;\n        }\n\n        try\n        {\n            executeReport( Locale.getDefault() );\n\n            if ( destDir.exists() )\n            {\n                File outputFile = generateArchive( destDir, finalName + \"-javadoc.jar\" );\n\n                if ( !attach )\n                {\n                    if ( getLog().isInfoEnabled() )\n                    {\n                        getLog().info( \"NOT adding javadoc to attached artifacts list.\" );\n                    }\n                }\n                else\n                {\n                    // TODO: these introduced dependencies on the project are going to become problematic - can we export it\n                    //  through metadata instead?\n                    projectHelper.attachArtifact( project, \"javadoc\", \"javadoc\", outputFile );\n                }\n            }\n        }\n        catch ( ArchiverException e )\n        {\n            throw new MojoExecutionException( \"ArchiverException: Error while creating archive:\" + e.getMessage(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"IOException: Error while creating archive:\" + e.getMessage(), e );\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"MavenReportException: Error while creating archive:\" + e.getMessage(), e );\n        }\n    }","commit_id":"c2e9a4491132ab79f5732ca13c864ec6bb07e1ca","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Method that creates the jar file\n     *\n     * @param javadocFiles the directory where the generated jar file will be put\n     * @param target       the filename of the generated jar file\n     * @return a File object that contains the generated jar file\n     * @throws ArchiverException\n     * @throws IOException\n     */\n    private File generateArchive( File javadocFiles, String target )\n        throws ArchiverException, IOException\n    {\n        File javadocJar = new File( jarOutputDirectory, target );\n\n        if ( javadocJar.exists() )\n        {\n            javadocJar.delete();\n        }\n\n        JarArchiver archiver = new JarArchiver();\n\n        List resources = project.getBuild().getResources();\n\n        for ( Iterator i = resources.iterator(); i.hasNext(); )\n        {\n            Resource r = (Resource) i.next();\n\n            if ( r.getDirectory().endsWith( \"maven-shared-archive-resources\" ) )\n            {\n                archiver.addDirectory( new File( r.getDirectory() ) );\n            }\n        }\n\n        //archiver.setDotFileDirectory( new File( project.getBuild().getDirectory() ) );\n\n        archiver.addDirectory( javadocFiles );\n\n        archiver.setDestFile( javadocJar );\n\n        archiver.createArchive();\n\n        return javadocJar;\n    }","id":83525,"modified_method":"/**\n     * Method that creates the jar file\n     *\n     * @param javadocFiles the directory where the generated jar file will be put\n     * @param target       the filename of the generated jar file\n     * @return a File object that contains the generated jar file\n     * @throws ArchiverException\n     * @throws IOException\n     */\n    private File generateArchive( File javadocFiles, String target )\n        throws ArchiverException, IOException\n    {\n        File javadocJar = new File( jarOutputDirectory, target );\n\n        if ( javadocJar.exists() )\n        {\n            javadocJar.delete();\n        }\n\n        MavenArchiver archiver = new MavenArchiver();\n        archiver.setArchiver( jarArchiver );\n        archiver.setOutputFile( javadocJar );\n\n        File contentDirectory = javadocFiles;\n        if ( !contentDirectory.exists() )\n        {\n            getLog().warn( \"JAR will be empty - no content was marked for inclusion!\" );\n        }\n        else\n        {\n            archiver.getArchiver().addDirectory( contentDirectory );\n        }\n\n        List resources = project.getBuild().getResources();\n\n        for ( Iterator i = resources.iterator(); i.hasNext(); )\n        {\n            Resource r = (Resource) i.next();\n            if ( r.getDirectory().endsWith( \"maven-shared-archive-resources\" ) )\n            {\n                archiver.getArchiver().addDirectory( new File( r.getDirectory() ) );\n            }\n        }\n\n        if ( useDefaultManifestFile && defaultManifestFile.exists() && archive.getManifestFile() == null )\n        {\n            getLog().info( \"Adding existing MANIFEST to archive. Found under: \" + defaultManifestFile.getPath() );\n            archive.setManifestFile( defaultManifestFile );\n        }\n\n        try\n        {\n            // we dont want Maven stuff\n            archive.setAddMavenDescriptor( false );\n            archiver.createArchive( project, archive );\n        }\n        catch ( ManifestException e )\n        {\n            throw new ArchiverException( \"ManifestException: \" + e.getMessage(), e );\n        }\n        catch ( DependencyResolutionRequiredException e )\n        {\n            throw new ArchiverException( \"DependencyResolutionRequiredException: \" + e.getMessage(), e );\n        }\n\n        return javadocJar;\n    }","commit_id":"c2e9a4491132ab79f5732ca13c864ec6bb07e1ca","url":"https://github.com/apache/maven-plugins"},{"original_method":"public JavadocJarDefaultMavenProjectStub()\n    {\n\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model = null;\n\n        try\n        {\n            model = pomReader.read( new FileReader( new File( getBasedir() +\n                \"/src/test/resources/unit/default-configuration/default-configuration-plugin-config.xml\" ) ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n\n        }\n\n        setGroupId( model.getGroupId() );\n        setArtifactId( model.getArtifactId() );\n        setVersion( model.getVersion() );\n        setName( model.getName() );\n        setUrl( model.getUrl() );\n        setPackaging( model.getPackaging() );\n\n        Scm scm = new Scm();\n        scm.setConnection( \"scm:svn:http://svn.apache.org/maven/sample/trunk\" );\n        setScm( scm );\n\n        Artifact artifact =\n            new JavadocPluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging() );\n        artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n        setArtifact( artifact );\n\n        Build build = new Build();\n        build.setFinalName( \"javadocjar-default\" );\n        build.setDirectory( getBasedir() + \"/target/test/unit/javadocjar-default/target\" );\n        setBuild( build );\n\n        String basedir = getBasedir().getAbsolutePath();\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( basedir + \"/src/test/resources/unit/javadocjar-default/javadocjar/def\" );\n        setCompileSourceRoots( compileSourceRoots );\n    }","id":83526,"modified_method":"public JavadocJarDefaultMavenProjectStub()\n    {\n\n        MavenXpp3Reader pomReader = new MavenXpp3Reader();\n        Model model = null;\n\n        try\n        {\n            model = pomReader.read( new FileReader( new File( getBasedir() +\n                \"/src/test/resources/unit/javadocjar-default/javadocjar-default-plugin-config.xml\" ) ) );\n            setModel( model );\n        }\n        catch ( Exception e )\n        {\n\n        }\n\n        setGroupId( model.getGroupId() );\n        setArtifactId( model.getArtifactId() );\n        setVersion( model.getVersion() );\n        setName( model.getName() );\n        setUrl( model.getUrl() );\n        setPackaging( model.getPackaging() );\n\n        Scm scm = new Scm();\n        scm.setConnection( \"scm:svn:http://svn.apache.org/maven/sample/trunk\" );\n        setScm( scm );\n\n        JavadocPluginArtifactStub artifact =\n            new JavadocPluginArtifactStub( getGroupId(), getArtifactId(), getVersion(), getPackaging() );\n        artifact.setArtifactHandler( new DefaultArtifactHandlerStub() );\n        artifact.setType( \"jar\" );\n        artifact.setBaseVersion( \"1.0-SNAPSHOT\" );\n        setArtifact( artifact );\n\n        Build build = new Build();\n        build.setFinalName( \"javadocjar-default\" );\n        build.setDirectory( getBasedir() + \"/target/test/unit/javadocjar-default/target\" );\n        setBuild( build );\n\n        String basedir = getBasedir().getAbsolutePath();\n        List compileSourceRoots = new ArrayList();\n        compileSourceRoots.add( basedir + \"/src/test/resources/unit/javadocjar-default/javadocjar/def\" );\n        setCompileSourceRoots( compileSourceRoots );\n    }","commit_id":"c2e9a4491132ab79f5732ca13c864ec6bb07e1ca","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @todo Add license files in META-INF directory.\n     */\n    public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        MavenProject project = (MavenProject)request.getParameter(\"project\");\n\n        String manifest = (String) request.getParameter( \"manifest\" );\n\n        File basedir = new File( (String) request.getParameter( \"basedir\" ) );\n\n        String outputDirectory = (String) request.getParameter( \"outputDirectory\" );\n\n        String jarName = (String) request.getParameter( \"jarName\" );\n\n        boolean compress = new Boolean( (String) request.getParameter( \"compress\" ) ).booleanValue();\n\n        boolean index = new Boolean( (String) request.getParameter( \"index\" ) ).booleanValue();\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n\n        File jarFile = new File( basedir, jarName + \".jar\" );\n\n        JarArchiver archiver = new JarArchiver();\n        archiver.addDirectory( new File( outputDirectory ), new String[] { \"**/**\" }, new String[] { \"**/package.html\" } );\n        archiver.addFile( project.getFile(), \"META-INF/maven/pom.xml\" );\n\n        if (manifest != null && ! \"\".equals( manifest ) )\n        {\n            File manifestFile = new File( manifest );\n            archiver.setManifest( manifestFile );\n        }\n\n        // Configure the jar\n        archiver.addConfiguredManifest( getManifest( request ) );\n\n        archiver.setCompress( compress );\n        archiver.setIndex( index );\n        archiver.setDestFile( jarFile );\n\n        // create archive\n        archiver.createArchive();\n    }","id":83527,"modified_method":"/**\n     * @todo Add license files in META-INF directory.\n     */\n    public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        File basedir = new File( (String) request.getParameter( \"basedir\" ) );\n\n        String outputDirectory = (String) request.getParameter( \"outputDirectory\" );\n\n        String jarName = (String) request.getParameter( \"jarName\" );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        File jarFile = new File( basedir, jarName + \".jar\" );\n\n        MavenArchiver archiver = new MavenArchiver();\n\n        archiver.setOutputFile( jarFile );\n\n        archiver.getArchiver().addDirectory( new File( outputDirectory ), new String[] { \"**/**\" }, new String[] { \"**/package.html\" } );\n\n        // create archive\n        archiver.createArchive( request );\n    }","commit_id":"323eecfc571eeffdedf7066e61c5b9a57e3aefa9","url":"https://github.com/apache/maven"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n        request.getLog().info(\"war\");\n\n    }","id":83528,"modified_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        parseRequest( request );\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        if ( \"inplace\".equals( mode ) )\n        {\n            generateInPlaceWebapp();\n        }\n        else\n        {\n            generateExplodedWebapp();\n\n            if ( ! \"exploded\".equals( mode ) )\n            {\n                //generate war file\n                request.getLog().info( \"Generating war \" + warFile.getAbsolutePath() );\n\n                MavenArchiver archiver = new MavenArchiver();\n\n                //archiver.setArchiver( new WarArchiver() );\n\n                archiver.setOutputFile( warFile );\n\n                archiver.getArchiver().addDirectory( webappDirectory, new String[] { \"**/**\" }, null );\n\n                // create archive\n                archiver.createArchive( request );\n            }\n        }\n    }","commit_id":"323eecfc571eeffdedf7066e61c5b9a57e3aefa9","url":"https://github.com/apache/maven"},{"original_method":"@Override\n  public final QuotaCounts computeQuotaUsage(BlockStoragePolicySuite bsps,\n      byte blockStoragePolicyId, boolean useCache, int lastSnapshotId) {\n    final QuotaCounts counts = new QuotaCounts.Builder().nameSpace(1).build();\n\n    final BlockStoragePolicy bsp = bsps.getPolicy(blockStoragePolicyId);\n    FileWithSnapshotFeature sf = getFileWithSnapshotFeature();\n    if (sf == null) {\n      counts.add(storagespaceConsumed(bsp));\n      return counts;\n    }\n\n    FileDiffList fileDiffList = sf.getDiffs();\n    int last = fileDiffList.getLastSnapshotId();\n\n    if (lastSnapshotId == Snapshot.CURRENT_STATE_ID\n        || last == Snapshot.CURRENT_STATE_ID) {\n      counts.add(storagespaceConsumed(bsp));\n      return counts;\n    }\n\n    final long ssDeltaNoReplication;\n    short replication;\n    if (isStriped()) {\n      return computeQuotaUsageWithStriped(bsp, counts);\n    }\n\n    if (last < lastSnapshotId) {\n      ssDeltaNoReplication = computeFileSize(true, false);\n      replication = getFileReplication();\n    } else {\n      int sid = fileDiffList.getSnapshotById(lastSnapshotId);\n      ssDeltaNoReplication = computeFileSize(sid);\n      replication = getFileReplication(sid);\n    }\n\n    counts.addStorageSpace(ssDeltaNoReplication * replication);\n    if (bsp != null) {\n      List<StorageType> storageTypes = bsp.chooseStorageTypes(replication);\n      for (StorageType t : storageTypes) {\n        if (!t.supportTypeQuota()) {\n          continue;\n        }\n        counts.addTypeSpace(t, ssDeltaNoReplication);\n      }\n    }\n    return counts;\n  }","id":83529,"modified_method":"@Override\n  public final QuotaCounts computeQuotaUsage(BlockStoragePolicySuite bsps,\n      byte blockStoragePolicyId, boolean useCache, int lastSnapshotId) {\n    final QuotaCounts counts = new QuotaCounts.Builder().nameSpace(1).build();\n\n    final BlockStoragePolicy bsp = (blockStoragePolicyId ==\n        BLOCK_STORAGE_POLICY_ID_UNSPECIFIED) ? null :\n        bsps.getPolicy(blockStoragePolicyId);\n    FileWithSnapshotFeature sf = getFileWithSnapshotFeature();\n    if (sf == null) {\n      counts.add(storagespaceConsumed(bsp));\n      return counts;\n    }\n\n    FileDiffList fileDiffList = sf.getDiffs();\n    int last = fileDiffList.getLastSnapshotId();\n\n    if (lastSnapshotId == Snapshot.CURRENT_STATE_ID\n        || last == Snapshot.CURRENT_STATE_ID) {\n      counts.add(storagespaceConsumed(bsp));\n      return counts;\n    }\n\n    final long ssDeltaNoReplication;\n    short replication;\n    if (isStriped()) {\n      return computeQuotaUsageWithStriped(bsp, counts);\n    }\n\n    if (last < lastSnapshotId) {\n      ssDeltaNoReplication = computeFileSize(true, false);\n      replication = getFileReplication();\n    } else {\n      int sid = fileDiffList.getSnapshotById(lastSnapshotId);\n      ssDeltaNoReplication = computeFileSize(sid);\n      replication = getFileReplication(sid);\n    }\n\n    counts.addStorageSpace(ssDeltaNoReplication * replication);\n    if (bsp != null) {\n      List<StorageType> storageTypes = bsp.chooseStorageTypes(replication);\n      for (StorageType t : storageTypes) {\n        if (!t.supportTypeQuota()) {\n          continue;\n        }\n        counts.addTypeSpace(t, ssDeltaNoReplication);\n      }\n    }\n    return counts;\n  }","commit_id":"ea5bb483269b51a349c358b71f84904c76693a66","url":"https://github.com/apache/hadoop"},{"original_method":"Policy getElementPolicy(Extensible ex, boolean includeAttributes, DescriptionInfo di) {\n        if (null == ex || null == di) {\n            return null;\n        }\n        \n        if (di.getProperty(\"registeredPolicy\") == null) {\n            List<UnknownExtensibilityElement> diext = \n                di.getExtensors(UnknownExtensibilityElement.class);\n            if (diext != null) {\n                for (UnknownExtensibilityElement e : diext) {\n                    String uri = e.getElement().getAttributeNS(PolicyConstants.WSU_NAMESPACE_URI,\n                                                  PolicyConstants.WSU_ID_ATTR_NAME);\n                    \n                    if (Constants.isPolicyElement(e.getElementType())\n                        && !StringUtils.isEmpty(uri)) {\n                        try {\n                            Policy policy = builder.getPolicy(e.getElement());\n                            String fragement = \"#\" + uri;\n                            registry.register(fragement, policy);\n                            if (di.getBaseURI() == null) {\n                                registry.register(Integer.toString(di.hashCode()) + fragement, policy);\n                            } else {\n                                registry.register(di.getBaseURI() + fragement, policy);\n                            }\n                        } catch (Exception policyEx) {\n                            //ignore the policy can not be built\n                            LOG.warning(\"Failed to build the policy '\" + uri + \"':\" + policyEx.getMessage());\n                        }\n                    }\n                }\n            }\n            di.setProperty(\"registeredPolicy\", true);\n        }\n        \n        Policy elementPolicy = null;\n        List<UnknownExtensibilityElement> extensions = \n            ex.getExtensors(UnknownExtensibilityElement.class);\n        \n        if (null != extensions) {\n            for (UnknownExtensibilityElement e : extensions) {\n                Policy p = null;\n                if (Constants.isPolicyElement(e.getElementType())) {\n                    p = builder.getPolicy(e.getElement());\n\n                } else if (Constants.isPolicyRef(e.getElementType())) {\n                    PolicyReference ref = builder.getPolicyReference(e.getElement());\n                    if (null != ref) {\n                        p = resolveReference(ref, di);\n                    }\n                }\n                if (null != p) {\n                    if (elementPolicy == null) {\n                        elementPolicy = new Policy();\n                    }\n                    elementPolicy = elementPolicy.merge(p);\n                }\n            }\n        }\n        \n        if (includeAttributes && ex.getExtensionAttributes() != null) {\n            for (Map.Entry<QName, Object> ent : ex.getExtensionAttributes().entrySet()) {\n                if (Constants.isPolicyURIsAttr(ent.getKey())) {\n                    Object attr = ent.getValue();\n                    // can be of type a String, a QName, a list of Srings or a list of QNames\n                    String uris = null;\n                    if (attr instanceof QName) {\n                        uris = ((QName)attr).getLocalPart();\n                    } else if (attr instanceof String) {\n                        uris = (String)attr;\n                    }\n                    if (null != uris) {\n                        StringTokenizer st = new StringTokenizer(uris);\n                        while (st.hasMoreTokens()) {\n                            String uri = st.nextToken();\n                            PolicyReference ref = new PolicyReference();\n                            ref.setURI(uri);\n                            Policy p = resolveReference(ref, di);\n                            if (null != p) {\n                                elementPolicy = elementPolicy == null \n                                    ? new Policy().merge(p) : elementPolicy.merge(p);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return elementPolicy;\n    }","id":83530,"modified_method":"Policy getElementPolicy(Extensible ex, boolean includeAttributes, DescriptionInfo di) {\n        if (null == ex || null == di) {\n            return null;\n        }\n        \n        if (di.getProperty(\"registeredPolicy\") == null) {\n            List<UnknownExtensibilityElement> diext = \n                di.getExtensors(UnknownExtensibilityElement.class);\n            if (diext != null) {\n                for (UnknownExtensibilityElement e : diext) {\n                    String uri = e.getElement().getAttributeNS(PolicyConstants.WSU_NAMESPACE_URI,\n                                                  PolicyConstants.WSU_ID_ATTR_NAME);\n                    \n                    if (Constants.isPolicyElement(e.getElementType())\n                        && !StringUtils.isEmpty(uri)) {\n                        \n                        String id = (di.getBaseURI() == null ? Integer.toString(di.hashCode()) : di.getBaseURI()) \n                                + \"#\" + uri;\n                        Policy policy = registry.lookup(id);\n                        if (policy == null) {\n                            try {\n                                policy = builder.getPolicy(e.getElement());\n                                String fragement = \"#\" + uri;\n                                registry.register(fragement, policy);\n                                registry.register(id, policy);\n                            } catch (Exception policyEx) {\n                                //ignore the policy can not be built\n                                LOG.warning(\"Failed to build the policy '\" + uri + \"':\" + policyEx.getMessage());\n                            }\n                        }\n                    }\n                }\n            }\n            di.setProperty(\"registeredPolicy\", true);\n        }\n        \n        Policy elementPolicy = null;\n        List<UnknownExtensibilityElement> extensions = \n            ex.getExtensors(UnknownExtensibilityElement.class);\n        \n        if (null != extensions) {\n            for (UnknownExtensibilityElement e : extensions) {\n                Policy p = null;\n                if (Constants.isPolicyElement(e.getElementType())) {\n                    p = builder.getPolicy(e.getElement());\n\n                } else if (Constants.isPolicyRef(e.getElementType())) {\n                    PolicyReference ref = builder.getPolicyReference(e.getElement());\n                    if (null != ref) {\n                        p = resolveReference(ref, di);\n                    }\n                }\n                if (null != p) {\n                    if (elementPolicy == null) {\n                        elementPolicy = new Policy();\n                    }\n                    elementPolicy = elementPolicy.merge(p);\n                }\n            }\n        }\n        \n        if (includeAttributes && ex.getExtensionAttributes() != null) {\n            for (Map.Entry<QName, Object> ent : ex.getExtensionAttributes().entrySet()) {\n                if (Constants.isPolicyURIsAttr(ent.getKey())) {\n                    Object attr = ent.getValue();\n                    // can be of type a String, a QName, a list of Srings or a list of QNames\n                    String uris = null;\n                    if (attr instanceof QName) {\n                        uris = ((QName)attr).getLocalPart();\n                    } else if (attr instanceof String) {\n                        uris = (String)attr;\n                    }\n                    if (null != uris) {\n                        StringTokenizer st = new StringTokenizer(uris);\n                        while (st.hasMoreTokens()) {\n                            String uri = st.nextToken();\n                            PolicyReference ref = new PolicyReference();\n                            ref.setURI(uri);\n                            Policy p = resolveReference(ref, di);\n                            if (null != p) {\n                                elementPolicy = elementPolicy == null \n                                    ? new Policy().merge(p) : elementPolicy.merge(p);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return elementPolicy;\n    }","commit_id":"26eababf9a40ca1345653a0d80bb69d3e01f5923","url":"https://github.com/apache/cxf"},{"original_method":"public boolean isNotificationEnabled(Class type)\n    {\n        return configuration.getPolicy().isNotificationEnabled(type);\n    }","id":83531,"modified_method":"public boolean isNotificationEnabled(Class type)\n    {\n        boolean enabled = false;\n        if (configuration != null)\n        {\n            Policy policy = configuration.getPolicy();\n            if (policy != null)\n            {\n                enabled = policy.isNotificationEnabled(type);\n            }\n        }\n        return enabled;\n    }","commit_id":"06701f913e9d2aeef71639b9a768c7c6af305daa","url":"https://github.com/mulesoft/mule"},{"original_method":"private void addSelectedUnregisteredMappings(List<MapInfo> infos) {\n    List<MapInfo> items = new ArrayList<MapInfo>(myModel.getItems());\n    for (MapInfo info : infos) {\n      items.remove(info);\n      items.add(new MapInfo(new VcsDirectoryMapping(info.mapping.getDirectory(), info.mapping.getVcs(), info.mapping.getRootSettings()), isMappingValid(info.mapping)));\n    }\n    addOrRemoveSeparator(items);\n    Collections.sort(items, MapInfo.COMPARATOR);\n    myModel.setItems(items);\n    checkNotifyListeners(getActiveVcses());\n  }","id":83532,"modified_method":"private void addSelectedUnregisteredMappings(List<MapInfo> infos) {\n    List<MapInfo> items = new ArrayList<MapInfo>(myModel.getItems());\n    for (MapInfo info : infos) {\n      items.remove(info);\n      items.add(MapInfo.registered(info.mapping, isMappingValid(info.mapping)));\n    }\n    sortAndAddSeparatorIfNeeded(items);\n    myModel.setItems(items);\n    checkNotifyListeners(getActiveVcses());\n  }","commit_id":"f4e8dc7c457224a08e80db8dd7ac12f681710f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Contract(pure = false)\n  private static void addOrRemoveSeparator(@NotNull List<MapInfo> items) {\n    boolean hasUnregistered = false;\n    boolean hasSeparator = false;\n    for (MapInfo item : items) {\n      if (item.type == MapInfo.Type.UNREGISTERED) {\n        hasUnregistered = true;\n      }\n      else if (item.type == MapInfo.Type.SEPARATOR) {\n        hasSeparator = true;\n      }\n    }\n    if (!hasUnregistered && hasSeparator) {\n      items.remove(MapInfo.SEPARATOR);\n    }\n    else if (hasUnregistered && !hasSeparator) {\n      items.add(MapInfo.SEPARATOR);\n    }\n  }","id":83533,"modified_method":"@Contract(pure = false)\n  private static void sortAndAddSeparatorIfNeeded(@NotNull List<MapInfo> items) {\n    boolean hasUnregistered = false;\n    boolean hasSeparator = false;\n    for (MapInfo item : items) {\n      if (item.type == MapInfo.Type.UNREGISTERED) {\n        hasUnregistered = true;\n      }\n      else if (item.type == MapInfo.Type.SEPARATOR) {\n        hasSeparator = true;\n      }\n    }\n    if (!hasUnregistered && hasSeparator) {\n      items.remove(MapInfo.SEPARATOR);\n    }\n    else if (hasUnregistered && !hasSeparator) {\n      items.add(MapInfo.SEPARATOR);\n    }\n    Collections.sort(items, MapInfo.COMPARATOR);\n  }","commit_id":"f4e8dc7c457224a08e80db8dd7ac12f681710f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addMapping(VcsDirectoryMapping mapping) {\n    List<MapInfo> items = new ArrayList<MapInfo>(myModel.getItems());\n    items.add(new MapInfo(new VcsDirectoryMapping(mapping.getDirectory(), mapping.getVcs(), mapping.getRootSettings()), isMappingValid(mapping)));\n    Collections.sort(items, MapInfo.COMPARATOR);\n    myModel.setItems(items);\n    checkNotifyListeners(getActiveVcses());\n  }","id":83534,"modified_method":"private void addMapping(VcsDirectoryMapping mapping) {\n    List<MapInfo> items = new ArrayList<MapInfo>(myModel.getItems());\n    items.add(MapInfo.registered(new VcsDirectoryMapping(mapping.getDirectory(), mapping.getVcs(), mapping.getRootSettings()),\n                                 isMappingValid(mapping)));\n    Collections.sort(items, MapInfo.COMPARATOR);\n    myModel.setItems(items);\n    checkNotifyListeners(getActiveVcses());\n  }","commit_id":"f4e8dc7c457224a08e80db8dd7ac12f681710f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void removeMapping() {\n    Collection<AbstractVcs> activeVcses = getActiveVcses();\n    ArrayList<MapInfo> mappings = new ArrayList<MapInfo>(myModel.getItems());\n    int index = myDirectoryMappingTable.getSelectionModel().getMinSelectionIndex();\n    Collection<MapInfo> selection = myDirectoryMappingTable.getSelection();\n    mappings.removeAll(selection);\n    myModel.setItems(mappings);\n    if (mappings.size() > 0) {\n      if (index >= mappings.size()) {\n        index = mappings.size() - 1;\n      }\n      myDirectoryMappingTable.getSelectionModel().setSelectionInterval(index, index);\n    }\n    checkNotifyListeners(activeVcses);\n  }","id":83535,"modified_method":"private void removeMapping() {\n    Collection<AbstractVcs> activeVcses = getActiveVcses();\n    ArrayList<MapInfo> mappings = new ArrayList<MapInfo>(myModel.getItems());\n    int index = myDirectoryMappingTable.getSelectionModel().getMinSelectionIndex();\n    Collection<MapInfo> selection = myDirectoryMappingTable.getSelection();\n    mappings.removeAll(selection);\n\n    Collection<MapInfo> removedValidRoots = ContainerUtil.mapNotNull(selection, new Function<MapInfo, MapInfo>() {\n      @Override\n      public MapInfo fun(MapInfo info) {\n        return info.type == MapInfo.Type.NORMAL ? MapInfo.unregistered(info.mapping.getDirectory(), info.mapping.getVcs()) : null;\n      }\n    });\n    mappings.addAll(removedValidRoots);\n    sortAndAddSeparatorIfNeeded(mappings);\n\n    myModel.setItems(mappings);\n    if (mappings.size() > 0) {\n      if (index >= mappings.size()) {\n        index = mappings.size() - 1;\n      }\n      myDirectoryMappingTable.getSelectionModel().setSelectionInterval(index, index);\n    }\n    checkNotifyListeners(activeVcses);\n  }","commit_id":"f4e8dc7c457224a08e80db8dd7ac12f681710f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initializeModel() {\n    List<MapInfo> mappings = new ArrayList<MapInfo>();\n    for (VcsDirectoryMapping mapping : ProjectLevelVcsManager.getInstance(myProject).getDirectoryMappings()) {\n      mappings.add(new MapInfo(new VcsDirectoryMapping(mapping.getDirectory(), mapping.getVcs(), mapping.getRootSettings()),\n                               isMappingValid(mapping)));\n    }\n\n    Collection<VcsRootError> errors = findUnregisteredRoots();\n    if (!errors.isEmpty()) {\n      mappings.add(MapInfo.SEPARATOR);\n      for (VcsRootError error : errors) {\n        mappings.add(new MapInfo(error.getMapping(), error.getVcsKey().getName()));\n      }\n    }\n\n    myModel = new ListTableModel<MapInfo>(new ColumnInfo[]{DIRECTORY, VCS_SETTING}, mappings, 0);\n    myDirectoryMappingTable.setModelAndUpdateColumns(myModel);\n\n    myRecentlyChangedConfigurable.reset();\n    myLimitHistory.reset();\n    myScopeFilterConfig.reset();\n    myBaseRevisionTexts.setSelected(myVcsConfiguration.INCLUDE_TEXT_INTO_SHELF);\n    myShowChangedRecursively.setSelected(myVcsConfiguration.SHOW_DIRTY_RECURSIVELY);\n    myCommitMessageMarginConfigurable.reset();\n  }","id":83536,"modified_method":"private void initializeModel() {\n    List<MapInfo> mappings = new ArrayList<MapInfo>();\n    for (VcsDirectoryMapping mapping : ProjectLevelVcsManager.getInstance(myProject).getDirectoryMappings()) {\n      mappings.add(MapInfo.registered(new VcsDirectoryMapping(mapping.getDirectory(), mapping.getVcs(), mapping.getRootSettings()),\n                                      isMappingValid(mapping)));\n    }\n\n    Collection<VcsRootError> errors = findUnregisteredRoots();\n    if (!errors.isEmpty()) {\n      mappings.add(MapInfo.SEPARATOR);\n      for (VcsRootError error : errors) {\n        mappings.add(MapInfo.unregistered(error.getMapping(), error.getVcsKey().getName()));\n      }\n    }\n\n    myModel = new ListTableModel<MapInfo>(new ColumnInfo[]{DIRECTORY, VCS_SETTING}, mappings, 0);\n    myDirectoryMappingTable.setModelAndUpdateColumns(myModel);\n\n    myRecentlyChangedConfigurable.reset();\n    myLimitHistory.reset();\n    myScopeFilterConfig.reset();\n    myBaseRevisionTexts.setSelected(myVcsConfiguration.INCLUDE_TEXT_INTO_SHELF);\n    myShowChangedRecursively.setSelected(myVcsConfiguration.SHOW_DIRTY_RECURSIVELY);\n    myCommitMessageMarginConfigurable.reset();\n  }","commit_id":"f4e8dc7c457224a08e80db8dd7ac12f681710f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"MapInfo(@NotNull VcsDirectoryMapping mapping, @NotNull Type type) {\n      this.mapping = mapping;\n      this.type = type;\n    }","id":83537,"modified_method":"private MapInfo(@NotNull VcsDirectoryMapping mapping, @NotNull Type type) {\n      this.mapping = mapping;\n      this.type = type;\n    }","commit_id":"f4e8dc7c457224a08e80db8dd7ac12f681710f3e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    final Project project = e.getProject();\n    if (project == null) return;\n\n    if (myPopup != null && myPopup.isVisible()) return;\n\n    final JBList list = new JBList(buildModel(project));\n\n    EditBookmarkDescriptionAction editDescriptionAction = new EditBookmarkDescriptionAction(project, list);\n    DefaultActionGroup actions = new DefaultActionGroup();\n    actions.add(editDescriptionAction);\n    actions.add(new DeleteBookmarkAction(project, list));\n    actions.add(new ToggleSortBookmarksAction());\n    actions.add(new MoveBookmarkUpAction(project, list));\n    actions.add(new MoveBookmarkDownAction(project, list));\n\n    myPopup = new MasterDetailPopupBuilder(project).\n      setList(list).\n      setDelegate(this).\n      setDetailView(new DetailViewImpl(project)).\n      setDimensionServiceKey(\"bookmarks\").\n      setAddDetailViewToEast(true).\n      setActionsGroup(actions).\n      setPopupTuner(new Consumer<PopupChooserBuilder>() {\n        @Override\n        public void consume(PopupChooserBuilder builder) {\n          builder.setCloseOnEnter(false).setCancelOnClickOutside(false);\n        }\n      }).\n      setDoneRunnable(new Runnable() {\n        @Override\n        public void run() {\n          myPopup.cancel();\n        }\n      }).\n      createMasterDetailPopup();\n\n    new AnAction() {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        @SuppressWarnings(\"deprecation\") Object[] values = list.getSelectedValues();\n        for (Object item : values) {\n          if (item instanceof BookmarkItem) {\n            itemChosen((BookmarkItem)item, project, myPopup, true);\n          }\n        }\n      }\n    }.registerCustomShortcutSet(CommonShortcuts.getEditSource(), list);\n\n    editDescriptionAction.setPopup(myPopup);\n    myPopup.showCenteredInCurrentWindow(project);\n\n    list.getEmptyText().setText(\"No Bookmarks\");\n    list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    project.getMessageBus().connect(myPopup).subscribe(BookmarksListener.TOPIC, new BookmarksListener() {\n      @Override\n      public void bookmarkAdded(@NotNull Bookmark b) {\n      }\n\n      @Override\n      public void bookmarkRemoved(@NotNull Bookmark b) {\n      }\n\n      @Override\n      public void bookmarkChanged(@NotNull Bookmark b) {\n      }\n\n      @Override\n      public void bookmarksOrderChanged() {\n        doUpdate();\n      }\n\n      private void doUpdate() {\n        TreeSet selectedValues = new TreeSet(Arrays.asList(list.getSelectedValues()));\n        DefaultListModel listModel = buildModel(project);\n        list.setModel(listModel);\n        ListSelectionModel selectionModel = list.getSelectionModel();\n        for (int i = 0; i < listModel.getSize(); i++) {\n          if (selectedValues.contains(listModel.get(i))) {\n            selectionModel.addSelectionInterval(i, i);\n          }\n        }\n      }\n    });\n  }","id":83538,"modified_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    final Project project = e.getProject();\n    if (project == null) return;\n\n    if (myPopup != null && myPopup.isVisible()) return;\n\n    final JBList list = new JBList(buildModel(project));\n\n    EditBookmarkDescriptionAction editDescriptionAction = new EditBookmarkDescriptionAction(project, list);\n    DefaultActionGroup actions = new DefaultActionGroup();\n    actions.add(editDescriptionAction);\n    actions.add(new DeleteBookmarkAction(project, list));\n    actions.add(new ToggleSortBookmarksAction());\n    actions.add(new MoveBookmarkUpAction(project, list));\n    actions.add(new MoveBookmarkDownAction(project, list));\n\n    myPopup = new MasterDetailPopupBuilder(project).\n      setList(list).\n      setDelegate(this).\n      setDetailView(new DetailViewImpl(project)).\n      setDimensionServiceKey(DIMENSION_SERVICE_KEY).\n      setAddDetailViewToEast(true).\n      setActionsGroup(actions).\n      setPopupTuner(new Consumer<PopupChooserBuilder>() {\n        @Override\n        public void consume(PopupChooserBuilder builder) {\n          builder.setCloseOnEnter(false).setCancelOnClickOutside(false);\n        }\n      }).\n      setDoneRunnable(new Runnable() {\n        @Override\n        public void run() {\n          myPopup.cancel();\n        }\n      }).\n      createMasterDetailPopup();\n\n    new AnAction() {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        @SuppressWarnings(\"deprecation\") Object[] values = list.getSelectedValues();\n        for (Object item : values) {\n          if (item instanceof BookmarkItem) {\n            itemChosen((BookmarkItem)item, project, myPopup, true);\n          }\n        }\n      }\n    }.registerCustomShortcutSet(CommonShortcuts.getEditSource(), list);\n\n    editDescriptionAction.setPopup(myPopup);\n    final Point location = DimensionService.getInstance().getLocation(DIMENSION_SERVICE_KEY, project);\n    if (location != null) {\n      myPopup.showInScreenCoordinates(WindowManager.getInstance().getFrame(project), location);\n    }\n    else {\n      myPopup.showCenteredInCurrentWindow(project);\n    }\n\n    list.getEmptyText().setText(\"No Bookmarks\");\n    list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    project.getMessageBus().connect(myPopup).subscribe(BookmarksListener.TOPIC, new BookmarksListener() {\n      @Override\n      public void bookmarkAdded(@NotNull Bookmark b) {\n      }\n\n      @Override\n      public void bookmarkRemoved(@NotNull Bookmark b) {\n      }\n\n      @Override\n      public void bookmarkChanged(@NotNull Bookmark b) {\n      }\n\n      @Override\n      public void bookmarksOrderChanged() {\n        doUpdate();\n      }\n\n      private void doUpdate() {\n        TreeSet selectedValues = new TreeSet(Arrays.asList(list.getSelectedValues()));\n        DefaultListModel listModel = buildModel(project);\n        list.setModel(listModel);\n        ListSelectionModel selectionModel = list.getSelectionModel();\n        for (int i = 0; i < listModel.getSize(); i++) {\n          if (selectedValues.contains(listModel.get(i))) {\n            selectionModel.addSelectionInterval(i, i);\n          }\n        }\n      }\n    });\n  }","commit_id":"4e892c58a23aac261c139c9dc9f3a9cb4a2252d5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public JBPopup createMasterDetailPopup() {\n    if (myChooserComponent instanceof JList) {\n      //noinspection unchecked\n      ((JList)myChooserComponent).setCellRenderer(new ListItemRenderer(myProject, myDelegate));\n    }\n\n    if (myDetailView == null) {\n      myDetailView = new DetailViewImpl(myProject);\n    }\n\n    myPathLabel = new JLabel(\" \");\n    myPathLabel.setHorizontalAlignment(SwingConstants.RIGHT);\n    myPathLabel.setFont(myPathLabel.getFont().deriveFont((float)10));\n\n    JPanel footerPanel = new JPanel(new BorderLayout()) {\n      @Override\n      protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        g.setColor(BORDER_COLOR);\n        g.drawLine(0, 0, getWidth(), 0);\n      }\n    };\n    footerPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));\n    footerPanel.add(myPathLabel);\n\n    Runnable itemCallback = new Runnable() {\n      @Override\n      public void run() {\n        IdeFocusManager.getInstance(myProject).doWhenFocusSettlesDown(new Runnable() {\n          @Override\n          public void run() {\n            chooseItems(false);\n          }\n        });\n      }\n    };\n\n    JComponent toolBar = null;\n    if (myActions != null) {\n      ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(\"\", myActions, true);\n      actionToolbar.setReservePlaceAutoPopupIcon(false);\n      actionToolbar.setMinimumButtonSize(new Dimension(20, 20));\n      toolBar = actionToolbar.getComponent();\n      toolBar.setOpaque(false);\n    }\n\n    PopupChooserBuilder builder = createInnerBuilder().\n      setMovable(true).\n      setResizable(true).\n      setAutoselectOnMouseMove(false).\n      setMayBeParent(true).\n      setDimensionServiceKey(myDimensionServiceKey).\n      setSettingButton(toolBar).\n      setSouthComponent(footerPanel).\n      setItemChoosenCallback(itemCallback).\n      setFilteringEnabled(new Function<Object, String>() {\n        @Override\n        public String fun(Object o) {\n          return ((ItemWrapper)o).speedSearchText();\n        }\n      });\n\n    if (myPopupTuner != null) {\n      myPopupTuner.consume(builder);\n    }\n\n    if (myDoneRunnable != null) {\n      ActionListener actionListener = new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent event) {\n          myDoneRunnable.run();\n        }\n      };\n\n      if ((SystemInfo.isMacOSLion || SystemInfo.isMacOSMountainLion) && !UIUtil.isUnderDarcula()) {\n        final JButton done = new JButton(\"Done\");\n        done.setMnemonic('o');\n        done.addActionListener(actionListener);\n        builder.setCommandButton(new ActiveComponent.Adapter() {\n          @Override\n          public JComponent getComponent() {\n            return done;\n          }\n        });\n      }\n      else {\n        IconButton close = new IconButton(\"Close\", AllIcons.Actions.Close, AllIcons.Actions.CloseHovered);\n        builder.setCommandButton(new InplaceButton(close, actionListener));\n      }\n    }\n\n    String title = myDelegate.getTitle();\n    if (title != null) {\n      builder.setTitle(title);\n    }\n\n    myPopup = builder.createPopup();\n\n    builder.getScrollPane().setBorder(IdeBorderFactory.createBorder(SideBorder.RIGHT));\n\n    myPopup.addListener(new JBPopupListener.Adapter() {\n      @Override\n      public void onClosed(LightweightWindowEvent event) {\n        myDetailView.clearEditor();\n      }\n    });\n\n    if (myDoneRunnable != null) {\n      new AnAction(\"Done\") {\n        @Override\n        public void actionPerformed(AnActionEvent e) {\n          myDoneRunnable.run();\n        }\n      }.registerCustomShortcutSet(KeyEvent.VK_ENTER, InputEvent.CTRL_DOWN_MASK, myPopup.getContent());\n    }\n\n    return myPopup;\n  }","id":83539,"modified_method":"@NotNull\n  public JBPopup createMasterDetailPopup() {\n    if (myChooserComponent instanceof JList) {\n      //noinspection unchecked\n      ((JList)myChooserComponent).setCellRenderer(new ListItemRenderer(myProject, myDelegate));\n    }\n\n    if (myDetailView == null) {\n      myDetailView = new DetailViewImpl(myProject);\n    }\n\n    myPathLabel = new JLabel(\" \");\n    myPathLabel.setHorizontalAlignment(SwingConstants.RIGHT);\n    myPathLabel.setFont(myPathLabel.getFont().deriveFont((float)10));\n\n    JPanel footerPanel = new JPanel(new BorderLayout()) {\n      @Override\n      protected void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        g.setColor(BORDER_COLOR);\n        g.drawLine(0, 0, getWidth(), 0);\n      }\n    };\n    footerPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));\n    footerPanel.add(myPathLabel);\n\n    Runnable itemCallback = new Runnable() {\n      @Override\n      public void run() {\n        IdeFocusManager.getInstance(myProject).doWhenFocusSettlesDown(new Runnable() {\n          @Override\n          public void run() {\n            chooseItems(false);\n          }\n        });\n      }\n    };\n\n    JComponent toolBar = null;\n    if (myActions != null) {\n      ActionToolbar actionToolbar = ActionManager.getInstance().createActionToolbar(\"\", myActions, true);\n      actionToolbar.setReservePlaceAutoPopupIcon(false);\n      actionToolbar.setMinimumButtonSize(new Dimension(20, 20));\n      toolBar = actionToolbar.getComponent();\n      toolBar.setOpaque(false);\n    }\n\n    PopupChooserBuilder builder = createInnerBuilder().\n      setMovable(true).\n      setResizable(true).\n      setAutoselectOnMouseMove(false).\n      setMayBeParent(true).\n      setDimensionServiceKey(myDimensionServiceKey).\n      setUseDimensionServiceForXYLocation(myDimensionServiceKey != null).\n      setSettingButton(toolBar).\n      setSouthComponent(footerPanel).\n      setItemChoosenCallback(itemCallback).\n      setFilteringEnabled(new Function<Object, String>() {\n        @Override\n        public String fun(Object o) {\n          return ((ItemWrapper)o).speedSearchText();\n        }\n      });\n\n    if (myPopupTuner != null) {\n      myPopupTuner.consume(builder);\n    }\n\n    if (myDoneRunnable != null) {\n      ActionListener actionListener = new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent event) {\n          myDoneRunnable.run();\n        }\n      };\n\n      if ((SystemInfo.isMacOSLion || SystemInfo.isMacOSMountainLion) && !UIUtil.isUnderDarcula()) {\n        final JButton done = new JButton(\"Done\");\n        done.setMnemonic('o');\n        done.addActionListener(actionListener);\n        builder.setCommandButton(new ActiveComponent.Adapter() {\n          @Override\n          public JComponent getComponent() {\n            return done;\n          }\n        });\n      }\n      else {\n        IconButton close = new IconButton(\"Close\", AllIcons.Actions.Close, AllIcons.Actions.CloseHovered);\n        builder.setCommandButton(new InplaceButton(close, actionListener));\n      }\n    }\n\n    String title = myDelegate.getTitle();\n    if (title != null) {\n      builder.setTitle(title);\n    }\n\n    myPopup = builder.createPopup();\n\n    builder.getScrollPane().setBorder(IdeBorderFactory.createBorder(SideBorder.RIGHT));\n\n    myPopup.addListener(new JBPopupListener.Adapter() {\n      @Override\n      public void onClosed(LightweightWindowEvent event) {\n        myDetailView.clearEditor();\n      }\n    });\n\n    if (myDoneRunnable != null) {\n      new AnAction(\"Done\") {\n        @Override\n        public void actionPerformed(AnActionEvent e) {\n          myDoneRunnable.run();\n        }\n      }.registerCustomShortcutSet(KeyEvent.VK_ENTER, InputEvent.CTRL_DOWN_MASK, myPopup.getContent());\n    }\n\n    return myPopup;\n  }","commit_id":"4e892c58a23aac261c139c9dc9f3a9cb4a2252d5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    ProcessHandler activeProcessHandler = getHandler(dataContext);\n\n    Project project = e.getProject();\n    List<Pair<TaskInfo, ProgressIndicator>> backgroundTasks = getCancellableProcesses(project);\n    if (ActionPlaces.isMainMenuOrActionSearch(e.getPlace())) {\n      if (canBeStopped(activeProcessHandler) && backgroundTasks.isEmpty()) {\n        stopProcess(activeProcessHandler);\n        return;\n      }\n\n      Pair<List<HandlerItem>, HandlerItem>\n        handlerItems = getItemsList(backgroundTasks, getActiveDescriptors(dataContext), activeProcessHandler);\n      if (handlerItems == null || handlerItems.first.isEmpty()) {\n        return;\n      }\n\n      final JBList list = new JBList(handlerItems.first);\n      if (handlerItems.second != null) list.setSelectedValue(handlerItems.second, true);\n\n      list.setCellRenderer(new GroupedItemsListRenderer(new ListItemDescriptorAdapter() {\n        @Nullable\n        @Override\n        public String getTextFor(Object value) {\n          return value instanceof HandlerItem ? ((HandlerItem)value).displayName : null;\n        }\n\n        @Nullable\n        @Override\n        public Icon getIconFor(Object value) {\n          return value instanceof HandlerItem ? ((HandlerItem)value).icon : null;\n        }\n\n        @Override\n        public boolean hasSeparatorAboveOf(Object value) {\n          return value instanceof HandlerItem && ((HandlerItem)value).hasSeparator;\n        }\n      }));\n\n      final PopupChooserBuilder builder = JBPopupFactory.getInstance().createListPopupBuilder(list);\n      final JBPopup popup = builder\n        .setMovable(true)\n        .setTitle(handlerItems.first.size() == 1 ? \"Confirm process stop\" : \"Stop process\")\n        .setFilteringEnabled(new Function<Object, String>() {\n          @Override\n          public String fun(Object o) {\n            return ((HandlerItem)o).displayName;\n          }\n        })\n        .setItemChoosenCallback(new Runnable() {\n          @Override\n          public void run() {\n            HandlerItem item = (HandlerItem)list.getSelectedValue();\n            if (item != null) item.stop();\n          }\n        }).setRequestFocus(true).createPopup();\n\n      assert project != null;\n      popup.showCenteredInCurrentWindow(project);\n    }\n    else if (activeProcessHandler != null) {\n      stopProcess(activeProcessHandler);\n    }\n  }","id":83540,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    ProcessHandler activeProcessHandler = getHandler(dataContext);\n\n    Project project = e.getProject();\n    List<Pair<TaskInfo, ProgressIndicator>> backgroundTasks = getCancellableProcesses(project);\n    if (ActionPlaces.isMainMenuOrActionSearch(e.getPlace())) {\n      if (canBeStopped(activeProcessHandler) && backgroundTasks.isEmpty()) {\n        stopProcess(activeProcessHandler);\n        return;\n      }\n\n      Pair<List<HandlerItem>, HandlerItem>\n        handlerItems = getItemsList(backgroundTasks, getActiveDescriptors(dataContext), activeProcessHandler);\n      if (handlerItems == null || handlerItems.first.isEmpty()) {\n        return;\n      }\n\n      final JBList list = new JBList(handlerItems.first);\n      if (handlerItems.second != null) list.setSelectedValue(handlerItems.second, true);\n\n      list.setCellRenderer(new GroupedItemsListRenderer(new ListItemDescriptorAdapter() {\n        @Nullable\n        @Override\n        public String getTextFor(Object value) {\n          return value instanceof HandlerItem ? ((HandlerItem)value).displayName : null;\n        }\n\n        @Nullable\n        @Override\n        public Icon getIconFor(Object value) {\n          return value instanceof HandlerItem ? ((HandlerItem)value).icon : null;\n        }\n\n        @Override\n        public boolean hasSeparatorAboveOf(Object value) {\n          return value instanceof HandlerItem && ((HandlerItem)value).hasSeparator;\n        }\n      }));\n\n      JBPopup popup = JBPopupFactory.getInstance().createListPopupBuilder(list)\n        .setMovable(true)\n        .setTitle(handlerItems.first.size() == 1 ? \"Confirm process stop\" : \"Stop process\")\n        .setFilteringEnabled(new Function<Object, String>() {\n          @Override\n          public String fun(Object o) {\n            return ((HandlerItem)o).displayName;\n          }\n        })\n        .setItemChoosenCallback(new Runnable() {\n          @Override\n          public void run() {\n            HandlerItem item = (HandlerItem)list.getSelectedValue();\n            if (item != null) item.stop();\n          }\n        })\n        .setRequestFocus(true)\n        .createPopup();\n      if (project == null) {\n        popup.showInBestPositionFor(dataContext);\n      }\n      else {\n        popup.showCenteredInCurrentWindow(project);\n      }\n    }\n    else if (activeProcessHandler != null) {\n      stopProcess(activeProcessHandler);\n    }\n  }","commit_id":"26f17744a2fadb54f048ebcfa2c4aef525847abd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void show() {\n    //final long time = System.currentTimeMillis();\n    final ActionCallback treeHasBuilt = new ActionCallback();\n    IdeFocusManager.getInstance(myProject).typeAheadUntil(treeHasBuilt);\n    JComponent panel = createCenterPanel();\n    new MnemonicHelper().register(panel);\n    boolean shouldSetWidth = DimensionService.getInstance().getSize(getDimensionServiceKey(), myProject) == null;\n    myPopup = JBPopupFactory.getInstance().createComponentPopupBuilder(panel, null)\n      .setTitle(myTitle)\n      .setResizable(true)\n      .setFocusable(true)\n      .setMovable(true)\n      //.setCancelOnClickOutside(false) //for debug and snapshots\n      .setCancelKeyEnabled(false)\n      .setDimensionServiceKey(null, getDimensionServiceKey(), false)\n      .createPopup();\n    Disposer.register(myPopup, this);\n    Disposer.register(myPopup, new Disposable() {\n      @Override\n      public void dispose() {\n        if (!treeHasBuilt.isDone()) {\n          treeHasBuilt.setRejected();\n        }\n      }\n    });\n    myPopup.showCenteredInCurrentWindow(myProject);\n\n    ((AbstractPopup)myPopup).setShowHints(true);\n    if (shouldSetWidth) {\n      myPopup.setSize(new Dimension(myPreferredWidth + 10, myPopup.getSize().height));\n    }\n    myAbstractTreeBuilder.expandAll(new Runnable() {\n      @Override\n      public void run() {\n        IdeFocusManager.getInstance(myProject).requestFocus(myTree, true);\n        myAbstractTreeBuilder.queueUpdate().doWhenDone(new Runnable() {\n          @Override\n          public void run() {\n            myInitialPsiElement = getCurrentElement(getPsiFile(myProject));\n            selectPsiElement(myInitialPsiElement);\n            treeHasBuilt.setDone();\n            //long t = System.currentTimeMillis() - time;\n            //System.out.println(\"Shown in \" + t + \"ms\");\n          }\n        });\n      }\n    });\n    final Alarm alarm = new Alarm(Alarm.ThreadToUse.SHARED_THREAD, myPopup);\n    alarm.addRequest(new Runnable() {\n      String filter = \"\";\n      @Override\n      public void run() {\n        alarm.cancelAllRequests();\n        String prefix = mySpeedSearch.getEnteredPrefix();\n        myTree.getEmptyText().setText(StringUtil.isEmpty(prefix) ?  \"Nothing to show\" : \"Can't find '\" + prefix + \"'\");\n        if (prefix == null) prefix = \"\";\n\n        if (!filter.equals(prefix)) {\n          filter = prefix;\n          myAbstractTreeBuilder.refilter(null, false, false).doWhenProcessed(new Runnable() {\n            @Override\n            public void run() {\n              myTree.repaint();\n              //if (mySpeedSearch.isPopupActive()) {\n              //  mySpeedSearch.refreshSelection();\n              //}\n            }\n          });          \n        }\n        alarm.addRequest(this, 300);\n      }\n    }, 300);\n  }","id":83541,"modified_method":"public void show() {\n    //final long time = System.currentTimeMillis();\n    final ActionCallback treeHasBuilt = new ActionCallback();\n    IdeFocusManager.getInstance(myProject).typeAheadUntil(treeHasBuilt);\n    JComponent panel = createCenterPanel();\n    new MnemonicHelper().register(panel);\n    boolean shouldSetWidth = DimensionService.getInstance().getSize(getDimensionServiceKey(), myProject) == null;\n    myPopup = JBPopupFactory.getInstance().createComponentPopupBuilder(panel, null)\n      .setTitle(myTitle)\n      .setResizable(true)\n      .setModalContext(false)\n      .setFocusable(true)\n      .setMovable(true)\n      .setBelongsToGlobalPopupStack(true)\n      //.setCancelOnClickOutside(false) //for debug and snapshots\n      .setCancelKeyEnabled(false)\n      .setDimensionServiceKey(null, getDimensionServiceKey(), false)\n      .setCancelCallback(new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          DimensionService.getInstance().setLocation(getDimensionServiceKey(), myPopup.getLocationOnScreen(), myProject);\n          return true;\n        }\n      })\n      .createPopup();\n    Disposer.register(myPopup, this);\n    Disposer.register(myPopup, new Disposable() {\n      @Override\n      public void dispose() {\n        if (!treeHasBuilt.isDone()) {\n          treeHasBuilt.setRejected();\n        }\n      }\n    });\n    final Point location = DimensionService.getInstance().getLocation(getDimensionServiceKey(), myProject);\n    if (location != null) {\n      myPopup.showInScreenCoordinates(myEditor.getContentComponent(), location);\n    } else {\n      myPopup.showCenteredInCurrentWindow(myProject);\n    }\n\n    ((AbstractPopup)myPopup).setShowHints(true);\n    if (shouldSetWidth) {\n      myPopup.setSize(new Dimension(myPreferredWidth + 10, myPopup.getSize().height));\n    }\n    myAbstractTreeBuilder.expandAll(new Runnable() {\n      @Override\n      public void run() {\n        IdeFocusManager.getInstance(myProject).requestFocus(myTree, true);\n        myAbstractTreeBuilder.queueUpdate().doWhenDone(new Runnable() {\n          @Override\n          public void run() {\n            myInitialPsiElement = getCurrentElement(getPsiFile(myProject));\n            selectPsiElement(myInitialPsiElement);\n            treeHasBuilt.setDone();\n            //long t = System.currentTimeMillis() - time;\n            //System.out.println(\"Shown in \" + t + \"ms\");\n          }\n        });\n      }\n    });\n    final Alarm alarm = new Alarm(Alarm.ThreadToUse.SHARED_THREAD, myPopup);\n    alarm.addRequest(new Runnable() {\n      String filter = \"\";\n\n      @Override\n      public void run() {\n        alarm.cancelAllRequests();\n        String prefix = mySpeedSearch.getEnteredPrefix();\n        myTree.getEmptyText().setText(StringUtil.isEmpty(prefix) ? \"Nothing to show\" : \"Can't find '\" + prefix + \"'\");\n        if (prefix == null) prefix = \"\";\n\n        if (!filter.equals(prefix)) {\n          filter = prefix;\n          myAbstractTreeBuilder.refilter(null, false, false).doWhenProcessed(new Runnable() {\n            @Override\n            public void run() {\n              myTree.repaint();\n              //if (mySpeedSearch.isPopupActive()) {\n              //  mySpeedSearch.refreshSelection();\n              //}\n            }\n          });\n        }\n        alarm.addRequest(this, 300);\n      }\n    }, 300);\n  }","commit_id":"b03d51f1eabe3c0d83a3bf62bccdef4780e902bf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public String computeTemplateKey(@NotNull CustomTemplateCallback callback) {\n    Editor editor = callback.getEditor();\n    int currentOffset = editor.getCaretModel().getOffset();\n    int startOffset = Math.min(editor.getDocument().getLineStartOffset(editor.getDocument().getLineNumber(currentOffset)), currentOffset);\n    CharSequence documentText = editor.getDocument().getCharsSequence();\n    PsiElement prevVisibleLeaf = callback.getContext();\n    while (prevVisibleLeaf != null) {\n      TextRange textRange = prevVisibleLeaf.getTextRange();\n      if (textRange.getEndOffset() <= startOffset) {\n        break;\n      }\n      IElementType prevType = prevVisibleLeaf.getNode().getElementType();\n      if (prevType == XmlTokenType.XML_TAG_END || prevType == XmlTokenType.XML_EMPTY_ELEMENT_END) {\n        startOffset = textRange.getEndOffset();\n        break;\n      }\n      prevVisibleLeaf = PsiTreeUtil.prevVisibleLeaf(prevVisibleLeaf);\n    }\n\n    if (startOffset < 0 || currentOffset > documentText.length() || currentOffset < startOffset) {\n      Logger.getInstance(getClass()).error(\"Error while calculating emmet abbreviation. Offset: \" + currentOffset + \"; Start: \" + startOffset, \n                                           AttachmentFactory.createAttachment(editor.getDocument()));\n      return null;\n    }\n    String key = computeKey(documentText.subSequence(startOffset, currentOffset));\n    return !StringUtil.isEmpty(key) && ZenCodingTemplate.checkTemplateKey(key, callback, this) ? key : null;\n  }","id":83542,"modified_method":"@Nullable\n  @Override\n  public String computeTemplateKey(@NotNull CustomTemplateCallback callback) {\n    Editor editor = callback.getEditor();\n    int currentOffset = editor.getCaretModel().getOffset();\n    int startOffset = Math.min(editor.getDocument().getLineStartOffset(editor.getDocument().getLineNumber(currentOffset)), currentOffset);\n    CharSequence documentText = editor.getDocument().getCharsSequence();\n    PsiElement prevVisibleLeaf = callback.getContext();\n    while (prevVisibleLeaf != null) {\n      TextRange textRange = prevVisibleLeaf.getTextRange();\n      final int endOffset = textRange.getEndOffset();\n      if (endOffset <= currentOffset) {\n        if (endOffset <= startOffset) {\n          break;\n        }\n        IElementType prevType = prevVisibleLeaf.getNode().getElementType();\n        if (prevType == XmlTokenType.XML_TAG_END || prevType == XmlTokenType.XML_EMPTY_ELEMENT_END) {\n          startOffset = endOffset;\n          break;\n        }\n      }\n      prevVisibleLeaf = PsiTreeUtil.prevVisibleLeaf(prevVisibleLeaf); \n    }\n\n    if (startOffset < 0 || currentOffset > documentText.length() || currentOffset < startOffset) {\n      Logger.getInstance(getClass()).error(\"Error while calculating emmet abbreviation. Offset: \" + currentOffset + \"; Start: \" + startOffset, \n                                           AttachmentFactory.createAttachment(editor.getDocument()));\n      return null;\n    }\n    String key = computeKey(documentText.subSequence(startOffset, currentOffset));\n    return !StringUtil.isEmpty(key) && ZenCodingTemplate.checkTemplateKey(key, callback, this) ? key : null;\n  }","commit_id":"f496797b552b8d80b30a5011cca1b328360a3bd7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public TextRange getCodeBlockRange(Editor editor, PsiFile psiFile) {\n    int caretOffset = editor.getCaretModel().getOffset();\n    PsiElement element = psiFile.findElementAt(caretOffset);\n    if (element == null) {\n      return null;\n    }\n    while (caretOffset > 0 && element instanceof PsiWhiteSpace) {\n      caretOffset--;\n      element = psiFile.findElementAt(caretOffset);\n    }\n    PyStatement statement = PsiTreeUtil.getParentOfType(element, PyStatement.class);\n    if (statement != null) {\n      PyStatementList statementList = PsiTreeUtil.findChildOfType(statement, PyStatementList.class);\n\n      // if the statement above caret is not a block statement, look above for a statement list and then find the statement above\n      // that statement list\n      if (statementList == null) {\n        statementList = PsiTreeUtil.getParentOfType(statement, PyStatementList.class);\n        if (statementList != null) {\n          statement = PsiTreeUtil.getParentOfType(statementList, PyStatement.class);\n        }\n      }\n      if (statement != null) {\n        // if we're in the beginning of the statement already, pressing Ctrl-[ again should move the caret one statement higher\n        if (caretOffset == statement.getTextRange().getStartOffset()) {\n          final PyStatement statementAbove = PsiTreeUtil.getParentOfType(statement, PyStatement.class);\n          if (statementAbove != null) {\n            return new TextRange(statementAbove.getTextRange().getStartOffset(), statement.getTextRange().getEndOffset());\n          }\n        }\n        return statement.getTextRange();\n      }\n    }\n    return null;\n  }","id":83543,"modified_method":"@Nullable\n  @Override\n  public TextRange getCodeBlockRange(Editor editor, PsiFile psiFile) {\n    int caretOffset = editor.getCaretModel().getOffset();\n    PsiElement element = psiFile.findElementAt(caretOffset);\n    if (element == null) {\n      return null;\n    }\n    while (caretOffset > 0 && element instanceof PsiWhiteSpace) {\n      caretOffset--;\n      element = psiFile.findElementAt(caretOffset);\n    }\n    PyStatement statement = PsiTreeUtil.getParentOfType(element, PyStatement.class);\n    if (statement != null) {\n      PyStatementList statementList = PsiTreeUtil.findChildOfType(statement, PyStatementList.class);\n\n      // if the statement above caret is not a block statement, look above for a statement list and then find the statement above\n      // that statement list\n      if (statementList == null) {\n        statementList = PsiTreeUtil.getParentOfType(statement, PyStatementList.class);\n        if (statementList != null) {\n          statement = PsiTreeUtil.getParentOfType(statementList, PyStatement.class);\n        }\n      }\n      if (statement != null) {\n        // if we're in the beginning of the statement already, pressing Ctrl-[ again should move the caret one statement higher\n        final int statementStart = statement.getTextRange().getStartOffset();\n        int statementEnd = statement.getTextRange().getEndOffset();\n        while (statementEnd > statementStart && psiFile.findElementAt(statementEnd) instanceof PsiWhiteSpace) {\n          statementEnd--;\n        }\n        if (caretOffset == statementStart || caretOffset == statementEnd) {\n          final PyStatement statementAbove = PsiTreeUtil.getParentOfType(statement, PyStatement.class);\n          if (statementAbove != null) {\n            if (caretOffset == statementStart) {\n              return new TextRange(statementAbove.getTextRange().getStartOffset(), statementEnd);\n            }\n            else {\n              return new TextRange(statementStart, statementAbove.getTextRange().getEndOffset());\n            }\n          }\n        }\n        return statement.getTextRange();\n      }\n    }\n    return null;\n  }","commit_id":"d851ecdab3f654cb28a535f70f23211b45473d9f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitPyStringLiteralExpression(PyStringLiteralExpression pyString) {\n    for (ASTNode node : pyString.getStringNodes()) {\n      final StringNodeInfo nodeInfo = new StringNodeInfo(node);\n      if (nodeInfo.isFormatted()) {\n        final int nodeOffset = node.getTextRange().getStartOffset();\n        final List<FragmentOffsets> fragments = FStringParser.parse(node.getText());\n        boolean hasUnclosedBrace = false;\n        for (FragmentOffsets fragment : fragments) {\n          if (fragment.getLeftBraceOffset() + 1 >= fragment.getContentEndOffset()) {\n            report(fragment.getContentRange().shiftRight(nodeOffset), \"Empty expressions are not allowed inside f-strings\");\n          }\n          if (fragment.getRightBraceOffset() == -1) {\n            hasUnclosedBrace = true;\n          }\n        }\n        if (hasUnclosedBrace) {\n          report(TextRange.from(nodeInfo.getContentRange().getEndOffset(), 0).shiftRight(nodeOffset), \"'}' is expected\");\n        }\n      }\n    }\n  }","id":83544,"modified_method":"@Override\n  public void visitPyStringLiteralExpression(PyStringLiteralExpression pyString) {\n    for (ASTNode node : pyString.getStringNodes()) {\n      final StringNodeInfo nodeInfo = new StringNodeInfo(node);\n      final String nodeText = node.getText();\n      if (nodeInfo.isFormatted()) {\n        final int nodeOffset = node.getTextRange().getStartOffset();\n        final int nodeContentEnd = nodeInfo.getContentRange().getEndOffset();\n        final List<FragmentOffsets> fragments = FStringParser.parse(nodeText);\n        boolean hasUnclosedBrace = false;\n        for (FragmentOffsets fragment : fragments) {\n          final int fragContentEnd = fragment.getContentEndOffset();\n          if (fragment.getLeftBraceOffset() + 1 >= fragContentEnd) {\n            report(fragment.getContentRange().shiftRight(nodeOffset), \"Empty expressions are not allowed inside f-strings\");\n          }\n          if (fragment.getRightBraceOffset() == -1) {\n            hasUnclosedBrace = true;\n          }\n          // Do not warn about illegal conversion character if '!' is right before closing quotes \n          if (fragContentEnd < nodeContentEnd && nodeText.charAt(fragContentEnd) == '!' && fragContentEnd + 1 < nodeContentEnd) {\n            final char conversionChar = nodeText.charAt(fragContentEnd + 1);\n            final int offset = fragContentEnd + nodeOffset + 1;\n            if (fragContentEnd + 1 == fragment.getRightBraceOffset() || conversionChar == ':') {\n              reportEmpty(offset, \"Conversion character is expected: should be one of 's', 'r', 'a'\");\n            }\n            else if (\"sra\".indexOf(conversionChar) < 0) {\n              reportCharacter(offset, \"Illegal conversion character '\" + conversionChar + \"': should be one of 's', 'r', 'a'\");\n            }\n          }\n        }\n        if (hasUnclosedBrace) {\n          reportEmpty(nodeContentEnd + nodeOffset, \"'}' is expected\");\n        }\n      }\n    }\n  }","commit_id":"6ea142ef974df63c4ea9637541a9e272586bbed7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Language evaluateLanguageInRange(final int start, final int end, final PsiFile file, Language lang) {\n    PsiElement elt;\n    int curOffset = start;\n    do {\n      elt = getElementAtOffset(file,curOffset);\n      if (elt == null) break;\n      if (!(elt instanceof PsiWhiteSpace)) {\n        if (!Comparing.equal(lang, findLanguageFromElement(elt,file))) {\n          lang = file.getLanguage();\n          break;\n        }\n      }\n      curOffset = elt.getTextRange().getEndOffset();\n    } while(curOffset < end);\n    return narrowLanguage(lang, file.getLanguage());\n  }","id":83545,"modified_method":"public static Language evaluateLanguageInRange(final int start, final int end, final PsiFile file, Language lang) {\n    PsiElement elt;\n    int curOffset = start;\n    do {\n      elt = getElementAtOffset(file,curOffset);\n      if (elt == null) break;\n      if (!(elt instanceof PsiWhiteSpace)) {\n        if (!Comparing.equal(lang, findLanguageFromElement(elt,file))) {\n          lang = file.getLanguage();\n          break;\n        }\n      }\n      int endOffset = elt.getTextRange().getEndOffset();\n      if (endOffset == curOffset) {\n        endOffset++;\n      }\n      curOffset = endOffset;\n    } while(curOffset < end);\n    return narrowLanguage(lang, file.getLanguage());\n  }","commit_id":"0cc3621fba7d5905bb5d358d5bc03af1fcaeccb7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String addTextRangeToHistory(TextRange textRange, final EditorEx consoleEditor) {\n    final DocumentImpl history = (DocumentImpl)myHistoryViewer.getDocument();\n    final MarkupModel markupModel = history.getMarkupModel(myProject);\n    appendToHistoryDocument(history, myPrompt);\n    markupModel.addRangeHighlighter(history.getTextLength() - myPrompt.length(), history.getTextLength(), HighlighterLayer.SYNTAX,\n                                    ConsoleViewContentType.USER_INPUT.getAttributes(),\n                                    HighlighterTargetArea.EXACT_RANGE);\n\n    final String text = consoleEditor.getDocument().getText(textRange);\n     //offset can be changed after text trimming after insert due to buffer constraints\n    appendToHistoryDocument(history, text);\n    int offset = history.getTextLength() - text.length();\n    final HighlighterIterator iterator = consoleEditor.getHighlighter().createIterator(0);\n    while (!iterator.atEnd()) {\n      final int localOffset = textRange.getStartOffset();\n      final int start = Math.max(iterator.getStart(), localOffset) - localOffset;\n      final int end = Math.min(iterator.getEnd(), textRange.getEndOffset()) - localOffset;\n      markupModel.addRangeHighlighter(start + offset, end + offset, HighlighterLayer.SYNTAX, iterator.getTextAttributes(),\n                                      HighlighterTargetArea.EXACT_RANGE);\n\n      iterator.advance();\n    }\n    if (myDoSaveErrorsToHistory) {\n      duplicateHighlighters(markupModel, consoleEditor.getDocument().getMarkupModel(myProject), offset, textRange);\n      duplicateHighlighters(markupModel, consoleEditor.getMarkupModel(), offset, textRange);\n    }\n    if (!text.endsWith(\"\\n\")) {\n      appendToHistoryDocument(history, \"\\n\");\n    }\n    return text;\n  }","id":83546,"modified_method":"private String addTextRangeToHistory(TextRange textRange, final EditorEx consoleEditor) {\n    final DocumentImpl history = (DocumentImpl)myHistoryViewer.getDocument();\n    final MarkupModel markupModel = history.getMarkupModel(myProject);\n    appendToHistoryDocument(history, myPrompt);\n    markupModel.addRangeHighlighter(history.getTextLength() - myPrompt.length(), history.getTextLength(), HighlighterLayer.SYNTAX,\n                                    ConsoleViewContentType.USER_INPUT.getAttributes(),\n                                    HighlighterTargetArea.EXACT_RANGE);\n\n    final String text = consoleEditor.getDocument().getText(textRange);\n     //offset can be changed after text trimming after insert due to buffer constraints\n    appendToHistoryDocument(history, text);\n    int offset = history.getTextLength() - text.length();\n    final int localOffset = textRange.getStartOffset();\n    final HighlighterIterator iterator = consoleEditor.getHighlighter().createIterator(localOffset);\n    final int localEndOffset = textRange.getEndOffset();\n    while (!iterator.atEnd()) {\n      final int itStart = iterator.getStart();\n      if (itStart > localEndOffset) break;\n      final int itEnd = iterator.getEnd();\n      if (itEnd < localOffset) continue;\n      final int start = Math.max(itStart, localOffset) - localOffset + offset;\n      final int end = Math.min(itEnd, localEndOffset) - localOffset + offset;\n      markupModel.addRangeHighlighter(start, end, HighlighterLayer.SYNTAX, iterator.getTextAttributes(),\n                                      HighlighterTargetArea.EXACT_RANGE);\n\n      iterator.advance();\n    }\n    if (myDoSaveErrorsToHistory) {\n      duplicateHighlighters(markupModel, consoleEditor.getDocument().getMarkupModel(myProject), offset, textRange);\n      duplicateHighlighters(markupModel, consoleEditor.getMarkupModel(), offset, textRange);\n    }\n    if (!text.endsWith(\"\\n\")) {\n      appendToHistoryDocument(history, \"\\n\");\n    }\n    return text;\n  }","commit_id":"97dc0c7efdead5ec5d44339ae31e810264bbba60","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static TextRange getRangeToSelect (@NotNull PsiCodeBlock block) {\n    PsiElement first = block.getFirstBodyElement();\n    if (first instanceof PsiWhiteSpace) {\n      first = first.getNextSibling();\n    }\n    if (first == null) {\n      int offset = block.getTextRange().getStartOffset() + 1;\n      return new TextRange(offset, offset);\n    }\n    PsiJavaToken rBrace = block.getRBrace();\n    PsiElement last = rBrace.getPrevSibling();\n    if (last instanceof PsiWhiteSpace) {\n      last = last.getPrevSibling();\n    }\n    return new TextRange(first.getTextRange().getStartOffset(), last.getTextRange().getEndOffset());\n  }","id":83547,"modified_method":"public static TextRange getRangeToSelect (@NotNull PsiCodeBlock block) {\n    PsiElement first = block.getFirstBodyElement();\n    if (first instanceof PsiWhiteSpace) {\n      first = first.getNextSibling();\n    }\n    if (first == null) {\n      int offset = block.getTextRange().getStartOffset() + 1;\n      return new TextRange(offset, offset);\n    }\n    PsiJavaToken rBrace = block.getRBrace();\n    PsiElement last = rBrace.getPrevSibling();\n    if (last instanceof PsiWhiteSpace) {\n      last = last.getPrevSibling();\n    }\n    final int startOffset = first.getTextRange().getStartOffset();\n    final int endOffset = last.getTextRange().getEndOffset();\n    return startOffset <= endOffset ? new TextRange(startOffset, endOffset) \n                                    : new TextRange(startOffset, startOffset);\n  }","commit_id":"e50817287cbc76ded7809dffae4c17d493d7a53a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public String computeTemplateKey(@NotNull CustomTemplateCallback callback) {\n    Editor editor = callback.getEditor();\n    int currentOffset = editor.getCaretModel().getOffset();\n    int startOffset = Math.min(editor.getDocument().getLineStartOffset(editor.getDocument().getLineNumber(currentOffset)), currentOffset);\n    CharSequence documentText = editor.getDocument().getCharsSequence();\n    PsiElement prevVisibleLeaf = callback.getContext();\n    while (prevVisibleLeaf != null) {\n      TextRange textRange = prevVisibleLeaf.getTextRange();\n      if (textRange.getEndOffset() <= startOffset) {\n        break;\n      }\n      IElementType prevType = prevVisibleLeaf.getNode().getElementType();\n      if (prevType == XmlTokenType.XML_TAG_END || prevType == XmlTokenType.XML_EMPTY_ELEMENT_END) {\n        startOffset = textRange.getEndOffset();\n        break;\n      }\n      prevVisibleLeaf = PsiTreeUtil.prevVisibleLeaf(prevVisibleLeaf);\n    }\n\n    if (startOffset < 0 || currentOffset > documentText.length() || currentOffset < startOffset) {\n      Logger.getInstance(getClass()).error(\"Error while calculating emmet abbreviation. Offset: \" + currentOffset + \"; Start: \" + startOffset, \n                                           AttachmentFactory.createAttachment(editor.getDocument()));\n      return null;\n    }\n    String key = computeKey(documentText.subSequence(startOffset, currentOffset));\n    return !StringUtil.isEmpty(key) && ZenCodingTemplate.checkTemplateKey(key, callback, this) ? key : null;\n  }","id":83548,"modified_method":"@Nullable\n  @Override\n  public String computeTemplateKey(@NotNull CustomTemplateCallback callback) {\n    Editor editor = callback.getEditor();\n    int currentOffset = editor.getCaretModel().getOffset();\n    int startOffset = Math.min(editor.getDocument().getLineStartOffset(editor.getDocument().getLineNumber(currentOffset)), currentOffset);\n    CharSequence documentText = editor.getDocument().getCharsSequence();\n    PsiElement prevVisibleLeaf = callback.getContext();\n    while (prevVisibleLeaf != null) {\n      TextRange textRange = prevVisibleLeaf.getTextRange();\n      final int endOffset = textRange.getEndOffset();\n      if (endOffset > currentOffset) {\n        continue;\n      }\n      if (endOffset <= startOffset) {\n        break;\n      }\n      IElementType prevType = prevVisibleLeaf.getNode().getElementType();\n      if (prevType == XmlTokenType.XML_TAG_END || prevType == XmlTokenType.XML_EMPTY_ELEMENT_END) {\n        startOffset = endOffset;\n        break;\n      }\n      prevVisibleLeaf = PsiTreeUtil.prevVisibleLeaf(prevVisibleLeaf);\n    }\n\n    if (startOffset < 0 || currentOffset > documentText.length() || currentOffset < startOffset) {\n      Logger.getInstance(getClass()).error(\"Error while calculating emmet abbreviation. Offset: \" + currentOffset + \"; Start: \" + startOffset, \n                                           AttachmentFactory.createAttachment(editor.getDocument()));\n      return null;\n    }\n    String key = computeKey(documentText.subSequence(startOffset, currentOffset));\n    return !StringUtil.isEmpty(key) && ZenCodingTemplate.checkTemplateKey(key, callback, this) ? key : null;\n  }","commit_id":"9b60f7b9f8b5a0706c27970b10f1fa9ac2334cfa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean isKeepFileVersionLabel(\n\t\t\tDLFileEntry dlFileEntry, DLFileVersion lastDLFileVersion,\n\t\t\tDLFileVersion latestDLFileVersion, int workflowAction)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (PropsValues.DL_FILE_ENTRY_VERSION_POLICY != 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ((lastDLFileVersion.getFolderId() ==\n\t\t\t\tlatestDLFileVersion.getFolderId()) &&\n\t\t\tValidator.equals(\n\t\t\t\tlastDLFileVersion.getTitle(), latestDLFileVersion.getTitle()) &&\n\t\t\tValidator.equals(\n\t\t\t\tlastDLFileVersion.getDescription(),\n\t\t\t\tlatestDLFileVersion.getDescription()) &&\n\t\t\t(lastDLFileVersion.getFileEntryTypeId() ==\n\t\t\t\tlatestDLFileVersion.getFileEntryTypeId())) {\n\n\t\t\t// Expando\n\n\t\t\tExpandoTable expandoTable = null;\n\n\t\t\ttry {\n\t\t\t\texpandoTable = expandoTableLocalService.getDefaultTable(\n\t\t\t\t\tlastDLFileVersion.getCompanyId(),\n\t\t\t\t\tDLFileEntry.class.getName());\n\t\t\t}\n\t\t\tcatch (NoSuchTableException nste) {\n\t\t\t}\n\n\t\t\tif (expandoTable != null) {\n\t\t\t\tDate lastModifiedDate = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tExpandoRow lastExpandoRow = expandoRowLocalService.getRow(\n\t\t\t\t\t\texpandoTable.getTableId(),\n\t\t\t\t\t\tlastDLFileVersion.getPrimaryKey());\n\n\t\t\t\t\tlastModifiedDate = lastExpandoRow.getModifiedDate();\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchRowException nsre) {\n\t\t\t\t}\n\n\t\t\t\tDate latestModifiedDate = null;\n\n\t\t\t\ttry {\n\t\t\t\t\tExpandoRow latestExpandoRow = expandoRowLocalService.getRow(\n\t\t\t\t\t\texpandoTable.getTableId(),\n\t\t\t\t\t\tlatestDLFileVersion.getPrimaryKey());\n\n\t\t\t\t\tlatestModifiedDate = latestExpandoRow.getModifiedDate();\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchRowException nsre) {\n\t\t\t\t}\n\n\t\t\t\tif (!Validator.equals(lastModifiedDate, latestModifiedDate)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// File entry type\n\n\t\t\tDLFileEntryType dlFileEntryType =\n\t\t\t\tdlFileEntryTypeLocalService.getFileEntryType(\n\t\t\t\t\tlastDLFileVersion.getFileEntryTypeId());\n\n\t\t\tList<DDMStructure> ddmStructures = dlFileEntryType.getDDMStructures();\n\n\t\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\t\tDLFileEntryMetadata lastFileEntryMetadata =\n\t\t\t\t\tdlFileEntryMetadataLocalService.getFileEntryMetadata(\n\t\t\t\t\t\tddmStructure.getStructureId(),\n\t\t\t\t\t\tlastDLFileVersion.getFileVersionId());\n\t\t\t\tDLFileEntryMetadata latestFileEntryMetadata =\n\t\t\t\t\tdlFileEntryMetadataLocalService.getFileEntryMetadata(\n\t\t\t\t\t\tddmStructure.getStructureId(),\n\t\t\t\t\t\tlatestDLFileVersion.getFileVersionId());\n\n\t\t\t\tFields lastFields = StorageEngineUtil.getFields(\n\t\t\t\t\tlastFileEntryMetadata.getDDMStorageId());\n\t\t\t\tFields latestFields = StorageEngineUtil.getFields(\n\t\t\t\t\tlatestFileEntryMetadata.getDDMStorageId());\n\n\t\t\t\tIterator<com.liferay.portlet.dynamicdatamapping.storage.Field>\n\t\t\t\t\tlastItr = lastFields.iterator();\n\t\t\t\tIterator<com.liferay.portlet.dynamicdatamapping.storage.Field>\n\t\t\t\t\tlatestItr = latestFields.iterator();\n\n\t\t\t\twhile (lastItr.hasNext() && latestItr.hasNext()) {\n\t\t\t\t\tcom.liferay.portlet.dynamicdatamapping.storage.Field\n\t\t\t\t\t\tlastField = lastItr.next();\n\t\t\t\t\tcom.liferay.portlet.dynamicdatamapping.storage.Field\n\t\t\t\t\t\tlatestField = latestItr.next();\n\n\t\t\t\t\tif (!lastField.equals(latestField)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (lastItr.hasNext() && !latestItr.hasNext() ||\n\t\t\t\t\t\t!lastItr.hasNext() && latestItr.hasNext()) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Size\n\n\t\t\tlong lastSize = lastDLFileVersion.getSize();\n\t\t\tlong latestSize = latestDLFileVersion.getSize();\n\n\t\t\tif ((lastSize == 0) && ((latestSize == 0) || (latestSize > 0))) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (lastSize != latestSize) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Checksum\n\n\t\t\tInputStream lastInputStream = null;\n\t\t\tInputStream latestInputStream = null;\n\n\t\t\ttry {\n\t\t\t\tString lastChecksum = lastDLFileVersion.getChecksum();\n\n\t\t\t\tif (Validator.isNull(lastChecksum)) {\n\t\t\t\t\tlastInputStream = DLStoreUtil.getFileAsStream(\n\t\t\t\t\t\tdlFileEntry.getCompanyId(),\n\t\t\t\t\t\tdlFileEntry.getDataRepositoryId(),\n\t\t\t\t\t\tdlFileEntry.getName(), lastDLFileVersion.getVersion());\n\n\t\t\t\t\tlastChecksum = DigesterUtil.digestBase64(lastInputStream);\n\n\t\t\t\t\tlastDLFileVersion.setChecksum(lastChecksum);\n\n\t\t\t\t\tdlFileVersionPersistence.update(lastDLFileVersion);\n\t\t\t\t}\n\n\t\t\t\tlatestInputStream = DLStoreUtil.getFileAsStream(\n\t\t\t\t\tdlFileEntry.getCompanyId(),\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tlatestDLFileVersion.getVersion());\n\n\t\t\t\tString latestChecksum = DigesterUtil.digestBase64(\n\t\t\t\t\tlatestInputStream);\n\n\t\t\t\tif (lastChecksum.equals(latestChecksum)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tlatestDLFileVersion.setChecksum(latestChecksum);\n\n\t\t\t\tdlFileVersionPersistence.update(latestDLFileVersion);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tStreamUtil.cleanUp(lastInputStream);\n\t\t\t\tStreamUtil.cleanUp(latestInputStream);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":83549,"modified_method":"protected boolean isKeepFileVersionLabel(\n\t\t\tDLFileEntry dlFileEntry, DLFileVersion lastDLFileVersion,\n\t\t\tDLFileVersion latestDLFileVersion, int workflowAction)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (PropsValues.DL_FILE_ENTRY_VERSION_POLICY != 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlong lastFolderId = lastDLFileVersion.getFolderId();\n\t\tlong latestFolderId = latestDLFileVersion.getFolderId();\n\n\t\tif (lastFolderId != latestFolderId) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString lastTitle = lastDLFileVersion.getTitle();\n\t\tString latestTitle = latestDLFileVersion.getTitle();\n\n\t\tif (!Validator.equals(lastTitle, latestTitle)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString lastDescription = lastDLFileVersion.getDescription();\n\t\tString latestDescription = latestDLFileVersion.getDescription();\n\n\t\tif (!Validator.equals(lastDescription, latestDescription)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlong lastFileEntryTypeId = lastDLFileVersion.getFileEntryTypeId();\n\t\tlong latestFileEntryTypeId = latestDLFileVersion.getFileEntryTypeId();\n\n\t\tif (lastFileEntryTypeId != latestFileEntryTypeId) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Expando\n\n\t\tExpandoTable expandoTable = null;\n\n\t\ttry {\n\t\t\texpandoTable = expandoTableLocalService.getDefaultTable(\n\t\t\t\tlastDLFileVersion.getCompanyId(), DLFileEntry.class.getName());\n\t\t}\n\t\tcatch (NoSuchTableException nste) {\n\t\t}\n\n\t\tif (expandoTable != null) {\n\t\t\tDate lastModifiedDate = null;\n\n\t\t\ttry {\n\t\t\t\tExpandoRow lastExpandoRow = expandoRowLocalService.getRow(\n\t\t\t\t\texpandoTable.getTableId(),\n\t\t\t\t\tlastDLFileVersion.getPrimaryKey());\n\n\t\t\t\tlastModifiedDate = lastExpandoRow.getModifiedDate();\n\t\t\t}\n\t\t\tcatch (NoSuchRowException nsre) {\n\t\t\t}\n\n\t\t\tDate latestModifiedDate = null;\n\n\t\t\ttry {\n\t\t\t\tExpandoRow latestExpandoRow = expandoRowLocalService.getRow(\n\t\t\t\t\texpandoTable.getTableId(),\n\t\t\t\t\tlatestDLFileVersion.getPrimaryKey());\n\n\t\t\t\tlatestModifiedDate = latestExpandoRow.getModifiedDate();\n\t\t\t}\n\t\t\tcatch (NoSuchRowException nsre) {\n\t\t\t}\n\n\t\t\tif (!Validator.equals(lastModifiedDate, latestModifiedDate)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// File entry type\n\n\t\tDLFileEntryType dlFileEntryType =\n\t\t\tdlFileEntryTypeLocalService.getFileEntryType(\n\t\t\t\tlastDLFileVersion.getFileEntryTypeId());\n\n\t\tList<DDMStructure> ddmStructures = dlFileEntryType.getDDMStructures();\n\n\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\tDLFileEntryMetadata lastFileEntryMetadata =\n\t\t\t\tdlFileEntryMetadataLocalService.getFileEntryMetadata(\n\t\t\t\t\tddmStructure.getStructureId(),\n\t\t\t\t\tlastDLFileVersion.getFileVersionId());\n\t\t\tDLFileEntryMetadata latestFileEntryMetadata =\n\t\t\t\tdlFileEntryMetadataLocalService.getFileEntryMetadata(\n\t\t\t\t\tddmStructure.getStructureId(),\n\t\t\t\t\tlatestDLFileVersion.getFileVersionId());\n\n\t\t\tFields lastFields = StorageEngineUtil.getFields(\n\t\t\t\tlastFileEntryMetadata.getDDMStorageId());\n\t\t\tFields latestFields = StorageEngineUtil.getFields(\n\t\t\t\tlatestFileEntryMetadata.getDDMStorageId());\n\n\t\t\tIterator<com.liferay.portlet.dynamicdatamapping.storage.Field>\n\t\t\t\tlastItr = lastFields.iterator();\n\t\t\tIterator<com.liferay.portlet.dynamicdatamapping.storage.Field>\n\t\t\t\tlatestItr = latestFields.iterator();\n\n\t\t\twhile (lastItr.hasNext() && latestItr.hasNext()) {\n\t\t\t\tcom.liferay.portlet.dynamicdatamapping.storage.Field\n\t\t\t\t\tlastField = lastItr.next();\n\t\t\t\tcom.liferay.portlet.dynamicdatamapping.storage.Field\n\t\t\t\t\tlatestField = latestItr.next();\n\n\t\t\t\tif (!lastField.equals(latestField)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (lastItr.hasNext() && !latestItr.hasNext() ||\n\t\t\t\t\t!lastItr.hasNext() && latestItr.hasNext()) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Size\n\n\t\tlong lastSize = lastDLFileVersion.getSize();\n\t\tlong latestSize = latestDLFileVersion.getSize();\n\n\t\tif ((lastSize == 0) && (latestSize >= 0)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (lastSize != latestSize) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Checksum\n\n\t\tInputStream lastInputStream = null;\n\t\tInputStream latestInputStream = null;\n\n\t\ttry {\n\t\t\tString lastChecksum = lastDLFileVersion.getChecksum();\n\n\t\t\tif (Validator.isNull(lastChecksum)) {\n\t\t\t\tlastInputStream = DLStoreUtil.getFileAsStream(\n\t\t\t\t\tdlFileEntry.getCompanyId(),\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tlastDLFileVersion.getVersion());\n\n\t\t\t\tlastChecksum = DigesterUtil.digestBase64(lastInputStream);\n\n\t\t\t\tlastDLFileVersion.setChecksum(lastChecksum);\n\n\t\t\t\tdlFileVersionPersistence.update(lastDLFileVersion);\n\t\t\t}\n\n\t\t\tlatestInputStream = DLStoreUtil.getFileAsStream(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(), latestDLFileVersion.getVersion());\n\n\t\t\tString latestChecksum = DigesterUtil.digestBase64(\n\t\t\t\tlatestInputStream);\n\n\t\t\tif (lastChecksum.equals(latestChecksum)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tlatestDLFileVersion.setChecksum(latestChecksum);\n\n\t\t\tdlFileVersionPersistence.update(latestDLFileVersion);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(lastInputStream);\n\t\t\tStreamUtil.cleanUp(latestInputStream);\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"8ddbcb638cf46c70259cbfb8cceb23d6613f708f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void checkInFileEntry(\n\t\t\tlong userId, long fileEntryId, boolean majorVersion,\n\t\t\tString changeLog, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!isFileEntryCheckedOut(fileEntryId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tboolean webDAVCheckInMode = GetterUtil.getBoolean(\n\t\t\tserviceContext.getAttribute(DL.WEBDAV_CHECK_IN_MODE));\n\n\t\tboolean manualCheckInRequired = dlFileEntry.getManualCheckInRequired();\n\n\t\tif (!webDAVCheckInMode && manualCheckInRequired) {\n\t\t\tdlFileEntry.setManualCheckInRequired(false);\n\n\t\t\tdlFileEntryPersistence.update(dlFileEntry);\n\t\t}\n\n\t\tDLFileVersion lastDLFileVersion =\n\t\t\tdlFileVersionLocalService.getFileVersion(\n\t\t\t\tdlFileEntry.getFileEntryId(), dlFileEntry.getVersion());\n\n\t\tDLFileVersion latestDLFileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(fileEntryId, false);\n\n\t\tboolean retainLabel = false;\n\n\t\tif (!majorVersion) {\n\t\t\tretainLabel = isKeepFileVersionLabel(\n\t\t\t\tdlFileEntry, lastDLFileVersion, latestDLFileVersion,\n\t\t\t\tserviceContext.getWorkflowAction());\n\t\t}\n\n\t\tif (retainLabel) {\n\t\t\tif (lastDLFileVersion.getSize() != latestDLFileVersion.getSize()) {\n\n\t\t\t\t// File version\n\n\t\t\t\tlastDLFileVersion.setExtension(\n\t\t\t\t\tlatestDLFileVersion.getExtension());\n\t\t\t\tlastDLFileVersion.setMimeType(\n\t\t\t\t\tlatestDLFileVersion.getMimeType());\n\t\t\t\tlastDLFileVersion.setSize(latestDLFileVersion.getSize());\n\n\t\t\t\tdlFileVersionPersistence.update(lastDLFileVersion);\n\n\t\t\t\t// File\n\n\t\t\t\ttry {\n\t\t\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\t\t\tdlFileEntry.getName(), lastDLFileVersion.getVersion());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchModelException nsme) {\n\t\t\t\t}\n\n\t\t\t\tDLStoreUtil.copyFileVersion(\n\t\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\t\tdlFileEntry.getName(),\n\t\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION,\n\t\t\t\t\tlastDLFileVersion.getVersion());\n\t\t\t}\n\n\t\t\t// Latest file version\n\n\t\t\tremoveFileVersion(dlFileEntry, latestDLFileVersion);\n\n\t\t\tlatestDLFileVersion = lastDLFileVersion;\n\t\t}\n\t\telse {\n\n\t\t\t// File version\n\n\t\t\tString version = getNextVersion(\n\t\t\t\tdlFileEntry, majorVersion, serviceContext.getWorkflowAction());\n\n\t\t\tlatestDLFileVersion.setVersion(version);\n\t\t\tlatestDLFileVersion.setChangeLog(changeLog);\n\n\t\t\tdlFileVersionPersistence.update(latestDLFileVersion);\n\n\t\t\t// File\n\n\t\t\tDLStoreUtil.updateFileVersion(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(),\n\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION, version);\n\t\t}\n\n\t\t// Folder\n\n\t\tif (dlFileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tdlFileEntry.getFolderId());\n\n\t\t\tdlFolder.setLastPostDate(dlFileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(dlFolder);\n\t\t}\n\n\t\t// Workflow\n\n\t\tif ((serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) && !retainLabel) {\n\n\t\t\tstartWorkflowInstance(\n\t\t\t\tuserId, serviceContext, latestDLFileVersion,\n\t\t\t\tDLSyncConstants.EVENT_UPDATE);\n\t\t}\n\n\t\tunlockFileEntry(fileEntryId);\n\t}","id":83550,"modified_method":"@Override\n\tpublic void checkInFileEntry(\n\t\t\tlong userId, long fileEntryId, boolean majorVersion,\n\t\t\tString changeLog, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!isFileEntryCheckedOut(fileEntryId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDLFileEntry dlFileEntry = dlFileEntryPersistence.findByPrimaryKey(\n\t\t\tfileEntryId);\n\n\t\tboolean webDAVCheckInMode = GetterUtil.getBoolean(\n\t\t\tserviceContext.getAttribute(DL.WEBDAV_CHECK_IN_MODE));\n\n\t\tboolean manualCheckInRequired = dlFileEntry.getManualCheckInRequired();\n\n\t\tif (!webDAVCheckInMode && manualCheckInRequired) {\n\t\t\tdlFileEntry.setManualCheckInRequired(false);\n\n\t\t\tdlFileEntryPersistence.update(dlFileEntry);\n\t\t}\n\n\t\tDLFileVersion lastDLFileVersion =\n\t\t\tdlFileVersionLocalService.getFileVersion(\n\t\t\t\tdlFileEntry.getFileEntryId(), dlFileEntry.getVersion());\n\n\t\tDLFileVersion latestDLFileVersion =\n\t\t\tdlFileVersionLocalService.getLatestFileVersion(fileEntryId, false);\n\n\t\tboolean keepFileVersionLabel = false;\n\n\t\tif (!majorVersion) {\n\t\t\tkeepFileVersionLabel = isKeepFileVersionLabel(\n\t\t\t\tdlFileEntry, lastDLFileVersion, latestDLFileVersion,\n\t\t\t\tserviceContext.getWorkflowAction());\n\t\t}\n\n\t\tif (keepFileVersionLabel) {\n\t\t\tif (lastDLFileVersion.getSize() != latestDLFileVersion.getSize()) {\n\n\t\t\t\t// File version\n\n\t\t\t\tlastDLFileVersion.setExtension(\n\t\t\t\t\tlatestDLFileVersion.getExtension());\n\t\t\t\tlastDLFileVersion.setMimeType(\n\t\t\t\t\tlatestDLFileVersion.getMimeType());\n\t\t\t\tlastDLFileVersion.setSize(latestDLFileVersion.getSize());\n\n\t\t\t\tdlFileVersionPersistence.update(lastDLFileVersion);\n\n\t\t\t\t// File\n\n\t\t\t\ttry {\n\t\t\t\t\tDLStoreUtil.deleteFile(\n\t\t\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\t\t\tdlFileEntry.getName(), lastDLFileVersion.getVersion());\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchModelException nsme) {\n\t\t\t\t}\n\n\t\t\t\tDLStoreUtil.copyFileVersion(\n\t\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\t\tdlFileEntry.getName(),\n\t\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION,\n\t\t\t\t\tlastDLFileVersion.getVersion());\n\t\t\t}\n\n\t\t\t// Latest file version\n\n\t\t\tremoveFileVersion(dlFileEntry, latestDLFileVersion);\n\n\t\t\tlatestDLFileVersion = lastDLFileVersion;\n\t\t}\n\t\telse {\n\n\t\t\t// File version\n\n\t\t\tString version = getNextVersion(\n\t\t\t\tdlFileEntry, majorVersion, serviceContext.getWorkflowAction());\n\n\t\t\tlatestDLFileVersion.setVersion(version);\n\t\t\tlatestDLFileVersion.setChangeLog(changeLog);\n\n\t\t\tdlFileVersionPersistence.update(latestDLFileVersion);\n\n\t\t\t// File\n\n\t\t\tDLStoreUtil.updateFileVersion(\n\t\t\t\tuser.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(),\n\t\t\t\tDLFileEntryConstants.PRIVATE_WORKING_COPY_VERSION, version);\n\t\t}\n\n\t\t// Folder\n\n\t\tif (dlFileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tDLFolder dlFolder = dlFolderPersistence.findByPrimaryKey(\n\t\t\t\tdlFileEntry.getFolderId());\n\n\t\t\tdlFolder.setLastPostDate(dlFileEntry.getModifiedDate());\n\n\t\t\tdlFolderPersistence.update(dlFolder);\n\t\t}\n\n\t\t// Workflow\n\n\t\tif ((serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) && !keepFileVersionLabel) {\n\n\t\t\tstartWorkflowInstance(\n\t\t\t\tuserId, serviceContext, latestDLFileVersion,\n\t\t\t\tDLSyncConstants.EVENT_UPDATE);\n\t\t}\n\n\t\tunlockFileEntry(fileEntryId);\n\t}","commit_id":"4007e08ae9046a7d64d5c60b9eea9d0e9e51f32b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isKeepFileVersionLabel(\n\t\t\tDLFileEntry dlFileEntry, DLFileVersion lastDLFileVersion,\n\t\t\tDLFileVersion latestDLFileVersion, int workflowAction)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (PropsValues.DL_FILE_ENTRY_VERSION_POLICY != 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString lastDescription = lastDLFileVersion.getDescription();\n\t\tString latestDescription = latestDLFileVersion.getDescription();\n\n\t\tif (!Validator.equals(lastDescription, latestDescription)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlong lastFolderId = lastDLFileVersion.getFolderId();\n\t\tlong latestFolderId = latestDLFileVersion.getFolderId();\n\n\t\tif (lastFolderId != latestFolderId) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString lastTitle = lastDLFileVersion.getTitle();\n\t\tString latestTitle = latestDLFileVersion.getTitle();\n\n\t\tif (!Validator.equals(lastTitle, latestTitle)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// File entry type\n\n\t\tlong lastFileEntryTypeId = lastDLFileVersion.getFileEntryTypeId();\n\t\tlong latestFileEntryTypeId = latestDLFileVersion.getFileEntryTypeId();\n\n\t\tif (lastFileEntryTypeId != latestFileEntryTypeId) {\n\t\t\treturn false;\n\t\t}\n\n\t\tDLFileEntryType dlFileEntryType =\n\t\t\tdlFileEntryTypeLocalService.getFileEntryType(\n\t\t\t\tlastDLFileVersion.getFileEntryTypeId());\n\n\t\tList<DDMStructure> ddmStructures = dlFileEntryType.getDDMStructures();\n\n\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\tDLFileEntryMetadata lastFileEntryMetadata =\n\t\t\t\tdlFileEntryMetadataLocalService.getFileEntryMetadata(\n\t\t\t\t\tddmStructure.getStructureId(),\n\t\t\t\t\tlastDLFileVersion.getFileVersionId());\n\t\t\tDLFileEntryMetadata latestFileEntryMetadata =\n\t\t\t\tdlFileEntryMetadataLocalService.getFileEntryMetadata(\n\t\t\t\t\tddmStructure.getStructureId(),\n\t\t\t\t\tlatestDLFileVersion.getFileVersionId());\n\n\t\t\tFields lastFields = StorageEngineUtil.getFields(\n\t\t\t\tlastFileEntryMetadata.getDDMStorageId());\n\t\t\tFields latestFields = StorageEngineUtil.getFields(\n\t\t\t\tlatestFileEntryMetadata.getDDMStorageId());\n\n\t\t\tIterator<com.liferay.portlet.dynamicdatamapping.storage.Field>\n\t\t\t\tlastItr = lastFields.iterator();\n\t\t\tIterator<com.liferay.portlet.dynamicdatamapping.storage.Field>\n\t\t\t\tlatestItr = latestFields.iterator();\n\n\t\t\twhile (lastItr.hasNext() && latestItr.hasNext()) {\n\t\t\t\tcom.liferay.portlet.dynamicdatamapping.storage.Field\n\t\t\t\t\tlastField = lastItr.next();\n\t\t\t\tcom.liferay.portlet.dynamicdatamapping.storage.Field\n\t\t\t\t\tlatestField = latestItr.next();\n\n\t\t\t\tif (!lastField.equals(latestField)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (lastItr.hasNext() && !latestItr.hasNext() ||\n\t\t\t\t\t!lastItr.hasNext() && latestItr.hasNext()) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Expando\n\n\t\tExpandoTable expandoTable = null;\n\n\t\ttry {\n\t\t\texpandoTable = expandoTableLocalService.getDefaultTable(\n\t\t\t\tlastDLFileVersion.getCompanyId(), DLFileEntry.class.getName());\n\t\t}\n\t\tcatch (NoSuchTableException nste) {\n\t\t}\n\n\t\tif (expandoTable != null) {\n\t\t\tDate lastModifiedDate = null;\n\n\t\t\ttry {\n\t\t\t\tExpandoRow lastExpandoRow = expandoRowLocalService.getRow(\n\t\t\t\t\texpandoTable.getTableId(),\n\t\t\t\t\tlastDLFileVersion.getPrimaryKey());\n\n\t\t\t\tlastModifiedDate = lastExpandoRow.getModifiedDate();\n\t\t\t}\n\t\t\tcatch (NoSuchRowException nsre) {\n\t\t\t}\n\n\t\t\tDate latestModifiedDate = null;\n\n\t\t\ttry {\n\t\t\t\tExpandoRow latestExpandoRow = expandoRowLocalService.getRow(\n\t\t\t\t\texpandoTable.getTableId(),\n\t\t\t\t\tlatestDLFileVersion.getPrimaryKey());\n\n\t\t\t\tlatestModifiedDate = latestExpandoRow.getModifiedDate();\n\t\t\t}\n\t\t\tcatch (NoSuchRowException nsre) {\n\t\t\t}\n\n\t\t\tif (!Validator.equals(lastModifiedDate, latestModifiedDate)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Size\n\n\t\tlong lastSize = lastDLFileVersion.getSize();\n\t\tlong latestSize = latestDLFileVersion.getSize();\n\n\t\tif ((lastSize == 0) && (latestSize >= 0)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (lastSize != latestSize) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Checksum\n\n\t\tInputStream lastInputStream = null;\n\t\tInputStream latestInputStream = null;\n\n\t\ttry {\n\t\t\tString lastChecksum = lastDLFileVersion.getChecksum();\n\n\t\t\tif (Validator.isNull(lastChecksum)) {\n\t\t\t\tlastInputStream = DLStoreUtil.getFileAsStream(\n\t\t\t\t\tdlFileEntry.getCompanyId(),\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tlastDLFileVersion.getVersion());\n\n\t\t\t\tlastChecksum = DigesterUtil.digestBase64(lastInputStream);\n\n\t\t\t\tlastDLFileVersion.setChecksum(lastChecksum);\n\n\t\t\t\tdlFileVersionPersistence.update(lastDLFileVersion);\n\t\t\t}\n\n\t\t\tlatestInputStream = DLStoreUtil.getFileAsStream(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(), latestDLFileVersion.getVersion());\n\n\t\t\tString latestChecksum = DigesterUtil.digestBase64(\n\t\t\t\tlatestInputStream);\n\n\t\t\tif (lastChecksum.equals(latestChecksum)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tlatestDLFileVersion.setChecksum(latestChecksum);\n\n\t\t\tdlFileVersionPersistence.update(latestDLFileVersion);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(lastInputStream);\n\t\t\tStreamUtil.cleanUp(latestInputStream);\n\t\t}\n\n\t\treturn false;\n\t}","id":83551,"modified_method":"protected boolean isKeepFileVersionLabel(\n\t\t\tDLFileEntry dlFileEntry, DLFileVersion lastDLFileVersion,\n\t\t\tDLFileVersion latestDLFileVersion, int workflowAction)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (workflowAction == WorkflowConstants.ACTION_SAVE_DRAFT) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (PropsValues.DL_FILE_ENTRY_VERSION_POLICY != 1) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!Validator.equals(\n\t\t\t\tlastDLFileVersion.getDescription(),\n\t\t\t\tlatestDLFileVersion.getDescription())) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (lastDLFileVersion.getFolderId() !=\n\t\t\t\tlatestDLFileVersion.getFolderId()) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!Validator.equals(\n\t\t\t\tlastDLFileVersion.getTitle(), latestDLFileVersion.getTitle())) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// File entry type\n\n\t\tif (lastDLFileVersion.getFileEntryTypeId() !=\n\t\t\t\tlatestDLFileVersion.getFileEntryTypeId()) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tDLFileEntryType dlFileEntryType =\n\t\t\tdlFileEntryTypeLocalService.getFileEntryType(\n\t\t\t\tlastDLFileVersion.getFileEntryTypeId());\n\n\t\tList<DDMStructure> ddmStructures = dlFileEntryType.getDDMStructures();\n\n\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\tDLFileEntryMetadata lastFileEntryMetadata =\n\t\t\t\tdlFileEntryMetadataLocalService.getFileEntryMetadata(\n\t\t\t\t\tddmStructure.getStructureId(),\n\t\t\t\t\tlastDLFileVersion.getFileVersionId());\n\t\t\tDLFileEntryMetadata latestFileEntryMetadata =\n\t\t\t\tdlFileEntryMetadataLocalService.getFileEntryMetadata(\n\t\t\t\t\tddmStructure.getStructureId(),\n\t\t\t\t\tlatestDLFileVersion.getFileVersionId());\n\n\t\t\tFields lastFields = StorageEngineUtil.getFields(\n\t\t\t\tlastFileEntryMetadata.getDDMStorageId());\n\t\t\tFields latestFields = StorageEngineUtil.getFields(\n\t\t\t\tlatestFileEntryMetadata.getDDMStorageId());\n\n\t\t\tIterator<com.liferay.portlet.dynamicdatamapping.storage.Field>\n\t\t\t\tlastItr = lastFields.iterator();\n\t\t\tIterator<com.liferay.portlet.dynamicdatamapping.storage.Field>\n\t\t\t\tlatestItr = latestFields.iterator();\n\n\t\t\twhile (lastItr.hasNext() && latestItr.hasNext()) {\n\t\t\t\tcom.liferay.portlet.dynamicdatamapping.storage.Field\n\t\t\t\t\tlastField = lastItr.next();\n\t\t\t\tcom.liferay.portlet.dynamicdatamapping.storage.Field\n\t\t\t\t\tlatestField = latestItr.next();\n\n\t\t\t\tif (!lastField.equals(latestField)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (lastItr.hasNext() && !latestItr.hasNext() ||\n\t\t\t\t\t!lastItr.hasNext() && latestItr.hasNext()) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Expando\n\n\t\tExpandoTable expandoTable = null;\n\n\t\ttry {\n\t\t\texpandoTable = expandoTableLocalService.getDefaultTable(\n\t\t\t\tlastDLFileVersion.getCompanyId(), DLFileEntry.class.getName());\n\t\t}\n\t\tcatch (NoSuchTableException nste) {\n\t\t}\n\n\t\tif (expandoTable != null) {\n\t\t\tDate lastModifiedDate = null;\n\n\t\t\ttry {\n\t\t\t\tExpandoRow lastExpandoRow = expandoRowLocalService.getRow(\n\t\t\t\t\texpandoTable.getTableId(),\n\t\t\t\t\tlastDLFileVersion.getPrimaryKey());\n\n\t\t\t\tlastModifiedDate = lastExpandoRow.getModifiedDate();\n\t\t\t}\n\t\t\tcatch (NoSuchRowException nsre) {\n\t\t\t}\n\n\t\t\tDate latestModifiedDate = null;\n\n\t\t\ttry {\n\t\t\t\tExpandoRow latestExpandoRow = expandoRowLocalService.getRow(\n\t\t\t\t\texpandoTable.getTableId(),\n\t\t\t\t\tlatestDLFileVersion.getPrimaryKey());\n\n\t\t\t\tlatestModifiedDate = latestExpandoRow.getModifiedDate();\n\t\t\t}\n\t\t\tcatch (NoSuchRowException nsre) {\n\t\t\t}\n\n\t\t\tif (!Validator.equals(lastModifiedDate, latestModifiedDate)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// Size\n\n\t\tlong lastSize = lastDLFileVersion.getSize();\n\t\tlong latestSize = latestDLFileVersion.getSize();\n\n\t\tif ((lastSize == 0) && (latestSize >= 0)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (lastSize != latestSize) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Checksum\n\n\t\tInputStream lastInputStream = null;\n\t\tInputStream latestInputStream = null;\n\n\t\ttry {\n\t\t\tString lastChecksum = lastDLFileVersion.getChecksum();\n\n\t\t\tif (Validator.isNull(lastChecksum)) {\n\t\t\t\tlastInputStream = DLStoreUtil.getFileAsStream(\n\t\t\t\t\tdlFileEntry.getCompanyId(),\n\t\t\t\t\tdlFileEntry.getDataRepositoryId(), dlFileEntry.getName(),\n\t\t\t\t\tlastDLFileVersion.getVersion());\n\n\t\t\t\tlastChecksum = DigesterUtil.digestBase64(lastInputStream);\n\n\t\t\t\tlastDLFileVersion.setChecksum(lastChecksum);\n\n\t\t\t\tdlFileVersionPersistence.update(lastDLFileVersion);\n\t\t\t}\n\n\t\t\tlatestInputStream = DLStoreUtil.getFileAsStream(\n\t\t\t\tdlFileEntry.getCompanyId(), dlFileEntry.getDataRepositoryId(),\n\t\t\t\tdlFileEntry.getName(), latestDLFileVersion.getVersion());\n\n\t\t\tString latestChecksum = DigesterUtil.digestBase64(\n\t\t\t\tlatestInputStream);\n\n\t\t\tif (lastChecksum.equals(latestChecksum)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tlatestDLFileVersion.setChecksum(latestChecksum);\n\n\t\t\tdlFileVersionPersistence.update(latestDLFileVersion);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(e, e);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(lastInputStream);\n\t\t\tStreamUtil.cleanUp(latestInputStream);\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"4007e08ae9046a7d64d5c60b9eea9d0e9e51f32b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public VariableResolver getVariableResolver(String name)\n    {\n        if (event != null)\n        {\n            if (FLOW.equals(name))\n            {\n                return new MuleImmutableVariableResolver<FlowContext>(FLOW, (new FlowContext(\n                    event.getFlowConstruct())), null);\n            }\n            else if (MVELExpressionLanguageContext.MULE_EVENT_INTERNAL_VARIABLE.equals(name))\n            {\n                return new MuleImmutableVariableResolver<MuleEvent>(\n                    MVELExpressionLanguageContext.MULE_EVENT_INTERNAL_VARIABLE, event, null);\n            }\n            else\n            {\n                return super.getVariableResolver(name);\n            }\n        }\n        return null;\n    }","id":83552,"modified_method":"@Override\n    public VariableResolver getVariableResolver(String name)\n    {\n        if (event != null)\n        {\n            if (FLOW.equals(name))\n            {\n                return new MuleImmutableVariableResolver<FlowContext>(FLOW, (new FlowContext(\n                    event.getFlowConstruct())), null);\n            }\n            else if (MVELExpressionLanguageContext.MULE_EVENT_INTERNAL_VARIABLE.equals(name))\n            {\n                return new MuleImmutableVariableResolver<MuleEvent>(\n                    MVELExpressionLanguageContext.MULE_EVENT_INTERNAL_VARIABLE, event, null);\n            }\n        }\n        return super.getVariableResolver(name);\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"public EventVariableResolverFactory(MuleEvent event)\n    {\n        super(event.getMessage());\n        this.event = event;\n    }","id":83553,"modified_method":"public EventVariableResolverFactory(ParserConfiguration parserConfiguration,\n                                        MuleContext muleContext,\n                                        MuleEvent event)\n    {\n        super(parserConfiguration, muleContext, event.getMessage());\n        this.event = event;\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T evaluate(String expression, Map<String, Object> vars)\n    {\n        MVELExpressionLanguageContext context = createExpressionLanguageContext(vars);\n        context.addChildContext(staticContext);\n        context.addChildContext(globalContext);\n        return (T) evaluateInternal(expression, context);\n    }","id":83554,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T evaluate(String expression, Map<String, Object> vars)\n    {\n        MVELExpressionLanguageContext context = createExpressionLanguageContext();\n        if (vars != null)\n        {\n            context.setNextFactory(new CachedMapVariableResolverFactory(vars,\n                new DelegateVariableResolverFactory(staticContext, globalContext)));\n        }\n        else\n        {\n            context.setNextFactory(new DelegateVariableResolverFactory(staticContext, globalContext));\n        }\n        return (T) evaluateInternal(expression, context);\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    @Deprecated\n    public <T> T evaluate(String expression, MuleMessage message, Map<String, Object> vars)\n    {\n        MVELExpressionLanguageContext context = createExpressionLanguageContext(vars);\n        context.addChildContext(staticContext);\n        context.addChildContext(new MessageVariableResolverFactory(message));\n        context.addChildContext(globalContext);\n        if (autoResolveVariables)\n        {\n            context.addChildContext(createVariableVariableResolverFactory(message));\n        }\n        return evaluateInternal(expression, context);\n    }","id":83555,"modified_method":"@Override\n    @Deprecated\n    public <T> T evaluate(String expression, MuleMessage message, Map<String, Object> vars)\n    {\n        MVELExpressionLanguageContext context = createExpressionLanguageContext();\n        if (vars != null)\n        {\n            context.setNextFactory(new CachedMapVariableResolverFactory(vars,\n                new DelegateVariableResolverFactory(staticContext, new MessageVariableResolverFactory(\n                    parserConfiguration, muleContext, message, new DelegateVariableResolverFactory(\n                        globalContext, createVariableVariableResolverFactory(message))))));\n        }\n        else\n        {\n            context.setNextFactory(new DelegateVariableResolverFactory(staticContext,\n                new MessageVariableResolverFactory(parserConfiguration, muleContext, message,\n                    new DelegateVariableResolverFactory(globalContext,\n                        createVariableVariableResolverFactory(message)))));\n        }\n        return evaluateInternal(expression, context);\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"protected MVELExpressionLanguageContext createExpressionLanguageContext(Map<String, Object> vars)\n    {\n        MVELExpressionLanguageContext context = new MVELExpressionLanguageContext(parserConfiguration,\n            muleContext);\n        if (vars != null)\n        {\n            context.addChildContext(new CachedMapVariableResolverFactory(vars));\n        }\n        return context;\n    }","id":83556,"modified_method":"protected MVELExpressionLanguageContext createExpressionLanguageContext()\n    {\n        return new MVELExpressionLanguageContext(parserConfiguration, muleContext);\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"protected VariableResolverFactory createVariableVariableResolverFactory(MuleEvent event)\n    {\n        return new VariableVariableResolverFactory(parserConfiguration, muleContext, event);\n    }","id":83557,"modified_method":"protected VariableResolverFactory createVariableVariableResolverFactory(MuleEvent event)\n    {\n        if (autoResolveVariables)\n        {\n            return new VariableVariableResolverFactory(parserConfiguration, muleContext, event);\n        }\n        else\n        {\n            return null;\n        }\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public <T> T evaluate(String expression, MuleEvent event, Map<String, Object> vars)\n    {\n        MVELExpressionLanguageContext context = createExpressionLanguageContext(vars);\n        context.addChildContext(staticContext);\n        context.addChildContext(new EventVariableResolverFactory(event));\n        context.addChildContext(globalContext);\n        if (autoResolveVariables)\n        {\n            context.addChildContext(createVariableVariableResolverFactory(event));\n        }\n        return evaluateInternal(expression, context);\n    }","id":83558,"modified_method":"@Override\n    public <T> T evaluate(String expression, MuleEvent event, Map<String, Object> vars)\n    {\n        MVELExpressionLanguageContext context = createExpressionLanguageContext();\n        if (vars != null)\n        {\n            context.setNextFactory(new CachedMapVariableResolverFactory(vars,\n                new DelegateVariableResolverFactory(staticContext, new EventVariableResolverFactory(\n                    parserConfiguration, muleContext, event, new DelegateVariableResolverFactory(\n                        globalContext, createVariableVariableResolverFactory(event))))));\n        }\n        else\n        {\n            context.setNextFactory(new DelegateVariableResolverFactory(staticContext,\n                new EventVariableResolverFactory(parserConfiguration, muleContext, event,\n                    new DelegateVariableResolverFactory(globalContext,\n                        createVariableVariableResolverFactory(event)))));\n        }\n        return evaluateInternal(expression, context);\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"public VariableResolver getVariableResolver(String name)\n    {\n        VariableResolver variableResolver = variableResolvers.get(name);\n        if (variableResolver == null)\n        {\n            for (VariableResolverFactory child : children)\n            {\n                if (child.isResolveable(name))\n                {\n                    variableResolver = child.getVariableResolver(name);\n                    break;\n                }\n            }\n            if (variableResolver == null && nextFactory != null)\n            {\n                variableResolver = nextFactory.getVariableResolver(name);\n            }\n        }\n        // In order to allow aliases to use message context without requiring the creating of a\n        // GlobalVariableResolver for each expression evaluation, we create a new resolver on the fly with\n        // current context instead.\n        if (variableResolver instanceof MuleAliasVariableResolver)\n        {\n            variableResolver = new MuleAliasVariableResolver((MuleAliasVariableResolver) variableResolver,\n                this);\n        }\n        return variableResolver;\n    }","id":83559,"modified_method":"public VariableResolver getVariableResolver(String name)\n    {\n        VariableResolver variableResolver = variableResolvers.get(name);\n        if (variableResolver == null)\n        {\n            variableResolver = getNextVariableResolver(name);\n        }\n        // In order to allow aliases to use message context without requiring the creating of a\n        // GlobalVariableResolver for each expression evaluation, we create a new resolver on the fly with\n        // current context instead.\n        if (variableResolver instanceof MuleAliasVariableResolver)\n        {\n            variableResolver = new MuleAliasVariableResolver((MuleAliasVariableResolver) variableResolver,\n                this);\n        }\n        return variableResolver;\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public boolean isTarget(String name)\n    {\n        if (variableResolvers.containsKey(name))\n        {\n            return true;\n        }\n        else\n        {\n            for (VariableResolverFactory child : children)\n            {\n                if (child.isResolveable(name))\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":83560,"modified_method":"@Override\n    public boolean isTarget(String name)\n    {\n        return variableResolvers.containsKey(name);\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public VariableResolver getVariableResolver(String name)\n    {\n        if (muleMessage != null)\n        {\n            if (MESSAGE.equals(name))\n            {\n                return new MuleImmutableVariableResolver<MessageContext>(MESSAGE, new MessageContext(\n                    muleMessage), null);\n            }\n            else if (PAYLOAD.equals(name))\n            {\n                return new MuleVariableResolver<Object>(PAYLOAD, muleMessage.getPayload(), null,\n                    new VariableAssignmentCallback<Object>()\n                    {\n                        @Override\n                        public void assignValue(String name, Object value, Object newValue)\n                        {\n                            muleMessage.setPayload(newValue);\n                        }\n                    });\n            }\n            else if (FLOW_VARS.equals(name))\n            {\n                return new MuleImmutableVariableResolver<Map<String, Object>>(FLOW_VARS,\n                    new MessagePropertyMapContext(muleMessage, PropertyScope.INVOCATION), null);\n            }\n            else if (EXCEPTION.equals(name))\n            {\n                if (muleMessage.getExceptionPayload() != null)\n                {\n                    return new MuleImmutableVariableResolver<Throwable>(EXCEPTION,\n                        muleMessage.getExceptionPayload().getException(), null);\n                }\n                else\n                {\n                    return new MuleImmutableVariableResolver<MuleMessage>(EXCEPTION, null, null);\n                }\n            }\n            else if (SESSION_VARS.equals(name))\n            {\n                return new MuleImmutableVariableResolver<Map<String, Object>>(SESSION_VARS,\n                    new MessagePropertyMapContext(muleMessage, PropertyScope.SESSION), null);\n            }\n            else if (MVELExpressionLanguageContext.MULE_MESSAGE_INTERNAL_VARIABLE.equals(name))\n            {\n                return new MuleImmutableVariableResolver<MuleMessage>(\n                    MVELExpressionLanguageContext.MULE_MESSAGE_INTERNAL_VARIABLE, muleMessage, null);\n            }\n        }\n        return null;\n    }","id":83561,"modified_method":"@Override\n    public VariableResolver getVariableResolver(String name)\n    {\n        if (muleMessage != null)\n        {\n            if (MESSAGE.equals(name))\n            {\n                return new MuleImmutableVariableResolver<MessageContext>(MESSAGE, new MessageContext(\n                    muleMessage), null);\n            }\n            else if (PAYLOAD.equals(name))\n            {\n                return new MuleVariableResolver<Object>(PAYLOAD, muleMessage.getPayload(), null,\n                    new VariableAssignmentCallback<Object>()\n                    {\n                        @Override\n                        public void assignValue(String name, Object value, Object newValue)\n                        {\n                            muleMessage.setPayload(newValue);\n                        }\n                    });\n            }\n            else if (FLOW_VARS.equals(name))\n            {\n                return new MuleImmutableVariableResolver<Map<String, Object>>(FLOW_VARS,\n                    new MessagePropertyMapContext(muleMessage, PropertyScope.INVOCATION), null);\n            }\n            else if (EXCEPTION.equals(name))\n            {\n                if (muleMessage.getExceptionPayload() != null)\n                {\n                    return new MuleImmutableVariableResolver<Throwable>(EXCEPTION,\n                        muleMessage.getExceptionPayload().getException(), null);\n                }\n                else\n                {\n                    return new MuleImmutableVariableResolver<MuleMessage>(EXCEPTION, null, null);\n                }\n            }\n            else if (SESSION_VARS.equals(name))\n            {\n                return new MuleImmutableVariableResolver<Map<String, Object>>(SESSION_VARS,\n                    new MessagePropertyMapContext(muleMessage, PropertyScope.SESSION), null);\n            }\n            else if (MVELExpressionLanguageContext.MULE_MESSAGE_INTERNAL_VARIABLE.equals(name))\n            {\n                return new MuleImmutableVariableResolver<MuleMessage>(\n                    MVELExpressionLanguageContext.MULE_MESSAGE_INTERNAL_VARIABLE, muleMessage, null);\n            }\n        }\n        return super.getNextVariableResolver(name);\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public boolean isTarget(String name)\n    {\n        return MESSAGE.equals(name) || PAYLOAD.equals(name) || FLOW_VARS.equals(name)\n               || EXCEPTION.equals(name) || SESSION_VARS.equals(name)\n               || MVELExpressionLanguageContext.MULE_MESSAGE_INTERNAL_VARIABLE.equals(name);\n    }","id":83562,"modified_method":"public MessageVariableResolverFactory(final ParserConfiguration parserConfiguration,\n                                          final MuleContext muleContext,\n                                          final MuleMessage message)\n    {\n        super(parserConfiguration, muleContext);\n        this.muleMessage = message;\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public VariableResolver getVariableResolver(String name)\n    {\n        if (SERVER.equals(name))\n        {\n            return new MuleImmutableVariableResolver<ServerContext>(SERVER, new ServerContext(), null);\n        }\n        else if (MULE.equals(name))\n        {\n            return new MuleImmutableVariableResolver<MuleInstanceContext>(MULE, new MuleInstanceContext(\n                muleContext), null);\n        }\n        else if (APP.equals(name))\n        {\n            return new MuleImmutableVariableResolver<AppContext>(APP, new AppContext(muleContext), null);\n        }\n        else if (REGEX.equals(name))\n        {\n            return new MuleImmutableVariableResolver<FunctionInstance>(REGEX, regexFunction, null);\n        }\n        else if (DATE_TIME.equals(name))\n        {\n            return new MuleImmutableVariableResolver<FunctionInstance>(DATE_TIME, dateTimeFunction, null);\n        }\n        else if (MVELExpressionLanguageContext.MULE_CONTEXT_INTERNAL_VARIABLE.equals(name))\n        {\n            return new MuleImmutableVariableResolver<MuleContext>(\n                MVELExpressionLanguageContext.MULE_CONTEXT_INTERNAL_VARIABLE, muleContext, null);\n        }\n        else\n        {\n            return super.getVariableResolver(name);\n        }\n    }","id":83563,"modified_method":"public VariableResolver getVariableResolver(String name)\n    {\n        VariableResolver variableResolver = variableResolvers.get(name);\n        if (variableResolver == null)\n        {\n            variableResolver = getNextVariableResolver(name);\n        }\n        return variableResolver;\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"public StaticVariableResolverFactory(ParserConfiguration parserConfiguration, MuleContext muleContext)\n    {\n        super(parserConfiguration, muleContext);\n        regexFunction = new FunctionInstance(new MVELFunctionAdaptor(REGEX,\n            new RegexExpressionLanguageFuntion(), new ParserContext(parserConfiguration)));\n        dateTimeFunction = new FunctionInstance(new MVELFunctionAdaptor(DATE_TIME,\n            new DateTimeExpressionLanguageFuntion(), new ParserContext(parserConfiguration)));\n    }","id":83564,"modified_method":"public StaticVariableResolverFactory(ParserConfiguration parserConfiguration, MuleContext muleContext)\n    {\n        super(parserConfiguration, muleContext);\n        addVariable(\"server\", new ServerContext());\n        addVariable(\"mule\", new MuleInstanceContext(muleContext));\n        addVariable(\"app\", new AppContext(muleContext));\n        declareFunction(\"regex\", new RegexExpressionLanguageFuntion());\n        declareFunction(\"dateTime\", new DateTimeExpressionLanguageFuntion());\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    @Override\n    public VariableResolver getVariableResolver(String name)\n    {\n\n        if (message != null && message.getInvocationPropertyNames().contains(name))\n        {\n            return new FlowVariableVariableResolver(name);\n        }\n        else if (message != null && message.getSessionPropertyNames().contains(name))\n        {\n            return new SessionVariableVariableResolver(name);\n        }\n        else if (nextFactory.isResolveable(name))\n        {\n            return nextFactory.getVariableResolver(name);\n        }\n        else\n        {\n            return null;\n        }\n    }","id":83565,"modified_method":"@SuppressWarnings(\"deprecation\")\n    @Override\n    public VariableResolver getVariableResolver(String name)\n    {\n\n        if (message != null && message.getInvocationPropertyNames().contains(name))\n        {\n            return new FlowVariableVariableResolver(name);\n        }\n        else if (message != null && message.getSessionPropertyNames().contains(name))\n        {\n            return new SessionVariableVariableResolver(name);\n        }\n        else\n        {\n            return super.getNextVariableResolver(name);\n        }\n    }","commit_id":"387a10daf35c313e0c4e6472e34ed42bfb8d2c7e","url":"https://github.com/mulesoft/mule"},{"original_method":"@SuppressWarnings( \"unchecked\" )\n  T doSetReferer( final R referer, final Reference.State preconditionState, final Reference.State finalState ) throws ResourceAllocationException {\n    this.checkPreconditions( preconditionState );\n    if ( ( referer != null ) && !Reference.State.PENDING.equals( finalState ) ) {\n      final R refererEntity = referer;\n      this.setReference( refererEntity );\n      this.setState( finalState );\n    } else {\n      this.setReference( null );\n      this.setState( finalState );\n    }\n    return ( T ) this;\n  }","id":83566,"modified_method":"@SuppressWarnings( \"unchecked\" )\n  T doSetReferer( final R referer, final Reference.State preconditionState, final Reference.State finalState ) throws ResourceAllocationException {\n    this.checkPreconditions( referer, preconditionState, finalState );\n    if ( ( referer != null ) && !Reference.State.PENDING.equals( finalState ) ) {\n      final R refererEntity = referer;\n      this.setReference( refererEntity );\n      this.setState( finalState );\n    } else {\n      this.setReference( null );\n      this.setState( finalState );\n    }\n    return ( T ) this;\n  }","commit_id":"1b8bf602aa59d364aba85d5593b1f5cce0b70aaa","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void checkPreconditions( final Reference.State preconditionState ) throws RuntimeException {\n    if ( ( !Entities.hasTransaction( this ) ) ) {\n      throw new RuntimeException( \"Error allocating resource \" + PersistentReference.this.getClass( ).getSimpleName( ) + \" with id \"\n                                  + this.getDisplayName( ) + \" as there is no ongoing transaction.\" );\n    }\n    if ( ( this.getState( ) != null ) && ( preconditionState != null ) && !preconditionState.equals( this.getState( ) ) ) {\n      throw new RuntimeException( \"Error allocating resource \" + PersistentReference.this.getClass( ).getSimpleName( ) + \" with id \"\n                                  + this.getDisplayName( ) + \" as the state is not \" + preconditionState.name( ) + \" (currently \"\n                                  + this.getState( ) + \").\" );\n    }\n  }","id":83567,"modified_method":"private void checkPreconditions( R referer, final Reference.State preconditionState, Reference.State finalState ) throws RuntimeException {\n    if ( ( !Entities.hasTransaction( this ) ) ) {\n      throw new RuntimeException( \"Error allocating resource \" + PersistentReference.this.getClass( ).getSimpleName( ) + \" with id \"\n                                  + this.getDisplayName( ) + \" as there is no ongoing transaction.\" );\n    }\n    State currentState = this.getState( );\n    boolean matchPrecondition = preconditionState == null || ( currentState != null && preconditionState.equals( currentState ) );\n    boolean matchFinal = ( finalState == null && currentState == null ) || ( finalState != null && currentState != null && finalState.equals( currentState ) );\n    boolean matchReferer = ( this.getReference( ) == null ) || ( referer != null && this.getReference( ) != null && referer.equals( this.getReference( ) ) );\n    if ( ( matchFinal && matchReferer ) || matchPrecondition ) {\n      return;\n    } else {\n      throw new RuntimeException( \"Error allocating resource \" + PersistentReference.this.getClass( ).getSimpleName( )\n        + \" with id \"\n        + this.getDisplayName( )\n        + \" as the state is not either the precondition \"\n        + preconditionState.name( )\n        + \" or the final state \"\n        + finalState.name( )\n        + \" (currently \"\n        + currentState.name( )\n        + \", referer \"\n        + this.getReference( )\n        + \", passed referer \"\n        + referer\n        + \")\" );\n    }\n  }","commit_id":"1b8bf602aa59d364aba85d5593b1f5cce0b70aaa","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@GET\n    @Path(\"complete\")\n    public Response completeAuthentication(@Context OidcClientTokenContext oidcContext) {\n        stateManager.setClientTokenContext(mc, oidcContext);\n        URI redirectUri = null;\n        String location = oidcContext.getState().getFirst(\"state\");\n        if (location == null) {\n            String basePath = (String)mc.get(\"http.base.path\");\n            redirectUri = UriBuilder.fromUri(basePath).path(defaultLocation).build();\n        } else {\n            redirectUri = URI.create(location);\n        }\n        return Response.seeOther(redirectUri).build();\n    }","id":83568,"modified_method":"@GET\n    @Path(\"complete\")\n    public Response completeAuthentication(@Context OidcClientTokenContext oidcContext) {\n        stateManager.setClientTokenContext(mc, oidcContext);\n        URI redirectUri = null;\n        MultivaluedMap<String, String> state = oidcContext.getState();\n        String location = state != null ? state.getFirst(\"state\") : null;\n        if (location == null) {\n            String basePath = (String)mc.get(\"http.base.path\");\n            redirectUri = UriBuilder.fromUri(basePath).path(defaultLocation).build();\n        } else {\n            redirectUri = URI.create(location);\n        }\n        return Response.seeOther(redirectUri).build();\n    }","commit_id":"557dc292f63176ba971ebc8c8e23e1fb74c5c4a1","url":"https://github.com/apache/cxf"},{"original_method":"@POST\n    @Path(\"complete\")\n    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n    public Response completeScriptAuthentication(MultivaluedMap<String, String> map) {\n        String idTokenParamValue = map.getFirst(tokenFormParameter);\n        OidcClientTokenContextImpl ctx = new OidcClientTokenContextImpl();\n        ctx.setIdToken(userInfoClient.getIdToken(idTokenParamValue, consumer.getKey()));\n        return completeAuthentication(ctx);   \n    }","id":83569,"modified_method":"@POST\n    @Path(\"signin\")\n    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n    public Response completeScriptAuthentication(MultivaluedMap<String, String> map) {\n        String idTokenParamValue = map.getFirst(tokenFormParameter);\n        OidcClientTokenContextImpl ctx = new OidcClientTokenContextImpl();\n        ctx.setIdToken(idTokenValidator.getIdToken(idTokenParamValue, consumer.getKey()));\n        return completeAuthentication(ctx);   \n    }","commit_id":"557dc292f63176ba971ebc8c8e23e1fb74c5c4a1","url":"https://github.com/apache/cxf"},{"original_method":"protected void setToBeShown(boolean value, boolean onOk) {\n    if (onOk) {\n      ((ReadonlyStatusHandlerImpl)ReadonlyStatusHandler.getInstance(myProject)).getState().SHOW_DIALOG = value;\n    }\n  }","id":83570,"modified_method":"@Override\n  protected void setToBeShown(boolean value, boolean onOk) {\n    if (onOk) {\n      ReadonlyStatusHandlerImpl.State state = ((ReadonlyStatusHandlerImpl)ReadonlyStatusHandler.getInstance(myProject)).getState();\n      if (state != null) {\n        state.SHOW_DIALOG = value;\n      }\n    }\n  }","commit_id":"6db69c4a1ff1c528c5ad77d531225e262a13a66b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doOKAction() {\n    for(FileInfo info: myFiles) {\n      if (myUsingFileSystemRadioButton.isSelected()) {\n        info.getHandleType().selectFirst();\n      }\n      else if (info.hasVersionControl()) {\n        info.getHandleType().select(info.getHandleType().get(1));\n      }\n    }\n\n    ArrayList<FileInfo> files = new ArrayList<FileInfo>();\n    Collections.addAll(files, myFiles);\n    String changelist = (String)myChangelist.getSelectedItem();\n    ReadonlyStatusHandlerImpl.processFiles(files, changelist);\n\n    if (files.isEmpty()) {\n      super.doOKAction();\n    }\n    else {\n      myFiles = files.toArray(new FileInfo[files.size()]);\n      initFileList();\n    }\n  }","id":83571,"modified_method":"@Override\n  protected void doOKAction() {\n    for (FileInfo info : myFiles) {\n      if (myUsingFileSystemRadioButton.isSelected()) {\n        info.getHandleType().selectFirst();\n      }\n      else if (info.hasVersionControl()) {\n        info.getHandleType().select(info.getHandleType().get(1));\n      }\n    }\n\n    List<FileInfo> files = new ArrayList<FileInfo>();\n    Collections.addAll(files, myFiles);\n    String changelist = (String)myChangelist.getSelectedItem();\n    ReadonlyStatusHandlerImpl.processFiles(files, changelist);\n\n    if (files.isEmpty()) {\n      super.doOKAction();\n    }\n    else {\n      String list = StringUtil.join(files, new Function<FileInfo, String>() {\n        @Override\n        public String fun(FileInfo info) {\n          return info.getFile().getPresentableUrl();\n        }\n      }, \"<br>\");\n      String message = VcsBundle.message(\"handle.ro.file.status.failed\", list);\n      Messages.showErrorDialog(getRootPane(), message, VcsBundle.message(\"dialog.title.clear.read.only.file.status\"));\n      myFiles = files.toArray(new FileInfo[files.size()]);\n      initFileList();\n    }\n  }","commit_id":"6db69c4a1ff1c528c5ad77d531225e262a13a66b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean isToBeShown() {\n    return ((ReadonlyStatusHandlerImpl)ReadonlyStatusHandler.getInstance(myProject)).getState().SHOW_DIALOG;\n  }","id":83572,"modified_method":"@Override\n  protected boolean isToBeShown() {\n    ReadonlyStatusHandlerImpl.State state = ((ReadonlyStatusHandlerImpl)ReadonlyStatusHandler.getInstance(myProject)).getState();\n    return state != null && state.SHOW_DIALOG;\n  }","commit_id":"6db69c4a1ff1c528c5ad77d531225e262a13a66b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ReadOnlyStatusDialog(Project project, final FileInfo[] files) {\n    super(project);\n    myFiles = files;\n    initFileList();\n\n    ActionListener listener = new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myChangelist.setEnabled(myUsingVcsRadioButton.isSelected());\n      }\n    };\n    myUsingVcsRadioButton.addActionListener(listener);\n    myUsingFileSystemRadioButton.addActionListener(listener);\n    \n    if (myUsingVcsRadioButton.isEnabled()) {\n      myUsingVcsRadioButton.setSelected(true);\n    }\n    else {\n      myUsingFileSystemRadioButton.setSelected(true);\n    }\n    myChangelist.setEnabled(myUsingVcsRadioButton.isSelected());\n    myFileList.setCellRenderer(new FileListRenderer());\n    setTitle(VcsBundle.message(\"dialog.title.clear.read.only.file.status\"));\n\n    init();\n  }","id":83573,"modified_method":"public ReadOnlyStatusDialog(Project project, final FileInfo[] files) {\n    super(project);\n    setTitle(VcsBundle.message(\"dialog.title.clear.read.only.file.status\"));\n    myFiles = files;\n    initFileList();\n\n    ActionListener listener = new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myChangelist.setEnabled(myUsingVcsRadioButton.isSelected());\n      }\n    };\n    myUsingVcsRadioButton.addActionListener(listener);\n    myUsingFileSystemRadioButton.addActionListener(listener);\n    (myUsingVcsRadioButton.isEnabled() ? myUsingVcsRadioButton : myUsingFileSystemRadioButton).setSelected(true);\n    myChangelist.setEnabled(myUsingVcsRadioButton.isSelected());\n\n    //noinspection unchecked\n    myFileList.setCellRenderer(new FileListRenderer());\n\n    init();\n  }","commit_id":"6db69c4a1ff1c528c5ad77d531225e262a13a66b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isModelRootOrParent(VirtualFile virtualFile) {\n    if (!(virtualFile.isDirectory())) return false;\n\n    Module module = ModuleUtil.findModuleForFile(virtualFile, myProject);\n    if (module == null) return false;\n    MPSFacet mpsFacet = FacetManager.getInstance(module).getFacetByType(MPSFacetType.ID);\n    if (mpsFacet == null || !(mpsFacet.wasInitialized())) return false;\n\n    String url = virtualFile.getUrl();\n    if (!LocalFileSystem.PROTOCOL.equals(VirtualFileManager.extractProtocol(url))) return false;\n\n    String path = VirtualFileManager.extractPath(url);\n    for (ModelRoot mr : mpsFacet.getConfiguration().getState().getModelRoots()) {\n      if (mr.getPath().startsWith(path)) return true;\n    }\n    return false;\n  }","id":83574,"modified_method":"private boolean isModelRootOrParent(VirtualFile virtualFile) {\n    if (!(virtualFile.isDirectory())) return false;\n\n    Module module = ModuleUtil.findModuleForFile(virtualFile, myProject);\n    if (module == null) return false;\n    MPSFacet mpsFacet = FacetManager.getInstance(module).getFacetByType(MPSFacetType.ID);\n    if (mpsFacet == null || !(mpsFacet.wasInitialized())) return false;\n\n    MPSConfigurationBean configurationBean = mpsFacet.getConfiguration().getState();\n    if (configurationBean == null) return false;\n\n    String url = virtualFile.getUrl();\n    if (!LocalFileSystem.PROTOCOL.equals(VirtualFileManager.extractProtocol(url))) return false;\n\n    String path = VirtualFileManager.extractPath(url);\n\n    for (ModelRoot mr : configurationBean.getModelRoots()) {\n      if (mr.getPath().startsWith(path)) return true;\n    }\n    return false;\n  }","commit_id":"9a0f1f4917b84261736853ef4b32e131812a0a8f","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean hasModelRoots(Module module) {\n    if (module == null) return false;\n    MPSFacet mpsFacet = FacetManager.getInstance(module).getFacetByType(MPSFacetType.ID);\n    return mpsFacet != null && mpsFacet.wasInitialized() && !(mpsFacet.getConfiguration().getState().getModelRoots().isEmpty());\n  }","id":83575,"modified_method":"private boolean hasModelRoots(Module module) {\n    if (module == null) return false;\n    MPSFacet mpsFacet = FacetManager.getInstance(module).getFacetByType(MPSFacetType.ID);\n    if(mpsFacet == null || !mpsFacet.wasInitialized()) return false;\n\n    MPSConfigurationBean configurationBean = mpsFacet.getConfiguration().getState();\n    return configurationBean != null && !(configurationBean.getModelRoots().isEmpty());\n  }","commit_id":"9a0f1f4917b84261736853ef4b32e131812a0a8f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ComponentState(String first, Object second) {\n      this.first = first;\n    }","id":83576,"modified_method":"public ComponentState(String first, Element second) {\n      this.first = first;\n      this.second = second;\n    }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void init(MPSProject project) {\n    myProject = project.getComponent(Project.class);\n    myCustomPartsToDispose = initCustomParts(project);\n\n    initEditors(project);\n\n    myPrefsComponents = createPreferencesComponents(getIDEAProject());\n    for (BaseProjectPrefsComponent component : myPrefsComponents) {\n      component.init();\n    }\n\n    myTools = (List) (initTools(myProject));\n    final Project ideaProject = getIDEAProject();\n    for (final GeneratedTool tool : myTools) {\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          if (ideaProject.isDisposed()) return;\n          try {\n            tool.init(ideaProject);\n          } catch (Throwable t) {\n            LOG.error(t);\n          }\n          doAdd(tool, false);\n          myInitializedTools.add(tool);\n        }\n      });\n    }\n  }","id":83577,"modified_method":"public void init(MPSProject project) {\n    myProject = project.getComponent(Project.class);\n    myCustomPartsToDispose = initCustomParts(project);\n\n    initEditors(project);\n\n    myTools = (List) (initTools(myProject));\n    final Project ideaProject = getIDEAProject();\n    for (final GeneratedTool tool : myTools) {\n      if (ideaProject.isDisposed()) return;\n      try {\n        tool.init(ideaProject);\n      } catch (Throwable t) {\n        LOG.error(t);\n      }\n      doAdd(tool, false);\n      myInitializedTools.add(tool);\n    }\n\n    myPrefsComponents = createPreferencesComponents(getIDEAProject());\n    for (BaseProjectPrefsComponent component : myPrefsComponents) {\n      component.init();\n    }\n  }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MyState getState() {\n    MyState state = new MyState();\n    for (BaseProjectPrefsComponent component : myPrefsComponents) {\n      state.myComponentsState.add(new ComponentState(component.getClass().getName(), component.getState()));\n    }\n    return state;\n  }","id":83578,"modified_method":"public PluginState getState() {\n    PluginState state = new PluginState();\n    for (BaseProjectPrefsComponent component : myPrefsComponents) {\n      state.myComponentsState.add(new ComponentState(component.getClass().getName(), component.getState()));\n    }\n    return state;\n  }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void dispose() {\n    for (BaseCustomProjectPlugin customPart : myCustomPartsToDispose) {\n      customPart.dispose();\n    }\n    myCustomPartsToDispose.clear();\n\n    for (final GeneratedTool tool : myTools) {\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          if (!myInitializedTools.contains(tool)) return;\n          try {\n            tool.dispose();\n          } catch (Throwable t) {\n            LOG.error(t);\n          }\n          tool.unregister();\n        }\n      });\n    }\n    myTools.clear();\n\n    for (BaseProjectPrefsComponent component : myPrefsComponents) {\n      component.dispose();\n    }\n\n    MPSEditorOpener opener = myProject.getComponent(MPSEditorOpener.class);\n    if (opener != null) {\n      opener.unregisterOpenHandlers(this);\n    }\n  }","id":83579,"modified_method":"public void dispose() {\n    for (BaseCustomProjectPlugin customPart : myCustomPartsToDispose) {\n      customPart.dispose();\n    }\n    myCustomPartsToDispose.clear();\n\n    for (BaseProjectPrefsComponent component : myPrefsComponents) {\n      component.dispose();\n    }\n\n    for (final GeneratedTool tool : myTools) {\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          if (!myInitializedTools.contains(tool)) return;\n          try {\n            tool.dispose();\n          } catch (Throwable t) {\n            LOG.error(t);\n          }\n          tool.unregister();\n        }\n      });\n    }\n    myTools.clear();\n\n    MPSEditorOpener opener = myProject.getComponent(MPSEditorOpener.class);\n    if (opener != null) {\n      opener.unregisterOpenHandlers(this);\n    }\n  }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void loadState(MyState state) {\n    HashMap<String, BaseProjectPrefsComponent> components = new HashMap<String, BaseProjectPrefsComponent>();\n    for (BaseProjectPrefsComponent component : myPrefsComponents) {\n      components.put(component.getClass().getName(), component);\n    }\n\n    for (ComponentState componentState : state.myComponentsState) {\n      if (componentState.second == null) return;\n      components.get(componentState.first).loadState(componentState.second);\n    }\n  }","id":83580,"modified_method":"public void loadState(PluginState state) {\n    HashMap<String, BaseProjectPrefsComponent> components = new HashMap<String, BaseProjectPrefsComponent>();\n    for (BaseProjectPrefsComponent component : myPrefsComponents) {\n      components.put(component.getClass().getName(), component);\n    }\n\n    for (ComponentState componentState : state.myComponentsState) {\n      if (componentState.second == null) return;\n      components.get(componentState.first).loadState(componentState.second);\n    }\n  }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void spreadState() {\n    HashMap<String, BaseProjectPlugin> plugins = new HashMap<String, BaseProjectPlugin>();\n    for (BaseProjectPlugin plugin : myPlugins) {\n      plugins.put(plugin.getClass().getName(), plugin);\n    }\n\n    for (PluginState pluginState : myState.myPluginsState) {\n      plugins.get(pluginState.first).loadState((jetbrains.mps.plugins.projectplugins.BaseProjectPlugin.MyState) pluginState.second);\n    }\n  }","id":83581,"modified_method":"protected void spreadState() {\n    HashMap<String, BaseProjectPlugin> plugins = new HashMap<String, BaseProjectPlugin>();\n    for (BaseProjectPlugin plugin : myPlugins) {\n      PluginState state = myState.pluginsState.get(plugin.getClass().getName());\n      if (state != null) {\n        plugin.loadState(state);\n      }\n    }\n  }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void collectState() {\n    myState.myPluginsState.clear();\n    for (BaseProjectPlugin plugin : myPlugins) {\n      myState.myPluginsState.add(new PluginState(plugin.getClass().getName(), plugin.getState()));\n    }\n  }","id":83582,"modified_method":"protected void collectState() {\n    myState.pluginsState.clear();\n    for (BaseProjectPlugin plugin : myPlugins) {\n      PluginState state = plugin.getState();\n      if (state != null) {\n        myState.pluginsState.put(plugin.getClass().getName(), state);\n      }\n    }\n  }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void loadPlugins() {\n    if (isLoaded) return;\n    Set<Language> languages = new HashSet<Language>();\n    Set<DevKit> devkits = new HashSet<DevKit>();\n\n    MPSProject mpsProject = myProject.getComponent(MPSProjectHolder.class).getMPSProject();\n\n    for (Solution s : mpsProject.getProjectSolutions()) {\n      languages.addAll(s.getScope().getVisibleLanguages());\n      devkits.addAll(s.getScope().getVisibleDevkits());\n    }\n\n    for (Language l : mpsProject.getProjectLanguages()) {\n      languages.add(l);\n    }\n\n    languages.addAll(LibraryManager.getInstance().getGlobalModules(Language.class));\n    devkits.addAll(LibraryManager.getInstance().getGlobalModules(DevKit.class));\n\n    for (DevKit dk : mpsProject.getProjectDevKits()) {\n      devkits.add(dk);\n    }\n\n    for (Language language : languages) {\n      if (language.getPluginModelDescriptor() != null) {\n        Class pluginClass = language.getClass(language.getGeneratedPluginClassLongName());\n        if (pluginClass != null) {\n          addPlugin(language, language.getGeneratedPluginClassLongName());\n        }\n      }\n    }\n\n    for (DevKit dk : devkits) {\n      if (dk.getDevKitPluginClass() != null) {\n        addPlugin(dk, dk.getDevKitPluginClass());\n      }\n    }\n\n    addIdePlugin();\n\n    for (BaseProjectPlugin plugin : myPlugins) {\n      try {\n        plugin.init(mpsProject);\n      } catch (Throwable t1) {\n        LOG.error(\"Plugin \" + plugin + \" threw an exception during initialization \", t1);\n      }\n    }\n    spreadState();\n    isLoaded = true;\n  }","id":83583,"modified_method":"private void loadPlugins() {\n    if (isLoaded) return;\n    Set<Language> languages = new HashSet<Language>();\n    Set<DevKit> devkits = new HashSet<DevKit>();\n\n    final MPSProject mpsProject = myProject.getComponent(MPSProjectHolder.class).getMPSProject();\n\n    for (Solution s : mpsProject.getProjectSolutions()) {\n      languages.addAll(s.getScope().getVisibleLanguages());\n      devkits.addAll(s.getScope().getVisibleDevkits());\n    }\n\n    for (Language l : mpsProject.getProjectLanguages()) {\n      languages.add(l);\n    }\n\n    languages.addAll(LibraryManager.getInstance().getGlobalModules(Language.class));\n    devkits.addAll(LibraryManager.getInstance().getGlobalModules(DevKit.class));\n\n    for (DevKit dk : mpsProject.getProjectDevKits()) {\n      devkits.add(dk);\n    }\n\n    for (Language language : languages) {\n      if (language.getPluginModelDescriptor() != null) {\n        Class pluginClass = language.getClass(language.getGeneratedPluginClassLongName());\n        if (pluginClass != null) {\n          addPlugin(language, language.getGeneratedPluginClassLongName());\n        }\n      }\n    }\n\n    for (DevKit dk : devkits) {\n      if (dk.getDevKitPluginClass() != null) {\n        addPlugin(dk, dk.getDevKitPluginClass());\n      }\n    }\n\n    addIdePlugin();\n\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        for (BaseProjectPlugin plugin : myPlugins) {\n          try {\n            plugin.init(mpsProject);\n          } catch (Throwable t1) {\n            LOG.error(\"Plugin \" + plugin + \" threw an exception during initialization \", t1);\n          }\n        }\n        spreadState();\n        isLoaded = true;\n      }\n    });\n  }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void loadState(MyState state) {\n    myState = state;\n  }","id":83584,"modified_method":"public void loadState(PluginsState state) {\n    myState = state;\n  }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MyState getState() {\n    collectState();\n    return myState;\n  }","id":83585,"modified_method":"public PluginsState getState() {\n    collectState();\n    return myState;\n  }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void runTestWithParameters(final TestRunParameters parameters, final List<SNode> tests) {\n    final List<String> params = ListSequence.<String>fromArray();\n    this.addJavaCommand(params);\n    if (this.unitTestPreferences.getState().useDebug) {\n      this.addDebug(params, this.unitTestPreferences.getState().debugPort, false);\n    }\n    ListSequence.fromList(params).addSequence(ListSequence.fromList(parameters.getVmParameters()));\n    this.addDebugParameters(params);\n    ModelAccess.instance().runReadAction(new Runnable() {\n\n      public void run() {\n        UnitTestRunner.this.addClassPath(params, UnitTestRunner.this.getClasspathString(ListSequence.fromList(tests).first(), parameters.getCalssPath()));\n      }\n\n    });\n    ListSequence.fromList(params).addElement(parameters.getTestRunner());\n    ModelAccess.instance().runReadAction(new Runnable() {\n\n      public void run() {\n        for (SNode test : tests) {\n          ListSequence.fromList(params).addSequence(ListSequence.fromList(ITestable_Behavior.call_getParametersPart_1215620460293(test)));\n        }\n      }\n\n    });\n    ProcessBuilder p = new ProcessBuilder(params);\n    this.component.appendInternal(this.getCommandString(p) + \"\\n\\n\");\n    try {\n      Process pro = p.start();\n      UnitTestRunOutputReader outReader = new UnitTestRunOutputReader(pro.getInputStream(), this.component, false);\n      UnitTestRunOutputReader errReader = new UnitTestRunOutputReader(pro.getErrorStream(), this.component, true);\n      CyclicBarrier barrier = new CyclicBarrier(2, outReader.getExecutor());\n      outReader.setBarrier(barrier);\n      errReader.setBarrier(barrier);\n      outReader.start();\n      errReader.start();\n      pro.waitFor();\n    } catch (Exception e) {\n      Logger.getLogger(UnitTestRunner.class).error(\"Can't run tests\", e);\n    }\n  }","id":83586,"modified_method":"private void runTestWithParameters(final TestRunParameters parameters, final List<SNode> tests) {\n    final List<String> params = ListSequence.<String>fromArray();\n    this.addJavaCommand(params);\n    if (this.unitTestPreferences.getStateObject().useDebug) {\n      this.addDebug(params, this.unitTestPreferences.getStateObject().debugPort, false);\n    }\n    ListSequence.fromList(params).addSequence(ListSequence.fromList(parameters.getVmParameters()));\n    this.addDebugParameters(params);\n    ModelAccess.instance().runReadAction(new Runnable() {\n\n      public void run() {\n        UnitTestRunner.this.addClassPath(params, UnitTestRunner.this.getClasspathString(ListSequence.fromList(tests).first(), parameters.getCalssPath()));\n      }\n\n    });\n    ListSequence.fromList(params).addElement(parameters.getTestRunner());\n    ModelAccess.instance().runReadAction(new Runnable() {\n\n      public void run() {\n        for (SNode test : tests) {\n          ListSequence.fromList(params).addSequence(ListSequence.fromList(ITestable_Behavior.call_getParametersPart_1215620460293(test)));\n        }\n      }\n\n    });\n    ProcessBuilder p = new ProcessBuilder(params);\n    this.component.appendInternal(this.getCommandString(p) + \"\\n\\n\");\n    try {\n      Process pro = p.start();\n      UnitTestRunOutputReader outReader = new UnitTestRunOutputReader(pro.getInputStream(), this.component, false);\n      UnitTestRunOutputReader errReader = new UnitTestRunOutputReader(pro.getErrorStream(), this.component, true);\n      CyclicBarrier barrier = new CyclicBarrier(2, outReader.getExecutor());\n      outReader.setBarrier(barrier);\n      errReader.setBarrier(barrier);\n      outReader.start();\n      errReader.start();\n      pro.waitFor();\n    } catch (Exception e) {\n      Logger.getLogger(UnitTestRunner.class).error(\"Can't run tests\", e);\n    }\n  }","commit_id":"1cb0ce2a77383d3256a3366bdb29f41e4fbab6d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"private <T> void commitPersistentComponent(@NotNull final PersistentStateComponent<T> persistentStateComponent,\n                                             @NotNull StateStorageManager.ExternalizationSession session) {\n    Storage[] storageSpecs = getComponentStorageSpecs(persistentStateComponent, StateStorageOperation.WRITE);\n\n    session\n        .setState(storageSpecs, persistentStateComponent, getComponentName(persistentStateComponent), persistentStateComponent.getState());\n  }","id":83587,"modified_method":"private <T> void commitPersistentComponent(@NotNull final PersistentStateComponent<T> persistentStateComponent,\n                                             @NotNull StateStorageManager.ExternalizationSession session) {\n    Storage[] storageSpecs = getComponentStorageSpecs(persistentStateComponent, StateStorageOperation.WRITE);\n\n    T state = persistentStateComponent.getState();\n    if (state != null) {\n      session\n        .setState(storageSpecs, persistentStateComponent, getComponentName(persistentStateComponent), state);\n    }\n  }","commit_id":"0fa63dcd655ec532876fdf54daa5313f2b06293f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private Element getJdomState(final Object component, final String componentName, @NotNull final StateStorage defaultsStorage)\n      throws StateStorage.StateStorageException {\n    ComponentRoamingManager roamingManager = ComponentRoamingManager.getInstance();\n    if (!roamingManager.typeSpecified(componentName)) {\n      if (component instanceof RoamingTypeDisabled) {\n         roamingManager.setRoamingType(componentName, RoamingType.DISABLED);\n      }\n      else if (component instanceof RoamingTypePerPlatform) {\n        roamingManager.setRoamingType(componentName, RoamingType.PER_PLATFORM);\n      }\n      else {\n        roamingManager.setRoamingType(componentName, RoamingType.PER_USER);\n      }\n    }\n    return defaultsStorage.getState(component, componentName, Element.class, null);\n  }","id":83588,"modified_method":"@Nullable\n  private Element getJdomState(final Object component, final String componentName, @NotNull final StateStorage defaultsStorage)\n      throws StateStorage.StateStorageException {\n    ComponentRoamingManager roamingManager = ComponentRoamingManager.getInstance();\n    if (!roamingManager.typeSpecified(componentName)) {\n      if (component instanceof RoamingTypeDisabled) {\n         roamingManager.setRoamingType(componentName, RoamingType.DISABLED);\n      }\n      else if (component instanceof RoamingTypePerPlatform) {\n        roamingManager.setRoamingType(componentName, RoamingType.PER_PLATFORM);\n      }\n      /*else {\n        roamingManager.setRoamingType(componentName, RoamingType.PER_USER);\n      }*/\n    }\n    return defaultsStorage.getState(component, componentName, Element.class, null);\n  }","commit_id":"0fa63dcd655ec532876fdf54daa5313f2b06293f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void writeExternal(Element element) throws WriteExternalException {\n    ConfigurationState state = new ConfigurationState();\n    state.myServerName = myServerName;\n    if (myDeploymentSource != null) {\n      DeploymentItemState itemState;\n      if (myDeploymentSource instanceof ArtifactDeploymentSource) {\n        itemState = new ArtifactDeploymentSettingsState(((ArtifactDeploymentSource)myDeploymentSource).getArtifactPointer().getArtifactName());\n      }\n      else if (myDeploymentSource instanceof ModuleDeploymentSource) {\n        itemState = new ModuleDeploymentSettingsState(((ModuleDeploymentSource)myDeploymentSource).getModulePointer().getModuleName());\n      }\n      else {\n        throw new WriteExternalException(\"Unknown source \" + myDeploymentSource);\n      }\n      if (myDeploymentConfiguration != null) {\n        itemState.setSettings(XmlSerializer.serialize(myDeploymentConfiguration.getSerializer().getState(), SERIALIZATION_FILTERS));\n      }\n      state.myDeploymentItemState.add(itemState);\n    }\n    XmlSerializer.serializeInto(state, element, SERIALIZATION_FILTERS);\n    super.writeExternal(element);\n  }","id":83589,"modified_method":"@Override\n  public void writeExternal(Element element) throws WriteExternalException {\n    ConfigurationState state = new ConfigurationState();\n    state.myServerName = myServerName;\n    if (myDeploymentSource != null) {\n      DeploymentItemState itemState;\n      if (myDeploymentSource instanceof ArtifactDeploymentSource) {\n        itemState = new ArtifactDeploymentSettingsState(((ArtifactDeploymentSource)myDeploymentSource).getArtifactPointer().getArtifactName());\n      }\n      else if (myDeploymentSource instanceof ModuleDeploymentSource) {\n        itemState = new ModuleDeploymentSettingsState(((ModuleDeploymentSource)myDeploymentSource).getModulePointer().getModuleName());\n      }\n      else {\n        throw new WriteExternalException(\"Unknown source \" + myDeploymentSource);\n      }\n      if (myDeploymentConfiguration != null) {\n        Object configurationState = myDeploymentConfiguration.getSerializer().getState();\n        if (configurationState != null) {\n          itemState.setSettings(XmlSerializer.serialize(configurationState, SERIALIZATION_FILTERS));\n        }\n      }\n      state.myDeploymentItemState.add(itemState);\n    }\n    XmlSerializer.serializeInto(state, element, SERIALIZATION_FILTERS);\n    super.writeExternal(element);\n  }","commit_id":"d7024945c57afa2d520616008427618f35678e32","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static String getSDKInstallPath(@Nullable Module module, @NotNull Project project) {\n    if (module != null) {\n      Library[] libraries = LibrariesUtil.getLibrariesByCondition(module, new Condition<Library>() {\n        public boolean value(Library library1) {\n          return isSDKLibrary(library1);\n        }\n      });\n      if (libraries.length != 0) {\n        final String home = getGantLibraryHome(libraries[0]);\n        if (StringUtil.isNotEmpty(home)) {\n          return home;\n        }\n      }\n    }\n\n    final String home = GantSettings.getInstance(project).getState().SDK_HOME;\n    if (StringUtil.isNotEmpty(home)) {\n      return home;\n    }\n    return \"\";\n  }","id":83590,"modified_method":"@NotNull\n  public static String getSDKInstallPath(@Nullable Module module, @NotNull Project project) {\n    if (module != null) {\n      Library[] libraries = LibrariesUtil.getLibrariesByCondition(module, new Condition<Library>() {\n        public boolean value(Library library1) {\n          return isSDKLibrary(library1);\n        }\n      });\n      if (libraries.length != 0) {\n        final String home = getGantLibraryHome(libraries[0]);\n        if (StringUtil.isNotEmpty(home)) {\n          return home;\n        }\n      }\n    }\n\n    final SdkHomeConfigurable.SdkHomeSettings state = GantSettings.getInstance(project).getState();\n    if (state != null) {\n      final String home = state.SDK_HOME;\n      if (StringUtil.isNotEmpty(home)) {\n        return home;\n      }\n    }\n    return \"\";\n  }","commit_id":"f7208f5f3cb92e97485f3d027025ea240c6b60fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static String getDeviceState(@NotNull IDevice device) {\n    return capitalize(device.getState().name().toLowerCase());\n  }","id":83591,"modified_method":"@NotNull\n  private static String getDeviceState(@NotNull IDevice device) {\n    IDevice.DeviceState state = device.getState();\n    return state != null ? capitalize(state.name().toLowerCase()) : \"\";\n  }","commit_id":"fa63c096d0b8253a826795e48e11c38a7c60d9b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Object referenceMacro_GetReferent_1201868923347(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83592,"modified_method":"public static Object referenceMacro_GetReferent_1201868923347(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1525847198352075387(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getAncestor(_context.getNode(), \"jetbrains.mps.lang.quotation.structure.Quotation\", false, false), \"map\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83593,"modified_method":"public static Object referenceMacro_GetReferent_1525847198352075387(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getAncestor(_context.getNode(), \"jetbrains.mps.lang.quotation.structure.Quotation\", false, false), \"map\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1196351887466(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getParent(_context.getNode()), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83594,"modified_method":"public static Object referenceMacro_GetReferent_1196351887466(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getParent(_context.getNode()), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1525847198352096750(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getAncestor(_context.getNode(), \"jetbrains.mps.lang.quotation.structure.Quotation\", false, false), \"map\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83595,"modified_method":"public static Object referenceMacro_GetReferent_1525847198352096750(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getAncestor(_context.getNode(), \"jetbrains.mps.lang.quotation.structure.Quotation\", false, false), \"map\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_473655348865090435(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83596,"modified_method":"public static Object referenceMacro_GetReferent_473655348865090435(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1196860192984(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getParent(_context.getNode()), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83597,"modified_method":"public static Object referenceMacro_GetReferent_1196860192984(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getParent(_context.getNode()), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1525847198352015013(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83598,"modified_method":"public static Object referenceMacro_GetReferent_1525847198352015013(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1525847198352014965(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83599,"modified_method":"public static Object referenceMacro_GetReferent_1525847198352014965(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1025590056396681336(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode().getReferenceTarget(\"sourceNode\"), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83600,"modified_method":"public static Object referenceMacro_GetReferent_1025590056396681336(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode().getReferenceTarget(\"sourceNode\"), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1025590056396681361(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode().getReferenceTarget(\"targetNode\"), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83601,"modified_method":"public static Object referenceMacro_GetReferent_1025590056396681361(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode().getReferenceTarget(\"targetNode\"), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1201870201455(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83602,"modified_method":"public static Object referenceMacro_GetReferent_1201870201455(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1201868926381(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83603,"modified_method":"public static Object referenceMacro_GetReferent_1201868926381(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1525847198352015051(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83604,"modified_method":"public static Object referenceMacro_GetReferent_1525847198352015051(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(_context.getNode(), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object referenceMacro_GetReferent_1196351887115(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return SNodeOperations.cast(_context.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getParent(_context.getNode()), \"nodeVariable\"), \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n  }","id":83605,"modified_method":"public static Object referenceMacro_GetReferent_1196351887115(final IOperationContext operationContext, final ReferenceMacroContext _context) {\n    return _context.getOutputNodeByInputNodeAndMappingLabel(SNodeOperations.getParent(_context.getNode()), \"nodeVariable\");\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected SNode applyPart0(@NotNull final TemplateExecutionEnvironment environment, @NotNull final TemplateContext context) throws GenerationException {\n    final SNode tnode1 = new SNode(\"jetbrains.mps.baseLanguageInternal.structure.ExtractStaticMethodExpression\");\n    try {\n      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a1);\n      environment.nodeCopied(context, tnode1, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396661195\");\n\n      {\n        final SNode tnode2 = new SNode(\"jetbrains.mps.baseLanguageInternal.structure.ExtractStaticMethod_CallExpression\");\n        try {\n          environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a1);\n          environment.nodeCopied(context, tnode2, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396668027\");\n          environment.resolveInTemplateLater(tnode2, \"baseMethodDeclaration\", new SNodePointer(\"r:00000000-0000-4000-0000-011c8959034c(jetbrains.mps.lang.quotation.generator.baseLanguage.template.main@generator)\", \"1025590056396668027\"), \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396661196\", \"_quotation_createNode\", context);\n\n          {\n            final List<SNode> tlist3 = new ArrayList();\n            try {\n              environment.getTracer().pushMacro(loopMacroRef_3njegt_a0a0a1a4a1a3a1a1);\n              final Iterable<SNode> loopList3 = QueriesGenerated.sourceNodesQuery_1025590056396691724(environment.getOperationContext(), new SourceSubstituteMacroNodesContext(context.getInput(), null, loopMacroRef_3njegt_a0a0a1a4a1a3a1a1, context, environment.getGenerator()));\n              for (SNode itnode3 : loopList3) {\n                if (itnode3 == null) {\n                  continue;\n                }\n                boolean inputChanged3 = context.getInput() != itnode3;\n                try {\n                  if (inputChanged3) {\n                    environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(itnode3));\n                  }\n                  TemplateContext context3 = context.subContext(null, itnode3);\n                  Collection<SNode> tlist4 = null;\n                  try {\n                    environment.getTracer().pushMacro(copySrcMacro_3njegt_a0a0a3a2a2a1a4a1a3a1a1);\n                    final SNode copySrcInput4 = QueriesGenerated.sourceNodeQuery_1025590056396691788(environment.getOperationContext(), new SourceSubstituteMacroNodeContext(context3.getInput(), copySrcMacro_3njegt_a0a0a3a2a2a1a4a1a3a1a1, context3, environment.getGenerator()));\n                    tlist4 = environment.copyNodes(TemplateUtil.singletonList(copySrcInput4), copySrcMacro_3njegt_a0a0a3a2a2a1a4a1a3a1a1, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396691722\", null, context3);\n                  } finally {\n                    environment.getTracer().closeMacro(copySrcMacro_3njegt_a0a0a3a2a2a1a4a1a3a1a1);\n                  }\n                  if (tlist4 != null) {\n                    tlist3.addAll(tlist4);\n                  }\n                } finally {\n                  if (inputChanged3) {\n                    environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(itnode3));\n                  }\n                }\n              }\n            } finally {\n              environment.getTracer().closeMacro(loopMacroRef_3njegt_a0a0a1a4a1a3a1a1);\n            }\n            for (SNode child5 : TemplateUtil.asNotNull(tlist3)) {\n              tnode2.addChild(\"actualArgument\", child5);\n            }\n            // TODO validate child \n          }\n        } finally {\n          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode2));\n          environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a1);\n        }\n        if (tnode2 != null) {\n          tnode1.addChild(\"inner\", tnode2);\n        }\n        // TODO validate child \n      }\n      {\n        Collection<SNode> tlist6 = null;\n        try {\n          environment.getTracer().pushMacro(nodeMacroRef_3njegt_a0a0a1a4a1a1);\n          TemplateContext context6 = context.subContext(\"quotationStaticMethod\");\n          final SNode tnode7 = new SNode(\"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration\");\n          try {\n            environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a3a1a4a1a1);\n            environment.nodeCopied(context6, tnode7, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396661196\");\n            tnode7.setProperty(\"name\", TemplateUtil.asString(QueriesGenerated.propertyMacro_GetPropertyValue_1025590056397541505(environment.getOperationContext(), new PropertyMacroContext(context6.getInput(), \"_quotation_createNode\", propertyMacro_3njegt_c0b0b0a2a3a1a4a1a1, context6, environment.getGenerator()))));\n\n            {\n              final SNode tnode8 = new SNode(\"jetbrains.mps.baseLanguage.structure.PrivateVisibility\");\n              try {\n                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a3a1a4a1a1);\n                environment.nodeCopied(context6, tnode8, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056400639397\");\n\n              } finally {\n                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode8));\n                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a3a1a4a1a1);\n              }\n              if (tnode8 != null) {\n                tnode7.addChild(\"visibility\", tnode8);\n              }\n              // TODO validate child \n            }\n            {\n              final SNode tnode9 = new SNode(\"jetbrains.mps.lang.smodel.structure.SNodeType\");\n              try {\n                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a5a3a1a4a1a1);\n                environment.nodeCopied(context6, tnode9, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396674747\");\n\n              } finally {\n                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode9));\n                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a5a3a1a4a1a1);\n              }\n              if (tnode9 != null) {\n                tnode7.addChild(\"returnType\", tnode9);\n              }\n              // TODO validate child \n            }\n            {\n              final List<SNode> tlist10 = new ArrayList();\n              try {\n                environment.getTracer().pushMacro(loopMacroRef_3njegt_a0a0a1a6a3a1a4a1a1);\n                final Iterable<SNode> loopList10 = QueriesGenerated.sourceNodesQuery_1025590056396672113(environment.getOperationContext(), new SourceSubstituteMacroNodesContext(context6.getInput(), null, loopMacroRef_3njegt_a0a0a1a6a3a1a4a1a1, context6, environment.getGenerator()));\n                for (SNode itnode10 : loopList10) {\n                  if (itnode10 == null) {\n                    continue;\n                  }\n                  boolean inputChanged10 = context6.getInput() != itnode10;\n                  try {\n                    if (inputChanged10) {\n                      environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(itnode10));\n                    }\n                    TemplateContext context10 = context6.subContext(\"parametersFromExpressions\", itnode10);\n                    final SNode tnode11 = new SNode(\"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\");\n                    try {\n                      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a6a3a1a4a1a1);\n                      environment.nodeCopied(context10, tnode11, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396672110\");\n                      tnode11.setProperty(\"name\", TemplateUtil.asString(QueriesGenerated.propertyMacro_GetPropertyValue_1025590056396672173(environment.getOperationContext(), new PropertyMacroContext(context10.getInput(), \"a\", propertyMacro_3njegt_c0b0b0a2a3a2a2a1a6a3a1a4a1a1, context10, environment.getGenerator()))));\n\n                      {\n                        final SNode tnode12 = new SNode(\"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n                        try {\n                          environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a3a2a2a1a6a3a1a4a1a1);\n                          environment.nodeCopied(context10, tnode12, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396672111\");\n                          tnode12.setReference(\"classifier\", SReference.create(\"classifier\", tnode12, SModelReference.fromString(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\"), SNodeId.fromString(\"~Object\")));\n\n                        } finally {\n                          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode12));\n                          environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a3a2a2a1a6a3a1a4a1a1);\n                        }\n                        if (tnode12 != null) {\n                          tnode11.addChild(\"type\", tnode12);\n                        }\n                        // TODO validate child \n                      }\n                    } finally {\n                      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode11));\n                      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a6a3a1a4a1a1);\n                    }\n                    if (tnode11 != null) {\n                      environment.registerLabel(itnode10, tnode11, \"parametersFromExpressions\");\n                      tlist10.add(tnode11);\n                    }\n                  } finally {\n                    if (inputChanged10) {\n                      environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(itnode10));\n                    }\n                  }\n                }\n              } finally {\n                environment.getTracer().closeMacro(loopMacroRef_3njegt_a0a0a1a6a3a1a4a1a1);\n              }\n              for (SNode child13 : TemplateUtil.asNotNull(tlist10)) {\n                tnode7.addChild(\"parameter\", child13);\n              }\n              // TODO validate child \n            }\n            {\n              final SNode tnode14 = new SNode(\"jetbrains.mps.baseLanguage.structure.StatementList\");\n              try {\n                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a7a3a1a4a1a1);\n                environment.nodeCopied(context6, tnode14, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396661199\");\n\n                {\n                  final SNode tnode15 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\");\n                  try {\n                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a7a3a1a4a1a1);\n                    environment.nodeCopied(context6, tnode15, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681206\");\n\n                    {\n                      final SNode tnode16 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n                      try {\n                        environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a3a1a7a3a1a4a1a1);\n                        environment.nodeCopied(context6, tnode16, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681207\");\n                        tnode16.setProperty(\"name\", \"result\");\n\n                        {\n                          final SNode tnode17 = new SNode(\"jetbrains.mps.baseLanguage.structure.NullLiteral\");\n                          try {\n                            environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a1a3a1a7a3a1a4a1a1);\n                            environment.nodeCopied(context6, tnode17, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681208\");\n\n                          } finally {\n                            environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode17));\n                            environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a1a3a1a7a3a1a4a1a1);\n                          }\n                          if (tnode17 != null) {\n                            tnode16.addChild(\"initializer\", tnode17);\n                          }\n                          // TODO validate child \n                        }\n                        {\n                          final SNode tnode18 = new SNode(\"jetbrains.mps.lang.smodel.structure.SNodeType\");\n                          try {\n                            environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a5a1a3a1a3a1a7a3a1a4a1a1);\n                            environment.nodeCopied(context6, tnode18, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681209\");\n\n                          } finally {\n                            environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode18));\n                            environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a5a1a3a1a3a1a7a3a1a4a1a1);\n                          }\n                          if (tnode18 != null) {\n                            tnode16.addChild(\"type\", tnode18);\n                          }\n                          // TODO validate child \n                        }\n                      } finally {\n                        environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode16));\n                        environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a3a1a7a3a1a4a1a1);\n                      }\n                      if (tnode16 != null) {\n                        tnode15.addChild(\"localVariableDeclaration\", tnode16);\n                      }\n                      // TODO validate child \n                    }\n                  } finally {\n                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode15));\n                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a7a3a1a4a1a1);\n                  }\n                  if (tnode15 != null) {\n                    tnode14.addChild(\"statement\", tnode15);\n                  }\n                  // TODO validate child \n                }\n                {\n                  final SNode tnode19 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\");\n                  try {\n                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a7a3a1a4a1a1);\n                    environment.nodeCopied(context6, tnode19, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681210\");\n\n                    {\n                      Collection<SNode> tlist20 = null;\n                      try {\n                        environment.getTracer().pushMacro(ifMacroRef_3njegt_a0a0a1a3a1a4a1a7a3a1a4a1a1);\n                        TemplateContext context20 = context6.subContext(\"map\");\n                        if (QueriesGenerated.ifMacro_Condition_1025590056396681218(environment.getOperationContext(), new IfMacroContext(context6.getInput(), ifMacroRef_3njegt_a0a0a1a3a1a4a1a7a3a1a4a1a1, context6, environment.getGenerator()))) {\n                          final SNode tnode21 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n                          try {\n                            environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                            environment.nodeCopied(context20, tnode21, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681211\");\n                            tnode21.setProperty(\"name\", \"_parameterValues_129834374\");\n\n                            {\n                              final SNode tnode22 = new SNode(\"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n                              try {\n                                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                                environment.nodeCopied(context20, tnode22, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681212\");\n                                tnode22.setReference(\"classifier\", SReference.create(\"classifier\", tnode22, SModelReference.fromString(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.util(JDK/java.util@java_stub)\"), SNodeId.fromString(\"~Set\")));\n\n                                {\n                                  final SNode tnode23 = new SNode(\"jetbrains.mps.lang.smodel.structure.SNodeType\");\n                                  try {\n                                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a4a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                                    environment.nodeCopied(context20, tnode23, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681213\");\n\n                                  } finally {\n                                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode23));\n                                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a4a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                                  }\n                                  if (tnode23 != null) {\n                                    tnode22.addChild(\"parameter\", tnode23);\n                                  }\n                                  // TODO validate child \n                                }\n                              } finally {\n                                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode22));\n                                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                              }\n                              if (tnode22 != null) {\n                                tnode21.addChild(\"type\", tnode22);\n                              }\n                              // TODO validate child \n                            }\n                            {\n                              final SNode tnode24 = new SNode(\"jetbrains.mps.baseLanguage.structure.GenericNewExpression\");\n                              try {\n                                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a5a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                                environment.nodeCopied(context20, tnode24, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681214\");\n\n                                {\n                                  final SNode tnode25 = new SNode(\"jetbrains.mps.baseLanguage.structure.ClassCreator\");\n                                  try {\n                                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a5a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                                    environment.nodeCopied(context20, tnode25, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681215\");\n                                    tnode25.setReference(\"baseMethodDeclaration\", SReference.create(\"baseMethodDeclaration\", tnode25, SModelReference.fromString(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.util(JDK/java.util@java_stub)\"), SNodeId.fromString(\"~HashSet.<init>()\")));\n\n                                    {\n                                      final SNode tnode26 = new SNode(\"jetbrains.mps.lang.smodel.structure.SNodeType\");\n                                      try {\n                                        environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a1a5a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                                        environment.nodeCopied(context20, tnode26, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681216\");\n\n                                      } finally {\n                                        environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode26));\n                                        environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a1a5a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                                      }\n                                      if (tnode26 != null) {\n                                        tnode25.addChild(\"typeParameter\", tnode26);\n                                      }\n                                      // TODO validate child \n                                    }\n                                  } finally {\n                                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode25));\n                                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a5a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                                  }\n                                  if (tnode25 != null) {\n                                    tnode24.addChild(\"creator\", tnode25);\n                                  }\n                                  // TODO validate child \n                                }\n                              } finally {\n                                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode24));\n                                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a5a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                              }\n                              if (tnode24 != null) {\n                                tnode21.addChild(\"initializer\", tnode24);\n                              }\n                              // TODO validate child \n                            }\n                          } finally {\n                            environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode21));\n                            environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a2a1a3a1a4a1a7a3a1a4a1a1);\n                          }\n                          tlist20 = TemplateUtil.singletonList(tnode21);\n                          environment.registerLabel(context6.getInput(), tnode21, \"map\");\n                        }\n\n                      } finally {\n                        environment.getTracer().closeMacro(ifMacroRef_3njegt_a0a0a1a3a1a4a1a7a3a1a4a1a1);\n                      }\n                      for (SNode child27 : TemplateUtil.asNotNull(tlist20)) {\n                        tnode19.addChild(\"localVariableDeclaration\", child27);\n                      }\n                      // TODO validate child \n                    }\n                  } finally {\n                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode19));\n                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a7a3a1a4a1a1);\n                  }\n                  if (tnode19 != null) {\n                    tnode14.addChild(\"statement\", tnode19);\n                  }\n                  // TODO validate child \n                }\n                {\n                  final List<SNode> tlist28 = new ArrayList();\n                  try {\n                    environment.getTracer().pushMacro(loopMacroRef_3njegt_a0a0a1a5a1a7a3a1a4a1a1);\n                    final Iterable<SNode> loopList28 = QueriesGenerated.sourceNodesQuery_1025590056396681241(environment.getOperationContext(), new SourceSubstituteMacroNodesContext(context6.getInput(), null, loopMacroRef_3njegt_a0a0a1a5a1a7a3a1a4a1a1, context6, environment.getGenerator()));\n                    for (SNode itnode28 : loopList28) {\n                      if (itnode28 == null) {\n                        continue;\n                      }\n                      boolean inputChanged28 = context6.getInput() != itnode28;\n                      try {\n                        if (inputChanged28) {\n                          environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(itnode28));\n                        }\n                        TemplateContext context28 = context6.subContext(null, itnode28);\n                        final SNode tnode29 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\");\n                        try {\n                          environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a5a1a7a3a1a4a1a1);\n                          environment.nodeCopied(context28, tnode29, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681222\");\n\n                          {\n                            Collection<SNode> tlist30 = null;\n                            try {\n                              environment.getTracer().pushMacro(ifMacroRef_3njegt_a0a0a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                              TemplateContext context30 = context28.subContext(\"nodeVariable\");\n                              if (QueriesGenerated.ifMacro_Condition_1025590056396681235(environment.getOperationContext(), new IfMacroContext(context28.getInput(), ifMacroRef_3njegt_a0a0a1a3a3a2a2a1a5a1a7a3a1a4a1a1, context28, environment.getGenerator()))) {\n                                final SNode tnode31 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n                                try {\n                                  environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a2a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                  environment.nodeCopied(context30, tnode31, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681223\");\n                                  tnode31.setProperty(\"name\", TemplateUtil.asString(QueriesGenerated.propertyMacro_GetPropertyValue_1025590056396681226(environment.getOperationContext(), new PropertyMacroContext(context30.getInput(), \"_node_\", propertyMacro_3njegt_c0b0b0a2a1a2a1a3a3a2a2a1a5a1a7a3a1a4a1a1, context30, environment.getGenerator()))));\n\n                                  {\n                                    final SNode tnode32 = new SNode(\"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n                                    try {\n                                      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a2a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                      environment.nodeCopied(context30, tnode32, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681224\");\n                                      tnode32.setReference(\"classifier\", SReference.create(\"classifier\", tnode32, SModelReference.fromString(\"f:java_stub#6ed54515-acc8-4d1e-a16c-9fd6cfe951ea#jetbrains.mps.smodel(MPS.Core/jetbrains.mps.smodel@java_stub)\"), SNodeId.fromString(\"~SNode\")));\n\n                                    } finally {\n                                      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode32));\n                                      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a2a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                    }\n                                    if (tnode32 != null) {\n                                      tnode31.addChild(\"type\", tnode32);\n                                    }\n                                    // TODO validate child \n                                  }\n                                  {\n                                    final SNode tnode33 = new SNode(\"jetbrains.mps.baseLanguage.structure.NullLiteral\");\n                                    try {\n                                      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a5a1a2a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                      environment.nodeCopied(context30, tnode33, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681239\");\n\n                                    } finally {\n                                      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode33));\n                                      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a5a1a2a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                    }\n                                    if (tnode33 != null) {\n                                      tnode31.addChild(\"initializer\", tnode33);\n                                    }\n                                    // TODO validate child \n                                  }\n                                } finally {\n                                  environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode31));\n                                  environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a2a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                }\n                                tlist30 = TemplateUtil.singletonList(tnode31);\n                                environment.registerLabel(context28.getInput(), tnode31, \"nodeVariable\");\n                              }\n\n                            } finally {\n                              environment.getTracer().closeMacro(ifMacroRef_3njegt_a0a0a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                            }\n                            for (SNode child34 : TemplateUtil.asNotNull(tlist30)) {\n                              tnode29.addChild(\"localVariableDeclaration\", child34);\n                            }\n                            // TODO validate child \n                          }\n                        } finally {\n                          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode29));\n                          environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a5a1a7a3a1a4a1a1);\n                        }\n                        if (tnode29 != null) {\n                          tlist28.add(tnode29);\n                        }\n                      } finally {\n                        if (inputChanged28) {\n                          environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(itnode28));\n                        }\n                      }\n                    }\n                  } finally {\n                    environment.getTracer().closeMacro(loopMacroRef_3njegt_a0a0a1a5a1a7a3a1a4a1a1);\n                  }\n                  for (SNode child35 : TemplateUtil.asNotNull(tlist28)) {\n                    tnode14.addChild(\"statement\", child35);\n                  }\n                  // TODO validate child \n                }\n                {\n                  final SNode tnode36 = new SNode(\"jetbrains.mps.baseLanguage.structure.BlockStatement\");\n                  try {\n                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a6a1a7a3a1a4a1a1);\n                    environment.nodeCopied(context6, tnode36, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681323\");\n\n                    {\n                      Collection<SNode> tlist37 = null;\n                      try {\n                        environment.getTracer().pushMacro(switchMacroRef_3njegt_a0a0a1a3a1a6a1a7a3a1a4a1a1);\n                        final SNode switchInput37 = QueriesGenerated.sourceNodeQuery_1025590056396681326(environment.getOperationContext(), new SourceSubstituteMacroNodeContext(context6.getInput(), switchMacroRef_3njegt_a0a0a1a3a1a6a1a7a3a1a4a1a1, context6, environment.getGenerator()));\n                        if (switchInput37 == null) {\n                          tlist37 = Collections.emptyList();\n                        } else {\n                          boolean inputChanged37 = context6.getInput() != switchInput37;\n                          try {\n                            if (inputChanged37) {\n                              environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(switchInput37));\n                            }\n                            environment.getTracer().pushSwitch(templateSwitchNode_3njegt_a0a1a1a0c0b0d0b0g0b0h0d0b0e0b0b);\n                            tlist37 = environment.trySwitch(templateSwitchNode_3njegt_a0a1a1a0c0b0d0b0g0b0h0d0b0e0b0b, \"nodeCreatorForQuotedNode\", context6.subContext(\"nodeCreatorForQuotedNode\", switchInput37));\n                            if (tlist37 == null) {\n                              final SNode tnode38 = new SNode(\"jetbrains.mps.baseLanguage.structure.StatementList\");\n                              try {\n                                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a0c0b0d0b0g0b0h0d0b0e0b0b);\n                                environment.nodeCopied(context6, tnode38, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681324\");\n\n                              } finally {\n                                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode38));\n                                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a0c0b0d0b0g0b0h0d0b0e0b0b);\n                              }\n                              if (tnode38 != null) {\n                                tlist37 = TemplateUtil.singletonList(tnode38);\n                              }\n                            }\n                          } finally {\n                            // TODO close switch node \n                            if (inputChanged37) {\n                              environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(switchInput37));\n                            }\n                          }\n                        }\n                        environment.registerLabel(switchInput37, tlist37, \"nodeCreatorForQuotedNode\");\n                      } finally {\n                        environment.getTracer().closeMacro(switchMacroRef_3njegt_a0a0a1a3a1a6a1a7a3a1a4a1a1);\n                      }\n                      for (SNode child39 : TemplateUtil.asNotNull(tlist37)) {\n                        tnode36.addChild(\"statements\", child39);\n                      }\n                      // TODO validate child \n                    }\n                  } finally {\n                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode36));\n                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a6a1a7a3a1a4a1a1);\n                  }\n                  if (tnode36 != null) {\n                    tnode14.addChild(\"statement\", tnode36);\n                  }\n                  // TODO validate child \n                }\n                {\n                  final List<SNode> tlist40 = new ArrayList();\n                  try {\n                    environment.getTracer().pushMacro(loopMacroRef_3njegt_a0a0a1a7a1a7a3a1a4a1a1);\n                    final Iterable<SNode> loopList40 = QueriesGenerated.sourceNodesQuery_1025590056396681374(environment.getOperationContext(), new SourceSubstituteMacroNodesContext(context6.getInput(), null, loopMacroRef_3njegt_a0a0a1a7a1a7a3a1a4a1a1, context6, environment.getGenerator()));\n                    for (SNode itnode40 : loopList40) {\n                      if (itnode40 == null) {\n                        continue;\n                      }\n                      boolean inputChanged40 = context6.getInput() != itnode40;\n                      try {\n                        if (inputChanged40) {\n                          environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(itnode40));\n                        }\n                        TemplateContext context40 = context6.subContext(null, itnode40);\n                        final SNode tnode41 = new SNode(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\");\n                        try {\n                          environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a7a1a7a3a1a4a1a1);\n                          environment.nodeCopied(context40, tnode41, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681332\");\n\n                          {\n                            final SNode tnode42 = new SNode(\"jetbrains.mps.baseLanguage.structure.DotExpression\");\n                            try {\n                              environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                              environment.nodeCopied(context40, tnode42, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681333\");\n\n                              {\n                                final SNode tnode43 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\");\n                                try {\n                                  environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                  environment.nodeCopied(context40, tnode43, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681334\");\n                                  environment.resolve(new ReferenceResolver() {\n                                    public Object resolve(SNode outputNode, TemplateContext context) {\n                                      return QueriesGenerated.referenceMacro_GetReferent_1025590056396681336(environment.getOperationContext(), new ReferenceMacroContext(context.getInput(), tnode43, referenceMacro_3njegt_c0b0a0a0a0a0c0b0d0b0d0d0c0c0b0h0b0h0d0b0e0b0b, \"variableDeclaration\", context, environment.getGenerator()));\n                                    }\n\n                                    public String getDefaultResolveInfo() {\n                                      return \"_node_\";\n                                    }\n\n                                    public SNodePointer getTemplateNode() {\n                                      return new SNodePointer(\"r:00000000-0000-4000-0000-011c8959034c(jetbrains.mps.lang.quotation.generator.baseLanguage.template.main@generator)\", \"1025590056396681335\");\n                                    }\n                                  }, tnode43, \"variableDeclaration\", context40);\n\n                                } finally {\n                                  environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode43));\n                                  environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                }\n                                if (tnode43 != null) {\n                                  tnode42.addChild(\"operand\", tnode43);\n                                }\n                                // TODO validate child \n                              }\n                              {\n                                final SNode tnode44 = new SNode(\"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\");\n                                try {\n                                  environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                  environment.nodeCopied(context40, tnode44, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681348\");\n                                  tnode44.setReference(\"baseMethodDeclaration\", SReference.create(\"baseMethodDeclaration\", tnode44, SModelReference.fromString(\"f:java_stub#6ed54515-acc8-4d1e-a16c-9fd6cfe951ea#jetbrains.mps.smodel(MPS.Core/jetbrains.mps.smodel@java_stub)\"), SNodeId.fromString(\"~SNode.setReferenceTarget(java.lang.String,org.jetbrains.mps.openapi.model.SNode):void\")));\n\n                                  {\n                                    final SNode tnode45 = new SNode(\"jetbrains.mps.baseLanguage.structure.StringLiteral\");\n                                    try {\n                                      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                      environment.nodeCopied(context40, tnode45, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681349\");\n                                      tnode45.setProperty(\"value\", TemplateUtil.asString(QueriesGenerated.propertyMacro_GetPropertyValue_1025590056396681351(environment.getOperationContext(), new PropertyMacroContext(context40.getInput(), \"role\", propertyMacro_3njegt_c0b0b0a2a1a4a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1, context40, environment.getGenerator()))));\n\n                                    } finally {\n                                      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode45));\n                                      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                    }\n                                    if (tnode45 != null) {\n                                      tnode44.addChild(\"actualArgument\", tnode45);\n                                    }\n                                    // TODO validate child \n                                  }\n                                  {\n                                    final SNode tnode46 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\");\n                                    try {\n                                      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a5a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                      environment.nodeCopied(context40, tnode46, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681359\");\n                                      environment.resolve(new ReferenceResolver() {\n                                        public Object resolve(SNode outputNode, TemplateContext context) {\n                                          return QueriesGenerated.referenceMacro_GetReferent_1025590056396681361(environment.getOperationContext(), new ReferenceMacroContext(context.getInput(), tnode46, referenceMacro_3njegt_c0b0a0a0a0a0c0b0f0b0e0b0d0d0c0c0b0h0b0h0d0b0e0b0b, \"variableDeclaration\", context, environment.getGenerator()));\n                                        }\n\n                                        public String getDefaultResolveInfo() {\n                                          return \"_node_\";\n                                        }\n\n                                        public SNodePointer getTemplateNode() {\n                                          return new SNodePointer(\"r:00000000-0000-4000-0000-011c8959034c(jetbrains.mps.lang.quotation.generator.baseLanguage.template.main@generator)\", \"1025590056396681360\");\n                                        }\n                                      }, tnode46, \"variableDeclaration\", context40);\n\n                                    } finally {\n                                      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode46));\n                                      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a5a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                    }\n                                    if (tnode46 != null) {\n                                      tnode44.addChild(\"actualArgument\", tnode46);\n                                    }\n                                    // TODO validate child \n                                  }\n                                } finally {\n                                  environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode44));\n                                  environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                }\n                                if (tnode44 != null) {\n                                  tnode42.addChild(\"operation\", tnode44);\n                                }\n                                // TODO validate child \n                              }\n                            } finally {\n                              environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode42));\n                              environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                            }\n                            if (tnode42 != null) {\n                              tnode41.addChild(\"expression\", tnode42);\n                            }\n                            // TODO validate child \n                          }\n                        } finally {\n                          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode41));\n                          environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a7a1a7a3a1a4a1a1);\n                        }\n                        if (tnode41 != null) {\n                          tlist40.add(tnode41);\n                        }\n                      } finally {\n                        if (inputChanged40) {\n                          environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(itnode40));\n                        }\n                      }\n                    }\n                  } finally {\n                    environment.getTracer().closeMacro(loopMacroRef_3njegt_a0a0a1a7a1a7a3a1a4a1a1);\n                  }\n                  for (SNode child47 : TemplateUtil.asNotNull(tlist40)) {\n                    tnode14.addChild(\"statement\", child47);\n                  }\n                  // TODO validate child \n                }\n                {\n                  final SNode tnode48 = new SNode(\"jetbrains.mps.baseLanguage.structure.ReturnStatement\");\n                  try {\n                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a8a1a7a3a1a4a1a1);\n                    environment.nodeCopied(context6, tnode48, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681560\");\n\n                    {\n                      final SNode tnode49 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\");\n                      try {\n                        environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a8a1a7a3a1a4a1a1);\n                        environment.nodeCopied(context6, tnode49, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681561\");\n                        environment.resolveInTemplateLater(tnode49, \"variableDeclaration\", new SNodePointer(\"r:00000000-0000-4000-0000-011c8959034c(jetbrains.mps.lang.quotation.generator.baseLanguage.template.main@generator)\", \"1025590056396681561\"), \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681207\", \"result\", context6);\n\n                      } finally {\n                        environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode49));\n                        environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a8a1a7a3a1a4a1a1);\n                      }\n                      if (tnode49 != null) {\n                        tnode48.addChild(\"expression\", tnode49);\n                      }\n                      // TODO validate child \n                    }\n                  } finally {\n                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode48));\n                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a8a1a7a3a1a4a1a1);\n                  }\n                  if (tnode48 != null) {\n                    tnode14.addChild(\"statement\", tnode48);\n                  }\n                  // TODO validate child \n                }\n              } finally {\n                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode14));\n                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a7a3a1a4a1a1);\n              }\n              if (tnode14 != null) {\n                tnode7.addChild(\"body\", tnode14);\n              }\n              // TODO validate child \n            }\n          } finally {\n            environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode7));\n            environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a3a1a4a1a1);\n          }\n          tlist6 = TemplateUtil.singletonList(tnode7);\n          environment.registerLabel(context.getInput(), tnode7, \"quotationStaticMethod\");\n        } finally {\n          environment.getTracer().closeMacro(nodeMacroRef_3njegt_a0a0a1a4a1a1);\n        }\n        for (SNode child50 : TemplateUtil.asNotNull(tlist6)) {\n          tnode1.addChild(\"method\", child50);\n        }\n        // TODO validate child \n      }\n    } finally {\n      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode1));\n      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a1);\n    }\n    return tnode1;\n  }","id":83606,"modified_method":"protected SNode applyPart0(@NotNull final TemplateExecutionEnvironment environment, @NotNull final TemplateContext context) throws GenerationException {\n    final SNode tnode1 = new SNode(\"jetbrains.mps.baseLanguageInternal.structure.ExtractStaticMethodExpression\");\n    try {\n      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a1);\n      environment.nodeCopied(context, tnode1, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396661195\");\n\n      {\n        final SNode tnode2 = new SNode(\"jetbrains.mps.baseLanguageInternal.structure.ExtractStaticMethod_CallExpression\");\n        try {\n          environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a1);\n          environment.nodeCopied(context, tnode2, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396668027\");\n          environment.resolveInTemplateLater(tnode2, \"baseMethodDeclaration\", new SNodePointer(\"r:00000000-0000-4000-0000-011c8959034c(jetbrains.mps.lang.quotation.generator.baseLanguage.template.main@generator)\", \"1025590056396668027\"), \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396661196\", \"_quotation_createNode\", context);\n\n          {\n            final List<SNode> tlist3 = new ArrayList();\n            try {\n              environment.getTracer().pushMacro(loopMacroRef_3njegt_a0a0a1a4a1a3a1a1);\n              final Iterable<SNode> loopList3 = QueriesGenerated.sourceNodesQuery_1025590056396691724(environment.getOperationContext(), new SourceSubstituteMacroNodesContext(context.getInput(), null, loopMacroRef_3njegt_a0a0a1a4a1a3a1a1, context, environment.getGenerator()));\n              for (SNode itnode3 : loopList3) {\n                if (itnode3 == null) {\n                  continue;\n                }\n                boolean inputChanged3 = context.getInput() != itnode3;\n                try {\n                  if (inputChanged3) {\n                    environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(itnode3));\n                  }\n                  TemplateContext context3 = context.subContext(null, itnode3);\n                  Collection<SNode> tlist4 = null;\n                  try {\n                    environment.getTracer().pushMacro(copySrcMacro_3njegt_a0a0a3a2a2a1a4a1a3a1a1);\n                    final SNode copySrcInput4 = QueriesGenerated.sourceNodeQuery_1025590056396691788(environment.getOperationContext(), new SourceSubstituteMacroNodeContext(context3.getInput(), copySrcMacro_3njegt_a0a0a3a2a2a1a4a1a3a1a1, context3, environment.getGenerator()));\n                    tlist4 = environment.copyNodes(TemplateUtil.singletonList(copySrcInput4), copySrcMacro_3njegt_a0a0a3a2a2a1a4a1a3a1a1, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396691722\", null, context3);\n                  } finally {\n                    environment.getTracer().closeMacro(copySrcMacro_3njegt_a0a0a3a2a2a1a4a1a3a1a1);\n                  }\n                  if (tlist4 != null) {\n                    tlist3.addAll(tlist4);\n                  }\n                } finally {\n                  if (inputChanged3) {\n                    environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(itnode3));\n                  }\n                }\n              }\n            } finally {\n              environment.getTracer().closeMacro(loopMacroRef_3njegt_a0a0a1a4a1a3a1a1);\n            }\n            for (SNode child5 : TemplateUtil.asNotNull(tlist3)) {\n              tnode2.addChild(\"actualArgument\", child5);\n            }\n            // TODO validate child \n          }\n        } finally {\n          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode2));\n          environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a1);\n        }\n        if (tnode2 != null) {\n          tnode1.addChild(\"inner\", tnode2);\n        }\n        // TODO validate child \n      }\n      {\n        Collection<SNode> tlist6 = null;\n        try {\n          environment.getTracer().pushMacro(nodeMacroRef_3njegt_a0a0a1a4a1a1);\n          TemplateContext context6 = context.subContext(\"quotationStaticMethod\");\n          final SNode tnode7 = new SNode(\"jetbrains.mps.baseLanguage.structure.StaticMethodDeclaration\");\n          try {\n            environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a3a1a4a1a1);\n            environment.nodeCopied(context6, tnode7, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396661196\");\n            tnode7.setProperty(\"name\", TemplateUtil.asString(QueriesGenerated.propertyMacro_GetPropertyValue_1025590056397541505(environment.getOperationContext(), new PropertyMacroContext(context6.getInput(), \"_quotation_createNode\", propertyMacro_3njegt_c0b0b0a2a3a1a4a1a1, context6, environment.getGenerator()))));\n\n            {\n              final SNode tnode8 = new SNode(\"jetbrains.mps.baseLanguage.structure.PrivateVisibility\");\n              try {\n                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a3a1a4a1a1);\n                environment.nodeCopied(context6, tnode8, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056400639397\");\n\n              } finally {\n                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode8));\n                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a3a1a4a1a1);\n              }\n              if (tnode8 != null) {\n                tnode7.addChild(\"visibility\", tnode8);\n              }\n              // TODO validate child \n            }\n            {\n              final SNode tnode9 = new SNode(\"jetbrains.mps.lang.smodel.structure.SNodeType\");\n              try {\n                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a5a3a1a4a1a1);\n                environment.nodeCopied(context6, tnode9, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396674747\");\n\n              } finally {\n                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode9));\n                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a5a3a1a4a1a1);\n              }\n              if (tnode9 != null) {\n                tnode7.addChild(\"returnType\", tnode9);\n              }\n              // TODO validate child \n            }\n            {\n              final List<SNode> tlist10 = new ArrayList();\n              try {\n                environment.getTracer().pushMacro(loopMacroRef_3njegt_a0a0a1a6a3a1a4a1a1);\n                final Iterable<SNode> loopList10 = QueriesGenerated.sourceNodesQuery_1025590056396672113(environment.getOperationContext(), new SourceSubstituteMacroNodesContext(context6.getInput(), null, loopMacroRef_3njegt_a0a0a1a6a3a1a4a1a1, context6, environment.getGenerator()));\n                for (SNode itnode10 : loopList10) {\n                  if (itnode10 == null) {\n                    continue;\n                  }\n                  boolean inputChanged10 = context6.getInput() != itnode10;\n                  try {\n                    if (inputChanged10) {\n                      environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(itnode10));\n                    }\n                    TemplateContext context10 = context6.subContext(\"parametersFromExpressions\", itnode10);\n                    final SNode tnode11 = new SNode(\"jetbrains.mps.baseLanguage.structure.ParameterDeclaration\");\n                    try {\n                      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a6a3a1a4a1a1);\n                      environment.nodeCopied(context10, tnode11, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396672110\");\n                      tnode11.setProperty(\"name\", TemplateUtil.asString(QueriesGenerated.propertyMacro_GetPropertyValue_1025590056396672173(environment.getOperationContext(), new PropertyMacroContext(context10.getInput(), \"a\", propertyMacro_3njegt_c0b0b0a2a3a2a2a1a6a3a1a4a1a1, context10, environment.getGenerator()))));\n\n                      {\n                        final SNode tnode12 = new SNode(\"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n                        try {\n                          environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a3a2a2a1a6a3a1a4a1a1);\n                          environment.nodeCopied(context10, tnode12, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396672111\");\n                          tnode12.setReference(\"classifier\", SReference.create(\"classifier\", tnode12, SModelReference.fromString(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.lang(JDK/java.lang@java_stub)\"), SNodeId.fromString(\"~Object\")));\n\n                        } finally {\n                          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode12));\n                          environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a3a2a2a1a6a3a1a4a1a1);\n                        }\n                        if (tnode12 != null) {\n                          tnode11.addChild(\"type\", tnode12);\n                        }\n                        // TODO validate child \n                      }\n                    } finally {\n                      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode11));\n                      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a6a3a1a4a1a1);\n                    }\n                    if (tnode11 != null) {\n                      environment.registerLabel(itnode10, tnode11, \"parametersFromExpressions\");\n                      tlist10.add(tnode11);\n                    }\n                  } finally {\n                    if (inputChanged10) {\n                      environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(itnode10));\n                    }\n                  }\n                }\n              } finally {\n                environment.getTracer().closeMacro(loopMacroRef_3njegt_a0a0a1a6a3a1a4a1a1);\n              }\n              for (SNode child13 : TemplateUtil.asNotNull(tlist10)) {\n                tnode7.addChild(\"parameter\", child13);\n              }\n              // TODO validate child \n            }\n            {\n              final SNode tnode14 = new SNode(\"jetbrains.mps.baseLanguage.structure.StatementList\");\n              try {\n                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a7a3a1a4a1a1);\n                environment.nodeCopied(context6, tnode14, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396661199\");\n\n                {\n                  final SNode tnode15 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\");\n                  try {\n                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a7a3a1a4a1a1);\n                    environment.nodeCopied(context6, tnode15, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681206\");\n\n                    {\n                      final SNode tnode16 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n                      try {\n                        environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a3a1a7a3a1a4a1a1);\n                        environment.nodeCopied(context6, tnode16, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681207\");\n                        tnode16.setProperty(\"name\", \"result\");\n\n                        {\n                          final SNode tnode17 = new SNode(\"jetbrains.mps.baseLanguage.structure.NullLiteral\");\n                          try {\n                            environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a1a3a1a7a3a1a4a1a1);\n                            environment.nodeCopied(context6, tnode17, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681208\");\n\n                          } finally {\n                            environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode17));\n                            environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a1a3a1a7a3a1a4a1a1);\n                          }\n                          if (tnode17 != null) {\n                            tnode16.addChild(\"initializer\", tnode17);\n                          }\n                          // TODO validate child \n                        }\n                        {\n                          final SNode tnode18 = new SNode(\"jetbrains.mps.lang.smodel.structure.SNodeType\");\n                          try {\n                            environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a5a1a3a1a3a1a7a3a1a4a1a1);\n                            environment.nodeCopied(context6, tnode18, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681209\");\n\n                          } finally {\n                            environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode18));\n                            environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a5a1a3a1a3a1a7a3a1a4a1a1);\n                          }\n                          if (tnode18 != null) {\n                            tnode16.addChild(\"type\", tnode18);\n                          }\n                          // TODO validate child \n                        }\n                      } finally {\n                        environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode16));\n                        environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a3a1a7a3a1a4a1a1);\n                      }\n                      if (tnode16 != null) {\n                        tnode15.addChild(\"localVariableDeclaration\", tnode16);\n                      }\n                      // TODO validate child \n                    }\n                  } finally {\n                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode15));\n                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a7a3a1a4a1a1);\n                  }\n                  if (tnode15 != null) {\n                    tnode14.addChild(\"statement\", tnode15);\n                  }\n                  // TODO validate child \n                }\n                {\n                  final SNode tnode19 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\");\n                  try {\n                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a7a3a1a4a1a1);\n                    environment.nodeCopied(context6, tnode19, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681210\");\n\n                    {\n                      Collection<SNode> tlist20 = null;\n                      try {\n                        environment.getTracer().pushMacro(nodeMacroRef_3njegt_a0a0a1a3a1a4a1a7a3a1a4a1a1);\n                        TemplateContext context20 = context6.subContext(\"map\");\n                        final SNode tnode21 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n                        try {\n                          environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a3a1a3a1a4a1a7a3a1a4a1a1);\n                          environment.nodeCopied(context20, tnode21, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681211\");\n                          tnode21.setProperty(\"name\", \"_parameterValues_129834374\");\n\n                          {\n                            final SNode tnode22 = new SNode(\"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n                            try {\n                              environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a3a1a3a1a4a1a7a3a1a4a1a1);\n                              environment.nodeCopied(context20, tnode22, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681212\");\n                              tnode22.setReference(\"classifier\", SReference.create(\"classifier\", tnode22, SModelReference.fromString(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.util(JDK/java.util@java_stub)\"), SNodeId.fromString(\"~Set\")));\n\n                              {\n                                final SNode tnode23 = new SNode(\"jetbrains.mps.lang.smodel.structure.SNodeType\");\n                                try {\n                                  environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a4a3a1a3a1a4a1a7a3a1a4a1a1);\n                                  environment.nodeCopied(context20, tnode23, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681213\");\n\n                                } finally {\n                                  environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode23));\n                                  environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a4a3a1a3a1a4a1a7a3a1a4a1a1);\n                                }\n                                if (tnode23 != null) {\n                                  tnode22.addChild(\"parameter\", tnode23);\n                                }\n                                // TODO validate child \n                              }\n                            } finally {\n                              environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode22));\n                              environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a3a1a3a1a4a1a7a3a1a4a1a1);\n                            }\n                            if (tnode22 != null) {\n                              tnode21.addChild(\"type\", tnode22);\n                            }\n                            // TODO validate child \n                          }\n                          {\n                            final SNode tnode24 = new SNode(\"jetbrains.mps.baseLanguage.structure.GenericNewExpression\");\n                            try {\n                              environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a5a3a1a3a1a4a1a7a3a1a4a1a1);\n                              environment.nodeCopied(context20, tnode24, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681214\");\n\n                              {\n                                final SNode tnode25 = new SNode(\"jetbrains.mps.baseLanguage.structure.ClassCreator\");\n                                try {\n                                  environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a5a3a1a3a1a4a1a7a3a1a4a1a1);\n                                  environment.nodeCopied(context20, tnode25, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681215\");\n                                  tnode25.setReference(\"baseMethodDeclaration\", SReference.create(\"baseMethodDeclaration\", tnode25, SModelReference.fromString(\"f:java_stub#6354ebe7-c22a-4a0f-ac54-50b52ab9b065#java.util(JDK/java.util@java_stub)\"), SNodeId.fromString(\"~HashSet.<init>()\")));\n\n                                  {\n                                    final SNode tnode26 = new SNode(\"jetbrains.mps.lang.smodel.structure.SNodeType\");\n                                    try {\n                                      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a1a5a3a1a3a1a4a1a7a3a1a4a1a1);\n                                      environment.nodeCopied(context20, tnode26, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681216\");\n\n                                    } finally {\n                                      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode26));\n                                      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a1a5a3a1a3a1a4a1a7a3a1a4a1a1);\n                                    }\n                                    if (tnode26 != null) {\n                                      tnode25.addChild(\"typeParameter\", tnode26);\n                                    }\n                                    // TODO validate child \n                                  }\n                                } finally {\n                                  environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode25));\n                                  environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a5a3a1a3a1a4a1a7a3a1a4a1a1);\n                                }\n                                if (tnode25 != null) {\n                                  tnode24.addChild(\"creator\", tnode25);\n                                }\n                                // TODO validate child \n                              }\n                            } finally {\n                              environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode24));\n                              environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a5a3a1a3a1a4a1a7a3a1a4a1a1);\n                            }\n                            if (tnode24 != null) {\n                              tnode21.addChild(\"initializer\", tnode24);\n                            }\n                            // TODO validate child \n                          }\n                        } finally {\n                          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode21));\n                          environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a3a1a3a1a4a1a7a3a1a4a1a1);\n                        }\n                        tlist20 = TemplateUtil.singletonList(tnode21);\n                        environment.registerLabel(context6.getInput(), tnode21, \"map\");\n                      } finally {\n                        environment.getTracer().closeMacro(nodeMacroRef_3njegt_a0a0a1a3a1a4a1a7a3a1a4a1a1);\n                      }\n                      for (SNode child27 : TemplateUtil.asNotNull(tlist20)) {\n                        tnode19.addChild(\"localVariableDeclaration\", child27);\n                      }\n                      // TODO validate child \n                    }\n                  } finally {\n                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode19));\n                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a7a3a1a4a1a1);\n                  }\n                  if (tnode19 != null) {\n                    tnode14.addChild(\"statement\", tnode19);\n                  }\n                  // TODO validate child \n                }\n                {\n                  final List<SNode> tlist28 = new ArrayList();\n                  try {\n                    environment.getTracer().pushMacro(loopMacroRef_3njegt_a0a0a1a5a1a7a3a1a4a1a1);\n                    final Iterable<SNode> loopList28 = QueriesGenerated.sourceNodesQuery_1025590056396681241(environment.getOperationContext(), new SourceSubstituteMacroNodesContext(context6.getInput(), null, loopMacroRef_3njegt_a0a0a1a5a1a7a3a1a4a1a1, context6, environment.getGenerator()));\n                    for (SNode itnode28 : loopList28) {\n                      if (itnode28 == null) {\n                        continue;\n                      }\n                      boolean inputChanged28 = context6.getInput() != itnode28;\n                      try {\n                        if (inputChanged28) {\n                          environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(itnode28));\n                        }\n                        TemplateContext context28 = context6.subContext(null, itnode28);\n                        final SNode tnode29 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\");\n                        try {\n                          environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a5a1a7a3a1a4a1a1);\n                          environment.nodeCopied(context28, tnode29, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681222\");\n\n                          {\n                            Collection<SNode> tlist30 = null;\n                            try {\n                              environment.getTracer().pushMacro(nodeMacroRef_3njegt_a0a0a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                              TemplateContext context30 = context28.subContext(\"nodeVariable\");\n                              final SNode tnode31 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableDeclaration\");\n                              try {\n                                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a3a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                environment.nodeCopied(context30, tnode31, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681223\");\n                                tnode31.setProperty(\"name\", TemplateUtil.asString(QueriesGenerated.propertyMacro_GetPropertyValue_1025590056396681226(environment.getOperationContext(), new PropertyMacroContext(context30.getInput(), \"_node_\", propertyMacro_3njegt_c0b0b0a2a3a1a3a3a2a2a1a5a1a7a3a1a4a1a1, context30, environment.getGenerator()))));\n\n                                {\n                                  final SNode tnode32 = new SNode(\"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n                                  try {\n                                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a3a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                    environment.nodeCopied(context30, tnode32, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681224\");\n                                    tnode32.setReference(\"classifier\", SReference.create(\"classifier\", tnode32, SModelReference.fromString(\"f:java_stub#6ed54515-acc8-4d1e-a16c-9fd6cfe951ea#jetbrains.mps.smodel(MPS.Core/jetbrains.mps.smodel@java_stub)\"), SNodeId.fromString(\"~SNode\")));\n\n                                  } finally {\n                                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode32));\n                                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a3a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                  }\n                                  if (tnode32 != null) {\n                                    tnode31.addChild(\"type\", tnode32);\n                                  }\n                                  // TODO validate child \n                                }\n                                {\n                                  final SNode tnode33 = new SNode(\"jetbrains.mps.baseLanguage.structure.NullLiteral\");\n                                  try {\n                                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a5a3a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                    environment.nodeCopied(context30, tnode33, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681239\");\n\n                                  } finally {\n                                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode33));\n                                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a5a3a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                                  }\n                                  if (tnode33 != null) {\n                                    tnode31.addChild(\"initializer\", tnode33);\n                                  }\n                                  // TODO validate child \n                                }\n                              } finally {\n                                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode31));\n                                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a3a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                              }\n                              tlist30 = TemplateUtil.singletonList(tnode31);\n                              environment.registerLabel(context28.getInput(), tnode31, \"nodeVariable\");\n                            } finally {\n                              environment.getTracer().closeMacro(nodeMacroRef_3njegt_a0a0a1a3a3a2a2a1a5a1a7a3a1a4a1a1);\n                            }\n                            for (SNode child34 : TemplateUtil.asNotNull(tlist30)) {\n                              tnode29.addChild(\"localVariableDeclaration\", child34);\n                            }\n                            // TODO validate child \n                          }\n                        } finally {\n                          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode29));\n                          environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a5a1a7a3a1a4a1a1);\n                        }\n                        if (tnode29 != null) {\n                          tlist28.add(tnode29);\n                        }\n                      } finally {\n                        if (inputChanged28) {\n                          environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(itnode28));\n                        }\n                      }\n                    }\n                  } finally {\n                    environment.getTracer().closeMacro(loopMacroRef_3njegt_a0a0a1a5a1a7a3a1a4a1a1);\n                  }\n                  for (SNode child35 : TemplateUtil.asNotNull(tlist28)) {\n                    tnode14.addChild(\"statement\", child35);\n                  }\n                  // TODO validate child \n                }\n                {\n                  final SNode tnode36 = new SNode(\"jetbrains.mps.baseLanguage.structure.BlockStatement\");\n                  try {\n                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a6a1a7a3a1a4a1a1);\n                    environment.nodeCopied(context6, tnode36, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681323\");\n\n                    {\n                      Collection<SNode> tlist37 = null;\n                      try {\n                        environment.getTracer().pushMacro(switchMacroRef_3njegt_a0a0a1a3a1a6a1a7a3a1a4a1a1);\n                        final SNode switchInput37 = QueriesGenerated.sourceNodeQuery_1025590056396681326(environment.getOperationContext(), new SourceSubstituteMacroNodeContext(context6.getInput(), switchMacroRef_3njegt_a0a0a1a3a1a6a1a7a3a1a4a1a1, context6, environment.getGenerator()));\n                        if (switchInput37 == null) {\n                          tlist37 = Collections.emptyList();\n                        } else {\n                          boolean inputChanged37 = context6.getInput() != switchInput37;\n                          try {\n                            if (inputChanged37) {\n                              environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(switchInput37));\n                            }\n                            environment.getTracer().pushSwitch(templateSwitchNode_3njegt_a0a1a1a0c0b0d0b0g0b0h0d0b0e0b0b);\n                            tlist37 = environment.trySwitch(templateSwitchNode_3njegt_a0a1a1a0c0b0d0b0g0b0h0d0b0e0b0b, \"nodeCreatorForQuotedNode\", context6.subContext(\"nodeCreatorForQuotedNode\", switchInput37));\n                            if (tlist37 == null) {\n                              final SNode tnode38 = new SNode(\"jetbrains.mps.baseLanguage.structure.StatementList\");\n                              try {\n                                environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a0c0b0d0b0g0b0h0d0b0e0b0b);\n                                environment.nodeCopied(context6, tnode38, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681324\");\n\n                              } finally {\n                                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode38));\n                                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a0c0b0d0b0g0b0h0d0b0e0b0b);\n                              }\n                              if (tnode38 != null) {\n                                tlist37 = TemplateUtil.singletonList(tnode38);\n                              }\n                            }\n                          } finally {\n                            // TODO close switch node \n                            if (inputChanged37) {\n                              environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(switchInput37));\n                            }\n                          }\n                        }\n                        environment.registerLabel(switchInput37, tlist37, \"nodeCreatorForQuotedNode\");\n                      } finally {\n                        environment.getTracer().closeMacro(switchMacroRef_3njegt_a0a0a1a3a1a6a1a7a3a1a4a1a1);\n                      }\n                      for (SNode child39 : TemplateUtil.asNotNull(tlist37)) {\n                        tnode36.addChild(\"statements\", child39);\n                      }\n                      // TODO validate child \n                    }\n                  } finally {\n                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode36));\n                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a6a1a7a3a1a4a1a1);\n                  }\n                  if (tnode36 != null) {\n                    tnode14.addChild(\"statement\", tnode36);\n                  }\n                  // TODO validate child \n                }\n                {\n                  final List<SNode> tlist40 = new ArrayList();\n                  try {\n                    environment.getTracer().pushMacro(loopMacroRef_3njegt_a0a0a1a7a1a7a3a1a4a1a1);\n                    final Iterable<SNode> loopList40 = QueriesGenerated.sourceNodesQuery_1025590056396681374(environment.getOperationContext(), new SourceSubstituteMacroNodesContext(context6.getInput(), null, loopMacroRef_3njegt_a0a0a1a7a1a7a3a1a4a1a1, context6, environment.getGenerator()));\n                    for (SNode itnode40 : loopList40) {\n                      if (itnode40 == null) {\n                        continue;\n                      }\n                      boolean inputChanged40 = context6.getInput() != itnode40;\n                      try {\n                        if (inputChanged40) {\n                          environment.getTracer().pushInputNode(GenerationTracerUtil.getSNodePointer(itnode40));\n                        }\n                        TemplateContext context40 = context6.subContext(null, itnode40);\n                        final SNode tnode41 = new SNode(\"jetbrains.mps.baseLanguage.structure.ExpressionStatement\");\n                        try {\n                          environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a7a1a7a3a1a4a1a1);\n                          environment.nodeCopied(context40, tnode41, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681332\");\n\n                          {\n                            final SNode tnode42 = new SNode(\"jetbrains.mps.baseLanguage.structure.DotExpression\");\n                            try {\n                              environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                              environment.nodeCopied(context40, tnode42, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681333\");\n\n                              {\n                                final SNode tnode43 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\");\n                                try {\n                                  environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                  environment.nodeCopied(context40, tnode43, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681334\");\n                                  environment.resolve(new ReferenceResolver() {\n                                    public Object resolve(SNode outputNode, TemplateContext context) {\n                                      return QueriesGenerated.referenceMacro_GetReferent_1025590056396681336(environment.getOperationContext(), new ReferenceMacroContext(context.getInput(), tnode43, referenceMacro_3njegt_c0b0a0a0a0a0c0b0d0b0d0d0c0c0b0h0b0h0d0b0e0b0b, \"variableDeclaration\", context, environment.getGenerator()));\n                                    }\n\n                                    public String getDefaultResolveInfo() {\n                                      return \"_node_\";\n                                    }\n\n                                    public SNodePointer getTemplateNode() {\n                                      return new SNodePointer(\"r:00000000-0000-4000-0000-011c8959034c(jetbrains.mps.lang.quotation.generator.baseLanguage.template.main@generator)\", \"1025590056396681335\");\n                                    }\n                                  }, tnode43, \"variableDeclaration\", context40);\n\n                                } finally {\n                                  environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode43));\n                                  environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                }\n                                if (tnode43 != null) {\n                                  tnode42.addChild(\"operand\", tnode43);\n                                }\n                                // TODO validate child \n                              }\n                              {\n                                final SNode tnode44 = new SNode(\"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\");\n                                try {\n                                  environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                  environment.nodeCopied(context40, tnode44, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681348\");\n                                  tnode44.setReference(\"baseMethodDeclaration\", SReference.create(\"baseMethodDeclaration\", tnode44, SModelReference.fromString(\"f:java_stub#6ed54515-acc8-4d1e-a16c-9fd6cfe951ea#jetbrains.mps.smodel(MPS.Core/jetbrains.mps.smodel@java_stub)\"), SNodeId.fromString(\"~SNode.setReferenceTarget(java.lang.String,org.jetbrains.mps.openapi.model.SNode):void\")));\n\n                                  {\n                                    final SNode tnode45 = new SNode(\"jetbrains.mps.baseLanguage.structure.StringLiteral\");\n                                    try {\n                                      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a4a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                      environment.nodeCopied(context40, tnode45, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681349\");\n                                      tnode45.setProperty(\"value\", TemplateUtil.asString(QueriesGenerated.propertyMacro_GetPropertyValue_1025590056396681351(environment.getOperationContext(), new PropertyMacroContext(context40.getInput(), \"role\", propertyMacro_3njegt_c0b0b0a2a1a4a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1, context40, environment.getGenerator()))));\n\n                                    } finally {\n                                      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode45));\n                                      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                    }\n                                    if (tnode45 != null) {\n                                      tnode44.addChild(\"actualArgument\", tnode45);\n                                    }\n                                    // TODO validate child \n                                  }\n                                  {\n                                    final SNode tnode46 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\");\n                                    try {\n                                      environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a5a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                      environment.nodeCopied(context40, tnode46, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681359\");\n                                      environment.resolve(new ReferenceResolver() {\n                                        public Object resolve(SNode outputNode, TemplateContext context) {\n                                          return QueriesGenerated.referenceMacro_GetReferent_1025590056396681361(environment.getOperationContext(), new ReferenceMacroContext(context.getInput(), tnode46, referenceMacro_3njegt_c0b0a0a0a0a0c0b0f0b0e0b0d0d0c0c0b0h0b0h0d0b0e0b0b, \"variableDeclaration\", context, environment.getGenerator()));\n                                        }\n\n                                        public String getDefaultResolveInfo() {\n                                          return \"_node_\";\n                                        }\n\n                                        public SNodePointer getTemplateNode() {\n                                          return new SNodePointer(\"r:00000000-0000-4000-0000-011c8959034c(jetbrains.mps.lang.quotation.generator.baseLanguage.template.main@generator)\", \"1025590056396681360\");\n                                        }\n                                      }, tnode46, \"variableDeclaration\", context40);\n\n                                    } finally {\n                                      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode46));\n                                      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a5a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                    }\n                                    if (tnode46 != null) {\n                                      tnode44.addChild(\"actualArgument\", tnode46);\n                                    }\n                                    // TODO validate child \n                                  }\n                                } finally {\n                                  environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode44));\n                                  environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a4a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                                }\n                                if (tnode44 != null) {\n                                  tnode42.addChild(\"operation\", tnode44);\n                                }\n                                // TODO validate child \n                              }\n                            } finally {\n                              environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode42));\n                              environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a3a2a2a1a7a1a7a3a1a4a1a1);\n                            }\n                            if (tnode42 != null) {\n                              tnode41.addChild(\"expression\", tnode42);\n                            }\n                            // TODO validate child \n                          }\n                        } finally {\n                          environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode41));\n                          environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a3a2a2a1a7a1a7a3a1a4a1a1);\n                        }\n                        if (tnode41 != null) {\n                          tlist40.add(tnode41);\n                        }\n                      } finally {\n                        if (inputChanged40) {\n                          environment.getTracer().closeInputNode(GenerationTracerUtil.getSNodePointer(itnode40));\n                        }\n                      }\n                    }\n                  } finally {\n                    environment.getTracer().closeMacro(loopMacroRef_3njegt_a0a0a1a7a1a7a3a1a4a1a1);\n                  }\n                  for (SNode child47 : TemplateUtil.asNotNull(tlist40)) {\n                    tnode14.addChild(\"statement\", child47);\n                  }\n                  // TODO validate child \n                }\n                {\n                  final SNode tnode48 = new SNode(\"jetbrains.mps.baseLanguage.structure.ReturnStatement\");\n                  try {\n                    environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a8a1a7a3a1a4a1a1);\n                    environment.nodeCopied(context6, tnode48, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681560\");\n\n                    {\n                      final SNode tnode49 = new SNode(\"jetbrains.mps.baseLanguage.structure.LocalVariableReference\");\n                      try {\n                        environment.getTracer().pushTemplateNode(templateNode_3njegt_a0a0a1a3a1a8a1a7a3a1a4a1a1);\n                        environment.nodeCopied(context6, tnode49, \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681561\");\n                        environment.resolveInTemplateLater(tnode49, \"variableDeclaration\", new SNodePointer(\"r:00000000-0000-4000-0000-011c8959034c(jetbrains.mps.lang.quotation.generator.baseLanguage.template.main@generator)\", \"1025590056396681561\"), \"tpl/r:00000000-0000-4000-0000-011c8959034c/1025590056396681207\", \"result\", context6);\n\n                      } finally {\n                        environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode49));\n                        environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a3a1a8a1a7a3a1a4a1a1);\n                      }\n                      if (tnode49 != null) {\n                        tnode48.addChild(\"expression\", tnode49);\n                      }\n                      // TODO validate child \n                    }\n                  } finally {\n                    environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode48));\n                    environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a8a1a7a3a1a4a1a1);\n                  }\n                  if (tnode48 != null) {\n                    tnode14.addChild(\"statement\", tnode48);\n                  }\n                  // TODO validate child \n                }\n              } finally {\n                environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode14));\n                environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a7a3a1a4a1a1);\n              }\n              if (tnode14 != null) {\n                tnode7.addChild(\"body\", tnode14);\n              }\n              // TODO validate child \n            }\n          } finally {\n            environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode7));\n            environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a3a1a4a1a1);\n          }\n          tlist6 = TemplateUtil.singletonList(tnode7);\n          environment.registerLabel(context.getInput(), tnode7, \"quotationStaticMethod\");\n        } finally {\n          environment.getTracer().closeMacro(nodeMacroRef_3njegt_a0a0a1a4a1a1);\n        }\n        for (SNode child50 : TemplateUtil.asNotNull(tlist6)) {\n          tnode1.addChild(\"method\", child50);\n        }\n        // TODO validate child \n      }\n    } finally {\n      environment.getTracer().pushOutputNode(GenerationTracerUtil.getSNodePointer(environment.getOutputModel(), tnode1));\n      environment.getTracer().closeTemplateNode(templateNode_3njegt_a0a0a1a1);\n    }\n    return tnode1;\n  }","commit_id":"464a4be68be036b52e566fe72f9f2bbe18d6f97a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected Object getHandler(ReactiveServerHttpRequest request) {\n\t\tObject handler = null;\n\t\tfor (HandlerMapping handlerMapping : this.handlerMappings) {\n\t\t\thandler = handlerMapping.getHandler(request);\n\t\t\tif (handler != null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn handler;\n\t}","id":83607,"modified_method":"protected Publisher<Object> getHandler(ReactiveServerHttpRequest request) {\n\t\tfor (HandlerMapping handlerMapping : this.handlerMappings) {\n\t\t\tPublisher<Object> handlerPublisher = handlerMapping.getHandler(request);\n\t\t\tif (handlerPublisher != null) {\n\t\t\t\treturn handlerPublisher;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"d319edba28d0fbf24b58525bff3cc5bd04dc934f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Publisher<Void> handle(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Processing \" + request.getMethod() + \" request for [\" + request.getURI() + \"]\");\n\t\t}\n\n\t\tObject handler = getHandler(request);\n\t\tif (handler == null) {\n\t\t\t// No exception handling mechanism yet\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\tresponse.writeHeaders();\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tHandlerAdapter handlerAdapter = getHandlerAdapter(handler);\n\t\tif (handlerAdapter == null) {\n\t\t\treturn Publishers.error(new IllegalStateException(\"No HandlerAdapter for \" + handler));\n\t\t}\n\n\t\tPublisher<HandlerResult> resultPublisher = handlerAdapter.handle(request, response, handler);\n\n\t\treturn Publishers.concatMap(resultPublisher, result -> {\n\t\t\tfor (HandlerResultHandler resultHandler : resultHandlers) {\n\t\t\t\tif (resultHandler.supports(result)) {\n\t\t\t\t\treturn resultHandler.handleResult(request, response, result);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Publishers.error(new IllegalStateException(\n\t\t\t\t\t\"No HandlerResultHandler for \" + result.getValue()));\n\t\t});\n\t}","id":83608,"modified_method":"@Override\n\tpublic Publisher<Void> handle(ReactiveServerHttpRequest request, ReactiveServerHttpResponse response) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Processing \" + request.getMethod() + \" request for [\" + request.getURI() + \"]\");\n\t\t}\n\n\t\tPublisher<Object> handlerPublisher = getHandler(request);\n\t\tif (handlerPublisher == null) {\n\t\t\t// No exception handling mechanism yet\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\tresponse.writeHeaders();\n\t\t\treturn Publishers.empty();\n\t\t}\n\n\t\tPublisher<HandlerResult> resultPublisher = Publishers.concatMap(handlerPublisher, handler -> {\n\t\t\tHandlerAdapter handlerAdapter = getHandlerAdapter(handler);\n\t\t\treturn handlerAdapter.handle(request, response, handler);\n\t\t});\n\n\t\treturn Publishers.concatMap(resultPublisher, result -> {\n\t\t\tHandlerResultHandler handler = getResultHandler(result);\n\t\t\treturn handler.handleResult(request, response, result);\n\t\t});\n\t}","commit_id":"d319edba28d0fbf24b58525bff3cc5bd04dc934f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected HandlerAdapter getHandlerAdapter(Object handler) {\n\t\tfor (HandlerAdapter handlerAdapter : this.handlerAdapters) {\n\t\t\tif (handlerAdapter.supports(handler)) {\n\t\t\t\treturn handlerAdapter;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":83609,"modified_method":"protected HandlerAdapter getHandlerAdapter(Object handler) {\n\t\tfor (HandlerAdapter handlerAdapter : this.handlerAdapters) {\n\t\t\tif (handlerAdapter.supports(handler)) {\n\t\t\t\treturn handlerAdapter;\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalStateException(\"No HandlerAdapter: \" + handler);\n\t}","commit_id":"d319edba28d0fbf24b58525bff3cc5bd04dc934f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Object getHandler(ReactiveServerHttpRequest request) {\n\t\tfor (Map.Entry<RequestMappingInfo, HandlerMethod> entry : this.methodMap.entrySet()) {\n\t\t\tRequestMappingInfo info = entry.getKey();\n\t\t\tif (info.matchesRequest(request)) {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Mapped \" + request.getMethod() + \" \" +\n\t\t\t\t\t\t\trequest.getURI().getPath() + \" to [\" + entry.getValue() + \"]\");\n\t\t\t\t}\n\t\t\t\treturn entry.getValue();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":83610,"modified_method":"@Override\n\tpublic Publisher<Object> getHandler(ReactiveServerHttpRequest request) {\n\t\tfor (Map.Entry<RequestMappingInfo, HandlerMethod> entry : this.methodMap.entrySet()) {\n\t\t\tRequestMappingInfo info = entry.getKey();\n\t\t\tif (info.matchesRequest(request)) {\n\t\t\t\tHandlerMethod handlerMethod = entry.getValue();\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Mapped \" + request.getMethod() + \" \" +\n\t\t\t\t\t\t\trequest.getURI().getPath() + \" to [\" + handlerMethod + \"]\");\n\t\t\t\t}\n\t\t\t\treturn Publishers.just(handlerMethod);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"d319edba28d0fbf24b58525bff3cc5bd04dc934f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void path() throws Exception {\n\t\tReactiveServerHttpRequest request = new MockServerHttpRequest(HttpMethod.GET, \"boo\");\n\t\tHandlerMethod handler = (HandlerMethod) this.mapping.getHandler(request);\n\t\tassertEquals(TestController.class.getMethod(\"boo\"), handler.getMethod());\n\t}","id":83611,"modified_method":"@Test\n\tpublic void path() throws Exception {\n\t\tReactiveServerHttpRequest request = new MockServerHttpRequest(HttpMethod.GET, \"boo\");\n\t\tPublisher<?> handlerPublisher = this.mapping.getHandler(request);\n\t\tHandlerMethod handlerMethod = toHandlerMethod(handlerPublisher);\n\t\tassertEquals(TestController.class.getMethod(\"boo\"), handlerMethod.getMethod());\n\t}","commit_id":"d319edba28d0fbf24b58525bff3cc5bd04dc934f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void method() throws Exception {\n\t\tReactiveServerHttpRequest request = new MockServerHttpRequest(HttpMethod.POST, \"foo\");\n\t\tHandlerMethod handler = (HandlerMethod) this.mapping.getHandler(request);\n\t\tassertEquals(TestController.class.getMethod(\"postFoo\"), handler.getMethod());\n\n\t\trequest = new MockServerHttpRequest(HttpMethod.GET, \"foo\");\n\t\thandler = (HandlerMethod) this.mapping.getHandler(request);\n\t\tassertEquals(TestController.class.getMethod(\"getFoo\"), handler.getMethod());\n\t}","id":83612,"modified_method":"@Test\n\tpublic void method() throws Exception {\n\t\tReactiveServerHttpRequest request = new MockServerHttpRequest(HttpMethod.POST, \"foo\");\n\t\tPublisher<?> handlerPublisher = this.mapping.getHandler(request);\n\t\tHandlerMethod handlerMethod = toHandlerMethod(handlerPublisher);\n\t\tassertEquals(TestController.class.getMethod(\"postFoo\"), handlerMethod.getMethod());\n\n\t\trequest = new MockServerHttpRequest(HttpMethod.GET, \"foo\");\n\t\thandlerPublisher = this.mapping.getHandler(request);\n\t\thandlerMethod = toHandlerMethod(handlerPublisher);\n\t\tassertEquals(TestController.class.getMethod(\"getFoo\"), handlerMethod.getMethod());\n\t}","commit_id":"d319edba28d0fbf24b58525bff3cc5bd04dc934f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Object getHandler(ReactiveServerHttpRequest request) {\n\t\treturn this.handlerMap.get(request.getURI().getPath());\n\t}","id":83613,"modified_method":"@Override\n\tpublic Publisher<Object> getHandler(ReactiveServerHttpRequest request) {\n\t\tString path = request.getURI().getPath();\n\t\tObject handler = this.handlerMap.get(path);\n\t\treturn (handler != null ? Publishers.just(handler) : null);\n\t}","commit_id":"d319edba28d0fbf24b58525bff3cc5bd04dc934f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public ErrorColumn(JavaEditor editor, int height, JavaMode mode) {\n\t\tthis.editor = editor;\n\t\tthis.preferredHeight = height;\n\t\tthis.errorCheckerService = editor.errorCheckerService;\n\n\t\terrorColor = mode.getColor(\"errorbar.errorcolor\"); //, errorColor);\n\t\twarningColor = mode.getColor(\"errorbar.warningcolor\"); //, warningColor);\n\t\t//backgroundColor = mode.getColor(\"errorbar.backgroundcolor\"); //, backgroundColor);\n\t\tbackgroundColor = mode.getColor(\"gutter.bgcolor\");\n\n\t\taddListeners();\n\t}","id":83614,"modified_method":"public ErrorColumn(JavaEditor editor, int height, JavaMode mode) {\n\t\tthis.editor = editor;\n\t\tthis.preferredHeight = height;\n\t\tthis.errorCheckerService = editor.errorCheckerService;\n\n\t\terrorColor = mode.getColor(\"editor.column.error.color\");\n\t\twarningColor = mode.getColor(\"editor.column.warning.color\");\n\t\tbackgroundColor = mode.getColor(\"editor.gutter.bgcolor\");\n\n\t\taddListeners();\n\t}","commit_id":"232a11db423a389d39bc4f362673f7d2f2e0ca81","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Sets ErrorCheckerService and loads theme for TextAreaPainter(XQMode)\n   *\n   * @param ecs\n   * @param mode\n   */\n  public void setMode(JavaMode mode) {\n    //this.errorCheckerService = ecs;\n    //loadTheme(mode);\n\n    errorColor = mode.getColor(\"editor.errorcolor\"); //, errorColor);\n    warningColor = mode.getColor(\"editor.warningcolor\"); //, warningColor);\n    errorMarkerColor = mode.getColor(\"editor.errormarkercolor\"); //, errorMarkerColor);\n    warningMarkerColor = mode.getColor(\"editor.warningmarkercolor\"); //, warningMarkerColor);\n\n    gutterTextFont = mode.getFont(\"editor.gutter.text.font\");\n    gutterTextColor = mode.getColor(\"editor.gutter.text.color\");\n    gutterLineHighlightColor = mode.getColor(\"editor.gutter.linehighlight.color\");\n  }","id":83615,"modified_method":"/**\n   * Sets ErrorCheckerService and loads theme for TextAreaPainter(XQMode)\n   *\n   * @param ecs\n   * @param mode\n   */\n  public void setMode(JavaMode mode) {\n    errorUnderlineColor = mode.getColor(\"editor.error.underline.color\");\n    warningUnderlineColor = mode.getColor(\"editor.warning.underline.color\");\n//    errorMarkerColor = mode.getColor(\"editor.errormarkercolor\");\n//    warningMarkerColor = mode.getColor(\"editor.warningmarkercolor\");\n\n    gutterTextFont = mode.getFont(\"editor.gutter.text.font\");\n    gutterTextColor = mode.getColor(\"editor.gutter.text.color\");\n    gutterLineHighlightColor = mode.getColor(\"editor.gutter.linehighlight.color\");\n  }","commit_id":"232a11db423a389d39bc4f362673f7d2f2e0ca81","url":"https://github.com/processing/processing"},{"original_method":"/**\n   * Paints the underline for an error/warning line\n   *\n   * @param gfx\n   *          the graphics context\n   * @param tokenMarker\n   * @param line\n   *          0-based line number: NOTE\n   * @param x\n   */\n  protected void paintErrorLine(Graphics gfx, int line, int x) {\n    ErrorCheckerService ecs = getEditor().getErrorChecker();\n    if (ecs == null || ecs.problemsList == null) {\n      return;\n    }\n\n    boolean notFound = true;\n    boolean isWarning = false;\n    Problem problem = null;\n\n    errorLineCoords.clear();\n    // Check if current line contains an error. If it does, find if it's an\n    // error or warning\n    for (ErrorMarker emarker : getEditor().getErrorPoints()) {\n      if (emarker.getProblem().getLineNumber() == line) {\n        notFound = false;\n        if (emarker.getType() == ErrorMarker.Warning) {\n          isWarning = true;\n        }\n        problem = emarker.getProblem();\n        //log(problem.toString());\n        break;\n      }\n    }\n\n    if (notFound) {\n      return;\n    }\n\n    // Determine co-ordinates\n    // log(\"Hoff \" + ta.getHorizontalOffset() + \", \" +\n    // horizontalAdjustment);\n    int y = textArea.lineToY(line);\n    y += fm.getLeading() + fm.getMaxDescent();\n//    int height = fm.getHeight();\n    int start = textArea.getLineStartOffset(line) + problem.getPDELineStartOffset();\n    int pLength = problem.getPDELineStopOffset() + 1 - problem.getPDELineStartOffset();\n\n    try {\n      String badCode = null;\n      String goodCode = null;\n      try {\n        SyntaxDocument doc = textArea.getDocument();\n        badCode = doc.getText(start, pLength);\n        goodCode = doc.getText(textArea.getLineStartOffset(line), problem.getPDELineStartOffset());\n        //log(\"paintErrorLine() LineText GC: \" + goodCode);\n        //log(\"paintErrorLine() LineText BC: \" + badCode);\n      } catch (BadLocationException bl) {\n        // Error in the import statements or end of code.\n        // System.out.print(\"BL caught. \" + ta.getLineCount() + \" ,\"\n        // + line + \" ,\");\n        // log((ta.getLineStopOffset(line) - start - 1));\n        return;\n      }\n\n      // Take care of offsets\n      int aw = fm.stringWidth(trimRight(badCode)) + textArea.getHorizontalOffset(); // apparent width. Whitespaces\n      // to the left of line + text\n      // width\n      int rw = fm.stringWidth(badCode.trim()); // real width\n      int x1 = fm.stringWidth(goodCode) + (aw - rw), y1 = y + fm.getHeight()\n          - 2, x2 = x1 + rw;\n      // Adding offsets for the gutter\n      x1 += Editor.LEFT_GUTTER;\n      x2 += Editor.LEFT_GUTTER;\n\n      errorLineCoords.add(new ErrorLineCoord(x1,  x2, y, y1, problem));\n\n      // gfx.fillRect(x1, y, rw, height);\n\n      // Let the painting begin!\n\n      // Little rect at starting of a line containing errors - disabling it for now\n//      gfx.setColor(errorMarkerColor);\n//      if (isWarning) {\n//        gfx.setColor(warningMarkerColor);\n//      }\n//      gfx.fillRect(1, y + 2, 3, height - 2);\n\n      gfx.setColor(errorColor);\n      if (isWarning) {\n        gfx.setColor(warningColor);\n      }\n      int xx = x1;\n\n      // Draw the jagged lines\n      while (xx < x2) {\n        gfx.drawLine(xx, y1, xx + 2, y1 + 1);\n        xx += 2;\n        gfx.drawLine(xx, y1 + 1, xx + 2, y1);\n        xx += 2;\n      }\n    } catch (Exception e) {\n      System.out\n          .println(\"Looks like I messed up! XQTextAreaPainter.paintLine() : \"\n              + e);\n      //e.printStackTrace();\n    }\n\n    // Won't highlight the line. Select the text instead.\n    // gfx.setColor(Color.RED);\n    // gfx.fillRect(2, y, 3, height);\n  }","id":83616,"modified_method":"/**\n   * Paints the underline for an error/warning line\n   *\n   * @param gfx\n   *          the graphics context\n   * @param tokenMarker\n   * @param line\n   *          0-based line number: NOTE\n   * @param x\n   */\n  protected void paintErrorLine(Graphics gfx, int line, int x) {\n    ErrorCheckerService ecs = getEditor().getErrorChecker();\n    if (ecs == null || ecs.problemsList == null) {\n      return;\n    }\n\n    boolean notFound = true;\n    boolean isWarning = false;\n    Problem problem = null;\n\n    errorLineCoords.clear();\n    // Check if current line contains an error. If it does, find if it's an\n    // error or warning\n    for (ErrorMarker emarker : getEditor().getErrorPoints()) {\n      if (emarker.getProblem().getLineNumber() == line) {\n        notFound = false;\n        if (emarker.getType() == ErrorMarker.Warning) {\n          isWarning = true;\n        }\n        problem = emarker.getProblem();\n        //log(problem.toString());\n        break;\n      }\n    }\n\n    if (notFound) {\n      return;\n    }\n\n    // Determine co-ordinates\n    // log(\"Hoff \" + ta.getHorizontalOffset() + \", \" +\n    // horizontalAdjustment);\n    int y = textArea.lineToY(line);\n    y += fm.getLeading() + fm.getMaxDescent();\n//    int height = fm.getHeight();\n    int start = textArea.getLineStartOffset(line) + problem.getPDELineStartOffset();\n    int pLength = problem.getPDELineStopOffset() + 1 - problem.getPDELineStartOffset();\n\n    try {\n      String badCode = null;\n      String goodCode = null;\n      try {\n        SyntaxDocument doc = textArea.getDocument();\n        badCode = doc.getText(start, pLength);\n        goodCode = doc.getText(textArea.getLineStartOffset(line), problem.getPDELineStartOffset());\n        //log(\"paintErrorLine() LineText GC: \" + goodCode);\n        //log(\"paintErrorLine() LineText BC: \" + badCode);\n      } catch (BadLocationException bl) {\n        // Error in the import statements or end of code.\n        // System.out.print(\"BL caught. \" + ta.getLineCount() + \" ,\"\n        // + line + \" ,\");\n        // log((ta.getLineStopOffset(line) - start - 1));\n        return;\n      }\n\n      // Take care of offsets\n      int aw = fm.stringWidth(trimRight(badCode)) + textArea.getHorizontalOffset(); // apparent width. Whitespaces\n      // to the left of line + text\n      // width\n      int rw = fm.stringWidth(badCode.trim()); // real width\n      int x1 = fm.stringWidth(goodCode) + (aw - rw), y1 = y + fm.getHeight()\n          - 2, x2 = x1 + rw;\n      // Adding offsets for the gutter\n      x1 += Editor.LEFT_GUTTER;\n      x2 += Editor.LEFT_GUTTER;\n\n      errorLineCoords.add(new ErrorLineCoord(x1,  x2, y, y1, problem));\n\n      // gfx.fillRect(x1, y, rw, height);\n\n      // Let the painting begin!\n\n      // Little rect at starting of a line containing errors - disabling it for now\n//      gfx.setColor(errorMarkerColor);\n//      if (isWarning) {\n//        gfx.setColor(warningMarkerColor);\n//      }\n//      gfx.fillRect(1, y + 2, 3, height - 2);\n\n      gfx.setColor(errorUnderlineColor);\n      if (isWarning) {\n        gfx.setColor(warningUnderlineColor);\n      }\n      int xx = x1;\n\n      // Draw the jagged lines\n      while (xx < x2) {\n        gfx.drawLine(xx, y1, xx + 2, y1 + 1);\n        xx += 2;\n        gfx.drawLine(xx, y1 + 1, xx + 2, y1);\n        xx += 2;\n      }\n    } catch (Exception e) {\n      System.out\n          .println(\"Looks like I messed up! XQTextAreaPainter.paintLine() : \"\n              + e);\n      //e.printStackTrace();\n    }\n\n    // Won't highlight the line. Select the text instead.\n    // gfx.setColor(Color.RED);\n    // gfx.fillRect(2, y, 3, height);\n  }","commit_id":"232a11db423a389d39bc4f362673f7d2f2e0ca81","url":"https://github.com/processing/processing"},{"original_method":"protected Container createColorFields(String buttonName, ActionListener buttonListener) {\n    Box box = Box.createVerticalBox();\n    box.setAlignmentY(0);\n\n    final int GAP = Base.isWindows() ? 5 : 0;\n    final int BETWEEN = Base.isWindows() ? 8 : 6; //10;\n\n    Box row;\n\n    row = Box.createHorizontalBox();\n    if (Base.isMacOS()) {\n      row.add(Box.createHorizontalStrut(17));\n    } else {\n      row.add(createFixedLabel(\"\"));\n    }\n    // Can't just set the bg color of the panel because it also tints the bevel\n    // (on OS X), which looks odd. So instead we override paintComponent().\n    colorPanel = new JPanel() {\n        public void paintComponent(Graphics g) {\n          g.setColor(new Color(red, green, blue));\n          Dimension size = getSize();\n          g.fillRect(0, 0, size.width, size.height);\n        }\n      };\n    colorPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));\n    Dimension dim = new Dimension(70, 25);\n    colorPanel.setMinimumSize(dim);\n    colorPanel.setMaximumSize(dim);\n    colorPanel.setPreferredSize(dim);\n    row.add(colorPanel);\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(BETWEEN));\n//    if (Base.isMacOS()) {  // need a little extra\n//      box.add(Box.createVerticalStrut(BETWEEN));\n//    }\n\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"H\"));\n    row.add(hueField = new NumberField(4, false));\n    row.add(new JLabel(\" \\u00B0\"));  // degree symbol\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(GAP));\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"S\"));\n    row.add(saturationField = new NumberField(4, false));\n    row.add(new JLabel(\" %\"));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(GAP));\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"B\"));\n    row.add(brightnessField = new NumberField(4, false));\n    row.add(new JLabel(\" %\"));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(BETWEEN));\n\n    //\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"R\"));\n    row.add(redField = new NumberField(4, false));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(GAP));\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"G\"));\n    row.add(greenField = new NumberField(4, false));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(GAP));\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"B\"));\n    row.add(blueField = new NumberField(4, false));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(BETWEEN));\n\n    //\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"\"));\n    // Windows needs extra space, OS X and Linux do not\n    // Mac OS X needs 6 because #CCCCCC is quite wide\n    final int hexCount = Base.isWindows() ? 7 : 6;\n    row.add(hexField = new NumberField(hexCount, true));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(GAP));\n\n    //\n    \n//    // Not great, because the insets make things weird anyway\n//    //Dimension dim = new Dimension(hexField.getPreferredSize()); \n//    Dimension dim = new Dimension(70, 20);\n//    colorPanel.setMinimumSize(dim);\n//    colorPanel.setMaximumSize(dim);\n//    colorPanel.setPreferredSize(dim);\n////    colorPanel.setBorder(new EmptyBorder(hexField.getInsets()));\n\n    // \n    \n    row = Box.createHorizontalBox();\n    if (Base.isMacOS()) {\n      row.add(Box.createHorizontalStrut(11));\n    } else {\n      row.add(createFixedLabel(\"\"));\n    }\n    JButton button = new JButton(buttonName);\n    button.addActionListener(buttonListener);\n    //System.out.println(\"button: \" + button.getInsets());\n    row.add(button);\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    \n    //\n    \n    box.add(Box.createVerticalGlue());\n    return box;\n  }","id":83617,"modified_method":"protected Container createColorFields(String buttonName, ActionListener buttonListener) {\n    Box box = Box.createVerticalBox();\n    box.setAlignmentY(0);\n\n    final int GAP = Base.isWindows() ? 5 : 0;\n    final int BETWEEN = Base.isWindows() ? 8 : 6; //10;\n\n    Box row;\n\n    row = Box.createHorizontalBox();\n    if (Base.isMacOS()) {\n      row.add(Box.createHorizontalStrut(17));\n    } else {\n      row.add(createFixedLabel(\"\"));\n    }\n    // Can't just set the bg color of the panel because it also tints the bevel\n    // (on OS X), which looks odd. So instead we override paintComponent().\n    colorPanel = new JPanel() {\n        public void paintComponent(Graphics g) {\n          g.setColor(new Color(red, green, blue));\n          Dimension size = getSize();\n          g.fillRect(0, 0, size.width, size.height);\n        }\n      };\n    colorPanel.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED));\n    Dimension dim = new Dimension(70, 25);\n    colorPanel.setMinimumSize(dim);\n    colorPanel.setMaximumSize(dim);\n    colorPanel.setPreferredSize(dim);\n    row.add(colorPanel);\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(BETWEEN));\n//    if (Base.isMacOS()) {  // need a little extra\n//      box.add(Box.createVerticalStrut(BETWEEN));\n//    }\n\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"H\"));\n    row.add(hueField = new NumberField(4, false));\n    row.add(new JLabel(\" \\u00B0\"));  // degree symbol\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(GAP));\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"S\"));\n    row.add(saturationField = new NumberField(4, false));\n    row.add(new JLabel(\" %\"));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(GAP));\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"B\"));\n    row.add(brightnessField = new NumberField(4, false));\n    row.add(new JLabel(\" %\"));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(BETWEEN));\n\n    //\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"R\"));\n    row.add(redField = new NumberField(4, false));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(GAP));\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"G\"));\n    row.add(greenField = new NumberField(4, false));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(GAP));\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"B\"));\n    row.add(blueField = new NumberField(4, false));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(BETWEEN));\n\n    //\n\n    row = Box.createHorizontalBox();\n    row.add(createFixedLabel(\"\"));\n    // Windows needs extra space, OS X and Linux do not\n    // Mac OS X needs 6 because #CCCCCC is quite wide\n    final int hexCount = Base.isWindows() ? 7 : 6;\n    row.add(hexField = new NumberField(hexCount, true));\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    box.add(Box.createVerticalStrut(GAP));\n\n    //\n    \n//    // Not great, because the insets make things weird anyway\n//    //Dimension dim = new Dimension(hexField.getPreferredSize()); \n//    Dimension dim = new Dimension(70, 20);\n//    colorPanel.setMinimumSize(dim);\n//    colorPanel.setMaximumSize(dim);\n//    colorPanel.setPreferredSize(dim);\n////    colorPanel.setBorder(new EmptyBorder(hexField.getInsets()));\n\n    // \n    \n    row = Box.createHorizontalBox();\n    if (Base.isMacOS()) {\n      row.add(Box.createHorizontalStrut(11));\n    } else {\n      row.add(createFixedLabel(\"\"));\n    }\n    JButton button = new JButton(buttonName);\n    button.addActionListener(buttonListener);\n    //System.out.println(\"button: \" + button.getInsets());\n    row.add(button);\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    \n    row = Box.createHorizontalBox();\n    if (Base.isMacOS()) {\n      row.add(Box.createHorizontalStrut(11));\n    } else {\n      row.add(createFixedLabel(\"\"));\n    }\n    button = new JButton(\"Cancel\");\n    button.addActionListener(new ActionListener() {\n\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        ColorChooser.this.hide();\n      }\n    });\n    row.add(button);\n    row.add(Box.createHorizontalGlue());\n    box.add(row);\n    //\n    \n    box.add(Box.createVerticalGlue());\n    return box;\n  }","commit_id":"4601397e64c20d60cb7d3864f24b583f46196b76","url":"https://github.com/processing/processing"},{"original_method":"public Preferences(Base base) {\n    this.base = base;\n    //dialog = new JDialog(editor, \"Preferences\", true);\n    dialog = new JFrame(\"Preferences\");\n    dialog.setResizable(false);\n\n//    GroupLayout layout = new GroupLayout(getContentPane());\n//    dialog.getContentPane().setLayout(layout);\n//    layout.setAutoCreateGaps(true);\n//    layout.setAutoCreateContainerGaps(true);\n    \n    Container pain = dialog.getContentPane();\n    pain.setLayout(null);\n\n    int top = GUI_BIG;\n    int left = GUI_BIG;\n    int right = 0;\n\n    JLabel label;\n    JButton button; //, button2;\n    //JComboBox combo;\n    Dimension d, d2; //, d3;\n    int h, vmax;\n\n\n    // Sketchbook location:\n    // [...............................]  [ Browse ]\n\n    label = new JLabel(\"Sketchbook location:\");\n    pain.add(label);\n    d = label.getPreferredSize();\n    label.setBounds(left, top, d.width, d.height);\n    top += d.height; // + GUI_SMALL;\n\n    sketchbookLocationField = new JTextField(40);\n    pain.add(sketchbookLocationField);\n    d = sketchbookLocationField.getPreferredSize();\n\n    button = new JButton(PROMPT_BROWSE);\n    button.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          File dflt = new File(sketchbookLocationField.getText());\n          PApplet.selectFolder(\"Select new sketchbook location\",\n                               \"sketchbookCallback\", dflt,\n                               Preferences.this, dialog);\n//          File file =\n//            Base.selectFolder(\"Select new sketchbook location\", dflt, dialog);\n//          if (file != null) {\n//            sketchbookLocationField.setText(file.getAbsolutePath());\n//          }\n        }\n      });\n    pain.add(button);\n    d2 = button.getPreferredSize();\n\n    // take max height of all components to vertically align em\n    vmax = Math.max(d.height, d2.height);\n    sketchbookLocationField.setBounds(left, top + (vmax-d.height)/2,\n                                      d.width, d.height);\n    h = left + d.width + GUI_SMALL;\n    button.setBounds(h, top + (vmax-d2.height)/2,\n                     d2.width, d2.height);\n\n    right = Math.max(right, h + d2.width + GUI_BIG);\n    top += vmax + GUI_BETWEEN;\n\n\n    // Editor and console font [ Source Code Pro ]\n\n    // Nevermind on this for now.. Java doesn't seem to have a method for \n    // enumerating only the fixed-width (monospaced) fonts. To do this \n    // properly, we'd need to list the fonts, and compare the metrics of \n    // i and M for each. When they're identical (and not degenerate), \n    // we'd call that font fixed width. That's all a very expensive set of \n    // operations, so it should also probably be cached between runs and \n    // updated in the background.\n\n    Container fontBox = Box.createHorizontalBox();\n    JLabel fontLabel = new JLabel(\"Editor and Console font \");\n    final String fontTip = \"<html>\" +\n      \"Select the font used in the Editor and the Console.<br/>\" +\n      \"Only monospaced (fixed-width) fonts may be used, <br/>\" +\n      \"though the list may be imperfect.\";\n    fontLabel.setToolTipText(fontTip);\n    fontBox.add(fontLabel);\n    // get a wide name in there before getPreferredSize() is called\n    fontSelectionBox = new JComboBox(new Object[] { Toolkit.getMonoFontName() });\n    fontSelectionBox.setToolTipText(fontTip);\n//    fontSelectionBox.addItem(Toolkit.getMonoFont(size, style));\n    //updateDisplayList();  \n    fontSelectionBox.setEnabled(false);  // don't enable until fonts are loaded\n    fontBox.add(fontSelectionBox);\n//    fontBox.add(Box.createHorizontalGlue());\n    pain.add(fontBox);\n    d = fontBox.getPreferredSize();\n    fontBox.setBounds(left, top, d.width + 150, d.height);\n//    fontBox.setBounds(left, top, dialog.getWidth() - left*2, d.height);\n    top += d.height + GUI_BETWEEN;\n    \n    \n    // Editor font size [ 12 ]  Console font size [ 10 ]\n\n    Container box = Box.createHorizontalBox();\n    \n    label = new JLabel(\"Editor font size: \");\n    box.add(label);\n    //fontSizeField = new JTextField(4);\n    fontSizeField = new JComboBox<Integer>(FONT_SIZES);\n    fontSizeField.setEditable(true);\n    box.add(fontSizeField);\n//    label = new JLabel(\"  (requires restart of Processing)\");\n//    box.add(label);\n    box.add(Box.createHorizontalStrut(GUI_BETWEEN));\n\n    label = new JLabel(\"Console font size: \");\n    box.add(label);\n    consoleSizeField = new JComboBox<Integer>(FONT_SIZES);\n    consoleSizeField.setEditable(true);\n    box.add(consoleSizeField);\n    \n    pain.add(box);\n    d = box.getPreferredSize();\n    box.setBounds(left, top, d.width, d.height);\n//    Font editorFont = Preferences.getFont(\"editor.font\");\n    //fontSizeField.setText(String.valueOf(editorFont.getSize()));\n//    fontSizeField.setSelectedItem(editorFont.getSize());\n    fontSizeField.setSelectedItem(Preferences.getFont(\"editor.font.size\"));\n    top += d.height + GUI_BETWEEN;\n\n    Container colorBox = Box.createHorizontalBox();\n\n    label = new JLabel(\"Background color when Presenting: \");\n    colorBox.add(label);\n\n    final String colorTip = \"<html>\"\n        + \"Select the background color used when using Present.<br/>\"\n        + \"Present is used to present a sketch in full-screen, <br/>\"\n        + \"accessible from the Sketch menu.\";\n    label.setToolTipText(colorTip);\n\n    presentColor = new JTextField(\"      \");\n    presentColor.setOpaque(true);\n    presentColor.setEnabled(false);\n    presentColor.setBorder(BorderFactory.createLineBorder(Color.BLACK));\n    presentColor.setBackground(Preferences.getColor(\"run.present.bgcolor\"));\n    presentColor.setForeground(Preferences.getColor(\"run.present.bgcolor\"));\n\n    presentColorHex = new JTextField(6);\n    presentColorHex\n        .setText(Preferences.get(\"run.present.bgcolor\").substring(1));\n    presentColorHex.getDocument().addDocumentListener(new DocumentListener() {\n\n      @Override\n      public void removeUpdate(DocumentEvent e) {\n        final String colorValue = presentColorHex.getText().toUpperCase();\n        if (colorValue.length() == 7 && (colorValue.startsWith(\"#\")))\n          EventQueue.invokeLater(new Runnable() {\n            public void run() {\n              presentColorHex.setText(colorValue.substring(1));\n            }\n          });\n        if (colorValue.length() == 6\n            && colorValue.matches(\"[0123456789ABCDEF]*\")) {\n          presentColor.setBackground(new Color(Integer.parseInt(\n              colorValue.substring(0, 2), 16), Integer.parseInt(\n              colorValue.substring(2, 4), 16), Integer.parseInt(\n              colorValue.substring(4, 6), 16)));\n          if (!colorValue.equals(presentColorHex.getText()))\n            EventQueue.invokeLater(new Runnable() {\n              public void run() {\n                presentColorHex.setText(colorValue);\n              }\n            });\n        }\n      }\n\n      @Override\n      public void insertUpdate(DocumentEvent e) {\n        final String colorValue = presentColorHex.getText().toUpperCase();\n        if (colorValue.length() == 7 && (colorValue.startsWith(\"#\")))\n          EventQueue.invokeLater(new Runnable() {\n            public void run() {\n              presentColorHex.setText(colorValue.substring(1));\n            }\n          });\n        if (colorValue.length() == 6\n            && colorValue.matches(\"[0123456789ABCDEF]*\")) {\n          presentColor.setBackground(new Color(Integer.parseInt(\n              colorValue.substring(0, 2), 16), Integer.parseInt(\n              colorValue.substring(2, 4), 16), Integer.parseInt(\n              colorValue.substring(4, 6), 16)));\n          if (!colorValue.equals(presentColorHex.getText()))\n            EventQueue.invokeLater(new Runnable() {\n              public void run() {\n                presentColorHex.setText(colorValue);\n              }\n            });\n        }\n      }\n\n      @Override\n      public void changedUpdate(DocumentEvent e) {\n      }\n    });\n\n    final CustomColorChooser c = new CustomColorChooser(\n        Preferences.getColor(\"run.present.bgcolor\"), presentColorHex,\n        presentColor);\n\n    presentColor.addMouseListener(new MouseListener() {\n\n      @Override\n      public void mouseReleased(MouseEvent e) {\n      }\n\n      @Override\n      public void mousePressed(MouseEvent e) {\n      }\n\n      @Override\n      public void mouseExited(MouseEvent e) {\n      }\n\n      @Override\n      public void mouseEntered(MouseEvent e) {\n      }\n\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        c.show();\n      }\n    });\n\n    presentColorHex.addInputMethodListener(new InputMethodListener() {\n\n      @Override\n      public void inputMethodTextChanged(InputMethodEvent event) {\n      }\n\n      @Override\n      public void caretPositionChanged(InputMethodEvent event) {\n      }\n    });\n\n    colorBox.add(presentColor);\n\n    colorBox.add(Box.createHorizontalStrut(GUI_SMALL));\n\n    label = new JLabel(\"#\");\n    colorBox.add(label);\n\n    colorBox.add(presentColorHex);\n\n    pain.add(colorBox);\n    d = colorBox.getPreferredSize();\n    colorBox.setBounds(left, top, d.width, d.height);\n\n    top += d.height + GUI_BETWEEN;\n\n    // [ ] Use smooth text in editor window\n\n    editorAntialiasBox = new JCheckBox(\"Use smooth text in editor window\");\n//      new JCheckBox(\"Use smooth text in editor window \" +\n//                    \"(requires restart of Processing)\");\n    pain.add(editorAntialiasBox);\n    d = editorAntialiasBox.getPreferredSize();\n    // adding +10 because ubuntu + jre 1.5 truncating items\n    editorAntialiasBox.setBounds(left, top, d.width + 10, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height + GUI_BETWEEN;\n\n\n    // [ ] Enable complex text input (for Japanese et al, requires restart)\n\n    inputMethodBox =\n      new JCheckBox(\"Enable complex text input \" +\n                    \"(i.e. Japanese, requires restart of Processing)\");\n    pain.add(inputMethodBox);\n    d = inputMethodBox.getPreferredSize();\n    inputMethodBox.setBounds(left, top, d.width + 10, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height + GUI_BETWEEN;\n\n\n    // [ ] Increase maximum available memory to [______] MB\n\n    Container memoryBox = Box.createHorizontalBox();\n    memoryOverrideBox = new JCheckBox(\"Increase maximum available memory to \");\n    memoryBox.add(memoryOverrideBox);\n    memoryField = new JTextField(4);\n    memoryBox.add(memoryField);\n    memoryBox.add(new JLabel(\" MB\"));\n    pain.add(memoryBox);\n    d = memoryBox.getPreferredSize();\n    memoryBox.setBounds(left, top, d.width, d.height);\n    top += d.height + GUI_BETWEEN;\n\n\n//    // [ ] Use multiple .jar files when exporting applets\n//\n//    exportSeparateBox =\n//      new JCheckBox(\"Use multiple .jar files when exporting applets \" +\n//                    \"(ignored when using libraries)\");\n//    pain.add(exportSeparateBox);\n//    d = exportSeparateBox.getPreferredSize();\n//    // adding +10 because ubuntu + jre 1.5 truncating items\n//    exportSeparateBox.setBounds(left, top, d.width + 10, d.height);\n//    right = Math.max(right, left + d.width);\n//    top += d.height + GUI_BETWEEN;\n\n\n    // [ ] Delete previous application folder on export\n\n    deletePreviousBox =\n      new JCheckBox(\"Delete previous application folder on export\");\n    pain.add(deletePreviousBox);\n    d = deletePreviousBox.getPreferredSize();\n    deletePreviousBox.setBounds(left, top, d.width + 10, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height + GUI_BETWEEN;\n    \n    \n//    // [ ] Use external editor\n//\n//    externalEditorBox = new JCheckBox(\"Use external editor\");\n//    pain.add(externalEditorBox);\n//    d = externalEditorBox.getPreferredSize();\n//    externalEditorBox.setBounds(left, top, d.width + 10, d.height);\n//    right = Math.max(right, left + d.width);\n//    top += d.height + GUI_BETWEEN;\n\n    \n    // [ ] Use external editor\n\n    whinyBox = new JCheckBox(\"Hide tab/toolbar background image (requires restart)\");\n    pain.add(whinyBox);\n    d = whinyBox.getPreferredSize();\n    whinyBox.setBounds(left, top, d.width + 10, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height + GUI_BETWEEN;\n\n\n    // [ ] Check for updates on startup\n\n    checkUpdatesBox = new JCheckBox(\"Check for updates on startup\");\n    pain.add(checkUpdatesBox);\n    d = checkUpdatesBox.getPreferredSize();\n    checkUpdatesBox.setBounds(left, top, d.width + 10, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height + GUI_BETWEEN;\n\n\n    // Run sketches on display [  1 ]\n\n    Container displayBox = Box.createHorizontalBox();\n    JLabel displayLabel = new JLabel(\"Run sketches on display \");\n    final String tip = \"<html>\" +\n      \"Sets the display where sketches are initially placed.<br>\" +\n      \"As usual, if the sketch window is moved, it will re-open<br>\" +\n      \"at the same location, however when running in present<br>\" +\n      \"(full screen) mode, this display will always be used.\";\n    displayLabel.setToolTipText(tip);\n    displayBox.add(displayLabel);\n    displaySelectionBox = new JComboBox();\n    updateDisplayList();  // needs to happen here for getPreferredSize()\n    displayBox.add(displaySelectionBox);\n    pain.add(displayBox);\n    d = displayBox.getPreferredSize();\n    displayBox.setBounds(left, top, d.width, d.height);\n    top += d.height + GUI_BETWEEN;\n\n\n    // [ ] Automatically associate .pde files with Processing\n\n    if (Base.isWindows()) {\n      autoAssociateBox =\n        new JCheckBox(\"Automatically associate .pde files with Processing\");\n      pain.add(autoAssociateBox);\n      d = autoAssociateBox.getPreferredSize();\n      autoAssociateBox.setBounds(left, top, d.width + 10, d.height);\n      right = Math.max(right, left + d.width);\n      top += d.height + GUI_BETWEEN;\n    }\n\n\n    // Launch programs as [ ] 32-bit [ ] 64-bit (Mac OS X only)\n\n    /*\n    if (Base.isMacOS()) {\n      box = Box.createHorizontalBox();\n      label = new JLabel(\"Launch programs in  \");\n      box.add(label);\n      bitsThirtyTwoButton = new JRadioButton(\"32-bit mode  \");\n      box.add(bitsThirtyTwoButton);\n      bitsSixtyFourButton = new JRadioButton(\"64-bit mode\");\n      box.add(bitsSixtyFourButton);\n\n      ButtonGroup bg = new ButtonGroup();\n      bg.add(bitsThirtyTwoButton);\n      bg.add(bitsSixtyFourButton);\n\n      pain.add(box);\n      d = box.getPreferredSize();\n      box.setBounds(left, top, d.width, d.height);\n      top += d.height + GUI_BETWEEN;\n    }\n    */\n\n\n    // More preferences are in the ...\n\n    label = new JLabel(\"More preferences can be edited directly in the file\");\n    pain.add(label);\n    d = label.getPreferredSize();\n    label.setForeground(Color.gray);\n    label.setBounds(left, top, d.width, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height; // + GUI_SMALL;\n\n    label = new JLabel(preferencesFile.getAbsolutePath());\n    final JLabel clickable = label;\n    label.addMouseListener(new MouseAdapter() {\n        public void mousePressed(MouseEvent e) {\n          Base.openFolder(Base.getSettingsFolder());\n        }\n\n        public void mouseEntered(MouseEvent e) {\n          clickable.setForeground(new Color(0, 0, 140));\n        }\n\n        public void mouseExited(MouseEvent e) {\n          clickable.setForeground(Color.BLACK);\n        }\n      });\n    pain.add(label);\n    d = label.getPreferredSize();\n    label.setBounds(left, top, d.width, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height;\n\n    label = new JLabel(\"(edit only when Processing is not running)\");\n    pain.add(label);\n    d = label.getPreferredSize();\n    label.setForeground(Color.gray);\n    label.setBounds(left, top, d.width, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height; // + GUI_SMALL;\n\n\n    // [  OK  ] [ Cancel ]  maybe these should be next to the message?\n\n    button = new JButton(PROMPT_OK);\n    button.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          applyFrame();\n          disposeFrame();\n        }\n      });\n    pain.add(button);\n    d2 = button.getPreferredSize();\n    BUTTON_HEIGHT = d2.height;\n\n    h = right - (BUTTON_WIDTH + GUI_SMALL + BUTTON_WIDTH);\n    button.setBounds(h, top, BUTTON_WIDTH, BUTTON_HEIGHT);\n    h += BUTTON_WIDTH + GUI_SMALL;\n\n    button = new JButton(PROMPT_CANCEL);\n    button.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          disposeFrame();\n        }\n      });\n    pain.add(button);\n    button.setBounds(h, top, BUTTON_WIDTH, BUTTON_HEIGHT);\n\n    top += BUTTON_HEIGHT + GUI_BETWEEN;\n\n\n    // finish up\n\n    wide = right + GUI_BIG;\n    high = top + GUI_SMALL;\n\n\n    // closing the window is same as hitting cancel button\n\n    dialog.addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n          disposeFrame();\n        }\n      });\n\n    ActionListener disposer = new ActionListener() {\n        public void actionPerformed(ActionEvent actionEvent) {\n          disposeFrame();\n        }\n      };\n    Toolkit.registerWindowCloseKeys(dialog.getRootPane(), disposer);\n    Toolkit.setIcon(dialog);\n\n    Dimension screen = Toolkit.getScreenSize();\n    dialog.setLocation((screen.width - wide) / 2,\n                      (screen.height - high) / 2);\n\n    dialog.pack(); // get insets\n    Insets insets = dialog.getInsets();\n    dialog.setSize(wide + insets.left + insets.right,\n                  high + insets.top + insets.bottom);\n\n\n    // handle window closing commands for ctrl/cmd-W or hitting ESC.\n\n    pain.addKeyListener(new KeyAdapter() {\n        public void keyPressed(KeyEvent e) {\n          //System.out.println(e);\n          KeyStroke wc = Toolkit.WINDOW_CLOSE_KEYSTROKE;\n          if ((e.getKeyCode() == KeyEvent.VK_ESCAPE) ||\n              (KeyStroke.getKeyStrokeForEvent(e).equals(wc))) {\n            disposeFrame();\n          }\n        }\n      });\n  }","id":83618,"modified_method":"public Preferences(Base base) {\n    this.base = base;\n    //dialog = new JDialog(editor, \"Preferences\", true);\n    dialog = new JFrame(\"Preferences\");\n    dialog.setResizable(false);\n\n//    GroupLayout layout = new GroupLayout(getContentPane());\n//    dialog.getContentPane().setLayout(layout);\n//    layout.setAutoCreateGaps(true);\n//    layout.setAutoCreateContainerGaps(true);\n    \n    Container pain = dialog.getContentPane();\n    pain.setLayout(null);\n\n    int top = GUI_BIG;\n    int left = GUI_BIG;\n    int right = 0;\n\n    JLabel label;\n    JButton button; //, button2;\n    //JComboBox combo;\n    Dimension d, d2; //, d3;\n    int h, vmax;\n\n\n    // Sketchbook location:\n    // [...............................]  [ Browse ]\n\n    label = new JLabel(\"Sketchbook location:\");\n    pain.add(label);\n    d = label.getPreferredSize();\n    label.setBounds(left, top, d.width, d.height);\n    top += d.height; // + GUI_SMALL;\n\n    sketchbookLocationField = new JTextField(40);\n    pain.add(sketchbookLocationField);\n    d = sketchbookLocationField.getPreferredSize();\n\n    button = new JButton(PROMPT_BROWSE);\n    button.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          File dflt = new File(sketchbookLocationField.getText());\n          PApplet.selectFolder(\"Select new sketchbook location\",\n                               \"sketchbookCallback\", dflt,\n                               Preferences.this, dialog);\n//          File file =\n//            Base.selectFolder(\"Select new sketchbook location\", dflt, dialog);\n//          if (file != null) {\n//            sketchbookLocationField.setText(file.getAbsolutePath());\n//          }\n        }\n      });\n    pain.add(button);\n    d2 = button.getPreferredSize();\n\n    // take max height of all components to vertically align em\n    vmax = Math.max(d.height, d2.height);\n    sketchbookLocationField.setBounds(left, top + (vmax-d.height)/2,\n                                      d.width, d.height);\n    h = left + d.width + GUI_SMALL;\n    button.setBounds(h, top + (vmax-d2.height)/2,\n                     d2.width, d2.height);\n\n    right = Math.max(right, h + d2.width + GUI_BIG);\n    top += vmax + GUI_BETWEEN;\n\n\n    // Editor and console font [ Source Code Pro ]\n\n    // Nevermind on this for now.. Java doesn't seem to have a method for \n    // enumerating only the fixed-width (monospaced) fonts. To do this \n    // properly, we'd need to list the fonts, and compare the metrics of \n    // i and M for each. When they're identical (and not degenerate), \n    // we'd call that font fixed width. That's all a very expensive set of \n    // operations, so it should also probably be cached between runs and \n    // updated in the background.\n\n    Container fontBox = Box.createHorizontalBox();\n    JLabel fontLabel = new JLabel(\"Editor and Console font \");\n    final String fontTip = \"<html>\" +\n      \"Select the font used in the Editor and the Console.<br/>\" +\n      \"Only monospaced (fixed-width) fonts may be used, <br/>\" +\n      \"though the list may be imperfect.\";\n    fontLabel.setToolTipText(fontTip);\n    fontBox.add(fontLabel);\n    // get a wide name in there before getPreferredSize() is called\n    fontSelectionBox = new JComboBox(new Object[] { Toolkit.getMonoFontName() });\n    fontSelectionBox.setToolTipText(fontTip);\n//    fontSelectionBox.addItem(Toolkit.getMonoFont(size, style));\n    //updateDisplayList();  \n    fontSelectionBox.setEnabled(false);  // don't enable until fonts are loaded\n    fontBox.add(fontSelectionBox);\n//    fontBox.add(Box.createHorizontalGlue());\n    pain.add(fontBox);\n    d = fontBox.getPreferredSize();\n    fontBox.setBounds(left, top, d.width + 150, d.height);\n//    fontBox.setBounds(left, top, dialog.getWidth() - left*2, d.height);\n    top += d.height + GUI_BETWEEN;\n    \n    \n    // Editor font size [ 12 ]  Console font size [ 10 ]\n\n    Container box = Box.createHorizontalBox();\n    \n    label = new JLabel(\"Editor font size: \");\n    box.add(label);\n    //fontSizeField = new JTextField(4);\n    fontSizeField = new JComboBox<Integer>(FONT_SIZES);\n    fontSizeField.setEditable(true);\n    box.add(fontSizeField);\n//    label = new JLabel(\"  (requires restart of Processing)\");\n//    box.add(label);\n    box.add(Box.createHorizontalStrut(GUI_BETWEEN));\n\n    label = new JLabel(\"Console font size: \");\n    box.add(label);\n    consoleSizeField = new JComboBox<Integer>(FONT_SIZES);\n    consoleSizeField.setEditable(true);\n    box.add(consoleSizeField);\n    \n    pain.add(box);\n    d = box.getPreferredSize();\n    box.setBounds(left, top, d.width, d.height);\n//    Font editorFont = Preferences.getFont(\"editor.font\");\n    //fontSizeField.setText(String.valueOf(editorFont.getSize()));\n//    fontSizeField.setSelectedItem(editorFont.getSize());\n    fontSizeField.setSelectedItem(Preferences.getFont(\"editor.font.size\"));\n    top += d.height + GUI_BETWEEN;\n    \n    \n    Container colorBox = Box.createHorizontalBox();\n\n    label = new JLabel(\"Background color when Presenting: \");\n    colorBox.add(label);\n\n    final String colorTip = \"<html>\"\n        + \"Select the background color used when using Present.<br/>\"\n        + \"Present is used to present a sketch in full-screen, <br/>\"\n        + \"accessible from the Sketch menu.\";\n    label.setToolTipText(colorTip);\n\n    presentColor = new JTextField(\"      \");\n    presentColor.setOpaque(true);\n    presentColor.setEnabled(false);\n    presentColor.setBorder(BorderFactory.createLineBorder(Color.BLACK));\n    presentColor.setBackground(Preferences.getColor(\"run.present.bgcolor\"));\n\n    presentColorHex = new JTextField(6);\n    presentColorHex\n        .setText(Preferences.get(\"run.present.bgcolor\").substring(1));\n    presentColorHex.getDocument().addDocumentListener(new DocumentListener() {\n\n      @Override\n      public void removeUpdate(DocumentEvent e) {\n        final String colorValue = presentColorHex.getText().toUpperCase();\n        if (colorValue.length() == 7 && (colorValue.startsWith(\"#\")))\n          EventQueue.invokeLater(new Runnable() {\n            public void run() {\n              presentColorHex.setText(colorValue.substring(1));\n            }\n          });\n        if (colorValue.length() == 6\n            && colorValue.matches(\"[0123456789ABCDEF]*\")) {\n          presentColor.setBackground(new Color(Integer.parseInt(\n              colorValue.substring(0, 2), 16), Integer.parseInt(\n              colorValue.substring(2, 4), 16), Integer.parseInt(\n              colorValue.substring(4, 6), 16)));\n          if (!colorValue.equals(presentColorHex.getText()))\n            EventQueue.invokeLater(new Runnable() {\n              public void run() {\n                presentColorHex.setText(colorValue);\n              }\n            });\n        }\n      }\n\n      @Override\n      public void insertUpdate(DocumentEvent e) {\n        final String colorValue = presentColorHex.getText().toUpperCase();\n        if (colorValue.length() == 7 && (colorValue.startsWith(\"#\")))\n          EventQueue.invokeLater(new Runnable() {\n            public void run() {\n              presentColorHex.setText(colorValue.substring(1));\n            }\n          });\n        if (colorValue.length() == 6\n            && colorValue.matches(\"[0123456789ABCDEF]*\")) {\n          presentColor.setBackground(new Color(Integer.parseInt(\n              colorValue.substring(0, 2), 16), Integer.parseInt(\n              colorValue.substring(2, 4), 16), Integer.parseInt(\n              colorValue.substring(4, 6), 16)));\n          if (!colorValue.equals(presentColorHex.getText()))\n            EventQueue.invokeLater(new Runnable() {\n              public void run() {\n                presentColorHex.setText(colorValue);\n              }\n            });\n        }\n      }\n\n      @Override public void changedUpdate(DocumentEvent e) {}\n    });\n\n    selector = new ColorChooser(\n      dialog, false, Preferences.getColor(\"run.present.bgcolor\"), \"OK\", new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          String colorValue = selector.getHexColor();\n          presentColorHex.setText(colorValue.substring(1));\n          presentColor.setBackground(new Color(Integer.parseInt(\n              colorValue.substring(1, 3), 16), Integer.parseInt(\n              colorValue.substring(3, 5), 16), Integer.parseInt(\n              colorValue.substring(5, 7), 16)));\n          selector.hide();\n        }\n      });\n\n    presentColor.addMouseListener(new MouseListener() {\n      @Override public void mouseReleased(MouseEvent e) {}\n      @Override public void mousePressed(MouseEvent e) {}\n      @Override public void mouseExited(MouseEvent e) {}\n      @Override public void mouseEntered(MouseEvent e) {}\n\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        selector.show();\n      }\n    });\n\n    label = new JLabel(\"#\");\n    colorBox.add(label);\n\n    colorBox.add(presentColorHex);\n\n    colorBox.add(Box.createHorizontalStrut(GUI_SMALL));\n\n    colorBox.add(presentColor);\n\n    pain.add(colorBox);\n    d = colorBox.getPreferredSize();\n    colorBox.setBounds(left, top, d.width, d.height);\n\n    top += d.height + GUI_BETWEEN;\n\n    // [ ] Use smooth text in editor window\n\n    editorAntialiasBox = new JCheckBox(\"Use smooth text in editor window\");\n//      new JCheckBox(\"Use smooth text in editor window \" +\n//                    \"(requires restart of Processing)\");\n    pain.add(editorAntialiasBox);\n    d = editorAntialiasBox.getPreferredSize();\n    // adding +10 because ubuntu + jre 1.5 truncating items\n    editorAntialiasBox.setBounds(left, top, d.width + 10, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height + GUI_BETWEEN;\n\n\n    // [ ] Enable complex text input (for Japanese et al, requires restart)\n\n    inputMethodBox =\n      new JCheckBox(\"Enable complex text input \" +\n                    \"(i.e. Japanese, requires restart of Processing)\");\n    pain.add(inputMethodBox);\n    d = inputMethodBox.getPreferredSize();\n    inputMethodBox.setBounds(left, top, d.width + 10, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height + GUI_BETWEEN;\n\n\n    // [ ] Increase maximum available memory to [______] MB\n\n    Container memoryBox = Box.createHorizontalBox();\n    memoryOverrideBox = new JCheckBox(\"Increase maximum available memory to \");\n    memoryBox.add(memoryOverrideBox);\n    memoryField = new JTextField(4);\n    memoryBox.add(memoryField);\n    memoryBox.add(new JLabel(\" MB\"));\n    pain.add(memoryBox);\n    d = memoryBox.getPreferredSize();\n    memoryBox.setBounds(left, top, d.width, d.height);\n    top += d.height + GUI_BETWEEN;\n\n\n//    // [ ] Use multiple .jar files when exporting applets\n//\n//    exportSeparateBox =\n//      new JCheckBox(\"Use multiple .jar files when exporting applets \" +\n//                    \"(ignored when using libraries)\");\n//    pain.add(exportSeparateBox);\n//    d = exportSeparateBox.getPreferredSize();\n//    // adding +10 because ubuntu + jre 1.5 truncating items\n//    exportSeparateBox.setBounds(left, top, d.width + 10, d.height);\n//    right = Math.max(right, left + d.width);\n//    top += d.height + GUI_BETWEEN;\n\n\n    // [ ] Delete previous application folder on export\n\n    deletePreviousBox =\n      new JCheckBox(\"Delete previous application folder on export\");\n    pain.add(deletePreviousBox);\n    d = deletePreviousBox.getPreferredSize();\n    deletePreviousBox.setBounds(left, top, d.width + 10, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height + GUI_BETWEEN;\n    \n    \n//    // [ ] Use external editor\n//\n//    externalEditorBox = new JCheckBox(\"Use external editor\");\n//    pain.add(externalEditorBox);\n//    d = externalEditorBox.getPreferredSize();\n//    externalEditorBox.setBounds(left, top, d.width + 10, d.height);\n//    right = Math.max(right, left + d.width);\n//    top += d.height + GUI_BETWEEN;\n\n    \n    // [ ] Use external editor\n\n    whinyBox = new JCheckBox(\"Hide tab/toolbar background image (requires restart)\");\n    pain.add(whinyBox);\n    d = whinyBox.getPreferredSize();\n    whinyBox.setBounds(left, top, d.width + 10, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height + GUI_BETWEEN;\n\n\n    // [ ] Check for updates on startup\n\n    checkUpdatesBox = new JCheckBox(\"Check for updates on startup\");\n    pain.add(checkUpdatesBox);\n    d = checkUpdatesBox.getPreferredSize();\n    checkUpdatesBox.setBounds(left, top, d.width + 10, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height + GUI_BETWEEN;\n\n\n    // Run sketches on display [  1 ]\n\n    Container displayBox = Box.createHorizontalBox();\n    JLabel displayLabel = new JLabel(\"Run sketches on display \");\n    final String tip = \"<html>\" +\n      \"Sets the display where sketches are initially placed.<br>\" +\n      \"As usual, if the sketch window is moved, it will re-open<br>\" +\n      \"at the same location, however when running in present<br>\" +\n      \"(full screen) mode, this display will always be used.\";\n    displayLabel.setToolTipText(tip);\n    displayBox.add(displayLabel);\n    displaySelectionBox = new JComboBox();\n    updateDisplayList();  // needs to happen here for getPreferredSize()\n    displayBox.add(displaySelectionBox);\n    pain.add(displayBox);\n    d = displayBox.getPreferredSize();\n    displayBox.setBounds(left, top, d.width, d.height);\n    top += d.height + GUI_BETWEEN;\n\n\n    // [ ] Automatically associate .pde files with Processing\n\n    if (Base.isWindows()) {\n      autoAssociateBox =\n        new JCheckBox(\"Automatically associate .pde files with Processing\");\n      pain.add(autoAssociateBox);\n      d = autoAssociateBox.getPreferredSize();\n      autoAssociateBox.setBounds(left, top, d.width + 10, d.height);\n      right = Math.max(right, left + d.width);\n      top += d.height + GUI_BETWEEN;\n    }\n\n\n    // Launch programs as [ ] 32-bit [ ] 64-bit (Mac OS X only)\n\n    /*\n    if (Base.isMacOS()) {\n      box = Box.createHorizontalBox();\n      label = new JLabel(\"Launch programs in  \");\n      box.add(label);\n      bitsThirtyTwoButton = new JRadioButton(\"32-bit mode  \");\n      box.add(bitsThirtyTwoButton);\n      bitsSixtyFourButton = new JRadioButton(\"64-bit mode\");\n      box.add(bitsSixtyFourButton);\n\n      ButtonGroup bg = new ButtonGroup();\n      bg.add(bitsThirtyTwoButton);\n      bg.add(bitsSixtyFourButton);\n\n      pain.add(box);\n      d = box.getPreferredSize();\n      box.setBounds(left, top, d.width, d.height);\n      top += d.height + GUI_BETWEEN;\n    }\n    */\n\n\n    // More preferences are in the ...\n\n    label = new JLabel(\"More preferences can be edited directly in the file\");\n    pain.add(label);\n    d = label.getPreferredSize();\n    label.setForeground(Color.gray);\n    label.setBounds(left, top, d.width, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height; // + GUI_SMALL;\n\n    label = new JLabel(preferencesFile.getAbsolutePath());\n    final JLabel clickable = label;\n    label.addMouseListener(new MouseAdapter() {\n        public void mousePressed(MouseEvent e) {\n          Base.openFolder(Base.getSettingsFolder());\n        }\n\n        public void mouseEntered(MouseEvent e) {\n          clickable.setForeground(new Color(0, 0, 140));\n        }\n\n        public void mouseExited(MouseEvent e) {\n          clickable.setForeground(Color.BLACK);\n        }\n      });\n    pain.add(label);\n    d = label.getPreferredSize();\n    label.setBounds(left, top, d.width, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height;\n\n    label = new JLabel(\"(edit only when Processing is not running)\");\n    pain.add(label);\n    d = label.getPreferredSize();\n    label.setForeground(Color.gray);\n    label.setBounds(left, top, d.width, d.height);\n    right = Math.max(right, left + d.width);\n    top += d.height; // + GUI_SMALL;\n\n\n    // [  OK  ] [ Cancel ]  maybe these should be next to the message?\n\n    button = new JButton(PROMPT_OK);\n    button.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          applyFrame();\n          disposeFrame();\n        }\n      });\n    pain.add(button);\n    d2 = button.getPreferredSize();\n    BUTTON_HEIGHT = d2.height;\n\n    h = right - (BUTTON_WIDTH + GUI_SMALL + BUTTON_WIDTH);\n    button.setBounds(h, top, BUTTON_WIDTH, BUTTON_HEIGHT);\n    h += BUTTON_WIDTH + GUI_SMALL;\n\n    button = new JButton(PROMPT_CANCEL);\n    button.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          disposeFrame();\n        }\n      });\n    pain.add(button);\n    button.setBounds(h, top, BUTTON_WIDTH, BUTTON_HEIGHT);\n\n    top += BUTTON_HEIGHT + GUI_BETWEEN;\n\n\n    // finish up\n\n    wide = right + GUI_BIG;\n    high = top + GUI_SMALL;\n\n\n    // closing the window is same as hitting cancel button\n\n    dialog.addWindowListener(new WindowAdapter() {\n        public void windowClosing(WindowEvent e) {\n          disposeFrame();\n        }\n      });\n\n    ActionListener disposer = new ActionListener() {\n        public void actionPerformed(ActionEvent actionEvent) {\n          disposeFrame();\n        }\n      };\n    Toolkit.registerWindowCloseKeys(dialog.getRootPane(), disposer);\n    Toolkit.setIcon(dialog);\n\n    Dimension screen = Toolkit.getScreenSize();\n    dialog.setLocation((screen.width - wide) / 2,\n                      (screen.height - high) / 2);\n\n    dialog.pack(); // get insets\n    Insets insets = dialog.getInsets();\n    dialog.setSize(wide + insets.left + insets.right,\n                  high + insets.top + insets.bottom);\n\n\n    // handle window closing commands for ctrl/cmd-W or hitting ESC.\n\n    pain.addKeyListener(new KeyAdapter() {\n        public void keyPressed(KeyEvent e) {\n          //System.out.println(e);\n          KeyStroke wc = Toolkit.WINDOW_CLOSE_KEYSTROKE;\n          if ((e.getKeyCode() == KeyEvent.VK_ESCAPE) ||\n              (KeyStroke.getKeyStrokeForEvent(e).equals(wc))) {\n            disposeFrame();\n          }\n        }\n      });\n  }","commit_id":"4601397e64c20d60cb7d3864f24b583f46196b76","url":"https://github.com/processing/processing"},{"original_method":"protected void showFrame() {\n    editorAntialiasBox.setSelected(getBoolean(\"editor.smooth\")); //$NON-NLS-1$\n    inputMethodBox.setSelected(getBoolean(\"editor.input_method_support\")); //$NON-NLS-1$\n\n    // set all settings entry boxes to their actual status\n//    exportSeparateBox.\n//      setSelected(getBoolean(\"export.applet.separate_jar_files\"));\n    deletePreviousBox.\n      setSelected(getBoolean(\"export.delete_target_folder\")); //$NON-NLS-1$\n\n    //closingLastQuitsBox.\n    //  setSelected(getBoolean(\"sketchbook.closing_last_window_quits\"));\n    //sketchPromptBox.\n    //  setSelected(getBoolean(\"sketchbook.prompt\"));\n    //sketchCleanBox.\n    //  setSelected(getBoolean(\"sketchbook.auto_clean\"));\n\n    sketchbookLocationField.\n      setText(get(\"sketchbook.path\")); //$NON-NLS-1$\n//    externalEditorBox.\n//      setSelected(getBoolean(\"editor.external\"));\n    checkUpdatesBox.\n      setSelected(getBoolean(\"update.check\")); //$NON-NLS-1$\n\n    whinyBox.setSelected(getBoolean(\"header.hide.image\") || //$NON-NLS-1$\n                         getBoolean(\"buttons.hide.image\")); //$NON-NLS-1$\n\n    updateDisplayList();\n    int displayNum = getInteger(\"run.display\"); //$NON-NLS-1$\n//    System.out.println(\"display is \" + displayNum + \", d count is \" + displayCount);\n    if (displayNum >= 0 && displayNum < displayCount) {\n//      System.out.println(\"setting num to \" + displayNum);\n      displaySelectionBox.setSelectedIndex(displayNum);\n    }\n    \n    // This takes a while to load, so run it from a separate thread\n    new Thread(new Runnable() {\n      public void run() {\n        initFontList();\n      }\n    }).start();\n    \n    fontSizeField.setSelectedItem(getInteger(\"editor.font.size\"));\n    consoleSizeField.setSelectedItem(getInteger(\"console.font.size\"));\n\n    presentColor.setBackground(Preferences.getColor(\"run.present.bgcolor\"));\n    presentColorHex\n        .setText(Preferences.get(\"run.present.bgcolor\").substring(1));\n\n    /*\n    if (Base.isMacOS()) {\n      String bits = Preferences.get(\"run.options.bits\"); //$NON-NLS-1$\n      if (bits.equals(\"32\")) { //$NON-NLS-1$\n        bitsThirtyTwoButton.setSelected(true);\n      } else if (bits.equals(\"64\")) { //$NON-NLS-1$\n        bitsSixtyFourButton.setSelected(true);\n      }\n      // in case we go back and support OS X 10.5...\n      if (System.getProperty(\"os.version\").startsWith(\"10.5\")) { //$NON-NLS-1$ //$NON-NLS-2$\n        bitsSixtyFourButton.setSelected(true);\n        bitsThirtyTwoButton.setEnabled(false);\n      }\n    }\n    */\n\n    if (autoAssociateBox != null) {\n      autoAssociateBox.\n        setSelected(getBoolean(\"platform.auto_file_type_associations\")); //$NON-NLS-1$\n    }\n\n    dialog.setVisible(true);\n  }","id":83619,"modified_method":"protected void showFrame() {\n    editorAntialiasBox.setSelected(getBoolean(\"editor.smooth\")); //$NON-NLS-1$\n    inputMethodBox.setSelected(getBoolean(\"editor.input_method_support\")); //$NON-NLS-1$\n\n    // set all settings entry boxes to their actual status\n//    exportSeparateBox.\n//      setSelected(getBoolean(\"export.applet.separate_jar_files\"));\n    deletePreviousBox.\n      setSelected(getBoolean(\"export.delete_target_folder\")); //$NON-NLS-1$\n\n    //closingLastQuitsBox.\n    //  setSelected(getBoolean(\"sketchbook.closing_last_window_quits\"));\n    //sketchPromptBox.\n    //  setSelected(getBoolean(\"sketchbook.prompt\"));\n    //sketchCleanBox.\n    //  setSelected(getBoolean(\"sketchbook.auto_clean\"));\n\n    sketchbookLocationField.\n      setText(get(\"sketchbook.path\")); //$NON-NLS-1$\n//    externalEditorBox.\n//      setSelected(getBoolean(\"editor.external\"));\n    checkUpdatesBox.\n      setSelected(getBoolean(\"update.check\")); //$NON-NLS-1$\n\n    whinyBox.setSelected(getBoolean(\"header.hide.image\") || //$NON-NLS-1$\n                         getBoolean(\"buttons.hide.image\")); //$NON-NLS-1$\n\n    updateDisplayList();\n    int displayNum = getInteger(\"run.display\"); //$NON-NLS-1$\n//    System.out.println(\"display is \" + displayNum + \", d count is \" + displayCount);\n    if (displayNum >= 0 && displayNum < displayCount) {\n//      System.out.println(\"setting num to \" + displayNum);\n      displaySelectionBox.setSelectedIndex(displayNum);\n    }\n    \n    // This takes a while to load, so run it from a separate thread\n    new Thread(new Runnable() {\n      public void run() {\n        initFontList();\n      }\n    }).start();\n    \n    fontSizeField.setSelectedItem(getInteger(\"editor.font.size\"));\n    consoleSizeField.setSelectedItem(getInteger(\"console.font.size\"));\n\n    presentColor.setBackground(Preferences.getColor(\"run.present.bgcolor\"));\n    presentColorHex.setText(Preferences.get(\"run.present.bgcolor\").substring(1));\n    \n    memoryOverrideBox.\n      setSelected(getBoolean(\"run.options.memory\")); //$NON-NLS-1$\n    memoryField.\n      setText(get(\"run.options.memory.maximum\")); //$NON-NLS-1$\n\n    /*\n    if (Base.isMacOS()) {\n      String bits = Preferences.get(\"run.options.bits\"); //$NON-NLS-1$\n      if (bits.equals(\"32\")) { //$NON-NLS-1$\n        bitsThirtyTwoButton.setSelected(true);\n      } else if (bits.equals(\"64\")) { //$NON-NLS-1$\n        bitsSixtyFourButton.setSelected(true);\n      }\n      // in case we go back and support OS X 10.5...\n      if (System.getProperty(\"os.version\").startsWith(\"10.5\")) { //$NON-NLS-1$ //$NON-NLS-2$\n        bitsSixtyFourButton.setSelected(true);\n        bitsThirtyTwoButton.setEnabled(false);\n      }\n    }\n    */\n\n    if (autoAssociateBox != null) {\n      autoAssociateBox.\n        setSelected(getBoolean(\"platform.auto_file_type_associations\")); //$NON-NLS-1$\n    }\n\n    dialog.setVisible(true);\n  }","commit_id":"4601397e64c20d60cb7d3864f24b583f46196b76","url":"https://github.com/processing/processing"},{"original_method":"@Override\n    public void paint(Graphics g) {\n      GraphicsUtil.setupAntialiasing(g);\n      GraphicsUtil.setupAAPainting(g);\n      final Dimension size = getSize();\n      final boolean isEmpty = getIcon() == null && StringUtil.isEmpty(getText());\n\n      if (myForceTransparent) {\n        final Icon icon = getIcon();\n        int x = 7;\n        if (icon != null) {\n          icon.paintIcon(this, g, x, (size.height - icon.getIconHeight()) / 2);\n          x += icon.getIconWidth() + 3;\n        }\n        if (!StringUtil.isEmpty(getText())) {\n          final Font font = getFont();\n          g.setFont(font);\n          g.setColor(UIManager.getColor(\"Panel.foreground\"));\n          g.drawString(getText(), x, (size.height + font.getSize()) / 2 - 1);\n        }\n      } else {\n\n      if (isSmallVariant()) {\n        final Graphics2D g2 = (Graphics2D)g;\n        g2.setColor(UIUtil.getControlColor());\n        final int w = getWidth();\n        final int h = getHeight();\n        if (getModel().isArmed() && getModel().isPressed()) {\n          g2.setPaint(UIUtil.getGradientPaint(0, 0, UIUtil.getControlColor(), 0, h, ColorUtil.shift(UIUtil.getControlColor(), 0.8)));\n        }\n        else {\n          if (UIUtil.isUnderDarcula()) {\n            g2.setPaint(UIUtil.getGradientPaint(0, 0, ColorUtil.shift(UIUtil.getControlColor(), 1.1), 0, h, ColorUtil.shift(UIUtil.getControlColor(), 0.9)));\n          } else {\n            g2.setPaint(UIUtil.getGradientPaint(0, 0, new JBColor(SystemInfo.isMac? Gray._226 : Gray._245, Gray._131), 0, h, new JBColor(SystemInfo.isMac? Gray._198 : Gray._208, Gray._128)));\n          }\n        }\n        g2.fillRoundRect(2, 0, w - 2, h, 5, 5);\n\n        Color borderColor = myMouseInside ? new JBColor(Gray._111, Gray._118) : new JBColor(Gray._151, Gray._95);\n        g2.setPaint(borderColor);\n        g2.drawRoundRect(2, 0, w - 3, h - 1, 5, 5);\n\n        final Icon icon = getIcon();\n        int x = 7;\n        if (icon != null) {\n          icon.paintIcon(this, g, x, (size.height - icon.getIconHeight()) / 2);\n          x += icon.getIconWidth() + 3;\n        }\n        if (!StringUtil.isEmpty(getText())) {\n          final Font font = getFont();\n          g2.setFont(font);\n          g2.setColor(UIManager.getColor(\"Panel.foreground\"));\n          g2.drawString(getText(), x, (size.height + font.getSize()) / 2 - 1);\n        }\n      }\n      else {\n        paintComponent(g);\n      }\n    }\n      final Insets insets = super.getInsets();\n      final Icon icon = isEnabled() ? ARROW_ICON : DISABLED_ARROW_ICON;\n      final int x;\n      if (isEmpty) {\n        x = (size.width - icon.getIconWidth()) / 2;\n      }\n      else {\n        if (isSmallVariant()) {\n          x = size.width - icon.getIconWidth() - insets.right + 1;\n        }\n        else {\n          x = size.width - icon.getIconWidth() - insets.right + (UIUtil.isUnderNimbusLookAndFeel() ? -3 : 2);\n        }\n      }\n\n      icon.paintIcon(null, g, x, (size.height - icon.getIconHeight()) / 2);\n      g.setPaintMode();\n    }","id":83620,"modified_method":"@Override\n    public void paint(Graphics g) {\n      GraphicsUtil.setupAntialiasing(g);\n      GraphicsUtil.setupAAPainting(g);\n      final Dimension size = getSize();\n      final boolean isEmpty = getIcon() == null && StringUtil.isEmpty(getText());\n\n      final Color textColor = (myForceEnabled == null ? myPresentation.isEnabled() : myForceEnabled)\n                      ? UIManager.getColor(\"Panel.foreground\")\n                      : UIUtil.getInactiveTextColor();\n      if (myForceTransparent) {\n        final Icon icon = getIcon();\n        int x = 7;\n        if (icon != null) {\n          icon.paintIcon(this, g, x, (size.height - icon.getIconHeight()) / 2);\n          x += icon.getIconWidth() + 3;\n        }\n        if (!StringUtil.isEmpty(getText())) {\n          final Font font = getFont();\n          g.setFont(font);\n          g.setColor(textColor);\n          g.drawString(getText(), x, (size.height + font.getSize()) / 2 - 1);\n        }\n      } else {\n\n      if (isSmallVariant()) {\n        final Graphics2D g2 = (Graphics2D)g;\n        g2.setColor(UIUtil.getControlColor());\n        final int w = getWidth();\n        final int h = getHeight();\n        if (getModel().isArmed() && getModel().isPressed()) {\n          g2.setPaint(UIUtil.getGradientPaint(0, 0, UIUtil.getControlColor(), 0, h, ColorUtil.shift(UIUtil.getControlColor(), 0.8)));\n        }\n        else {\n          if (UIUtil.isUnderDarcula()) {\n            g2.setPaint(UIUtil.getGradientPaint(0, 0, ColorUtil.shift(UIUtil.getControlColor(), 1.1), 0, h, ColorUtil.shift(UIUtil.getControlColor(), 0.9)));\n          } else {\n            g2.setPaint(UIUtil.getGradientPaint(0, 0, new JBColor(SystemInfo.isMac? Gray._226 : Gray._245, Gray._131), 0, h, new JBColor(SystemInfo.isMac? Gray._198 : Gray._208, Gray._128)));\n          }\n        }\n        g2.fillRoundRect(2, 0, w - 2, h, 5, 5);\n\n        Color borderColor = myMouseInside ? new JBColor(Gray._111, Gray._118) : new JBColor(Gray._151, Gray._95);\n        g2.setPaint(borderColor);\n        g2.drawRoundRect(2, 0, w - 3, h - 1, 5, 5);\n\n        final Icon icon = getIcon();\n        int x = 7;\n        if (icon != null) {\n          icon.paintIcon(this, g, x, (size.height - icon.getIconHeight()) / 2);\n          x += icon.getIconWidth() + 3;\n        }\n        if (!StringUtil.isEmpty(getText())) {\n          final Font font = getFont();\n          g2.setFont(font);\n          g2.setColor(textColor);\n          g2.drawString(getText(), x, (size.height + font.getSize()) / 2 - 1);\n        }\n      }\n      else {\n        paintComponent(g);\n      }\n    }\n      final Insets insets = super.getInsets();\n      final Icon icon = isEnabled() ? ARROW_ICON : DISABLED_ARROW_ICON;\n      final int x;\n      if (isEmpty) {\n        x = (size.width - icon.getIconWidth()) / 2;\n      }\n      else {\n        if (isSmallVariant()) {\n          x = size.width - icon.getIconWidth() - insets.right + 1;\n        }\n        else {\n          x = size.width - icon.getIconWidth() - insets.right + (UIUtil.isUnderNimbusLookAndFeel() ? -3 : 2);\n        }\n      }\n\n      icon.paintIcon(null, g, x, (size.height - icon.getIconHeight()) / 2);\n      g.setPaintMode();\n    }","commit_id":"c9b3e65dee012615089f7f372a07870277ec3c22","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateOptionsAndDescriptionPanel(TreePath path) {\n    if (path == null) return;\n    final InspectionConfigTreeNode node = (InspectionConfigTreeNode)path.getLastPathComponent();\n    final Descriptor descriptor = node.getDescriptor();\n    if (descriptor != null) {\n      final String description = descriptor.loadDescription();\n\n      if (description != null) {\n        // need this in order to correctly load plugin-supplied descriptions\n        try {\n          final HintHint hintHint = new HintHint(myBrowser, new Point(0, 0));\n          hintHint.setFont(myBrowser.getFont());\n          myBrowser.read(new StringReader(SearchUtil.markup(HintUtil.prepareHintText(description, hintHint), myProfileFilter.getFilter())), null);\n        }\n        catch (IOException e2) {\n          try {\n            //noinspection HardCodedStringLiteral\n            myBrowser.read(new StringReader(XmlStringUtil.wrapInHtml(\"<b>\" + UNDER_CONSTRUCTION + \"<\/b>\")), null);\n          }\n          catch (IOException e1) {\n            //Can't be\n          }\n        }\n        catch (Throwable t) {\n          LOG.error(\"Failed to load description for: \" + descriptor.getToolWrapper().getTool().getClass() + \"; description: \" + description, t);\n        }\n\n      }\n      else {\n        try {\n          myBrowser.read(new StringReader(EMPTY_HTML), null);\n        }\n        catch (IOException e1) {\n          //Can't be\n        }\n      }\n\n      myOptionsPanel.removeAll();\n\n      final NamedScope scope = node.getScope(myProjectProfileManager.getProject());\n      if (scope != null || node.isInspectionNode()) {\n        final HighlightDisplayKey key = descriptor.getKey();\n        final LevelChooser chooser = new LevelChooser(((SeverityProvider)mySelectedProfile.getProfileManager()).getOwnSeverityRegistrar()) {\n          @Override\n          public Dimension getPreferredSize() {\n            Dimension preferredSize = super.getPreferredSize();\n            return new Dimension(Math.min(300, preferredSize.width), preferredSize.height);\n          }\n\n          @Override\n          public Dimension getMinimumSize() {\n            return getPreferredSize();\n          }\n        };\n        chooser.getComboBox().addActionListener(new ActionListener() {\n          @Override\n          public void actionPerformed(ActionEvent e) {\n            Project project = myProjectProfileManager.getProject();\n            boolean toUpdate = mySelectedProfile.getErrorLevel(key, scope, project) != chooser.getLevel();\n            mySelectedProfile.setErrorLevel(key, chooser.getLevel(), node.isInspectionNode() || node.isByDefault() ? -1 : node.getParent().getIndex(node),\n                                            project);\n            if (toUpdate) node.dropCache();\n          }\n        });\n        chooser.setLevel(mySelectedProfile.getErrorLevel(key, scope, myProjectProfileManager.getProject()));\n\n        final JPanel withSeverity = new JPanel(new GridBagLayout());\n        withSeverity.add(new JLabel(InspectionsBundle.message(\"inspection.severity\")),\n                         new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.WEST,\n                                                GridBagConstraints.NONE, new Insets(0, 0, 10, 10), 0, 0));\n        withSeverity.add(chooser, new GridBagConstraints(1, 0, 1, 1, 1.0, 0, GridBagConstraints.WEST,\n                                                         GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));\n\n        final JComponent comp = descriptor.getState().getAdditionalConfigPanel();\n        withSeverity.add(comp,\n                         new GridBagConstraints(0, 1, 2, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST,\n                                                GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\n\n        myOptionsPanel.add(withSeverity, BorderLayout.CENTER);\n      }\n      myOptionsPanel.revalidate();\n      GuiUtils.enableChildren(myOptionsPanel, node.isChecked());\n    }\n    else {\n      initOptionsAndDescriptionPanel();\n    }\n    myOptionsPanel.repaint();\n  }","id":83621,"modified_method":"private void updateOptionsAndDescriptionPanel(TreePath path) {\n    if (path == null) return;\n    final InspectionConfigTreeNode node = (InspectionConfigTreeNode)path.getLastPathComponent();\n    final Descriptor descriptor = node.getDescriptor();\n    if (descriptor != null) {\n      final String description = descriptor.loadDescription();\n\n      if (description != null) {\n        // need this in order to correctly load plugin-supplied descriptions\n        try {\n          final HintHint hintHint = new HintHint(myBrowser, new Point(0, 0));\n          hintHint.setFont(myBrowser.getFont());\n          myBrowser.read(new StringReader(SearchUtil.markup(HintUtil.prepareHintText(description, hintHint), myProfileFilter.getFilter())), null);\n        }\n        catch (IOException e2) {\n          try {\n            //noinspection HardCodedStringLiteral\n            myBrowser.read(new StringReader(XmlStringUtil.wrapInHtml(\"<b>\" + UNDER_CONSTRUCTION + \"<\/b>\")), null);\n          }\n          catch (IOException e1) {\n            //Can't be\n          }\n        }\n        catch (Throwable t) {\n          LOG.error(\"Failed to load description for: \" + descriptor.getToolWrapper().getTool().getClass() + \"; description: \" + description, t);\n        }\n\n      }\n      else {\n        try {\n          myBrowser.read(new StringReader(EMPTY_HTML), null);\n        }\n        catch (IOException e1) {\n          //Can't be\n        }\n      }\n\n      myOptionsPanel.removeAll();\n\n      final NamedScope scope = node.getScope(myProjectProfileManager.getProject());\n      if (scope != null || node.isInspectionNode()) {\n        final HighlightDisplayKey key = descriptor.getKey();\n        final LevelChooserAction chooser =\n          new LevelChooserAction(((SeverityProvider)mySelectedProfile.getProfileManager()).getOwnSeverityRegistrar()) {\n            @Override\n            protected void onChosen(final HighlightSeverity severity) {\n              final HighlightDisplayLevel level = HighlightDisplayLevel.find(severity);\n              final Project project = myProjectProfileManager.getProject();\n              final boolean toUpdate = mySelectedProfile.getErrorLevel(key, scope, project) != level;\n              mySelectedProfile.setErrorLevel(key, level,\n                                              node.isInspectionNode() || node.isByDefault() ? -1 : node.getParent().getIndex(node),\n                                              project);\n              if (toUpdate) node.dropCache();\n            }\n          };\n        chooser.setChosen(mySelectedProfile.getErrorLevel(key, scope, myProjectProfileManager.getProject()).getSeverity());\n\n        final JPanel withSeverity = new JPanel(new GridBagLayout());\n        withSeverity.add(new JLabel(InspectionsBundle.message(\"inspection.severity\")),\n                         new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.WEST,\n                                                GridBagConstraints.NONE, new Insets(0, 0, 10, 10), 0, 0));\n        withSeverity.add(chooser.createCustomComponent(chooser.getTemplatePresentation()), new GridBagConstraints(1, 0, 1, 1, 1.0, 0, GridBagConstraints.WEST,\n                                                         GridBagConstraints.NONE, new Insets(0, 0, 10, 0), 0, 0));\n\n        final JComponent comp = descriptor.getState().getAdditionalConfigPanel();\n        withSeverity.add(comp,\n                         new GridBagConstraints(0, 1, 2, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST,\n                                                GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\n\n        myOptionsPanel.add(withSeverity, BorderLayout.CENTER);\n      }\n      myOptionsPanel.revalidate();\n      GuiUtils.enableChildren(myOptionsPanel, node.isChecked());\n    }\n    else {\n      initOptionsAndDescriptionPanel();\n    }\n    myOptionsPanel.repaint();\n  }","commit_id":"c9b3e65dee012615089f7f372a07870277ec3c22","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * generates the section of the report listing all the files revisions\n     *\n     * @param files list of files to generate the reports from\n     */\n    private void doChangedFiles( List files, Sink sink )\n    {\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            ChangeFile file = (ChangeFile) i.next();\n            sinkLogFile( sink, file.getName(), file.getRevision() );\n        }\n    }","id":83622,"modified_method":"/**\n     * generates the section of the report listing all the files revisions\n     *\n     * @param files list of files to generate the reports from\n     * @param sink  the report formatting tool\n     */\n    private void doChangedFiles( List files, Sink sink )\n    {\n        for ( Iterator i = files.iterator(); i.hasNext(); )\n        {\n            ChangeFile file = (ChangeFile) i.next();\n            sinkLogFile( sink, file.getName(), file.getRevision() );\n        }\n    }","commit_id":"268d41776eaee30218daa879910a1a809085d213","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * reports on the details of an SCM entry log\n     *\n     * @param entry  an SCM entry to generate the report from\n     * @param bundle the resource bundle to retrieve report phrases from\n     * @param sink   the report formatting tool\n     */\n    private void doChangedSetDetail( ChangeSet entry, ResourceBundle bundle, Sink sink )\n    {\n        sink.tableRow();\n\n        sink.tableCell();\n        sink.text( entry.getDateFormatted() + \" \" + entry.getTimeFormatted() );\n        sink.tableCell_();\n\n        sink.tableCell();\n        sink.text( entry.getAuthor() );\n        sink.tableCell_();\n\n        sink.tableCell();\n        //doRevision( entry.getFiles(), bundle, sink );\n        doChangedFiles( entry.getFiles(), sink );\n        sink.lineBreak();\n        sink.text( entry.getComment() );\n        sink.tableCell_();\n\n        sink.tableRow_();\n    }","id":83623,"modified_method":"/**\n     * reports on the details of an SCM entry log\n     *\n     * @param entry  an SCM entry to generate the report from\n     * @param bundle the resource bundle to retrieve report phrases from\n     * @param sink   the report formatting tool\n     */\n    private void doChangedSetDetail( ChangeSet entry, ResourceBundle bundle, Sink sink )\n    {\n        sink.tableRow();\n\n        sink.tableCell();\n        sink.text( entry.getDateFormatted() + \" \" + entry.getTimeFormatted() );\n        sink.tableCell_();\n\n        sink.tableCell();\n        sink.text( entry.getAuthor() );\n        sink.tableCell_();\n\n        sink.tableCell();\n        //doRevision( entry.getFiles(), bundle, sink );\n        doChangedFiles( entry.getFiles(), sink );\n        sink.lineBreak();\n        StringReader sr = new StringReader( entry.getComment() );\n        BufferedReader br = new BufferedReader( sr );\n        String line;\n        try\n        {\n            line = br.readLine();\n            while ( line != null )\n            {\n                sink.text( line );\n                line = br.readLine();\n                if ( line != null )\n                {\n                    sink.lineBreak();\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            getLog().warn( \"Unable to read the comment of a ChangeSet as a stream.\" );\n        }\n        finally\n        {\n            if ( br != null )\n            {\n                try\n                {\n                    br.close();\n                }\n                catch ( IOException e )\n                {\n                    getLog().warn( \"Unable to close a reader.\" );\n                }\n            }\n            if ( sr != null )\n            {\n                sr.close();\n            }\n        }\n        sink.tableCell_();\n\n        sink.tableRow_();\n    }","commit_id":"268d41776eaee30218daa879910a1a809085d213","url":"https://github.com/apache/maven-plugins"},{"original_method":"private static boolean changeListMatches(final CommittedChangeList changeList, final String[] filterWords) {\n    for(String word: filterWords) {\n      if (changeList.getComment().toLowerCase().indexOf(word) >= 0 ||\n          changeList.getCommitterName().toLowerCase().indexOf(word) >= 0 ||\n          Long.toString(changeList.getNumber()).indexOf(word) >= 0) {\n        return true;\n      }\n    }\n    return false;\n  }","id":83624,"modified_method":"private static boolean changeListMatches(@NotNull final CommittedChangeList changeList, final String[] filterWords) {\n    for(String word: filterWords) {\n      final String comment = changeList.getComment();\n      final String committer = changeList.getCommitterName();\n      if ((comment != null && comment.toLowerCase().indexOf(word) >= 0) ||\n          (committer != null && committer.toLowerCase().indexOf(word) >= 0) ||\n          Long.toString(changeList.getNumber()).indexOf(word) >= 0) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"e6163272b497f6e669b927bd8cb28909976a4888","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void logRequirements( String message, Requirement[] req )\n    {\n        logger.log( LogService.LOG_ERROR, message );\n        for ( int i = 0; req != null && i < req.length; i++ )\n        {\n            logger.log( LogService.LOG_ERROR, \"  \" + i + \": \" + req[i].getName() + \" (\" + req[i].getComment() + \")\" );\n        }\n    }","id":83625,"modified_method":"private void logRequirements( String message, Requirement[] req )\n    {\n        logger.log( LogService.LOG_ERROR, message );\n        for ( int i = 0; req != null && i < req.length; i++ )\n        {\n            String moreInfo = req[i].getComment();\n            if ( moreInfo == null )\n            {\n                moreInfo = req[i].getFilter().toString();\n            }\n            logger.log( LogService.LOG_ERROR, \"  \" + i + \": \" + req[i].getName() + \" (\" + moreInfo + \")\" );\n        }\n    }","commit_id":"aeb5f3b090b9f8c10f29d61068c37dc914c37fe5","url":"https://github.com/apache/felix"},{"original_method":"public void addCookie(Cookie cookie)\n    {\n        _connection.getResponseFields().addSetCookie(cookie.getName(),\n                cookie.getValue(),\n                cookie.getDomain(),\n                cookie.getPath(),\n                cookie.getMaxAge(),\n                cookie.getComment(),\n                cookie.getSecure(),\n                false,//cookie.isHttpOnly(),\n                cookie.getVersion());\n    }","id":83626,"modified_method":"public void addCookie(Cookie cookie)\n    {\n        String comment=cookie.getComment();\n        boolean http_only=false;\n        \n        if (comment!=null)\n        {\n            int i=comment.indexOf(HTTP_ONLY_COMMENT);\n            if (i>=0)\n            {\n                http_only=true;\n                comment=comment.substring(i,i+HTTP_ONLY_COMMENT.length()).trim();\n                if (comment.length()==0)\n                    comment=null;\n            }\n        }\n        _connection.getResponseFields().addSetCookie(cookie.getName(),\n                cookie.getValue(),\n                cookie.getDomain(),\n                cookie.getPath(),\n                cookie.getMaxAge(),\n                comment,\n                cookie.getSecure(),\n                http_only,// || cookie.isHttpOnly(),\n                cookie.getVersion());\n    }","commit_id":"1907944aef88b4b95a6e39486fd731a49420c266","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void prepopulateLists() {\n        if (!theLists.isEmpty()) {\n            return;\n        }\n        //phone number\n        List<Keyword> phones = new ArrayList<>();\n        phones.add(new Keyword(\"[(]{0,1}\\\\d\\\\d\\\\d[)]{0,1}[\\\\.-]\\\\d\\\\d\\\\d[\\\\.-]\\\\d\\\\d\\\\d\\\\d\", false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER)); //NON-NLS\n        //phones.add(new Keyword(\"\\\\d{8,10}\", false));\n        //IP address\n        List<Keyword> ips = new ArrayList<>();\n        ips.add(new Keyword(\"(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\", false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_IP_ADDRESS));\n        //email\n        List<Keyword> emails = new ArrayList<>();\n        emails.add(new Keyword(\"(?=.{8})[a-z0-9%+_-]+(?:\\\\.[a-z0-9%+_-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\\\.)+[a-z]{2,4}(?<!\\\\.txt|\\\\.exe|\\\\.dll|\\\\.jpg|\\\\.xml)\", //NON-NLS\n                false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL));\n        //emails.add(new Keyword(\"[A-Z0-9._%-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,4}\", \n        //                       false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL));\n        //URL\n        List<Keyword> urls = new ArrayList<>();\n        //urls.add(new Keyword(\"http://|https://|^www\\\\.\", false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL));\n        urls.add(new Keyword(\"((((ht|f)tp(s?))\\\\://)|www\\\\.)[a-zA-Z0-9\\\\-\\\\.]+\\\\.([a-zA-Z]{2,5})(\\\\:[0-9]+)*(/($|[a-zA-Z0-9\\\\.\\\\,\\\\;\\\\?\\\\'\\\\\\\\+&amp;%\\\\$#\\\\=~_\\\\-]+))*\", false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL)); //NON-NLS\n\n        //urls.add(new Keyword(\"ssh://\", false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL));\n        //disable messages for harcoded/locked lists\n        String name;\n\n        name = \"Phone Numbers\"; //NON-NLS\n        lockedLists.add(name);\n        addList(name, phones, false, false, true);\n\n        name = \"IP Addresses\"; //NON-NLS\n        lockedLists.add(name);\n        addList(name, ips, false, false, true);\n\n        name = \"Email Addresses\"; //NON-NLS\n        lockedLists.add(name);\n        addList(name, emails, true, false, true);\n\n        name = \"URLs\"; //NON-NLS\n        lockedLists.add(name);\n        addList(name, urls, false, false, true);\n    }","id":83627,"modified_method":"private void prepopulateLists() {\n        if (!theLists.isEmpty()) {\n            return;\n        }\n        //phone number\n        List<Keyword> phones = new ArrayList<>();\n        phones.add(new Keyword(PHONE_NUMBER_REGEX, false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_PHONE_NUMBER));\n        lockedLists.add(\"Phone Numbers\"); //NON-NLS\n        addList(\"Phone Numbers\", phones, false, false, true); //NON-NLS\n\n        //IP address\n        List<Keyword> ips = new ArrayList<>();\n        ips.add(new Keyword(IP_ADDRESS_REGEX, false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_IP_ADDRESS));\n        lockedLists.add(\"IP Addresses\"); //NON-NLS\n        addList(\"IP Addresses\", ips, false, false, true); //NON-NLS\n\n        //email\n        List<Keyword> emails = new ArrayList<>();\n        emails.add(new Keyword(EMAIL_ADDRESS_REGEX, false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_EMAIL));\n        lockedLists.add(\"Email Addresses\"); //NON-NLS\n        addList(\"Email Addresses\", emails, true, false, true); //NON-NLS\n\n        //URL\n        List<Keyword> urls = new ArrayList<>();\n        urls.add(new Keyword(URL_REGEX, false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_URL));\n        lockedLists.add(\"URLs\"); //NON-NLS\n        addList(\"URLs\", urls, false, false, true); //NON-NLS\n\n        //CCN\n        List<Keyword> ccns = new ArrayList<>();\n        ccns.add(new Keyword(CCN_REGEX, false, BlackboardAttribute.ATTRIBUTE_TYPE.TSK_CREDIT_CARD_NUMBER));\n        lockedLists.add(\"Credit Card Numbers\"); //NON-NLS\n        addList(\"Credit Card Numbers\", ccns, true, false, true); //NON-NLS\n    }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void init() {\n        // make a query for each keyword\n        queryDelegates = new ArrayList<>();\n\n        for (KeywordList keywordList : keywordLists) {\n            for (Keyword keyword : keywordList.getKeywords()) {\n                KeywordSearchQuery query;\n                if (keyword.isLiteral()) {\n                    // literal, exact match\n                    if (keyword.isWholeword()) {\n                        query = new LuceneQuery(keywordList, keyword);\n                        query.escape();\n                    } // literal, substring match\n                    else {\n                        query = new TermComponentQuery(keywordList, keyword);\n                        query.escape();\n                        query.setSubstringQuery();\n                    }\n                } // regexp\n                else {\n                    query = new TermComponentQuery(keywordList, keyword);\n                }\n                queryDelegates.add(query);\n            }\n        }\n    }","id":83628,"modified_method":"private void init() {\n        // make a query for each keyword\n        queryDelegates = new ArrayList<>();\n\n        for (KeywordList keywordList : keywordLists) {\n            for (Keyword keyword : keywordList.getKeywords()) {\n                KeywordSearchQuery query;\n                if (keyword.isLiteral()) {\n                    // literal, exact match\n                    if (keyword.isWholeword()) {\n                        query = new LuceneQuery(keywordList, keyword);\n                        query.escape();\n                    } // literal, substring match\n                    else {\n                        query = new TermComponentQuery(keywordList, keyword);\n                        query.escape();\n                        query.setSubstringQuery();\n                    }\n                } // regexp\n                else {\n                    query = new TermComponentQuery(keywordList, keyword);\n                    query.setSubstringQuery();\n                }\n                queryDelegates.add(query);\n            }\n        }\n    }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        protected Object doInBackground() throws Exception {\n            final String displayName = NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.doInBackGround.displayName\")\n                    + (finalRun ? (\" - \" + NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.doInBackGround.finalizeMsg\")) : \"\");\n            final String pgDisplayName = displayName + (\" (\" + NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.doInBackGround.pendingMsg\") + \")\");\n            progressGroup = AggregateProgressFactory.createSystemHandle(pgDisplayName, null, new Cancellable() {\n                @Override\n                public boolean cancel() {\n                    logger.log(Level.INFO, \"Cancelling the searcher by user.\"); //NON-NLS\n                    if (progressGroup != null) {\n                        progressGroup.setDisplayName(displayName + \" \" + NbBundle.getMessage(this.getClass(), \"SearchRunner.doInBackGround.cancelMsg\"));\n                    }\n                    return SearchRunner.Searcher.this.cancel(true);\n                }\n            }, null);\n\n            updateKeywords();\n\n            ProgressContributor[] subProgresses = new ProgressContributor[keywords.size()];\n            int i = 0;\n            for (Keyword keywordQuery : keywords) {\n                subProgresses[i] = AggregateProgressFactory.createProgressContributor(keywordQuery.getQuery());\n                progressGroup.addContributor(subProgresses[i]);\n                i++;\n            }\n\n            progressGroup.start();\n\n            final StopWatch stopWatch = new StopWatch();\n            stopWatch.start();\n            try {\n                progressGroup.setDisplayName(displayName);\n\n                int keywordsSearched = 0;\n\n                for (Keyword keywordQuery : keywords) {\n                    if (this.isCancelled()) {\n                        logger.log(Level.INFO, \"Cancel detected, bailing before new keyword processed: {0}\", keywordQuery.getQuery()); //NON-NLS\n                        return null;\n                    }\n\n                    final String queryStr = keywordQuery.getQuery();\n                    final KeywordList list = keywordToList.get(queryStr);\n\n                    //new subProgress will be active after the initial query\n                    //when we know number of hits to start() with\n                    if (keywordsSearched > 0) {\n                        subProgresses[keywordsSearched - 1].finish();\n                    }\n\n                    KeywordSearchQuery keywordSearchQuery = null;\n\n                    boolean isRegex = !keywordQuery.isLiteral();\n                    if (isRegex) {\n                        keywordSearchQuery = new TermComponentQuery(list, keywordQuery);\n                    } else {\n                        keywordSearchQuery = new LuceneQuery(list, keywordQuery);\n                        keywordSearchQuery.escape();\n                    }\n\n                    // Filtering\n                    //limit search to currently ingested data sources\n                    //set up a filter with 1 or more image ids OR'ed\n                    final KeywordQueryFilter dataSourceFilter = new KeywordQueryFilter(KeywordQueryFilter.FilterType.DATA_SOURCE, job.getDataSourceId());\n                    keywordSearchQuery.addFilter(dataSourceFilter);\n\n                    QueryResults queryResults;\n\n                    // Do the actual search\n                    try {\n                        queryResults = keywordSearchQuery.performQuery();\n                    } catch (NoOpenCoreException ex) {\n                        logger.log(Level.WARNING, \"Error performing query: \" + keywordQuery.getQuery(), ex); //NON-NLS\n                        //no reason to continue with next query if recovery failed\n                        //or wait for recovery to kick in and run again later\n                        //likely case has closed and threads are being interrupted\n                        return null;\n                    } catch (CancellationException e) {\n                        logger.log(Level.INFO, \"Cancel detected, bailing during keyword query: {0}\", keywordQuery.getQuery()); //NON-NLS\n                        return null;\n                    } catch (Exception e) {\n                        logger.log(Level.WARNING, \"Error performing query: \" + keywordQuery.getQuery(), e); //NON-NLS\n                        continue;\n                    }\n\n                    // calculate new results by substracting results already obtained in this ingest\n                    // this creates a map of each keyword to the list of unique files that have that hit. \n                    QueryResults newResults = filterResults(queryResults);\n\n                    if (!newResults.getKeywords().isEmpty()) {\n\n                        // Write results to BB\n                        //new artifacts created, to report to listeners\n                        Collection<BlackboardArtifact> newArtifacts = new ArrayList<>();\n\n                        //scale progress bar more more granular, per result sub-progress, within per keyword\n                        int totalUnits = newResults.getKeywords().size();\n                        subProgresses[keywordsSearched].start(totalUnits);\n                        int unitProgress = 0;\n                        String queryDisplayStr = keywordQuery.getQuery();\n                        if (queryDisplayStr.length() > 50) {\n                            queryDisplayStr = queryDisplayStr.substring(0, 49) + \"...\";\n                        }\n                        subProgresses[keywordsSearched].progress(list.getName() + \": \" + queryDisplayStr, unitProgress);\n\n                        // Create blackboard artifacts                \n                        newArtifacts = newResults.writeAllHitsToBlackBoard(null, subProgresses[keywordsSearched], this, list.getIngestMessages());\n\n                    } //if has results\n\n                    //reset the status text before it goes away\n                    subProgresses[keywordsSearched].progress(\"\");\n\n                    ++keywordsSearched;\n\n                } //for each keyword\n\n            } //end try block\n            catch (Exception ex) {\n                logger.log(Level.WARNING, \"searcher exception occurred\", ex); //NON-NLS\n            } finally {\n                try {\n                    finalizeSearcher();\n                    stopWatch.stop();\n\n                    logger.log(Level.INFO, \"Searcher took to run: {0} secs.\", stopWatch.getElapsedTimeSecs()); //NON-NLS\n                } finally {\n                    // In case a thread is waiting on this worker to be done\n                    job.searchNotify();\n                }\n            }\n\n            return null;\n        }","id":83629,"modified_method":"@Override\n        protected Object doInBackground() throws Exception {\n            final String displayName = NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.doInBackGround.displayName\")\n                    + (finalRun ? (\" - \" + NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.doInBackGround.finalizeMsg\")) : \"\");\n            final String pgDisplayName = displayName + (\" (\" + NbBundle.getMessage(this.getClass(), \"KeywordSearchIngestModule.doInBackGround.pendingMsg\") + \")\");\n            progressGroup = AggregateProgressFactory.createSystemHandle(pgDisplayName, null, new Cancellable() {\n                @Override\n                public boolean cancel() {\n                    logger.log(Level.INFO, \"Cancelling the searcher by user.\"); //NON-NLS\n                    if (progressGroup != null) {\n                        progressGroup.setDisplayName(displayName + \" \" + NbBundle.getMessage(this.getClass(), \"SearchRunner.doInBackGround.cancelMsg\"));\n                    }\n                    return SearchRunner.Searcher.this.cancel(true);\n                }\n            }, null);\n\n            updateKeywords();\n\n            ProgressContributor[] subProgresses = new ProgressContributor[keywords.size()];\n            int i = 0;\n            for (Keyword keywordQuery : keywords) {\n                subProgresses[i] = AggregateProgressFactory.createProgressContributor(keywordQuery.getQuery());\n                progressGroup.addContributor(subProgresses[i]);\n                i++;\n            }\n\n            progressGroup.start();\n\n            final StopWatch stopWatch = new StopWatch();\n            stopWatch.start();\n            try {\n                progressGroup.setDisplayName(displayName);\n\n                int keywordsSearched = 0;\n\n                for (Keyword keywordQuery : keywords) {\n                    if (this.isCancelled()) {\n                        logger.log(Level.INFO, \"Cancel detected, bailing before new keyword processed: {0}\", keywordQuery.getQuery()); //NON-NLS\n                        return null;\n                    }\n\n                    final String queryStr = keywordQuery.getQuery();\n                    final KeywordList list = keywordToList.get(queryStr);\n\n                    //new subProgress will be active after the initial query\n                    //when we know number of hits to start() with\n                    if (keywordsSearched > 0) {\n                        subProgresses[keywordsSearched - 1].finish();\n                    }\n\n                    KeywordSearchQuery keywordSearchQuery = null;\n\n                    boolean isRegex = !keywordQuery.isLiteral();\n                    if (isRegex) {\n                        keywordSearchQuery = new TermComponentQuery(list, keywordQuery);\n                        keywordSearchQuery.setSubstringQuery();\n                    } else {\n                        keywordSearchQuery = new LuceneQuery(list, keywordQuery);\n                        keywordSearchQuery.escape();\n                    }\n\n                    // Filtering\n                    //limit search to currently ingested data sources\n                    //set up a filter with 1 or more image ids OR'ed\n                    final KeywordQueryFilter dataSourceFilter = new KeywordQueryFilter(KeywordQueryFilter.FilterType.DATA_SOURCE, job.getDataSourceId());\n                    keywordSearchQuery.addFilter(dataSourceFilter);\n\n                    QueryResults queryResults;\n\n                    // Do the actual search\n                    try {\n                        queryResults = keywordSearchQuery.performQuery();\n                    } catch (NoOpenCoreException ex) {\n                        logger.log(Level.WARNING, \"Error performing query: \" + keywordQuery.getQuery(), ex); //NON-NLS\n                        //no reason to continue with next query if recovery failed\n                        //or wait for recovery to kick in and run again later\n                        //likely case has closed and threads are being interrupted\n                        return null;\n                    } catch (CancellationException e) {\n                        logger.log(Level.INFO, \"Cancel detected, bailing during keyword query: {0}\", keywordQuery.getQuery()); //NON-NLS\n                        return null;\n                    } catch (Exception e) {\n                        logger.log(Level.WARNING, \"Error performing query: \" + keywordQuery.getQuery(), e); //NON-NLS\n                        continue;\n                    }\n\n                    // calculate new results by substracting results already obtained in this ingest\n                    // this creates a map of each keyword to the list of unique files that have that hit. \n                    QueryResults newResults = filterResults(queryResults);\n\n                    if (!newResults.getKeywords().isEmpty()) {\n\n                        // Write results to BB\n                        //new artifacts created, to report to listeners\n                        Collection<BlackboardArtifact> newArtifacts = new ArrayList<>();\n\n                        //scale progress bar more more granular, per result sub-progress, within per keyword\n                        int totalUnits = newResults.getKeywords().size();\n                        subProgresses[keywordsSearched].start(totalUnits);\n                        int unitProgress = 0;\n                        String queryDisplayStr = keywordQuery.getQuery();\n                        if (queryDisplayStr.length() > 50) {\n                            queryDisplayStr = queryDisplayStr.substring(0, 49) + \"...\";\n                        }\n                        subProgresses[keywordsSearched].progress(list.getName() + \": \" + queryDisplayStr, unitProgress);\n\n                        // Create blackboard artifacts                \n                        newArtifacts = newResults.writeAllHitsToBlackBoard(null, subProgresses[keywordsSearched], this, list.getIngestMessages());\n\n                    } //if has results\n\n                    //reset the status text before it goes away\n                    subProgresses[keywordsSearched].progress(\"\");\n\n                    ++keywordsSearched;\n\n                } //for each keyword\n\n            } //end try block\n            catch (Exception ex) {\n                logger.log(Level.WARNING, \"searcher exception occurred\", ex); //NON-NLS\n            } finally {\n                try {\n                    finalizeSearcher();\n                    stopWatch.stop();\n\n                    logger.log(Level.INFO, \"Searcher took to run: {0} secs.\", stopWatch.getElapsedTimeSecs()); //NON-NLS\n                } finally {\n                    // In case a thread is waiting on this worker to be done\n                    job.searchNotify();\n                }\n            }\n\n            return null;\n        }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public KeywordCachedArtifact writeSingleFileHitsToBlackBoard(String termHit, KeywordHit hit, String snippet, String listName) {\n        final String MODULE_NAME = KeywordSearchModuleFactory.getModuleName();\n\n        //there is match actually in this file, create artifact only then\n        BlackboardArtifact bba;\n        KeywordCachedArtifact writeResult;\n        Collection<BlackboardAttribute> attributes = new ArrayList<>();\n        try {\n            bba = hit.getContent().newArtifact(ARTIFACT_TYPE.TSK_KEYWORD_HIT);\n            writeResult = new KeywordCachedArtifact(bba);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Error adding bb artifact for keyword hit\", e); //NON-NLS\n            return null;\n        }\n\n        //regex match\n        attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD, MODULE_NAME, termHit));\n\n        if ((listName != null) && (listName.equals(\"\") == false)) {\n            attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_SET_NAME, MODULE_NAME, listName));\n        }\n\n        //preview\n        if (snippet != null) {\n            attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD_PREVIEW, MODULE_NAME, snippet));\n        }\n        //regex keyword\n        attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD_REGEXP, MODULE_NAME, keyword.getQuery()));\n\n        if (hit.isArtifactHit()) {\n            attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT, MODULE_NAME, hit.getArtifact().getArtifactID()));\n        }\n\n        try {\n            bba.addAttributes(attributes);\n            writeResult.add(attributes);\n            return writeResult;\n        } catch (TskException e) {\n            logger.log(Level.WARNING, \"Error adding bb attributes for terms search artifact\", e); //NON-NLS\n        }\n\n        return null;\n    }","id":83630,"modified_method":"@Override\n    public KeywordCachedArtifact writeSingleFileHitsToBlackBoard(String termHit, KeywordHit hit, String snippet, String listName) {\n\n        try {\n            BlackboardArtifact bba;\n            Collection<BlackboardAttribute> attributes = new ArrayList<>();\n\n            bba = hit.getContent().newArtifact(ARTIFACT_TYPE.TSK_KEYWORD_HIT);\n\n            if (keyword.getType() == ATTRIBUTE_TYPE.TSK_CREDIT_CARD_NUMBER) {\n                Matcher matcher = TRACK1_PATTERN.matcher(hit.getSnippet());\n                if (matcher.find()) {\n                    parseTrackData(bba, matcher, hit, true);\n                }\n                matcher = TRACK2_PATTERN.matcher(hit.getSnippet());\n                if (matcher.find()) {\n                    parseTrackData(bba, matcher, hit,false);\n                }\n            } else {\n\n            }\n\n            //regex match\n            attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD, MODULE_NAME, termHit));\n\n            if (StringUtils.isNotEmpty(listName)) {\n                attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_SET_NAME, MODULE_NAME, listName));\n            }\n\n            //regex keyword\n            attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD_REGEXP, MODULE_NAME, keyword.getQuery()));\n            //preview\n            if (snippet != null) {\n                attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_KEYWORD_PREVIEW, MODULE_NAME, snippet));\n            }\n\n            if (hit.isArtifactHit()) {\n                attributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_ASSOCIATED_ARTIFACT, MODULE_NAME, hit.getArtifact().getArtifactID()));\n            }\n\n            try {\n                bba.addAttributes(attributes);\n                KeywordCachedArtifact writeResult = new KeywordCachedArtifact(bba);\n                writeResult.add(attributes);\n                return writeResult;\n            } catch (TskCoreException e) {\n                LOGGER.log(Level.WARNING, \"Error adding bb attributes for terms search artifact\", e); //NON-NLS\n            }\n        } catch (TskCoreException e) {\n            LOGGER.log(Level.WARNING, \"Error adding bb artifact for keyword hit\", e); //NON-NLS\n        }\n\n        return null;\n    }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void escape() {\n        queryEscaped = Pattern.quote(keyword.getQuery());\n        isEscaped = true;\n    }","id":83631,"modified_method":"@Override\n    public void escape() {\n        escapedQuery = Pattern.quote(keyword.getQuery());\n        isEscaped = true;\n    }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public boolean validate() {\n        if (queryEscaped.equals(\"\")) {\n            return false;\n        }\n\n        boolean valid = true;\n        try {\n            Pattern.compile(queryEscaped);\n        } catch (PatternSyntaxException ex1) {\n            valid = false;\n        } catch (IllegalArgumentException ex2) {\n            valid = false;\n        }\n        return valid;\n    }","id":83632,"modified_method":"@Override\n    public boolean validate() {\n        if (escapedQuery.isEmpty()) {\n            return false;\n        }\n\n        try {\n            Pattern.compile(escapedQuery);\n        } catch (IllegalArgumentException ex) {\n            return false;\n        }\n\n        return true;\n    }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public TermComponentQuery(KeywordList keywordList, Keyword keyword) {\n        this.field = null;\n        this.keyword = keyword;\n        this.keywordList = keywordList;\n        this.queryEscaped = keyword.getQuery();\n        isEscaped = false;\n        terms = null;\n    }","id":83633,"modified_method":"TermComponentQuery(KeywordList keywordList, Keyword keyword) {\n        this.keyword = keyword;\n        this.keywordList = keywordList;\n        this.escapedQuery = keyword.getQuery();\n        isEscaped = false;\n    }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void setField(String field) {\n        this.field = field;\n    }","id":83634,"modified_method":"@Override\n    @Deprecated\n    public void setField(String field) {\n    }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public QueryResults performQuery() throws NoOpenCoreException {\n        /*\n         * Execute the regex query to get a list of terms that match the regex.\n         * Note that the field that is being searched is tokenized based on\n         * whitespace.\n         */ \n        final SolrQuery q = createQuery();\n        q.setShowDebugInfo(DEBUG);\n        q.setTermsLimit(MAX_TERMS_RESULTS);\n        logger.log(Level.INFO, \"Query: {0}\", q.toString()); //NON-NLS\n        terms = executeQuery(q);\n\n        /*\n         * For each term that matched the regex, query for the term to get the\n         * full set of document hits.\n         */\n        QueryResults results = new QueryResults(this, keywordList);\n        int resultSize = 0;\n        for (Term term : terms) {\n            final String termStr = KeywordSearchUtil.escapeLuceneQuery(term.getTerm());\n\n            LuceneQuery filesQuery = new LuceneQuery(keywordList, new Keyword(termStr, true));\n\n            //filesQuery.setField(TERMS_SEARCH_FIELD);\n            for (KeywordQueryFilter filter : filters) {\n                //set filter\n                //note: we can't set filter query on terms query\n                //but setting filter query on terms results query will yield the same result\n                filesQuery.addFilter(filter);\n            }\n            try {\n                QueryResults subResults = filesQuery.performQuery();\n                Set<KeywordHit> filesResults = new HashSet<>();\n                for (Keyword key : subResults.getKeywords()) {\n                    List<KeywordHit> keyRes = subResults.getResults(key);\n                    resultSize += keyRes.size();\n                    filesResults.addAll(keyRes);\n                }\n                results.addResult(new Keyword(term.getTerm(), false), new ArrayList<>(filesResults));\n            } catch (NoOpenCoreException e) {\n                logger.log(Level.WARNING, \"Error executing Solr query,\", e); //NON-NLS\n                throw e;\n            } catch (RuntimeException e) {\n                logger.log(Level.WARNING, \"Error executing Solr query,\", e); //NON-NLS\n            }\n\n        }\n\n        //TODO limit how many results we store, not to hit memory limits\n        logger.log(Level.INFO, \"Regex # results: {0}\", resultSize); //NON-NLS\n\n        return results;\n    }","id":83635,"modified_method":"@Override\n    public QueryResults performQuery() throws NoOpenCoreException {\n\n        /*\n         * Execute the regex query to get a list of terms that match the regex.\n         * Note that the field that is being searched is tokenized based on\n         * whitespace.\n         */\n        final SolrQuery termsQuery = new SolrQuery();\n        termsQuery.setRequestHandler(TERMS_HANDLER);\n        termsQuery.setTerms(true);\n        termsQuery.setTermsRegexFlag(CASE_INSENSITIVE);\n        //q.setTermsRegexFlag(regexFlag);\n        //q.setTermsRaw(true);\n        termsQuery.setTermsRegex(escapedQuery);\n        termsQuery.addTermsField(TERMS_SEARCH_FIELD);\n        termsQuery.setTimeAllowed(TERMS_TIMEOUT);\n        termsQuery.setShowDebugInfo(DEBUG);\n        termsQuery.setTermsLimit(MAX_TERMS_RESULTS);\n        LOGGER.log(Level.INFO, \"Query: {0}\", termsQuery.toString()); //NON-NLS\n\n        List<Term> terms;\n        try {\n            Server solrServer = KeywordSearch.getServer();\n            terms = solrServer.queryTerms(termsQuery).getTerms(TERMS_SEARCH_FIELD);\n        } catch (KeywordSearchModuleException ex) {\n            LOGGER.log(Level.WARNING, \"Error executing the regex terms query: \" + keyword.getQuery(), ex); //NON-NLS\n            //TODO: this almost certainly wrong and guaranteed to throw a NPE at some point!!!!\n            return null;  //no need to create result view, just display error dialog\n        }\n        /*\n         * For each term that matched the regex, query for the term to get the\n         * full set of document hits.\n         */\n        QueryResults results = new QueryResults(this, keywordList);\n        int resultSize = 0;\n        for (Term term : terms) {\n            String escapedTermString = null;\n\n            if (keyword.getType() == ATTRIBUTE_TYPE.TSK_CREDIT_CARD_NUMBER) {\n                if (false == new LuhnCheckDigit().isValid(term.getTerm())) {\n//                        LOGGER.log(Level.INFO, term.getTerm() + \" did not pass luhn validation!\");\n//                        continue;\n//                    }\n//              \n                } else {\n\n                }\n            }\n            escapedTermString = KeywordSearchUtil.escapeLuceneQuery(term.getTerm());\n\n            /*\n             * Note: we can't set filter query on terms query but setting filter\n             * query on terms results query will yield the same result\n             */\n            LuceneQuery filesQuery = new LuceneQuery(keywordList, new Keyword(escapedTermString, true));\n            filters.forEach(filesQuery::addFilter);\n            \n            try {\n                QueryResults fileResults = filesQuery.performQuery();\n                Set<KeywordHit> filesResults = new HashSet<>();\n                for (Keyword key : fileResults.getKeywords()) {\n                    List<KeywordHit> keyRes = fileResults.getResults(key);\n                    resultSize += keyRes.size();\n                    filesResults.addAll(keyRes);\n                }\n                results.addResult(new Keyword(escapedTermString, false), new ArrayList<>(filesResults));\n            } catch (NoOpenCoreException | RuntimeException  e) {\n                LOGGER.log(Level.WARNING, \"Error executing Solr query,\", e); //NON-NLS\n                throw e;\n            }\n        }\n\n        //TODO limit how many results we store, not to hit memory limits\n        LOGGER.log(Level.INFO, \"Regex # results: {0}\", resultSize); //NON-NLS\n\n        return results;\n    }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void setSubstringQuery() {\n        queryEscaped = \".*\" + queryEscaped + \".*\";\n    }","id":83636,"modified_method":"@Override\n    public void setSubstringQuery() {\n        escapedQuery = \".*\" + escapedQuery + \".*\";\n    }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public String getEscapedQueryString() {\n        return this.queryEscaped;\n    }","id":83637,"modified_method":"@Override\n    public String getEscapedQueryString() {\n        return this.escapedQuery;\n    }","commit_id":"07f3053a02be0b3a9cbf771f149c582ef3c27c4f","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private SNode getImports(PsiImportStatementBase[] imports) {\n    SNode javaImports = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.JavaImports\", null);\n\n    for (PsiImportStatementBase imp : imports) {\n      SNode javaImport = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.JavaImport\", null);\n      SPropertyOperations.set(javaImport, \"onDemand\", \"\" + (imp.isOnDemand()));\n      SPropertyOperations.set(javaImport, \"static\", \"\" + (imp instanceof PsiImportStaticStatement));\n      String qName = imp.getImportReference().getQualifiedName();\n      SPropertyOperations.set(javaImport, \"tokens\", qName);\n\n      ListSequence.fromList(SLinkOperations.getTargets(javaImports, \"entries\", true)).addElement(javaImport);\n    }\n    return javaImports;\n  }","id":83638,"modified_method":"private SNode getImports(PsiImportStatementBase[] imports) {\n    SNode javaImports = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.JavaImports\", null);\n\n    for (PsiImportStatementBase imp : imports) {\n      PsiJavaCodeReferenceElement ref = imp.getImportReference();\n      if (ref == null) {\n        continue;\n      }\n\n      SNode javaImport = SConceptOperations.createNewNode(\"jetbrains.mps.baseLanguage.structure.JavaImport\", null);\n      SPropertyOperations.set(javaImport, \"onDemand\", \"\" + (imp.isOnDemand()));\n      SPropertyOperations.set(javaImport, \"static\", \"\" + (imp instanceof PsiImportStaticStatement));\n      String qName = ref.getQualifiedName();\n      SPropertyOperations.set(javaImport, \"tokens\", qName);\n\n      ListSequence.fromList(SLinkOperations.getTargets(javaImports, \"entries\", true)).addElement(javaImport);\n    }\n    return javaImports;\n  }","commit_id":"3b64989f63f89d1e5bd71ed6fa1b4e95713cc570","url":"https://github.com/JetBrains/MPS"},{"original_method":"@NotNull\n  private static Import importToImport(PsiImportStatementBase t) {\n    if (t != null && t.getImportReference() != null)\n      return new Import(t.getImportReference().getQualifiedName()); // TODO: use identifier\n    return new Import(\"\");\n  }","id":83639,"modified_method":"@NotNull\n  private static Import importToImport(PsiImportStatementBase t) {\n    if (t != null) {\n      final PsiJavaCodeReferenceElement reference = t.getImportReference();\n      if (reference != null) {\n        return new Import(reference.getQualifiedName()); // TODO: use identifier\n      }\n    }\n    return new Import(\"\");\n  }","commit_id":"f5c1f098be37d7bea8004e4e3877f4566a877479","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void initializeMaps() {\n    if (myClassNameToImportMap == null) {\n      myClassNameToImportMap = new HashMap<String, PsiImportStatement>();\n      myPackageNameToImportMap = new HashMap<String, PsiImportStatement>();\n      myNameToSingleImportMap = new HashMap<String, PsiImportStatementBase>();\n      PsiImportStatement[] imports = getImportStatements();\n      for (PsiImportStatement anImport : imports) {\n        String qName = anImport.getQualifiedName();\n        if (qName == null) continue;\n        if (anImport.isOnDemand()) {\n          myPackageNameToImportMap.put(qName, anImport);\n        }\n        else {\n          myClassNameToImportMap.put(qName, anImport);\n          myNameToSingleImportMap.put(anImport.getImportReference().getReferenceName(), anImport);\n        }\n      }\n\n      PsiImportStaticStatement[] importStatics = getImportStaticStatements();\n      for (PsiImportStaticStatement importStatic : importStatics) {\n        if (!importStatic.isOnDemand()) {\n          String referenceName = importStatic.getReferenceName();\n          if (referenceName != null) {\n            myNameToSingleImportMap.put(referenceName, importStatic);\n          }\n        }\n      }\n    }\n  }","id":83640,"modified_method":"private void initializeMaps() {\n    Map<String, PsiImportStatement> classNameToImportMap = new HashMap<String, PsiImportStatement>();\n    Map<String, PsiImportStatement> packageNameToImportMap = new HashMap<String, PsiImportStatement>();\n    Map<String, PsiImportStatementBase> nameToSingleImportMap = new HashMap<String, PsiImportStatementBase>();\n    PsiImportStatement[] imports = getImportStatements();\n    for (PsiImportStatement anImport : imports) {\n      String qName = anImport.getQualifiedName();\n      if (qName == null) continue;\n      if (anImport.isOnDemand()) {\n        packageNameToImportMap.put(qName, anImport);\n      }\n      else {\n        classNameToImportMap.put(qName, anImport);\n        PsiJavaCodeReferenceElement importReference = anImport.getImportReference();\n        if (importReference == null) continue;\n        nameToSingleImportMap.put(importReference.getReferenceName(), anImport);\n      }\n    }\n\n    PsiImportStaticStatement[] importStatics = getImportStaticStatements();\n    for (PsiImportStaticStatement importStatic : importStatics) {\n      if (!importStatic.isOnDemand()) {\n        String referenceName = importStatic.getReferenceName();\n        if (referenceName != null) {\n          nameToSingleImportMap.put(referenceName, importStatic);\n        }\n      }\n    }\n\n    myClassNameToImportMap = classNameToImportMap;\n    myPackageNameToImportMap = packageNameToImportMap;\n    myNameToSingleImportMap = nameToSingleImportMap;\n  }","commit_id":"18415bbbb35f42a0af0ce7d950fddc13ea1eaf48","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processDeclarations(@NotNull final PsiScopeProcessor processor, @NotNull final ResolveState state, final PsiElement lastParent,\n                                     @NotNull final PsiElement place) {\n    if (isStarImport()) {\n      PyReferenceExpression expr = getImportSource();\n      if (expr != null) {\n        final PsiElement importedFile = ResolveImportUtil.resolveImportReference(expr, expr.getReferencedName());\n        if (importedFile != null) {\n          return importedFile.processDeclarations(processor, state, null, place);\n        }\n      }\n    }\n    else {\n      PyImportElement[] importElements = getImportElements();\n      for(PyImportElement element: importElements) {\n        if (!element.processDeclarations(processor, state, lastParent, place)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }","id":83641,"modified_method":"public boolean processDeclarations(@NotNull final PsiScopeProcessor processor, @NotNull final ResolveState state, final PsiElement lastParent,\n                                     @NotNull final PsiElement place) {\n    if (isStarImport()) {\n      PyReferenceExpression expr = getImportSource();\n      if (expr != null) {\n        final PsiElement importedFile = ResolveImportUtil.resolveImportReference(expr);\n        if (importedFile != null) {\n          return importedFile.processDeclarations(processor, state, null, place);\n        }\n      }\n    }\n    else {\n      PyImportElement[] importElements = getImportElements();\n      for(PyImportElement element: importElements) {\n        if (!element.processDeclarations(processor, state, lastParent, place)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }","commit_id":"ad8cef190c57e0b0981fb939f1441653bf5312ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean processDeclarations(@NotNull final PsiScopeProcessor processor, @NotNull final ResolveState state, final PsiElement lastParent,\n                                     @NotNull final PsiElement place) {\n    return processor.execute(getImportReference(), state);\n  }","id":83642,"modified_method":"@Override\n  public boolean processDeclarations(@NotNull final PsiScopeProcessor processor, @NotNull final ResolveState state, final PsiElement lastParent,\n                                     @NotNull final PsiElement place) {\n    final PyReferenceExpression importRef = getImportReference();\n    final PsiElement element = importRef.resolve();\n    if (element != null) {\n      return processor.execute(element, state);\n    }\n    return true;\n  }","commit_id":"ad8cef190c57e0b0981fb939f1441653bf5312ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean processDeclarations(@NotNull final PsiScopeProcessor processor, @NotNull final ResolveState state, final PsiElement lastParent,\n                                     @NotNull final PsiElement place) {\n    return getImportElement().processDeclarations(processor, state, lastParent, place);\n  }","id":83643,"modified_method":"@Override\n  public boolean processDeclarations(@NotNull final PsiScopeProcessor processor,\n                                     @NotNull final ResolveState state,\n                                     final PsiElement lastParent,\n                                     @NotNull final PsiElement place) {\n    for (PyImportElement element : getImportElements()) {\n      if (element == lastParent) continue;\n      if (!element.processDeclarations(processor, state, null, place)) return false;\n    }\n    return true;\n  }","commit_id":"ad8cef190c57e0b0981fb939f1441653bf5312ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyImportElement getImportElement() {\n    return (PyImportElement)getNode().findChildByType(PyElementTypes.IMPORT_ELEMENT).getPsi();\n  }","id":83644,"modified_method":"public PyImportElement[] getImportElements() {\n    return childrenToPsi(TokenSet.create(PyElementTypes.IMPORT_ELEMENT), new PyImportElement[0]);\n  }","commit_id":"ad8cef190c57e0b0981fb939f1441653bf5312ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public\n  @Nullable\n  PsiElement resolve() {\n    final String referencedName = getReferencedName();\n    if (referencedName == null) return null;\n\n    final PyExpression qualifier = getQualifier();\n    if (qualifier != null) {\n      if (qualifier instanceof PyCallExpression) {\n        final PyCallExpression callExpression = (PyCallExpression)qualifier;\n        final PyReferenceExpression expression = callExpression.getCalledFunctionReference();\n        final PsiElement element = expression.resolve();\n        if (element != null) {\n          return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), element, element, element);\n        }\n      }\n      else if (qualifier instanceof PyReferenceExpression) {\n        final PsiElement element = ((PyReferenceExpression)qualifier).resolve();\n        if (element != null) {\n          final PsiElement parent = element.getParent();\n          if (parent instanceof PyAssignmentStatement) {\n            final PyExpression value = ((PyAssignmentStatement)parent).getAssignedValue();\n            if (value instanceof PyCallExpression) {\n              final PsiElement c = ((PyCallExpression)value).getCalledFunctionReference().resolve();\n              return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), c, c, c);\n            }\n          } else if (element instanceof PyReferenceExpression && parent instanceof PyImportElement) {\n            final PsiElement c = ((PyReferenceExpression)element).resolve();\n            return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), c, c, c);\n          }\n        }\n      }\n      return null; // TODO?\n    }\n\n    if (getParent() instanceof PyImportElement || getParent() instanceof PyFromImportStatement) {\n      return ResolveImportUtil.resolveImportReference(this, referencedName);\n    }\n\n    return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), this, this, null);\n  }","id":83645,"modified_method":"public\n  @Nullable\n  PsiElement resolve() {\n    final String referencedName = getReferencedName();\n    if (referencedName == null) return null;\n\n    if (getParent() instanceof PyImportElement || getParent() instanceof PyFromImportStatement) {\n      return ResolveImportUtil.resolveImportReference(this);\n    }\n\n    final PyExpression qualifier = getQualifier();\n    if (qualifier != null) {\n      if (qualifier instanceof PyCallExpression) {\n        final PyCallExpression callExpression = (PyCallExpression)qualifier;\n        final PyReferenceExpression expression = callExpression.getCalledFunctionReference();\n        final PsiElement element = expression.resolve();\n        if (element != null) {\n          return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), element, element, element);\n        }\n      }\n      else if (qualifier instanceof PyReferenceExpression) {\n        final PsiElement element = ((PyReferenceExpression)qualifier).resolve();\n        if (element != null) {\n          final PsiElement parent = element.getParent();\n          if (parent instanceof PyAssignmentStatement) {\n            final PyExpression value = ((PyAssignmentStatement)parent).getAssignedValue();\n            if (value instanceof PyCallExpression) {\n              final PsiElement c = ((PyCallExpression)value).getCalledFunctionReference().resolve();\n              return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), c, c, c);\n            }\n          } else if (element instanceof PyReferenceExpression && parent instanceof PyImportElement) {\n            final PsiElement c = ((PyReferenceExpression)element).resolve();\n            return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), c, c, c);\n          }\n        }\n      }\n      return null; // TODO?\n    }\n\n    return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), this, this, null);\n  }","commit_id":"ad8cef190c57e0b0981fb939f1441653bf5312ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean execute(PsiElement element, ResolveState substitutor) {\n      if (element instanceof PsiNamedElement) {\n        if (_name.equals(((PsiNamedElement)element).getName())) {\n          _result = element;\n          return false;\n        }\n      }\n      else if (element instanceof PyReferenceExpression) {\n        PyReferenceExpression expr = (PyReferenceExpression)element;\n        String referencedName = expr.getReferencedName();\n        if (referencedName != null && referencedName.equals(_name)) {\n          _result = element;\n          return false;\n        }\n      }\n\n      return true;\n    }","id":83646,"modified_method":"public boolean execute(PsiElement element, ResolveState substitutor) {\n      if (element instanceof PyFile) {\n        final VirtualFile file = ((PyFile)element).getVirtualFile();\n        if (file != null && _name.equals(file.getNameWithoutExtension())) {\n          _result = element;\n          return false;\n        }\n      }\n      else if (element instanceof PsiNamedElement) {\n        if (_name.equals(((PsiNamedElement)element).getName())) {\n          _result = element;\n          return false;\n        }\n      }\n      else if (element instanceof PyReferenceExpression) {\n        PyReferenceExpression expr = (PyReferenceExpression)element;\n        String referencedName = expr.getReferencedName();\n        if (referencedName != null && referencedName.equals(_name)) {\n          _result = element;\n          return false;\n        }\n      }\n\n      return true;\n    }","commit_id":"ad8cef190c57e0b0981fb939f1441653bf5312ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  static PsiElement resolveImportReference(final PyElement context, final String referencedName) {\n    final PsiFile[] files = FilenameIndex.getFilesByName(context.getProject(), referencedName + \".py\",\n                                                         GlobalSearchScope.allScope(context.getProject()));\n    if (files.length == 1) return files[0];\n    return null;\n  }","id":83647,"modified_method":"@Nullable\n  static PsiElement resolveImportReference(final PyReferenceExpression importRef) {\n    String referencedName = importRef.getReferencedName();\n    if (referencedName == null) return null;\n    if (importRef.getParent() instanceof PyImportElement) {\n      PyImportElement parent = (PyImportElement) importRef.getParent();\n      if (parent.getParent() instanceof PyFromImportStatement) {\n        PyFromImportStatement stmt = (PyFromImportStatement) parent.getParent();\n        final PyReferenceExpression source = stmt.getImportSource();\n        if (source == null) return null;\n        PsiElement sourceFile = resolveImportReference(source);\n        if (sourceFile instanceof PyFile) {\n          return PyResolveUtil.treeWalkUp(new PyResolveUtil.ResolveProcessor(referencedName), sourceFile, null, importRef);\n        }\n      }\n    }\n    final PsiFile[] files = FilenameIndex.getFilesByName(importRef.getProject(), referencedName + \".py\",\n                                                         GlobalSearchScope.allScope(importRef.getProject()));\n    if (files.length == 1) return files[0];\n    return null;\n  }","commit_id":"ad8cef190c57e0b0981fb939f1441653bf5312ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean accept(File dir, String name) {\n      return name.indexOf(\"CVS\") == -1;\n    }","id":83648,"modified_method":"@Override\n    public boolean accept(File dir, String name) {\n      return !name.contains(\"CVS\");\n    }","commit_id":"75bb20554d5c01b35f0d0e7de3397affe3e1d473","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TestInfo(@NotNull ThrowableRunnable test, int expected) {\n      this.test = test;\n      this.expected = expected;\n    }","id":83649,"modified_method":"private TestInfo(@NotNull ThrowableRunnable test, int expected, String message) {\n      this.test = test;\n      this.expected = expected;\n      this.message = message;\n    }","commit_id":"75bb20554d5c01b35f0d0e7de3397affe3e1d473","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void assertFilesEqual(VirtualFile fileAfter, VirtualFile fileBefore) throws IOException {\n    try {\n      assertJarFilesEqual(VfsUtil.virtualToIoFile(fileAfter), VfsUtil.virtualToIoFile(fileBefore));\n    }\n    catch (IOException e) {\n      FileDocumentManager manager = FileDocumentManager.getInstance();\n      Document docBefore = manager.getDocument(fileBefore);\n      Document docAfter = manager.getDocument(fileAfter);\n      if (docBefore != null && docAfter != null) {\n        Assert.assertEquals(fileAfter.getPath(), docAfter.getText(), docBefore.getText());\n      } else {\n        Assert.assertArrayEquals(fileAfter.getPath(), fileAfter.contentsToByteArray(), fileBefore.contentsToByteArray());\n      }\n    }\n  }","id":83650,"modified_method":"public static void assertFilesEqual(VirtualFile fileAfter, VirtualFile fileBefore) throws IOException {\n    try {\n      assertJarFilesEqual(VfsUtil.virtualToIoFile(fileAfter), VfsUtil.virtualToIoFile(fileBefore));\n    }\n    catch (IOException e) {\n      FileDocumentManager manager = FileDocumentManager.getInstance();\n      Document docBefore = manager.getDocument(fileBefore);\n      boolean canLoadBeforeText = !fileBefore.getFileType().isBinary() || fileBefore.getFileType() == FileTypes.UNKNOWN;\n      String textB = docBefore == null ? !canLoadBeforeText ? null : LoadTextUtil.getTextByBinaryPresentation(fileBefore.contentsToByteArray(false), fileBefore).toString() : docBefore.getText();\n      Document docAfter = manager.getDocument(fileAfter);\n      boolean canLoadAfterText = !fileBefore.getFileType().isBinary() || fileBefore.getFileType() == FileTypes.UNKNOWN;\n      String textA = docAfter == null ? !canLoadAfterText ? null : LoadTextUtil.getTextByBinaryPresentation(fileAfter.contentsToByteArray(false), fileAfter).toString() : docAfter.getText();\n      if (textA != null && textB != null) {\n        Assert.assertEquals(fileAfter.getPath(), textA, textB);\n      }\n      else {\n        Assert.assertArrayEquals(fileAfter.getPath(), fileAfter.contentsToByteArray(), fileBefore.contentsToByteArray());\n      }\n    }\n  }","commit_id":"75bb20554d5c01b35f0d0e7de3397affe3e1d473","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void assertTiming() {\n      assert expected != 0 : \"Must call .expect() before run test\";\n      if (COVERAGE_ENABLED_BUILD) return;\n\n      while (true) {\n        attempts--;\n        long start;\n        try {\n          if (setup != null) setup.run();\n          start = System.currentTimeMillis();\n          test.run();\n        }\n        catch (Throwable throwable) {\n          throw new RuntimeException(throwable);\n        }\n        long finish = System.currentTimeMillis();\n        long duration = finish - start;\n\n        int expectedOnMyMachine = expected;\n        if (adjustForCPU) {\n          expectedOnMyMachine = Math.max(1, (int)(1.0 * expectedOnMyMachine * Timings.CPU_TIMING / Timings.ETALON_CPU_TIMING));\n          expectedOnMyMachine = usesAllCPUCores ? expectedOnMyMachine * 8 / JobSchedulerImpl.CORES_COUNT : expectedOnMyMachine;\n        }\n        if (adjustForIO) {\n          expectedOnMyMachine = Math.max(1, (int)(1.0 * expectedOnMyMachine * Timings.IO_TIMING / Timings.ETALON_IO_TIMING));\n        }\n        final double acceptableChangeFactor = 1.1;\n\n        // Allow 10% more in case of test machine is busy.\n        String logMessage = message;\n        if (duration > expectedOnMyMachine) {\n          int percentage = (int)(100.0 * (duration - expectedOnMyMachine) / expectedOnMyMachine);\n          logMessage += \". (\" + percentage + \"% longer).\";\n        }\n        logMessage += \" Expected: \" + expectedOnMyMachine + \".\" +\n                      \" Actual: \" + duration + \".\" + Timings.getStatistics() ;\n        if (duration < expectedOnMyMachine) {\n          TeamCityLogger.info(logMessage);\n          System.out.println(\"SUCCESS: \"+logMessage);\n        }\n        else if (duration < expectedOnMyMachine * acceptableChangeFactor) {\n          TeamCityLogger.warning(logMessage, null);\n          System.out.println(\"WARNING: \" + logMessage);\n        }\n        else {\n          // try one more time\n          if (attempts == 0) throw new AssertionFailedError(logMessage);\n          System.gc();\n          System.gc();\n          System.gc();\n          String s = \"Another epic fail (remaining attempts: \" + attempts + \"): \" + logMessage;\n          TeamCityLogger.warning(s, null);\n          System.err.println(s);\n          continue;\n        }\n        break;\n      }\n    }","id":83651,"modified_method":"public void assertTiming() {\n      assert expected != 0 : \"Must call .expect() before run test\";\n      if (COVERAGE_ENABLED_BUILD) return;\n\n      while (true) {\n        attempts--;\n        long start;\n        try {\n          if (setup != null) setup.run();\n          start = System.currentTimeMillis();\n          test.run();\n        }\n        catch (Throwable throwable) {\n          throw new RuntimeException(throwable);\n        }\n        long finish = System.currentTimeMillis();\n        long duration = finish - start;\n\n        int expectedOnMyMachine = expected;\n        if (adjustForCPU) {\n          // most of our algorithms are quadratic. sad but true.\n          expectedOnMyMachine = Math.max(1, (int)(expectedOnMyMachine * (0.907 + Math.pow(1.0 * Timings.CPU_TIMING / Timings.ETALON_CPU_TIMING - 0.695,2))));\n          expectedOnMyMachine = usesAllCPUCores ? expectedOnMyMachine * 8 / JobSchedulerImpl.CORES_COUNT : expectedOnMyMachine;\n        }\n        if (adjustForIO) {\n          expectedOnMyMachine = Math.max(1, (int)(1.0 * expectedOnMyMachine * (1 + Math.pow(1.0 * Timings.IO_TIMING / Timings.ETALON_IO_TIMING - 1,2))));\n        }\n        final double acceptableChangeFactor = 1.1;\n\n        // Allow 10% more in case of test machine is busy.\n        String logMessage = message;\n        if (duration > expectedOnMyMachine) {\n          int percentage = (int)(100.0 * (duration - expectedOnMyMachine) / expectedOnMyMachine);\n          logMessage += \". (\" + percentage + \"% longer).\";\n        }\n        logMessage += \" Expected: \" + expectedOnMyMachine + \".\" +\n                      \" Actual: \" + duration + \".\" + Timings.getStatistics() ;\n        if (duration < expectedOnMyMachine) {\n          int percentage = (int)(100.0 * (expectedOnMyMachine - duration) / expectedOnMyMachine);\n          logMessage = \"(\" + percentage + \"% faster). \" + logMessage;\n\n          TeamCityLogger.info(logMessage);\n          System.out.println(\"SUCCESS: \"+logMessage);\n        }\n        else if (duration < expectedOnMyMachine * acceptableChangeFactor) {\n          TeamCityLogger.warning(logMessage, null);\n          System.out.println(\"WARNING: \" + logMessage);\n        }\n        else {\n          // try one more time\n          if (attempts == 0) throw new AssertionFailedError(logMessage);\n          System.gc();\n          System.gc();\n          System.gc();\n          String s = \"Another epic fail (remaining attempts: \" + attempts + \"): \" + logMessage;\n          TeamCityLogger.warning(s, null);\n          System.err.println(s);\n          continue;\n        }\n        break;\n      }\n    }","commit_id":"75bb20554d5c01b35f0d0e7de3397affe3e1d473","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static TestInfo startPerformanceTest(int expected, @NotNull ThrowableRunnable test) {\n    return new TestInfo(test, expected);\n  }","id":83652,"modified_method":"/**\n   * example usage: startPerformanceTest(100, testRunnable).cpuBound().assertTiming();\n   */\n  public static TestInfo startPerformanceTest(int expected, @NotNull ThrowableRunnable test) {\n    return startPerformanceTest(\"\",expected, test);\n  }","commit_id":"75bb20554d5c01b35f0d0e7de3397affe3e1d473","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static TestInfo startPerformanceTest(@NonNls @NotNull String message, int expected, @NotNull ThrowableRunnable test) {\n    return startPerformanceTest(expected, test).message(message);\n  }","id":83653,"modified_method":"public static TestInfo startPerformanceTest(@NonNls @NotNull String message, int expected, @NotNull ThrowableRunnable test) {\n    return new TestInfo(test, expected,message);\n  }","commit_id":"75bb20554d5c01b35f0d0e7de3397affe3e1d473","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@TestOnly\n  public static void waitForAlarm(final int delay) throws InterruptedException {\n    assert !ApplicationManager.getApplication().isWriteAccessAllowed(): \"It's a bad idea to wait for an alarm under the write action. Somebody creates an alarm which requires read action and you are deadlocked.\";\n    final AtomicBoolean invoked = new AtomicBoolean();\n    final Alarm alarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);\n    alarm.addRequest(new Runnable() {\n      @Override\n      public void run() {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            alarm.addRequest(new Runnable() {\n              @Override\n              public void run() {\n                invoked.set(true);\n              }\n            }, delay);\n          }\n        });\n      }\n    }, delay);\n\n    UIUtil.dispatchAllInvocationEvents();\n\n    boolean sleptAlready = false;\n    while (!invoked.get()) {\n      UIUtil.dispatchAllInvocationEvents();\n      Thread.sleep(sleptAlready ? 10 : delay);\n      sleptAlready = true;\n    }\n    UIUtil.dispatchAllInvocationEvents();\n  }","id":83654,"modified_method":"@TestOnly\n  public static void waitForAlarm(final int delay) throws InterruptedException {\n    assert !ApplicationManager.getApplication().isWriteAccessAllowed(): \"It's a bad idea to wait for an alarm under the write action. Somebody creates an alarm which requires read action and you are deadlocked.\";\n    assert ApplicationManager.getApplication().isDispatchThread();\n\n    final AtomicBoolean invoked = new AtomicBoolean();\n    final Alarm alarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);\n    alarm.addRequest(new Runnable() {\n      @Override\n      public void run() {\n        ApplicationManager.getApplication().invokeLater(new Runnable() {\n          @Override\n          public void run() {\n            alarm.addRequest(new Runnable() {\n              @Override\n              public void run() {\n                invoked.set(true);\n              }\n            }, delay);\n          }\n        });\n      }\n    }, delay);\n\n    UIUtil.dispatchAllInvocationEvents();\n\n    boolean sleptAlready = false;\n    while (!invoked.get()) {\n      UIUtil.dispatchAllInvocationEvents();\n      Thread.sleep(sleptAlready ? 10 : delay);\n      sleptAlready = true;\n    }\n    UIUtil.dispatchAllInvocationEvents();\n  }","commit_id":"75bb20554d5c01b35f0d0e7de3397affe3e1d473","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void assertJarFilesEqual(File file1, File file2) throws IOException {\n    final JarFile jarFile1 = new JarFile(file1);\n    final JarFile jarFile2 = new JarFile(file2);\n    final File tempDirectory1 = PlatformTestCase.createTempDir(\"tmp1\");\n    final File tempDirectory2 = PlatformTestCase.createTempDir(\"tmp2\");\n    ZipUtil.extract(jarFile1, tempDirectory1, CVS_FILE_FILTER);\n    ZipUtil.extract(jarFile2, tempDirectory2, CVS_FILE_FILTER);\n    jarFile1.close();\n    jarFile2.close();\n    final VirtualFile dirAfter = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempDirectory1);\n    final VirtualFile dirBefore = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempDirectory2);\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        dirAfter.refresh(false, true);\n        dirBefore.refresh(false, true);\n      }\n    });\n    assertDirectoriesEqual(dirAfter, dirBefore, CVS_FILE_FILTER);\n  }","id":83655,"modified_method":"public static void assertJarFilesEqual(File file1, File file2) throws IOException {\n    JarFile jarFile1 = null;\n    JarFile jarFile2 = null;\n    final File tempDirectory1;\n    final File tempDirectory2;\n    try {\n      jarFile2 = new JarFile(file2);\n      jarFile1 = new JarFile(file1);\n      tempDirectory1 = PlatformTestCase.createTempDir(\"tmp1\");\n      tempDirectory2 = PlatformTestCase.createTempDir(\"tmp2\");\n      ZipUtil.extract(jarFile1, tempDirectory1, CVS_FILE_FILTER);\n      ZipUtil.extract(jarFile2, tempDirectory2, CVS_FILE_FILTER);\n    }\n    finally {\n      if (jarFile1 != null) {\n        jarFile1.close();\n      }\n      if (jarFile2 != null) {\n        jarFile2.close();\n      }\n    }\n    final VirtualFile dirAfter = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempDirectory1);\n    final VirtualFile dirBefore = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempDirectory2);\n    ApplicationManager.getApplication().runWriteAction(new Runnable() {\n      @Override\n      public void run() {\n        dirAfter.refresh(false, true);\n        dirBefore.refresh(false, true);\n      }\n    });\n    assertDirectoriesEqual(dirAfter, dirBefore, CVS_FILE_FILTER);\n  }","commit_id":"75bb20554d5c01b35f0d0e7de3397affe3e1d473","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * \n     * @param distUrl URL to directory where the distribution zip is found\n     * @param grailsVersion version of Grails to configure\n     * @return a File pointing to the directory where this version of Grails is configured\n     */\n    private static File configureGrailsInstallation(String distUrl,\n            final String grailsVersion) throws Exception {\n        final String src = distUrl + \"grails-\" + grailsVersion + \".zip\";\n        final URI uri = new URI(src);\n        \n        final File grailsCacheDir =  new File(System.getProperty(\"user.home\") + \"/.grails/\");\n        final File wrapperDir = new File(grailsCacheDir, \"wrapper\");\n        final File downloadFile = new File(wrapperDir, \"grails-\" + grailsVersion + \"-download.zip\");\n        new RemoteFileHelper().retrieve(uri, downloadFile);\n        final File installDir = new File(wrapperDir, grailsVersion);\n        if (!installDir.exists()) {\n            extract(downloadFile, installDir);\n        }\n        final File grailsHome = new File(installDir, \"grails-\" + grailsVersion);\n        return grailsHome;\n    }","id":83656,"modified_method":"/**\n     * \n     * @param distUrl URL to directory where the distribution zip is found\n     * @param grailsVersion version of Grails to configure\n     * @return a File pointing to the directory where this version of Grails is configured\n     */\n    private static File configureGrailsInstallation(String distUrl,\n            final String grailsVersion) throws Exception {\n        final String src = distUrl + \"grails-\" + grailsVersion + \".zip\";\n        final URI uri = new URI(src);\n        \n        final File grailsCacheDir =  new File(System.getProperty(\"user.home\") + \"/.grails/\");\n        final File wrapperDir = new File(grailsCacheDir, \"wrapper\");\n        final File installDir = new File(wrapperDir, grailsVersion);\n        File downloadFile = null;\n        if (!installDir.exists()) {\n            try {\n                downloadFile = new File(wrapperDir, \"grails-\" + grailsVersion + \"-download.zip\");\n                new RemoteFileHelper().retrieve(uri, downloadFile);\n                extract(downloadFile, installDir);\n            } finally {\n                try {\n                    if(downloadFile != null && downloadFile.exists()) {\n                        downloadFile.delete();\n                    }\n                } catch (Exception e) {}\n            }\n        }\n        final File grailsHome = new File(installDir, \"grails-\" + grailsVersion);\n        return grailsHome;\n    }","commit_id":"2652e45570db31a06671c7332981744d75298ce7","url":"https://github.com/grails/grails-core"},{"original_method":"public void retrieve(final URI address, final File destination) throws Exception {\n        if (destination.exists()) {\n            return;\n        }\n        destination.getParentFile().mkdirs();\n\n        System.out.println(\"Downloading \" + address + \" to \" + destination.getAbsolutePath());\n        OutputStream out = null;\n        InputStream in = null;\n        try {\n            final URL url = address.toURL();\n            out = new BufferedOutputStream(\n                    new FileOutputStream(destination));\n            final URLConnection conn = url.openConnection();\n            in = conn.getInputStream();\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int numRead;\n            long progressCounter = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                progressCounter += numRead;\n                if (progressCounter / CHUNK_SIZE > 0) {\n                    System.out.print(\".\");\n                    progressCounter = progressCounter - CHUNK_SIZE;\n                }\n                out.write(buffer, 0, numRead);\n            }\n        } finally {\n            System.out.println(\"\");\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }","id":83657,"modified_method":"public void retrieve(final URI address, final File destination) throws Exception {\n        destination.getParentFile().mkdirs();\n\n        System.out.println(\"Downloading \" + address + \" to \" + destination.getAbsolutePath());\n        OutputStream out = null;\n        InputStream in = null;\n        try {\n            final URL url = address.toURL();\n            out = new BufferedOutputStream(\n                    new FileOutputStream(destination));\n            final URLConnection conn = url.openConnection();\n            in = conn.getInputStream();\n            final byte[] buffer = new byte[BUFFER_SIZE];\n            int numRead;\n            long progressCounter = 0;\n            while ((numRead = in.read(buffer)) != -1) {\n                progressCounter += numRead;\n                if (progressCounter / CHUNK_SIZE > 0) {\n                    System.out.print(\".\");\n                    progressCounter = progressCounter - CHUNK_SIZE;\n                }\n                out.write(buffer, 0, numRead);\n            }\n        } finally {\n            System.out.println(\"\");\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }","commit_id":"2652e45570db31a06671c7332981744d75298ce7","url":"https://github.com/grails/grails-core"},{"original_method":"public void render () {\r\n\r\n\t\tlogger.log();\r\n\r\n\t\tfinal float delta = Gdx.graphics.getDeltaTime();\r\n\t\tcamController.update(delta);\r\n\r\n\t\tGdx.gl.glEnable(GL10.GL_CULL_FACE);\r\n\t\tGdx.gl.glCullFace(GL10.GL_BACK);\r\n\t\tGdx.gl.glEnable(GL10.GL_DEPTH_TEST);\r\n\t\tGdx.gl.glDepthMask(true);\r\n\r\n\t\tGdx.gl.glClearColor(0, 0, 0, 0);\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\r\n\r\n\t\ttexture.bind(0);\r\n\r\n\t\tlightShader.begin();\r\n\t\tlightShader.setUniformf(\"camPos\", cam.position.x, cam.position.y, cam.position.z);\r\n\r\n\t\tlightShader.setUniform3fv(\"lightsPos\", lightsPos, 0, LIGHTS_NUM * 3);\r\n\t\tlightShader.setUniform3fv(\"lightsCol\", lightsCol, 0, LIGHTS_NUM * 3);\r\n\t\tlightShader.setUniform1fv(\"lightsInt\", lightsInt, 0, LIGHTS_NUM);\r\n\r\n\t\tlightShader.setUniformMatrix(\"u_projectionViewMatrix\", cam.combined);\r\n\t\tlightShader.setUniformi(\"u_texture\", 0);\r\n\r\n\t\tmesh.render(lightShader, GL10.GL_TRIANGLES);\r\n\r\n\t\ttexture2.bind(0);\r\n\t\tmesh2.render(lightShader, GL10.GL_TRIANGLES);\r\n\r\n\t\tlightShader.end();\r\n\r\n\t}","id":83658,"modified_method":"public void render() {\r\n\r\n\t\tlogger.log();\r\n\r\n\t\tfinal float delta = Gdx.graphics.getDeltaTime();\r\n\t\tcamController.update(delta);\r\n\r\n\t\tGdx.gl.glEnable(GL10.GL_CULL_FACE);\r\n\t\tGdx.gl.glCullFace(GL10.GL_BACK);\r\n\t\tGdx.gl.glEnable(GL10.GL_DEPTH_TEST);\r\n\t\tGdx.gl.glDepthMask(true);\r\n\r\n\t\tGdx.gl.glClearColor(0, 0, 0, 0);\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\r\n\r\n\t\ttexture.bind(0);\r\n\r\n\t\tlightShader.begin();\r\n\r\n\t\tlightShader.setUniformMatrix(\"u_modelMatrix\", modelMatrix, false);\r\n\t\tlightShader.setUniformf(\"camPos\", cam.position.x, cam.position.y,\r\n\t\t\t\tcam.position.z);\r\n\r\n\t\tlightManager.calculateLights(0, 0, 0);\r\n\t\tlightManager.applyLights(lightShader);\r\n\r\n\t\tlightShader.setUniformMatrix(\"u_projectionViewMatrix\", cam.combined);\r\n\t\tlightShader.setUniformi(\"u_texture0\", 0);\r\n\r\n\t\tmesh.render(lightShader, GL10.GL_TRIANGLES);\r\n\r\n\t\ttexture2.bind(0);\r\n\r\n\t\tlightManager.calculateLights(0, 0, 0);\r\n\t\tlightManager.applyLights(lightShader);\r\n\t\tmesh2.render(lightShader, GL10.GL_TRIANGLES);\r\n\r\n\t\tlightShader.end();\r\n\r\n\t}","commit_id":"ee5937be884d83350e2b3d2cf51f50ca886a9f7a","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void create () {\r\n\t\tGdx.graphics.setVSync(false);\r\n\r\n\t\t// rng light pos and colors\r\n\t\tfor (int i = 0; i < LIGHTS_NUM; i++) {\r\n\t\t\tlightsPos[3 * i + 0] = 2 - MathUtils.random() * 5;\r\n\t\t\tlightsPos[3 * i + 1] = MathUtils.random() * 5;\r\n\t\t\t;\r\n\t\t\tlightsPos[3 * i + 2] = 1 - MathUtils.random() * 8;\r\n\r\n\t\t\tlightsCol[3 * i + 0] = MathUtils.random();\r\n\t\t\tlightsCol[3 * i + 1] = MathUtils.random();\r\n\t\t\tlightsCol[3 * i + 2] = MathUtils.random();\r\n\r\n\t\t\tlightsInt[i] = LIGHT_INTESITY;\r\n\t\t}\r\n\r\n\t\tlightShader = ShaderLoader.createShader(\"light\", \"light\");\r\n\r\n\t\tcam = new PerspectiveCamera(67, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());\r\n\t\tcam.near = 0.1f;\r\n\t\tcam.far = 64f;\r\n\t\tcam.position.set(0, 0.5f, -2f);\r\n\t\tcam.update();\r\n\r\n\t\tcamController = new PerspectiveCamController(cam);\r\n\t\tGdx.input.setInputProcessor(camController);\r\n\r\n\t\ttexture = new Texture(Gdx.files.internal(\"data/multipleuvs_1.png\"), null, true);\r\n\t\ttexture.setFilter(TextureFilter.MipMapLinearLinear, TextureFilter.Linear);\r\n\r\n\t\ttexture2 = new Texture(Gdx.files.internal(\"data/wall.png\"), null, true);\r\n\t\ttexture2.setFilter(TextureFilter.MipMapLinearLinear, TextureFilter.Linear);\r\n\t\ttexture2.setWrap(TextureWrap.Repeat, TextureWrap.Repeat);\r\n\r\n\t\ttry {\r\n\t\t\tInputStream in = Gdx.files.internal(\"data/smoothsphere.obj\").read();\r\n\t\t\tmesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\t\t\tin = Gdx.files.internal(\"data/basicscene.obj\").read();\r\n\t\t\tmesh2 = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\t// TODO Auto-generated catch block\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\tmesh2.scale(1.25f, 1.25f, 1.25f);\r\n\r\n\t\tmesh.getVertexAttribute(Usage.Position).alias = \"a_position\";\r\n\t\tmesh.getVertexAttribute(Usage.Normal).alias = \"a_normal\";\r\n\t\t// mesh.getVertexAttribute(Usage.TextureCoordinates).alias =\r\n\t\t// \"a_texCoord0\";\r\n\r\n\t\tmesh2.getVertexAttribute(Usage.Position).alias = \"a_position\";\r\n\t\tmesh2.getVertexAttribute(Usage.Normal).alias = \"a_normal\";\r\n\t\t// mesh2.getVertexAttribute(Usage.TextureCoordinates).alias =\r\n\t\t// \"a_texCoord0\";\r\n\r\n\t}","id":83659,"modified_method":"public void create() {\r\n\r\n\t\tlightShader = ShaderLoader.createShader(\"light\", \"light\");\r\n\r\n\t\tlightManager = new LightManager(8);\r\n\t\tfor (int i = 0; i < 32; i++) {\r\n\t\t\tPointLight l = new PointLight();\r\n\t\t\tl.position.set(MathUtils.random(16) - 8, MathUtils.random(6) - 2,\r\n\t\t\t\t\t-MathUtils.random(16) + 2);\r\n\t\t\tl.color.r = MathUtils.random();\r\n\t\t\tl.color.b = MathUtils.random();\r\n\t\t\tl.color.g = MathUtils.random();\r\n\t\t\tl.range = 8;\r\n\t\t\tlightManager.addLigth(l);\r\n\r\n\t\t}\r\n\r\n\t\tfor (int i = 0; i < 1000; i++) {\r\n\t\t\tlightManager.calculateLights(0, 0, 0);\r\n\t\t\tlightManager.pointLights.shuffle();\r\n\t\t}\r\n\r\n\t\tlong time = System.nanoTime();\r\n\t\tlightManager.calculateLights(0, 0, 0);\r\n\t\tSystem.out.println(\"Time to sort lights pwe model: \"\r\n\t\t\t\t+ (System.nanoTime() - time) + \" ns\");\r\n\r\n\t\tcam = new PerspectiveCamera(67, Gdx.graphics.getWidth(),\r\n\t\t\t\tGdx.graphics.getHeight());\r\n\t\tcam.near = 0.1f;\r\n\t\tcam.far = 64f;\r\n\t\tcam.position.set(0, 0.5f, -2f);\r\n\t\tcam.update();\r\n\r\n\t\tcamController = new PerspectiveCamController(cam);\r\n\t\tGdx.input.setInputProcessor(camController);\r\n\r\n\t\ttexture = new Texture(Gdx.files.internal(\"data/multipleuvs_1.png\"),\r\n\t\t\t\tnull, true);\r\n\t\ttexture.setFilter(TextureFilter.MipMapLinearLinear,\r\n\t\t\t\tTextureFilter.Linear);\r\n\r\n\t\ttexture2 = new Texture(Gdx.files.internal(\"data/wall.png\"), null, true);\r\n\t\ttexture2.setFilter(TextureFilter.MipMapLinearLinear,\r\n\t\t\t\tTextureFilter.Linear);\r\n\t\ttexture2.setWrap(TextureWrap.Repeat, TextureWrap.Repeat);\r\n\r\n\t\ttry {\r\n\t\t\tInputStream in = Gdx.files.internal(\"data/smoothsphere.obj\").read();\r\n\t\t\tmesh = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\t\t\tin = Gdx.files.internal(\"data/basicscene.obj\").read();\r\n\t\t\tmesh2 = ObjLoader.loadObj(in);\r\n\t\t\tin.close();\r\n\r\n\t\t} catch (IOException e) {\r\n\t\t\t// TODO Auto-generated catch block\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\tmesh2.scale(1.25f, 1.25f, 1.25f);\r\n\r\n\t\tmesh.getVertexAttribute(Usage.Position).alias = \"a_position\";\r\n\t\tmesh.getVertexAttribute(Usage.Normal).alias = \"a_normal\";\r\n\t\t// mesh.getVertexAttribute(Usage.TextureCoordinates).alias =\r\n\t\t// \"a_texCoord0\";\r\n\r\n\t\tmesh2.getVertexAttribute(Usage.Position).alias = \"a_position\";\r\n\t\tmesh2.getVertexAttribute(Usage.Normal).alias = \"a_normal\";\r\n\t\t// mesh2.getVertexAttribute(Usage.TextureCoordinates).alias =\r\n\t\t// \"a_texCoord0\";\r\n\r\n\t}","commit_id":"ee5937be884d83350e2b3d2cf51f50ca886a9f7a","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void end() {\r\n\r\n\t\t// TODO how materials is accounted\r\n\r\n\t\t// batched frustum vs bounding box culling(if slow JNI) for all models\r\n\r\n\t\t// sort models(submeshes??)to tranparent and opaque render queue\r\n\r\n\t\t// frustum culling for all point lights (sphere)\r\n\r\n\t\t// find N nearest lights per model\r\n\r\n\t\t// draw for opaque queu\r\n\r\n\t\t// if transparent queue is not empty enable blending(this force gpu to\r\n\t\t// flush and there is some time to sort)\r\n\r\n\t\t// sort transparent models(submeshes??)\r\n\r\n\t\t// do drawing for transparent models\r\n\r\n\t\t// clear all queus\r\n\r\n\t}","id":83660,"modified_method":"@Override\r\n\tpublic void end() {\r\n\r\n\t\t// TODO how materials is accounted\r\n\r\n\t\t// batched frustum vs bounding box culling(if slow JNI) for all models,\r\n\t\t// Maybe at somewhere else,\r\n\r\n\t\t// sort models(submeshes??)to tranparent and opaque render queue, maybe\r\n\t\t// that can be done at flush?\r\n\r\n\t\tflush();\r\n\t}","commit_id":"ee5937be884d83350e2b3d2cf51f50ca886a9f7a","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void begin() {\r\n\t\t// all setting has to be done before this\r\n\r\n\t\t// example: camera updating or updating lights positions\r\n\t}","id":83661,"modified_method":"@Override\r\n\tpublic void begin() {\r\n\t\tdrawing = true;\r\n\r\n\t\t// all setting has to be done before this\r\n\r\n\t\t// example: camera updating or updating lights positions\r\n\t}","commit_id":"ee5937be884d83350e2b3d2cf51f50ca886a9f7a","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void draw(StillModel model, StillModelInstance instance) {\r\n\t\t// add render queue\r\n\t}","id":83662,"modified_method":"@Override\r\n\tpublic void draw(StillModel model, StillModelInstance instance) {\r\n\t\t// add render queue\r\n\t\tstillModelQueue.add(model);\r\n\t\tstillModelInstances.add(instance);\r\n\t}","commit_id":"ee5937be884d83350e2b3d2cf51f50ca886a9f7a","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void render() {\r\n\t\tGdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1.0f);\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\r\n\t\tGdx.gl.glEnable(GL10.GL_DEPTH_TEST);\r\n\r\n\t\tangle += Gdx.graphics.getDeltaTime();\r\n\t\t//cam.rotate(Gdx.graphics.getDeltaTime(), 0, 1, 0);\r\n\t\tcam.update();\r\n\r\n\t\t// drawAxes();\r\n\r\n\t\tshader.begin();\r\n\t\tshader.setUniformMatrix(\"u_projectionViewMatrix\", cam.combined);\r\n\t\tshader.setUniformi(\"u_texture0\", 0);\r\n\t\tshader.setUniformi(\"u_texture1\", 1);\r\n\t\ttextures[0].bind(0);\r\n\t\ttextures[1].bind(1);\r\n\t\tmodel.render(shader);\r\n\r\n\t\tbatch.begin();\r\n\t\tfont.draw(batch, \"fps: \" + Gdx.graphics.getFramesPerSecond(), 20, 30);\r\n\t\tbatch.end();\r\n\r\n\t\tfps.log();\r\n\t}","id":83663,"modified_method":"@Override\r\n\tpublic void render() {\r\n\t\tGdx.gl.glClearColor(0.2f, 0.2f, 0.2f, 1.0f);\r\n\t\tGdx.gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\r\n\t\tGdx.gl.glEnable(GL10.GL_DEPTH_TEST);\r\n\r\n\t\tangle += Gdx.graphics.getDeltaTime();\r\n\t\t// cam.rotate(Gdx.graphics.getDeltaTime(), 0, 1, 0);\r\n\t\tcam.update();\r\n\r\n\t\tshader.begin();\r\n\t\tshader.setUniformMatrix(\"u_projectionViewMatrix\", cam.combined);\r\n\r\n\t\tshader.setUniformi(\"u_texture0\", 0);\r\n\t\ttextures[0].bind(0);\r\n\r\n\t\t// shader.setUniformi(\"u_texture1\", 1);\r\n\t\t// textures[1].bind(1);\r\n\r\n\t\t// model.render(shader);\r\n\r\n\t\tprotoRenderer.begin();\r\n\t\tprotoRenderer.draw(model, instance);\r\n\t\tprotoRenderer.end();\r\n\r\n\t\tbatch.begin();\r\n\t\tfont.draw(batch, \"fps: \" + Gdx.graphics.getFramesPerSecond(), 20, 30);\r\n\t\tbatch.end();\r\n\r\n\t\tfps.log();\r\n\t}","commit_id":"ee5937be884d83350e2b3d2cf51f50ca886a9f7a","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void create() {\r\n\t\tlong start = System.nanoTime();\r\n\t\tmodel = ModelLoaderRegistry\r\n\t\t\t\t.loadStillModel(Gdx.files.internal(fileName));\r\n\t\tGdx.app.log(\"StillModelViewer\", \"loading took: \"\r\n\t\t\t\t+ (System.nanoTime() - start) / 1000000000.0f);\r\n\r\n\t\tfor (StillSubMesh mesh : model.subMeshes) {\r\n\t\t\tmesh.mesh.scale(0.1f, 0.1f, 0.1f);\r\n\t\t}\r\n\r\n\t\tif (!fileName.endsWith(\".g3d\")) {\r\n\t\t\tG3dExporter.export(model, Gdx.files.absolute(fileName + \".g3d\"));\r\n\t\t\tstart = System.nanoTime();\r\n\t\t\tmodel = G3dLoader.loadStillModel(Gdx.files.absolute(fileName\r\n\t\t\t\t\t+ \".g3d\"));\r\n\t\t\tGdx.app.log(\"StillModelViewer\",\r\n\t\t\t\t\t\"loading binary took: \" + (System.nanoTime() - start)\r\n\t\t\t\t\t\t\t/ 1000000000.0f);\r\n\t\t}\r\n\r\n\t\tif (textureFileNames.length != 0) {\r\n\t\t\ttextures = new Texture[textureFileNames.length];\r\n\t\t\tfor (int i = 0; i < textureFileNames.length; i++) {\r\n\t\t\t\ttextures[i] = new Texture(\r\n\t\t\t\t\t\tGdx.files.internal(textureFileNames[i]), i > 0 ? false\r\n\t\t\t\t\t\t\t\t: true);\r\n\t\t\t}\r\n\t\t}\r\n\t\thasNormals = hasNormals();\r\n\r\n\t\tSystem.out.println(\"hasNormal: \" + hasNormals);\r\n\r\n\t\tmodel.getBoundingBox(bounds);\r\n\t\tfloat len = bounds.getDimensions().len();\r\n\t\tSystem.out.println(\"bounds: \" + bounds);\r\n\r\n\t\tcam = new PerspectiveCamera(60, Gdx.graphics.getWidth(),\r\n\t\t\t\tGdx.graphics.getHeight());\r\n\t\tcam.position.set(bounds.getCenter().cpy()\r\n\t\t\t\t.add(len / 2, len / 2, len / 2));\r\n\t\tcam.lookAt(bounds.getCenter().x, bounds.getCenter().y,\r\n\t\t\t\tbounds.getCenter().z);\r\n\t\tcam.near = 0.1f;\r\n\t\tcam.far = 1000;\r\n\r\n\t\trenderer = new ImmediateModeRenderer20(false, true, 16);\r\n\t\tbatch = new SpriteBatch();\r\n\t\tfont = new BitmapFont();\r\n\r\n\t\tshader = new ShaderProgram(Gdx.files\r\n\t\t\t\t.internal(\"data/modelshader.vertex\").readString(), Gdx.files\r\n\t\t\t\t.internal(\"data/modelshader.fragment\").readString());\r\n\t\tSystem.out.println(\"shader\" + shader.isCompiled());\r\n\r\n\t\tfor (StillSubMesh mesh : model.subMeshes) {\r\n\t\t\tSystem.out.println(mesh.material.name);\r\n\t\t}\r\n\t}","id":83664,"modified_method":"@Override\r\n\tpublic void create() {\r\n\t\tlong start = System.nanoTime();\r\n\t\tmodel = ModelLoaderRegistry\r\n\t\t\t\t.loadStillModel(Gdx.files.internal(fileName));\r\n\t\tGdx.app.log(\"StillModelViewer\", \"loading took: \"\r\n\t\t\t\t+ (System.nanoTime() - start) / 1000000000.0f);\r\n\r\n\t\tfor (StillSubMesh mesh : model.subMeshes) {\r\n\t\t\tmesh.mesh.scale(0.1f, 0.1f, 0.1f);\r\n\t\t}\r\n\r\n\t\tif (!fileName.endsWith(\".g3d\")) {\r\n\t\t\tG3dExporter.export(model, Gdx.files.absolute(fileName + \".g3d\"));\r\n\t\t\tstart = System.nanoTime();\r\n\t\t\tmodel = G3dLoader.loadStillModel(Gdx.files.absolute(fileName\r\n\t\t\t\t\t+ \".g3d\"));\r\n\t\t\tGdx.app.log(\"StillModelViewer\",\r\n\t\t\t\t\t\"loading binary took: \" + (System.nanoTime() - start)\r\n\t\t\t\t\t\t\t/ 1000000000.0f);\r\n\t\t}\r\n\r\n\t\tif (textureFileNames.length != 0) {\r\n\t\t\ttextures = new Texture[textureFileNames.length];\r\n\t\t\tfor (int i = 0; i < textureFileNames.length; i++) {\r\n\t\t\t\ttextures[i] = new Texture(\r\n\t\t\t\t\t\tGdx.files.internal(textureFileNames[i]), i > 0 ? false\r\n\t\t\t\t\t\t\t\t: true);\r\n\t\t\t}\r\n\t\t}\r\n\t\thasNormals = hasNormals();\r\n\r\n\t\tSystem.out.println(\"hasNormal: \" + hasNormals);\r\n\r\n\t\tmodel.getBoundingBox(bounds);\r\n\t\tfloat len = bounds.getDimensions().len();\r\n\t\tSystem.out.println(\"bounds: \" + bounds);\r\n\r\n\t\tcam = new PerspectiveCamera(60, Gdx.graphics.getWidth(),\r\n\t\t\t\tGdx.graphics.getHeight());\r\n\t\tcam.position.set(bounds.getCenter().cpy()\r\n\t\t\t\t.add(len / 2, len / 2, len / 2));\r\n\t\tcam.lookAt(bounds.getCenter().x, bounds.getCenter().y,\r\n\t\t\t\tbounds.getCenter().z);\r\n\t\tcam.near = 0.1f;\r\n\t\tcam.far = 1000;\r\n\r\n\t\trenderer = new ImmediateModeRenderer20(false, true, 16);\r\n\t\tbatch = new SpriteBatch();\r\n\t\tfont = new BitmapFont();\r\n\r\n\t\tshader = ShaderLoader.createShader(\"light\", \"light\");\r\n\r\n\t\tlightManager = new LightManager(8);\r\n\t\tfor (int i = 0; i < 16; i++) {\r\n\t\t\tPointLight l = new PointLight();\r\n\t\t\tl.position.set(MathUtils.random(16) - 8, MathUtils.random(6) - 2,\r\n\t\t\t\t\t-MathUtils.random(16) + 2);\r\n\t\t\tl.color.r = MathUtils.random();\r\n\t\t\tl.color.b = MathUtils.random();\r\n\t\t\tl.color.g = MathUtils.random();\r\n\t\t\tl.range = 4;\r\n\t\t\tlightManager.addLigth(l);\r\n\r\n\t\t}\r\n\t\t\r\n\t\tprotoRenderer = new PrototypeRendererGL20();\r\n\t\tprotoRenderer.setShader(shader);\r\n\t\tprotoRenderer.setLightManager(lightManager);\r\n\r\n\t\tinstance = new Instance();\r\n\r\n\t\tfor (StillSubMesh mesh : model.subMeshes) {\r\n\t\t\tSystem.out.println(mesh.material.name);\r\n\t\t}\r\n\t}","commit_id":"ee5937be884d83350e2b3d2cf51f50ca886a9f7a","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Test method. */\n  @Test\n  public void function() {\n    String func = query(_INSPECT_FUNCTION.args(\" true#0\"));\n    query(func + \"/@name/data()\", \"true\");\n    query(func + \"/@uri/data()\", \"http://www.w3.org/2005/xpath-functions\");\n    query(func + \"/return/@type/data()\", \"xs:boolean\");\n    query(func + \"/return/@occurrence/data()\", \"\");\n\n    func = query(_INSPECT_FUNCTION.args(\" { }\"));\n    query(func + \"/@name/data()\", \"\");\n    query(func + \"/@uri/data()\", \"\");\n    query(func + \"/argument/@type/data()\", \"xs:anyAtomicType\");\n    query(func + \"/return/@type/data()\", \"item()\");\n    query(func + \"/return/@occurrence/data()\", \"*\");\n\n    func = query(_INSPECT_FUNCTION.args(\" function($a as xs:string) as item() { $a }\"));\n    query(func + \"/@name/data()\", \"\");\n    query(func + \"/@uri/data()\", \"\");\n    query(func + \"/argument/@name/data()\", \"\");\n    query(func + \"/argument/@type/data()\", \"xs:string\");\n    query(func + \"/return/@type/data()\", \"item()\");\n    query(func + \"/return/@occurrence/data()\", \"\");\n\n    func = query(\"declare %private function Q{U}f($v as xs:int) as xs:integer {$v};\" +\n        _INSPECT_FUNCTION.args(\" Q{U}f#1\"));\n    query(func + \"/@name/data()\", \"f\");\n    query(func + \"/@uri/data()\", \"U\");\n    query(func + \"/argument/@name/data()\", \"v\");\n    query(func + \"/argument/@type/data()\", \"xs:int\");\n    query(func + \"/annotation/@name/data()\", \"private\");\n    query(func + \"/annotation/@uri/data()\", \"http://www.w3.org/2012/xquery\");\n    query(func + \"/return/@type/data()\", \"xs:integer\");\n    query(func + \"/return/@occurrence/data()\", \"\");\n  }","id":83665,"modified_method":"/** Test method. */\n  @Test\n  public void function() {\n    String func = query(_INSPECT_FUNCTION.args(\" true#0\"));\n    query(func + \"/@name/data()\", \"true\");\n    query(func + \"/@uri/data()\", \"http://www.w3.org/2005/xpath-functions\");\n    query(func + \"/return/@type/data()\", \"xs:boolean\");\n    query(func + \"/return/@occurrence/data()\", \"\");\n\n    func = query(_INSPECT_FUNCTION.args(\" { }\"));\n    query(func + \"/@name/data()\", \"\");\n    query(func + \"/@uri/data()\", \"\");\n    query(func + \"/argument/@type/data()\", \"xs:anyAtomicType\");\n    query(func + \"/return/@type/data()\", \"item()\");\n    query(func + \"/return/@occurrence/data()\", \"*\");\n\n    func = query(_INSPECT_FUNCTION.args(\" function($a as xs:int) as xs:integer { $a + 1 }\"));\n    query(func + \"/@name/data()\", \"\");\n    query(func + \"/@uri/data()\", \"\");\n    query(func + \"/argument/@name/data()\", \"\");\n    query(func + \"/argument/@type/data()\", \"xs:int\");\n    query(func + \"/return/@type/data()\", \"xs:integer\");\n    query(func + \"/return/@occurrence/data()\", \"\");\n\n    func = query(\"declare %private function Q{U}f($v as xs:int) as xs:integer {$v};\" +\n        _INSPECT_FUNCTION.args(\" Q{U}f#1\"));\n    query(func + \"/@name/data()\", \"f\");\n    query(func + \"/@uri/data()\", \"U\");\n    query(func + \"/argument/@name/data()\", \"v\");\n    query(func + \"/argument/@type/data()\", \"xs:int\");\n    query(func + \"/annotation/@name/data()\", \"private\");\n    query(func + \"/annotation/@uri/data()\", \"http://www.w3.org/2012/xquery\");\n    query(func + \"/return/@type/data()\", \"xs:integer\");\n    query(func + \"/return/@occurrence/data()\", \"\");\n  }","commit_id":"258b37dcfbd554cda01a994c30fd46d45cadc487","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Dumps the argument's type and size and returns it unchanged.\n   * @param ctx query context\n   * @return the argument expression\n   */\n  private Expr type(final QueryContext ctx) {\n    FNInfo.dump(Util.inf(\"{ type: %, size: % }\", expr[0].type(), expr[0].size()),\n        token(expr[0].toString()), ctx);\n    return expr[0];\n  }","id":83666,"modified_method":"/**\n   * Dumps the argument's type and size and returns it unchanged.\n   * @param ctx query context\n   * @return the argument expression\n   */\n  private Expr type(final QueryContext ctx) {\n    FNInfo.dump(Util.inf(\"{ type: %, size: %, exprSize: % }\", expr[0].type(), expr[0].size(),\n        expr[0].exprSize()), token(expr[0].toString()), ctx);\n    return expr[0];\n  }","commit_id":"258b37dcfbd554cda01a994c30fd46d45cadc487","url":"https://github.com/BaseXdb/basex"},{"original_method":"/** Checks if statically unused functions are compiled at runtime. */\n  @Test\n  public void compStatUnusedTest() {\n    check(\"declare function local:foo() { abs(?) };\" +\n        \"function-lookup(xs:QName('local:foo'), 0)()(-42)\",\n        \"42\",\n        \"exists(//\" + Util.className(PartFunc.class) + ')'\n    );\n  }","id":83667,"modified_method":"/** Checks if statically unused functions are compiled at runtime. */\n  @Test\n  public void compStatUnusedTest() {\n    check(\"declare function local:foo() { abs(?) };\" +\n        \"function-lookup(xs:QName(('local:foo')[random:double() < 1]), 0)()(-42)\",\n        \"42\",\n        \"empty(//\" + Util.className(StaticFuncs.class) + \"/*)\"\n    );\n  }","commit_id":"258b37dcfbd554cda01a994c30fd46d45cadc487","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Expr optimize(final QueryContext ctx, final VarScope scp) throws QueryException {\n    type = FuncType.get(ann, args, ret).seqType();\n    size = 1;\n\n    final int fp = scope.enter(ctx);\n    try {\n      // inline all values in the closure\n      for(final Entry<Var, Value> e : staticBindings()) {\n        final Expr inlined = expr.inline(ctx, scope, e.getKey(), e.getValue());\n        if (inlined != null) expr = inlined;\n      }\n    } catch(final QueryException qe) {\n      expr = FNInfo.error(qe, ret != null ? ret : expr.type());\n    } finally {\n      scope.cleanUp(this);\n      scope.exit(ctx, fp);\n    }\n\n    // only evaluate if the closure is empty, so we don't lose variables\n    return scope.closure().isEmpty() ? preEval(ctx) : this;\n  }","id":83668,"modified_method":"@Override\n  public Expr optimize(final QueryContext ctx, final VarScope scp) throws QueryException {\n    final SeqType r = expr.type();\n    final SeqType retType = ret == null || r.instanceOf(ret) ? r : ret;\n    type = FuncType.get(ann, args, retType).seqType();\n    size = 1;\n\n    final int fp = scope.enter(ctx);\n    try {\n      // inline all values in the closure\n      for(final Entry<Var, Value> e : staticBindings()) {\n        final Expr inlined = expr.inline(ctx, scope, e.getKey(), e.getValue());\n        if (inlined != null) expr = inlined;\n      }\n    } catch(final QueryException qe) {\n      expr = FNInfo.error(qe, ret != null ? ret : expr.type());\n    } finally {\n      scope.cleanUp(this);\n      scope.exit(ctx, fp);\n    }\n\n    // only evaluate if the closure is empty, so we don't lose variables\n    return scope.closure().isEmpty() ? preEval(ctx) : this;\n  }","commit_id":"258b37dcfbd554cda01a994c30fd46d45cadc487","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public FuncItem item(final QueryContext ctx, final InputInfo ii) throws QueryException {\n    final FuncType ft = FuncType.get(ann, args, ret);\n    final boolean c = ft.type != null && !expr.type().instanceOf(ft.type);\n\n    // collect closure\n    final Map<Var, Value> clos = new HashMap<Var, Value>();\n    for(final Entry<Var, Expr> e : scope.closure().entrySet())\n      clos.put(e.getKey(), e.getValue().value(ctx));\n\n    return new FuncItem(args, expr, ft, clos, c, scope, sc);\n  }","id":83669,"modified_method":"@Override\n  public FuncItem item(final QueryContext ctx, final InputInfo ii) throws QueryException {\n    final FuncType ft = (FuncType) type().type;\n    final boolean c = ret != null && !expr.type().instanceOf(ret);\n\n    // collect closure\n    final Map<Var, Value> clos = new HashMap<Var, Value>();\n    for(final Entry<Var, Expr> e : scope.closure().entrySet())\n      clos.put(e.getKey(), e.getValue().value(ctx));\n\n    return new FuncItem(args, expr, ft, clos, c, scope, sc);\n  }","commit_id":"258b37dcfbd554cda01a994c30fd46d45cadc487","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Fills in all used scopes of the given one.\n   * @param curr current scope\n   * @return IDs of all directly reachable scopes\n   * @throws QueryException if a variable directly calls itself\n   */\n  private int[] neighbors(final Scope curr) throws QueryException {\n    final IntList adj = new IntList();\n    final boolean ok = curr.visit(new ASTVisitor() {\n      @Override\n      public boolean staticVar(final StaticVar var) {\n        return var != curr && neighbor(var);\n      }\n\n      @Override\n      public boolean funcCall(final StaticFuncCall call) {\n        return neighbor(call.func());\n      }\n\n      @Override\n      public boolean inlineFunc(final Scope sub) {\n        return sub.visit(this);\n      }\n\n      /**\n       * Adds a neighbor of the currently inspected scope.\n       * @param scp the neighbor\n       * @return {@code true} for convenience\n       */\n      private boolean neighbor(final Scope scp) {\n        final int old = id(scp), id = old == -1 ? add(scp) : old;\n        if(old == -1 || !adj.contains(id)) adj.add(id);\n        return true;\n      }\n    });\n    if(!ok) throw Err.VARUNDEF.get(((StaticScope) curr).info, curr);\n    return adj.toArray();\n  }","id":83670,"modified_method":"/**\n   * Fills in all used scopes of the given one.\n   * @param curr current scope\n   * @return IDs of all directly reachable scopes\n   * @throws QueryException if a variable directly calls itself\n   */\n  private int[] neighbors(final Scope curr) throws QueryException {\n    final IntList adj = new IntList();\n    final boolean ok = curr.visit(new ASTVisitor() {\n      @Override\n      public boolean staticVar(final StaticVar var) {\n        return var != curr && neighbor(var);\n      }\n\n      @Override\n      public boolean funcCall(final StaticFuncCall call) {\n        return neighbor(call.func());\n      }\n\n      @Override\n      public boolean inlineFunc(final Scope sub) {\n        return sub.visit(this);\n      }\n\n      @Override\n      public boolean funcItem(final FuncItem func) {\n        return neighbor(func);\n      }\n\n      /**\n       * Adds a neighbor of the currently inspected scope.\n       * @param scp the neighbor\n       * @return {@code true} for convenience\n       */\n      private boolean neighbor(final Scope scp) {\n        final int old = id(scp), id = old == -1 ? add(scp) : old;\n        if(old == -1 || !adj.contains(id)) adj.add(id);\n        return true;\n      }\n    });\n    if(!ok) throw Err.VARUNDEF.get(((StaticScope) curr).info, curr);\n    return adj.toArray();\n  }","commit_id":"258b37dcfbd554cda01a994c30fd46d45cadc487","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public String toString() {\n    final StringBuilder sb = new StringBuilder();\n    for(final FuncCache fc : funcs.values()) {\n      sb.append(fc.func.toString()).append(Text.NL);\n    }\n    return sb.toString();\n  }","id":83671,"modified_method":"@Override\n  public String toString() {\n    final StringBuilder sb = new StringBuilder();\n    for(final FuncCache fc : funcs.values()) {\n      if(fc.func != null && fc.func.compiled()) {\n        sb.append(fc.func.toString()).append(Text.NL);\n      }\n    }\n    return sb.toString();\n  }","commit_id":"258b37dcfbd554cda01a994c30fd46d45cadc487","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void plan(final FElem plan) {\n    if(!funcs.isEmpty()) addPlan(plan, planElem(), funcs());\n  }","id":83672,"modified_method":"@Override\n  public void plan(final FElem plan) {\n    if(!funcs.isEmpty()) {\n      final FElem el = planElem();\n      plan.add(el);\n      for(final StaticFunc f : funcs())\n        if(f != null && f.compiled()) f.plan(el);\n    }\n  }","commit_id":"258b37dcfbd554cda01a994c30fd46d45cadc487","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void plan(final FElem plan) {\n    final FElem el = planElem();\n    addPlan(plan, el, expr[expr.length - 1]);\n    for(int i = 0; i < expr.length - 1; i++) expr[i].plan(el);\n  }","id":83673,"modified_method":"@Override\n  public void plan(final FElem plan) {\n    addPlan(plan, planElem());\n    /* avoid recursive calls\n    final FElem el = planElem();\n    addPlan(plan, el, expr[expr.length - 1]);\n    for(int i = 0; i < expr.length - 1; i++) expr[i].plan(el);\n    */\n  }","commit_id":"2a5b872d8ad3f36e885cde67b8aebd2c4389eeb9","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void plan(final FElem plan) {\r\n    final FElem el = planElem();\r\n    addPlan(plan, el, expr);\r\n    for(int i = 0; i < args.length; ++i) {\r\n      el.add(planAttr(ARG + i, args[i].name.string()));\r\n    }\r\n  }","id":83674,"modified_method":"@Override\r\n  public void plan(final FElem plan) {\r\n    addPlan(plan, planElem());\r\n    /* avoid recursive calls\r\n    final FElem el = planElem();\r\n    addPlan(plan, el, expr);\r\n    for(int i = 0; i < args.length; ++i) {\r\n      el.add(planAttr(ARG + i, args[i].name.string()));\r\n    }\r\n    */\r\n  }","commit_id":"2a5b872d8ad3f36e885cde67b8aebd2c4389eeb9","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void plan(final FElem plan) {\n    final FElem el = planElem();\n    addPlan(plan, el, expr[expr.length - 1]);\n    for(int i = 0; i < expr.length - 1; i++) expr[i].plan(el);\n  }","id":83675,"modified_method":"@Override\n  public void plan(final FElem plan) {\n    addPlan(plan, planElem());\n    /* avoid recursive calls\n    final FElem el = planElem();\n    addPlan(plan, el, expr[expr.length - 1]);\n    for(int i = 0; i < expr.length - 1; i++) expr[i].plan(el);\n    */\n  }","commit_id":"ac81239e9f3fd99570c4e32e4690eedc591b2944","url":"https://github.com/BaseXdb/basex"},{"original_method":"private boolean parseReg(String regRecord, long orgId) {\n        Case currentCase = Case.getCurrentCase(); // get the most updated case\n        SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n\n        try {\n            File regfile = new File(regRecord);\n            FileInputStream fstream = new FileInputStream(regfile);\n            InputStreamReader fstreamReader = new InputStreamReader(fstream, \"UTF-8\");\n            BufferedReader input = new BufferedReader(fstreamReader);\n            //logger.log(Level.INFO, \"using encoding \" + fstreamReader.getEncoding());\n            String regString = new Scanner(input).useDelimiter(\"\\\\Z\").next();\n            regfile.delete();\n            String startdoc = \"<?xml version=\\\"1.0\\\"?><document>\";\n            String result = regString.replaceAll(\"----------------------------------------\", \"\");\n            result = result.replaceAll(\"\\\\n\", \"\");\n            result = result.replaceAll(\"\\\\r\", \"\");\n            result = result.replaceAll(\"'\", \"&apos;\");\n            result = result.replaceAll(\"&\", \"&amp;\");\n            String enddoc = \"<\/document>\";\n            String stringdoc = startdoc + result + enddoc;\n            SAXBuilder sb = new SAXBuilder();\n            Document document = sb.build(new StringReader(stringdoc));\n            Element root = document.getRootElement();\n            List<Element> types = root.getChildren();\n            Iterator<Element> iterator = types.iterator();\n            while (iterator.hasNext()) {\n                String etime = \"\";\n                String context = \"\";\n                Element tempnode = iterator.next();\n                // Element tempnode = types.get(i);\n                context = tempnode.getName();\n                Element timenode = tempnode.getChild(\"time\");\n                etime = timenode.getTextTrim();\n                Long time = null;\n                try {\n                    Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(etime).getTime();\n                    time = epochtime.longValue();\n                    String Tempdate = time.toString();\n                    time = Long.valueOf(Tempdate) / 1000;\n                } catch (ParseException e) {\n                    logger.log(Level.WARNING, \"RegRipper::Conversion on DateTime -> failed for: \" + etime);\n                }\n                Element artroot = tempnode.getChild(\"artifacts\");\n                List<Element> artlist = artroot.getChildren();\n                String winver = \"\";\n                String installdate = \"\";\n                if (artlist.isEmpty()) {\n                } else {\n                    Iterator<Element> aiterator = artlist.iterator();\n                    while (aiterator.hasNext()) {\n                        Element artnode = aiterator.next();\n                        String name = artnode.getAttributeValue(\"name\");\n                        String value = artnode.getTextTrim();\n                        Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n\n                        if (\"recentdocs\".equals(context)) {\n                            //               BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_RECENT_OBJECT);\n                            //               bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(), \"RecentActivity\", context, time));\n                            //               bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\", context, name));\n                            //               bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), \"RecentActivity\", context, value));\n                            //               bbart.addAttributes(bbattributes);\n                        } else if (\"usb\".equals(context)) {\n\n                            Long utime = null;\n                            try {\n\n                                utime = Long.parseLong(name);\n                                String Tempdate = utime.toString();\n                                utime = Long.valueOf(Tempdate);\n                                utime = utime;\n                            } catch (Exception e) {\n                                logger.log(Level.WARNING, \"RegRipper::Conversion on DateTime -> \", e);\n                            }\n\n                            BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n                                //TODO Revisit usage of deprecated constructor as per TSK-583\n                                //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", context, utime));\n                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\",  utime));\n                            String dev = artnode.getAttributeValue(\"dev\");\n                                //TODO Revisit usage of deprecated constructor as per TSK-583\n                                //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID(), \"RecentActivity\", context, dev));\n                                //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID(), \"RecentActivity\", context, value));\n                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID(), \"RecentActivity\", dev));\n                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID(), \"RecentActivity\", value));\n                            bbart.addAttributes(bbattributes);\n                        } else if (\"uninstall\".equals(context)) {\n                            Long ftime = null;\n                            try {\n                                Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(name).getTime();\n                                ftime = epochtime.longValue();\n                                ftime = ftime / 1000;\n                            } catch (ParseException e) {\n                                logger.log(Level.WARNING, \"RegRipper::Conversion on DateTime -> \", e);\n                            }\n                                //TODO Revisit usage of deprecated constructor as per TSK-583\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(), \"RecentActivity\", context, time));\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", context, value));\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", context, ftime));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID(), \"RecentActivity\", time));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", value));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", ftime));\n                            BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_INSTALLED_PROG);\n                            bbart.addAttributes(bbattributes);\n                        } else if (\"WinVersion\".equals(context)) {\n\n                            if (name.contains(\"ProductName\")) {\n                                winver = value;\n                            }\n                            if (name.contains(\"CSDVersion\")) {\n                                winver = winver + \" \" + value;\n                            }\n                            if (name.contains(\"InstallDate\")) {\n                                installdate = value;\n                                Long installtime = null;\n                                try {\n                                    Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(value).getTime();\n                                    installtime = epochtime.longValue();\n                                    String Tempdate = installtime.toString();\n                                    installtime = Long.valueOf(Tempdate) / 1000;\n                                } catch (ParseException e) {\n                                    logger.log(Level.WARNING, \"RegRipper::Conversion on DateTime -> \", e);\n                                }\n                                    //TODO Revisit usage of deprecated constructor as per TSK-583\n//                                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", context, winver));\n//                                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", context, installtime));\n                                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", winver));\n                                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", installtime));\n                                BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_INSTALLED_PROG);\n                                bbart.addAttributes(bbattributes);\n                            }\n                        } else if (\"office\".equals(context)) {\n\n                            BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_RECENT_OBJECT);\n                                //TODO Revisit usage of deprecated constructor as per TSK-583\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(), \"RecentActivity\", context, time));\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\", context, name));\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), \"RecentActivity\", context, value));\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", context, artnode.getName()));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID(), \"RecentActivity\", time));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\", name));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), \"RecentActivity\", value));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", artnode.getName()));\n                            bbart.addAttributes(bbattributes);\n\n                        } else {\n//                            BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(sysid);\n//                            bbart.addAttributes(bbattributes);\n                        }\n                    }\n                }\n            }\n        } catch (Exception ex) {\n\n            logger.log(Level.WARNING, \"Error while trying to read into a registry file.\" + ex);\n        }\n        return true;\n    }","id":83676,"modified_method":"private boolean parseReg(String regRecord, long orgId) {\n        Case currentCase = Case.getCurrentCase(); // get the most updated case\n        SleuthkitCase tempDb = currentCase.getSleuthkitCase();\n\n        try {\n            File regfile = new File(regRecord);\n            FileInputStream fstream = new FileInputStream(regfile);\n            //InputStreamReader fstreamReader = new InputStreamReader(fstream, \"UTF-8\");\n            //BufferedReader input = new BufferedReader(fstreamReader);\n            //logger.log(Level.INFO, \"using encoding \" + fstreamReader.getEncoding());\n            String regString = new Scanner(fstream, \"UTF-8\").useDelimiter(\"\\\\Z\").next();\n            regfile.delete();\n            String startdoc = \"<?xml version=\\\"1.0\\\"?><document>\";\n            String result = regString.replaceAll(\"----------------------------------------\", \"\");\n            result = result.replaceAll(\"\\\\n\", \"\");\n            result = result.replaceAll(\"\\\\r\", \"\");\n            result = result.replaceAll(\"'\", \"&apos;\");\n            result = result.replaceAll(\"&\", \"&amp;\");\n            String enddoc = \"<\/document>\";\n            String stringdoc = startdoc + result + enddoc;\n            \n            DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();   \n            Document doc = builder.parse(new InputSource(new StringReader(stringdoc)));\n            Element oroot = doc.getDocumentElement();\n            NodeList children = oroot.getChildNodes();\n            int len = children.getLength();\n            for(int i=0; i<len; i++) {\n                Element tempnode = (Element) children.item(i);\n                String context = tempnode.getNodeName();\n                \n                Element timenode = (Element) tempnode.getElementsByTagName(\"time\").item(0);\n                String etime = timenode.getTextContent();\n                Long time = null;\n                try {\n                    Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(etime).getTime();\n                    time = epochtime.longValue();\n                    String Tempdate = time.toString();\n                    time = Long.valueOf(Tempdate) / 1000;\n                } catch (ParseException e) {\n                    logger.log(Level.WARNING, \"RegRipper::Conversion on DateTime -> failed for: \" + etime);\n                }\n                \n                Element artroot = (Element) tempnode.getElementsByTagName(\"artifacts\").item(0);\n                NodeList myartlist = artroot.getChildNodes();\n                String winver = \"\";\n                String installdate = \"\";\n                for(int j=0; j<myartlist.getLength(); j++) {\n                    Node artchild = myartlist.item(j);\n                    // If it has attributes, then it is an Element (based off API)\n                    if(artchild.hasAttributes()) {\n                        Element artnode = (Element) artchild;\n                        String name = artnode.getAttribute(\"name\");\n                        String value = artnode.getTextContent().trim();\n                        Collection<BlackboardAttribute> bbattributes = new ArrayList<BlackboardAttribute>();\n                        \n                        if (\"recentdocs\".equals(context)) {\n                            //               BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_RECENT_OBJECT);\n                            //               bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(), \"RecentActivity\", context, time));\n                            //               bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\", context, name));\n                            //               bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), \"RecentActivity\", context, value));\n                            //               bbart.addAttributes(bbattributes);\n                        } else if (\"usb\".equals(context)) {\n\n                            Long utime = null;\n                            try {\n\n                                utime = Long.parseLong(name);\n                                String Tempdate = utime.toString();\n                                utime = Long.valueOf(Tempdate);\n                                utime = utime;\n                            } catch (Exception e) {\n                                logger.log(Level.WARNING, \"RegRipper::Conversion on DateTime -> \", e);\n                            }\n\n                            BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_DEVICE_ATTACHED);\n                                //TODO Revisit usage of deprecated constructor as per TSK-583\n                                //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", context, utime));\n                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\",  utime));\n                            String dev = artnode.getAttribute(\"dev\");\n                                //TODO Revisit usage of deprecated constructor as per TSK-583\n                                //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID(), \"RecentActivity\", context, dev));\n                                //bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID(), \"RecentActivity\", context, value));\n                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_MODEL.getTypeID(), \"RecentActivity\", dev));\n                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DEVICE_ID.getTypeID(), \"RecentActivity\", value));\n                            bbart.addAttributes(bbattributes);\n                        } else if (\"uninstall\".equals(context)) {\n                            Long ftime = null;\n                            try {\n                                Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(name).getTime();\n                                ftime = epochtime.longValue();\n                                ftime = ftime / 1000;\n                            } catch (ParseException e) {\n                                logger.log(Level.WARNING, \"RegRipper::Conversion on DateTime -> \", e);\n                            }\n                                //TODO Revisit usage of deprecated constructor as per TSK-583\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(), \"RecentActivity\", context, time));\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", context, value));\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", context, ftime));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID(), \"RecentActivity\", time));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", value));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", ftime));\n                            BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_INSTALLED_PROG);\n                            bbart.addAttributes(bbattributes);\n                        } else if (\"WinVersion\".equals(context)) {\n\n                            if (name.contains(\"ProductName\")) {\n                                winver = value;\n                            }\n                            if (name.contains(\"CSDVersion\")) {\n                                winver = winver + \" \" + value;\n                            }\n                            if (name.contains(\"InstallDate\")) {\n                                installdate = value;\n                                Long installtime = null;\n                                try {\n                                    Long epochtime = new SimpleDateFormat(\"EEE MMM d HH:mm:ss yyyy\").parse(value).getTime();\n                                    installtime = epochtime.longValue();\n                                    String Tempdate = installtime.toString();\n                                    installtime = Long.valueOf(Tempdate) / 1000;\n                                } catch (ParseException e) {\n                                    logger.log(Level.WARNING, \"RegRipper::Conversion on DateTime -> \", e);\n                                }\n                                    //TODO Revisit usage of deprecated constructor as per TSK-583\n//                                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", context, winver));\n//                                    bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", context, installtime));\n                                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", winver));\n                                     bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME.getTypeID(), \"RecentActivity\", installtime));\n                                BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_INSTALLED_PROG);\n                                bbart.addAttributes(bbattributes);\n                            }\n                        } else if (\"office\".equals(context)) {\n\n                            BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(ARTIFACT_TYPE.TSK_RECENT_OBJECT);\n                                //TODO Revisit usage of deprecated constructor as per TSK-583\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_LAST_ACCESSED.getTypeID(), \"RecentActivity\", context, time));\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\", context, name));\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), \"RecentActivity\", context, value));\n//                                bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", context, artnode.getName()));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_DATETIME_ACCESSED.getTypeID(), \"RecentActivity\", time));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_NAME.getTypeID(), \"RecentActivity\", name));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_VALUE.getTypeID(), \"RecentActivity\", value));\n                                 bbattributes.add(new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_PROG_NAME.getTypeID(), \"RecentActivity\", artnode.getNodeName()));\n                            bbart.addAttributes(bbattributes);\n\n                        } else {\n//                            BlackboardArtifact bbart = tempDb.getContentById(orgId).newArtifact(sysid);\n//                            bbart.addAttributes(bbattributes);\n                        }\n                    }\n                    \n                }\n            }\n        } catch (Exception ex) {\n\n            logger.log(Level.WARNING, \"Error while trying to read into a registry file.\" + ex);\n        }\n        return true;\n    }","commit_id":"ecd0c71a966864ece56d6ecff54800f82bff3b47","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    if (parameter(node, editorContext) != null) {\n      for(SNode param : parameter(node, editorContext)) {\n        AddNodeMacroParam_copySrcMacro_Intention intention = new AddNodeMacroParam_copySrcMacro_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","id":83677,"modified_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    List<SNode> paramList = parameter(node, editorContext);\n    if (paramList != null) {\n      for(SNode param : paramList) {\n        AddNodeMacroParam_copySrcMacro_Intention intention = new AddNodeMacroParam_copySrcMacro_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","commit_id":"fbdb0ec5af2d291091df594911b1af98cdb863d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    if (parameter(node, editorContext) != null) {\n      for(SNode param : parameter(node, editorContext)) {\n        AddNodeMacroParam_copySrclMacro_Intention intention = new AddNodeMacroParam_copySrclMacro_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","id":83678,"modified_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    List<SNode> paramList = parameter(node, editorContext);\n    if (paramList != null) {\n      for(SNode param : paramList) {\n        AddNodeMacroParam_copySrclMacro_Intention intention = new AddNodeMacroParam_copySrclMacro_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","commit_id":"fbdb0ec5af2d291091df594911b1af98cdb863d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    if (parameter(node, editorContext) != null) {\n      for(SNode param : parameter(node, editorContext)) {\n        AddNodeMacroParam_ifMacro_Intention intention = new AddNodeMacroParam_ifMacro_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","id":83679,"modified_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    List<SNode> paramList = parameter(node, editorContext);\n    if (paramList != null) {\n      for(SNode param : paramList) {\n        AddNodeMacroParam_ifMacro_Intention intention = new AddNodeMacroParam_ifMacro_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","commit_id":"fbdb0ec5af2d291091df594911b1af98cdb863d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    if (parameter(node, editorContext) != null) {\n      for(SNode param : parameter(node, editorContext)) {\n        AddNodeMacroParam_loopMacro_Intention intention = new AddNodeMacroParam_loopMacro_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","id":83680,"modified_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    List<SNode> paramList = parameter(node, editorContext);\n    if (paramList != null) {\n      for(SNode param : paramList) {\n        AddNodeMacroParam_loopMacro_Intention intention = new AddNodeMacroParam_loopMacro_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","commit_id":"fbdb0ec5af2d291091df594911b1af98cdb863d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    if (parameter(node, editorContext) != null) {\n      for(SNode param : parameter(node, editorContext)) {\n        AddPropertyMacroParam_property_Intention intention = new AddPropertyMacroParam_property_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","id":83681,"modified_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    List<SNode> paramList = parameter(node, editorContext);\n    if (paramList != null) {\n      for(SNode param : paramList) {\n        AddPropertyMacroParam_property_Intention intention = new AddPropertyMacroParam_property_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","commit_id":"fbdb0ec5af2d291091df594911b1af98cdb863d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    if (parameter(node, editorContext) != null) {\n      for(SNode param : parameter(node, editorContext)) {\n        AddReferenceMacroParam_link_Intention intention = new AddReferenceMacroParam_link_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","id":83682,"modified_method":"public static List<Intention> instances(final SNode node, final EditorContext editorContext) {\n    List<Intention> list = ListSequence.fromList(new ArrayList<Intention>());\n    List<SNode> paramList = parameter(node, editorContext);\n    if (paramList != null) {\n      for(SNode param : paramList) {\n        AddReferenceMacroParam_link_Intention intention = new AddReferenceMacroParam_link_Intention();\n        intention.myParameter = param;\n        ListSequence.fromList(list).addElement(intention);\n      }\n    }\n    return list;\n  }","commit_id":"fbdb0ec5af2d291091df594911b1af98cdb863d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode getContextNodeConcept_fast(SNode contextNode) {\n    SNode enclosingMacro = findOuterMacro(contextNode);\n    if ((enclosingMacro == null)) {\n      return QueriesUtil.getApplicableConcept_fromEnvironment(contextNode);\n    }\n    return null;\n  }","id":83683,"modified_method":"public static SNode getContextNodeConcept_fast(SNode contextNode) {\n    SNode enclosingMacro = findOuterMacro(contextNode);\n    if ((enclosingMacro == null)) {\n      return QueriesUtil.getApplicableConcept_fromEnvironment(contextNode);\n    }\n    if (SNodeOperations.isInstanceOf(enclosingMacro, \"jetbrains.mps.lang.generator.structure.SourceSubstituteMacro\")) {\n      return getConceptFrom(SNodeOperations.cast(enclosingMacro, \"jetbrains.mps.lang.generator.structure.SourceSubstituteMacro\"));\n    }\n    return null;\n  }","commit_id":"fbdb0ec5af2d291091df594911b1af98cdb863d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode getContextNodeConcept_slow(SNode contextNode) {\n    SNode enclosingMacro = findOuterMacro(contextNode);\n    if ((enclosingMacro == null)) {\n      return QueriesUtil.getApplicableConcept_fromEnvironment(contextNode);\n    }\n    if (SNodeOperations.isInstanceOf(enclosingMacro, \"jetbrains.mps.lang.generator.structure.SourceSubstituteMacro\")) {\n      SNode query = QueriesUtil.getQueryFunction_fromSourceSubstituteMacro(SNodeOperations.cast(enclosingMacro, \"jetbrains.mps.lang.generator.structure.SourceSubstituteMacro\"));\n      return getConceptFrom(TypeChecker.getInstance().getTypeOf(query));\n    }\n    return null;\n  }","id":83684,"modified_method":"public static SNode getContextNodeConcept_slow(SNode contextNode) {\n    SNode enclosingMacro = findOuterMacro(contextNode);\n    if ((enclosingMacro == null)) {\n      return QueriesUtil.getApplicableConcept_fromEnvironment(contextNode);\n    }\n    if (SNodeOperations.isInstanceOf(enclosingMacro, \"jetbrains.mps.lang.generator.structure.SourceSubstituteMacro\")) {\n      return getConceptFrom(SNodeOperations.cast(enclosingMacro, \"jetbrains.mps.lang.generator.structure.SourceSubstituteMacro\"));\n    }\n    return null;\n  }","commit_id":"fbdb0ec5af2d291091df594911b1af98cdb863d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static SNode getConceptFrom(SNode returnType) {\n    {\n      _Patterns.Pattern_0 pattern_0 = new _Patterns.Pattern_0();\n      SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(returnType, pattern_0);\n      if (coercedNode_0 != null) {\n        return pattern_0.PatternVar0;\n      } else\n      {\n        {\n          _Patterns.Pattern_1 pattern_1 = new _Patterns.Pattern_1();\n          SNode coercedNode_1 = TypeChecker.getInstance().getRuntimeSupport().coerce_(returnType, pattern_1);\n          if (coercedNode_1 != null) {\n            return pattern_1.PatternVar1;\n          } else\n          {\n            return null;\n          }\n        }\n      }\n    }\n  }","id":83685,"modified_method":"private static SNode getConceptFrom(SNode macro) {\n    SNode query = QueriesUtil.getQueryFunction_fromSourceSubstituteMacro(macro);\n    SNode returnType = TypeChecker.getInstance().getTypeOf(query);\n    // ======\n    if (SNodeOperations.isInstanceOf(query, \"jetbrains.mps.lang.generator.structure.SourceSubstituteMacro_SourceNodeQuery\")) {\n      {\n        _Patterns.Pattern_0 pattern_0 = new _Patterns.Pattern_0();\n        SNode coercedNode_0 = TypeChecker.getInstance().getRuntimeSupport().coerce_(returnType, pattern_0);\n        if (coercedNode_0 != null) {\n          return pattern_0.PatternVar0;\n        } else\n        {\n          return null;\n        }\n      }\n    } else if (SNodeOperations.isInstanceOf(query, \"jetbrains.mps.lang.generator.structure.SourceSubstituteMacro_SourceNodesQuery\")) {\n      {\n        _Patterns.Pattern_1 pattern_1 = new _Patterns.Pattern_1();\n        SNode coercedNode_1 = TypeChecker.getInstance().getRuntimeSupport().coerce_(returnType, pattern_1);\n        if (coercedNode_1 != null) {\n          return pattern_1.PatternVar1;\n        } else\n        {\n          return null;\n        }\n      }\n    } else\n    {\n      return null;\n    }\n  }","commit_id":"fbdb0ec5af2d291091df594911b1af98cdb863d5","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void close() throws IOException\n    {\n    }","id":83686,"modified_method":"public void close() throws IOException\n    {\n        // This is to make sure that reader index in the ChannelBuffer is left\n        // in the right place even if this reader wasn't completely read through.\n        readToTheEnd();\n    }","commit_id":"11be6070318c8d504b3e318fe480887871c94a96","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void makeSureNextTransactionIsFullyFetched( ChannelBuffer buffer )\n    {\n        buffer.markReaderIndex();\n        try\n        {\n            if ( buffer.readByte() > 0 /* datasource id */ )\n            {\n                buffer.skipBytes( 8 ); // tx id\n                int blockSize = 0;\n                while ( (blockSize = buffer.readUnsignedByte()) == 0 )\n                {\n                    buffer.skipBytes( BlockLogBuffer.DATA_SIZE );\n                }\n                buffer.skipBytes( blockSize );\n            }\n        }\n        finally\n        {\n            buffer.resetReaderIndex();\n        }\n    }","id":83687,"modified_method":"private static void makeSureNextTransactionIsFullyFetched( ChannelBuffer buffer )\n    {\n        buffer.markReaderIndex();\n        try\n        {\n            if ( buffer.readUnsignedByte() > 0 /* datasource id */ )\n            {\n                buffer.skipBytes( 8 ); // tx id\n                int blockSize = 0;\n                while ( (blockSize = buffer.readUnsignedByte()) == 0 )\n                {\n                    buffer.skipBytes( BlockLogBuffer.DATA_SIZE );\n                }\n                buffer.skipBytes( blockSize );\n            }\n        }\n        finally\n        {\n            buffer.resetReaderIndex();\n        }\n    }","commit_id":"11be6070318c8d504b3e318fe480887871c94a96","url":"https://github.com/neo4j/neo4j"},{"original_method":"public <T> T receive( Response<T> response )\n    {\n        try\n        {\n            XaDataSourceManager localDataSourceManager =\n                getConfig().getTxModule().getXaDataSourceManager();\n            for ( Triplet<String, Long, TxExtractor> tx : IteratorUtil.asIterable( response.transactions() ) )\n            {\n                String resourceName = tx.first();\n                XaDataSource dataSource = localDataSourceManager.getXaDataSource( resourceName );\n                dataSource.applyCommittedTransaction( tx.second(), tx.third().extract() );\n            }\n            updateTime();\n            return response.response();\n        }\n        catch ( IOException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw new RuntimeException( e );\n        }\n    }","id":83688,"modified_method":"public <T> T receive( Response<T> response )\n    {\n        try\n        {\n            XaDataSourceManager localDataSourceManager =\n                getConfig().getTxModule().getXaDataSourceManager();\n            for ( Triplet<String, Long, TxExtractor> tx : IteratorUtil.asIterable( response.transactions() ) )\n            {\n                String resourceName = tx.first();\n                XaDataSource dataSource = localDataSourceManager.getXaDataSource( resourceName );\n                ReadableByteChannel txStream = tx.third().extract();\n                try\n                {\n                    dataSource.applyCommittedTransaction( tx.second(), txStream );\n                }\n                finally\n                {\n                    txStream.close();\n                }\n            }\n            updateTime();\n            return response.response();\n        }\n        catch ( IOException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"11be6070318c8d504b3e318fe480887871c94a96","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void close() throws IOException\n    {\n    }","id":83689,"modified_method":"public void close() throws IOException\n    {\n        // This is to make sure that reader index in the ChannelBuffer is left\n        // in the right place even if this reader wasn't completely read through.\n        readToTheEnd();\n    }","commit_id":"e2687a3774109c1a6a467b5008389597214822ed","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void makeSureNextTransactionIsFullyFetched( ChannelBuffer buffer )\n    {\n        buffer.markReaderIndex();\n        try\n        {\n            if ( buffer.readByte() > 0 /* datasource id */ )\n            {\n                buffer.skipBytes( 8 ); // tx id\n                int blockSize = 0;\n                while ( (blockSize = buffer.readUnsignedByte()) == 0 )\n                {\n                    buffer.skipBytes( BlockLogBuffer.DATA_SIZE );\n                }\n                buffer.skipBytes( blockSize );\n            }\n        }\n        finally\n        {\n            buffer.resetReaderIndex();\n        }\n    }","id":83690,"modified_method":"private static void makeSureNextTransactionIsFullyFetched( ChannelBuffer buffer )\n    {\n        buffer.markReaderIndex();\n        try\n        {\n            if ( buffer.readUnsignedByte() > 0 /* datasource id */ )\n            {\n                buffer.skipBytes( 8 ); // tx id\n                int blockSize = 0;\n                while ( (blockSize = buffer.readUnsignedByte()) == 0 )\n                {\n                    buffer.skipBytes( BlockLogBuffer.DATA_SIZE );\n                }\n                buffer.skipBytes( blockSize );\n            }\n        }\n        finally\n        {\n            buffer.resetReaderIndex();\n        }\n    }","commit_id":"e2687a3774109c1a6a467b5008389597214822ed","url":"https://github.com/neo4j/neo4j"},{"original_method":"public <T> T receive( Response<T> response )\n    {\n        try\n        {\n            XaDataSourceManager localDataSourceManager =\n                getConfig().getTxModule().getXaDataSourceManager();\n            for ( Triplet<String, Long, TxExtractor> tx : IteratorUtil.asIterable( response.transactions() ) )\n            {\n                String resourceName = tx.first();\n                XaDataSource dataSource = localDataSourceManager.getXaDataSource( resourceName );\n                dataSource.applyCommittedTransaction( tx.second(), tx.third().extract() );\n            }\n            updateTime();\n            return response.response();\n        }\n        catch ( IOException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw new RuntimeException( e );\n        }\n    }","id":83691,"modified_method":"public <T> T receive( Response<T> response )\n    {\n        try\n        {\n            XaDataSourceManager localDataSourceManager =\n                getConfig().getTxModule().getXaDataSourceManager();\n            for ( Triplet<String, Long, TxExtractor> tx : IteratorUtil.asIterable( response.transactions() ) )\n            {\n                String resourceName = tx.first();\n                XaDataSource dataSource = localDataSourceManager.getXaDataSource( resourceName );\n                ReadableByteChannel txStream = tx.third().extract();\n                try\n                {\n                    dataSource.applyCommittedTransaction( tx.second(), txStream );\n                }\n                finally\n                {\n                    txStream.close();\n                }\n            }\n            updateTime();\n            return response.response();\n        }\n        catch ( IOException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"e2687a3774109c1a6a467b5008389597214822ed","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void close() throws IOException\n    {\n    }","id":83692,"modified_method":"public void close() throws IOException\n    {\n        // This is to make sure that reader index in the ChannelBuffer is left\n        // in the right place even if this reader wasn't completely read through.\n        readToTheEnd();\n    }","commit_id":"26bc7f46df8fd74e1ca9fd903be352e9b63171b6","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void makeSureNextTransactionIsFullyFetched( ChannelBuffer buffer )\n    {\n        buffer.markReaderIndex();\n        try\n        {\n            if ( buffer.readByte() > 0 /* datasource id */ )\n            {\n                buffer.skipBytes( 8 ); // tx id\n                int blockSize = 0;\n                while ( (blockSize = buffer.readUnsignedByte()) == 0 )\n                {\n                    buffer.skipBytes( BlockLogBuffer.DATA_SIZE );\n                }\n                buffer.skipBytes( blockSize );\n            }\n        }\n        finally\n        {\n            buffer.resetReaderIndex();\n        }\n    }","id":83693,"modified_method":"private static void makeSureNextTransactionIsFullyFetched( ChannelBuffer buffer )\n    {\n        buffer.markReaderIndex();\n        try\n        {\n            if ( buffer.readUnsignedByte() > 0 /* datasource id */ )\n            {\n                buffer.skipBytes( 8 ); // tx id\n                int blockSize = 0;\n                while ( (blockSize = buffer.readUnsignedByte()) == 0 )\n                {\n                    buffer.skipBytes( BlockLogBuffer.DATA_SIZE );\n                }\n                buffer.skipBytes( blockSize );\n            }\n        }\n        finally\n        {\n            buffer.resetReaderIndex();\n        }\n    }","commit_id":"26bc7f46df8fd74e1ca9fd903be352e9b63171b6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public <T> T receive( Response<T> response )\n    {\n        try\n        {\n            XaDataSourceManager localDataSourceManager =\n                getConfig().getTxModule().getXaDataSourceManager();\n            for ( Triplet<String, Long, TxExtractor> tx : IteratorUtil.asIterable( response.transactions() ) )\n            {\n                String resourceName = tx.first();\n                XaDataSource dataSource = localDataSourceManager.getXaDataSource( resourceName );\n                dataSource.applyCommittedTransaction( tx.second(), tx.third().extract() );\n            }\n            updateTime();\n            return response.response();\n        }\n        catch ( IOException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw new RuntimeException( e );\n        }\n    }","id":83694,"modified_method":"public <T> T receive( Response<T> response )\n    {\n        try\n        {\n            XaDataSourceManager localDataSourceManager =\n                getConfig().getTxModule().getXaDataSourceManager();\n            for ( Triplet<String, Long, TxExtractor> tx : IteratorUtil.asIterable( response.transactions() ) )\n            {\n                String resourceName = tx.first();\n                XaDataSource dataSource = localDataSourceManager.getXaDataSource( resourceName );\n                ReadableByteChannel txStream = tx.third().extract();\n                try\n                {\n                    dataSource.applyCommittedTransaction( tx.second(), txStream );\n                }\n                finally\n                {\n                    txStream.close();\n                }\n            }\n            updateTime();\n            return response.response();\n        }\n        catch ( IOException e )\n        {\n            newMaster( broker.getMaster(), e );\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"26bc7f46df8fd74e1ca9fd903be352e9b63171b6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public EditorContext_MigrationScript(IOperationContext operationContext) {\n    super(\"To Editor API usages\");\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Replacing jetbrains.mps.nodeEditor.EditorContext classifier type instances with jetbrains.mps.openapi.editor.EditorContext\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Replacing jetbrains.mps.nodeEditor.EditorContext classifier type instances with jetbrains.mps.openapi.editor.EditorContext\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassifierType\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SLinkOperations.setTarget(node, \"classifier\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext\"), false);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.EditorContext to jetbrains.mps.openapi.editor.EditorContext\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.EditorContext to jetbrains.mps.openapi.editor.EditorContext\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        // <node> \n        // <node> \n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getSelectedNode():jetbrains.mps.smodel.SNode\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode,boolean):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode,java.lang.String):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectBefore(jetbrains.mps.smodel.SNode):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectAfter(jetbrains.mps.smodel.SNode):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectAndSetCaret(jetbrains.mps.smodel.SNode,int):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getSelectedCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getContextCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getNodeEditorComponent():jetbrains.mps.nodeEditor.EditorComponent\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getEditorComponent():jetbrains.mps.openapi.editor.EditorComponent\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.executeCommand(java.lang.Runnable):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.executeCommand(jetbrains.mps.util.Computable):java.lang.Object\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.flushEvents():void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getScope():jetbrains.mps.smodel.IScope\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createNodeCell(jetbrains.mps.smodel.SNode):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createReferentCell(jetbrains.mps.smodel.SNode,jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createRoleAttributeCell(java.lang.Class,jetbrains.mps.openapi.editor.EditorCell,jetbrains.mps.smodel.SNode):jetbrains.mps.openapi.editor.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getOperationContext():jetbrains.mps.smodel.IOperationContext\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getInspector():jetbrains.mps.openapi.editor.EditorInspector\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.isInspector():boolean\")) {\n          return true;\n        }\n        return false;\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getSelectedNode():jetbrains.mps.smodel.SNode\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getSelectedNode():jetbrains.mps.smodel.SNode\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode,boolean):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode,boolean):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode,java.lang.String):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode,java.lang.String):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectBefore(jetbrains.mps.smodel.SNode):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.selectBefore(jetbrains.mps.smodel.SNode):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectAfter(jetbrains.mps.smodel.SNode):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.selectAfter(jetbrains.mps.smodel.SNode):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectAndSetCaret(jetbrains.mps.smodel.SNode,int):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.selectAndSetCaret(jetbrains.mps.smodel.SNode,int):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getSelectedCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getSelectedCell():jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getContextCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getContextCell():jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getNodeEditorComponent():jetbrains.mps.nodeEditor.EditorComponent\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getEditorComponent():jetbrains.mps.openapi.editor.EditorComponent\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getEditorComponent():jetbrains.mps.openapi.editor.EditorComponent\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getEditorComponent():jetbrains.mps.openapi.editor.EditorComponent\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.executeCommand(java.lang.Runnable):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.executeCommand(java.lang.Runnable):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.executeCommand(jetbrains.mps.util.Computable):java.lang.Object\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.executeCommand(java.lang.Runnable):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.flushEvents():void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.flushEvents():void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getScope():jetbrains.mps.smodel.IScope\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getScope():jetbrains.mps.smodel.IScope\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createNodeCell(jetbrains.mps.smodel.SNode):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.createNodeCell(jetbrains.mps.smodel.SNode):jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createReferentCell(jetbrains.mps.smodel.SNode,jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.createReferentCell(jetbrains.mps.smodel.SNode,jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createRoleAttributeCell(java.lang.Class,jetbrains.mps.openapi.editor.EditorCell,jetbrains.mps.smodel.SNode):jetbrains.mps.openapi.editor.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.createRoleAttributeCell(java.lang.Class,jetbrains.mps.openapi.editor.EditorCell,jetbrains.mps.smodel.SNode):jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getOperationContext():jetbrains.mps.smodel.IOperationContext\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getOperationContext():jetbrains.mps.smodel.IOperationContext\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getInspector():jetbrains.mps.openapi.editor.EditorInspector\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getInspector():jetbrains.mps.openapi.editor.EditorInspector\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.isInspector():boolean\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.isInspector():boolean\"), false);\n          return;\n        }\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    // whitespace \n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Replacing jetbrains.mps.nodeEditor.EditorComponent classifier type instances with jetbrains.mps.openapi.editor.EditorComponent\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Replacing jetbrains.mps.nodeEditor.EditorComponent classifier type instances with jetbrains.mps.openapi.editor.EditorComponent\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassifierType\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SLinkOperations.setTarget(node, \"classifier\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent\"), false);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.EditorComponent to jetbrains.mps.openapi.editor.EditorComponent\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.EditorComponent to jetbrains.mps.openapi.editor.EditorComponent\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        // <node> \n        // <node> \n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.selectNode(jetbrains.mps.smodel.SNode):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.getDeepestSelectedCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.getSelectedNodes():java.util.List\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.findCellWithId(jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.rebuildEditorContent():void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.isReadOnly():boolean\")) {\n          return true;\n        }\n        return false;\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.selectNode(jetbrains.mps.smodel.SNode):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.selectNode(jetbrains.mps.smodel.SNode):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.getDeepestSelectedCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.getDeepestSelectedCell():jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.getSelectedNodes():java.util.List\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.getSelectedNodes():java.util.List\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.findCellWithId(jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.findCellWithId(jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.rebuildEditorContent():void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.rebuildEditorContent():void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.isReadOnly():boolean\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.isReadOnly():boolean\"), false);\n          return;\n        }\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    // whitespace \n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Replacing jetbrains.mps.nodeEditor.cells.EditorCell classifier type instances with jetbrains.mps.openapi.editor.EditorCell\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Replacing jetbrains.mps.nodeEditor.cells.EditorCell classifier type instances with jetbrains.mps.openapi.editor.EditorCell\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassifierType\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SLinkOperations.setTarget(node, \"classifier\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorCell\"), false);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.cells.EditorCell to jetbrains.mps.openapi.editor.EditorCell\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.cells.EditorCell to jetbrains.mps.openapi.editor.EditorCell\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        // <node> \n        // <node> \n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.getCellId():java.lang.String\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.getSNode():jetbrains.mps.smodel.SNode\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.isSingleNodeCell():boolean\")) {\n          return true;\n        }\n        return false;\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.getCellId():java.lang.String\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorCell.getCellId():java.lang.String\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.getSNode():jetbrains.mps.smodel.SNode\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorCell.getSNode():jetbrains.mps.smodel.SNode\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.isSingleNodeCell():boolean\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorCell.isSingleNodeCell():boolean\"), false);\n          return;\n        }\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n  }","id":83695,"modified_method":"public EditorContext_MigrationScript(IOperationContext operationContext) {\n    super(\"To Editor API usages\");\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Replacing jetbrains.mps.nodeEditor.EditorContext classifier type instances with jetbrains.mps.openapi.editor.EditorContext\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Replacing jetbrains.mps.nodeEditor.EditorContext classifier type instances with jetbrains.mps.openapi.editor.EditorContext\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassifierType\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        return SLinkOperations.getTarget(node, \"classifier\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SLinkOperations.setTarget(node, \"classifier\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext\"), false);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Replacing ClassCreators usingjetbrains.mps.nodeEditor.EditorContextas a parameter withjetbrains.mps.openapi.editor.EditorContext\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Replacing ClassCreators usingjetbrains.mps.nodeEditor.EditorContextas a parameter withjetbrains.mps.openapi.editor.EditorContext\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassCreator\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        SReference reference = SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassCreator\", \"constructorDeclaration\"));\n        if (reference == null || reference.getTargetNodeSilently() != null) {\n          return false;\n        }\n        SNodeId targetNodeId = reference.getTargetNodeId();\n        if (targetNodeId == null) {\n          return false;\n        }\n        return targetNodeId.toString().contains(\"jetbrains.mps.nodeEditor.EditorContext\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SReference oldReference = SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassCreator\", \"constructorDeclaration\"));\n        SNodeId oldNodeId = oldReference.getTargetNodeId();\n        SNodeId newNodeId = SNodeId.fromString(oldNodeId.toString().replaceAll(\"jetbrains.mps.nodeEditor.EditorContext\", \"jetbrains.mps.openapi.editor.EditorContext\"));\n        SReference newReference = new StaticReference(oldReference.getRole(), node, oldReference.getTargetSModelReference(), newNodeId, oldReference.getResolveInfo());\n        node.setReference(\"constructorDeclaration\", newReference);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.EditorContext to jetbrains.mps.openapi.editor.EditorContext\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.EditorContext to jetbrains.mps.openapi.editor.EditorContext\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        // <node> \n        // <node> \n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getSelectedNode():jetbrains.mps.smodel.SNode\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode,boolean):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode,java.lang.String):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectBefore(jetbrains.mps.smodel.SNode):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectAfter(jetbrains.mps.smodel.SNode):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectAndSetCaret(jetbrains.mps.smodel.SNode,int):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getSelectedCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getContextCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getNodeEditorComponent():jetbrains.mps.nodeEditor.EditorComponent\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getEditorComponent():jetbrains.mps.openapi.editor.EditorComponent\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.executeCommand(java.lang.Runnable):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.executeCommand(jetbrains.mps.util.Computable):java.lang.Object\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.flushEvents():void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getScope():jetbrains.mps.smodel.IScope\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createNodeCell(jetbrains.mps.smodel.SNode):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createReferentCell(jetbrains.mps.smodel.SNode,jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createRoleAttributeCell(java.lang.Class,jetbrains.mps.openapi.editor.EditorCell,jetbrains.mps.smodel.SNode):jetbrains.mps.openapi.editor.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getOperationContext():jetbrains.mps.smodel.IOperationContext\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getInspector():jetbrains.mps.openapi.editor.EditorInspector\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.isInspector():boolean\")) {\n          return true;\n        }\n        return false;\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getSelectedNode():jetbrains.mps.smodel.SNode\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getSelectedNode():jetbrains.mps.smodel.SNode\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode,boolean):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.selectWRTFocusPolicy(jetbrains.mps.smodel.SNode,boolean):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode,java.lang.String):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.select(jetbrains.mps.smodel.SNode,java.lang.String):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectBefore(jetbrains.mps.smodel.SNode):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.selectBefore(jetbrains.mps.smodel.SNode):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectAfter(jetbrains.mps.smodel.SNode):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.selectAfter(jetbrains.mps.smodel.SNode):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.selectAndSetCaret(jetbrains.mps.smodel.SNode,int):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.selectAndSetCaret(jetbrains.mps.smodel.SNode,int):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getSelectedCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getSelectedCell():jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getContextCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getContextCell():jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getNodeEditorComponent():jetbrains.mps.nodeEditor.EditorComponent\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getEditorComponent():jetbrains.mps.openapi.editor.EditorComponent\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getEditorComponent():jetbrains.mps.openapi.editor.EditorComponent\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getEditorComponent():jetbrains.mps.openapi.editor.EditorComponent\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.executeCommand(java.lang.Runnable):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.executeCommand(java.lang.Runnable):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.executeCommand(jetbrains.mps.util.Computable):java.lang.Object\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.executeCommand(java.lang.Runnable):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.flushEvents():void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.flushEvents():void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getScope():jetbrains.mps.smodel.IScope\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getScope():jetbrains.mps.smodel.IScope\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createNodeCell(jetbrains.mps.smodel.SNode):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.createNodeCell(jetbrains.mps.smodel.SNode):jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createReferentCell(jetbrains.mps.smodel.SNode,jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.createReferentCell(jetbrains.mps.smodel.SNode,jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.createRoleAttributeCell(java.lang.Class,jetbrains.mps.openapi.editor.EditorCell,jetbrains.mps.smodel.SNode):jetbrains.mps.openapi.editor.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.createRoleAttributeCell(java.lang.Class,jetbrains.mps.openapi.editor.EditorCell,jetbrains.mps.smodel.SNode):jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getOperationContext():jetbrains.mps.smodel.IOperationContext\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getOperationContext():jetbrains.mps.smodel.IOperationContext\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.getInspector():jetbrains.mps.openapi.editor.EditorInspector\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.getInspector():jetbrains.mps.openapi.editor.EditorInspector\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorContext.isInspector():boolean\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorContext.isInspector():boolean\"), false);\n          return;\n        }\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    // whitespace \n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Replacing ClassCreators usingjetbrains.mps.nodeEditor.EditorComponentas a parameter withjetbrains.mps.openapi.editor.EditorComponent\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Replacing ClassCreators usingjetbrains.mps.nodeEditor.EditorComponentas a parameter withjetbrains.mps.openapi.editor.EditorComponent\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassCreator\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        SReference reference = SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassCreator\", \"constructorDeclaration\"));\n        if (reference == null || reference.getTargetNodeSilently() != null) {\n          return false;\n        }\n        SNodeId targetNodeId = reference.getTargetNodeId();\n        if (targetNodeId == null) {\n          return false;\n        }\n        return targetNodeId.toString().contains(\"jetbrains.mps.nodeEditor.EditorComponent\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SReference oldReference = SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassCreator\", \"constructorDeclaration\"));\n        SNodeId oldNodeId = oldReference.getTargetNodeId();\n        SNodeId newNodeId = SNodeId.fromString(oldNodeId.toString().replaceAll(\"jetbrains.mps.nodeEditor.EditorComponent\", \"jetbrains.mps.openapi.editor.EditorComponent\"));\n        SReference newReference = new StaticReference(oldReference.getRole(), node, oldReference.getTargetSModelReference(), newNodeId, oldReference.getResolveInfo());\n        node.setReference(\"constructorDeclaration\", newReference);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.EditorComponent to jetbrains.mps.openapi.editor.EditorComponent\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.EditorComponent to jetbrains.mps.openapi.editor.EditorComponent\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        // <node> \n        // <node> \n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.selectNode(jetbrains.mps.smodel.SNode):void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.getDeepestSelectedCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.getSelectedNodes():java.util.List\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.findCellWithId(jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.rebuildEditorContent():void\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.isReadOnly():boolean\")) {\n          return true;\n        }\n        return false;\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.selectNode(jetbrains.mps.smodel.SNode):void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.selectNode(jetbrains.mps.smodel.SNode):void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.getDeepestSelectedCell():jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.getDeepestSelectedCell():jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.getSelectedNodes():java.util.List\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.getSelectedNodes():java.util.List\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.findCellWithId(jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.nodeEditor.cells.EditorCell\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.findCellWithId(jetbrains.mps.smodel.SNode,java.lang.String):jetbrains.mps.openapi.editor.EditorCell\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.rebuildEditorContent():void\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.rebuildEditorContent():void\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor(MPS.Editor/jetbrains.mps.nodeEditor@java_stub)\", \"~EditorComponent.isReadOnly():boolean\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorComponent.isReadOnly():boolean\"), false);\n          return;\n        }\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    // whitespace \n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Replacing ClassCreators usingjetbrains.mps.nodeEditor.cells.EditorCellas a parameter withjetbrains.mps.openapi.editor.EditorCell\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Replacing ClassCreators usingjetbrains.mps.nodeEditor.cells.EditorCellas a parameter withjetbrains.mps.openapi.editor.EditorCell\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.ClassCreator\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        SReference reference = SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassCreator\", \"constructorDeclaration\"));\n        if (reference == null || reference.getTargetNodeSilently() != null) {\n          return false;\n        }\n        SNodeId targetNodeId = reference.getTargetNodeId();\n        if (targetNodeId == null) {\n          return false;\n        }\n        return targetNodeId.toString().contains(\"jetbrains.mps.nodeEditor.cells.EditorCell\");\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        SReference oldReference = SNodeOperations.getReference(node, SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.ClassCreator\", \"constructorDeclaration\"));\n        SNodeId oldNodeId = oldReference.getTargetNodeId();\n        SNodeId newNodeId = SNodeId.fromString(oldNodeId.toString().replaceAll(\"jetbrains.mps.nodeEditor.cells.EditorCell\", \"jetbrains.mps.openapi.editor.EditorCell\"));\n        SReference newReference = new StaticReference(oldReference.getRole(), node, oldReference.getTargetSModelReference(), newNodeId, oldReference.getResolveInfo());\n        node.setReference(\"constructorDeclaration\", newReference);\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n    this.addRefactoring(new AbstractMigrationRefactoring(operationContext) {\n      public String getName() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.cells.EditorCell to jetbrains.mps.openapi.editor.EditorCell\";\n      }\n\n      public String getAdditionalInfo() {\n        return \"Pull up methods from jetbrains.mps.nodeEditor.cells.EditorCell to jetbrains.mps.openapi.editor.EditorCell\";\n      }\n\n      public String getFqNameOfConceptToSearchInstances() {\n        return \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\";\n      }\n\n      public boolean isApplicableInstanceNode(SNode node) {\n        // <node> \n        // <node> \n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.getCellId():java.lang.String\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.getSNode():jetbrains.mps.smodel.SNode\")) {\n          return true;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.isSingleNodeCell():boolean\")) {\n          return true;\n        }\n        return false;\n      }\n\n      public void doUpdateInstanceNode(SNode node) {\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.getCellId():java.lang.String\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorCell.getCellId():java.lang.String\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.getSNode():jetbrains.mps.smodel.SNode\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorCell.getSNode():jetbrains.mps.smodel.SNode\"), false);\n          return;\n        }\n        if (SLinkOperations.getTarget(node, \"baseMethodDeclaration\", false) == SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.nodeEditor.cells(MPS.Editor/jetbrains.mps.nodeEditor.cells@java_stub)\", \"~EditorCell.isSingleNodeCell():boolean\")) {\n          SLinkOperations.setTarget(node, \"baseMethodDeclaration\", SNodeOperations.getNode(\"f:java_stub#1ed103c3-3aa6-49b7-9c21-6765ee11f224#jetbrains.mps.openapi.editor(MPS.Editor/jetbrains.mps.openapi.editor@java_stub)\", \"~EditorCell.isSingleNodeCell():boolean\"), false);\n          return;\n        }\n      }\n\n      public boolean isShowAsIntention() {\n        return false;\n      }\n    });\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_7cysuj_g0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"}\");\n    editorCell.setCellId(\"Constant_7cysuj_g0\");\n    BaseLanguageStyle_StyleSheet.getRightBrace(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83696,"modified_method":"private EditorCell createConstant_7cysuj_g0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"}\");\n    editorCell.setCellId(\"Constant_7cysuj_g0\");\n    BaseLanguageStyle_StyleSheet.getRightBrace(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_7cysuj_c0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"->\");\n    editorCell.setCellId(\"Constant_7cysuj_c0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83697,"modified_method":"private EditorCell createConstant_7cysuj_c0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"->\");\n    editorCell.setCellId(\"Constant_7cysuj_c0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_7cysuj_e0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"{\");\n    editorCell.setCellId(\"Constant_7cysuj_e0\");\n    BaseLanguageStyle_StyleSheet.getLeftBrace(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83698,"modified_method":"private EditorCell createConstant_7cysuj_e0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"{\");\n    editorCell.setCellId(\"Constant_7cysuj_e0\");\n    BaseLanguageStyle_StyleSheet.getLeftBrace(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_chq41h_a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"Factory static method: \");\n    editorCell.setCellId(\"Constant_chq41h_a0\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83699,"modified_method":"private EditorCell createConstant_chq41h_a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"Factory static method: \");\n    editorCell.setCellId(\"Constant_chq41h_a0\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_a1a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"show as intention\");\n    editorCell.setCellId(\"Constant_nl0fz6_a1a0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83700,"modified_method":"private EditorCell createConstant_nl0fz6_a1a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"show as intention\");\n    editorCell.setCellId(\"Constant_nl0fz6_a1a0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_b0a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_nl0fz6_b0a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83701,"modified_method":"private EditorCell createConstant_nl0fz6_b0a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_nl0fz6_b0a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_a0a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"description\");\n    editorCell.setCellId(\"Constant_nl0fz6_a0a0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83702,"modified_method":"private EditorCell createConstant_nl0fz6_a0a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"description\");\n    editorCell.setCellId(\"Constant_nl0fz6_a0a0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_b1a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_nl0fz6_b1a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83703,"modified_method":"private EditorCell createConstant_nl0fz6_b1a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_nl0fz6_b1a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_a4a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"do\");\n    editorCell.setCellId(\"Constant_nl0fz6_a4a0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83704,"modified_method":"private EditorCell createConstant_nl0fz6_a4a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"do\");\n    editorCell.setCellId(\"Constant_nl0fz6_a4a0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_a2a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"for each\");\n    editorCell.setCellId(\"Constant_nl0fz6_a2a0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83705,"modified_method":"private EditorCell createConstant_nl0fz6_a2a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"for each\");\n    editorCell.setCellId(\"Constant_nl0fz6_a2a0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_b4a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_nl0fz6_b4a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83706,"modified_method":"private EditorCell createConstant_nl0fz6_b4a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_nl0fz6_b4a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_b0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \";\");\n    editorCell.setCellId(\"Constant_nl0fz6_b0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.EDITABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83707,"modified_method":"private EditorCell createConstant_nl0fz6_b0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \";\");\n    editorCell.setCellId(\"Constant_nl0fz6_b0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.EDITABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_b3a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_nl0fz6_b3a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83708,"modified_method":"private EditorCell createConstant_nl0fz6_b3a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_nl0fz6_b3a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_b2a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_nl0fz6_b2a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83709,"modified_method":"private EditorCell createConstant_nl0fz6_b2a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \":\");\n    editorCell.setCellId(\"Constant_nl0fz6_b2a0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.TEXT_COLOR, MPSColors.DARK_BLUE);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nl0fz6_a3a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"where\");\n    editorCell.setCellId(\"Constant_nl0fz6_a3a0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83710,"modified_method":"private EditorCell createConstant_nl0fz6_a3a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"where\");\n    editorCell.setCellId(\"Constant_nl0fz6_a3a0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_th2ud5_d0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"updaters:\");\n    editorCell.setCellId(\"Constant_th2ud5_d0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83711,"modified_method":"private EditorCell createConstant_th2ud5_d0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"updaters:\");\n    editorCell.setCellId(\"Constant_th2ud5_d0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_th2ud5_a1a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"title:\");\n    editorCell.setCellId(\"Constant_th2ud5_a1a\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83712,"modified_method":"private EditorCell createConstant_th2ud5_a1a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"title:\");\n    editorCell.setCellId(\"Constant_th2ud5_a1a\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_th2ud5_b0a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"script\");\n    editorCell.setCellId(\"Constant_th2ud5_b0a\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83713,"modified_method":"private EditorCell createConstant_th2ud5_b0a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"script\");\n    editorCell.setCellId(\"Constant_th2ud5_b0a\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_th2ud5_c0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"\");\n    editorCell.setCellId(\"Constant_th2ud5_c0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83714,"modified_method":"private EditorCell createConstant_th2ud5_c0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"\");\n    editorCell.setCellId(\"Constant_th2ud5_c0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createIndentCell_th2ud5_a4a(EditorContext editorContext, SNode node) {\n    EditorCell_Indent result = new EditorCell_Indent((jetbrains.mps.nodeEditor.EditorContext) editorContext, node);\n    return result;\n  }","id":83715,"modified_method":"private EditorCell createIndentCell_th2ud5_a4a(EditorContext editorContext, SNode node) {\n    EditorCell_Indent result = new EditorCell_Indent(editorContext, node);\n    return result;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_th2ud5_a3a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"to\");\n    editorCell.setCellId(\"Constant_th2ud5_a3a0\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83716,"modified_method":"private EditorCell createConstant_th2ud5_a3a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"to\");\n    editorCell.setCellId(\"Constant_th2ud5_a3a0\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createRefCell_errt5h_b0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new RefCellCellProvider(node, editorContext);\n    provider.setRole(\"oldMethodDeclaration\");\n    provider.setNoTargetText(\"<no oldMethodDeclaration>\");\n    EditorCell editorCell;\n    provider.setAuxiliaryCellProvider(new PullUpMethod_Editor._Inline_errt5h_a1a());\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","id":83717,"modified_method":"private EditorCell createRefCell_errt5h_b0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new RefCellCellProvider(node, editorContext);\n    provider.setRole(\"oldMethodDeclaration\");\n    provider.setNoTargetText(\"\");\n    EditorCell editorCell;\n    provider.setAuxiliaryCellProvider(new PullUpMethod_Editor._Inline_errt5h_a1a());\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_errt5h_c0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"->\");\n    editorCell.setCellId(\"Constant_errt5h_c0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83718,"modified_method":"private EditorCell createConstant_errt5h_c0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"->\");\n    editorCell.setCellId(\"Constant_errt5h_c0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0a, conceptFqName)) {\n      case 0:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.CommentMigrationScriptPart\", \"jetbrains.mps.lang.script.structure.MigrationScriptPart\", false, new String[]{\"jetbrains.mps.lang.script.structure.MigrationScriptPart\"}, new String[]{\"text\"}, new String[]{});\n      case 1:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.ExtractInterfaceMigration\", \"jetbrains.mps.lang.script.structure.MigrationScriptPart\", false, new String[]{\"jetbrains.mps.lang.script.structure.MigrationScriptPart\"}, new String[]{}, new String[]{\"oldClassifier\", \"newClassifier\"});\n      case 2:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.FactoryMigrationScriptPart\", \"jetbrains.mps.lang.script.structure.MigrationScriptPart\", false, new String[]{\"jetbrains.mps.lang.script.structure.MigrationScriptPart\"}, new String[]{}, new String[]{});\n      case 3:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScript\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.baseLanguage.structure.IValidIdentifier\"}, new String[]{\"title\", \"migrationFromBuild\", \"category\", \"type\", \"toBuild\"}, new String[]{});\n      case 4:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScriptPart\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 5:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScriptPart_Instance\", \"jetbrains.mps.lang.script.structure.MigrationScriptPart\", false, new String[]{\"jetbrains.mps.lang.script.structure.MigrationScriptPart\"}, new String[]{\"description\", \"showAsIntention\"}, new String[]{\"affectedInstanceConcept\"});\n      case 6:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScriptPart_Instance_Predicate\", \"jetbrains.mps.baseLanguage.structure.ConceptFunction\", false, new String[]{\"jetbrains.mps.baseLanguage.structure.ConceptFunction\"}, new String[]{}, new String[]{});\n      case 7:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScriptPart_Instance_Updater\", \"jetbrains.mps.baseLanguage.structure.ConceptFunction\", false, new String[]{\"jetbrains.mps.baseLanguage.structure.ConceptFunction\"}, new String[]{}, new String[]{});\n      case 8:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScriptPart_node\", \"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter\", false, new String[]{\"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter\"}, new String[]{}, new String[]{});\n      case 9:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.PullUpMethod\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{\"oldMethodDeclaration\", \"newMethodDeclaration\"});\n      case 10:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.WhitespaceMigrationScriptPart\", \"jetbrains.mps.lang.script.structure.MigrationScriptPart\", false, new String[]{\"jetbrains.mps.lang.script.structure.MigrationScriptPart\"}, new String[]{}, new String[]{});\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","id":83719,"modified_method":"public ConceptDescriptor getDescriptor(String conceptFqName) {\n    switch (Arrays.binarySearch(stringSwitchCases_1htk8d_a0a0a, conceptFqName)) {\n      case 0:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.CommentMigrationScriptPart\", \"jetbrains.mps.lang.script.structure.MigrationScriptPart\", false, new String[]{\"jetbrains.mps.lang.script.structure.MigrationScriptPart\"}, new String[]{\"text\"}, new String[]{});\n      case 1:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.ExtractInterfaceMigration\", \"jetbrains.mps.lang.script.structure.MigrationScriptPart\", false, new String[]{\"jetbrains.mps.lang.script.structure.MigrationScriptPart\"}, new String[]{\"updateClassifierTypes\"}, new String[]{\"oldClassifier\", \"newClassifier\"});\n      case 2:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.FactoryMigrationScriptPart\", \"jetbrains.mps.lang.script.structure.MigrationScriptPart\", false, new String[]{\"jetbrains.mps.lang.script.structure.MigrationScriptPart\"}, new String[]{}, new String[]{});\n      case 3:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScript\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\", \"jetbrains.mps.baseLanguage.structure.IValidIdentifier\"}, new String[]{\"title\", \"migrationFromBuild\", \"category\", \"type\", \"toBuild\"}, new String[]{});\n      case 4:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScriptPart\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{});\n      case 5:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScriptPart_Instance\", \"jetbrains.mps.lang.script.structure.MigrationScriptPart\", false, new String[]{\"jetbrains.mps.lang.script.structure.MigrationScriptPart\"}, new String[]{\"description\", \"showAsIntention\"}, new String[]{\"affectedInstanceConcept\"});\n      case 6:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScriptPart_Instance_Predicate\", \"jetbrains.mps.baseLanguage.structure.ConceptFunction\", false, new String[]{\"jetbrains.mps.baseLanguage.structure.ConceptFunction\"}, new String[]{}, new String[]{});\n      case 7:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScriptPart_Instance_Updater\", \"jetbrains.mps.baseLanguage.structure.ConceptFunction\", false, new String[]{\"jetbrains.mps.baseLanguage.structure.ConceptFunction\"}, new String[]{}, new String[]{});\n      case 8:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.MigrationScriptPart_node\", \"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter\", false, new String[]{\"jetbrains.mps.baseLanguage.structure.ConceptFunctionParameter\"}, new String[]{}, new String[]{});\n      case 9:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.PullUpMethod\", \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{\"jetbrains.mps.lang.core.structure.BaseConcept\"}, new String[]{}, new String[]{\"oldMethodDeclaration\", \"newMethodDeclaration\"});\n      case 10:\n        return new CompiledConceptDescriptor(\"jetbrains.mps.lang.script.structure.WhitespaceMigrationScriptPart\", \"jetbrains.mps.lang.script.structure.MigrationScriptPart\", false, new String[]{\"jetbrains.mps.lang.script.structure.MigrationScriptPart\"}, new String[]{}, new String[]{});\n      default:\n        return StructureAspectInterpreted.getInstance().getDescriptor(conceptFqName);\n    }\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TypesystemDescriptor() {\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_MigrationScriptPart_node_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      NonTypesystemRule_Runtime nonTypesystemRule = new check_FactoryMigrationScriptPath_NonTypesystemRule();\n      this.myNonTypesystemRules.add(nonTypesystemRule);\n    }\n  }","id":83720,"modified_method":"public TypesystemDescriptor() {\n    {\n      InferenceRule_Runtime inferenceRule = new typeof_MigrationScriptPart_node_InferenceRule();\n      this.myInferenceRules.add(inferenceRule);\n    }\n    {\n      NonTypesystemRule_Runtime nonTypesystemRule = new check_FactoryMigrationScriptPath_NonTypesystemRule();\n      this.myNonTypesystemRules.add(nonTypesystemRule);\n    }\n    {\n      NonTypesystemRule_Runtime nonTypesystemRule = new check_PullUpMethod_NonTypesystemRule();\n      this.myNonTypesystemRules.add(nonTypesystemRule);\n    }\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_vwvhta_a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant((jetbrains.mps.nodeEditor.EditorContext) editorContext, node, \"\");\n    editorCell.setCellId(\"Constant_vwvhta_a\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.EDITABLE, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":83721,"modified_method":"private EditorCell createConstant_vwvhta_a(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"\");\n    editorCell.setCellId(\"Constant_vwvhta_a\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.EDITABLE, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"a197bce104969186a6edee0f15d1091fa3304db7","url":"https://github.com/JetBrains/MPS"},{"original_method":"private String _getCanonicalURL(Layout layout, ThemeDisplay themeDisplay)\n\t\tthrows PortalException, SystemException {\n\n\t\tString layoutFullURL = PortalUtil.getLayoutFullURL(\n\t\t\tlayout, themeDisplay, false);\n\n\t\treturn PortalUtil.getCanonicalURL(\n\t\t\tlayoutFullURL, themeDisplay, layout, true);\n\t}","id":83722,"modified_method":"private String _getCanonicalURL(Layout layout, ThemeDisplay themeDisplay)\n\t\tthrows PortalException, SystemException {\n\n\t\tString layoutFullURL = PortalUtil.getLayoutFullURL(\n\t\t\tlayout, themeDisplay, false);\n\n\t\tString relativeURL = PortalUtil.getCanonicalURL(\n\t\t\tlayoutFullURL, themeDisplay, layout, true);\n\n\t\tString portalURL = PortalUtil.getPortalURL(layout, themeDisplay);\n\n\t\trelativeURL = relativeURL.substring(portalURL.length());\n\n\t\treturn relativeURL;\n\t}","commit_id":"322f82b663a9e3653048069eda0764c42aadb886","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n        public SourceLocation transform(Closure<?> closure) {\n            RuleMetadata ruleMetadata = getRuleMetadata(closure);\n            URI uri = URI.create(ruleMetadata.absoluteScriptSourceLocation());\n            String scheme = uri.getScheme();\n            String description;\n\n            if (\"file\".equalsIgnoreCase(scheme)) {\n                description = relativeFilePathResolver.resolveAsRelativePath(ruleMetadata.absoluteScriptSourceLocation());\n            } else {\n                description = uri.toString();\n            }\n\n            return new SourceLocation(uri, description, ruleMetadata.lineNumber(), ruleMetadata.columnNumber());\n        }","id":83723,"modified_method":"@Override\n        public SourceLocation transform(TransformedClosure closure) {\n            SourceLocation sourceLocation = closure.sourceLocation();\n            URI uri = sourceLocation.getUri();\n            String scheme = uri.getScheme();\n            String description;\n\n            if (\"file\".equalsIgnoreCase(scheme)) {\n                description = relativeFilePathResolver.resolveAsRelativePath(uri);\n            } else {\n                description = uri.toString();\n            }\n\n            return new SourceLocation(uri, description, sourceLocation.getExpression(), sourceLocation.getLineNumber(), sourceLocation.getColumnNumber());\n        }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> DeferredModelAction toAction(final ModelPath subjectPath, final Class<T> subjectType, final Closure<?> closure) {\n        SourceLocation sourceLocation = ruleLocationExtractor.transform(closure);\n        final ModelRuleDescriptor descriptor = sourceLocation.asDescriptor(\"model.\" + subjectPath);\n\n        return new DeferredModelAction() {\n            @Override\n            public ModelRuleDescriptor getDescriptor() {\n                return descriptor;\n            }\n\n            @Override\n            public void execute(MutableModelNode node, ModelActionRole role) {\n                TransformedClosure transformedClosure = (TransformedClosure) closure;\n                final boolean supportsNestedRules = node.canBeViewedAs(ModelType.of(ManagedInstance.class));\n                InputReferences inputs = transformedClosure.inputReferences();\n                List<InputReference> inputReferences = supportsNestedRules ? inputs.getOwnReferences() : inputs.getAllReferences();\n                final Map<String, PotentialInput> inputValues = Maps.newLinkedHashMap();\n                List<ModelReference<?>> inputModelReferences = Lists.newArrayList();\n\n                for (InputReference inputReference : inputReferences) {\n                    String description = String.format(\"@ line %d\", inputReference.getLineNumber());\n                    String path = inputReference.getPath();\n                    if (!inputValues.containsKey(path)) {\n                        inputValues.put(path, new PotentialInput(inputModelReferences.size()));\n                        inputModelReferences.add(ModelReference.untyped(ModelPath.path(path), description));\n                    }\n                }\n\n                node.applyToSelf(role, InputUsingModelAction.of(ModelReference.of(subjectPath, subjectType), descriptor, inputModelReferences, new BiAction<T, List<ModelView<?>>>() {\n                    @Override\n                    public void execute(T t, List<ModelView<?>> modelViews) {\n                        Closure<?> cloned = closure.rehydrate(null, closure.getThisObject(), closure.getThisObject());\n                        ((TransformedClosure) cloned).makeRule(new PotentialInputs(modelViews, inputValues), supportsNestedRules);\n                        ClosureBackedAction.execute(t, cloned);\n                    }\n                }));\n\n            }\n        };\n    }","id":83724,"modified_method":"public <T> DeferredModelAction toAction(final Class<T> subjectType, final Closure<?> closure) {\n        final TransformedClosure transformedClosure = (TransformedClosure) closure;\n        SourceLocation sourceLocation = ruleLocationExtractor.transform(transformedClosure);\n        final ModelRuleDescriptor descriptor = sourceLocation.asDescriptor();\n\n        return new DeferredModelAction() {\n            @Override\n            public ModelRuleDescriptor getDescriptor() {\n                return descriptor;\n            }\n\n            @Override\n            public void execute(MutableModelNode node, ModelActionRole role) {\n                final boolean supportsNestedRules = node.canBeViewedAs(ModelType.of(ManagedInstance.class));\n                InputReferences inputs = transformedClosure.inputReferences();\n                List<InputReference> inputReferences = supportsNestedRules ? inputs.getOwnReferences() : inputs.getAllReferences();\n                final Map<String, PotentialInput> inputValues = Maps.newLinkedHashMap();\n                List<ModelReference<?>> inputModelReferences = Lists.newArrayList();\n\n                for (InputReference inputReference : inputReferences) {\n                    String description = String.format(\"@ line %d\", inputReference.getLineNumber());\n                    String path = inputReference.getPath();\n                    if (!inputValues.containsKey(path)) {\n                        inputValues.put(path, new PotentialInput(inputModelReferences.size()));\n                        inputModelReferences.add(ModelReference.untyped(ModelPath.path(path), description));\n                    }\n                }\n\n                node.applyToSelf(role, InputUsingModelAction.of(ModelReference.of(node.getPath(), subjectType), descriptor, inputModelReferences, new BiAction<T, List<ModelView<?>>>() {\n                    @Override\n                    public void execute(T t, List<ModelView<?>> modelViews) {\n                        // Make a copy of the closure, attach inputs and execute\n                        Closure<?> cloned = closure.rehydrate(null, closure.getThisObject(), closure.getThisObject());\n                        ((TransformedClosure) cloned).makeRule(new PotentialInputs(modelViews, inputValues), supportsNestedRules);\n                        ClosureBackedAction.execute(t, cloned);\n                    }\n                }));\n            }\n        };\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void call(SourceUnit source) throws CompilationFailedException {\n        List<Statement> statements = source.getAST().getStatementBlock().getStatements();\n        for (Statement statement : statements) {\n            ScriptBlock scriptBlock = AstUtils.detectScriptBlock(statement, SCRIPT_BLOCK_NAMES);\n            if (scriptBlock == null) {\n                // Look for model(«») (i.e. call to model with anything other than non literal closure)\n                MethodCallExpression methodCall = AstUtils.extractBareMethodCall(statement);\n                if (methodCall == null) {\n                    continue;\n                }\n\n                String methodName = AstUtils.extractConstantMethodName(methodCall);\n                if (methodName == null) {\n                    continue;\n                }\n\n                if (methodName.equals(MODEL)) {\n                    source.getErrorCollector().addError(\n                            new SyntaxException(NON_LITERAL_CLOSURE_TO_TOP_LEVEL_MODEL_MESSAGE, statement.getLineNumber(), statement.getColumnNumber()),\n                            source\n                    );\n                }\n            } else {\n                RuleVisitor ruleVisitor = new RuleVisitor(source, scriptSourceDescription, location);\n                RulesVisitor rulesVisitor = new RulesVisitor(source, ruleVisitor, scriptSourceDescription, location);\n                scriptBlock.getClosureExpression().getCode().visit(rulesVisitor);\n            }\n        }\n    }","id":83725,"modified_method":"@Override\n    public void call(SourceUnit source) throws CompilationFailedException {\n        List<Statement> statements = source.getAST().getStatementBlock().getStatements();\n        for (Statement statement : statements) {\n            ScriptBlock scriptBlock = AstUtils.detectScriptBlock(statement, SCRIPT_BLOCK_NAMES);\n            if (scriptBlock == null) {\n                // Look for model(«») (i.e. call to model with anything other than non literal closure)\n                MethodCallExpression methodCall = AstUtils.extractBareMethodCall(statement);\n                if (methodCall == null) {\n                    continue;\n                }\n\n                String methodName = AstUtils.extractConstantMethodName(methodCall);\n                if (methodName == null) {\n                    continue;\n                }\n\n                if (methodName.equals(MODEL)) {\n                    source.getErrorCollector().addError(\n                            new SyntaxException(NON_LITERAL_CLOSURE_TO_TOP_LEVEL_MODEL_MESSAGE, statement.getLineNumber(), statement.getColumnNumber()),\n                            source\n                    );\n                }\n            } else {\n                RuleVisitor ruleVisitor = new RuleVisitor(source, scriptSourceDescription, location);\n                RulesVisitor rulesVisitor = new RulesVisitor(source, ruleVisitor);\n                scriptBlock.getClosureExpression().getCode().visit(rulesVisitor);\n            }\n        }\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"public static void visitGeneratedClosure(ClassNode node) {\n        MethodNode closureCallMethod = AstUtils.getGeneratedClosureImplMethod(node);\n        Statement closureCode = closureCallMethod.getCode();\n        SourceLocation sourceLocation = closureCode.getNodeMetaData(AST_NODE_METADATA_LOCATION_KEY);\n        if (sourceLocation != null) {\n            AnnotationNode metadataAnnotation = new AnnotationNode(RULE_METADATA);\n\n            metadataAnnotation.addMember(\"absoluteScriptSourceLocation\", new ConstantExpression(sourceLocation.getUri().toString()));\n            metadataAnnotation.addMember(\"lineNumber\", new ConstantExpression(sourceLocation.getLineNumber()));\n            metadataAnnotation.addMember(\"columnNumber\", new ConstantExpression(sourceLocation.getColumnNumber()));\n\n            InputReferences inputs = closureCode.getNodeMetaData(AST_NODE_METADATA_INPUTS_KEY);\n\n            node.addAnnotation(metadataAnnotation);\n\n            node.addInterface(TRANSFORMED_CLOSURE);\n            node.addField(new FieldNode(INPUTS_FIELD_NAME, Modifier.PUBLIC, POTENTIAL_INPUTS, node, null));\n\n            // Generate makeRule() method\n            List<Statement> statements = new ArrayList<Statement>();\n            statements.add(new ExpressionStatement(new BinaryExpression(new VariableExpression(INPUTS_FIELD_NAME), ASSIGN, new VariableExpression(\"inputs\"))));\n            node.addMethod(new MethodNode(\"makeRule\",\n                    Modifier.PUBLIC,\n                    ClassHelper.VOID_TYPE,\n                    new Parameter[]{new Parameter(POTENTIAL_INPUTS, \"inputs\"), new Parameter(ClassHelper.boolean_TYPE, \"enabledNestedRules\")},\n                    new ClassNode[0],\n                    new BlockStatement(statements, new VariableScope())));\n\n            // Generate inputReferences() method\n            VariableExpression inputsVar = new VariableExpression(\"inputs\", INPUT_REFERENCES);\n            VariableScope methodVarScope = new VariableScope();\n            methodVarScope.putDeclaredVariable(inputsVar);\n            statements = new ArrayList<Statement>();\n            statements.add(new ExpressionStatement(new DeclarationExpression(inputsVar, ASSIGN, new ConstructorCallExpression(INPUT_REFERENCES, new ArgumentListExpression()))));\n            for (InputReference inputReference : inputs.getOwnReferences()) {\n                statements.add(new ExpressionStatement(new MethodCallExpression(inputsVar,\n                        \"ownReference\",\n                        new ArgumentListExpression(\n                                new ConstantExpression(inputReference.getPath()),\n                                new ConstantExpression(inputReference.getLineNumber())))));\n            }\n            for (InputReference inputReference : inputs.getNestedReferences()) {\n                statements.add(new ExpressionStatement(new MethodCallExpression(inputsVar,\n                        \"nestedReference\",\n                        new ArgumentListExpression(\n                                new ConstantExpression(inputReference.getPath()),\n                                new ConstantExpression(inputReference.getLineNumber())))));\n            }\n            statements.add(new ReturnStatement(inputsVar));\n            node.addMethod(new MethodNode(\"inputReferences\",\n                                Modifier.PUBLIC,\n                                INPUT_REFERENCES,\n                                new Parameter[0],\n                                new ClassNode[0],\n                                new BlockStatement(statements, methodVarScope)));\n        }\n    }","id":83726,"modified_method":"public static void visitGeneratedClosure(ClassNode node) {\n        MethodNode closureCallMethod = AstUtils.getGeneratedClosureImplMethod(node);\n        Statement closureCode = closureCallMethod.getCode();\n        InputReferences inputs = closureCode.getNodeMetaData(AST_NODE_METADATA_INPUTS_KEY);\n        if (inputs != null) {\n            SourceLocation sourceLocation = closureCode.getNodeMetaData(AST_NODE_METADATA_LOCATION_KEY);\n\n            node.addInterface(TRANSFORMED_CLOSURE);\n            node.addField(new FieldNode(INPUTS_FIELD_NAME, Modifier.PUBLIC, POTENTIAL_INPUTS, node, null));\n\n            // Generate makeRule() method\n            List<Statement> statements = new ArrayList<Statement>();\n            statements.add(new ExpressionStatement(new BinaryExpression(new VariableExpression(INPUTS_FIELD_NAME), ASSIGN, new VariableExpression(\"inputs\"))));\n            node.addMethod(new MethodNode(\"makeRule\",\n                    Modifier.PUBLIC,\n                    ClassHelper.VOID_TYPE,\n                    new Parameter[]{new Parameter(POTENTIAL_INPUTS, \"inputs\"), new Parameter(ClassHelper.boolean_TYPE, \"enabledNestedRules\")},\n                    new ClassNode[0],\n                    new BlockStatement(statements, new VariableScope())));\n\n            // Generate inputReferences() method\n            VariableExpression inputsVar = new VariableExpression(\"inputs\", INPUT_REFERENCES);\n            VariableScope methodVarScope = new VariableScope();\n            methodVarScope.putDeclaredVariable(inputsVar);\n            statements = new ArrayList<Statement>();\n            statements.add(new ExpressionStatement(new DeclarationExpression(inputsVar, ASSIGN, new ConstructorCallExpression(INPUT_REFERENCES, new ArgumentListExpression()))));\n            for (InputReference inputReference : inputs.getOwnReferences()) {\n                statements.add(new ExpressionStatement(new MethodCallExpression(inputsVar,\n                        \"ownReference\",\n                        new ArgumentListExpression(\n                                new ConstantExpression(inputReference.getPath()),\n                                new ConstantExpression(inputReference.getLineNumber())))));\n            }\n            for (InputReference inputReference : inputs.getNestedReferences()) {\n                statements.add(new ExpressionStatement(new MethodCallExpression(inputsVar,\n                        \"nestedReference\",\n                        new ArgumentListExpression(\n                                new ConstantExpression(inputReference.getPath()),\n                                new ConstantExpression(inputReference.getLineNumber())))));\n            }\n            statements.add(new ReturnStatement(inputsVar));\n            node.addMethod(new MethodNode(\"inputReferences\",\n                                Modifier.PUBLIC,\n                                INPUT_REFERENCES,\n                                new Parameter[0],\n                                new ClassNode[0],\n                                new BlockStatement(statements, methodVarScope)));\n\n            // Generate sourceLocation() method\n            statements = new ArrayList<Statement>();\n            statements.add(new ReturnStatement(new ConstructorCallExpression(SOURCE_LOCATION,\n                    new ArgumentListExpression(Arrays.<Expression>asList(\n                            new ConstantExpression(sourceLocation.getUri().toString()),\n                            new ConstantExpression(sourceLocation.toString()),\n                            new ConstantExpression(sourceLocation.getExpression()),\n                            new ConstantExpression(sourceLocation.getLineNumber()),\n                            new ConstantExpression(sourceLocation.getColumnNumber())\n                    )))));\n            node.addMethod(new MethodNode(\"sourceLocation\",\n                                Modifier.PUBLIC,\n                                SOURCE_LOCATION,\n                                new Parameter[0],\n                                new ClassNode[0],\n                                new BlockStatement(statements, new VariableScope())));\n        }\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void visitExpressionStatement(ExpressionStatement stat) {\n        if (stat.getExpression() instanceof MethodCallExpression) {\n            MethodCallExpression call = (MethodCallExpression) stat.getExpression();\n            if (call.isImplicitThis()) {\n                ArgumentListExpression arguments = (ArgumentListExpression) call.getArguments();\n                if (!arguments.getExpressions().isEmpty()) {\n                    Expression lastArg = arguments.getExpression(arguments.getExpressions().size() - 1);\n                    if (lastArg instanceof ClosureExpression) {\n                        // TODO - other args need to be visited\n                        visitRuleClosure((ClosureExpression) lastArg, new SourceLocation(location, scriptSourceDescription, call.getLineNumber(), call.getColumnNumber()));\n                        return;\n                    }\n                }\n            }\n        }\n        super.visitExpressionStatement(stat);\n    }","id":83727,"modified_method":"@Override\n    public void visitExpressionStatement(ExpressionStatement stat) {\n        if (stat.getExpression() instanceof MethodCallExpression) {\n            MethodCallExpression call = (MethodCallExpression) stat.getExpression();\n            if (call.isImplicitThis() && call.getArguments() instanceof ArgumentListExpression) {\n                ArgumentListExpression arguments = (ArgumentListExpression) call.getArguments();\n                if (!arguments.getExpressions().isEmpty()) {\n                    Expression lastArg = arguments.getExpression(arguments.getExpressions().size() - 1);\n                    if (lastArg instanceof ClosureExpression) {\n                        // TODO - other args need to be visited\n                        visitRuleClosure((ClosureExpression) lastArg, call, call.getText());\n                        return;\n                    }\n                }\n            }\n        }\n        super.visitExpressionStatement(stat);\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"public void visitRuleClosure(ClosureExpression expression, SourceLocation sourceLocation) {\n        InputReferences parentInputs = inputs;\n        VariableExpression parentInputsVariable = inputsVariable;\n        try {\n            inputs = new InputReferences();\n            inputsVariable = new VariableExpression(\"__rule_inputs_var_\" + (counter++), POTENTIAL_INPUTS);\n            inputsVariable.setClosureSharedVariable(true);\n            super.visitClosureExpression(expression);\n            BlockStatement code = (BlockStatement) expression.getCode();\n            code.setNodeMetaData(AST_NODE_METADATA_LOCATION_KEY, sourceLocation);\n            code.setNodeMetaData(AST_NODE_METADATA_INPUTS_KEY, inputs);\n            if (parentInputsVariable != null) {\n                expression.getVariableScope().putReferencedLocalVariable(parentInputsVariable);\n            }\n            code.getVariableScope().putDeclaredVariable(inputsVariable);\n\n            if (parentInputsVariable == null) {\n                // <inputs-lvar> = <inputs-field>\n                DeclarationExpression variableDeclaration = new DeclarationExpression(inputsVariable, ASSIGN, new VariableExpression(INPUTS_FIELD_NAME));\n                code.getStatements().add(0, new ExpressionStatement(variableDeclaration));\n\n            } else {\n                // <inputs-lvar> = <inputs-field> ?: <parent-inputs-lvar>\n                DeclarationExpression variableDeclaration = new DeclarationExpression(inputsVariable, ASSIGN,\n                        new ElvisOperatorExpression(\n                                new VariableExpression(INPUTS_FIELD_NAME),\n                                parentInputsVariable));\n                code.getStatements().add(0, new ExpressionStatement(variableDeclaration));\n            }\n\n            // Move default values into body of closure, so they can use <inputs-lvar>\n            for (Parameter parameter : expression.getParameters()) {\n                if (parameter.hasInitialExpression()) {\n                    code.getStatements().add(1, new ExpressionStatement(new BinaryExpression(new VariableExpression(parameter.getName()), ASSIGN, parameter.getInitialExpression())));\n                    parameter.setInitialExpression(ConstantExpression.NULL);\n                }\n            }\n        } finally {\n            if (parentInputs != null) {\n                parentInputs.addNestedReferences(inputs);\n            }\n            inputs = parentInputs;\n            inputsVariable = parentInputsVariable;\n        }\n    }","id":83728,"modified_method":"public void visitRuleClosure(ClosureExpression expression, Expression invocation, String invocationDisplayName) {\n        InputReferences parentInputs = inputs;\n        VariableExpression parentInputsVariable = inputsVariable;\n        try {\n            inputs = new InputReferences();\n            inputsVariable = new VariableExpression(\"__rule_inputs_var_\" + (counter++), POTENTIAL_INPUTS);\n            inputsVariable.setClosureSharedVariable(true);\n            super.visitClosureExpression(expression);\n            BlockStatement code = (BlockStatement) expression.getCode();\n            code.setNodeMetaData(AST_NODE_METADATA_LOCATION_KEY, new SourceLocation(location, scriptSourceDescription, invocationDisplayName, invocation.getLineNumber(), invocation.getColumnNumber()));\n            code.setNodeMetaData(AST_NODE_METADATA_INPUTS_KEY, inputs);\n            if (parentInputsVariable != null) {\n                expression.getVariableScope().putReferencedLocalVariable(parentInputsVariable);\n            }\n            code.getVariableScope().putDeclaredVariable(inputsVariable);\n\n            if (parentInputsVariable == null) {\n                // <inputs-lvar> = <inputs-field>\n                DeclarationExpression variableDeclaration = new DeclarationExpression(inputsVariable, ASSIGN, new VariableExpression(INPUTS_FIELD_NAME));\n                code.getStatements().add(0, new ExpressionStatement(variableDeclaration));\n\n            } else {\n                // <inputs-lvar> = <inputs-field> ?: <parent-inputs-lvar>\n                DeclarationExpression variableDeclaration = new DeclarationExpression(inputsVariable, ASSIGN,\n                        new ElvisOperatorExpression(\n                                new VariableExpression(INPUTS_FIELD_NAME),\n                                parentInputsVariable));\n                code.getStatements().add(0, new ExpressionStatement(variableDeclaration));\n            }\n\n            // Move default values into body of closure, so they can use <inputs-lvar>\n            for (Parameter parameter : expression.getParameters()) {\n                if (parameter.hasInitialExpression()) {\n                    code.getStatements().add(1, new ExpressionStatement(new BinaryExpression(new VariableExpression(parameter.getName()), ASSIGN, parameter.getInitialExpression())));\n                    parameter.setInitialExpression(ConstantExpression.NULL);\n                }\n            }\n        } finally {\n            if (parentInputs != null) {\n                parentInputs.addNestedReferences(inputs);\n            }\n            inputs = parentInputs;\n            inputsVariable = parentInputsVariable;\n        }\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"public void rewriteAction(MethodCallExpression call, String modelPath, ClosureExpression closureExpression) {\n        // Rewrite the method call to match TransformedModelDslBacking#configure(String, Closure), which is what the delegate will be\n        ConstantExpression modelPathArgument = new ConstantExpression(modelPath);\n        ArgumentListExpression replacedArgumentList = new ArgumentListExpression(modelPathArgument, closureExpression);\n        call.setMethod(new ConstantExpression(\"configure\"));\n        call.setArguments(replacedArgumentList);\n\n        // Call directly on the delegate to avoid some dynamic dispatch\n        call.setImplicitThis(true);\n        call.setObjectExpression(new MethodCallExpression(VariableExpression.THIS_EXPRESSION, \"getDelegate\", ArgumentListExpression.EMPTY_ARGUMENTS));\n\n        SourceLocation sourceLocation = new SourceLocation(getScriptSourceLocation(), getScriptSourceDescription(), call.getLineNumber(), call.getColumnNumber());\n        ruleVisitor.visitRuleClosure(closureExpression, sourceLocation);\n    }","id":83729,"modified_method":"public void rewriteAction(MethodCallExpression call, String modelPath, ClosureExpression closureExpression, String displayName) {\n        // Rewrite the method call to match TransformedModelDslBacking#configure(String, Closure), which is what the delegate will be\n        ConstantExpression modelPathArgument = new ConstantExpression(modelPath);\n        ArgumentListExpression replacedArgumentList = new ArgumentListExpression(modelPathArgument, closureExpression);\n        call.setMethod(new ConstantExpression(\"configure\"));\n        call.setArguments(replacedArgumentList);\n\n        // Call directly on the delegate to avoid some dynamic dispatch\n        call.setImplicitThis(true);\n        call.setObjectExpression(new MethodCallExpression(VariableExpression.THIS_EXPRESSION, \"getDelegate\", ArgumentListExpression.EMPTY_ARGUMENTS));\n\n        ruleVisitor.visitRuleClosure(closureExpression, call, displayName);\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        ClosureExpression closureExpression = AstUtils.getSingleClosureArg(call);\n        if (closureExpression != null) {\n            // path { ... }\n            rewriteAction(call, extractModelPathFromMethodTarget(call), closureExpression);\n            return;\n        }\n\n        Pair<ClassExpression, ClosureExpression> args = AstUtils.getClassAndClosureArgs(call);\n        if (args != null) {\n            // path(Type) { ... }\n            rewriteCreator(call, extractModelPathFromMethodTarget(call), args.getRight(), args.getLeft());\n            return;\n        }\n\n        ClassExpression classArg = AstUtils.getClassArg(call);\n        if (classArg != null) {\n            // path(Type)\n            List<Statement> statements = Lists.newLinkedList();\n            statements.add(new EmptyStatement());\n            BlockStatement block = new BlockStatement(statements, new VariableScope());\n            closureExpression = new ClosureExpression(Parameter.EMPTY_ARRAY, block);\n            closureExpression.setVariableScope(block.getVariableScope());\n            rewriteCreator(call, extractModelPathFromMethodTarget(call), closureExpression, classArg);\n            return;\n        }\n\n        restrict(call, INVALID_RULE_SIGNATURE);\n    }","id":83730,"modified_method":"@Override\n    public void visitMethodCallExpression(MethodCallExpression call) {\n        ClosureExpression closureExpression = AstUtils.getSingleClosureArg(call);\n        if (closureExpression != null) {\n            // path { ... }\n            String modelPath = extractModelPathFromMethodTarget(call);\n            rewriteAction(call, modelPath, closureExpression, modelPath + \" { ... }\");\n            return;\n        }\n\n        Pair<ClassExpression, ClosureExpression> args = AstUtils.getClassAndClosureArgs(call);\n        if (args != null) {\n            // path(Type) { ... }\n            String modelPath = extractModelPathFromMethodTarget(call);\n            rewriteCreator(call, modelPath, args.getRight(), args.getLeft(), modelPath + \"(\" + args.getLeft().getText() + \") { ... }\");\n            return;\n        }\n\n        ClassExpression classArg = AstUtils.getClassArg(call);\n        if (classArg != null) {\n            // path(Type)\n            List<Statement> statements = Lists.newLinkedList();\n            statements.add(new EmptyStatement());\n            BlockStatement block = new BlockStatement(statements, new VariableScope());\n            closureExpression = new ClosureExpression(Parameter.EMPTY_ARRAY, block);\n            closureExpression.setVariableScope(block.getVariableScope());\n            String modelPath = extractModelPathFromMethodTarget(call);\n            rewriteCreator(call, modelPath, closureExpression, classArg, modelPath + \"(\" + classArg.getText() + \")\");\n            return;\n        }\n\n        restrict(call, INVALID_RULE_SIGNATURE);\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"public void rewriteCreator(MethodCallExpression call, String modelPath, ClosureExpression closureExpression, ClassExpression typeExpression) {\n        // Rewrite the method call to match TransformedModelDslBacking#create(String, Closure), which is what the delegate will be\n        ConstantExpression modelPathArgument = new ConstantExpression(modelPath);\n        ArgumentListExpression replacedArgumentList = new ArgumentListExpression(modelPathArgument, typeExpression, closureExpression);\n        call.setMethod(new ConstantExpression(\"create\"));\n        call.setArguments(replacedArgumentList);\n\n        // Call directly on the delegate to avoid some dynamic dispatch\n        call.setImplicitThis(true);\n        call.setObjectExpression(new MethodCallExpression(VariableExpression.THIS_EXPRESSION, \"getDelegate\", ArgumentListExpression.EMPTY_ARGUMENTS));\n\n        SourceLocation sourceLocation = new SourceLocation(getScriptSourceLocation(), getScriptSourceDescription(), call.getLineNumber(), call.getColumnNumber());\n        ruleVisitor.visitRuleClosure(closureExpression, sourceLocation);\n    }","id":83731,"modified_method":"public void rewriteCreator(MethodCallExpression call, String modelPath, ClosureExpression closureExpression, ClassExpression typeExpression, String displayName) {\n        // Rewrite the method call to match TransformedModelDslBacking#create(String, Closure), which is what the delegate will be\n        ConstantExpression modelPathArgument = new ConstantExpression(modelPath);\n        ArgumentListExpression replacedArgumentList = new ArgumentListExpression(modelPathArgument, typeExpression, closureExpression);\n        call.setMethod(new ConstantExpression(\"create\"));\n        call.setArguments(replacedArgumentList);\n\n        // Call directly on the delegate to avoid some dynamic dispatch\n        call.setImplicitThis(true);\n        call.setObjectExpression(new MethodCallExpression(VariableExpression.THIS_EXPRESSION, \"getDelegate\", ArgumentListExpression.EMPTY_ARGUMENTS));\n\n        ruleVisitor.visitRuleClosure(closureExpression, call, displayName);\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"public RulesVisitor(SourceUnit sourceUnit, RuleVisitor ruleVisitor, String scriptSourceDescription, @Nullable URI location) {\n        super(sourceUnit, INVALID_STATEMENT);\n        this.ruleVisitor = ruleVisitor;\n        this.scriptSourceDescription = scriptSourceDescription;\n        this.location = location;\n    }","id":83732,"modified_method":"public RulesVisitor(SourceUnit sourceUnit, RuleVisitor ruleVisitor) {\n        super(sourceUnit, INVALID_STATEMENT);\n        this.ruleVisitor = ruleVisitor;\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"public SourceLocation(@Nullable URI uri, String scriptSourceDescription, int lineNumber, int columnNumber) {\n        this.uri = uri;\n        this.scriptSourceDescription = scriptSourceDescription;\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }","id":83733,"modified_method":"public SourceLocation(@Nullable URI uri, String scriptSourceDescription, String expression, int lineNumber, int columnNumber) {\n        this.uri = uri;\n        this.scriptSourceDescription = scriptSourceDescription;\n        this.expression = expression;\n        this.lineNumber = lineNumber;\n        this.columnNumber = columnNumber;\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"public ModelRuleDescriptor asDescriptor(String val) {\n        return new SimpleModelRuleDescriptor(String.format(\"%s @ %s\", val, toString()));\n    }","id":83734,"modified_method":"public ModelRuleDescriptor asDescriptor() {\n        return new SimpleModelRuleDescriptor(String.format(\"%s @ %s\", expression, toString()));\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Invoked by transformed DSL creation rules\n     */\n    public <T> void create(String modelPathString, Class<T> type, Closure<?> closure) {\n        ModelPath modelPath = ModelPath.path(modelPathString);\n        DeferredModelAction modelAction = ruleFactory.toAction(modelPath, type, closure);\n        ModelRuleDescriptor descriptor = modelAction.getDescriptor();\n        try {\n            NodeInitializerRegistry nodeInitializerRegistry = modelRegistry.realize(DefaultNodeInitializerRegistry.DEFAULT_REFERENCE.getPath(), DefaultNodeInitializerRegistry.DEFAULT_REFERENCE.getType());\n            NodeInitializer nodeInitializer = nodeInitializerRegistry.getNodeInitializer(NodeInitializerContext.forType(ModelType.of(type)));\n            modelRegistry.register(ModelRegistrations.of(modelPath, nodeInitializer).descriptor(descriptor).build());\n        } catch (ModelTypeInitializationException e) {\n            throw new InvalidModelRuleDeclarationException(descriptor, e);\n        }\n        registerAction(modelPath, type, ModelActionRole.Initialize, modelAction);\n    }","id":83735,"modified_method":"/**\n     * Invoked by transformed DSL creation rules\n     */\n    public <T> void create(String modelPathString, Class<T> type, Closure<?> closure) {\n        ModelPath modelPath = ModelPath.path(modelPathString);\n        DeferredModelAction modelAction = ruleFactory.toAction(type, closure);\n        ModelRuleDescriptor descriptor = modelAction.getDescriptor();\n        try {\n            NodeInitializerRegistry nodeInitializerRegistry = modelRegistry.realize(DefaultNodeInitializerRegistry.DEFAULT_REFERENCE.getPath(), DefaultNodeInitializerRegistry.DEFAULT_REFERENCE.getType());\n            NodeInitializer nodeInitializer = nodeInitializerRegistry.getNodeInitializer(NodeInitializerContext.forType(ModelType.of(type)));\n            modelRegistry.register(ModelRegistrations.of(modelPath, nodeInitializer).descriptor(descriptor).build());\n        } catch (ModelTypeInitializationException e) {\n            throw new InvalidModelRuleDeclarationException(descriptor, e);\n        }\n        registerAction(modelPath, type, ModelActionRole.Initialize, modelAction);\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Invoked by transformed DSL configuration rules\n     */\n    public void configure(String modelPathString, Closure<?> closure) {\n        ModelPath modelPath = ModelPath.path(modelPathString);\n        DeferredModelAction modelAction = ruleFactory.toAction(modelPath, Object.class, closure);\n        registerAction(modelPath, Object.class, ModelActionRole.Mutate, modelAction);\n    }","id":83736,"modified_method":"/**\n     * Invoked by transformed DSL configuration rules\n     */\n    public void configure(String modelPathString, Closure<?> closure) {\n        ModelPath modelPath = ModelPath.path(modelPathString);\n        DeferredModelAction modelAction = ruleFactory.toAction(Object.class, closure);\n        registerAction(modelPath, Object.class, ModelActionRole.Mutate, modelAction);\n    }","commit_id":"75edcebc7081de727e807480ba5645b83ebf4217","url":"https://github.com/gradle/gradle"},{"original_method":"protected void disconnect() throws IOException {\n        LOG.info(\"FtpConsumer's client is being explicitly disconnected\");\n        endpoint.disconnect(client);\n    }","id":83737,"modified_method":"protected void disconnect() throws IOException {\n        LOG.debug(\"Disconnecting from \" + endpoint.getConfiguration().remoteServerInformation());\n        endpoint.disconnect(client);\n    }","commit_id":"bfd86ec494b2b5f4fb9a8d26d37eabd79007987e","url":"https://github.com/apache/camel"},{"original_method":"protected void poll() throws Exception {\n        connectIfNecessary();\n        // If the attempt to connect isn't successful, then the thrown\n        // exception will signify that we couldn't poll\n        try {\n            final String fileName = endpoint.getConfiguration().getFile();\n            if (endpoint.getConfiguration().isDirectory()) {\n                pollDirectory(fileName);\n            } else {\n                int index = fileName.lastIndexOf('/');\n                if (index > -1) {\n                    client.changeWorkingDirectory(fileName.substring(0, index));\n                }\n                final FTPFile[] files = client.listFiles(fileName.substring(index + 1));\n                pollFile(files[0]);\n            }\n            lastPollTime = System.currentTimeMillis();\n        } catch (FTPConnectionClosedException e) {\n            // If the server disconnected us, then we must manually disconnect\n            // the client before attempting to reconnect\n            LOG.warn(\"Disconnecting due to exception: \" + e.toString());\n            disconnect();\n            // Rethrow to signify that we didn't poll\n            throw e;\n        } catch (RuntimeCamelException e) {\n            LOG.warn(\"Caught RuntimeCamelException: \" + e.toString());\n            LOG.warn(\"Hoping an explicit disconnect/reconnect will solve the problem\");\n            disconnect();\n            // Rethrow to signify that we didn't poll\n            throw e;\n        }\n    }","id":83738,"modified_method":"protected void poll() throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling \" + endpoint.getConfiguration());\n        }\n        connectIfNecessary();\n        // If the attempt to connect isn't successful, then the thrown\n        // exception will signify that we couldn't poll\n        try {\n            final String fileName = endpoint.getConfiguration().getFile();\n            if (endpoint.getConfiguration().isDirectory()) {\n                pollDirectory(fileName);\n            } else {\n                int index = fileName.lastIndexOf('/');\n                if (index > -1) {\n                    client.changeWorkingDirectory(fileName.substring(0, index));\n                }\n                final FTPFile[] files = client.listFiles(fileName.substring(index + 1));\n                pollFile(files[0]);\n            }\n            lastPollTime = System.currentTimeMillis();\n        } catch (FTPConnectionClosedException e) {\n            // If the server disconnected us, then we must manually disconnect\n            // the client before attempting to reconnect\n            LOG.warn(\"Disconnecting due to exception: \" + e.getMessage());\n            disconnect();\n            // Rethrow to signify that we didn't poll\n            throw e;\n        } catch (RuntimeCamelException e) {\n            LOG.warn(\"Caught RuntimeCamelException: \" + e.getMessage(), e);\n            LOG.warn(\"Hoping an explicit disconnect/reconnect will solve the problem\");\n            disconnect();\n            // Rethrow to signify that we didn't poll\n            throw e;\n        }\n    }","commit_id":"bfd86ec494b2b5f4fb9a8d26d37eabd79007987e","url":"https://github.com/apache/camel"},{"original_method":"private void pollFile(FTPFile ftpFile) throws Exception {\n        // TODO do we need to adjust the TZ? can we?\n        if (ftpFile.getTimestamp().getTimeInMillis() > lastPollTime) {\n            if (isMatched(ftpFile)) {\n                String fullFileName = getFullFileName(ftpFile);\n                final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n                client.retrieveFile(ftpFile.getName(), byteArrayOutputStream);\n                RemoteFileExchange exchange = endpoint.createExchange(fullFileName, byteArrayOutputStream);\n\n                if (isSetNames()) {\n                    // set the filename in the special header filename marker to the ftp filename\n                    String ftpBasePath = endpoint.getConfiguration().getFile();\n                    String relativePath = fullFileName.substring(ftpBasePath.length() + 1);\n                    relativePath = relativePath.replaceFirst(\"/\", \"\");\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Setting exchange filename to \" + relativePath);\n                    }\n                    exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);\n                }\n\n                getProcessor().process(exchange);\n            }\n        }\n    }","id":83739,"modified_method":"private void pollFile(FTPFile ftpFile) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling file: \" + ftpFile);\n        }\n\n        long ts = ftpFile.getTimestamp().getTimeInMillis();\n        // TODO do we need to adjust the TZ? can we?\n        if (ts > lastPollTime && isMatched(ftpFile)) {\n            String remoteServer =  endpoint.getConfiguration().remoteServerInformation();\n            String fullFileName = getFullFileName(ftpFile);\n\n            // is we use excluse read then acquire the exclusive read (waiting until we got it)\n            if (exclusiveRead) {\n                acquireExclusiveRead(client, ftpFile);\n            }\n\n            // retrieve the file\n            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            client.retrieveFile(ftpFile.getName(), byteArrayOutputStream);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Retrieved file: \" + ftpFile.getName() + \" from: \" + remoteServer);\n            }\n\n            RemoteFileExchange exchange = endpoint.createExchange(fullFileName, byteArrayOutputStream);\n\n            if (isSetNames()) {\n                // set the filename in the special header filename marker to the ftp filename\n                String ftpBasePath = endpoint.getConfiguration().getFile();\n                String relativePath = fullFileName.substring(ftpBasePath.length() + 1);\n                relativePath = relativePath.replaceFirst(\"/\", \"\");\n\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Setting exchange filename to \" + relativePath);\n                }\n                exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);\n            }\n\n            getProcessor().process(exchange);\n        }\n    }","commit_id":"bfd86ec494b2b5f4fb9a8d26d37eabd79007987e","url":"https://github.com/apache/camel"},{"original_method":"protected void pollDirectory(String dir) throws Exception {\n        String currentDir = client.printWorkingDirectory();\n\n        client.changeWorkingDirectory(dir);\n        for (FTPFile ftpFile : client.listFiles()) {\n            if (ftpFile.isFile()) {\n                pollFile(ftpFile);\n            } else if (ftpFile.isDirectory()) {\n                if (isRecursive()) {\n                    pollDirectory(getFullFileName(ftpFile));\n                }\n            } else {\n                // TODO: Type can be symbolic link etc. so what should we do?\n                LOG.warn(\"Unsupported type of FTPFile: \" + ftpFile + \" not a file or directory\");\n            }\n        }\n\n        // change back to original current dir\n        client.changeWorkingDirectory(currentDir);\n    }","id":83740,"modified_method":"protected void pollDirectory(String dir) throws Exception {\n        String currentDir = client.printWorkingDirectory();\n\n        client.changeWorkingDirectory(dir);\n        for (FTPFile ftpFile : client.listFiles()) {\n            if (ftpFile.isFile()) {\n                pollFile(ftpFile);\n            } else if (ftpFile.isDirectory()) {\n                if (isRecursive()) {\n                    pollDirectory(getFullFileName(ftpFile));\n                }\n            } else {\n                LOG.debug(\"Unsupported type of FTPFile: \" + ftpFile + \" (not a file or directory). Is skipped.\");\n            }\n        }\n\n        // change back to original current dir\n        client.changeWorkingDirectory(currentDir);\n    }","commit_id":"bfd86ec494b2b5f4fb9a8d26d37eabd79007987e","url":"https://github.com/apache/camel"},{"original_method":"protected void connectIfNecessary() throws IOException {\n        // TODO: is there a way to avoid copy-pasting the reconnect logic?\n        if (!client.isConnected()) {\n            LOG.warn(\"FtpConsumer's client isn't connected, trying to reconnect...\");\n            endpoint.connect(client);\n            LOG.info(\"Connected to \" + endpoint.getConfiguration());\n        }\n    }","id":83741,"modified_method":"protected void connectIfNecessary() throws IOException {\n        if (!client.isConnected()) {\n            LOG.debug(\"Not connected, trying to reconnect.\");\n            endpoint.connect(client);\n            LOG.info(\"Connected to \" + endpoint.getConfiguration().remoteServerInformation());\n        }\n    }","commit_id":"bfd86ec494b2b5f4fb9a8d26d37eabd79007987e","url":"https://github.com/apache/camel"},{"original_method":"private void pollFile(ChannelSftp.LsEntry sftpFile) throws Exception {\n        if (sftpFile.getAttrs().getMTime() * 1000L > lastPollTime) {\n            if (isMatched(sftpFile)) {\n                final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n                channel.get(sftpFile.getFilename(), byteArrayOutputStream);\n                RemoteFileExchange exchange = endpoint.createExchange(getFullFileName(sftpFile), byteArrayOutputStream);\n\n                if (isSetNames()) {\n                    String relativePath = getFullFileName(sftpFile).substring(endpoint.getConfiguration().getFile().length());\n                    if (relativePath.startsWith(\"/\")) {\n                        relativePath = relativePath.substring(1);\n                    }\n                    exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);\n                }\n\n                getProcessor().process(exchange);\n            }\n        }\n    }","id":83742,"modified_method":"private void pollFile(ChannelSftp.LsEntry sftpFile) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling file: \" + sftpFile);\n        }\n\n        long ts = sftpFile.getAttrs().getMTime() * 1000L;\n\n        // TODO do we need to adjust the TZ? can we?\n        if (ts > lastPollTime && isMatched(sftpFile)) {\n            String remoteServer =  endpoint.getConfiguration().remoteServerInformation();\n\n            // is we use excluse read then acquire the exclusive read (waiting until we got it)\n            if (exclusiveRead) {\n                acquireExclusiveRead(sftpFile);\n            }\n\n            // retrieve the file\n            final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n            channel.get(sftpFile.getFilename(), byteArrayOutputStream);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Retrieved file: \" + sftpFile.getFilename() + \" from: \" + remoteServer);\n            }\n\n            RemoteFileExchange exchange = endpoint.createExchange(getFullFileName(sftpFile), byteArrayOutputStream);\n\n            if (isSetNames()) {\n                String relativePath = getFullFileName(sftpFile).substring(endpoint.getConfiguration().getFile().length());\n                if (relativePath.startsWith(\"/\")) {\n                    relativePath = relativePath.substring(1);\n                }\n                exchange.getIn().setHeader(FileComponent.HEADER_FILE_NAME, relativePath);\n            }\n\n            getProcessor().process(exchange);\n        }\n    }","commit_id":"bfd86ec494b2b5f4fb9a8d26d37eabd79007987e","url":"https://github.com/apache/camel"},{"original_method":"protected void disconnect() throws JSchException {\n        if (session != null) {\n            LOG.info(\"Session is being explicitly disconnected\");\n            session.disconnect();\n        }\n        if (channel != null) {\n            LOG.info(\"Channel is being explicitly disconnected\");\n            channel.disconnect();\n        }\n    }","id":83743,"modified_method":"protected void disconnect() throws JSchException {\n        if (session != null) {\n            LOG.debug(\"Session is being explicitly disconnected\");\n            session.disconnect();\n        }\n        if (channel != null) {\n            LOG.debug(\"Channel is being explicitly disconnected\");\n            channel.disconnect();\n        }\n    }","commit_id":"bfd86ec494b2b5f4fb9a8d26d37eabd79007987e","url":"https://github.com/apache/camel"},{"original_method":"protected void poll() throws Exception {\n        // TODO: is there a way to avoid copy-pasting the reconnect logic?\n        connectIfNecessary();\n        // If the attempt to connect isn't successful, then the thrown\n        // exception will signify that we couldn't poll\n        try {\n            final String fileName = endpoint.getConfiguration().getFile();\n            if (endpoint.getConfiguration().isDirectory()) {\n                pollDirectory(fileName);\n            } else {\n                channel.cd(fileName.substring(0, fileName.lastIndexOf('/')));\n                final ChannelSftp.LsEntry file = (ChannelSftp.LsEntry)channel.ls(fileName.substring(fileName.lastIndexOf('/') + 1)).get(0);\n                pollFile(file);\n            }\n            lastPollTime = System.currentTimeMillis();\n        } catch (JSchException e) {\n            // If the connection has gone stale, then we must manually disconnect\n            // the client before attempting to reconnect\n            LOG.warn(\"Disconnecting due to exception: \" + e.toString());\n            disconnect();\n            // Rethrow to signify that we didn't poll\n            throw e;\n        } catch (SftpException e) {\n            // Still not sure if/when these come up and what we should do about them\n            // client.disconnect();\n            LOG.warn(\"Caught SftpException:\" + e.toString());\n            LOG.warn(\"Doing nothing for now, need to determine an appropriate action\");\n            // Rethrow to signify that we didn't poll\n            throw e;\n        }\n    }","id":83744,"modified_method":"protected void poll() throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Polling \" + endpoint.getConfiguration());\n        }\n        connectIfNecessary();\n        // If the attempt to connect isn't successful, then the thrown\n        // exception will signify that we couldn't poll\n        try {\n            final String fileName = endpoint.getConfiguration().getFile();\n            if (endpoint.getConfiguration().isDirectory()) {\n                pollDirectory(fileName);\n            } else {\n                channel.cd(fileName.substring(0, fileName.lastIndexOf('/')));\n                final ChannelSftp.LsEntry file = (ChannelSftp.LsEntry)channel.ls(fileName.substring(fileName.lastIndexOf('/') + 1)).get(0);\n                pollFile(file);\n            }\n            lastPollTime = System.currentTimeMillis();\n        } catch (JSchException e) {\n            // If the connection has gone stale, then we must manually disconnect\n            // the client before attempting to reconnect\n            LOG.warn(\"Disconnecting due to exception: \" + e.getMessage());\n            disconnect();\n            // Rethrow to signify that we didn't poll\n            throw e;\n        } catch (SftpException e) {\n            // Still not sure if/when these come up and what we should do about them\n            // client.disconnect();\n            LOG.warn(\"Caught SftpException:\" + e.getMessage(), e);\n            LOG.warn(\"Hoping an explicit disconnect/reconnect will solve the problem\");\n            // Rethrow to signify that we didn't poll\n            throw e;\n        }\n    }","commit_id":"bfd86ec494b2b5f4fb9a8d26d37eabd79007987e","url":"https://github.com/apache/camel"},{"original_method":"protected void connectIfNecessary() throws JSchException {\n        if (channel == null || !channel.isConnected()) {\n            if (session == null || !session.isConnected()) {\n                LOG.info(\"Session isn't connected, trying to recreate and connect...\");\n                session = endpoint.createSession();\n                session.connect();\n            }\n            LOG.info(\"Channel isn't connected, trying to recreate and connect...\");\n            channel = endpoint.createChannelSftp(session);\n            channel.connect();\n            LOG.info(\"Connected to \" + endpoint.getConfiguration().toString());\n        }\n    }","id":83745,"modified_method":"protected void connectIfNecessary() throws JSchException {\n        if (channel == null || !channel.isConnected()) {\n            if (session == null || !session.isConnected()) {\n                LOG.debug(\"Session isn't connected, trying to recreate and connect.\");\n                session = endpoint.createSession();\n                session.connect();\n            }\n            LOG.debug(\"Channel isn't connected, trying to recreate and connect.\");\n            channel = endpoint.createChannelSftp(session);\n            channel.connect();\n            LOG.info(\"Connected to \" + endpoint.getConfiguration().remoteServerInformation());\n        }\n    }","commit_id":"bfd86ec494b2b5f4fb9a8d26d37eabd79007987e","url":"https://github.com/apache/camel"},{"original_method":"protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {\n        File file = new File(remaining);\n        FileEndpoint result = new FileEndpoint(file, uri, this);\n        setProperties(result, parameters);\n        return result;\n    }","id":83746,"modified_method":"protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {\n        File file = new File(remaining);\n        FileEndpoint result = new FileEndpoint(file, uri, this);\n\n        // lookup idempotent repository in registry if provided\n        String ref = getAndRemoveParameter(parameters, \"idempotentRepositoryRef\", String.class);\n        if (ref != null) {\n            MessageIdRepository repository = mandatoryLookup(ref, MessageIdRepository.class);\n            result.setIdempotentRepository(repository);\n        }\n\n        setProperties(result, parameters);\n        return result;\n    }","commit_id":"e4dd67557bf9766a7bf7e42c128c5488a5c83627","url":"https://github.com/apache/camel"},{"original_method":"protected boolean isMatched(File file) {\n        String name = file.getName();\n\n        // folders/names starting with dot is always skipped (eg. \".\", \".camel\", \".camelLock\")\n        if (name.startsWith(\".\")) {\n            return false;\n        }\n        // lock files should be skipped\n        if (name.endsWith(FileEndpoint.DEFAULT_LOCK_FILE_POSTFIX)) {\n            return false;\n        }\n\n        // directories so far is always regarded as matched (matching on the name is only for files)\n        if (file.isDirectory()) {\n            return true;\n        }\n\n        if (regexPattern != null && regexPattern.length() > 0) {\n            if (!name.matches(regexPattern)) {\n                return false;\n            }\n        }\n\n        if (endpoint.getExcludedNamePrefix() != null) {\n            if (name.startsWith(endpoint.getExcludedNamePrefix())) {\n                return false;\n            }\n        }\n        if (endpoint.getExcludedNamePostfix() != null) {\n            if (name.endsWith(endpoint.getExcludedNamePostfix())) {\n                return false;\n            }\n        }\n\n        return true;\n    }","id":83747,"modified_method":"/**\n     * Strategy to perform file matching based on endpoint configuration.\n     * <p/>\n     * Will always return false for certain files:\n     * <ul>\n     *    <li>Starting with a dot<\/li>\n     *    <li>lock files<\/li>\n     * <\/ul>\n     *\n     * @param file  the file\n     * @return true if the file is matche, false if not\n     */\n    protected boolean isMatched(File file) {\n        String name = file.getName();\n\n        // folders/names starting with dot is always skipped (eg. \".\", \".camel\", \".camelLock\")\n        if (name.startsWith(\".\")) {\n            return false;\n        }\n        // lock files should be skipped\n        if (name.endsWith(FileEndpoint.DEFAULT_LOCK_FILE_POSTFIX)) {\n            return false;\n        }\n\n        // directories so far is always regarded as matched (matching on the name is only for files)\n        if (file.isDirectory()) {\n            return true;\n        }\n\n        if (regexPattern != null && regexPattern.length() > 0) {\n            if (!name.matches(regexPattern)) {\n                return false;\n            }\n        }\n\n        if (endpoint.getExcludedNamePrefix() != null) {\n            if (name.startsWith(endpoint.getExcludedNamePrefix())) {\n                return false;\n            }\n        }\n        if (endpoint.getExcludedNamePostfix() != null) {\n            if (name.endsWith(endpoint.getExcludedNamePostfix())) {\n                return false;\n            }\n        }\n\n        return true;\n    }","commit_id":"e4dd67557bf9766a7bf7e42c128c5488a5c83627","url":"https://github.com/apache/camel"},{"original_method":"protected synchronized void poll() throws Exception {\n        // should be true the first time as its the top directory\n        int rc = pollFileOrDirectory(endpoint.getFile(), true);\n\n        // if no files consumes and using generateEmptyExchangeWhenIdle option then process an empty exchange \n        if (rc == 0 && generateEmptyExchangeWhenIdle) {\n            final FileExchange exchange = endpoint.createExchange((File)null);\n            getAsyncProcessor().process(exchange, new AsyncCallback() {\n                public void done(boolean sync) {\n                }\n            });\n        }\n\n        lastPollTime = System.currentTimeMillis();\n    }","id":83748,"modified_method":"protected synchronized void poll() throws Exception {\n        // gather list of files to process\n        List<File> files = new ArrayList<File>();\n        filesToPoll(endpoint.getFile(), true, files);\n\n        // TODO allow reordering of files CAMEL-1112\n\n        // consume files one by one\n        int total = files.size();\n        for (int index = 0; index < files.size(); index++) {\n            File file = files.get(index);\n            processFile(file, total, index);\n        }\n    }","commit_id":"e4dd67557bf9766a7bf7e42c128c5488a5c83627","url":"https://github.com/apache/camel"},{"original_method":"protected boolean isValidFile(File file) {\n        boolean result = false;\n        if (file != null && file.exists()) {\n            // TODO: maybe use a configurable strategy instead of the hardcoded one based on last file change\n            if (isMatched(file) && (alwaysConsume || isChanged(file))) {\n                result = true;\n            }\n        }\n        return result;\n    }","id":83749,"modified_method":"/**\n     * Strategy for validating if the given file should be included or not\n     * @param file  the file\n     * @return true to include the file, false to skip it\n     */\n    protected boolean isValidFile(File file) {\n        // NOTE: contains will add if we had a miss\n        if (endpoint.isIdempotent() && endpoint.getIdempotentRepository().contains(file.getName())) {\n            // skip as we have already processed it\n            return false;\n        }\n\n        return isMatched(file);\n    }","commit_id":"e4dd67557bf9766a7bf7e42c128c5488a5c83627","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void testFileRoute() throws Exception {\n        MockEndpoint result = resolveMandatoryEndpoint(\"mock:result\", MockEndpoint.class);\n        result.expectedBodiesReceived(expectedBody);\n        result.setResultWaitTime(5000);\n\n        template.sendBodyAndHeader(uri, expectedBody, \"cheese\", 123);\n        Thread.sleep(4000);\n\n        result.assertIsSatisfied();\n\n        for (String lockName : recorder.getLocks()) {\n            File lock = new File(lockName);\n            assertFalse(lock.exists());\n        }\n    }","id":83750,"modified_method":"@Override\n    public void testFileRoute() throws Exception {\n        deleteDirectory(\"target/test-delete-inbox\");\n        \n        MockEndpoint result = resolveMandatoryEndpoint(\"mock:result\", MockEndpoint.class);\n        result.expectedBodiesReceived(expectedBody);\n\n        template.sendBodyAndHeader(uri, expectedBody, \"cheese\", 123);\n        result.assertIsSatisfied();\n\n        Thread.sleep(100);\n\n        for (String lockName : recorder.getLocks()) {\n            File lock = new File(lockName);\n            lock = lock.getAbsoluteFile();\n            assertFalse(lock.exists());\n        }\n    }","commit_id":"e4dd67557bf9766a7bf7e42c128c5488a5c83627","url":"https://github.com/apache/camel"},{"original_method":"public Consumer createConsumer(Processor processor) throws Exception {\n        Consumer result = new FileConsumer(this, processor);\n        configureConsumer(result);\n        return result;\n    }","id":83751,"modified_method":"public Consumer createConsumer(Processor processor) throws Exception {\n        Consumer result = new FileConsumer(this, processor);\n\n        // if idempotent and no repository set then create a default one\n        if (isIdempotent() && idempotentRepository == null) {\n            LOG.info(\"Using default memory based idempotent repository with cache max size: \" + DEFAULT_IDEMPOTENT_CACHE_SIZE);\n            idempotentRepository = MemoryMessageIdRepository.memoryMessageIdRepository(DEFAULT_IDEMPOTENT_CACHE_SIZE);\n        }\n\n        configureConsumer(result);\n        return result;\n    }","commit_id":"e4dd67557bf9766a7bf7e42c128c5488a5c83627","url":"https://github.com/apache/camel"},{"original_method":"public void testFileRoute() throws Exception {\n        template.sendBodyAndHeader(\"file:\" + inputDirectory, expectedBody, FileComponent.HEADER_FILE_NAME, fileName);\n\n        MockEndpoint result = getMockEndpoint(\"mock:result\");\n        result.expectedBodiesReceived(expectedBody);\n        result.setResultWaitTime(5000);\n\n        // now lets wait a bit and move that file\n        Thread.sleep(5000);\n\n        // lets delete the output directory\n        deleteDirectory(outputDirectory);\n\n        // now lets wait a bit for it to be polled\n        Thread.sleep(5000);\n\n        File file = new File(inputDirectory + \"/\" + fileName);\n\n        File outDir = new File(outputDirectory);\n        outDir.mkdirs();\n\n        File newFile = new File(outDir, fileName);\n\n        assertFileExists(file);\n        assertFileNotExists(newFile);\n\n        boolean answer = file.renameTo(newFile);\n        assertTrue(\"Move of file: \" + file + \" to \" + newFile + \" should have worked!\", answer);\n\n        assertFileNotExists(file);\n        assertFileExists(newFile);\n\n        // now lets wait for multiple polls to check we only process it once\n        Thread.sleep(5000);\n\n        assertMockEndpointsSatisfied();\n    }","id":83752,"modified_method":"public void testFileRoute() throws Exception {\n        template.sendBodyAndHeader(\"file:\" + inputDirectory, expectedBody, FileComponent.HEADER_FILE_NAME, fileName);\n\n        MockEndpoint result = getMockEndpoint(\"mock:result\");\n        result.expectedBodiesReceived(expectedBody);\n        result.setResultWaitTime(5000);\n\n        // now lets wait a bit and move that file\n        Thread.sleep(2000);\n\n        // lets delete the output directory\n        deleteDirectory(outputDirectory);\n\n        // now lets wait a bit for it to be polled\n        Thread.sleep(2000);\n\n        File file = new File(inputDirectory + \"/\" + fileName);\n\n        File outDir = new File(outputDirectory);\n        outDir.mkdirs();\n\n        File newFile = new File(outDir, fileName);\n\n        assertFileExists(file);\n        assertFileNotExists(newFile);\n\n        boolean answer = file.renameTo(newFile);\n        assertTrue(\"Move of file: \" + file + \" to \" + newFile + \" should have worked!\", answer);\n\n        assertFileNotExists(file);\n        assertFileExists(newFile);\n\n        // now lets wait for multiple polls to check we only process it once\n        Thread.sleep(3000);\n\n        assertMockEndpointsSatisfied();\n    }","commit_id":"e4dd67557bf9766a7bf7e42c128c5488a5c83627","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected String getOutputEndpointUri() {\n        return super.getOutputEndpointUri() + \"?noop=true\";\n    }","id":83753,"modified_method":"@Override\n    protected String getOutputEndpointUri() {\n        return super.getOutputEndpointUri() + \"?noop=true&idempotent=true\";\n    }","commit_id":"e4dd67557bf9766a7bf7e42c128c5488a5c83627","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates a Criterion with from the specified property name and \"like\" expression\n     * @param propertyName The property name\n     * @param propertyValue The like value\n     *\n     * @return A Criterion instance\n     */\n    public Object like(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [like] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        return addToCriteria(Restrictions.like(propertyName, propertyValue));\n    }","id":83754,"modified_method":"/**\n     * Creates a Criterion with from the specified property name and \"like\" expression\n     * @param propertyName The property name\n     * @param propertyValue The like value\n     *\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria like(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [like] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        addToCriteria(Restrictions.like(propertyName, propertyValue));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to return the property average value\n     *\n     * @param propertyName The name of the property\n     * @param alias The alias to use\n     */\n    public void avg(String propertyName, String alias) {\n        final AggregateProjection aggregateProjection = Projections.avg(calculatePropertyName(propertyName));\n        addProjectionToList(aggregateProjection, alias);\n    }","id":83755,"modified_method":"/**\n     * Adds a projection that allows the criteria to return the property average value\n     *\n     * @param propertyName The name of the property\n     * @param alias The alias to use\n     */\n    public org.grails.datastore.mapping.query.api.Projections avg(String propertyName, String alias) {\n        final AggregateProjection aggregateProjection = Projections.avg(calculatePropertyName(propertyName));\n        addProjectionToList(aggregateProjection, alias);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that contrains a collection property to be less than or equal to the given size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public Object sizeLe(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeLe] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        return addToCriteria(Restrictions.sizeLe(propertyName, size));\n    }","id":83756,"modified_method":"/**\n     * Creates a Criterion that contrains a collection property to be less than or equal to the given size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria sizeLe(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeLe] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        addToCriteria(Restrictions.sizeLe(propertyName, size));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Applys a \"in\" contrain on the specified property\n     * @param propertyName The property name\n     * @param values A collection of values\n     *\n     * @return A Criterion instance\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public Object in(String propertyName, Collection values) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [in] with propertyName [\" +\n                    propertyName + \"] and values [\" + values + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        return addToCriteria(Restrictions.in(propertyName, values));\n    }","id":83757,"modified_method":"/**\n     * Applys a \"in\" contrain on the specified property\n     * @param propertyName The property name\n     * @param values A collection of values\n     *\n     * @return A Criterion instance\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public org.grails.datastore.mapping.query.api.Criteria in(String propertyName, Collection values) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [in] with propertyName [\" +\n                    propertyName + \"] and values [\" + values + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        addToCriteria(Restrictions.in(propertyName, values));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Applys a \"in\" contrain on the specified property\n     * @param propertyName The property name\n     * @param values A collection of values\n     *\n     * @return A Criterion instance\n     */\n    public Object in(String propertyName, Object[] values) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [in] with propertyName [\" +\n                    propertyName + \"] and values [\" + values + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        return addToCriteria(Restrictions.in(propertyName, values));\n    }","id":83758,"modified_method":"/**\n     * Applys a \"in\" contrain on the specified property\n     * @param propertyName The property name\n     * @param values A collection of values\n     *\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria in(String propertyName, Object[] values) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [in] with propertyName [\" +\n                    propertyName + \"] and values [\" + values + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        addToCriteria(Restrictions.in(propertyName, values));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that tests if the first property is less than or equal to the second property\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public Object leProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [leProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        return addToCriteria(Restrictions.leProperty(propertyName, otherPropertyName));\n    }","id":83759,"modified_method":"/**\n     * Creates a Criterion that tests if the first property is less than or equal to the second property\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria leProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [leProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        addToCriteria(Restrictions.leProperty(propertyName, otherPropertyName));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a \"greater than\" Criterion based on the specified property name and value\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @return A Criterion instance\n     */\n    public Object gt(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [gt] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        return addToCriteria(Restrictions.gt(propertyName, propertyValue));\n    }","id":83760,"modified_method":"/**\n     * Creates a \"greater than\" Criterion based on the specified property name and value\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria gt(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [gt] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        addToCriteria(Restrictions.gt(propertyName, propertyValue));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to return the row count\n     *\n     */\n    public void rowCount() {\n        rowCount(null);\n    }","id":83761,"modified_method":"/**\n     * Adds a projection that allows the criteria to return the row count\n     *\n     */\n    public org.grails.datastore.mapping.query.api.Projections rowCount() {\n        return rowCount(null);\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that contrains a collection property to be not equal to the given size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public Object sizeNe(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeNe] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        return addToCriteria(Restrictions.sizeNe(propertyName, size));\n    }","id":83762,"modified_method":"/**\n     * Creates a Criterion that contrains a collection property to be not equal to the given size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria sizeNe(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeNe] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        addToCriteria(Restrictions.sizeNe(propertyName, size));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * A projection that selects a property name\n     * @param propertyName The name of the property\n     */\n    public void property(String propertyName) {\n        property(propertyName, null);\n    }","id":83763,"modified_method":"/**\n     * A projection that selects a property name\n     * @param propertyName The name of the property\n     */\n    public org.grails.datastore.mapping.query.api.Projections property(String propertyName) {\n        return property(propertyName, null);\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to retrieve a  minimum property value\n     *\n     * @param alias The alias to use\n     */\n    public void min(String propertyName, String alias) {\n        final AggregateProjection aggregateProjection = Projections.min(calculatePropertyName(propertyName));\n        addProjectionToList(aggregateProjection, alias);\n    }","id":83764,"modified_method":"/**\n     * Adds a projection that allows the criteria to retrieve a  minimum property value\n     *\n     * @param alias The alias to use\n     */\n    public org.grails.datastore.mapping.query.api.Projections min(String propertyName, String alias) {\n        final AggregateProjection aggregateProjection = Projections.min(calculatePropertyName(propertyName));\n        addProjectionToList(aggregateProjection, alias);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a \"greater than or equal to\" Criterion based on the specified property name and value\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @return A Criterion instance\n     */\n    public Object ge(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [ge] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        return addToCriteria(Restrictions.ge(propertyName, propertyValue));\n    }","id":83765,"modified_method":"/**\n     * Creates a \"greater than or equal to\" Criterion based on the specified property name and value\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria ge(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [ge] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        addToCriteria(Restrictions.ge(propertyName, propertyValue));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * A distinct projection that takes a list\n     *\n     * @param propertyNames The list of distince property names\n     * @param alias The alias to use\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public void distinct(Collection propertyNames, String alias) {\n        ProjectionList list = Projections.projectionList();\n        for (Object o : propertyNames) {\n            list.add(Projections.property(calculatePropertyName(o.toString())));\n        }\n        final Projection proj = Projections.distinct(list);\n        addProjectionToList(proj, alias);\n    }","id":83766,"modified_method":"/**\n     * A distinct projection that takes a list\n     *\n     * @param propertyNames The list of distince property names\n     * @param alias The alias to use\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public org.grails.datastore.mapping.query.api.Projections distinct(Collection propertyNames, String alias) {\n        ProjectionList list = Projections.projectionList();\n        for (Object o : propertyNames) {\n            list.add(Projections.property(calculatePropertyName(o.toString())));\n        }\n        final Projection proj = Projections.distinct(list);\n        addProjectionToList(proj, alias);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to return the property average value\n     *\n     * @param propertyName The name of the property\n     */\n    public void avg(String propertyName) {\n        avg(propertyName, null);\n    }","id":83767,"modified_method":"/**\n     * Adds a projection that allows the criteria to return the property average value\n     *\n     * @param propertyName The name of the property\n     */\n    public org.grails.datastore.mapping.query.api.Projections avg(String propertyName) {\n        return avg(propertyName, null);\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that compares to class properties for equality\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public Object eqProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [eqProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        return addToCriteria(Restrictions.eqProperty(propertyName, otherPropertyName));\n    }","id":83768,"modified_method":"/**\n     * Creates a Criterion that compares to class properties for equality\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria eqProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [eqProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        addToCriteria(Restrictions.eqProperty(propertyName, otherPropertyName));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to retrieve a  maximum property value\n     *\n     * @param propertyName The name of the property\n     * @param alias The alias to use\n     */\n    public void max(String propertyName, String alias) {\n        final AggregateProjection proj = Projections.max(calculatePropertyName(propertyName));\n        addProjectionToList(proj, alias);\n    }","id":83769,"modified_method":"/**\n     * Adds a projection that allows the criteria to retrieve a  maximum property value\n     *\n     * @param propertyName The name of the property\n     * @param alias The alias to use\n     */\n    public org.grails.datastore.mapping.query.api.Projections max(String propertyName, String alias) {\n        final AggregateProjection proj = Projections.max(calculatePropertyName(propertyName));\n        addProjectionToList(proj, alias);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Orders by the specified property name (defaults to ascending)\n     *\n     * @param propertyName The property name to order by\n     * @return A Order instance\n     */\n    public Object order(String propertyName) {\n        if (criteria == null) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [order] with propertyName [\" +\n                    propertyName + \"]not allowed here.\"));\n        }\n        propertyName = calculatePropertyName(propertyName);\n        Order o = Order.asc(propertyName);\n        if (paginationEnabledList) {\n            orderEntries.add(o);\n        }\n        else {\n            criteria.addOrder(o);\n        }\n        return o;\n    }","id":83770,"modified_method":"/**\n     * Orders by the specified property name (defaults to ascending)\n     *\n     * @param propertyName The property name to order by\n     * @return A Order instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria order(String propertyName) {\n        if (criteria == null) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [order] with propertyName [\" +\n                    propertyName + \"]not allowed here.\"));\n        }\n        propertyName = calculatePropertyName(propertyName);\n        Order o = Order.asc(propertyName);\n        if (paginationEnabledList) {\n            orderEntries.add(o);\n        }\n        else {\n            criteria.addOrder(o);\n        }\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion with from the specified property name and \"rlike\" (a regular expression version of \"like\") expression\n     * @param propertyName The property name\n     * @param propertyValue The ilike value\n     *\n     * @return A Criterion instance\n     */\n    public Object rlike(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [rlike] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        return addToCriteria(new RlikeExpression(propertyName, propertyValue));\n    }","id":83771,"modified_method":"/**\n     * Creates a Criterion with from the specified property name and \"rlike\" (a regular expression version of \"like\") expression\n     * @param propertyName The property name\n     * @param propertyValue The ilike value\n     *\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria rlike(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [rlike] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        addToCriteria(new RlikeExpression(propertyName, propertyValue));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a \"between\" Criterion based on the property name and specified lo and hi values\n     * @param propertyName The property name\n     * @param lo The low value\n     * @param hi The high value\n     * @return A Criterion instance\n     */\n    public Object between(String propertyName, Object lo, Object hi) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [between] with propertyName [\" +\n                    propertyName + \"]  not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        return addToCriteria(Restrictions.between(propertyName, lo, hi));\n    }","id":83772,"modified_method":"/**\n     * Creates a \"between\" Criterion based on the property name and specified lo and hi values\n     * @param propertyName The property name\n     * @param lo The low value\n     * @param hi The high value\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria between(String propertyName, Object lo, Object hi) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [between] with propertyName [\" +\n                    propertyName + \"]  not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        addToCriteria(Restrictions.between(propertyName, lo, hi));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Applies a sql restriction to the results to allow something like:\n      <pre>\n       def results = Person.withCriteria {\n           sqlRestriction \"char_length(first_name) <= 4\"\n       }\n      <\/pre>\n     *\n     * @param sqlRestriction the sql restriction\n     * @return a Criterion instance\n     */\n    public Object sqlRestriction(String sqlRestriction) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sqlRestriction] with value [\" +\n                    sqlRestriction + \"] not allowed here.\"));\n        }\n        return addToCriteria(Restrictions.sqlRestriction(sqlRestriction));\n    }","id":83773,"modified_method":"/**\n     * Applies a sql restriction to the results to allow something like:\n      <pre>\n       def results = Person.withCriteria {\n           sqlRestriction \"char_length(first_name) <= 4\"\n       }\n      <\/pre>\n     *\n     * @param sqlRestriction the sql restriction\n     * @return a Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria sqlRestriction(String sqlRestriction) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sqlRestriction] with value [\" +\n                    sqlRestriction + \"] not allowed here.\"));\n        }\n        addToCriteria(Restrictions.sqlRestriction(sqlRestriction));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion with from the specified property name and \"ilike\" (a case sensitive version of \"like\") expression\n     * @param propertyName The property name\n     * @param propertyValue The ilike value\n     *\n     * @return A Criterion instance\n     */\n    public Object ilike(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [ilike] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        return addToCriteria(Restrictions.ilike(propertyName, propertyValue));\n    }","id":83774,"modified_method":"/**\n     * Creates a Criterion with from the specified property name and \"ilike\" (a case sensitive version of \"like\") expression\n     * @param propertyName The property name\n     * @param propertyValue The ilike value\n     *\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria ilike(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [ilike] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        addToCriteria(Restrictions.ilike(propertyName, propertyValue));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to return the row count\n     *\n     * @param alias The alias to use\n     */\n    public void rowCount(String alias) {\n        final Projection proj = Projections.rowCount();\n        addProjectionToList(proj, alias);\n    }","id":83775,"modified_method":"/**\n     * Adds a projection that allows the criteria to return the row count\n     *\n     * @param alias The alias to use\n     */\n    public org.grails.datastore.mapping.query.api.Projections rowCount(String alias) {\n        final Projection proj = Projections.rowCount();\n        addProjectionToList(proj, alias);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * A distinct projection that takes a list\n     *\n     * @param propertyNames The list of distince property names\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public void distinct(Collection propertyNames) {\n        distinct(propertyNames, null);\n    }","id":83776,"modified_method":"/**\n     * A distinct projection that takes a list\n     *\n     * @param propertyNames The list of distince property names\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public org.grails.datastore.mapping.query.api.Projections distinct(Collection propertyNames) {\n        return distinct(propertyNames, null);\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to retrieve a  minimum property value\n     *\n     * @param propertyName The name of the property\n     */\n    public void min(String propertyName) {\n        min(propertyName, null);\n    }","id":83777,"modified_method":"/**\n     * Adds a projection that allows the criteria to retrieve a  minimum property value\n     *\n     * @param propertyName The name of the property\n     */\n    public org.grails.datastore.mapping.query.api.Projections min(String propertyName) {\n        return min(propertyName, null);\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that tests if the first property is greater than the second property\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public Object gtProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [gtProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        return addToCriteria(Restrictions.gtProperty(propertyName, otherPropertyName));\n    }","id":83778,"modified_method":"/**\n     * Creates a Criterion that tests if the first property is greater than the second property\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria gtProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [gtProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        addToCriteria(Restrictions.gtProperty(propertyName, otherPropertyName));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a \"less than or equal to\" Criterion based on the specified property name and value\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @return A Criterion instance\n     */\n    public Object le(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [le] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        return addToCriteria(Restrictions.le(propertyName, propertyValue));\n    }","id":83779,"modified_method":"/**\n     * Creates a \"less than or equal to\" Criterion based on the specified property name and value\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria le(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [le] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        addToCriteria(Restrictions.le(propertyName, propertyValue));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that tests if the first property is less than the second property\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public Object ltProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [ltProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        return addToCriteria(Restrictions.ltProperty(propertyName, otherPropertyName));\n    }","id":83780,"modified_method":"/**\n     * Creates a Criterion that tests if the first property is less than the second property\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria ltProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [ltProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        addToCriteria(Restrictions.ltProperty(propertyName, otherPropertyName));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that contrains a collection property to be greater than the given size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public Object sizeGt(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeGt] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        return addToCriteria(Restrictions.sizeGt(propertyName, size));\n    }","id":83781,"modified_method":"/**\n     * Creates a Criterion that contrains a collection property to be greater than the given size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria sizeGt(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeGt] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        addToCriteria(Restrictions.sizeGt(propertyName, size));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that contrains a collection property to be greater than or equal to the given size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public Object sizeGe(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeGe] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        return addToCriteria(Restrictions.sizeGe(propertyName, size));\n    }","id":83782,"modified_method":"/**\n     * Creates a Criterion that contrains a collection property to be greater than or equal to the given size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria sizeGe(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeGe] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        addToCriteria(Restrictions.sizeGe(propertyName, size));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that tests if the first property is greater than or equal to the second property\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public Object geProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [geProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        return addToCriteria(Restrictions.geProperty(propertyName, otherPropertyName));\n    }","id":83783,"modified_method":"/**\n     * Creates a Criterion that tests if the first property is greater than or equal to the second property\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria geProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [geProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        addToCriteria(Restrictions.geProperty(propertyName, otherPropertyName));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates an \"equals\" Criterion based on the specified property name and value.\n     * Supports case-insensitive search if the <code>params<\/code> map contains <code>true<\/code>\n     * under the 'ignoreCase' key.\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @param params optional map with customization parameters; currently only 'ignoreCase' is supported.\n     *\n     * @return A Criterion instance\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public Object eq(String propertyName, Object propertyValue, Map params) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [eq] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        SimpleExpression eq =  Restrictions.eq(propertyName, propertyValue);\n        if (params != null) {\n            Object ignoreCase = params.get(\"ignoreCase\");\n            if (ignoreCase instanceof Boolean && (Boolean)ignoreCase) {\n                eq = eq.ignoreCase();\n            }\n        }\n        return addToCriteria(eq);\n    }","id":83784,"modified_method":"/**\n     * Creates an \"equals\" Criterion based on the specified property name and value.\n     * Supports case-insensitive search if the <code>params<\/code> map contains <code>true<\/code>\n     * under the 'ignoreCase' key.\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @param params optional map with customization parameters; currently only 'ignoreCase' is supported.\n     *\n     * @return A Criterion instance\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public org.grails.datastore.mapping.query.api.Criteria eq(String propertyName, Object propertyValue, Map params) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [eq] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        SimpleExpression eq =  Restrictions.eq(propertyName, propertyValue);\n        if (params != null) {\n            Object ignoreCase = params.get(\"ignoreCase\");\n            if (ignoreCase instanceof Boolean && (Boolean)ignoreCase) {\n                eq = eq.ignoreCase();\n            }\n        }\n        addToCriteria(eq);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * A projection that selects a distince property name\n     * @param propertyName The property name\n     */\n    public void distinct(String propertyName) {\n        distinct(propertyName, null);\n    }","id":83785,"modified_method":"/**\n     * A projection that selects a distince property name\n     * @param propertyName The property name\n     */\n    public org.grails.datastore.mapping.query.api.Projections distinct(String propertyName) {\n        distinct(propertyName, null);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that compares to class properties for !equality\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public Object neProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [neProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        return addToCriteria(Restrictions.neProperty(propertyName, otherPropertyName));\n    }","id":83786,"modified_method":"/**\n     * Creates a Criterion that compares to class properties for !equality\n     * @param propertyName The first property name\n     * @param otherPropertyName The second property name\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria neProperty(String propertyName, String otherPropertyName) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [neProperty] with propertyName [\" +\n                    propertyName + \"] and other property name [\" + otherPropertyName + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        otherPropertyName = calculatePropertyName(otherPropertyName);\n        addToCriteria(Restrictions.neProperty(propertyName, otherPropertyName));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to retrieve the sum of the results of a property\n     *\n     * @param propertyName The name of the property\n     */\n    public void sum(String propertyName) {\n        sum(propertyName, null);\n    }","id":83787,"modified_method":"/**\n     * Adds a projection that allows the criteria to retrieve the sum of the results of a property\n     *\n     * @param propertyName The name of the property\n     */\n    public org.grails.datastore.mapping.query.api.Projections sum(String propertyName) {\n        return sum(propertyName, null);\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to retrieve the sum of the results of a property\n     *\n     * @param propertyName The name of the property\n     * @param alias The alias to use\n     */\n    public void sum(String propertyName, String alias) {\n        final AggregateProjection proj = Projections.sum(calculatePropertyName(propertyName));\n        addProjectionToList(proj, alias);\n    }","id":83788,"modified_method":"/**\n     * Adds a projection that allows the criteria to retrieve the sum of the results of a property\n     *\n     * @param propertyName The name of the property\n     * @param alias The alias to use\n     */\n    public org.grails.datastore.mapping.query.api.Projections sum(String propertyName, String alias) {\n        final AggregateProjection proj = Projections.sum(calculatePropertyName(propertyName));\n        addProjectionToList(proj, alias);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * A projection that selects a distince property name\n     * @param propertyName The property name\n     * @param alias The alias to use\n     */\n    public void distinct(String propertyName, String alias) {\n        final Projection proj = Projections.distinct(Projections.property(calculatePropertyName(propertyName)));\n        addProjectionToList(proj,alias);\n    }","id":83789,"modified_method":"/**\n     * A projection that selects a distince property name\n     * @param propertyName The property name\n     * @param alias The alias to use\n     */\n    public org.grails.datastore.mapping.query.api.Projections distinct(String propertyName, String alias) {\n        final Projection proj = Projections.distinct(Projections.property(calculatePropertyName(propertyName)));\n        addProjectionToList(proj,alias);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to retrieve a  maximum property value\n     *\n     * @param propertyName The name of the property\n     */\n    public void max(String propertyName) {\n        max(propertyName, null);\n    }","id":83790,"modified_method":"/**\n     * Adds a projection that allows the criteria to retrieve a  maximum property value\n     *\n     * @param propertyName The name of the property\n     */\n    public org.grails.datastore.mapping.query.api.Projections max(String propertyName) {\n        return max(propertyName, null);\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a \"less than\" Criterion based on the specified property name and value\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @return A Criterion instance\n     */\n    public Object lt(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [lt] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        return addToCriteria(Restrictions.lt(propertyName, propertyValue));\n    }","id":83791,"modified_method":"/**\n     * Creates a \"less than\" Criterion based on the specified property name and value\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria lt(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [lt] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        addToCriteria(Restrictions.lt(propertyName, propertyValue));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Orders by the specified property name and direction\n     *\n     * @param propertyName The property name to order by\n     * @param direction Either \"asc\" for ascending or \"desc\" for descending\n     *\n     * @return A Order instance\n     */\n    public Object order(String propertyName, String direction) {\n        if (criteria == null) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [order] with propertyName [\" +\n                    propertyName + \"]not allowed here.\"));\n        }\n        propertyName = calculatePropertyName(propertyName);\n        Order o;\n        if (direction.equals(ORDER_DESCENDING)) {\n            o = Order.desc(propertyName);\n        }\n        else {\n            o = Order.asc(propertyName);\n        }\n        if (paginationEnabledList) {\n            orderEntries.add(o);\n        }\n        else {\n            criteria.addOrder(o);\n        }\n        return o;\n    }","id":83792,"modified_method":"/**\n     * Orders by the specified property name and direction\n     *\n     * @param propertyName The property name to order by\n     * @param direction Either \"asc\" for ascending or \"desc\" for descending\n     *\n     * @return A Order instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria order(String propertyName, String direction) {\n        if (criteria == null) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [order] with propertyName [\" +\n                    propertyName + \"]not allowed here.\"));\n        }\n        propertyName = calculatePropertyName(propertyName);\n        Order o;\n        if (direction.equals(ORDER_DESCENDING)) {\n            o = Order.desc(propertyName);\n        }\n        else {\n            o = Order.asc(propertyName);\n        }\n        if (paginationEnabledList) {\n            orderEntries.add(o);\n        }\n        else {\n            criteria.addOrder(o);\n        }\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a \"not equal\" Criterion based on the specified property name and value\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @return The criterion object\n     */\n    public Object ne(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [ne] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        return addToCriteria(Restrictions.ne(propertyName, propertyValue));\n    }","id":83793,"modified_method":"/**\n     * Creates a \"not equal\" Criterion based on the specified property name and value\n     * @param propertyName The property name\n     * @param propertyValue The property value\n     * @return The criterion object\n     */\n    public org.grails.datastore.mapping.query.api.Criteria ne(String propertyName, Object propertyValue) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [ne] with propertyName [\" +\n                    propertyName + \"] and value [\" + propertyValue + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        propertyValue = calculatePropertyValue(propertyValue);\n        addToCriteria(Restrictions.ne(propertyName, propertyValue));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that contrains a collection property by size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public Object sizeEq(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeEq] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        return addToCriteria(Restrictions.sizeEq(propertyName, size));\n    }","id":83794,"modified_method":"/**\n     * Creates a Criterion that contrains a collection property by size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria sizeEq(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeEq] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        addToCriteria(Restrictions.sizeEq(propertyName, size));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * A projection that selects a property name\n     * @param propertyName The name of the property\n     * @param alias The alias to use\n     */\n    public void property(String propertyName, String alias) {\n        final PropertyProjection propertyProjection = Projections.property(calculatePropertyName(propertyName));\n        addProjectionToList(propertyProjection, alias);\n    }","id":83795,"modified_method":"/**\n     * A projection that selects a property name\n     * @param propertyName The name of the property\n     * @param alias The alias to use\n     */\n    public org.grails.datastore.mapping.query.api.Projections property(String propertyName, String alias) {\n        final PropertyProjection propertyProjection = Projections.property(calculatePropertyName(propertyName));\n        addProjectionToList(propertyProjection, alias);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Creates a Criterion that contrains a collection property to be less than to the given size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public Object sizeLt(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeLt] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        return addToCriteria(Restrictions.sizeLt(propertyName, size));\n    }","id":83796,"modified_method":"/**\n     * Creates a Criterion that contrains a collection property to be less than to the given size\n     *\n     * @param propertyName The property name\n     * @param size The size to constrain by\n     *\n     * @return A Criterion instance\n     */\n    public org.grails.datastore.mapping.query.api.Criteria sizeLt(String propertyName, int size) {\n        if (!validateSimpleExpression()) {\n            throwRuntimeException(new IllegalArgumentException(\"Call to [sizeLt] with propertyName [\" +\n                    propertyName + \"] and size [\" + size + \"] not allowed here.\"));\n        }\n\n        propertyName = calculatePropertyName(propertyName);\n        addToCriteria(Restrictions.sizeLt(propertyName, size));\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to return the distinct property count\n     *\n     * @param propertyName The name of the property\n     */\n    public void countDistinct(String propertyName) {\n        countDistinct(propertyName, null);\n    }","id":83797,"modified_method":"/**\n     * Adds a projection that allows the criteria to return the distinct property count\n     *\n     * @param propertyName The name of the property\n     */\n    public org.grails.datastore.mapping.query.api.Projections countDistinct(String propertyName) {\n        return countDistinct(propertyName, null);\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Adds a projection that allows the criteria to return the distinct property count\n     *\n     * @param propertyName The name of the property\n     * @param alias The alias to use\n     */\n    public void countDistinct(String propertyName, String alias) {\n        final CountProjection proj = Projections.countDistinct(calculatePropertyName(propertyName));\n        addProjectionToList(proj, alias);\n    }","id":83798,"modified_method":"/**\n     * Adds a projection that allows the criteria to return the distinct property count\n     *\n     * @param propertyName The name of the property\n     * @param alias The alias to use\n     */\n    public org.grails.datastore.mapping.query.api.Projections countDistinct(String propertyName, String alias) {\n        final CountProjection proj = Projections.countDistinct(calculatePropertyName(propertyName));\n        addProjectionToList(proj, alias);\n        return this;\n    }","commit_id":"868d2d25667e3c84f890dab7ba7261457a965184","url":"https://github.com/grails/grails-core"},{"original_method":"public void render(int indentX, int indentY, List<AboutBoxLine> lines) throws OverflowException {\n        x = indentX;\n        y = indentY;\n        ApplicationInfoEx appInfo = (ApplicationInfoEx)ApplicationInfo.getInstance();\n        for (AboutBoxLine line : lines) {\n          final String s = line.getText();\n          setFont(line.isBold() ? myBoldFont : myFont);\n          if (line.getUrl() != null) {\n            g2.setColor(myLinkColor);\n            FontMetrics metrics = g2.getFontMetrics(font);\n            myLinks.add(new Link(new Rectangle(x, yBase + y - fontAscent, metrics.stringWidth(s), fontHeight), line.getUrl()));\n          }\n          else {\n            g2.setColor(appInfo.getAboutForeground());\n          }\n          renderString(s, indentX);\n          if (!line.isKeepWithNext() && !line.equals(lines.get(lines.size()-1))) {\n            lineFeed(indentX, s);\n          }\n        }\n      }","id":83799,"modified_method":"public void render(int indentX, int indentY, List<AboutBoxLine> lines) throws OverflowException {\n        x = indentX;\n        y = indentY;\n        ApplicationInfoEx appInfo = (ApplicationInfoEx)ApplicationInfo.getInstance();\n        for (AboutBoxLine line : lines) {\n          final String s = line.getText();\n          setFont(line.isBold() ? myBoldFont : myFont);\n          if (line.getUrl() != null) {\n            g2.setColor(myLinkColor);\n            FontMetrics metrics = g2.getFontMetrics(font);\n            myLinks.add(new Link(new Rectangle(x, yBase + y - fontAscent, metrics.stringWidth(s), fontHeight), line.getUrl()));\n          }\n          else {\n            g2.setColor(Gray.x33);\n          }\n          renderString(s, indentX);\n          if (!line.isKeepWithNext() && !line.equals(lines.get(lines.size()-1))) {\n            lineFeed(indentX, s);\n          }\n        }\n      }","commit_id":"db190c9c50188be0920f82229f79d09d571a04ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void paintChildren(Graphics g) {\n      super.paintChildren(g);\n\n      Graphics2D g2 = (Graphics2D)g;\n      UISettings.setupAntialiasing(g);\n\n      Font labelFont = JBUI.Fonts.label();\n      if (SystemInfo.isWindows) {\n        labelFont = JBUI.Fonts.create(\"Tahoma\", 12);\n      }\n\n      for (int labelSize = JBUI.scale(10); labelSize != JBUI.scale(6); labelSize -= 1) {\n        myLinks.clear();\n        g2.setPaint(myColor);\n        myImage.paintIcon(this, g2, 0, 0);\n\n        g2.setColor(myColor);\n        TextRenderer renderer = new TextRenderer(0, 165, 398, 120, g2);\n        UIUtil.setupComposite(g2);\n        myFont = labelFont.deriveFont(Font.PLAIN, labelSize);\n        myBoldFont = labelFont.deriveFont(Font.BOLD, labelSize + 1);\n        try {\n          renderer.render(30, 0, myLines);\n          break;\n        }\n        catch (TextRenderer.OverflowException ignore) { }\n      }\n\n      ApplicationInfo appInfo = ApplicationInfo.getInstance();\n      Rectangle aboutLogoRect = appInfo.getAboutLogoRect();\n      if (aboutLogoRect != null) {\n        myLinks.add(new Link(aboutLogoRect, appInfo.getCompanyURL()));\n      }\n\n      if (appInfo instanceof ApplicationInfoImpl) {\n        g2.setColor(((ApplicationInfoImpl)appInfo).getCopyrightForeground());\n        if (SystemInfo.isMac) {\n          g2.setFont(JBUI.Fonts.miniFont());\n        }\n        else {\n          g2.setFont(JBUI.Fonts.create(\"Tahoma\", 10));\n        }\n      } else {\n        g2.setColor(JBColor.BLACK);\n      }\n      g2.drawString(\"\\u00A9 2000\\u2013\" + Calendar.getInstance().get(Calendar.YEAR) + \" JetBrains s.r.o. All rights reserved.\", JBUI.scale(30), JBUI.scale(284));\n    }","id":83800,"modified_method":"@Override\n    protected void paintChildren(Graphics g) {\n      super.paintChildren(g);\n\n      Graphics2D g2 = (Graphics2D)g;\n      UISettings.setupAntialiasing(g);\n\n      Font labelFont = JBUI.Fonts.label();\n      if (SystemInfo.isWindows) {\n        labelFont = JBUI.Fonts.create(\"Tahoma\", 12);\n      }\n\n      int startFontSize = Registry.is(\"ide.new.about\") ? 14 : 10;\n      for (int labelSize = JBUI.scale(startFontSize); labelSize != JBUI.scale(6); labelSize -= 1) {\n        myLinks.clear();\n        g2.setPaint(myColor);\n        myImage.paintIcon(this, g2, 0, 0);\n\n        g2.setColor(myColor);\n        TextRenderer renderer = createTextRenderer(g2);\n        UIUtil.setupComposite(g2);\n        myFont = labelFont.deriveFont(Font.PLAIN, labelSize);\n        myBoldFont = labelFont.deriveFont(Font.BOLD, labelSize + 1);\n        try {\n          renderer.render(30, 0, myLines);\n          break;\n        }\n        catch (TextRenderer.OverflowException ignore) { }\n      }\n\n      ApplicationInfo appInfo = ApplicationInfo.getInstance();\n      Rectangle aboutLogoRect = appInfo.getAboutLogoRect();\n      if (aboutLogoRect != null) {\n        myLinks.add(new Link(aboutLogoRect, appInfo.getCompanyURL()));\n      }\n\n      if (appInfo instanceof ApplicationInfoImpl) {\n        g2.setColor(((ApplicationInfoImpl)appInfo).getCopyrightForeground());\n        if (SystemInfo.isMac) {\n          g2.setFont(JBUI.Fonts.miniFont());\n        }\n        else {\n          g2.setFont(JBUI.Fonts.create(\"Tahoma\", 10));\n        }\n      } else {\n        g2.setColor(JBColor.BLACK);\n      }\n\n      if (Registry.is(\"ide.new.about\")) {\n        g2.setColor(Gray.x33);\n        g2.setFont(JBUI.Fonts.label(12));\n      }\n      final int copyrightX = Registry.is(\"ide.new.about\") ? JBUI.scale(100) : JBUI.scale(30);\n      final int copyrightY = Registry.is(\"ide.new.about\") ? JBUI.scale(390) : JBUI.scale(284);\n      g2.drawString(\"\\u00A9 2000\\u2013\" + Calendar.getInstance().get(Calendar.YEAR) + \" JetBrains s.r.o. All rights reserved.\", copyrightX, copyrightY);\n    }","commit_id":"db190c9c50188be0920f82229f79d09d571a04ed","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void findSettingsChanged() {\n    if (isShowing()) {\n      showResultsPopupIfNeed();\n    }\n    final ModalityState state = ModalityState.current();\n    finishPreviousPreviewSearch();\n    mySearchRescheduleOnCancellationsAlarm.cancelAllRequests();\n    applyTo(myModel, false);\n    FindManager.getInstance(myProject).getFindInProjectModel().copyFrom(myModel);\n    ((FindManagerImpl)FindManager.getInstance(myProject)).changeGlobalSettings(/*findModel*/myModel);\n\n\n    ValidationInfo result = getValidationInfo(/*findModel*/myModel);\n\n    final ProgressIndicatorBase progressIndicatorWhenSearchStarted = new ProgressIndicatorBase();\n    myResultsPreviewSearchProgress = progressIndicatorWhenSearchStarted;\n\n    final DefaultTableModel model = new DefaultTableModel() {\n      @Override\n      public boolean isCellEditable(int row, int column) {\n        return false;\n      }\n    };\n\n    model.addColumn(\"Usages\");\n\n    myCodePreviewComponent.setVisible(false);\n\n    myResultsPreviewTable.setModel(model);\n\n    if (result != null) {\n      myResultsPreviewTable.getEmptyText().setText(UIBundle.message(\"message.nothingToShow\"));\n      return;\n    }\n\n    myResultsPreviewTable.getColumnModel().getColumn(0).setCellRenderer(new FindDialog.UsageTableCellRenderer());\n    myResultsPreviewTable.getEmptyText().setText(\"Searching...\");\n\n    final AtomicInteger resultsCount = new AtomicInteger();\n\n    ProgressIndicatorUtils.scheduleWithWriteActionPriority(myResultsPreviewSearchProgress, new ReadTask() {\n      @Override\n      public void computeInReadAction(@NotNull ProgressIndicator indicator) {\n        final UsageViewPresentation presentation =\n          FindInProjectUtil.setupViewPresentation(FindSettings.getInstance().isShowResultsInSeparateView(), /*findModel*/myModel.clone());\n        final boolean showPanelIfOnlyOneUsage = !FindSettings.getInstance().isSkipResultsWithOneUsage();\n\n        final FindUsagesProcessPresentation processPresentation =\n          FindInProjectUtil.setupProcessPresentation(myProject, showPanelIfOnlyOneUsage, presentation);\n        FindInProjectUtil.findUsages(myModel.clone(), myProject, new Processor<UsageInfo>() {\n          @Override\n          public boolean process(final UsageInfo info) {\n            final Usage usage = UsageInfo2UsageAdapter.CONVERTER.fun(info);\n            usage.getPresentation().getIcon(); // cache icon\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                model.addRow(new Object[]{usage});\n                myCodePreviewComponent.setVisible(true);\n                if (model.getRowCount() == 1 && myResultsPreviewTable.getModel() == model) {\n                  myResultsPreviewTable.setRowSelectionInterval(0, 0);\n                }\n                scheduleUpdateResultsPopupBounds();\n              }\n            }, state);\n            return resultsCount.incrementAndGet() < ShowUsagesAction.USAGES_PAGE_SIZE;\n          }\n        }, processPresentation);\n        boolean succeeded = !progressIndicatorWhenSearchStarted.isCanceled();\n        if (succeeded) {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              if (progressIndicatorWhenSearchStarted == myResultsPreviewSearchProgress && !myResultsPreviewSearchProgress.isCanceled()) {\n                int occurrences = resultsCount.get();\n                if (occurrences == 0) myResultsPreviewTable.getEmptyText().setText(UIBundle.message(\"message.nothingToShow\"));\n                myCodePreviewComponent.setVisible(occurrences > 0);\n                scheduleUpdateResultsPopupBounds();\n              }\n            }\n          }, state);\n        }\n      }\n\n      @Override\n      public void onCanceled(@NotNull ProgressIndicator indicator) {\n        if (isShowing() && progressIndicatorWhenSearchStarted == myResultsPreviewSearchProgress) {\n          scheduleResultsUpdate();\n        }\n      }\n    });\n  }","id":83801,"modified_method":"private void findSettingsChanged() {\n    if (isShowing()) {\n      showResultsPopupIfNeed();\n    }\n    final ModalityState state = ModalityState.current();\n    finishPreviousPreviewSearch();\n    mySearchRescheduleOnCancellationsAlarm.cancelAllRequests();\n    applyTo(myModel, false);\n    FindManager.getInstance(myProject).getFindInProjectModel().copyFrom(myModel);\n    ((FindManagerImpl)FindManager.getInstance(myProject)).changeGlobalSettings(myModel);\n    FindSettings.getInstance().setDefaultScopeName(myScopeCombo.getSelectedScopeName());\n\n\n    ValidationInfo result = getValidationInfo(/*findModel*/myModel);\n\n    final ProgressIndicatorBase progressIndicatorWhenSearchStarted = new ProgressIndicatorBase();\n    myResultsPreviewSearchProgress = progressIndicatorWhenSearchStarted;\n\n    final DefaultTableModel model = new DefaultTableModel() {\n      @Override\n      public boolean isCellEditable(int row, int column) {\n        return false;\n      }\n    };\n\n    model.addColumn(\"Usages\");\n\n    myCodePreviewComponent.setVisible(false);\n\n    myResultsPreviewTable.setModel(model);\n\n    if (result != null) {\n      myResultsPreviewTable.getEmptyText().setText(UIBundle.message(\"message.nothingToShow\"));\n      return;\n    }\n\n    myResultsPreviewTable.getColumnModel().getColumn(0).setCellRenderer(new FindDialog.UsageTableCellRenderer());\n    myResultsPreviewTable.getEmptyText().setText(\"Searching...\");\n\n    final AtomicInteger resultsCount = new AtomicInteger();\n\n    ProgressIndicatorUtils.scheduleWithWriteActionPriority(myResultsPreviewSearchProgress, new ReadTask() {\n      @Override\n      public void computeInReadAction(@NotNull ProgressIndicator indicator) {\n        final UsageViewPresentation presentation =\n          FindInProjectUtil.setupViewPresentation(FindSettings.getInstance().isShowResultsInSeparateView(), /*findModel*/myModel.clone());\n        final boolean showPanelIfOnlyOneUsage = !FindSettings.getInstance().isSkipResultsWithOneUsage();\n\n        final FindUsagesProcessPresentation processPresentation =\n          FindInProjectUtil.setupProcessPresentation(myProject, showPanelIfOnlyOneUsage, presentation);\n        FindInProjectUtil.findUsages(myModel.clone(), myProject, new Processor<UsageInfo>() {\n          @Override\n          public boolean process(final UsageInfo info) {\n            final Usage usage = UsageInfo2UsageAdapter.CONVERTER.fun(info);\n            usage.getPresentation().getIcon(); // cache icon\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                model.addRow(new Object[]{usage});\n                myCodePreviewComponent.setVisible(true);\n                if (model.getRowCount() == 1 && myResultsPreviewTable.getModel() == model) {\n                  myResultsPreviewTable.setRowSelectionInterval(0, 0);\n                }\n                scheduleUpdateResultsPopupBounds();\n              }\n            }, state);\n            return resultsCount.incrementAndGet() < ShowUsagesAction.USAGES_PAGE_SIZE;\n          }\n        }, processPresentation);\n        boolean succeeded = !progressIndicatorWhenSearchStarted.isCanceled();\n        if (succeeded) {\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              if (progressIndicatorWhenSearchStarted == myResultsPreviewSearchProgress && !myResultsPreviewSearchProgress.isCanceled()) {\n                int occurrences = resultsCount.get();\n                if (occurrences == 0) myResultsPreviewTable.getEmptyText().setText(UIBundle.message(\"message.nothingToShow\"));\n                myCodePreviewComponent.setVisible(occurrences > 0);\n                StringBuilder info = new StringBuilder();\n                if (occurrences > 0) {\n                  info.append(Math.min(ShowUsagesAction.USAGES_PAGE_SIZE, occurrences));\n                  if (occurrences >= ShowUsagesAction.USAGES_PAGE_SIZE) {\n                    info.append(\"+\");\n                  }\n                  info.append(UIBundle.message(\"message.matches\", occurrences));\n                }\n                mySearchTextArea.setInfoText(info.toString());\n                scheduleUpdateResultsPopupBounds();\n              }\n            }\n          }, state);\n        }\n      }\n\n      @Override\n      public void onCanceled(@NotNull ProgressIndicator indicator) {\n        if (isShowing() && progressIndicatorWhenSearchStarted == myResultsPreviewSearchProgress) {\n          scheduleResultsUpdate();\n        }\n      }\n    });\n  }","commit_id":"031d9df76329bf02d2d4f74e0a2e3042479b8596","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SearchTextArea(@NotNull JTextArea textArea,boolean search) {\n    myTextArea = textArea;\n    setBorder(JBUI.Borders.empty(6, 6, 6, 8));\n    setLayout(new BorderLayout(JBUI.scale(4), 0));\n    myTextArea.addPropertyChangeListener(\"background\", this);\n    myTextArea.addFocusListener(this);\n    myTextArea.setBorder(null);\n    myTextArea.setOpaque(false);\n    JBScrollPane scrollPane = new JBScrollPane(myTextArea,\n                                               ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,\n                                               ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    scrollPane.getVerticalScrollBar().setBackground(UIUtil.TRANSPARENT_COLOR);\n    scrollPane.getViewport().setBorder(null);\n    scrollPane.getViewport().setOpaque(false);\n    scrollPane.setBorder(JBUI.Borders.emptyRight(2));\n    scrollPane.setOpaque(false);\n    ShowHistoryAction historyAction = new ShowHistoryAction(search);\n    ActionButton button =\n      new ActionButton(historyAction, historyAction.getTemplatePresentation(), ActionPlaces.UNKNOWN, new Dimension(JBUI.scale(16), JBUI.scale(16)));\n    button.setLook(new InplaceActionButtonLook());\n    JPanel p = new NonOpaquePanel(new BorderLayout());\n    p.add(button, BorderLayout.NORTH);\n    add(p, BorderLayout.WEST);\n    add(scrollPane, BorderLayout.CENTER);\n  }","id":83802,"modified_method":"public SearchTextArea(@NotNull JTextArea textArea,boolean search) {\n    myTextArea = textArea;\n    myTextArea.addPropertyChangeListener(\"background\", this);\n    myTextArea.addFocusListener(this);\n    myTextArea.setBorder(null);\n    myTextArea.setOpaque(false);\n    JBScrollPane scrollPane = new JBScrollPane(myTextArea,\n                                               ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,\n                                               ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n    scrollPane.getVerticalScrollBar().setBackground(UIUtil.TRANSPARENT_COLOR);\n    scrollPane.getViewport().setBorder(null);\n    scrollPane.getViewport().setOpaque(false);\n    scrollPane.setBorder(JBUI.Borders.emptyRight(2));\n    scrollPane.setOpaque(false);\n    ShowHistoryAction historyAction = new ShowHistoryAction(search);\n    ActionButton button =\n      new ActionButton(historyAction, historyAction.getTemplatePresentation(), ActionPlaces.UNKNOWN, new Dimension(JBUI.scale(16), JBUI.scale(16)));\n    button.setLook(new InplaceActionButtonLook());\n\n    myInfoLabel = new JBLabel(UIUtil.ComponentStyle.SMALL);\n    myInfoLabel.setForeground(JBColor.GRAY);\n\n    setBorder(JBUI.Borders.empty(6, 6, 6, 8));\n    setLayout(new MigLayout(\"flowx, ins 0, gapx \" + JBUI.scale(4) + \"px\"));\n    add(button, \"ay top, gaptop \" + JBUI.scale(2) + \"px\");\n    add(scrollPane, \"growx, pushx\");\n    add(myInfoLabel, \"ay top, gaptop \" + JBUI.scale(2) + \"px, gapright \" + JBUI.scale(6) + \"px\");\n  }","commit_id":"031d9df76329bf02d2d4f74e0a2e3042479b8596","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Creates an instance of <tt>CallPanel<\/tt>.\n     * @param mainFrame The main application window.\n     */\n    public CallManager(MainFrame mainFrame)\n    {\n        super(new BorderLayout());\n\n        this.mainFrame = mainFrame;\n\n        this.buttonsPanel\n                .setBorder(BorderFactory.createEmptyBorder(5, 0, 0, 0));\n\n        this.comboPanel.setBorder(BorderFactory.createEmptyBorder(10, 5, 0, 5));\n\n        this.init();\n    }","id":83803,"modified_method":"/**\n     * Creates an instance of <tt>CallManager<\/tt>.\n     * @param mainFrame The main application window.\n     */\n    public CallManager(MainFrame mainFrame)\n    {\n        super(new BorderLayout());\n\n        this.mainFrame = mainFrame;\n\n        phoneNumberCombo = new CallComboBox(this);\n        \n        this.buttonsPanel\n                .setBorder(BorderFactory.createEmptyBorder(5, 0, 0, 0));\n\n        this.comboPanel.setBorder(BorderFactory.createEmptyBorder(10, 5, 0, 5));\n\n        this.init();\n    }","commit_id":"e992e1a7e76ddde8c2e8bbcc57afc8d104321324","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>ActionEvent<\/tt> generated when user presses one of the\n     * buttons in this panel.\n     */\n    public void actionPerformed(ActionEvent e)\n    {\n        JButton button = (JButton) e.getSource();\n        String buttonName = button.getName();\n\n        if (buttonName.equalsIgnoreCase(\"call\")) {\n            OperationSetBasicTelephony telephony;\n\n            Object o = mainFrame.getContactListPanel()\n                .getContactList().getSelectedValue();\n\n            if(o != null && o instanceof MetaContact) {\n                MetaContact metaContact\n                    = (MetaContact)o;\n\n                Contact contact\n                    = getTelephonyContact(metaContact);\n\n                if(contact != null) {\n                    telephony\n                        = mainFrame.getTelephony(contact.getProtocolProvider());\n                \n                    Call createdCall;\n                    try {\n                        createdCall = telephony.createCall(contact);\n                        \n                        CallPanel callPanel = new CallPanel(\n                                createdCall, CallPanel.OUTGOING_CALL);\n                        mainFrame.addCallPanel(callPanel);\n                        \n                        activeCalls.put(createdCall, callPanel);\n                    }\n                    catch (OperationFailedException e1) {\n                        // TODO Auto-generated catch block\n                        e1.printStackTrace();\n                    }\n                }\n                else {\n                    //Message to user which says \"This contact could not be called!\"\n                }\n            }\n            else if(phoneNumberCombo.getSelectedItem() != null) {\n                ProtocolProviderService pps\n                    = getDefaultTelephonyProvider();\n\n                if(pps != null) {\n                    telephony = mainFrame.getTelephony(pps);\n\n                    Call createdCall;\n                    try {\n                        createdCall = telephony.createCall(\n                                phoneNumberCombo.getSelectedItem().toString());\n                        \n                        CallPanel callPanel = new CallPanel(\n                                createdCall, CallPanel.OUTGOING_CALL);\n                        mainFrame.addCallPanel(callPanel);\n                        \n                        activeCalls.put(createdCall, callPanel);\n                    }\n                    catch (OperationFailedException e1) {\n                        // TODO Auto-generated catch block\n                        e1.printStackTrace();\n                    }\n                    catch (ParseException e1) {\n                        // TODO Auto-generated catch block\n                        e1.printStackTrace();\n                    }\n                }\n            }\n            else {\n                //Message to user which says \"You must select a contact to call or enter a phone number\"\n            }\n        }\n        else if (buttonName.equalsIgnoreCase(\"hangup\")) {\n\n        }\n        else if (buttonName.equalsIgnoreCase(\"minimize\")) {\n\n            this.remove(comboPanel);\n            this.remove(buttonsPanel);\n\n            this.minimizeButtonPanel.removeAll();\n            this.minimizeButtonPanel.add(restoreButton);\n            this.isShown = false;\n\n            this.mainFrame.getContactListPanel()\n                .getContactList().requestFocus();\n\n            this.mainFrame.validate();\n        }\n        else if (buttonName.equalsIgnoreCase(\"restore\")) {\n\n            this.add(comboPanel, BorderLayout.NORTH);\n            this.add(buttonsPanel, BorderLayout.CENTER);\n\n            this.minimizeButtonPanel.removeAll();\n            this.minimizeButtonPanel.add(minimizeButton);\n            this.isShown = true;\n\n            this.mainFrame.validate();\n        }\n    }","id":83804,"modified_method":"/**\n     * Handles the <tt>ActionEvent<\/tt> generated when user presses one of the\n     * buttons in this panel.\n     */\n    public void actionPerformed(ActionEvent evt)\n    {\n        JButton button = (JButton) evt.getSource();\n        String buttonName = button.getName();\n\n        if (buttonName.equals(\"call\")) {\n            OperationSetBasicTelephony telephony;\n            \n            Object o = mainFrame.getContactListPanel().getContactList()\n                .getSelectedValue();\n            \n            //call button is pressed over an already open call panel\n            if(mainFrame.getSelectedCallPanel() != null \n                    && mainFrame.getSelectedCallPanel().getCallType() \n                        == CallPanel.INCOMING_CALL\n                    && mainFrame.getSelectedCallPanel().getCall().getCallState()\n                        == CallState.CALL_INITIALIZATION) {\n            \n                CallPanel callPanel = mainFrame.getSelectedCallPanel();\n                \n                Call call = callPanel.getCall();\n                \n                ProtocolProviderService pps\n                    = call.getProtocolProvider();\n                \n                Iterator participants = call.getCallParticipants();\n                \n                while(participants.hasNext()) {\n                    CallParticipant participant\n                        = (CallParticipant)participants.next();\n                    answerCall(pps, participant);\n                }\n            }\n            //call button is pressed when a meta contact is selected\n            else if(isCallMetaContact && o != null && o instanceof MetaContact) {\n                \n                MetaContact metaContact\n                    = (MetaContact)o;\n\n                Contact contact = getTelephonyContact(metaContact);\n                \n                if(contact != null) {\n                    telephony\n                        = mainFrame.getTelephony(contact.getProtocolProvider());\n                \n                    Call createdCall;\n                    try {\n                        createdCall = telephony.createCall(contact);\n                        \n                        CallPanel callPanel = new CallPanel(\n                                this, createdCall, CallPanel.OUTGOING_CALL);\n                        \n                        mainFrame.addCallPanel(callPanel);\n                        \n                        activeCalls.put(createdCall, callPanel);\n                    }\n                    catch (OperationFailedException e) {                        \n                        logger.error(\"The call could not be created: \" + e);\n                    }\n                }\n                else {\n                    JOptionPane.showMessageDialog(this.mainFrame,\n                            Messages.getString(\"contactNotSupportingTelephony\"),\n                            Messages.getString(\"warning\"),\n                            JOptionPane.WARNING_MESSAGE);\n                }\n            }\n            //if no contact is selected checks if the user has chosen or has\n            //writen something in the phone combo box\n            else if(!phoneNumberCombo.isComboFieldEmpty()) {\n                \n                ProtocolProviderService pps\n                    = getDefaultTelephonyProvider();\n                \n                if(pps != null) {\n                    telephony = mainFrame.getTelephony(pps);\n\n                    Call createdCall;\n                    try {\n                        createdCall = telephony.createCall(\n                                phoneNumberCombo.getSelectedItem().toString());\n                        \n                        CallPanel callPanel = new CallPanel(\n                                this, createdCall, CallPanel.OUTGOING_CALL);\n                        \n                        mainFrame.addCallPanel(callPanel);\n                        \n                        activeCalls.put(createdCall, callPanel);\n                    }\n                    catch (OperationFailedException e) {\n                        logger.error(\"The call could not be created: \" + e);\n                    }\n                    catch (ParseException e) {\n                        logger.error(\"The call could not be created: \" + e);\n                    }\n                }\n            }\n        }\n        else if (buttonName.equalsIgnoreCase(\"hangup\")) {\n            CallPanel selectedCallPanel = this.mainFrame.getSelectedCallPanel();\n            \n            if(selectedCallPanel != null) {\n                Call call = selectedCallPanel.getCall();\n                \n                ProtocolProviderService pps\n                    = call.getProtocolProvider();\n                \n                OperationSetBasicTelephony telephony\n                    = mainFrame.getTelephony(pps);\n                \n                Iterator participants = call.getCallParticipants();\n                \n                while(participants.hasNext()) {\n                    try {\n                        //now we hang up the first call participant in the call\n                        telephony.hangupCallParticipant(\n                            (CallParticipant)participants.next());\n                    }\n                    catch (OperationFailedException e) {\n                        logger.error(\"Hang up was not successful: \" + e);\n                    }\n                }\n                \n                activeCalls.remove(call);\n                mainFrame.removeCallPanel(selectedCallPanel);\n                updateButtonsStateAccordingToSelectedPanel();\n            }\n        }\n        else if (buttonName.equalsIgnoreCase(\"minimize\")) {\n\n            this.remove(comboPanel);\n            this.remove(buttonsPanel);\n\n            this.minimizeButtonPanel.removeAll();\n            this.minimizeButtonPanel.add(restoreButton);\n            this.isShown = false;\n\n            this.mainFrame.getContactListPanel()\n                .getContactList().requestFocus();\n\n            this.mainFrame.validate();\n        }\n        else if (buttonName.equalsIgnoreCase(\"restore\")) {\n\n            this.add(comboPanel, BorderLayout.NORTH);\n            this.add(buttonsPanel, BorderLayout.CENTER);\n\n            this.minimizeButtonPanel.removeAll();\n            this.minimizeButtonPanel.add(minimizeButton);\n            this.isShown = true;\n\n            this.mainFrame.validate();\n        }\n    }","commit_id":"e992e1a7e76ddde8c2e8bbcc57afc8d104321324","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * For the given MetaContact returns the protocol contact that supports\n     * a basic telephony operation.\n     * @param metaContact the MetaContac we are trying to call\n     * @return returns the protocol contact that supports a basic telephony\n     * operation\n     */\n    private Contact getTelephonyContact(\n            MetaContact metaContact)\n    {\n        String telephonySet\n            = OperationSetBasicTelephony.class.getName();\n\n        Iterator i = metaContact.getContacts();\n        while(i.hasNext()) {\n            Contact contact = (Contact)i.next();\n\n            if(contact.getProtocolProvider()\n                .getSupportedOperationSets()\n                    .containsKey(telephonySet)) {\n\n                return contact;\n            }\n        }\n        return null;\n    }","id":83805,"modified_method":"/**\n     * For the given MetaContact returns the protocol contact that supports\n     * a basic telephony operation.\n     * @param metaContact the MetaContac we are trying to call\n     * @return returns the protocol contact that supports a basic telephony\n     * operation\n     */\n    private Contact getTelephonyContact(\n            MetaContact metaContact)\n    {\n        Iterator i = metaContact.getContacts();\n        while(i.hasNext()) {\n            Contact contact = (Contact)i.next();\n\n            OperationSetBasicTelephony telephony\n                = mainFrame.getTelephony(contact.getProtocolProvider());\n            \n            if(telephony != null)\n                return contact;\n        }\n        return null;\n    }","commit_id":"e992e1a7e76ddde8c2e8bbcc57afc8d104321324","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes and constructs this panel.\n     */\n    private void init()\n    {\n        this.phoneNumberCombo.setEditable(true);\n\n        this.comboPanel.add(phoneNumberCombo, BorderLayout.CENTER);\n        // this.add(comboPanel, BorderLayout.NORTH);\n\n        this.callButton.setName(\"call\");\n        this.hangupButton.setName(\"hangup\");\n        this.minimizeButton.setName(\"minimize\");\n        this.restoreButton.setName(\"restore\");\n\n        this.callButton.addActionListener(this);\n        this.hangupButton.addActionListener(this);\n        this.minimizeButton.addActionListener(this);\n        this.restoreButton.addActionListener(this);\n\n        this.buttonsPanel.add(callButton);\n        this.buttonsPanel.add(hangupButton);\n\n        this.add(minimizeButtonPanel, BorderLayout.SOUTH);\n    }","id":83806,"modified_method":"/**\n     * Initializes and constructs this panel.\n     */\n    private void init()\n    {\n        this.phoneNumberCombo.setEditable(true);\n                \n        this.comboPanel.add(phoneNumberCombo, BorderLayout.CENTER);\n        // this.add(comboPanel, BorderLayout.NORTH);\n\n        this.callButton.setName(\"call\");\n        this.hangupButton.setName(\"hangup\");\n        this.minimizeButton.setName(\"minimize\");\n        this.restoreButton.setName(\"restore\");\n\n        this.callButton.addActionListener(this);\n        this.hangupButton.addActionListener(this);\n        this.minimizeButton.addActionListener(this);\n        this.restoreButton.addActionListener(this);\n\n        this.buttonsPanel.add(callButton);\n        this.buttonsPanel.add(hangupButton);\n        \n        this.callButton.setEnabled(false);\n        \n        this.hangupButton.setEnabled(false);\n\n        this.add(minimizeButtonPanel, BorderLayout.SOUTH);\n    }","commit_id":"e992e1a7e76ddde8c2e8bbcc57afc8d104321324","url":"https://github.com/jitsi/jitsi"},{"original_method":"public String getTitle()\n    {        \n        return null;\n    }","id":83807,"modified_method":"/**\n     * Returns the title of this call panel. The title is now the name of the\n     * first participant in the list of the call participants. Should be\n     * improved in the future.\n     * \n     * @return the title of this call panel\n     */\n    public String getTitle()\n    {        \n        return title;\n    }","commit_id":"e992e1a7e76ddde8c2e8bbcc57afc8d104321324","url":"https://github.com/jitsi/jitsi"},{"original_method":"public CallPanel(Call call, String callType)\n    {\n        this.call = call;\n        \n        if(callType.equals(INCOMING_CALL)) {\n            this.processIncomingCall();\n        }\n        else {\n            this.processOutgoingCall();\n        }\n    }","id":83808,"modified_method":"/**\n     * Creates an instance of CallPanel for the given call and call type.\n     * @param call the call \n     * @param callType INCOMING_CALL and OUTGOING_CALL \n     */\n    public CallPanel(CallManager callManager, Call call, String callType)\n    {\n        this.call = call;\n        \n        this.callType = callType;\n     \n        this.callManager = callManager;\n        this.call.addCallChangeListener(this);\n        \n        this.mainPanel.setBorder(\n                BorderFactory.createEmptyBorder(20, 10, 20, 10));\n        \n        int participantsCount = call.getCallParticipantsCount();\n        \n        if(participantsCount > 0) {\n            CallParticipant participant\n                = ((CallParticipant)call.getCallParticipants().next());\n            \n            if(participant.getDisplayName() != null)\n                this.title = participant.getDisplayName();\n            else\n                this.title = participant.getAddress();\n            \n            if(participantsCount < 2) {\n                this.mainPanel.setLayout(new BorderLayout());\n            }\n            else {\n                int rows = participantsCount/2 + participantsCount%2;\n                this.mainPanel.setLayout(new GridLayout(rows, 2));\n            }\n        }        \n        \n        this.getViewport().add(mainPanel);\n     \n        this.init();\n    }","commit_id":"e992e1a7e76ddde8c2e8bbcc57afc8d104321324","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\r\n     * Handles the <tt>ActionEvent<\/tt> triggered when user clicks on on the\r\n     * buttons. Shows the account registration wizard when user clicks on \"New\".\r\n     *\r\n     * @param evt the action event that has just occurred.\r\n     */\r\n    public void actionPerformed(ActionEvent evt)\r\n    {\r\n        Object sourceButton = evt.getSource();\r\n\r\n        if (sourceButton.equals(newButton))\r\n        {\r\n            NewAccountDialog.showNewAccountDialog();\r\n        }\r\n        else if (sourceButton.equals(removeButton))\r\n        {\r\n            Account account = accountList.getSelectedAccount();\r\n\r\n            if (account == null)\r\n                return;\r\n\r\n            AccountID accountID = account.getAccountID();\r\n\r\n            ProtocolProviderFactory providerFactory =\r\n                GuiActivator.getProtocolProviderFactory(\r\n                    accountID.getProtocolName());\r\n\r\n            if (providerFactory != null)\r\n            {\r\n                int result = JOptionPane.showConfirmDialog(\r\n                    this,\r\n                    GuiActivator.getResources()\r\n                        .getI18NString(\"service.gui.REMOVE_ACCOUNT_MESSAGE\"),\r\n                    GuiActivator.getResources().getI18NString(\r\n                        \"service.gui.REMOVE_ACCOUNT\"),\r\n                    JOptionPane.YES_NO_OPTION);\r\n\r\n                if (result == JOptionPane.YES_OPTION)\r\n                {\r\n                    ConfigurationService configService\r\n                        = GuiActivator.getConfigurationService();\r\n                    String prefix\r\n                        = \"net.java.sip.communicator.impl.gui.accounts\";\r\n                    List<String> accounts\r\n                        = configService.getPropertyNamesByPrefix(prefix, true);\r\n\r\n                    for (String accountRootPropName : accounts)\r\n                    {\r\n                        String accountUID\r\n                            = configService.getString(accountRootPropName);\r\n\r\n                        if (accountUID.equals(accountID.getAccountUniqueID()))\r\n                        {\r\n                            configService.setProperty(accountRootPropName, null);\r\n                            break;\r\n                        }\r\n                    }\r\n                    boolean isUninstalled\r\n                        = providerFactory.uninstallAccount(accountID);\r\n\r\n                    if (isUninstalled)\r\n                    {\r\n                        accountList.ensureAccountRemoved(accountID);\r\n\r\n                        // Notify the corresponding wizard that the account\r\n                        // would be removed.\r\n                        AccountRegWizardContainerImpl wizardContainer\r\n                            = (AccountRegWizardContainerImpl) GuiActivator\r\n                                .getUIService().getAccountRegWizardContainer();\r\n\r\n                        AccountRegistrationWizard wizard\r\n                            = wizardContainer.getProtocolWizard(\r\n                                    account.getProtocolProvider());\r\n\r\n                        wizard.accountRemoved(account.getProtocolProvider());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (sourceButton.equals(editButton))\r\n        {\r\n            Account account = accountList.getSelectedAccount();\r\n\r\n            if (account == null)\r\n                return;\r\n\r\n            AccountRegWizardContainerImpl wizard =\r\n                (AccountRegWizardContainerImpl) GuiActivator.getUIService()\r\n                    .getAccountRegWizardContainer();\r\n\r\n            wizard.setTitle(GuiActivator.getResources().getI18NString(\r\n                \"service.gui.ACCOUNT_REGISTRATION_WIZARD\"));\r\n\r\n            wizard.modifyAccount(account.getProtocolProvider());\r\n            wizard.showDialog(false);\r\n        }\r\n    }","id":83809,"modified_method":"/**\r\n     * Handles the <tt>ActionEvent<\/tt> triggered when user clicks on on the\r\n     * buttons. Shows the account registration wizard when user clicks on \"New\".\r\n     *\r\n     * @param evt the action event that has just occurred.\r\n     */\r\n    public void actionPerformed(ActionEvent evt)\r\n    {\r\n        Object sourceButton = evt.getSource();\r\n\r\n        if (sourceButton.equals(newButton))\r\n        {\r\n            NewAccountDialog.showNewAccountDialog();\r\n        }\r\n        else if (sourceButton.equals(removeButton))\r\n        {\r\n            Account account = accountList.getSelectedAccount();\r\n\r\n            if (account == null)\r\n                return;\r\n\r\n            AccountID accountID = account.getAccountID();\r\n\r\n            ProtocolProviderFactory providerFactory =\r\n                GuiActivator.getProtocolProviderFactory(\r\n                    accountID.getProtocolName());\r\n\r\n            if (providerFactory != null)\r\n            {\r\n                int result = JOptionPane.showConfirmDialog(\r\n                    this,\r\n                    GuiActivator.getResources()\r\n                        .getI18NString(\"service.gui.REMOVE_ACCOUNT_MESSAGE\"),\r\n                    GuiActivator.getResources().getI18NString(\r\n                        \"service.gui.REMOVE_ACCOUNT\"),\r\n                    JOptionPane.YES_NO_OPTION);\r\n\r\n                if (result == JOptionPane.YES_OPTION)\r\n                {\r\n                    ConfigurationService configService\r\n                        = GuiActivator.getConfigurationService();\r\n                    String prefix\r\n                        = \"net.java.sip.communicator.impl.gui.accounts\";\r\n                    List<String> accounts\r\n                        = configService.getPropertyNamesByPrefix(prefix, true);\r\n\r\n                    for (String accountRootPropName : accounts)\r\n                    {\r\n                        String accountUID\r\n                            = configService.getString(accountRootPropName);\r\n\r\n                        if (accountUID.equals(accountID.getAccountUniqueID()))\r\n                        {\r\n                            configService.setProperty(accountRootPropName, null);\r\n                            break;\r\n                        }\r\n                    }\r\n                    boolean isUninstalled\r\n                        = providerFactory.uninstallAccount(accountID);\r\n\r\n                    if (isUninstalled)\r\n                    {\r\n                        accountList.ensureAccountRemoved(accountID);\r\n\r\n                        // Notify the corresponding wizard that the account\r\n                        // would be removed.\r\n                        AccountRegWizardContainerImpl wizardContainer\r\n                            = (AccountRegWizardContainerImpl) GuiActivator\r\n                                .getUIService().getAccountRegWizardContainer();\r\n\r\n                        ProtocolProviderService protocolProvider =\r\n                                                  account.getProtocolProvider();\r\n                        AccountRegistrationWizard wizard =\r\n                            wizardContainer.getProtocolWizard(protocolProvider);\r\n\r\n                        if (wizard != null)\r\n                            wizard.accountRemoved(protocolProvider);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (sourceButton.equals(editButton))\r\n        {\r\n            Account account = accountList.getSelectedAccount();\r\n\r\n            if (account == null)\r\n                return;\r\n\r\n            AccountRegWizardContainerImpl wizard =\r\n                (AccountRegWizardContainerImpl) GuiActivator.getUIService()\r\n                    .getAccountRegWizardContainer();\r\n\r\n            AccountRegistrationWizard protocolWizard =\r\n                        wizard.getProtocolWizard(account.getProtocolProvider());\r\n\r\n            ResourceManagementService resources = GuiActivator.getResources();\r\n            if (protocolWizard != null)\r\n            {\r\n                wizard.setTitle(resources.getI18NString(\r\n                                    \"service.gui.ACCOUNT_REGISTRATION_WIZARD\"));\r\n\r\n                wizard.modifyAccount(account.getProtocolProvider());\r\n                wizard.showDialog(false);\r\n            }\r\n            else\r\n            {\r\n                // There is no wizard for this account - just show an error\r\n                // dialog:\r\n                String title = resources.getI18NString(\"service.gui.ERROR\");\r\n                String message =\r\n                      resources.getI18NString(\"service.gui.EDIT_NOT_SUPPORTED\");\r\n                ErrorDialog dialog = new ErrorDialog(null, title, message);\r\n                dialog.setVisible(true);\r\n            }\r\n        }\r\n    }","commit_id":"773e1fa6f8aced4e4c31e2a5f85e6478b8a02412","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Constructs the <tt>ChatContactPanel<\/tt>.\n     */\n    private void init() {\n        this.personNameLabel.setText(contactItem.getDisplayName());\n        this.personNameLabel.setFont(this.getFont().deriveFont(Font.BOLD));\n        this.personNameLabel.setIcon(new ImageIcon(Constants\n                .getStatusIcon(status)));\n        // this.personPhotoLabel.setIcon(new ImageIcon(contactItem.getPhoto()));\n\n        this.callButton.setToolTipText(Messages.getString(\"call\"));\n        this.infoButton.setToolTipText(Messages.getString(\"userInfo\"));\n        this.sendFileButton.setToolTipText(Messages.getString(\"sendFile\"));\n\n        this.callButton.setName(\"call\");\n        this.infoButton.setName(\"info\");\n        \n        this.callButton.addActionListener(this);\n        this.infoButton.addActionListener(this);\n        \n        this.buttonsPanel.add(infoButton);\n        this.buttonsPanel.add(callButton);\n        this.buttonsPanel.add(sendFileButton);\n\n        this.contactNamePanel.add(personNameLabel);\n\n        this.mainPanel.add(buttonsPanel, BorderLayout.NORTH);\n        this.mainPanel.add(contactNamePanel, BorderLayout.CENTER);\n\n        this.add(personPhotoLabel, BorderLayout.WEST);\n        this.add(mainPanel, BorderLayout.CENTER);\n\n        // Disabled all unused buttons.\n        this.callButton.setEnabled(false);\n        this.sendFileButton.setEnabled(false);\n    }","id":83810,"modified_method":"/**\n     * Constructs the <tt>ChatContactPanel<\/tt>.\n     */\n    private void init() {\n        this.personNameLabel.setText(contactItem.getDisplayName());\n        this.personNameLabel.setFont(this.getFont().deriveFont(Font.BOLD));\n        this.personNameLabel.setIcon(new ImageIcon(Constants\n                .getStatusIcon(status)));\n        // this.personPhotoLabel.setIcon(new ImageIcon(contactItem.getPhoto()));\n\n        this.callButton.setToolTipText(Messages.getString(\"call\"));\n        this.infoButton.setToolTipText(Messages.getString(\"userInfo\"));\n        this.sendFileButton.setToolTipText(Messages.getString(\"sendFile\"));\n\n        this.callButton.setName(\"call\");\n        this.infoButton.setName(\"info\");\n        \n        this.callButton.addActionListener(this);\n        this.infoButton.addActionListener(this);\n        \n        this.buttonsPanel.add(infoButton);\n        this.buttonsPanel.add(callButton);\n        this.buttonsPanel.add(sendFileButton);\n\n        this.contactNamePanel.add(personNameLabel);\n\n        this.mainPanel.add(buttonsPanel, BorderLayout.NORTH);\n        this.mainPanel.add(contactNamePanel, BorderLayout.CENTER);\n\n        this.add(personPhotoLabel, BorderLayout.WEST);\n        this.add(mainPanel, BorderLayout.CENTER);\n\n        // Disabled all unused buttons.\n        this.callButton.setEnabled(false);\n        this.sendFileButton.setEnabled(false);\n        \n        this.updateProtocolContact(chatPanel.getProtocolContact());\n    }","commit_id":"9595133a7fc3863fc3b326929c737009989562a3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the protocol contact for this chat.\n     * @param protocolContact The subcontact for the protocol.\n     */\n    public void setProtocolContact(Contact protocolContact) {\n        this.protocolContact = protocolContact;\n    }","id":83811,"modified_method":"/**\n     * Sets the protocol contact for this chat.\n     * @param protocolContact The subcontact for the protocol.\n     */\n    public void setProtocolContact(Contact protocolContact) {\n        this.protocolContact = protocolContact;\n        \n        this.chatConferencePanel.updateProtocolContact(protocolContact);\n    }","commit_id":"9595133a7fc3863fc3b326929c737009989562a3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles the <tt>ActionEvent<\/tt>. Determines which menu item was\n     * selected and makes the appropriate operations.\n     */\n    public void actionPerformed(ActionEvent e){\n\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n        String itemName = menuItem.getName();\n        String itemText = menuItem.getText();\n\n        if (itemName.startsWith(addSubcontactPrefix)) {\n            \n            ProtocolProviderService pps\n                = mainFrame.getProtocolProviderForAccount(itemText);\n\n            if(pps != null) {\n                AddContactDialog dialog = new AddContactDialog(\n                        mainFrame,\n                        contactItem, pps);\n    \n                dialog.setLocation(\n                        Toolkit.getDefaultToolkit().getScreenSize().width/2\n                            - 250,\n                        Toolkit.getDefaultToolkit().getScreenSize().height/2\n                            - 100\n                        );\n    \n                dialog.setVisible(true);\n            }\n        }\n        else if (itemName.equalsIgnoreCase(\"sendMessage\")) {\n            ContactListPanel clistPanel = mainFrame.getContactListPanel();\n            SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(\n                    contactItem));\n        }\n        else if (itemName.equalsIgnoreCase(\"sendFile\")) {\n            // disabled\n        }\n        else if (itemName.equalsIgnoreCase(\"renameContact\")) {\n            RenameContactDialog dialog = new RenameContactDialog(\n                    mainFrame, contactItem);\n\n            dialog.setLocation(\n                    Toolkit.getDefaultToolkit().getScreenSize().width/2\n                        - 200,\n                    Toolkit.getDefaultToolkit().getScreenSize().height/2\n                        - 50\n                    );\n\n            dialog.setVisible(true);\n            \n            dialog.requestFocusInFiled();\n        }\n        else if (itemName.equalsIgnoreCase(\"viewHistory\")) {\n\n            HistoryWindow history;\n            \n            if(guiContactList.containsHistoryWindowForContact(contactItem)) {                \n                history = guiContactList.getHistoryWindowForContact(contactItem);\n                \n                if(history.getState() == JFrame.ICONIFIED)\n                    history.setState(JFrame.NORMAL);\n                \n                history.toFront();\n            }\n            else {\n                history = new HistoryWindow(\n                    this.mainFrame, this.contactItem);\n                \n                guiContactList.addHistoryWindowForContact(contactItem, history);\n                \n                history.setVisible(true);\n            }\n        }\n        else if (itemName.equalsIgnoreCase(\"userInfo\")) {\n            Contact defaultContact = contactItem.getDefaultContact();\n\n            ProtocolProviderService defaultProvider\n                = defaultContact.getProtocolProvider();\n\n            OperationSetWebContactInfo wContactInfo\n                = mainFrame.getWebContactInfo(defaultProvider);\n\n            CrossPlatformBrowserLauncher.openURL(\n                    wContactInfo.getWebContactInfo(defaultContact)\n                        .toString());\n        }\n        else if (itemName.startsWith(moveToPrefix)) {\n            \n            MetaContactGroup group\n                = mainFrame.getGroupByID(\n                        itemName.substring(moveToPrefix.length()));\n\n            if(group != null) {\n                mainFrame.getContactList().moveMetaContact(contactItem, group);\n            }\n        }\n        else if (itemName.startsWith(removeContactPrefix)) {\n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(removeContactPrefix.length()));\n\n            if(contact != null) {\n                new RemoveContactThread(contact).start();                \n            }\n            else {\n                new RemoveAllContactsThread().start();\n            }\n        }\n        else if(itemName.startsWith(moveSubcontactPrefix)) {\n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(moveSubcontactPrefix.length()));\n\n            guiContactList.addExcContactListListener(this);\n            guiContactList.setCursor(\n                    Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n            \n            this.moveDialog = new MoveSubcontactMessageDialog(mainFrame, this);\n            \n            this.moveDialog.setVisible(true);\n                        \n            if(contact != null) {\n                this.contactToMove = contact;                \n            }\n            else {\n                this.moveAllContacts = true;\n            }\n        }\n    }","id":83812,"modified_method":"/**\n     * Handles the <tt>ActionEvent<\/tt>. Determines which menu item was\n     * selected and makes the appropriate operations.\n     */\n    public void actionPerformed(ActionEvent e){\n\n        JMenuItem menuItem = (JMenuItem) e.getSource();\n        String itemName = menuItem.getName();\n        String itemText = menuItem.getText();\n\n        if (itemName.startsWith(addSubcontactPrefix)) {\n            \n            ProtocolProviderService pps\n                = mainFrame.getProtocolProviderForAccount(itemText);\n\n            if(pps != null) {\n                AddContactDialog dialog = new AddContactDialog(\n                        mainFrame,\n                        contactItem, pps);\n    \n                dialog.setLocation(\n                        Toolkit.getDefaultToolkit().getScreenSize().width/2\n                            - 250,\n                        Toolkit.getDefaultToolkit().getScreenSize().height/2\n                            - 100\n                        );\n    \n                dialog.setVisible(true);\n            }\n        }\n        else if (itemName.equalsIgnoreCase(\"sendMessage\")) {\n            ContactListPanel clistPanel = mainFrame.getContactListPanel();\n            SwingUtilities.invokeLater(clistPanel.new RunMessageWindow(\n                    contactItem));\n        }\n        else if (itemName.equalsIgnoreCase(\"sendFile\")) {\n            // disabled\n        }\n        else if (itemName.equalsIgnoreCase(\"renameContact\")) {\n            RenameContactDialog dialog = new RenameContactDialog(\n                    mainFrame, contactItem);\n\n            dialog.setLocation(\n                    Toolkit.getDefaultToolkit().getScreenSize().width/2\n                        - 200,\n                    Toolkit.getDefaultToolkit().getScreenSize().height/2\n                        - 50\n                    );\n\n            dialog.setVisible(true);\n            \n            dialog.requestFocusInFiled();\n        }\n        else if (itemName.equalsIgnoreCase(\"viewHistory\")) {\n\n            HistoryWindow history;\n            \n            if(guiContactList.containsHistoryWindowForContact(contactItem)) {                \n                history = guiContactList.getHistoryWindowForContact(contactItem);\n                \n                if(history.getState() == JFrame.ICONIFIED)\n                    history.setState(JFrame.NORMAL);\n                \n                history.toFront();\n            }\n            else {\n                history = new HistoryWindow(\n                    this.mainFrame, this.contactItem);\n                \n                guiContactList.addHistoryWindowForContact(contactItem, history);\n                \n                history.setVisible(true);\n            }\n        }\n        else if (itemName.startsWith(infoSubcontactPrefix)) {\n                        \n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(infoSubcontactPrefix.length()));\n            \n            ProtocolProviderService contactProvider\n                = contact.getProtocolProvider();\n\n            OperationSetWebContactInfo wContactInfo\n                = mainFrame.getWebContactInfo(contactProvider);\n\n            CrossPlatformBrowserLauncher.openURL(\n                    wContactInfo.getWebContactInfo(contact)\n                        .toString());\n        }\n        else if (itemName.startsWith(moveToPrefix)) {\n            \n            MetaContactGroup group\n                = mainFrame.getGroupByID(\n                        itemName.substring(moveToPrefix.length()));\n\n            if(group != null) {\n                mainFrame.getContactList().moveMetaContact(contactItem, group);\n            }\n        }\n        else if (itemName.startsWith(removeContactPrefix)) {\n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(removeContactPrefix.length()));\n\n            if(contact != null) {\n                new RemoveContactThread(contact).start();                \n            }\n            else {\n                new RemoveAllContactsThread().start();\n            }\n        }\n        else if(itemName.startsWith(moveSubcontactPrefix)) {\n            Contact contact = getContactFromMetaContact(\n                    itemName.substring(moveSubcontactPrefix.length()));\n\n            guiContactList.addExcContactListListener(this);\n            guiContactList.setCursor(\n                    Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR));\n            \n            this.moveDialog = new MoveSubcontactMessageDialog(mainFrame, this);\n            \n            this.moveDialog.setVisible(true);\n                        \n            if(contact != null) {\n                this.contactToMove = contact;                \n            }\n            else {\n                this.moveAllContacts = true;\n            }\n        }\n    }","commit_id":"9595133a7fc3863fc3b326929c737009989562a3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes the menu, by adding all containing menu items.\n     */\n    private void init() {\n\n        this.moveToMenu.setIcon(new ImageIcon(ImageLoader\n                .getImage(ImageLoader.GROUPS_16x16_ICON)));\n\n        this.addSubcontactMenu.setIcon(new ImageIcon(ImageLoader\n                .getImage(ImageLoader.ADD_CONTACT_16x16_ICON)));\n\n        this.removeContactMenu.setIcon(new ImageIcon(ImageLoader\n                .getImage(ImageLoader.DELETE_16x16_ICON)));\n        \n        this.moveSubcontactMenu.setIcon(new ImageIcon(ImageLoader\n                .getImage(ImageLoader.MOVE_CONTACT_ICON)));\n\n        //Initialize the addSubcontact menu.\n        Iterator providers = this.mainFrame.getProtocolProviders();\n\n        if(providers.hasNext()) {\n            JLabel infoLabel = new JLabel(Messages.getString(\"selectAccount\"));\n\n            infoLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));\n            infoLabel.setFont(Constants.FONT.deriveFont(Font.BOLD));\n\n            this.addSubcontactMenu.add(infoLabel);\n            this.addSubcontactMenu.addSeparator();\n        }\n\n        while (providers.hasNext()) {\n            ProtocolProviderService pps\n                = (ProtocolProviderService)providers.next();\n\n            String protocolName = pps.getProtocolName();\n\n            JMenuItem menuItem = new JMenuItem(pps.getAccountID()\n                    .getUserID(),\n                    new ImageIcon(Constants.getProtocolIcon(protocolName)));\n\n            menuItem.setName(addSubcontactPrefix + protocolName);\n            menuItem.addActionListener(this);\n\n            this.addSubcontactMenu.add(menuItem);\n        }\n\n        //Initialize moveTo menu.\n        Iterator groups = this.mainFrame.getAllGroups();\n\n        if(groups.hasNext()) {\n            JLabel infoLabel = new JLabel(Messages.getString(\"selectGroup\"));\n\n            infoLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));\n            infoLabel.setFont(Constants.FONT.deriveFont(Font.BOLD));\n\n            this.moveToMenu.add(infoLabel);\n            this.moveToMenu.addSeparator();\n        }\n\n        while (groups.hasNext()) {\n            MetaContactGroup group = (MetaContactGroup)groups.next();\n\n            JMenuItem menuItem = new JMenuItem(group.getGroupName());\n\n            menuItem.setName(moveToPrefix + group.getMetaUID());\n            menuItem.addActionListener(this);\n\n            this.moveToMenu.add(menuItem);\n        }\n\n        //Initialize removeContact menu.\n        Iterator contacts = contactItem.getContacts();\n\n        if (contactItem.getContactCount() > 1) {\n           JMenuItem allItem = new JMenuItem(Messages.getString(\"allContacts\"));\n           JMenuItem allItem1 = new JMenuItem(Messages.getString(\"allContacts\"));\n           \n           allItem.addActionListener(this);\n           allItem1.addActionListener(this);\n           \n           allItem.setName(removeContactPrefix + \"allContacts\");\n           allItem1.setName(moveSubcontactPrefix + \"allContacts\");\n           \n           this.removeContactMenu.add(allItem);\n           this.moveSubcontactMenu.add(allItem1);\n           this.removeContactMenu.addSeparator();\n           this.moveSubcontactMenu.addSeparator();\n        }\n\n        while (contacts.hasNext()) {\n            Contact contact = (Contact)contacts.next();\n\n            JMenuItem contactItem = new JMenuItem(contact.getDisplayName());\n            JMenuItem contactItem1 = new JMenuItem(contact.getDisplayName());\n\n            contactItem.setName(removeContactPrefix + contact.getAddress()\n                    + contact.getProtocolProvider().getProtocolName());\n\n            contactItem1.setName(moveSubcontactPrefix + contact.getAddress()\n                    + contact.getProtocolProvider().getProtocolName());\n            \n            contactItem.addActionListener(this);\n            contactItem1.addActionListener(this);\n            \n            this.removeContactMenu.add(contactItem);\n            this.moveSubcontactMenu.add(contactItem1);\n        }\n\n        this.add(sendMessageItem);\n        this.add(sendFileItem);\n\n        this.addSeparator();\n\n        this.add(moveToMenu);\n        this.add(moveSubcontactMenu);\n\n        this.addSeparator();\n\n        this.add(addSubcontactMenu);\n\n        this.addSeparator();\n\n        this.add(removeContactMenu);\n        this.add(renameContactItem);\n\n        this.addSeparator();\n\n        this.add(viewHistoryItem);\n        this.add(userInfoItem);\n\n        this.sendMessageItem.setName(\"sendMessage\");\n        this.sendFileItem.setName(\"sendFile\");\n        this.moveToMenu.setName(\"moveToGroup\");\n        this.addSubcontactMenu.setName(\"addSubcontact\");\n        this.renameContactItem.setName(\"renameContact\");\n        this.viewHistoryItem.setName(\"viewHistory\");\n        this.userInfoItem.setName(\"userInfo\");\n\n        this.sendMessageItem.addActionListener(this);\n        this.sendFileItem.addActionListener(this);\n        this.renameContactItem.addActionListener(this);\n        this.viewHistoryItem.addActionListener(this);\n        this.userInfoItem.addActionListener(this);\n\n        // Disable all menu items that do nothing.\n        this.sendFileItem.setEnabled(false);\n    }","id":83813,"modified_method":"/**\n     * Initializes the menu, by adding all containing menu items.\n     */\n    private void init() {\n\n        this.moveToMenu.setIcon(new ImageIcon(ImageLoader\n                .getImage(ImageLoader.GROUPS_16x16_ICON)));\n\n        this.addSubcontactMenu.setIcon(new ImageIcon(ImageLoader\n                .getImage(ImageLoader.ADD_CONTACT_16x16_ICON)));\n\n        this.removeContactMenu.setIcon(new ImageIcon(ImageLoader\n                .getImage(ImageLoader.DELETE_16x16_ICON)));\n        \n        this.moveSubcontactMenu.setIcon(new ImageIcon(ImageLoader\n                .getImage(ImageLoader.MOVE_CONTACT_ICON)));\n        \n        this.userInfoMenu.setIcon(new ImageIcon(ImageLoader\n            .getImage(ImageLoader.INFO_16x16_ICON)));\n\n        //Initialize the addSubcontact menu.\n        Iterator providers = this.mainFrame.getProtocolProviders();\n\n        if(providers.hasNext()) {\n            JLabel infoLabel = new JLabel(Messages.getString(\"selectAccount\"));\n\n            infoLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));\n            infoLabel.setFont(Constants.FONT.deriveFont(Font.BOLD));\n\n            this.addSubcontactMenu.add(infoLabel);\n            this.addSubcontactMenu.addSeparator();\n        }\n\n        while (providers.hasNext()) {\n            ProtocolProviderService pps\n                = (ProtocolProviderService)providers.next();\n\n            String protocolName = pps.getProtocolName();\n\n            JMenuItem menuItem = new JMenuItem(pps.getAccountID()\n                    .getUserID(),\n                    new ImageIcon(Constants.getProtocolIcon(protocolName)));\n\n            menuItem.setName(addSubcontactPrefix + protocolName);\n            menuItem.addActionListener(this);\n\n            this.addSubcontactMenu.add(menuItem);\n        }\n\n        //Initialize moveTo menu.\n        Iterator groups = this.mainFrame.getAllGroups();\n\n        if(groups.hasNext()) {\n            JLabel infoLabel = new JLabel(Messages.getString(\"selectGroup\"));\n\n            infoLabel.setBorder(BorderFactory.createEmptyBorder(0, 5, 0, 0));\n            infoLabel.setFont(Constants.FONT.deriveFont(Font.BOLD));\n\n            this.moveToMenu.add(infoLabel);\n            this.moveToMenu.addSeparator();\n        }\n\n        while (groups.hasNext()) {\n            MetaContactGroup group = (MetaContactGroup)groups.next();\n\n            JMenuItem menuItem = new JMenuItem(group.getGroupName());\n\n            menuItem.setName(moveToPrefix + group.getMetaUID());\n            menuItem.addActionListener(this);\n\n            this.moveToMenu.add(menuItem);\n        }\n\n        //Initialize removeContact menu.\n        Iterator contacts = contactItem.getContacts();\n\n        if (contactItem.getContactCount() > 1) {\n           JMenuItem allItem = new JMenuItem(Messages.getString(\"allContacts\"));\n           JMenuItem allItem1 = new JMenuItem(Messages.getString(\"allContacts\"));\n           \n           allItem.setFont(Constants.FONT.deriveFont(Font.BOLD));\n           allItem1.setFont(Constants.FONT.deriveFont(Font.BOLD));\n           \n           allItem.addActionListener(this);\n           allItem1.addActionListener(this);\n           \n           allItem.setName(removeContactPrefix + \"allContacts\");\n           allItem1.setName(moveSubcontactPrefix + \"allContacts\");\n           \n           this.removeContactMenu.add(allItem);\n           this.moveSubcontactMenu.add(allItem1);\n           this.removeContactMenu.addSeparator();\n           this.moveSubcontactMenu.addSeparator();\n        }\n\n        while (contacts.hasNext()) {\n            Contact contact = (Contact)contacts.next();\n\n            ProtocolProviderService protocolProvider\n                = contact.getProtocolProvider();\n            \n            String contactDisplayName = contact.getDisplayName();\n            \n            JMenuItem contactItem = new JMenuItem(contactDisplayName);\n            JMenuItem contactItem1 = new JMenuItem(contactDisplayName);\n            JMenuItem contactItem2 = new JMenuItem(contactDisplayName);\n\n            String protocolName = contact\n                .getProtocolProvider().getProtocolName();\n            Icon protocolIcon = new ImageIcon(\n                    Constants.getProtocolIcon(protocolName));\n            \n            contactItem.setIcon(protocolIcon);\n            contactItem1.setIcon(protocolIcon);\n            \n            contactItem.setName(removeContactPrefix + contact.getAddress()\n                    + protocolProvider.getProtocolName());\n\n            contactItem1.setName(moveSubcontactPrefix + contact.getAddress()\n                    + protocolProvider.getProtocolName());\n            \n            contactItem2.setName(infoSubcontactPrefix + contact.getAddress()\n                    + protocolProvider.getProtocolName());\n            \n            contactItem.addActionListener(this);\n            contactItem1.addActionListener(this);\n            contactItem2.addActionListener(this);\n            \n            this.removeContactMenu.add(contactItem);\n            this.moveSubcontactMenu.add(contactItem1);\n\n            OperationSetWebContactInfo wContactInfo\n                = mainFrame.getWebContactInfo(protocolProvider);\n            \n            if(wContactInfo == null) {\n                contactItem2.setEnabled(false);\n                contactItem2.setToolTipText(\n                        Messages.getString(\"dontSupportWebInfo\"));\n            }\n            this.userInfoMenu.add(contactItem2);\n        }\n\n        this.add(sendMessageItem);\n        this.add(sendFileItem);\n\n        this.addSeparator();\n\n        this.add(moveToMenu);\n        this.add(moveSubcontactMenu);\n\n        this.addSeparator();\n\n        this.add(addSubcontactMenu);\n\n        this.addSeparator();\n\n        this.add(removeContactMenu);\n        this.add(renameContactItem);\n\n        this.addSeparator();\n\n        this.add(viewHistoryItem);\n        this.add(userInfoMenu);\n\n        this.sendMessageItem.setName(\"sendMessage\");\n        this.sendFileItem.setName(\"sendFile\");\n        this.moveToMenu.setName(\"moveToGroup\");\n        this.addSubcontactMenu.setName(\"addSubcontact\");\n        this.renameContactItem.setName(\"renameContact\");\n        this.viewHistoryItem.setName(\"viewHistory\");\n        this.userInfoMenu.setName(\"userInfo\");\n\n        this.sendMessageItem.addActionListener(this);\n        this.sendFileItem.addActionListener(this);\n        this.renameContactItem.addActionListener(this);\n        this.viewHistoryItem.addActionListener(this);\n        this.userInfoMenu.addActionListener(this);\n\n        // Disable all menu items that do nothing.\n        this.sendFileItem.setEnabled(false);\n    }","commit_id":"9595133a7fc3863fc3b326929c737009989562a3","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void initMnemonics() {\n        this.sendMessageItem.setMnemonic(\n                Messages.getString(\"mnemonic.sendMessage\").charAt(0));\n        this.sendFileItem.setMnemonic(\n                Messages.getString(\"mnemonic.sendFile\").charAt(0));\n        this.moveToMenu.setMnemonic(\n                Messages.getString(\"mnemonic.moveTo\").charAt(0));\n        this.addSubcontactMenu.setMnemonic(\n                Messages.getString(\"mnemonic.addSubcontact\").charAt(0));\n        this.removeContactMenu.setMnemonic(\n                Messages.getString(\"mnemonic.removeContact\").charAt(0));\n        this.renameContactItem.setMnemonic(\n                Messages.getString(\"mnemonic.renameContact\").charAt(0));\n        this.viewHistoryItem.setMnemonic(\n                Messages.getString(\"mnemonic.viewHistory\").charAt(0));\n        this.userInfoItem.setMnemonic(\n                Messages.getString(\"mnemonic.userInfo\").charAt(0));\n    }","id":83814,"modified_method":"private void initMnemonics() {\n        this.sendMessageItem.setMnemonic(\n                Messages.getString(\"mnemonic.sendMessage\").charAt(0));\n        this.sendFileItem.setMnemonic(\n                Messages.getString(\"mnemonic.sendFile\").charAt(0));\n        this.moveToMenu.setMnemonic(\n                Messages.getString(\"mnemonic.moveTo\").charAt(0));\n        this.addSubcontactMenu.setMnemonic(\n                Messages.getString(\"mnemonic.addSubcontact\").charAt(0));\n        this.removeContactMenu.setMnemonic(\n                Messages.getString(\"mnemonic.removeContact\").charAt(0));\n        this.renameContactItem.setMnemonic(\n                Messages.getString(\"mnemonic.renameContact\").charAt(0));\n        this.viewHistoryItem.setMnemonic(\n                Messages.getString(\"mnemonic.viewHistory\").charAt(0));\n        this.userInfoMenu.setMnemonic(\n                Messages.getString(\"mnemonic.userInfo\").charAt(0));\n    }","commit_id":"9595133a7fc3863fc3b326929c737009989562a3","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * In the corresponding <tt>ChatContactPanel<\/tt> changes the name of the\n     * given <tt>Contact<\/tt>.\n     * \n     * @param contact the <tt>Contact<\/tt>, which has been renamed\n     */\n    public void renameContact(Contact contact)\n    {\n        ChatContactPanel chatContactPanel = null;\n        if(contacts.containsKey(contact))\n        {\n            chatContactPanel = (ChatContactPanel)contacts.get(contact);\n        \n            chatContactPanel.renameContact(contact.getDisplayName());\n        }        \n    }","id":83815,"modified_method":"/**\n     * In the corresponding <tt>ChatContactPanel<\/tt> changes the name of the\n     * given <tt>Contact<\/tt>.\n     * \n     * @param chatContact the <tt>ChatContact<\/tt> to be renamed\n     */\n    public void renameContact(ChatContact chatContact)\n    {\n        ChatContactPanel chatContactPanel = null;\n        if(chatContacts.containsKey(chatContact))\n        {\n            chatContactPanel = (ChatContactPanel)chatContacts.get(chatContact);\n        \n            chatContactPanel.renameContact(chatContact.getName());\n        }        \n    }","commit_id":"49e0985d606d8a3a8d0efafae4e73d4eaaba6589","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds a simple <tt>Contact<\/tt> to the list of contacts contained in the\n     * chat.\n     * \n     * @param contact the <tt>Contact<\/tt> to be added\n     */\n    public void addContact(Contact contact)\n    {\n        ChatContactPanel chatContactPanel = new ChatContactPanel(\n            chatPanel, contact);\n\n        this.contactsPanel.add(chatContactPanel);\n        \n        this.contacts.put(contact, chatContactPanel);\n    }","id":83816,"modified_method":"/**\n     * Adds a <tt>ChatContact<\/tt> to the list of contacts contained in the\n     * chat.\n     * \n     * @param chatContact the <tt>ChatContact<\/tt> to add\n     */\n    public void addContact(ChatContact chatContact)\n    {                \n        ChatContactPanel chatContactPanel = new ChatContactPanel(\n            chatPanel, chatContact);\n\n        this.contactsPanel.add(chatContactPanel);\n        \n        this.chatContacts.put(chatContact, chatContactPanel);\n    }","commit_id":"49e0985d606d8a3a8d0efafae4e73d4eaaba6589","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>ChatContactListPanel<\/tt>.\n     */\n    public ChatContactListPanel(ChatPanel chatPanel)\n    {\n        super(new BorderLayout(5, 5));\n\n        this.chatPanel = chatPanel;\n               \n        this.contactsPanel.setLayout(\n            new BoxLayout(contactsPanel, BoxLayout.Y_AXIS));\n        \n        this.setMinimumSize(new Dimension(150, 100));\n\n        this.init();\n    }","id":83817,"modified_method":"/**\n     * Creates an instance of <tt>ChatContactListPanel<\/tt>.\n     */\n    public ChatContactListPanel(ChatPanel chatPanel)\n    {\n        super(new BorderLayout(5, 5));\n\n        this.chatPanel = chatPanel;\n               \n        this.contactsPanel.setLayout(\n            new BoxLayout(contactsPanel, BoxLayout.Y_AXIS));\n        \n        this.setMinimumSize(new Dimension(150, 100));\n\n        this.contactsPanel.setLayout(new BoxLayout(this.contactsPanel,\n                BoxLayout.Y_AXIS));\n\n        this.mainPanel.add(contactsPanel, BorderLayout.NORTH);\n        this.contactsScrollPane.getViewport().add(this.mainPanel);\n\n        this.buttonPanel.add(addToChatButton);\n\n        this.add(contactsScrollPane, BorderLayout.CENTER);\n        this.add(buttonPanel, BorderLayout.SOUTH);\n\n        // Disable all unused buttons.\n        this.addToChatButton.setEnabled(false);\n    }","commit_id":"49e0985d606d8a3a8d0efafae4e73d4eaaba6589","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of the <tt>ChatContactPanel<\/tt>.\n     * \n     * @param chatPanel\n     * @param protocolContact\n     */\n    public ChatContactPanel(ChatPanel chatPanel, Contact protocolContact)\n    {\n        this(chatPanel, null, protocolContact);\n    }","id":83818,"modified_method":"/**\n     * Creates an instance of the <tt>ChatContactPanel<\/tt>.\n     * \n     * @param chatPanel the <tt>ChatPanel<\/tt>, to which this\n     * <tt>ChatContactPanel<\/tt> belongs to.\n     * @param chatContact the chat contact\n     */\n    public ChatContactPanel(ChatPanel chatPanel, ChatContact contact)\n    {\n        super(new BorderLayout(10, 5));\n\n        this.chatContact = contact;\n        \n        this.setPreferredSize(new Dimension(100, 60));\n        \n        this.setBorder(BorderFactory.createBevelBorder(BevelBorder.RAISED));\n\n        this.status = chatContact.getPresenceStatus();\n        this.chatPanel = chatPanel;\n\n        this.setOpaque(false);\n        this.mainPanel.setOpaque(false);\n        this.buttonsPanel.setOpaque(false);\n                \n        this.personNameLabel.setText(chatContact.getName());\n        this.personNameLabel.setFont(this.getFont().deriveFont(Font.BOLD));\n        this.personNameLabel.setIcon(new ImageIcon(Constants\n                .getStatusIcon(status)));\n                \n        this.callButton.setToolTipText(\n            Messages.getI18NString(\"call\").getText());\n        this.infoButton.setToolTipText(\n            Messages.getI18NString(\"userInfo\").getText());\n        this.sendFileButton.setToolTipText(\n            Messages.getI18NString(\"sendFile\").getText());\n\n        this.callButton.setName(\"call\");\n        this.infoButton.setName(\"info\");\n        \n        this.callButton.addActionListener(this);\n        this.infoButton.addActionListener(this);\n        \n        this.buttonsPanel.add(infoButton);\n        this.buttonsPanel.add(callButton);\n        this.buttonsPanel.add(sendFileButton);\n\n        this.mainPanel.add(buttonsPanel, BorderLayout.NORTH);\n        this.mainPanel.add(personNameLabel, BorderLayout.CENTER);\n\n        this.add(personPhotoLabel, BorderLayout.WEST);\n        this.add(mainPanel, BorderLayout.CENTER);\n\n        // Disabled all unused buttons.\n        this.callButton.setEnabled(false);\n        this.sendFileButton.setEnabled(false);\n        \n        //Load the contact photo.\n        new Thread()\n        {\n            public void run()\n            {   \n                contactPhotoIcon = chatContact.getImage();\n                \n                SwingUtilities.invokeLater(new Runnable(){\n                    public void run()\n                    {\n                        if(contactPhotoIcon != null)\n                        {\n                            personPhotoLabel.setBorder(\n                                    new SIPCommBorders.BoldRoundBorder());\n                            personPhotoLabel.setIcon(contactPhotoIcon);\n                        }\n                    }\n                });\n                \n            }\n        }.start();\n\n        ProtocolProviderService pps\n            = chatContact.getProtocolProvider();\n    \n        Object contactInfoOpSet\n            = pps.getOperationSet(OperationSetWebContactInfo.class);\n        \n        if(contactInfoOpSet == null)\n            infoButton.setEnabled(false);\n        else\n            infoButton.setEnabled(true);\n        \n        this.setStatusIcon(chatContact.getPresenceStatus());\n    }","commit_id":"49e0985d606d8a3a8d0efafae4e73d4eaaba6589","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * \n     */\n    public void actionPerformed(ActionEvent e)\n    {\n        JButton button = (JButton) e.getSource();\n        \n        MainFrame mainFrame = chatPanel.getChatWindow().getMainFrame();\n        \n        if(button.getName().equals(\"call\")) {\n            \n        }\n        else if(button.getName().equals(\"info\"))\n        {\n            ProtocolProviderService pps\n                = protocolContact.getProtocolProvider();\n\n            OperationSetWebContactInfo wContactInfo\n                = mainFrame.getWebContactInfoOpSet(pps);\n\n            if(wContactInfo != null) {\n                GuiActivator.getBrowserLauncher().openURL(\n                    wContactInfo.getWebContactInfo(protocolContact)\n                        .toString());\n            }            \n        }\n    }","id":83819,"modified_method":"/**\n     * \n     */\n    public void actionPerformed(ActionEvent e)\n    {\n        JButton button = (JButton) e.getSource();\n        \n        if(button.getName().equals(\"call\"))\n        {\n            //TODO: Implement the call functionality\n        }\n        else if(button.getName().equals(\"info\"))\n        {\n            ProtocolProviderService pps\n                = chatContact.getProtocolProvider();\n\n            Object contactInfoOpSet\n                = pps.getOperationSet(OperationSetWebContactInfo.class);\n\n            if(contactInfoOpSet != null) {\n                GuiActivator.getBrowserLauncher().openURL(\n                    ((OperationSetWebContactInfo)contactInfoOpSet)\n                        .getWebContactInfo(chatContact.getAddress())\n                        .toString());\n            }            \n        }\n    }","commit_id":"49e0985d606d8a3a8d0efafae4e73d4eaaba6589","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>ConferenceChatPanel<\/tt>.\n     *\n     * @param chatWindow the <tt>ChatWindow<\/tt> that contains this chat panel\n     * @param chatRoom the <tt>ChatRoom<\/tt> object, which provides us the multi\n     * user chat functionality\n     */\n    public ConferenceChatPanel(ChatWindow chatWindow, ChatRoom chatRoom)\n    {\n        super(chatWindow);\n\n        this.chatWindowManager = chatWindow.getMainFrame().getChatWindowManager();\n\n        this.chatRoom = chatRoom;\n\n        List membersList = chatRoom.getMembers();\n\n        for (int i = 0; i < membersList.size(); i ++)\n        {\n            getChatContactListPanel().addContact((Contact)membersList.get(i));\n        }\n\n        this.chatRoom.addMessageListener(this);\n        this.chatRoom.addChatRoomPropertyChangeListener(this);\n        this.chatRoom.addLocalUserStatusListener(this);\n        this.chatRoom.addMemberListener(this);\n    }","id":83820,"modified_method":"/**\n     * Creates an instance of <tt>ConferenceChatPanel<\/tt>.\n     *\n     * @param chatWindow the <tt>ChatWindow<\/tt> that contains this chat panel\n     * @param chatRoom the <tt>ChatRoom<\/tt> object, which provides us the multi\n     * user chat functionality\n     */\n    public ConferenceChatPanel(ChatWindow chatWindow, ChatRoom chatRoom)\n    {\n        super(chatWindow);\n\n        this.chatWindowManager = chatWindow.getMainFrame().getChatWindowManager();\n\n        this.chatRoom = chatRoom;\n\n        List membersList = chatRoom.getMembers();\n\n        for (int i = 0; i < membersList.size(); i ++)\n        {\n            ChatContact chatContact\n                = new ChatContact((ChatRoomMember)membersList.get(i));\n            \n            getChatContactListPanel()\n                .addContact(chatContact);\n        }\n\n        this.chatRoom.addMessageListener(this);\n        this.chatRoom.addChatRoomPropertyChangeListener(this);\n        this.chatRoom.addLocalUserStatusListener(this);\n        this.chatRoom.addMemberListener(this);\n    }","commit_id":"49e0985d606d8a3a8d0efafae4e73d4eaaba6589","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements the\n     * <tt>ContactPresenceStatusListener.contactPresenceStatusChanged<\/tt>.\n     * Updates all status related icons in this chat panel.\n     */\n    public void contactPresenceStatusChanged(\n        ContactPresenceStatusChangeEvent evt)\n    {   \n        Contact sourceContact = evt.getSourceContact();\n    \n        MainFrame mainFrame = getChatWindow().getMainFrame();\n        \n        MetaContact sourceMetaContact = mainFrame\n            .getContactList().findMetaContactByContact(sourceContact);\n    \n        if (sourceMetaContact != null && metaContact.equals(sourceMetaContact))\n        {   \n            contactSelectorBox.updateContactStatus(sourceContact);\n            \n            PresenceStatus status = contactSelectorBox\n                .getSelectedProtocolContact().getPresenceStatus();\n\n            getChatContactListPanel().updateContactStatus(metaContact);\n\n            String message = getChatConversationPanel().processMessage(\n                this.metaContact.getDisplayName(),\n                new Date(System.currentTimeMillis()),\n                Constants.SYSTEM_MESSAGE,\n                Messages.getI18NString(\"statusChangedChatMessage\",\n                        new String[]{status.getStatusName()}).getText());\n\n            getChatConversationPanel().appendMessageToEnd(message);\n            \n            if(Constants.TABBED_CHAT_WINDOW)\n            {                \n                if (getChatWindow().getChatTabCount() > 0) {\n                    getChatWindow().setTabIcon(this,\n                        new ImageIcon(Constants.getStatusIcon(status)));\n                }\n            }\n        }        \n    }","id":83821,"modified_method":"/**\n     * Implements the\n     * <tt>ContactPresenceStatusListener.contactPresenceStatusChanged<\/tt>.\n     * Updates all status related icons in this chat panel.\n     */\n    public void contactPresenceStatusChanged(\n        ContactPresenceStatusChangeEvent evt)\n    {   \n        Contact sourceContact = evt.getSourceContact();\n        \n        MetaContact sourceMetaContact = GuiActivator.getMetaContactListService()\n            .findMetaContactByContact(sourceContact);\n    \n        if (sourceMetaContact != null && metaContact.equals(sourceMetaContact))\n        {   \n            // Update the status of the given contact in the \"send via\" selector\n            // box.\n            contactSelectorBox.updateContactStatus(sourceContact);\n            \n            // Update the status of the source meta contact in the contact details\n            // panel on the right.\n            \n            if(sourceMetaContact != null\n                    && sourceMetaContact.getDefaultContact().equals(sourceContact))\n            {\n                ChatContact chatContact\n                    = findChatContactByMetaContact(sourceMetaContact);\n            \n                ChatContactPanel chatContactPanel\n                    = getChatContactListPanel()\n                        .getChatContactPanel(chatContact);\n                \n                chatContactPanel.setStatusIcon(\n                    chatContact.getPresenceStatus());\n            }\n            \n            PresenceStatus status = contactSelectorBox\n                .getSelectedProtocolContact().getPresenceStatus();\n\n            // Show a status message to the user.\n            String message = getChatConversationPanel().processMessage(\n                sourceContact.getAddress(),\n                new Date(System.currentTimeMillis()),\n                Constants.SYSTEM_MESSAGE,\n                Messages.getI18NString(\"statusChangedChatMessage\",\n                        new String[]{status.getStatusName()}).getText());\n\n            getChatConversationPanel().appendMessageToEnd(message);\n            \n            if(Constants.TABBED_CHAT_WINDOW)\n            {                \n                if (getChatWindow().getChatTabCount() > 0) {\n                    getChatWindow().setTabIcon(this,\n                        new ImageIcon(Constants.getStatusIcon(status)));\n                }\n            }\n        }        \n    }","commit_id":"49e0985d606d8a3a8d0efafae4e73d4eaaba6589","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Implements <tt>MetaContactListListener.metaContactRenamed<\/tt> method.\n     * When a meta contact is renamed, updates all related labels in this\n     * chat panel.\n     */\n    public void metaContactRenamed(MetaContactRenamedEvent evt)\n    {\n        String newName = evt.getNewDisplayName();\n        \n        if(evt.getSourceMetaContact().equals(metaContact))\n        {\n            getChatContactListPanel().renameContact(evt.getSourceMetaContact());\n\n            getChatWindow().setTabTitle(this, newName);\n\n            if( getChatWindow().getCurrentChatPanel() == this)\n            {\n                getChatWindow().setTitle(newName);\n            }\n        }\n    }","id":83822,"modified_method":"/**\n     * Implements <tt>MetaContactListListener.metaContactRenamed<\/tt> method.\n     * When a meta contact is renamed, updates all related labels in this\n     * chat panel.\n     */\n    public void metaContactRenamed(MetaContactRenamedEvent evt)\n    {\n        String newName = evt.getNewDisplayName();\n        \n        if(evt.getSourceMetaContact().equals(metaContact))\n        {\n            ChatContact chatContact\n                = findChatContactByMetaContact(evt.getSourceMetaContact());\n            \n            getChatContactListPanel().renameContact(chatContact);\n\n            getChatWindow().setTabTitle(this, newName);\n\n            if( getChatWindow().getCurrentChatPanel() == this)\n            {\n                getChatWindow().setTitle(newName);\n            }\n        }\n    }","commit_id":"49e0985d606d8a3a8d0efafae4e73d4eaaba6589","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates a <tt>MetaContactChatPanel<\/tt> which is added to the given chat\n     * window.\n     *\n     * @param chatWindow The parent window of this chat panel.\n     * @param metaContact the meta contact that this chat is about.\n     * @param protocolContact The subContact which is selected ins\n     * the chat.\n     */\n    public MetaContactChatPanel(    ChatWindow chatWindow,\n                                    MetaContact metaContact,\n                                    Contact protocolContact)\n    {\n        super(chatWindow);\n\n        this.metaContact = metaContact;\n\n        //Add the contact to the list of contacts contained in this panel\n        getChatContactListPanel().addContact(metaContact, protocolContact);\n        \n        //Load the history period, to initialize the firstMessageTimestamp and\n        //the lastMessageTimeStamp variables. Used to disable/enable history\n        //flash buttons in the chat window tool bar.\n        new Thread(){\n            public void run(){\n                loadHistoryPeriod();\n            }\n        }.start();\n                \n        //For each subcontact in the given MetaContact adds a\n        //ContactPresenceStatusListener in order to have always the contact\n        //current status in the chat panel\n        Iterator protocolContacts = metaContact.getContacts();\n        \n        while(protocolContacts.hasNext())\n        {\n            Contact subContact = (Contact) protocolContacts.next();\n            \n            chatWindow.getMainFrame()\n                .getProtocolPresenceOpSet(subContact.getProtocolProvider())\n                .addContactPresenceStatusListener(this);\n        }\n        \n        //Obtains the MetaContactListService and adds itself to it as a\n        //listener of all events concerning the contact list.\n        chatWindow.getMainFrame().getContactList()\n            .addMetaContactListListener(this);\n        \n        //Initializes the \"send via\" selector box and adds it to the send panel\n        contactSelectorBox = new ProtocolContactSelectorBox(\n            this, metaContact, protocolContact);\n\n        getChatSendPanel().getSendPanel()\n            .add(contactSelectorBox, BorderLayout.CENTER);\n        getChatSendPanel().getSendPanel()\n            .add(sendViaLabel, BorderLayout.WEST);\n     \n        //Enables to change the protocol provider by simply pressing the Ctrl-P\n        //key combination\n        ActionMap amap = this.getActionMap();\n        \n        amap.put(\"ChangeProtocol\", new ChangeProtocolAction());\n        \n        InputMap imap = this.getInputMap(\n            JComponent.WHEN_IN_FOCUSED_WINDOW); \n        \n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_P,\n            KeyEvent.CTRL_DOWN_MASK), \"ChangeProtocol\");\n    }","id":83823,"modified_method":"/**\n     * Creates a <tt>MetaContactChatPanel<\/tt> which is added to the given chat\n     * window.\n     *\n     * @param chatWindow The parent window of this chat panel.\n     * @param metaContact the meta contact that this chat is about.\n     * @param protocolContact The subContact which is selected ins\n     * the chat.\n     */\n    public MetaContactChatPanel(    ChatWindow chatWindow,\n                                    MetaContact metaContact,\n                                    Contact protocolContact)\n    {\n        super(chatWindow);\n\n        this.metaContact = metaContact;\n\n        ChatContact chatContact = new ChatContact(metaContact, protocolContact);\n        \n        //Add the contact to the list of contacts contained in this panel        \n        getChatContactListPanel().addContact(chatContact);\n        \n        //Load the history period, to initialize the firstMessageTimestamp and\n        //the lastMessageTimeStamp variables. Used to disable/enable history\n        //flash buttons in the chat window tool bar.\n        new Thread(){\n            public void run(){\n                loadHistoryPeriod();\n            }\n        }.start();\n                \n        //For each subcontact in the given MetaContact adds a\n        //ContactPresenceStatusListener in order to have always the contact\n        //current status in the chat panel\n        Iterator protocolContacts = metaContact.getContacts();\n        \n        while(protocolContacts.hasNext())\n        {\n            Contact subContact = (Contact) protocolContacts.next();\n            \n            Object opSet = subContact.getProtocolProvider()\n                .getOperationSet(OperationSetPersistentPresence.class);\n            \n            if(opSet != null)\n            {\n                ((OperationSetPersistentPresence)opSet)\n                    .addContactPresenceStatusListener(this);\n                \n                ((OperationSetPersistentPresence)opSet)\n                    .addSubsciptionListener(this);\n            }\n        }\n        \n        //Obtains the MetaContactListService and adds itself to it as a\n        //listener of all events concerning the contact list.\n        chatWindow.getMainFrame().getContactList()\n            .addMetaContactListListener(this);\n        \n        //Initializes the \"send via\" selector box and adds it to the send panel\n        contactSelectorBox = new ProtocolContactSelectorBox(\n            this, metaContact, protocolContact);\n\n        getChatSendPanel().getSendPanel()\n            .add(contactSelectorBox, BorderLayout.CENTER);\n        getChatSendPanel().getSendPanel()\n            .add(sendViaLabel, BorderLayout.WEST);\n     \n        //Enables to change the protocol provider by simply pressing the Ctrl-P\n        //key combination\n        ActionMap amap = this.getActionMap();\n        \n        amap.put(\"ChangeProtocol\", new ChangeProtocolAction());\n        \n        InputMap imap = this.getInputMap(\n            JComponent.WHEN_IN_FOCUSED_WINDOW); \n        \n        imap.put(KeyStroke.getKeyStroke(KeyEvent.VK_P,\n            KeyEvent.CTRL_DOWN_MASK), \"ChangeProtocol\");\n    }","commit_id":"49e0985d606d8a3a8d0efafae4e73d4eaaba6589","url":"https://github.com/jitsi/jitsi"},{"original_method":"public MetaContact getMetaContact()\n    {\n        return metaContact;\n    }","id":83824,"modified_method":"/**\n     * Returns the <tt>MetaContact<\/tt> corresponding to the chat.\n     * \n     * @return the <tt>MetaContact<\/tt> corresponding to the chat.\n     */\n    public MetaContact getMetaContact()\n    {\n        return metaContact;\n    }","commit_id":"49e0985d606d8a3a8d0efafae4e73d4eaaba6589","url":"https://github.com/jitsi/jitsi"},{"original_method":"public GradleProjectStructureChangesPanel(@NotNull Project project,\n                                            @NotNull GradleProjectStructureChangesModel model,\n                                            @NotNull PlatformFacade platformFacade,\n                                            @NotNull GradleProjectStructureHelper projectStructureHelper)\n  {\n    super(project, platformFacade, projectStructureHelper, GradleConstants.TOOL_WINDOW_TOOLBAR_PLACE);\n    model.addListener(new GradleProjectStructureChangeListener() {\n      @Override\n      public void onChanges(@NotNull final Collection<GradleProjectStructureChange> oldChanges,\n                            @NotNull final Collection<GradleProjectStructureChange> currentChanges)\n      {\n        UIUtil.invokeLaterIfNeeded(new Runnable() {\n          @Override\n          public void run() {\n            myTreeModel.update(currentChanges);\n            myTreeModel.processObsoleteChanges(ContainerUtil.subtract(oldChanges, currentChanges));\n          }\n        });\n      }\n    });\n  }","id":83825,"modified_method":"public GradleProjectStructureChangesPanel(@NotNull Project project,\n                                            @NotNull GradleProjectStructureChangesModel model,\n                                            @NotNull PlatformFacade platformFacade,\n                                            @NotNull GradleProjectStructureHelper projectStructureHelper)\n  {\n    super(project, platformFacade, projectStructureHelper, GradleConstants.TOOL_WINDOW_TOOLBAR_PLACE);\n    model.addListener(new GradleProjectStructureChangeListener() {\n      @Override\n      public void onChanges(@NotNull final Collection<GradleProjectStructureChange> oldChanges,\n                            @NotNull final Collection<GradleProjectStructureChange> currentChanges)\n      {\n        UIUtil.invokeLaterIfNeeded(new Runnable() {\n          @Override\n          public void run() {\n            myTreeModel.processObsoleteChanges(ContainerUtil.subtract(oldChanges, currentChanges));\n            myTreeModel.processCurrentChanges(currentChanges);\n          }\n        });\n      }\n    });\n  }","commit_id":"60e29df111b3a6b0eac3df1c1b97ee4a6934c662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Asks current node to ensure that given child node is at the 'right position' (according to the {@link #NODE_COMPARATOR}.\n   * <p/>\n   * Does nothing if given node is not a child of the current node.\n   * \n   * @param child  target child node\n   */\n  public void correctChildPositionIfNecessary(@NotNull GradleProjectStructureNode<?> child) {\n    int currentPosition = -1;\n    int desiredPosition = getChildCount();\n    for (int i = 0; i < getChildCount(); i++) {\n      GradleProjectStructureNode<?> node = getChildAt(i);\n      if (node == child) {\n        currentPosition = i;\n        continue;\n      }\n      if (NODE_COMPARATOR.compare(child, node) <= 0) {\n        desiredPosition = i;\n        if (currentPosition >= 0) {\n          break;\n        }\n      }\n    }\n    if (currentPosition < 0) {\n      // Given node is not a child of the current node.\n      return;\n    }\n    if (currentPosition < desiredPosition) {\n      desiredPosition--;\n    }\n    if (currentPosition == desiredPosition) {\n      return;\n    }\n    remove(currentPosition);\n    insert(child, desiredPosition);\n  }","id":83826,"modified_method":"/**\n   * Asks current node to ensure that given child node is at the 'right position' (according to the {@link #NODE_COMPARATOR}.\n   * <p/>\n   * Does nothing if given node is not a child of the current node.\n   * \n   * @param child  target child node\n   * @return       <code>true<\/code> if child position was changed; <code>false<\/code> otherwise\n   */\n  public boolean correctChildPositionIfNecessary(@NotNull GradleProjectStructureNode<?> child) {\n    int currentPosition = -1;\n    int desiredPosition = -1;\n    for (int i = 0; i < getChildCount(); i++) {\n      GradleProjectStructureNode<?> node = getChildAt(i);\n      if (node == child) {\n        currentPosition = i;\n        continue;\n      }\n      if (desiredPosition < 0 && NODE_COMPARATOR.compare(child, node) <= 0) {\n        desiredPosition = i;\n        if (currentPosition >= 0) {\n          break;\n        }\n      }\n    }\n    if (currentPosition < 0) {\n      // Given node is not a child of the current node.\n      return false;\n    }\n    if (desiredPosition < 0) {\n      desiredPosition = getChildCount();\n    }\n    if (currentPosition < desiredPosition) {\n      desiredPosition--;\n    }\n    if (currentPosition == desiredPosition) {\n      return false;\n    }\n    remove(currentPosition);\n    insert(child, desiredPosition);\n    return true;\n  }","commit_id":"60e29df111b3a6b0eac3df1c1b97ee4a6934c662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setAttributes(@NotNull TextAttributesKey key) {\n    myDescriptor.setAttributes(key);\n    onNodeChanged(this);\n  }","id":83827,"modified_method":"public void setAttributes(@NotNull TextAttributesKey key) {\n    myDescriptor.setAttributes(key);\n    final GradleProjectStructureNode<?> parent = getParent();\n    if (parent == null) {\n      onNodeChanged(this);\n      return;\n    }\n    boolean positionChanged = parent.correctChildPositionIfNecessary(this);\n    if (!positionChanged) {\n      onNodeChanged(this);\n    }\n  }","commit_id":"60e29df111b3a6b0eac3df1c1b97ee4a6934c662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Asks current model to update its state in accordance with the given changes.\n   * \n   * @param changes  collections that contains all changes between the current gradle and intellij project structures\n   */\n  public void update(@NotNull Collection<GradleProjectStructureChange> changes) {\n    for (GradleProjectStructureChange change : changes) {\n      change.invite(myNewChangesDispatcher);\n    }\n  }","id":83828,"modified_method":"/**\n   * Asks current model to update its state in accordance with the given changes.\n   * \n   * @param changes  collections that contains all changes between the current gradle and intellij project structures\n   */\n  public void processCurrentChanges(@NotNull Collection<GradleProjectStructureChange> changes) {\n    for (GradleProjectStructureChange change : changes) {\n      change.invite(myNewChangesDispatcher);\n    }\n  }","commit_id":"60e29df111b3a6b0eac3df1c1b97ee4a6934c662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processObsoleteModulePresenceChange(@NotNull GradleModulePresenceChange change) {\n    GradleModuleId id = change.getGradleEntity();\n    boolean removeNode;\n    if (id == null) {\n      id = change.getIntellijEntity();\n      assert id != null;\n      removeNode = myProjectStructureHelper.findIntellijModule(id.getModuleName()) == null;\n    }\n    else {\n      removeNode = myProjectStructureHelper.findGradleModule(id.getModuleName()) == null;\n    }\n    \n\n    // There are two possible cases why 'module presence' change is obsolete:\n    //   1. Corresponding module has been added at the counterparty;\n    //   2. The 'local module' has been removed;\n    // We should distinguish between those situations because we need to mark the node as 'synced' at one case and\n    // completely removed at another one.\n    \n    final GradleProjectStructureNode<GradleModuleId> moduleNode = myModules.get(id.getModuleName());\n    if (moduleNode == null) {\n      return;\n    }\n    if (removeNode) {\n      moduleNode.removeFromParent();\n    }\n    else {\n      moduleNode.getDescriptor().setAttributes(GradleTextAttributes.GRADLE_NO_CHANGE);\n    }\n  }","id":83829,"modified_method":"private void processObsoleteModulePresenceChange(@NotNull GradleModulePresenceChange change) {\n    GradleModuleId id = change.getGradleEntity();\n    boolean removeNode;\n    if (id == null) {\n      id = change.getIntellijEntity();\n      assert id != null;\n      removeNode = myProjectStructureHelper.findIntellijModule(id.getModuleName()) == null;\n    }\n    else {\n      removeNode = myProjectStructureHelper.findGradleModule(id.getModuleName()) == null;\n    }\n    \n\n    // There are two possible cases why 'module presence' change is obsolete:\n    //   1. Corresponding module has been added at the counterparty;\n    //   2. The 'local module' has been removed;\n    // We should distinguish between those situations because we need to mark the node as 'synced' at one case and\n    // completely removed at another one.\n    \n    final GradleProjectStructureNode<GradleModuleId> moduleNode = myModules.get(id.getModuleName());\n    if (moduleNode == null) {\n      return;\n    }\n    if (removeNode) {\n      moduleNode.removeFromParent();\n    }\n    else {\n      moduleNode.setAttributes(GradleTextAttributes.GRADLE_NO_CHANGE);\n    }\n  }","commit_id":"60e29df111b3a6b0eac3df1c1b97ee4a6934c662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void drop(DropTargetDropEvent e ) {       \n        java.awt.Point dropLocation = e.getLocation();\n        TreePath treePath = this.getPathForLocation(dropLocation.x, dropLocation.y);\n        if (isvalidDropNode(treePath)){\n            if (e.isLocalTransfer()) \n                e.acceptDrop(DnDConstants.ACTION_MOVE);\n            else \n                e.acceptDrop(DnDConstants.ACTION_COPY);\n            boolean success = false;\n            Transferable transfer = e.getTransferable();\n            DataFlavor[] dataFlavors = transfer.getTransferDataFlavors();\n            String resourceName = null;\n            java.util.List fileList = null;\n            java.util.List resourceList = null;\n            if (debug) System.out.println(\"drop: found \" + dataFlavors.length + \" dataFlavors\");\n            try {\n                if (transfer.isDataFlavorSupported(VueDragTreeNodeSelection.resourceFlavor)) {\n                    if (debug) System.out.println(\"RESOURCE FOUND\");\n                    resourceList = (java.util.List) transfer.getTransferData(VueDragTreeNodeSelection.resourceFlavor);\n                    DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n                    java.util.Iterator iter = resourceList.iterator();\n                    DefaultTreeModel model = (DefaultTreeModel)this.getModel(); \n                    while(iter.hasNext()) {\n                        Resource resource = (Resource) iter.next();\n                        ResourceNode newNode =new  ResourceNode(resource);\n                        model.insertNodeInto(newNode, node, 0);\n                        this.expandRow(node.getLevel());\n                    }\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                //System.out.println(ex);\n                //continue;\n            }\n            \n            /**\n            for (int i = 0; i < dataFlavors.length; i++) {\n                DataFlavor flavor = dataFlavors[i];\n                Object data = null;\n                if (debug) System.out.print(\"flavor\" + i + \" \" + flavor.getMimeType());\n                try {\n                    data = transfer.getTransferData(flavor);\n                } catch (Exception ex) {\n                      System.out.println(\"getTransferData: \" + ex);\n                }\n                try {\n                    if (transfer.isDataFlavorSupported(VueDragTreeNodeSelection.resourceFlavor)) {\n                         if (debug) System.out.println(\"RESOURCE FOUND\");\n                         resourceList = (java.util.List) transfer.getTransferData(flavor);\n                         DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n                         java.util.Iterator iter = resourceList.iterator();\n                         DefaultTreeModel model = (DefaultTreeModel)this.getModel();\n\n                         while(iter.hasNext()) {\n                            Resource resource = (Resource) iter.next();\n                            ResourceNode newNode =new  ResourceNode(resource);             \n                            model.insertNodeInto(newNode, node, 0);  \n                            this.expandRow(node.getLevel());\n                        }\n\n                    }else if (flavor.isFlavorJavaFileListType()) {\n                        if (debug) System.out.println(\"FILE LIST FOUND\");\n                        fileList = (java.util.List) transfer.getTransferData(flavor);\n                        java.util.Iterator iter = fileList.iterator();\n                        while (iter.hasNext()) {\n                            java.io.File file = (java.io.File) iter.next();\n                            DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n                            FileNode newNode = new FileNode(file);\n                            DefaultTreeModel model = (DefaultTreeModel)this.getModel();\n                            model.insertNodeInto(newNode, node, 0);    \n                            this.setRootVisible(true);\n                            this.expandRow(node.getLevel());\n                            this.setRootVisible(false);\n                            System.out.println(\"node level \" + node.getLevel());\n                        }\n                        success = true;\n                    } else if (flavor.getMimeType().startsWith(MIME_TYPE_TEXT_PLAIN)) {\n                        // checking isFlavorTextType() above should be\n                        // enough, but some Windows apps (e.g.,\n                        // Netscape-6) are leading the flavor list with\n                        // 20-30 mime-types of \"text/uri-list\", but the\n                        // reader only ever spits out the first character.\n\n                            resourceName = readTextFlavor(flavor, transfer);\n                            if (resourceName != null){\n                                DefaultMutableTreeNode node = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n                                DefaultTreeModel model = (DefaultTreeModel)this.getModel();\n                                DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(resourceName);\n                                model.insertNodeInto(newNode, node, 0);  \n                                  this.expandRow(node.getLevel());\n                            }\n                    }\n                } catch (Exception ex) {\n                    ex.printStackTrace();\n                    //System.out.println(ex);\n                    //continue;\n                }\n\n            }\n             */\n            e.dropComplete(success);\n            }else{\n                if (debug) System.out.println(\"Invalid Drop Node\");\n            }\n\n    }","id":83830,"modified_method":"public void drop(DropTargetDropEvent e ) {       \n        java.awt.Point dropLocation = e.getLocation();\n        TreePath treePath = this.getPathForLocation(dropLocation.x, dropLocation.y);\n        ResourceNode dropNode = (ResourceNode)treePath.getLastPathComponent();\n        if ((dropNode.getResource()).getType() == FAVORITES){\n            if (e.isLocalTransfer()) \n                e.acceptDrop(DnDConstants.ACTION_MOVE);\n            else \n                e.acceptDrop(DnDConstants.ACTION_COPY);\n            boolean success = false;\n            Transferable transfer = e.getTransferable();\n            DataFlavor[] dataFlavors = transfer.getTransferDataFlavors();\n            String resourceName = null;\n            java.util.List fileList = null;\n            java.util.List resourceList = null;\n            if (debug) System.out.println(\"drop: found \" + dataFlavors.length + \" dataFlavors\");\n            try {\n                if (transfer.isDataFlavorSupported(VueDragTreeNodeSelection.resourceFlavor)) {\n                    if (debug) System.out.println(\"RESOURCE FOUND\" );\n                  \n                    resourceList = (java.util.List) transfer.getTransferData(VueDragTreeNodeSelection.resourceFlavor);\n                    DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode)treePath.getLastPathComponent();\n                    java.util.Iterator iter = resourceList.iterator();\n                    DefaultTreeModel model = (DefaultTreeModel)this.getModel(); \n                    \n                    while(iter.hasNext()) {\n                        Resource resource = (Resource) iter.next();\n                        System.out.println(\"RESOURCE FOUND 2\" + resource + resource.getTitle() + resource.getSpec());\n                         \n                                   if (resource instanceof CabinetResource){\n                             \n                                     CabinetEntry entry = ((CabinetResource)resource).getEntry();\n                                      CabinetNode cabNode = null;\n                                       if (entry instanceof RemoteCabinetEntry)\n                                                cabNode = new CabinetNode ((CabinetResource)resource, CabinetNode.REMOTE);\n                                         else\n                                                 cabNode = new CabinetNode ((CabinetResource)resource, CabinetNode.LOCAL);\n                                   \n                                        cabNode.explore();\n                             \n                                      this.setRootVisible(true);\n                                        model.insertNodeInto(cabNode, rootNode, (rootNode.getChildCount()));\n                                      this.expandPath(new TreePath(rootNode.getPath()));\n                                    \n                                      this.setRootVisible(false);\n                                    }\n                         else {\n                             \n                             ResourceNode newNode =new ResourceNode(resource);\n                             this.setRootVisible(true);\n                              model.insertNodeInto(newNode, rootNode, (rootNode.getChildCount()));\n                              this.expandPath(new TreePath(rootNode.getPath()));\n                            this.expandRow(0);\n                            this.setRootVisible(false);\n                             \n                         }   \n                      \n                      \n                          }\n                    }\n                \n            } catch (Exception ex) {\n                ex.printStackTrace();\n                //System.out.println(ex);\n                //continue;\n            }\n            \n            \n            e.dropComplete(success);\n            }else{\n                if (debug) System.out.println(\"Invalid Drop Node\");\n            }\n\n    }","commit_id":"70ade9d7253e13ab867ab86bb007989c72189b50","url":"https://github.com/VUE/VUE"},{"original_method":"public Component getTreeCellRendererComponent(\n                            JTree tree,\n                            Object value,\n                            boolean sel,\n                            boolean expanded,\n                            boolean leaf,\n                            int row,\n                            boolean hasFocus) {\n                                \n                       \n                     Icon leafIcon = VueResources.getImageIcon(\"favorites.leafIcon\") ;\n                     Icon inactiveIcon = VueResources.getImageIcon(\"favorites.inactiveIcon\") ;\n                     Icon activeIcon = VueResources.getImageIcon(\"favorites.activeIcon\") ;\n                     \n                  \n                     \n                     \n            super.getTreeCellRendererComponent(\n                            tree, value, sel,\n                            expanded, leaf, row,\n                            hasFocus);\n            \n                       \n                    \n                     \n                       if (value instanceof FavoritesNode)\n                      {\n                          \n                 \n                        if ( ((FavoritesNode)value).getChildCount() >0 )\n                        {\n                          setIcon(activeIcon);\n                          \n                        }\n                        else\n                        {\n                            setIcon(inactiveIcon);\n                          \n                        }\n                       \n                          \n                        }\n                       else if (leaf){ setIcon(leafIcon);}\n                     \n                       else {setIcon(activeIcon);}\n                           \n                           \n                       \n                     \n\n            return this;\n }","id":83831,"modified_method":"public Component getTreeCellRendererComponent(JTree tree,Object value, boolean sel,boolean expanded,boolean leaf,int row,\n                            boolean hasFocus) \n   {\n                                \n                       \n                     Icon leafIcon = VueResources.getImageIcon(\"favorites.leafIcon\") ;\n                     Icon inactiveIcon = VueResources.getImageIcon(\"favorites.inactiveIcon\") ;\n                     Icon activeIcon = VueResources.getImageIcon(\"favorites.activeIcon\") ;\n                     \n                 \n                   super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);\n            \n                       if ((((ResourceNode)value).getResource()).getType()==FAVORITES) \n                      {\n                          \n                                   if ((((DefaultMutableTreeNode)value).getChildCount()) > 0 ){ setIcon(activeIcon);}\n                                   else {setIcon(inactiveIcon);}\n                        \n                          \n                       }\n                       \n                       else if (leaf){ setIcon(leafIcon);}\n                     \n                       else {setIcon(activeIcon);}\n     \n                    return this;\n                  }","commit_id":"70ade9d7253e13ab867ab86bb007989c72189b50","url":"https://github.com/VUE/VUE"},{"original_method":"public VueDandDTree(FavoritesNode root){ \n            super(root,\"Favorites\");\n            this.setEditable(true);\n            this.setShowsRootHandles(true);\n            this.setExpandsSelectedPaths(true);\n            VueDandDTreeCellRenderer renderer = new VueDandDTreeCellRenderer(this);\n            this.setCellRenderer(renderer);\n            new DropTarget(this, // component\n            ACCEPTABLE_DROP_TYPES, // actions\n            this);\n\n   }","id":83832,"modified_method":"public VueDandDTree(FavoritesNode root){ \n            \n            super(root);\n           \n            this.setEditable(true);\n            this.setShowsRootHandles(true);\n            this.expandRow(0);\n            this.setExpandsSelectedPaths(true);\n            this.getModel().addTreeModelListener(new VueTreeModelListener());\n\n            VueDandDTreeCellRenderer renderer = new VueDandDTreeCellRenderer(this);\n            this.setCellRenderer(renderer);\n            new DropTarget(this, // component\n            ACCEPTABLE_DROP_TYPES, // actions\n            this);\n\n   }","commit_id":"70ade9d7253e13ab867ab86bb007989c72189b50","url":"https://github.com/VUE/VUE"},{"original_method":"public VueDandDTreeCellRenderer(VueDandDTree pTree) {\n        this.tree = pTree;\n        \n                   \n                    \n              \n       \n        \n                tree.addMouseMotionListener(new MouseMotionAdapter() {\n             \n             public void mouseClicked(MouseEvent me){\n                 \n                if  (me.getClickCount() == 1) {\n                     TreePath treePath = tree.getPathForLocation(me.getX(), me.getY());\n                \n                if (treePath!=null) {\n                   \n              if (treePath.getLastPathComponent() instanceof FileNode){\n                      FileNode node = (FileNode)treePath.getLastPathComponent();\n                      File fromNodeFile = node.getFile();\n                     \n              }\n               }\n                    \n             }\n             }\n            public void mouseMoved(MouseEvent me) {\n                TreePath treePath = tree.getPathForLocation(me.getX(), me.getY());\n                \n                if (treePath!=null) {\n                   \n                     if (treePath.getLastPathComponent() instanceof FileNode){\n                      FileNode node = (FileNode)treePath.getLastPathComponent();\n                            }\n                        }\n        \n        \n            \n                            }          \n            \n        });\n   \n    }","id":83833,"modified_method":"public VueDandDTreeCellRenderer(VueDandDTree pTree) {\n        \n       \n                this.tree = pTree;\n        \n                tree.addMouseMotionListener(new MouseMotionAdapter() {\n             \n                         public void mouseClicked(MouseEvent me){\n                 \n                         if  (me.getClickCount() == 1) {\n                        TreePath treePath = tree.getPathForLocation(me.getX(), me.getY());\n                               }\n                           }\n                         public void mouseMoved(MouseEvent me) {\n                         TreePath treePath = tree.getPathForLocation(me.getX(), me.getY());\n                         \n                \n                            }          \n            \n                  });\n                  \n                   \n\n   \n    }","commit_id":"70ade9d7253e13ab867ab86bb007989c72189b50","url":"https://github.com/VUE/VUE"},{"original_method":"public static String encrypt(Key key, String plainText)\n\t\tthrows EncryptorException {\n\n\t\tbyte[] encryptedBytes = encryptRaw(key, plainText);\n\n\t\treturn Base64.encode(encryptedBytes);\n\t}","id":83834,"modified_method":"public static String encrypt(Key key, String plainText)\n\t\tthrows EncryptorException {\n\n\t\tbyte[] encryptedBytes = encryptUnencoded(key, plainText);\n\n\t\treturn Base64.encode(encryptedBytes);\n\t}","commit_id":"bad23f30fa3e9458a904a3f67231a4f757cb7b58","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String decryptRaw(Key key, byte[] encryptedBytes)\n\t\tthrows EncryptorException {\n\n\t\ttry {\n\n\t\t\tbyte[] decryptedBytes = decrypt(key, encryptedBytes);\n\n\t\t\tString decryptedString = new String(decryptedBytes, ENCODING);\n\n\t\t\treturn decryptedString;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EncryptorException(e);\n\t\t}\n\t}","id":83835,"modified_method":"public static String decryptUnencodedAsString(\n\t\t\tKey key, byte[] encryptedBytes)\n\t\tthrows EncryptorException {\n\n\t\ttry {\n\t\t\tbyte[] decryptedBytes = decryptUnencodedAsBytes(\n\t\t\t\tkey, encryptedBytes);\n\n\t\t\treturn new String(decryptedBytes, ENCODING);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EncryptorException(e);\n\t\t}\n\t}","commit_id":"bad23f30fa3e9458a904a3f67231a4f757cb7b58","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String decrypt(Key key, String encryptedString)\n\t\tthrows EncryptorException {\n\n\t\tbyte[] encryptedBytes = Base64.decode(encryptedString);\n\n\t\treturn decryptRaw(key, encryptedBytes);\n\t}","id":83836,"modified_method":"public static String decrypt(Key key, String encryptedString)\n\t\tthrows EncryptorException {\n\n\t\tbyte[] encryptedBytes = Base64.decode(encryptedString);\n\n\t\treturn decryptUnencodedAsString(key, encryptedBytes);\n\t}","commit_id":"bad23f30fa3e9458a904a3f67231a4f757cb7b58","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static byte[] encryptRaw(Key key, String plainText)\n\t\tthrows EncryptorException {\n\n\t\ttry {\n\t\t\tbyte[] decryptedBytes = plainText.getBytes(ENCODING);\n\t\t\t\n\t\t\treturn encrypt(key, decryptedBytes);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EncryptorException(e);\n\t\t}\n\t}","id":83837,"modified_method":"public static byte[] encryptUnencoded(Key key, String plainText)\n\t\tthrows EncryptorException {\n\n\t\ttry {\n\t\t\tbyte[] decryptedBytes = plainText.getBytes(ENCODING);\n\n\t\t\treturn encryptUnencoded(key, decryptedBytes);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EncryptorException(e);\n\t\t}\n\t}","commit_id":"bad23f30fa3e9458a904a3f67231a4f757cb7b58","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static byte[] decrypt(Key key, byte[] encryptedBytes)\n\t\tthrows EncryptorException {\n\n\t\ttry {\n\t\t\tSecurity.addProvider(getProvider());\n\n\t\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n\n\t\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n\n\t\t\tbyte[] decryptedBytes = cipher.doFinal(encryptedBytes);\n\n\t\t\treturn decryptedBytes;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EncryptorException(e);\n\t\t}\n\t}","id":83838,"modified_method":"public static byte[] decryptUnencodedAsBytes(Key key, byte[] encryptedBytes)\n\t\tthrows EncryptorException {\n\n\t\ttry {\n\t\t\tSecurity.addProvider(getProvider());\n\n\t\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n\n\t\t\tcipher.init(Cipher.DECRYPT_MODE, key);\n\n\t\t\treturn cipher.doFinal(encryptedBytes);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EncryptorException(e);\n\t\t}\n\t}","commit_id":"bad23f30fa3e9458a904a3f67231a4f757cb7b58","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static byte[] encrypt(Key key, byte[] plainBytes)\n\t\tthrows EncryptorException {\n\n\t\ttry {\n\t\t\tSecurity.addProvider(getProvider());\n\n\t\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, key);\n\n\t\t\tbyte[] encryptedBytes = cipher.doFinal(plainBytes);\n\n\t\t\treturn encryptedBytes;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EncryptorException(e);\n\t\t}\n\t}","id":83839,"modified_method":"public static byte[] encryptUnencoded(Key key, byte[] plainBytes)\n\t\tthrows EncryptorException {\n\n\t\ttry {\n\t\t\tSecurity.addProvider(getProvider());\n\n\t\t\tCipher cipher = Cipher.getInstance(key.getAlgorithm());\n\n\t\t\tcipher.init(Cipher.ENCRYPT_MODE, key);\n\n\t\t\treturn cipher.doFinal(plainBytes);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new EncryptorException(e);\n\t\t}\n\t}","commit_id":"bad23f30fa3e9458a904a3f67231a4f757cb7b58","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean equals(Object obj)\n\t\t{\n\t\t\tif (obj instanceof EncryptHeader)\n\t\t\t{\n\t\t\t\tboolean res = ((((EncryptHeader) obj).getType() == type) && ((((EncryptHeader) obj)\n\t\t\t\t\t\t.getVersion().equals(version))));\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\treturn false;\n\t\t}","id":83840,"modified_method":"public boolean equals(Object obj)\n\t\t{\n\t\t\tif (obj instanceof EncryptHeader)\n\t\t\t{\n                return ((((EncryptHeader) obj).getType() == type) && ((((EncryptHeader) obj)\n                        .getVersion().equals(version))));\n\t\t\t}\n\t\t\treturn false;\n\t\t}","commit_id":"059753bddb0e71c706461bf92827cece4e4804d4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * @return\n\t */\n\n\tprivate Message sendKeyRequest()\n\t{\n\n\t\t// send client's public key to server and request\n\t\t// server's public key\n\t\t Message newMsg = new Message(keyServerAddr, local_addr, Kpair.getPublic()\n\t\t\t\t.getEncoded());\n\n\t\tnewMsg.putHeader(EncryptHeader.KEY, new EncryptHeader(\n\t\t\t\tEncryptHeader.KEY_REQUEST, getSymVersion()));\n\t\tpassDown(new Event(Event.MSG, newMsg));\n\t\treturn newMsg;\n\t}","id":83841,"modified_method":"/**\n\t * @return Message\n\t */\n\n\tprivate Message sendKeyRequest()\n\t{\n\n\t\t// send client's public key to server and request\n\t\t// server's public key\n\t\t Message newMsg = new Message(keyServerAddr, local_addr, Kpair.getPublic()\n\t\t\t\t.getEncoded());\n\n\t\tnewMsg.putHeader(EncryptHeader.KEY, new EncryptHeader(\n\t\t\t\tEncryptHeader.KEY_REQUEST, getSymVersion()));\n\t\tpassDown(new Event(Event.MSG, newMsg));\n\t\treturn newMsg;\n\t}","commit_id":"059753bddb0e71c706461bf92827cece4e4804d4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * @param symEncodingCipher2\n\t * @param msg\n\t */\n\tprivate byte[] encryptMessage(Cipher cipher, byte[] plain) throws Exception\n\t{\n\t    byte[] cypherText = cipher.doFinal(plain);\n\t\treturn cypherText;\n\n\t}","id":83842,"modified_method":"/**\n     *\n     * @param cipher\n     * @param plain\n     * @return\n     * @throws Exception\n     */\n    private byte[] encryptMessage(Cipher cipher, byte[] plain) throws Exception\n\t{\n        return cipher.doFinal(plain);\n\n\t}","commit_id":"059753bddb0e71c706461bf92827cece4e4804d4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * @param msg\n\t * @param pubKey\n\t * @throws InvalidKeyException\n\t * @throws IllegalStateException\n\t * @throws IllegalBlockSizeException\n\t * @throws BadPaddingException\n\t */\n\tprivate void sendSecretKey(SecretKey secret, PublicKey pubKey, Address source)\n\t\t\tthrows InvalidKeyException, IllegalStateException,\n\t\t\tIllegalBlockSizeException, BadPaddingException, NoSuchPaddingException,\n\t\t\tNoSuchAlgorithmException\n\t{\n\t\tMessage newMsg;\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"encoding shared key \");\n\n\t\t// create a cipher with peer's public key\n\t\tCipher tmp = Cipher.getInstance(asymAlgorithm);\n\t\ttmp.init(Cipher.ENCRYPT_MODE, pubKey);\n\n\t\t//encrypt current secret key\n\t\tbyte[] encryptedKey = tmp.doFinal(secret.getEncoded());\n\n\t\t//SW logout encrypted bytes we are sending so we\n\t\t// can match the clients log to see if they match\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\" Generated encoded key which only client can decode:\"\n\t\t\t\t\t+ formatArray(encryptedKey));\n\n\t\tnewMsg = new Message(source, local_addr, encryptedKey);\n\n\t\tnewMsg.putHeader(EncryptHeader.KEY, new EncryptHeader(\n\t\t\t\tEncryptHeader.SECRETKEY, getSymVersion()));\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\" Sending version \" + getSymVersion()\n\t\t\t\t\t+ \" encoded key to client\");\n\t\tpassDown(new Event(Event.MSG, newMsg));\n\t}","id":83843,"modified_method":"/**\n\t * @param secret\n\t * @param pubKey\n\t * @throws InvalidKeyException\n\t * @throws IllegalStateException\n\t * @throws IllegalBlockSizeException\n\t * @throws BadPaddingException\n\t */\n\tprivate void sendSecretKey(SecretKey secret, PublicKey pubKey, Address source)\n\t\t\tthrows InvalidKeyException, IllegalStateException,\n\t\t\tIllegalBlockSizeException, BadPaddingException, NoSuchPaddingException,\n\t\t\tNoSuchAlgorithmException\n\t{\n\t\tMessage newMsg;\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"encoding shared key \");\n\n\t\t// create a cipher with peer's public key\n\t\tCipher tmp = Cipher.getInstance(asymAlgorithm);\n\t\ttmp.init(Cipher.ENCRYPT_MODE, pubKey);\n\n\t\t//encrypt current secret key\n\t\tbyte[] encryptedKey = tmp.doFinal(secret.getEncoded());\n\n\t\t//SW logout encrypted bytes we are sending so we\n\t\t// can match the clients log to see if they match\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\" Generated encoded key which only client can decode:\"\n\t\t\t\t\t+ formatArray(encryptedKey));\n\n\t\tnewMsg = new Message(source, local_addr, encryptedKey);\n\n\t\tnewMsg.putHeader(EncryptHeader.KEY, new EncryptHeader(\n\t\t\t\tEncryptHeader.SECRETKEY, getSymVersion()));\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\" Sending version \" + getSymVersion()\n\t\t\t\t\t+ \" encoded key to client\");\n\t\tpassDown(new Event(Event.MSG, newMsg));\n\t}","commit_id":"059753bddb0e71c706461bf92827cece4e4804d4","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * used to reconstitute public key sent in byte form from peer\n\t * @param encodedKey\n\t * @return\n\t */\n\tprivate PublicKey generatePubKey(byte[] encodedKey)\n\t{\n\t\tPublicKey pubKey = null;\n\t\ttry\n\t\t{\n\t\t\tKeyFactory KeyFac = KeyFactory\n\t\t\t\t\t.getInstance(getAlgorithm(asymAlgorithm));\n\t\t\tX509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(encodedKey);\n\t\t\tpubKey = KeyFac.generatePublic(x509KeySpec);\n\t\t} catch (Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn pubKey;\n\t}","id":83844,"modified_method":"/**\n\t * used to reconstitute public key sent in byte form from peer\n\t * @param encodedKey\n\t * @return PublicKey\n\t */\n\tprivate PublicKey generatePubKey(byte[] encodedKey)\n\t{\n\t\tPublicKey pubKey = null;\n\t\ttry\n\t\t{\n\t\t\tKeyFactory KeyFac = KeyFactory\n\t\t\t\t\t.getInstance(getAlgorithm(asymAlgorithm));\n\t\t\tX509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(encodedKey);\n\t\t\tpubKey = KeyFac.generatePublic(x509KeySpec);\n\t\t} catch (Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn pubKey;\n\t}","commit_id":"059753bddb0e71c706461bf92827cece4e4804d4","url":"https://github.com/belaban/JGroups"},{"original_method":"public void up(Event evt)\n\t{\n\n\t\tswitch (evt.getType()) {\n\n\t\t\t// we need to know what our address is\n\t\t\tcase Event.SET_LOCAL_ADDRESS :\n\t\t\t\tlocal_addr = (Address) evt.getArg();\n                if (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"set local address to \" + local_addr);\n                break;\n\t\t\tcase Event.VIEW_CHANGE:\n                View view=(View)evt.getArg();\n                if (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"handling view: \" + view);\n\t\t\t\tif (!suppliedKey){\n\t\t\t\t\thandleViewChange(view);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// we try and decrypt all messages\n\t\t\tcase Event.MSG :\n\t\t\t\t// if empty just pass up\n\t\t\t\tif (evt.getArg() == null || ((Message)evt.getArg()).getBuffer() == null){\n\t\t\t\t\tif (trace)\n\t\t\t\t\t\tlog.trace(\"passing up message as it has an empty buffer \");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// try and handle message\n\t\t\t\ttry\n\t\t\t\t{\n                    handleUpMessage(evt);\n\t\t\t\t} catch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Exception occurred decrypting message\", e);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tdefault :\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpassUp(evt);\n\t\treturn;\n\t}","id":83845,"modified_method":"public void up(Event evt)\n\t{\n\n\t\tswitch (evt.getType()) {\n\n\t\t\t// we need to know what our address is\n\t\t\tcase Event.SET_LOCAL_ADDRESS :\n\t\t\t\tlocal_addr = (Address) evt.getArg();\n                if (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"set local address to \" + local_addr);\n                break;\n\t\t\tcase Event.VIEW_CHANGE:\n                View view=(View)evt.getArg();\n                if (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"handling view: \" + view);\n\t\t\t\tif (!suppliedKey){\n\t\t\t\t\thandleViewChange(view);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// we try and decrypt all messages\n\t\t\tcase Event.MSG :\n\t\t\t\t// if empty just pass up\n\t\t\t\tif (evt.getArg() == null || ((Message)evt.getArg()).getBuffer() == null){\n\t\t\t\t\tif (trace)\n\t\t\t\t\t\tlog.trace(\"passing up message as it has an empty buffer \");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// try and handle message\n\t\t\t\ttry\n\t\t\t\t{\n                    handleUpMessage(evt);\n\t\t\t\t} catch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Exception occurred decrypting message\", e);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tdefault :\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpassUp(evt);\n\t}","commit_id":"059753bddb0e71c706461bf92827cece4e4804d4","url":"https://github.com/belaban/JGroups"},{"original_method":"public void up(Event evt)\n\t{\n\n\t\tswitch (evt.getType()) {\n\n\t\t\t// we need to know what our address is\n\t\t\tcase Event.SET_LOCAL_ADDRESS :\n\t\t\t\tlocal_addr = (Address) evt.getArg();\n                if (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"set local address to \" + local_addr);\n                break;\n\t\t\tcase Event.VIEW_CHANGE:\n                View view=(View)evt.getArg();\n                if (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"handling view: \" + view);\n\t\t\t\tif (!suppliedKey){\n\t\t\t\t\thandleViewChange(view);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// we try and decrypt all messages\n\t\t\tcase Event.MSG :\n\t\t\t\t// if empty just pass up\n\t\t\t\tif (evt.getArg() == null || ((Message)evt.getArg()).getBuffer() == null){\n\t\t\t\t\tif (trace)\n\t\t\t\t\t\tlog.trace(\"passing up message as it has an empty buffer \");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// try and handle message\n\t\t\t\ttry\n\t\t\t\t{\n                    handleUpMessage(evt);\n\t\t\t\t} catch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Exception occurred decrypting message\", e);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tdefault :\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpassUp(evt);\n\t\treturn;\n\t}","id":83846,"modified_method":"public void up(Event evt)\n\t{\n\n\t\tswitch (evt.getType()) {\n\n\t\t\t// we need to know what our address is\n\t\t\tcase Event.SET_LOCAL_ADDRESS :\n\t\t\t\tlocal_addr = (Address) evt.getArg();\n                if (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"set local address to \" + local_addr);\n                break;\n\t\t\tcase Event.VIEW_CHANGE:\n                View view=(View)evt.getArg();\n                if (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"handling view: \" + view);\n\t\t\t\tif (!suppliedKey){\n\t\t\t\t\thandleViewChange(view);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t// we try and decrypt all messages\n\t\t\tcase Event.MSG :\n\t\t\t\t// if empty just pass up\n\t\t\t\tif (evt.getArg() == null || ((Message)evt.getArg()).getBuffer() == null){\n\t\t\t\t\tif (trace)\n\t\t\t\t\t\tlog.trace(\"passing up message as it has an empty buffer \");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// try and handle message\n\t\t\t\ttry\n\t\t\t\t{\n                    handleUpMessage(evt);\n\t\t\t\t} catch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tlog.warn(\"Exception occurred decrypting message\", e);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tdefault :\n\t\t\t\tbreak;\n\t\t}\n\n\t\tpassUp(evt);\n\t}","commit_id":"24eab6f8e7cc074e4b0f54fb4062b50119d6d5ed","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean equals(Object obj)\n\t\t{\n\t\t\tif (obj instanceof EncryptHeader)\n\t\t\t{\n\t\t\t\tboolean res = ((((EncryptHeader) obj).getType() == type) && ((((EncryptHeader) obj)\n\t\t\t\t\t\t.getVersion().equals(version))));\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\treturn false;\n\t\t}","id":83847,"modified_method":"public boolean equals(Object obj)\n\t\t{\n\t\t\tif (obj instanceof EncryptHeader)\n\t\t\t{\n                return ((((EncryptHeader) obj).getType() == type) && ((((EncryptHeader) obj)\n                        .getVersion().equals(version))));\n\t\t\t}\n\t\t\treturn false;\n\t\t}","commit_id":"24eab6f8e7cc074e4b0f54fb4062b50119d6d5ed","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * @param msg\n\t * @param pubKey\n\t * @throws InvalidKeyException\n\t * @throws IllegalStateException\n\t * @throws IllegalBlockSizeException\n\t * @throws BadPaddingException\n\t */\n\tprivate void sendSecretKey(SecretKey secret, PublicKey pubKey, Address source)\n\t\t\tthrows InvalidKeyException, IllegalStateException,\n\t\t\tIllegalBlockSizeException, BadPaddingException, NoSuchPaddingException,\n\t\t\tNoSuchAlgorithmException\n\t{\n\t\tMessage newMsg;\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"encoding shared key \");\n\n\t\t// create a cipher with peer's public key\n\t\tCipher tmp = Cipher.getInstance(asymAlgorithm);\n\t\ttmp.init(Cipher.ENCRYPT_MODE, pubKey);\n\n\t\t//encrypt current secret key\n\t\tbyte[] encryptedKey = tmp.doFinal(secret.getEncoded());\n\n\t\t//SW logout encrypted bytes we are sending so we\n\t\t// can match the clients log to see if they match\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\" Generated encoded key which only client can decode:\"\n\t\t\t\t\t+ formatArray(encryptedKey));\n\n\t\tnewMsg = new Message(source, local_addr, encryptedKey);\n\n\t\tnewMsg.putHeader(EncryptHeader.KEY, new EncryptHeader(\n\t\t\t\tEncryptHeader.SECRETKEY, getSymVersion()));\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\" Sending version \" + getSymVersion()\n\t\t\t\t\t+ \" encoded key to client\");\n\t\tpassDown(new Event(Event.MSG, newMsg));\n\t}","id":83848,"modified_method":"/**\n\t * @param secret\n\t * @param pubKey\n\t * @throws InvalidKeyException\n\t * @throws IllegalStateException\n\t * @throws IllegalBlockSizeException\n\t * @throws BadPaddingException\n\t */\n\tprivate void sendSecretKey(SecretKey secret, PublicKey pubKey, Address source)\n\t\t\tthrows InvalidKeyException, IllegalStateException,\n\t\t\tIllegalBlockSizeException, BadPaddingException, NoSuchPaddingException,\n\t\t\tNoSuchAlgorithmException\n\t{\n\t\tMessage newMsg;\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"encoding shared key \");\n\n\t\t// create a cipher with peer's public key\n\t\tCipher tmp = Cipher.getInstance(asymAlgorithm);\n\t\ttmp.init(Cipher.ENCRYPT_MODE, pubKey);\n\n\t\t//encrypt current secret key\n\t\tbyte[] encryptedKey = tmp.doFinal(secret.getEncoded());\n\n\t\t//SW logout encrypted bytes we are sending so we\n\t\t// can match the clients log to see if they match\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\" Generated encoded key which only client can decode:\"\n\t\t\t\t\t+ formatArray(encryptedKey));\n\n\t\tnewMsg = new Message(source, local_addr, encryptedKey);\n\n\t\tnewMsg.putHeader(EncryptHeader.KEY, new EncryptHeader(\n\t\t\t\tEncryptHeader.SECRETKEY, getSymVersion()));\n\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\" Sending version \" + getSymVersion()\n\t\t\t\t\t+ \" encoded key to client\");\n\t\tpassDown(new Event(Event.MSG, newMsg));\n\t}","commit_id":"24eab6f8e7cc074e4b0f54fb4062b50119d6d5ed","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * @param symEncodingCipher2\n\t * @param msg\n\t */\n\tprivate byte[] encryptMessage(Cipher cipher, byte[] plain) throws Exception\n\t{\n\t    byte[] cypherText = cipher.doFinal(plain);\n\t\treturn cypherText;\n\n\t}","id":83849,"modified_method":"/**\n     *\n     * @param cipher\n     * @param plain\n     * @return\n     * @throws Exception\n     */\n    private byte[] encryptMessage(Cipher cipher, byte[] plain) throws Exception\n\t{\n        return cipher.doFinal(plain);\n\n\t}","commit_id":"24eab6f8e7cc074e4b0f54fb4062b50119d6d5ed","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * @return\n\t */\n\n\tprivate Message sendKeyRequest()\n\t{\n\n\t\t// send client's public key to server and request\n\t\t// server's public key\n\t\t Message newMsg = new Message(keyServerAddr, local_addr, Kpair.getPublic()\n\t\t\t\t.getEncoded());\n\n\t\tnewMsg.putHeader(EncryptHeader.KEY, new EncryptHeader(\n\t\t\t\tEncryptHeader.KEY_REQUEST, getSymVersion()));\n\t\tpassDown(new Event(Event.MSG, newMsg));\n\t\treturn newMsg;\n\t}","id":83850,"modified_method":"/**\n\t * @return Message\n\t */\n\n\tprivate Message sendKeyRequest()\n\t{\n\n\t\t// send client's public key to server and request\n\t\t// server's public key\n\t\t Message newMsg = new Message(keyServerAddr, local_addr, Kpair.getPublic()\n\t\t\t\t.getEncoded());\n\n\t\tnewMsg.putHeader(EncryptHeader.KEY, new EncryptHeader(\n\t\t\t\tEncryptHeader.KEY_REQUEST, getSymVersion()));\n\t\tpassDown(new Event(Event.MSG, newMsg));\n\t\treturn newMsg;\n\t}","commit_id":"24eab6f8e7cc074e4b0f54fb4062b50119d6d5ed","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n\t * used to reconstitute public key sent in byte form from peer\n\t * @param encodedKey\n\t * @return\n\t */\n\tprivate PublicKey generatePubKey(byte[] encodedKey)\n\t{\n\t\tPublicKey pubKey = null;\n\t\ttry\n\t\t{\n\t\t\tKeyFactory KeyFac = KeyFactory\n\t\t\t\t\t.getInstance(getAlgorithm(asymAlgorithm));\n\t\t\tX509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(encodedKey);\n\t\t\tpubKey = KeyFac.generatePublic(x509KeySpec);\n\t\t} catch (Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn pubKey;\n\t}","id":83851,"modified_method":"/**\n\t * used to reconstitute public key sent in byte form from peer\n\t * @param encodedKey\n\t * @return PublicKey\n\t */\n\tprivate PublicKey generatePubKey(byte[] encodedKey)\n\t{\n\t\tPublicKey pubKey = null;\n\t\ttry\n\t\t{\n\t\t\tKeyFactory KeyFac = KeyFactory\n\t\t\t\t\t.getInstance(getAlgorithm(asymAlgorithm));\n\t\t\tX509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(encodedKey);\n\t\t\tpubKey = KeyFac.generatePublic(x509KeySpec);\n\t\t} catch (Exception e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn pubKey;\n\t}","commit_id":"24eab6f8e7cc074e4b0f54fb4062b50119d6d5ed","url":"https://github.com/belaban/JGroups"},{"original_method":"private static String replaceMacros(final String wrapperText, final String outputFileName, final String targetPlayer,\n                                      final @Nullable JSClass mainClass) {\n    final List<String> versionParts = StringUtil.split(targetPlayer, \".\");\n    final String major = versionParts.size() >= 1 ? versionParts.get(0) : \"0\";\n    final String minor = versionParts.size() >= 2 ? versionParts.get(1) : \"0\";\n    final String revision = versionParts.size() >= 3 ? versionParts.get(2) : \"0\";\n\n    final Ref<JSAttribute> swfMetadataRef = new Ref<JSAttribute>();\n\n    final PsiFile psiFile = mainClass == null ? null : mainClass.getContainingFile();\n\n    if (psiFile instanceof XmlFile) {\n      final XmlTag rootTag = ((XmlFile)psiFile).getRootTag();\n      if (rootTag != null) {\n        final String ns = rootTag.getPrefixByNamespace(JavaScriptSupportLoader.MXML_URI3) == null\n                          ? JavaScriptSupportLoader.MXML_URI\n                          : JavaScriptSupportLoader.MXML_URI3;\n        for (XmlTag tag : rootTag.findSubTags(FlexPredefinedTagNames.METADATA, ns)) {\n          JSResolveUtil.processInjectedFileForTag(tag, new JSResolveUtil.JSInjectedFilesVisitor() {\n            protected void process(final JSFile file) {\n              for (PsiElement elt : file.getChildren()) {\n                if (elt instanceof JSAttributeList) {\n                  final JSAttribute swfMetadata = ((JSAttributeList)elt).findAttributeByName(\"SWF\");\n                  if (swfMetadataRef.isNull() && swfMetadata != null) {\n                    swfMetadataRef.set(swfMetadata);\n                    return;\n                  }\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    else {\n      final JSAttributeList attributeList = mainClass == null ? null : mainClass.getAttributeList();\n      swfMetadataRef.set(attributeList == null ? null : attributeList.findAttributeByName(\"SWF\"));\n    }\n\n    final JSAttribute swfMetadata = swfMetadataRef.isNull() ? null : swfMetadataRef.get();\n\n    final JSAttributeNameValuePair titleAttr = swfMetadata == null ? null : swfMetadata.getValueByName(\"pageTitle\");\n    final String title = titleAttr != null ? titleAttr.getSimpleValue() : outputFileName;\n\n    final JSAttributeNameValuePair bgColorAttr = swfMetadata == null ? null : swfMetadata.getValueByName(\"backgroundColor\");\n    final String bgColor = bgColorAttr != null ? bgColorAttr.getSimpleValue() : \"#ffffff\";\n\n    final JSAttributeNameValuePair widthAttr = swfMetadata == null ? null : swfMetadata.getValueByName(\"width\");\n    final String width = widthAttr != null ? widthAttr.getSimpleValue() : \"100%\";\n\n    final JSAttributeNameValuePair heightAttr = swfMetadata == null ? null : swfMetadata.getValueByName(\"height\");\n    final String height = heightAttr != null ? heightAttr.getSimpleValue() : \"100%\";\n\n    final String[] replacement = {outputFileName, title, outputFileName, bgColor, width, height, major, minor, revision};\n    return StringUtil.replace(wrapperText, MACROS_TO_REPLACE, replacement);\n  }","id":83852,"modified_method":"private static String replaceMacros(final String wrapperText, final String outputFileName, final String targetPlayer,\n                                      final @Nullable JSClass mainClass) {\n    final List<String> versionParts = StringUtil.split(targetPlayer, \".\");\n    final String major = versionParts.size() >= 1 ? versionParts.get(0) : \"0\";\n    final String minor = versionParts.size() >= 2 ? versionParts.get(1) : \"0\";\n    final String revision = versionParts.size() >= 3 ? versionParts.get(2) : \"0\";\n\n    final Ref<JSAttribute> swfMetadataRef = new Ref<JSAttribute>();\n\n    final PsiFile psiFile = mainClass == null ? null : mainClass.getContainingFile();\n\n    if (psiFile instanceof XmlFile) {\n      final XmlTag rootTag = ((XmlFile)psiFile).getRootTag();\n      if (rootTag != null) {\n        final String ns = rootTag.getPrefixByNamespace(JavaScriptSupportLoader.MXML_URI3) == null\n                          ? JavaScriptSupportLoader.MXML_URI\n                          : JavaScriptSupportLoader.MXML_URI3;\n        for (XmlTag tag : rootTag.findSubTags(FlexPredefinedTagNames.METADATA, ns)) {\n          JSResolveUtil.processInjectedFileForTag(tag, new JSResolveUtil.JSInjectedFilesVisitor() {\n            protected void process(final JSFile file) {\n              for (PsiElement elt : file.getChildren()) {\n                if (elt instanceof JSAttributeList) {\n                  final JSAttribute swfMetadata = ((JSAttributeList)elt).findAttributeByName(\"SWF\");\n                  if (swfMetadataRef.isNull() && swfMetadata != null) {\n                    swfMetadataRef.set(swfMetadata);\n                    return;\n                  }\n                }\n              }\n            }\n          });\n        }\n      }\n    }\n    else {\n      final JSAttributeList attributeList = mainClass == null ? null : mainClass.getAttributeList();\n      swfMetadataRef.set(attributeList == null ? null : attributeList.findAttributeByName(\"SWF\"));\n    }\n\n    final JSAttribute swfMetadata = swfMetadataRef.isNull() ? null : swfMetadataRef.get();\n\n    final JSAttributeNameValuePair titleAttr = swfMetadata == null ? null : swfMetadata.getValueByName(\"pageTitle\");\n    final String title = titleAttr != null ? StringUtil.notNullize(titleAttr.getSimpleValue(), outputFileName) : outputFileName;\n\n    final JSAttributeNameValuePair bgColorAttr = swfMetadata == null ? null : swfMetadata.getValueByName(\"backgroundColor\");\n    final String bgColor = bgColorAttr != null ? StringUtil.notNullize(bgColorAttr.getSimpleValue(), \"#ffffff\") : \"#ffffff\";\n\n    final JSAttributeNameValuePair widthAttr = swfMetadata == null ? null : swfMetadata.getValueByName(\"width\");\n    final String width = widthAttr != null ? StringUtil.notNullize(widthAttr.getSimpleValue(), \"100%\") : \"100%\";\n\n    final JSAttributeNameValuePair heightAttr = swfMetadata == null ? null : swfMetadata.getValueByName(\"height\");\n    final String height = heightAttr != null ? StringUtil.notNullize(heightAttr.getSimpleValue(), \"100%\") : \"100%\";\n\n    final String[] replacement = {outputFileName, title, outputFileName, bgColor, width, height, major, minor, revision};\n    return StringUtil.replace(wrapperText, MACROS_TO_REPLACE, replacement);\n  }","commit_id":"dae7b4aa6ca690c146acb17bd338330150e0f76f","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected SNode computeTypesForNode_special(SNode initialNode, Collection<SNode> givenAdditionalNodes) {\n    assert myNodeTypesComponent.getTypeCheckingContext().isSingleTypeComputation();\n\n    assert myFullyCheckedNodes.isEmpty();\n    SNode type = null;\n    SNode prevNode = null;\n    SNode node = initialNode;\n    long start = System.currentTimeMillis();\n    myState.setTargetNode(initialNode);\n    while (node != null) {\n      Collection<SNode> additionalNodes = givenAdditionalNodes;\n      if (prevNode != null) {\n        additionalNodes = new ArrayList<SNode>(additionalNodes);\n        additionalNodes.add(prevNode);\n      }\n      computeTypesSpecial(node, false, additionalNodes, false, initialNode);\n      type = typeCalculated(initialNode);\n      if (type == null) {\n        if (node.isRoot()) {\n          //System.out.println(\"Root: \" + initialNode.getDebugText());\n          computeTypes(node,true, true, Collections.<SNode>emptyList(), true, initialNode);\n          type = getType(initialNode);\n          if (type == null && node != initialNode && myTypeChecker.isGenerationMode()) {\n            LOG.error(\"No typesystem rule for \" + initialNode.getDebugText() + \" in root \" + initialNode.getContainingRoot() + \": type calculation took \" + (System.currentTimeMillis() - start) + \" ms\", new Throwable(), new SNodePointer(initialNode));\n          }\n          return type;\n        }\n        prevNode = node;\n        node = node.getParent();\n      } else {\n        type = typeCalculated(initialNode);\n        return type;\n      }\n    }\n    return type;\n  }","id":83853,"modified_method":"protected SNode computeTypesForNode_special(SNode initialNode, Collection<SNode> givenAdditionalNodes) {\n    assert myNodeTypesComponent.getTypeCheckingContext().isSingleTypeComputation();\n\n    assert myFullyCheckedNodes.isEmpty();\n    SNode type = null;\n    SNode prevNode = null;\n    SNode node = initialNode;\n    long start = System.currentTimeMillis();\n    myState.setTargetNode(initialNode);\n    while (node != null) {\n      Collection<SNode> additionalNodes = givenAdditionalNodes;\n      if (prevNode != null) {\n        additionalNodes = new ArrayList<SNode>(additionalNodes);\n        additionalNodes.add(prevNode);\n      }\n      computeTypesSpecial(node, false, additionalNodes, false, initialNode);\n      type = typeCalculated(initialNode);\n      if (type == null) {\n        if (node.isRoot()) {\n          //System.out.println(\"Root: \" + initialNode.getDebugText());\n          if (myState.getInequalitySystem() == null) {\n            computeTypes(node,true, true, Collections.<SNode>emptyList(), true, initialNode);\n          }\n          type = getType(initialNode);\n          if (type == null && node != initialNode && myTypeChecker.isGenerationMode()) {\n            LOG.error(\"No typesystem rule for \" + initialNode.getDebugText() + \" in root \" + initialNode.getContainingRoot() + \": type calculation took \" + (System.currentTimeMillis() - start) + \" ms\", new Throwable(), new SNodePointer(initialNode));\n          }\n          return type;\n        }\n        prevNode = node;\n        node = node.getParent();\n      } else {\n        type = typeCalculated(initialNode);\n        return type;\n      }\n    }\n    return type;\n  }","commit_id":"459c4ec9f61ca890e255245daba582acc8489e25","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected SNode computeTypesForNode_special(SNode initialNode, List<SNode> givenAdditionalNodes) {\n    SNode type = null;\n    SNode prevNode = null;\n    SNode node = initialNode;\n    long start = System.currentTimeMillis();\n    myState.setTargetNode(initialNode);\n    while (node != null) {\n      List<SNode> additionalNodes = new ArrayList<SNode>(givenAdditionalNodes);\n      if (prevNode != null) {\n        additionalNodes.add(prevNode);\n      }\n      computeTypesSpecial(node, false, additionalNodes, false, initialNode);\n      type = typeCalculated(initialNode);\n      if (type == null) {\n        if (node.isRoot()) {\n          computeTypes(node, true, true, new ArrayList<SNode>(0), true, initialNode);\n          type = getType(initialNode);\n          if(type == null && node != initialNode && myState.getInequalitySystem() == null && !myNodeTypesComponent.getTypeCheckingContext().isInEditorQueries()) {\n            LOG.error(\"No typesystem rule for \" + initialNode.getDebugText() + \" in root \" + initialNode.getContainingRoot() + \": type calculation took \" + (System.currentTimeMillis() - start) + \" ms\", new Throwable(), new SNodePointer(initialNode));\n          }\n          return type;\n        }\n        prevNode = node;\n        node = node.getParent();\n      } else {\n        return type;\n      }\n    }\n    return type;\n  }","id":83854,"modified_method":"protected SNode computeTypesForNode_special(SNode initialNode, List<SNode> givenAdditionalNodes) {\n    SNode type = null;\n    SNode prevNode = null;\n    SNode node = initialNode;\n    long start = System.currentTimeMillis();\n    myState.setTargetNode(initialNode);\n    while (node != null) {\n      List<SNode> additionalNodes = new ArrayList<SNode>(givenAdditionalNodes);\n      if (prevNode != null) {\n        additionalNodes.add(prevNode);\n      }\n      computeTypesSpecial(node, false, additionalNodes, false, initialNode);\n      type = typeCalculated(initialNode);\n      if (type == null) {\n        if (node.isRoot()) {\n          if (myState.getInequalitySystem() == null) {\n            computeTypes(node, true, true, new ArrayList<SNode>(0), true, initialNode);\n          }\n          type = getType(initialNode);\n          if(type == null && node != initialNode && myState.getInequalitySystem() == null && !myNodeTypesComponent.getTypeCheckingContext().isInEditorQueries()) {\n            LOG.error(\"No typesystem rule for \" + initialNode.getDebugText() + \" in root \" + initialNode.getContainingRoot() + \": type calculation took \" + (System.currentTimeMillis() - start) + \" ms\", new Throwable(), new SNodePointer(initialNode));\n          }\n          return type;\n        }\n        prevNode = node;\n        node = node.getParent();\n      } else {\n        return type;\n      }\n    }\n    return type;\n  }","commit_id":"0bc845918961a6d1fef41615dba15a283bcf318b","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected SNode computeTypesForNode_special__(SNode initialNode, Collection<SNode> givenAdditionalNodes) {\n    SNode type = null;\n    SNode prevNode = null;\n    SNode node = initialNode;\n    long start = System.currentTimeMillis();\n    setTarget(initialNode);\n    while (node != null) {\n      Collection<SNode> additionalNodes = givenAdditionalNodes;\n      if (prevNode != null) {\n        additionalNodes = new ArrayList<SNode>(additionalNodes);\n        additionalNodes.add(prevNode);\n      }\n      computeTypesSpecial(node, false, additionalNodes, false, initialNode);\n      type = typeCalculated(initialNode);\n      if (type == null) {\n        if (node.getModel() != null && node.getParent() == null) {\n          //System.out.println(\"Root: \" + initialNode.getDebugText());\n          computeTypes(initialNode, node);\n          type = getType(initialNode);\n          if (type == null && node != initialNode) {\n            TypeSystemComponent.LOG.debug(\"No typesystem rule for \" + org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(initialNode) + \" in root \" + initialNode.getContainingRoot() + \": type calculation took \" + (System.currentTimeMillis() - start) + \" ms\", new Throwable(), new jetbrains.mps.smodel.SNodePointer(initialNode));\n          }\n          return type;\n        }\n        prevNode = node;\n        node = node.getParent();\n      } else {\n        type = typeCalculated(initialNode);\n        return type;\n      }\n    }\n    return type;\n  }","id":83855,"modified_method":"protected SNode computeTypesForNode_special__(SNode initialNode, Collection<SNode> givenAdditionalNodes) {\n    long start = System.currentTimeMillis();\n    setTarget(initialNode);\n    if (initialNode == null) return null;\n\n    computeTypesSpecial(initialNode, false, givenAdditionalNodes, false, initialNode);\n    SNode type = typeCalculated(initialNode);\n    if (type != null) return type;\n\n    if (initialNode.getModel() != null && initialNode.getParent() == null) {\n      computeTypes(initialNode, initialNode);\n      return getType(initialNode);\n    }\n\n    TypeSystemComponent.LOG.debug(\"No typesystem rule for \" + org.jetbrains.mps.openapi.model.SNodeUtil.getDebugText(initialNode) + \" in root \" + initialNode.getContainingRoot() + \": type calculation took \" + (System.currentTimeMillis() - start) + \" ms\", new Throwable(), new jetbrains.mps.smodel.SNodePointer(initialNode));\n    return null;\n  }","commit_id":"a40e2ad686561680582c0eb90f7f32fe5aee18ab","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void createFileAndDirsTest() throws Exception {\n    verifyInodesList(TEST_DIR_FILE_URI.split(\"/\"),\n        sTree.collectInodes(new AlluxioURI(TEST_DIR_FILE_URI)));\n    verifyInodesList(TEST_FILE_URI.split(\"/\"),\n        sTree.collectInodes(new AlluxioURI(TEST_FILE_URI)));\n    verifyInodesList(TEST_WEIRD_FILE_URI.split(\"/\"),\n        sTree.collectInodes(new AlluxioURI(TEST_WEIRD_FILE_URI)));\n    verifyInodesList(new String[]{\"\", \"testDir\"},\n        sTree.collectInodes(new AlluxioURI(TEST_NOT_EXIST_URI)));\n  }","id":83856,"modified_method":"@Test\n  public void createFileAndDirsTest() throws Exception {\n    try (InodePath inodePath = sTree.lockInodePath(new AlluxioURI(TEST_DIR_FILE_URI),\n        InodeTree.LockMode.READ)) {\n      verifyInodesList(TEST_DIR_FILE_URI.split(\"/\"), inodePath.getInodeList());\n    }\n    try (InodePath inodePath = sTree.lockInodePath(new AlluxioURI(TEST_FILE_URI),\n        InodeTree.LockMode.READ)) {\n      verifyInodesList(TEST_FILE_URI.split(\"/\"), inodePath.getInodeList());\n    }\n    try (InodePath inodePath = sTree.lockInodePath(new AlluxioURI(TEST_WEIRD_FILE_URI),\n        InodeTree.LockMode.READ)) {\n      verifyInodesList(TEST_WEIRD_FILE_URI.split(\"/\"), inodePath.getInodeList());\n    }\n    try (InodePath inodePath = sTree.lockInodePath(new AlluxioURI(TEST_NOT_EXIST_URI),\n        InodeTree.LockMode.READ)) {\n      verifyInodesList(new String[]{\"\", \"testDir\"}, inodePath.getInodeList());\n    }\n  }","commit_id":"ed2d08a0dd8aded2594b950c74afe9b9718b6f71","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n     * process the redelivered message. If the Jms receiver should process the\n     * message, it should be returned. Otherwise the connector should throw a\n     * <code>MessageRedeliveredException<\/code> to indicate that the message should\n     * be handled by the connector Exception Handler.\n     * \n     */\n    public void handleRedelivery(Message message) throws JMSException, MuleException\n    {\n        if (connector.getMaxRedelivery() <= 0)\n        {\n            return;\n        }\n\n        String id = message.getJMSMessageID();\n\n        if (id == null)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Message doesn't have a JMSMessageID set, Mule can't handle redelivery for it. \" + message);\n            }\n            return;\n        }\n\n        Integer redeliveryCount = messages.remove(id);\n        if (redeliveryCount != null)\n        {\n            redeliveryCount += 1; // inc the count\n        }\n\n        if (redeliveryCount == null)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Message with id: \" + id + \" has been redelivered for the first time\");\n            }\n            messages.put(id, 1);\n        }\n        else if (redeliveryCount > connector.getMaxRedelivery())\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(MessageFormat.format(\n                        \"Message with id: {0} has been redelivered {1} times, which exceeds the maxRedelivery setting \" +\n                        \"of {2} on the connector {3}\", id, redeliveryCount, connector.getMaxRedelivery(), connector.getName()));\n            }\n            JmsMessageAdapter adapter = (JmsMessageAdapter) connector.getMessageAdapter(message);\n\n            throw new MessageRedeliveredException(\n                    JmsMessages.tooManyRedeliveries(id, \"\" + redeliveryCount, connector.getMaxRedelivery(),\n                            connector.getName()), new DefaultMuleMessage(adapter, connector.getMuleContext()));\n\n        }\n        else\n        {\n            messages.put(id, redeliveryCount);\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Message with id: \" + id + \" has been redelivered \" + redeliveryCount + \" times\");\n            }\n        }\n    }","id":83857,"modified_method":"/**\n     * process the redelivered message. If the Jms receiver should process the\n     * message, it should be returned. Otherwise the connector should throw a\n     * <code>MessageRedeliveredException<\/code> to indicate that the message should\n     * be handled by the connector Exception Handler.\n     * \n     */\n    public void handleRedelivery(Message message) throws JMSException, MuleException\n    {\n        final int connectorRedelivery = connector.getMaxRedelivery();\n        if (connectorRedelivery == JmsConnector.REDELIVERY_SWALLOW_MESSAGE ||\n            connectorRedelivery < 0 ) // just in case, for manual setting)\n        {\n            return;\n        }\n\n        String id = message.getJMSMessageID();\n\n        if (id == null)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Message doesn't have a JMSMessageID set, Mule can't handle redelivery for it. \" + message);\n            }\n            return;\n        }\n\n        Integer redeliveryCount = messages.remove(id);\n        if (redeliveryCount != null)\n        {\n            redeliveryCount += 1; // inc the count\n        }\n\n        if (redeliveryCount == null)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Message with id: \" + id + \" has been redelivered for the first time\");\n            }\n            messages.put(id, 1);\n        }\n        else if (redeliveryCount == 1)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Message with id: \" + id + \" has been redelivered for the first time\");\n            }\n\n            if (connectorRedelivery == JmsConnector.REDELIVERY_FAIL_ON_FIRST)\n            {\n                JmsMessageAdapter adapter = (JmsMessageAdapter) connector.getMessageAdapter(message);\n                throw new MessageRedeliveredException(\n                        JmsMessages.tooManyRedeliveries(id, String.valueOf(redeliveryCount),\n                                                        connectorRedelivery, connector.getName()), new DefaultMuleMessage(adapter, connector.getMuleContext()));\n            }\n\n        }\n        else if (redeliveryCount > connectorRedelivery)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(MessageFormat.format(\n                        \"Message with id: {0} has been redelivered {1} times, which exceeds the maxRedelivery setting \" +\n                        \"of {2} on the connector {3}\", id, redeliveryCount, connectorRedelivery, connector.getName()));\n            }\n            JmsMessageAdapter adapter = (JmsMessageAdapter) connector.getMessageAdapter(message);\n\n            throw new MessageRedeliveredException(\n                    JmsMessages.tooManyRedeliveries(id, \"\" + redeliveryCount, connectorRedelivery,\n                            connector.getName()), new DefaultMuleMessage(adapter, connector.getMuleContext()));\n\n        }\n        else\n        {\n            messages.put(id, redeliveryCount);\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Message with id: \" + id + \" has been redelivered \" + redeliveryCount + \" times\");\n            }\n        }\n    }","commit_id":"70d1405ce544a947a96c84a3c87f6663939e1e93","url":"https://github.com/mulesoft/mule"},{"original_method":"public void onException(JMSException jmsException)\n    {\n        final JmsConnector jmsConnector = JmsConnector.this;\n        Map receivers = jmsConnector.getReceivers();\n        boolean isMultiConsumerReceiver = false;\n        \n        if (!receivers.isEmpty()) \n        {\n            Map.Entry entry = (Map.Entry) receivers.entrySet().iterator().next();\n            if (entry.getValue() instanceof MultiConsumerJmsMessageReceiver)\n            {\n                isMultiConsumerReceiver = true;\n            }\n        }\n        \n        int expectedReceiverCount = isMultiConsumerReceiver ? 1 : \n            (jmsConnector.getReceivers().size() * jmsConnector.getNumberOfConcurrentTransactedReceivers());\n        \n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"About to recycle myself due to remote JMS connection shutdown but need \"\n                + \"to wait for all active receivers to report connection loss. Receiver count: \" \n                + (receiverReportedExceptionCount.get() + 1) + '/' + expectedReceiverCount);\n        }\n        \n        if (receiverReportedExceptionCount.incrementAndGet() >= expectedReceiverCount)\n        {\n            receiverReportedExceptionCount.set(0);\n        \n            handleException(new ConnectException(jmsException, this));\n        }\n    }","id":83858,"modified_method":"public void onException(JMSException jmsException)\n    {\n        final JmsConnector jmsConnector = JmsConnector.this;\n        Map receivers = jmsConnector.getReceivers();\n        boolean isMultiConsumerReceiver = false;\n        \n        if (!receivers.isEmpty()) \n        {\n            Map.Entry entry = (Map.Entry) receivers.entrySet().iterator().next();\n            if (entry.getValue() instanceof MultiConsumerJmsMessageReceiver)\n            {\n                isMultiConsumerReceiver = true;\n            }\n        }\n        \n        int expectedReceiverCount = isMultiConsumerReceiver ? 1 : \n            (jmsConnector.getReceivers().size() * jmsConnector.getNumberOfConcurrentTransactedReceivers());\n        \n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"About to recycle myself due to remote JMS connection shutdown but need \"\n                + \"to wait for all active receivers to report connection loss. Receiver count: \" \n                + (receiverReportedExceptionCount.get() + 1) + '/' + expectedReceiverCount);\n        }\n        \n        if (receiverReportedExceptionCount.incrementAndGet() >= expectedReceiverCount)\n        {\n            receiverReportedExceptionCount.set(REDELIVERY_FAIL_ON_FIRST);\n        \n            handleException(new ConnectException(jmsException, this));\n        }\n    }","commit_id":"70d1405ce544a947a96c84a3c87f6663939e1e93","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * process the redelivered message. If the Jms receiver should process the\n     * message, it should be returned. Otherwise the connector should throw a\n     * <code>MessageRedeliveredException<\/code> to indicate that the message should\n     * be handled by the connector Exception Handler.\n     * \n     */\n    public void handleRedelivery(Message message) throws JMSException, MuleException\n    {\n        if (connector.getMaxRedelivery() <= 0)\n        {\n            return;\n        }\n\n        String messageId = message.getJMSMessageID();\n        int deliveryCount = -1;\n        try\n        {\n            deliveryCount = message.getIntProperty(JmsConstants.JMS_X_DELIVERY_COUNT);\n        }\n        catch (NumberFormatException nex)\n        {\n            throw new MuleRuntimeException(MessageFactory.createStaticMessage(String.format(\n                    \"Invalid use of %s. Message is flagged with JMSRedelivered, but JMSXDeliveryCount is not set\",\n                    getClass().getName())));\n        }\n\n        int redeliveryCount = deliveryCount - 1;\n\n        if (redeliveryCount == 1)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Message with id: \" + messageId + \" has been redelivered for the first time\");\n            }\n        }\n        else if (redeliveryCount > connector.getMaxRedelivery())\n        {\n            logger.debug(MessageFormat.format(\n                    \"Message with id: {0} has been redelivered {1} times, which exceeds the maxRedelivery setting \" +\n                    \"of {2} on the connector {3}\", messageId, redeliveryCount, connector.getMaxRedelivery(), connector.getName()));\n\n            JmsMessageAdapter adapter = (JmsMessageAdapter) connector.getMessageAdapter(message);\n            throw new MessageRedeliveredException(\n                JmsMessages.tooManyRedeliveries(messageId, String.valueOf(redeliveryCount),\n                                                connector.getMaxRedelivery(), connector.getName()), new DefaultMuleMessage(adapter, connector.getMuleContext()));\n\n        }\n        else\n        {\n            if (logger.isDebugEnabled())\n            {\n                // re-delivery count is actually less by 1 than an actual delivery count\n                logger.debug(\"Message with id: \" + messageId + \" has been redelivered \" + redeliveryCount + \" times\");\n            }\n        }\n    }","id":83859,"modified_method":"/**\n     * process the redelivered message. If the Jms receiver should process the\n     * message, it should be returned. Otherwise the connector should throw a\n     * <code>MessageRedeliveredException<\/code> to indicate that the message should\n     * be handled by the connector Exception Handler.\n     * \n     */\n    public void handleRedelivery(Message message) throws JMSException, MuleException\n    {\n        final int connectorRedelivery = connector.getMaxRedelivery();\n        if (connectorRedelivery == JmsConnector.REDELIVERY_SWALLOW_MESSAGE ||\n                connectorRedelivery < 0 ) // just in case, for manual setting)\n        {\n            return;\n        }\n\n        String messageId = message.getJMSMessageID();\n\n        int deliveryCount = -1;\n        try\n        {\n            deliveryCount = message.getIntProperty(JmsConstants.JMS_X_DELIVERY_COUNT);\n        }\n        catch (NumberFormatException nex)\n        {\n            throw new MuleRuntimeException(MessageFactory.createStaticMessage(String.format(\n                    \"Invalid use of %s. Message is flagged with JMSRedelivered, but JMSXDeliveryCount is not set\",\n                    getClass().getName())));\n        }\n\n        int redeliveryCount = deliveryCount - 1;\n\n        if (redeliveryCount == 1)\n        {\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Message with id: \" + messageId + \" has been redelivered for the first time\");\n            }\n\n            if (connectorRedelivery == JmsConnector.REDELIVERY_FAIL_ON_FIRST)\n            {\n                JmsMessageAdapter adapter = (JmsMessageAdapter) connector.getMessageAdapter(message);\n                throw new MessageRedeliveredException(\n                        JmsMessages.tooManyRedeliveries(messageId, String.valueOf(redeliveryCount),\n                                                        connectorRedelivery, connector.getName()), new DefaultMuleMessage(adapter, connector.getMuleContext()));\n            }\n\n        }\n        else if (redeliveryCount > connectorRedelivery)\n        {\n            logger.debug(MessageFormat.format(\n                    \"Message with id: {0} has been redelivered {1} times, which exceeds the maxRedelivery setting \" +\n                    \"of {2} on the connector {3}\", messageId, redeliveryCount, connectorRedelivery, connector.getName()));\n\n            JmsMessageAdapter adapter = (JmsMessageAdapter) connector.getMessageAdapter(message);\n            throw new MessageRedeliveredException(\n                JmsMessages.tooManyRedeliveries(messageId, String.valueOf(redeliveryCount),\n                                                connectorRedelivery, connector.getName()), new DefaultMuleMessage(adapter, connector.getMuleContext()));\n\n        }\n        else\n        {\n            if (logger.isDebugEnabled())\n            {\n                // re-delivery count is actually less by 1 than an actual delivery count\n                logger.debug(\"Message with id: \" + messageId + \" has been redelivered \" + redeliveryCount + \" times\");\n            }\n        }\n    }","commit_id":"70d1405ce544a947a96c84a3c87f6663939e1e93","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void applyVendorSpecificConnectionFactoryProperties(ConnectionFactory connectionFactory)\n    {\n        try\n        {\n            Method getRedeliveryPolicyMethod = connectionFactory.getClass().getMethod(\"getRedeliveryPolicy\");\n            Object redeliveryPolicy = getRedeliveryPolicyMethod.invoke(connectionFactory);\n            Method setMaximumRedeliveriesMethod = redeliveryPolicy.getClass().getMethod(\"setMaximumRedeliveries\", Integer.TYPE);\n            // redelivery = deliveryCount - 1, but AMQ is considering the first delivery attempt as a redelivery (wrong!). adjust for it\n            setMaximumRedeliveriesMethod.invoke(redeliveryPolicy, getMaxRedelivery() + 1);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Can not set MaxRedelivery parameter to RedeliveryPolicy \" + e);\n        }\n    }","id":83860,"modified_method":"protected void applyVendorSpecificConnectionFactoryProperties(ConnectionFactory connectionFactory)\n    {\n        try\n        {\n            Method getRedeliveryPolicyMethod = connectionFactory.getClass().getMethod(\"getRedeliveryPolicy\");\n            Object redeliveryPolicy = getRedeliveryPolicyMethod.invoke(connectionFactory);\n            Method setMaximumRedeliveriesMethod = redeliveryPolicy.getClass().getMethod(\"setMaximumRedeliveries\", Integer.TYPE);\n            int maxRedelivery = getMaxRedelivery();\n            if (maxRedelivery != REDELIVERY_IGNORE )\n            {\n                // redelivery = deliveryCount - 1, but AMQ is considering the first delivery attempt as a redelivery (wrong!). adjust for it\n                maxRedelivery++;\n            }\n            setMaximumRedeliveriesMethod.invoke(redeliveryPolicy, maxRedelivery);\n        }\n        catch (Exception e)\n        {\n            logger.error(\"Can not set MaxRedelivery parameter to RedeliveryPolicy \" + e);\n        }\n    }","commit_id":"d7bd42353e0725e5d2555d6acce92a1426bf64c6","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void testRedelivery() throws Exception\n    {\n        MuleClient client = muleContext.getClient();\n        // required if broker is not restarted with the test - it tries to deliver those messages to the\n        // client\n        // purge the queue\n        while (client.request(DESTINATION, 1000) != null)\n        {\n            logger.warn(\"Destination \" + DESTINATION + \" isn't empty, draining it\");\n        }\n\n        FunctionalTestComponent ftc = getFunctionalTestComponent(\"Bouncer\");\n\n        // whether a MessageRedeliverdException has been fired\n        final Latch messageRedeliveryExceptionFired = new Latch();\n        muleContext.registerListener(new ExceptionNotificationListener<ExceptionNotification>()\n        {\n            public void onNotification(ExceptionNotification notification)\n            {\n                logger.debug(\"onNotification() = \" + notification.getException().getClass().getName());\n                if (notification.getException() instanceof MessageRedeliveredException)\n                {\n                    messageRedeliveryExceptionFired.countDown();\n                    // Test for MULE-4630\n                    assertEquals(DESTINATION,\n                        ((MessageRedeliveredException) notification.getException()).getEndpoint()\n                            .getEndpointURI()\n                            .toString());\n                    assertEquals(MAX_REDELIVERY,\n                        ((MessageRedeliveredException) notification.getException()).getMaxRedelivery());\n                    assertTrue(((MessageRedeliveredException) notification.getException()).getMuleMessage()\n                        .getPayload() instanceof javax.jms.Message);\n                }\n            }\n        });\n\n        // enhance the counter callback to count, then throw an exception\n        final CounterCallback callback = new CounterCallback()\n        {\n            @Override\n            public void eventReceived(MuleEventContext context, Object Component) throws Exception\n            {\n                final int count = incCallbackCount();\n                logger.info(\"Message Delivery Count is: \" + count);\n                throw new FunctionalTestException();\n            }\n        };\n        ftc.setEventCallback(callback);\n\n        client.dispatch(DESTINATION, TEST_MESSAGE, null);\n\n        Thread.sleep(2000);\n        if (!messageRedeliveryExceptionFired.await(timeout, TimeUnit.MILLISECONDS))\n        {\n            fail(\"Exception from FunctionalTestComponent was not triggered three times\");\n        }\n        assertEquals(\"MessageRedeliveredException never fired.\", 0, messageRedeliveryExceptionFired.getCount());\n        assertEquals(\"Wrong number of delivery attempts\", MAX_REDELIVERY + 1, callback.getCallbackCount());\n\n    }","id":83861,"modified_method":"@Test\n    public void testRedelivery() throws Exception\n    {\n        client.dispatch(JMS_INPUT_QUEUE, TEST_MESSAGE, null);\n\n        assertTrue(messageRedeliveryExceptionFired.await(timeout, TimeUnit.MILLISECONDS));\n        assertEquals(\"MessageRedeliveredException never fired.\", 0, messageRedeliveryExceptionFired.getCount());\n        assertEquals(\"Wrong number of delivery attempts\", MAX_REDELIVERY + 1, callback.getCallbackCount());\n\n        assertMessageInDlq();\n    }","commit_id":"d7bd42353e0725e5d2555d6acce92a1426bf64c6","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n  public org.jetbrains.mps.openapi.model.SModel getModel() {\n    return myModel == null ? null : myModel.getModelDescriptor();\n  }","id":83862,"modified_method":"@Override\n  public org.jetbrains.mps.openapi.model.SModel getModel() {\n    return getRealModel();\n  }","commit_id":"9dd18bc47e24a063a2417a33162c0c2f8647f2e1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SModelBase getRealModel() {\n    SModel persistentModel = getPersistentModel();\n    return persistentModel == null ? null : persistentModel.getModelDescriptor();\n  }","id":83863,"modified_method":"private SModelBase getRealModel() {\n    final SModel persistentModel = myModel;\n    return persistentModel == null ? null : persistentModel.getModelDescriptor();\n  }","commit_id":"9dd18bc47e24a063a2417a33162c0c2f8647f2e1","url":"https://github.com/JetBrains/MPS"},{"original_method":"void fireNodeRead(boolean needUnclassified) {\n    // nodeRead()\n    if (myModel == null || !myModel.isUpdateMode()) {\n      SModelBase md = getRealModel();\n      if (md != null) {\n        md.fireNodeRead(this);\n      }\n    }\n    if (myModel == null || !myModel.canFireEvent()) {\n      return;\n    }\n    // fireNodeReadAccess()\n    NodeReadAccessCasterInEditor.fireNodeReadAccessed(this);\n    if (needUnclassified) {\n      // fireNodeUnclassifiedReadAccess()\n      NodeReadEventsCaster.fireNodeUnclassifiedReadAccess(this);\n    }\n  }","id":83864,"modified_method":"void fireNodeRead(boolean needUnclassified) {\n    // nodeRead()\n    if (myModel == null || myModel.isUpdateMode()) {\n      return;\n    }\n    SModelBase md = getRealModel();\n    if (md != null) {\n      md.fireNodeRead(this);\n    }\n    if (!myModel.canFireReadEvent()) {\n      return;\n    }\n    // fireNodeReadAccess()\n    NodeReadAccessCasterInEditor.fireNodeReadAccessed(this);\n    if (needUnclassified) {\n      // fireNodeUnclassifiedReadAccess()\n      NodeReadEventsCaster.fireNodeUnclassifiedReadAccess(this);\n    }\n  }","commit_id":"9dd18bc47e24a063a2417a33162c0c2f8647f2e1","url":"https://github.com/JetBrains/MPS"},{"original_method":"void firePropertyRead(SProperty p, String value, boolean hasProperty) {\n    // propertyRead();\n    if (myModel == null || !myModel.isUpdateMode()) {\n      SModelBase md = getRealModel();\n      if (md != null) {\n        md.firePropertyRead(this, p.getName());\n      }\n    }\n    //firePropertyReadAccessInEditor();\n    //fireNodePropertyReadAccess();\n    if (myModel == null || !myModel.canFireReadEvent()) {\n      return;\n    }\n    final String propertyName = p.getName();\n    NodeReadAccessCasterInEditor.firePropertyReadAccessed(this, propertyName, hasProperty);\n    NodeReadEventsCaster.fireNodePropertyReadAccess(this, propertyName, value);\n  }","id":83865,"modified_method":"void firePropertyRead(SProperty p, String value, boolean hasProperty) {\n    // propertyRead();\n    if (myModel == null || myModel.isUpdateMode()) {\n      return;\n    }\n    SModelBase md = getRealModel();\n    if (md != null) {\n      md.firePropertyRead(this, p.getName());\n    }\n    //firePropertyReadAccessInEditor();\n    //fireNodePropertyReadAccess();\n    if (!myModel.canFireReadEvent()) {\n      return;\n    }\n    final String propertyName = p.getName();\n    NodeReadAccessCasterInEditor.firePropertyReadAccessed(this, propertyName, hasProperty);\n    NodeReadEventsCaster.fireNodePropertyReadAccess(this, propertyName, value);\n  }","commit_id":"9dd18bc47e24a063a2417a33162c0c2f8647f2e1","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * @param link not null\n   * @param target may be null\n   */\n  private void fireReferenceRead(SReferenceLink link, SNode target) {\n    fireNodeRead(false);\n    // referenceRead()\n    if (myModel == null || !myModel.isUpdateMode()) {\n      SModelBase md = getRealModel();\n      if (md != null) {\n        md.fireReferenceRead(this, link.getRoleName());\n      }\n    }\n    // fireNodeReferentReadAccess();\n    if (myModel != null && myModel.canFireReadEvent()) {\n      NodeReadEventsCaster.fireNodeReferentReadAccess(this, link.getRoleName(), target);\n    }\n  }","id":83866,"modified_method":"/**\n   * @param link not null\n   * @param target may be null\n   */\n  private void fireReferenceRead(SReferenceLink link, SNode target) {\n    fireNodeRead(false);\n    // referenceRead()\n    if (myModel == null || myModel.isUpdateMode()) {\n      return;\n    }\n    SModelBase md = getRealModel();\n    if (md != null) {\n      md.fireReferenceRead(this, link.getRoleName());\n    }\n    // fireNodeReferentReadAccess();\n    if (myModel.canFireReadEvent()) {\n      NodeReadEventsCaster.fireNodeReferentReadAccess(this, link.getRoleName(), target);\n    }\n  }","commit_id":"9dd18bc47e24a063a2417a33162c0c2f8647f2e1","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void doSignature(AbstractTokenWrapper wrapper, List<WSEncryptionPart> sigParts, boolean attached) \n        throws WSSecurityException, SOAPException {\n        \n        if (!isRequestor()) {\n            assertUnusedTokens(abinding.getInitiatorToken());\n            assertUnusedTokens(abinding.getInitiatorEncryptionToken());\n            assertUnusedTokens(abinding.getInitiatorSignatureToken());\n        } else {\n            assertUnusedTokens(abinding.getRecipientToken());\n            assertUnusedTokens(abinding.getRecipientEncryptionToken());\n            assertUnusedTokens(abinding.getRecipientSignatureToken());\n        }\n        \n        AbstractToken sigToken = wrapper.getToken();\n        if (sigParts.isEmpty()) {\n            // Add the BST to the security header if required\n            if (!attached && isTokenRequired(sigToken.getIncludeTokenType())) {\n                WSSecSignature sig = getSignatureBuilder(sigToken, attached, false);\n                sig.appendBSTElementToHeader(secHeader);\n            } \n            return;\n        }\n        if (sigToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys) {\n            // Set up the encrypted key to use\n            setupEncryptedKey(wrapper, sigToken);\n            \n            WSSecDKSign dkSign = new WSSecDKSign();\n            dkSign.setIdAllocator(wssConfig.getIdAllocator());\n            dkSign.setCallbackLookup(callbackLookup);\n            dkSign.setAttachmentCallbackHandler(new AttachmentCallbackHandler(message));\n            dkSign.setStoreBytesInAttachment(storeBytesInAttachment);\n            if (wrapper.getToken().getVersion() == SPConstants.SPVersion.SP11) {\n                dkSign.setWscVersion(ConversationConstants.VERSION_05_02);\n            }\n            \n            dkSign.setExternalKey(this.encryptedKeyValue, this.encryptedKeyId);\n\n            // Set the algo info\n            dkSign.setSignatureAlgorithm(abinding.getAlgorithmSuite().getSymmetricSignature());\n            dkSign.setSigCanonicalization(abinding.getAlgorithmSuite().getC14n().getValue());\n            AlgorithmSuiteType algType = abinding.getAlgorithmSuite().getAlgorithmSuiteType();\n            dkSign.setDigestAlgorithm(algType.getDigest());\n            dkSign.setDerivedKeyLength(algType.getSignatureDerivedKeyLength() / 8);\n            dkSign.setCustomValueType(WSConstants.SOAPMESSAGE_NS11 + \"#\"\n                    + WSConstants.ENC_KEY_VALUE_TYPE);\n            \n            boolean includePrefixes = \n                MessageUtils.getContextualBoolean(\n                    message, SecurityConstants.ADD_INCLUSIVE_PREFIXES, true\n                );\n            dkSign.setAddInclusivePrefixes(includePrefixes);\n            \n            try {\n                dkSign.prepare(saaj.getSOAPPart(), secHeader);\n\n                if (abinding.isProtectTokens()) {\n                    assertPolicy(\n                        new QName(abinding.getName().getNamespaceURI(), SPConstants.PROTECT_TOKENS));\n                    if (bstElement != null) {\n                        WSEncryptionPart bstPart = \n                            new WSEncryptionPart(bstElement.getAttributeNS(WSConstants.WSU_NS, \"Id\"));\n                        bstPart.setElement(bstElement);\n                        sigParts.add(bstPart);\n                    } else {\n                        WSEncryptionPart ekPart = \n                            new WSEncryptionPart(encrKey.getId());\n                        ekPart.setElement(encrKey.getEncryptedKeyElement());\n                        sigParts.add(ekPart);\n                    }\n                }\n\n                dkSign.getParts().addAll(sigParts);\n\n                List<Reference> referenceList = dkSign.addReferencesToSign(sigParts, secHeader);\n\n                // Add elements to header\n                addDerivedKeyElement(dkSign.getdktElement());\n                \n                //Do signature\n                if (bottomUpElement == null) {\n                    dkSign.computeSignature(referenceList, false, null);\n                } else {\n                    dkSign.computeSignature(referenceList, true, bottomUpElement);\n                }\n                bottomUpElement = dkSign.getSignatureElement();\n                addSig(dkSign.getSignatureValue());\n                \n                mainSigId = dkSign.getSignatureId();\n            } catch (Exception ex) {\n                LOG.log(Level.FINE, ex.getMessage(), ex);\n                throw new Fault(ex);\n            }\n        } else {\n            WSSecSignature sig = getSignatureBuilder(sigToken, attached, false);\n                      \n            // This action must occur before sig.prependBSTElementToHeader\n            if (abinding.isProtectTokens()) {\n                assertPolicy(\n                    new QName(abinding.getName().getNamespaceURI(), SPConstants.PROTECT_TOKENS));\n                if (sig.getBSTTokenId() != null) {\n                    WSEncryptionPart bstPart = \n                        new WSEncryptionPart(sig.getBSTTokenId());\n                    bstPart.setElement(sig.getBinarySecurityTokenElement());\n                    sigParts.add(bstPart);\n                }\n                sig.prependBSTElementToHeader(secHeader);\n            }\n\n            List<Reference> referenceList = sig.addReferencesToSign(sigParts, secHeader);\n            //Do signature\n            if (bottomUpElement == null) {\n                sig.computeSignature(referenceList, false, null);\n            } else {\n                sig.computeSignature(referenceList, true, bottomUpElement);\n            }\n            bottomUpElement = sig.getSignatureElement();\n            \n            if (!abinding.isProtectTokens()) {\n                Element bstElement = sig.getBinarySecurityTokenElement();\n                if (bstElement != null) {\n                    secHeader.getSecurityHeader().insertBefore(bstElement, bottomUpElement);\n                }\n            }\n            \n            addSig(sig.getSignatureValue());\n                        \n            mainSigId = sig.getId();\n        }\n    }","id":83867,"modified_method":"private void doSignature(AbstractTokenWrapper wrapper, List<WSEncryptionPart> sigParts, boolean attached) \n        throws WSSecurityException, SOAPException {\n        \n        if (!isRequestor()) {\n            assertUnusedTokens(abinding.getInitiatorToken());\n            assertUnusedTokens(abinding.getInitiatorEncryptionToken());\n            assertUnusedTokens(abinding.getInitiatorSignatureToken());\n        } else {\n            assertUnusedTokens(abinding.getRecipientToken());\n            assertUnusedTokens(abinding.getRecipientEncryptionToken());\n            assertUnusedTokens(abinding.getRecipientSignatureToken());\n        }\n        \n        AbstractToken sigToken = wrapper.getToken();\n        if (sigParts.isEmpty()) {\n            // Add the BST to the security header if required\n            if (!attached && isTokenRequired(sigToken.getIncludeTokenType())) {\n                WSSecSignature sig = getSignatureBuilder(sigToken, attached, false);\n                sig.appendBSTElementToHeader(secHeader);\n            } \n            return;\n        }\n        if (sigToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys) {\n            // Set up the encrypted key to use\n            setupEncryptedKey(wrapper, sigToken);\n            \n            WSSecDKSign dkSign = new WSSecDKSign();\n            dkSign.setIdAllocator(wssConfig.getIdAllocator());\n            dkSign.setCallbackLookup(callbackLookup);\n            dkSign.setAttachmentCallbackHandler(new AttachmentCallbackHandler(message));\n            dkSign.setStoreBytesInAttachment(storeBytesInAttachment);\n            if (wrapper.getToken().getVersion() == SPConstants.SPVersion.SP11) {\n                dkSign.setWscVersion(ConversationConstants.VERSION_05_02);\n            }\n            \n            dkSign.setExternalKey(this.encryptedKeyValue, this.encryptedKeyId);\n\n            // Set the algo info\n            dkSign.setSignatureAlgorithm(abinding.getAlgorithmSuite().getSymmetricSignature());\n            dkSign.setSigCanonicalization(abinding.getAlgorithmSuite().getC14n().getValue());\n            AlgorithmSuiteType algType = abinding.getAlgorithmSuite().getAlgorithmSuiteType();\n            dkSign.setDigestAlgorithm(algType.getDigest());\n            dkSign.setDerivedKeyLength(algType.getSignatureDerivedKeyLength() / 8);\n            dkSign.setCustomValueType(WSConstants.SOAPMESSAGE_NS11 + \"#\"\n                    + WSConstants.ENC_KEY_VALUE_TYPE);\n            \n            boolean includePrefixes = \n                MessageUtils.getContextualBoolean(\n                    message, SecurityConstants.ADD_INCLUSIVE_PREFIXES, true\n                );\n            dkSign.setAddInclusivePrefixes(includePrefixes);\n            \n            try {\n                dkSign.prepare(saaj.getSOAPPart(), secHeader);\n\n                if (abinding.isProtectTokens()) {\n                    assertPolicy(\n                        new QName(abinding.getName().getNamespaceURI(), SPConstants.PROTECT_TOKENS));\n                    if (bstElement != null) {\n                        WSEncryptionPart bstPart = \n                            new WSEncryptionPart(bstElement.getAttributeNS(WSConstants.WSU_NS, \"Id\"));\n                        bstPart.setElement(bstElement);\n                        sigParts.add(bstPart);\n                    } else {\n                        WSEncryptionPart ekPart = \n                            new WSEncryptionPart(encrKey.getId());\n                        ekPart.setElement(encrKey.getEncryptedKeyElement());\n                        sigParts.add(ekPart);\n                    }\n                }\n\n                dkSign.getParts().addAll(sigParts);\n\n                List<Reference> referenceList = dkSign.addReferencesToSign(sigParts, secHeader);\n                if (!referenceList.isEmpty()) {\n                    // Add elements to header\n                    addDerivedKeyElement(dkSign.getdktElement());\n                    \n                    //Do signature\n                    if (bottomUpElement == null) {\n                        dkSign.computeSignature(referenceList, false, null);\n                    } else {\n                        dkSign.computeSignature(referenceList, true, bottomUpElement);\n                    }\n                    bottomUpElement = dkSign.getSignatureElement();\n                    addSig(dkSign.getSignatureValue());\n                    \n                    mainSigId = dkSign.getSignatureId();\n                }\n            } catch (Exception ex) {\n                LOG.log(Level.FINE, ex.getMessage(), ex);\n                throw new Fault(ex);\n            }\n        } else {\n            WSSecSignature sig = getSignatureBuilder(sigToken, attached, false);\n                      \n            // This action must occur before sig.prependBSTElementToHeader\n            if (abinding.isProtectTokens()) {\n                assertPolicy(\n                    new QName(abinding.getName().getNamespaceURI(), SPConstants.PROTECT_TOKENS));\n                if (sig.getBSTTokenId() != null) {\n                    WSEncryptionPart bstPart = \n                        new WSEncryptionPart(sig.getBSTTokenId());\n                    bstPart.setElement(sig.getBinarySecurityTokenElement());\n                    sigParts.add(bstPart);\n                }\n                sig.prependBSTElementToHeader(secHeader);\n            }\n\n            List<Reference> referenceList = sig.addReferencesToSign(sigParts, secHeader);\n            if (!referenceList.isEmpty()) {\n                //Do signature\n                if (bottomUpElement == null) {\n                    sig.computeSignature(referenceList, false, null);\n                } else {\n                    sig.computeSignature(referenceList, true, bottomUpElement);\n                }\n                bottomUpElement = sig.getSignatureElement();\n                \n                if (!abinding.isProtectTokens()) {\n                    Element bstElement = sig.getBinarySecurityTokenElement();\n                    if (bstElement != null) {\n                        secHeader.getSecurityHeader().insertBefore(bstElement, bottomUpElement);\n                    }\n                }\n                \n                addSig(sig.getSignatureValue());\n                            \n                mainSigId = sig.getId();\n            }\n        }\n    }","commit_id":"811f40df5523aee9eb938c2999aeac8d2fe7bf8d","url":"https://github.com/apache/cxf"},{"original_method":"private WSSecBase doEncryption(AbstractTokenWrapper recToken,\n                                    List<WSEncryptionPart> encrParts,\n                                    boolean externalRef) {\n        //Do encryption\n        if (recToken != null && recToken.getToken() != null && encrParts.size() > 0) {\n            AbstractToken encrToken = recToken.getToken();\n            assertPolicy(recToken);\n            assertPolicy(encrToken);\n            AlgorithmSuite algorithmSuite = abinding.getAlgorithmSuite();\n            if (encrToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys) {\n                return doEncryptionDerived(recToken, encrToken, encrParts, algorithmSuite);\n            } else {\n                try {\n                    WSSecEncrypt encr = new WSSecEncrypt();\n                    encr.setIdAllocator(wssConfig.getIdAllocator());\n                    encr.setCallbackLookup(callbackLookup);\n                    encr.setAttachmentCallbackHandler(new AttachmentCallbackHandler(message));\n                    encr.setStoreBytesInAttachment(storeBytesInAttachment);\n                    \n                    encr.setDocument(saaj.getSOAPPart());\n                    Crypto crypto = getEncryptionCrypto();\n                    \n                    SecurityToken securityToken = getSecurityToken();\n                    if (!isRequestor() && securityToken != null \n                        && recToken.getToken() instanceof SamlToken) {\n                        String tokenType = securityToken.getTokenType();\n                        if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                            || WSConstants.SAML_NS.equals(tokenType)) {\n                            encr.setCustomEKTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                            encr.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                            encr.setCustomEKTokenId(securityToken.getId());\n                        } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                            || WSConstants.SAML2_NS.equals(tokenType)) {\n                            encr.setCustomEKTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                            encr.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                            encr.setCustomEKTokenId(securityToken.getId());\n                        } else {\n                            setKeyIdentifierType(encr, encrToken);\n                        }\n                    } else {\n                        setKeyIdentifierType(encr, encrToken);\n                    }\n                    //\n                    // Using a stored cert is only suitable for the Issued Token case, where\n                    // we're extracting the cert from a SAML Assertion on the provider side\n                    //\n                    if (!isRequestor() && securityToken != null \n                        && securityToken.getX509Certificate() != null) {\n                        encr.setUseThisCert(securityToken.getX509Certificate());\n                    } else if (!isRequestor() && securityToken != null \n                        && securityToken.getKey() instanceof PublicKey) {\n                        encr.setUseThisPublicKey((PublicKey)securityToken.getKey());\n                    } else {\n                        setEncryptionUser(encr, encrToken, false, crypto);\n                    }\n                    if (!encr.isCertSet() && encr.getUseThisPublicKey() == null && crypto == null) {\n                        unassertPolicy(recToken, \"Missing security configuration. \"\n                                + \"Make sure jaxws:client element is configured \" \n                                + \"with a \" + SecurityConstants.ENCRYPT_PROPERTIES + \" value.\");\n                    }\n                    AlgorithmSuiteType algType = algorithmSuite.getAlgorithmSuiteType();\n                    encr.setSymmetricEncAlgorithm(algType.getEncryption());\n                    encr.setKeyEncAlgo(algType.getAsymmetricKeyWrap());\n                    encr.setMGFAlgorithm(algType.getMGFAlgo());\n                    encr.setDigestAlgorithm(algType.getEncryptionDigest());\n                    encr.prepare(saaj.getSOAPPart(), crypto);\n                    \n                    Element encryptedKeyElement = encr.getEncryptedKeyElement();\n                    List<Element> attachments = encr.getAttachmentEncryptedDataElements();\n                    //Encrypt, get hold of the ref list and add it\n                    if (externalRef) {\n                        Element refList = encr.encryptForRef(null, encrParts);\n                        if (refList != null) {\n                            insertBeforeBottomUp(refList);\n                        }\n                        if (attachments != null) {\n                            for (Element attachment : attachments) {\n                                this.insertBeforeBottomUp(attachment);\n                            }\n                        }\n                        this.addEncryptedKeyElement(encryptedKeyElement);\n                    } else {\n                        Element refList = encr.encryptForRef(null, encrParts);\n                        this.addEncryptedKeyElement(encryptedKeyElement);\n                        \n                        // Add internal refs\n                        if (refList != null) {\n                            encryptedKeyElement.appendChild(refList);\n                        }\n                        if (attachments != null) {\n                            for (Element attachment : attachments) {\n                                this.addEncryptedKeyElement(attachment);\n                            }\n                        }\n                    }\n\n                    // Put BST before EncryptedKey element\n                    if (encr.getBSTTokenId() != null) {\n                        encr.prependBSTElementToHeader(secHeader);\n                    }\n\n                    return encr;\n                } catch (WSSecurityException e) {\n                    LOG.log(Level.FINE, e.getMessage(), e);\n                    unassertPolicy(recToken, e);\n                }    \n            }\n        }\n        return null;\n    }","id":83868,"modified_method":"private WSSecBase doEncryption(AbstractTokenWrapper recToken,\n                                    List<WSEncryptionPart> encrParts,\n                                    boolean externalRef) {\n        //Do encryption\n        if (recToken != null && recToken.getToken() != null && encrParts.size() > 0) {\n            AbstractToken encrToken = recToken.getToken();\n            assertPolicy(recToken);\n            assertPolicy(encrToken);\n            AlgorithmSuite algorithmSuite = abinding.getAlgorithmSuite();\n            if (encrToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys) {\n                return doEncryptionDerived(recToken, encrToken, encrParts, algorithmSuite);\n            } else {\n                try {\n                    WSSecEncrypt encr = new WSSecEncrypt();\n                    encr.setIdAllocator(wssConfig.getIdAllocator());\n                    encr.setCallbackLookup(callbackLookup);\n                    encr.setAttachmentCallbackHandler(new AttachmentCallbackHandler(message));\n                    encr.setStoreBytesInAttachment(storeBytesInAttachment);\n                    \n                    encr.setDocument(saaj.getSOAPPart());\n                    Crypto crypto = getEncryptionCrypto();\n                    \n                    SecurityToken securityToken = getSecurityToken();\n                    if (!isRequestor() && securityToken != null \n                        && recToken.getToken() instanceof SamlToken) {\n                        String tokenType = securityToken.getTokenType();\n                        if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                            || WSConstants.SAML_NS.equals(tokenType)) {\n                            encr.setCustomEKTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                            encr.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                            encr.setCustomEKTokenId(securityToken.getId());\n                        } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                            || WSConstants.SAML2_NS.equals(tokenType)) {\n                            encr.setCustomEKTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                            encr.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                            encr.setCustomEKTokenId(securityToken.getId());\n                        } else {\n                            setKeyIdentifierType(encr, encrToken);\n                        }\n                    } else {\n                        setKeyIdentifierType(encr, encrToken);\n                    }\n                    //\n                    // Using a stored cert is only suitable for the Issued Token case, where\n                    // we're extracting the cert from a SAML Assertion on the provider side\n                    //\n                    if (!isRequestor() && securityToken != null \n                        && securityToken.getX509Certificate() != null) {\n                        encr.setUseThisCert(securityToken.getX509Certificate());\n                    } else if (!isRequestor() && securityToken != null \n                        && securityToken.getKey() instanceof PublicKey) {\n                        encr.setUseThisPublicKey((PublicKey)securityToken.getKey());\n                    } else {\n                        setEncryptionUser(encr, encrToken, false, crypto);\n                    }\n                    if (!encr.isCertSet() && encr.getUseThisPublicKey() == null && crypto == null) {\n                        unassertPolicy(recToken, \"Missing security configuration. \"\n                                + \"Make sure jaxws:client element is configured \" \n                                + \"with a \" + SecurityConstants.ENCRYPT_PROPERTIES + \" value.\");\n                    }\n                    AlgorithmSuiteType algType = algorithmSuite.getAlgorithmSuiteType();\n                    encr.setSymmetricEncAlgorithm(algType.getEncryption());\n                    encr.setKeyEncAlgo(algType.getAsymmetricKeyWrap());\n                    encr.setMGFAlgorithm(algType.getMGFAlgo());\n                    encr.setDigestAlgorithm(algType.getEncryptionDigest());\n                    encr.prepare(saaj.getSOAPPart(), crypto);\n                    \n                    Element encryptedKeyElement = encr.getEncryptedKeyElement();\n                    List<Element> attachments = encr.getAttachmentEncryptedDataElements();\n                    //Encrypt, get hold of the ref list and add it\n                    if (externalRef) {\n                        Element refList = encr.encryptForRef(null, encrParts);\n                        if (refList != null) {\n                            insertBeforeBottomUp(refList);\n                        }\n                        if (attachments != null) {\n                            for (Element attachment : attachments) {\n                                this.insertBeforeBottomUp(attachment);\n                            }\n                        }\n                        if (refList != null || (attachments != null && !attachments.isEmpty())) {\n                            this.addEncryptedKeyElement(encryptedKeyElement);\n                        }\n                    } else {\n                        Element refList = encr.encryptForRef(null, encrParts);\n                        if (refList != null || (attachments != null && !attachments.isEmpty())) {\n                            this.addEncryptedKeyElement(encryptedKeyElement);\n                        }\n                        \n                        // Add internal refs\n                        if (refList != null) {\n                            encryptedKeyElement.appendChild(refList);\n                        }\n                        if (attachments != null) {\n                            for (Element attachment : attachments) {\n                                this.addEncryptedKeyElement(attachment);\n                            }\n                        }\n                    }\n\n                    // Put BST before EncryptedKey element\n                    if (encr.getBSTTokenId() != null) {\n                        encr.prependBSTElementToHeader(secHeader);\n                    }\n\n                    return encr;\n                } catch (WSSecurityException e) {\n                    LOG.log(Level.FINE, e.getMessage(), e);\n                    unassertPolicy(recToken, e);\n                }    \n            }\n        }\n        return null;\n    }","commit_id":"811f40df5523aee9eb938c2999aeac8d2fe7bf8d","url":"https://github.com/apache/cxf"},{"original_method":"private byte[] doSignature(List<WSEncryptionPart> sigs,\n                             AbstractTokenWrapper policyAbstractTokenWrapper, \n                             AbstractToken policyToken, \n                             SecurityToken tok,\n                             boolean included) throws WSSecurityException {\n        if (policyToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys) {\n            return doSignatureDK(sigs, policyAbstractTokenWrapper, policyToken, tok, included);\n        } else {\n            WSSecSignature sig = new WSSecSignature();\n            sig.setIdAllocator(wssConfig.getIdAllocator());\n            sig.setCallbackLookup(callbackLookup);\n            sig.setAttachmentCallbackHandler(new AttachmentCallbackHandler(message));\n            sig.setStoreBytesInAttachment(storeBytesInAttachment);\n            // If a EncryptedKeyToken is used, set the correct value type to\n            // be used in the wsse:Reference in ds:KeyInfo\n            int type = included ? WSConstants.CUSTOM_SYMM_SIGNING \n                : WSConstants.CUSTOM_SYMM_SIGNING_DIRECT;\n            String sigTokId = tok.getId();\n            if (policyToken instanceof X509Token) {\n                if (isRequestor()) {\n                    sig.setCustomTokenValueType(\n                        WSConstants.SOAPMESSAGE_NS11 + \"#\" + WSConstants.ENC_KEY_VALUE_TYPE\n                    );\n                    sig.setKeyIdentifierType(type);\n                } else {\n                    //the tok has to be an EncryptedKey token\n                    sig.setEncrKeySha1value(tok.getSHA1());\n                    sig.setKeyIdentifierType(WSConstants.ENCRYPTED_KEY_SHA1_IDENTIFIER);\n                }\n            } else if (policyToken instanceof UsernameToken) {\n                sig.setCustomTokenValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);\n                sig.setKeyIdentifierType(type);\n            } else if (policyToken instanceof KerberosToken) {\n                if (isRequestor()) {\n                    sig.setCustomTokenValueType(tok.getTokenType());\n                    sig.setKeyIdentifierType(type);\n                } else {\n                    sig.setCustomTokenValueType(WSConstants.WSS_KRB_KI_VALUE_TYPE);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                    sigTokId = tok.getSHA1();\n                }\n            } else {\n                //Setting the AttachedReference or the UnattachedReference according to the flag\n                Element ref;\n                if (included) {\n                    ref = tok.getAttachedReference();\n                } else {\n                    ref = tok.getUnattachedReference();\n                }\n                \n                if (ref != null) {\n                    SecurityTokenReference secRef = \n                        new SecurityTokenReference(cloneElement(ref), new BSPEnforcer());\n                    sig.setSecurityTokenReference(secRef);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                } else {\n                    String tokenType = tok.getTokenType();\n                    if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                        || WSConstants.SAML_NS.equals(tokenType)) {\n                        sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                        sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                    } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                        || WSConstants.SAML2_NS.equals(tokenType)) {\n                        sig.setCustomTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                        sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                    } else {\n                        sig.setCustomTokenValueType(tokenType);\n                        sig.setKeyIdentifierType(type);\n                    }\n                }\n            }\n            \n            if (included) {\n                sigTokId = tok.getWsuId();\n                if (sigTokId == null) {\n                    if (policyToken instanceof SecureConversationToken\n                        || policyToken instanceof SecurityContextToken) {\n                        sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING_DIRECT);\n                    }\n                    sigTokId = tok.getId();                    \n                }\n                if (sigTokId.startsWith(\"#\")) {\n                    sigTokId = sigTokId.substring(1);\n                }\n            }\n                      \n            if (sbinding.isProtectTokens()) {\n                assertPolicy(new QName(sbinding.getName().getNamespaceURI(), SPConstants.PROTECT_TOKENS));\n                if (included) {\n                    sigs.add(new WSEncryptionPart(sigTokId));\n                }\n            }\n            \n            sig.setCustomTokenId(sigTokId);\n            sig.setSecretKey(tok.getSecret());\n            sig.setSignatureAlgorithm(sbinding.getAlgorithmSuite().getSymmetricSignature());\n            \n            boolean includePrefixes = \n                MessageUtils.getContextualBoolean(\n                    message, SecurityConstants.ADD_INCLUSIVE_PREFIXES, true\n                );\n            sig.setAddInclusivePrefixes(includePrefixes);\n            \n            AlgorithmSuiteType algType = sbinding.getAlgorithmSuite().getAlgorithmSuiteType();\n            sig.setDigestAlgo(algType.getDigest());\n            sig.setSigCanonicalization(sbinding.getAlgorithmSuite().getC14n().getValue());\n            Crypto crypto = null;\n            if (sbinding.getProtectionToken() != null) {\n                crypto = getEncryptionCrypto();\n            } else {\n                crypto = getSignatureCrypto();\n            }\n            this.message.getExchange().put(SecurityConstants.SIGNATURE_CRYPTO, crypto);\n            sig.prepare(saaj.getSOAPPart(), crypto, secHeader);\n            sig.getParts().addAll(sigs);\n            List<Reference> referenceList = sig.addReferencesToSign(sigs, secHeader);\n\n            //Do signature\n            if (bottomUpElement == null) {\n                sig.computeSignature(referenceList, false, null);\n            } else {\n                sig.computeSignature(referenceList, true, bottomUpElement);\n            }\n            bottomUpElement = sig.getSignatureElement();\n\n            this.mainSigId = sig.getId();\n            return sig.getSignatureValue();\n        }\n    }","id":83869,"modified_method":"private byte[] doSignature(List<WSEncryptionPart> sigs,\n                             AbstractTokenWrapper policyAbstractTokenWrapper, \n                             AbstractToken policyToken, \n                             SecurityToken tok,\n                             boolean included) throws WSSecurityException {\n        if (policyToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys) {\n            return doSignatureDK(sigs, policyAbstractTokenWrapper, policyToken, tok, included);\n        } else {\n            WSSecSignature sig = new WSSecSignature();\n            sig.setIdAllocator(wssConfig.getIdAllocator());\n            sig.setCallbackLookup(callbackLookup);\n            sig.setAttachmentCallbackHandler(new AttachmentCallbackHandler(message));\n            sig.setStoreBytesInAttachment(storeBytesInAttachment);\n            // If a EncryptedKeyToken is used, set the correct value type to\n            // be used in the wsse:Reference in ds:KeyInfo\n            int type = included ? WSConstants.CUSTOM_SYMM_SIGNING \n                : WSConstants.CUSTOM_SYMM_SIGNING_DIRECT;\n            String sigTokId = tok.getId();\n            if (policyToken instanceof X509Token) {\n                if (isRequestor()) {\n                    sig.setCustomTokenValueType(\n                        WSConstants.SOAPMESSAGE_NS11 + \"#\" + WSConstants.ENC_KEY_VALUE_TYPE\n                    );\n                    sig.setKeyIdentifierType(type);\n                } else {\n                    //the tok has to be an EncryptedKey token\n                    sig.setEncrKeySha1value(tok.getSHA1());\n                    sig.setKeyIdentifierType(WSConstants.ENCRYPTED_KEY_SHA1_IDENTIFIER);\n                }\n            } else if (policyToken instanceof UsernameToken) {\n                sig.setCustomTokenValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);\n                sig.setKeyIdentifierType(type);\n            } else if (policyToken instanceof KerberosToken) {\n                if (isRequestor()) {\n                    sig.setCustomTokenValueType(tok.getTokenType());\n                    sig.setKeyIdentifierType(type);\n                } else {\n                    sig.setCustomTokenValueType(WSConstants.WSS_KRB_KI_VALUE_TYPE);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                    sigTokId = tok.getSHA1();\n                }\n            } else {\n                //Setting the AttachedReference or the UnattachedReference according to the flag\n                Element ref;\n                if (included) {\n                    ref = tok.getAttachedReference();\n                } else {\n                    ref = tok.getUnattachedReference();\n                }\n                \n                if (ref != null) {\n                    SecurityTokenReference secRef = \n                        new SecurityTokenReference(cloneElement(ref), new BSPEnforcer());\n                    sig.setSecurityTokenReference(secRef);\n                    sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                } else {\n                    String tokenType = tok.getTokenType();\n                    if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                        || WSConstants.SAML_NS.equals(tokenType)) {\n                        sig.setCustomTokenValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n                        sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                    } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                        || WSConstants.SAML2_NS.equals(tokenType)) {\n                        sig.setCustomTokenValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n                        sig.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                    } else {\n                        sig.setCustomTokenValueType(tokenType);\n                        sig.setKeyIdentifierType(type);\n                    }\n                }\n            }\n            \n            if (included) {\n                sigTokId = tok.getWsuId();\n                if (sigTokId == null) {\n                    if (policyToken instanceof SecureConversationToken\n                        || policyToken instanceof SecurityContextToken) {\n                        sig.setKeyIdentifierType(WSConstants.CUSTOM_SYMM_SIGNING_DIRECT);\n                    }\n                    sigTokId = tok.getId();                    \n                }\n                if (sigTokId.startsWith(\"#\")) {\n                    sigTokId = sigTokId.substring(1);\n                }\n            }\n                      \n            if (sbinding.isProtectTokens()) {\n                assertPolicy(new QName(sbinding.getName().getNamespaceURI(), SPConstants.PROTECT_TOKENS));\n                if (included) {\n                    sigs.add(new WSEncryptionPart(sigTokId));\n                }\n            }\n            \n            sig.setCustomTokenId(sigTokId);\n            sig.setSecretKey(tok.getSecret());\n            sig.setSignatureAlgorithm(sbinding.getAlgorithmSuite().getSymmetricSignature());\n            \n            boolean includePrefixes = \n                MessageUtils.getContextualBoolean(\n                    message, SecurityConstants.ADD_INCLUSIVE_PREFIXES, true\n                );\n            sig.setAddInclusivePrefixes(includePrefixes);\n            \n            AlgorithmSuiteType algType = sbinding.getAlgorithmSuite().getAlgorithmSuiteType();\n            sig.setDigestAlgo(algType.getDigest());\n            sig.setSigCanonicalization(sbinding.getAlgorithmSuite().getC14n().getValue());\n            Crypto crypto = null;\n            if (sbinding.getProtectionToken() != null) {\n                crypto = getEncryptionCrypto();\n            } else {\n                crypto = getSignatureCrypto();\n            }\n            this.message.getExchange().put(SecurityConstants.SIGNATURE_CRYPTO, crypto);\n            sig.prepare(saaj.getSOAPPart(), crypto, secHeader);\n            sig.getParts().addAll(sigs);\n            List<Reference> referenceList = sig.addReferencesToSign(sigs, secHeader);\n            if (!referenceList.isEmpty()) {\n                //Do signature\n                if (bottomUpElement == null) {\n                    sig.computeSignature(referenceList, false, null);\n                } else {\n                    sig.computeSignature(referenceList, true, bottomUpElement);\n                }\n                bottomUpElement = sig.getSignatureElement();\n    \n                this.mainSigId = sig.getId();\n                return sig.getSignatureValue();\n            }\n            return null;\n        }\n    }","commit_id":"811f40df5523aee9eb938c2999aeac8d2fe7bf8d","url":"https://github.com/apache/cxf"},{"original_method":"private byte[] doSignatureDK(List<WSEncryptionPart> sigs,\n                               AbstractTokenWrapper policyAbstractTokenWrapper, \n                               AbstractToken policyToken, \n                               SecurityToken tok,\n                               boolean included) throws WSSecurityException {\n        Document doc = saaj.getSOAPPart();\n        WSSecDKSign dkSign = new WSSecDKSign();\n        dkSign.setIdAllocator(wssConfig.getIdAllocator());\n        dkSign.setCallbackLookup(callbackLookup);\n        dkSign.setAttachmentCallbackHandler(new AttachmentCallbackHandler(message));\n        dkSign.setStoreBytesInAttachment(storeBytesInAttachment);\n        if (policyAbstractTokenWrapper.getToken().getVersion() == SPConstants.SPVersion.SP11) {\n            dkSign.setWscVersion(ConversationConstants.VERSION_05_02);\n        }\n        \n        //Check for whether the token is attached in the message or not\n        boolean attached = false;\n        if (isTokenRequired(policyToken.getIncludeTokenType())) {\n            attached = true;\n        }\n        \n        // Setting the AttachedReference or the UnattachedReference according to the flag\n        Element ref;\n        if (attached) {\n            ref = tok.getAttachedReference();\n        } else {\n            ref = tok.getUnattachedReference();\n        }\n        \n        if (ref != null) {\n            dkSign.setExternalKey(tok.getSecret(), cloneElement(ref));\n        } else if (!isRequestor() && policyToken.getDerivedKeys() \n            == DerivedKeys.RequireDerivedKeys && tok.getSHA1() != null) {            \n            // If the Encrypted key used to create the derived key is not\n            // attached use key identifier as defined in WSS1.1 section\n            // 7.7 Encrypted Key reference\n            SecurityTokenReference tokenRef = new SecurityTokenReference(doc);\n            if (tok.getSHA1() != null) {\n                String tokenType = tok.getTokenType();\n                if (policyToken instanceof KerberosToken) {\n                    tokenRef.setKeyIdentifier(WSConstants.WSS_KRB_KI_VALUE_TYPE, tok.getSHA1(), true);\n                    if (tokenType == null) {\n                        tokenType = WSConstants.WSS_GSS_KRB_V5_AP_REQ;\n                    }\n                } else {\n                    tokenRef.setKeyIdentifierEncKeySHA1(tok.getSHA1());\n                    if (tokenType == null) {\n                        tokenType = WSConstants.WSS_ENC_KEY_VALUE_TYPE;\n                    }\n                }\n                tokenRef.addTokenType(tokenType);\n            }\n            dkSign.setExternalKey(tok.getSecret(), tokenRef.getElement());\n        } else {\n            if ((!attached && !isRequestor()) || policyToken instanceof SecureConversationToken \n                || policyToken instanceof SecurityContextToken) {\n                dkSign.setTokenIdDirectId(true);\n            }\n            dkSign.setExternalKey(tok.getSecret(), tok.getId());\n        }\n\n        //Set the algo info\n        dkSign.setSignatureAlgorithm(sbinding.getAlgorithmSuite().getSymmetricSignature());\n        dkSign.setSigCanonicalization(sbinding.getAlgorithmSuite().getC14n().getValue());\n        AlgorithmSuiteType algType = sbinding.getAlgorithmSuite().getAlgorithmSuiteType();\n        dkSign.setDigestAlgorithm(algType.getDigest());\n        dkSign.setDerivedKeyLength(algType.getSignatureDerivedKeyLength() / 8);\n        \n        boolean includePrefixes = \n            MessageUtils.getContextualBoolean(\n                message, SecurityConstants.ADD_INCLUSIVE_PREFIXES, true\n            );\n        dkSign.setAddInclusivePrefixes(includePrefixes);\n        \n        if (tok.getSHA1() != null) {\n            //Set the value type of the reference\n            String tokenType = tok.getTokenType();\n            if (tokenType == null) {\n                tokenType = WSConstants.WSS_ENC_KEY_VALUE_TYPE;\n            }\n            dkSign.setCustomValueType(tokenType);\n        } else {\n            String tokenType = tok.getTokenType();\n            if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                || WSConstants.SAML_NS.equals(tokenType)) {\n                dkSign.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                dkSign.setCustomValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n            } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                || WSConstants.SAML2_NS.equals(tokenType)) {\n                dkSign.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                dkSign.setCustomValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n            } else if (policyToken instanceof UsernameToken) {\n                dkSign.setCustomValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);\n            } else {\n                dkSign.setCustomValueType(tokenType);\n            }\n        }\n        \n        dkSign.prepare(doc, secHeader);\n        \n        if (sbinding.isProtectTokens()) {\n            String sigTokId = tok.getId();\n            if (included) {\n                sigTokId = tok.getWsuId();\n                if (sigTokId == null) {\n                    sigTokId = tok.getId();\n                }\n                if (sigTokId.startsWith(\"#\")) {\n                    sigTokId = sigTokId.substring(1);\n                }\n            }\n            sigs.add(new WSEncryptionPart(sigTokId));\n            assertPolicy(\n                new QName(sbinding.getName().getNamespaceURI(), SPConstants.PROTECT_TOKENS));\n        }\n        \n        dkSign.getParts().addAll(sigs);\n        List<Reference> referenceList = dkSign.addReferencesToSign(sigs, secHeader);\n        \n        //Add elements to header\n        Element el = dkSign.getdktElement();\n        addDerivedKeyElement(el);\n        \n        //Do signature\n        if (bottomUpElement == null) {\n            dkSign.computeSignature(referenceList, false, null);\n        } else {\n            dkSign.computeSignature(referenceList, true, bottomUpElement);\n        }\n        bottomUpElement = dkSign.getSignatureElement();\n        \n        this.mainSigId = dkSign.getSignatureId();\n\n        return dkSign.getSignatureValue();        \n    }","id":83870,"modified_method":"private byte[] doSignatureDK(List<WSEncryptionPart> sigs,\n                               AbstractTokenWrapper policyAbstractTokenWrapper, \n                               AbstractToken policyToken, \n                               SecurityToken tok,\n                               boolean included) throws WSSecurityException {\n        Document doc = saaj.getSOAPPart();\n        WSSecDKSign dkSign = new WSSecDKSign();\n        dkSign.setIdAllocator(wssConfig.getIdAllocator());\n        dkSign.setCallbackLookup(callbackLookup);\n        dkSign.setAttachmentCallbackHandler(new AttachmentCallbackHandler(message));\n        dkSign.setStoreBytesInAttachment(storeBytesInAttachment);\n        if (policyAbstractTokenWrapper.getToken().getVersion() == SPConstants.SPVersion.SP11) {\n            dkSign.setWscVersion(ConversationConstants.VERSION_05_02);\n        }\n        \n        //Check for whether the token is attached in the message or not\n        boolean attached = false;\n        if (isTokenRequired(policyToken.getIncludeTokenType())) {\n            attached = true;\n        }\n        \n        // Setting the AttachedReference or the UnattachedReference according to the flag\n        Element ref;\n        if (attached) {\n            ref = tok.getAttachedReference();\n        } else {\n            ref = tok.getUnattachedReference();\n        }\n        \n        if (ref != null) {\n            dkSign.setExternalKey(tok.getSecret(), cloneElement(ref));\n        } else if (!isRequestor() && policyToken.getDerivedKeys() \n            == DerivedKeys.RequireDerivedKeys && tok.getSHA1() != null) {            \n            // If the Encrypted key used to create the derived key is not\n            // attached use key identifier as defined in WSS1.1 section\n            // 7.7 Encrypted Key reference\n            SecurityTokenReference tokenRef = new SecurityTokenReference(doc);\n            if (tok.getSHA1() != null) {\n                String tokenType = tok.getTokenType();\n                if (policyToken instanceof KerberosToken) {\n                    tokenRef.setKeyIdentifier(WSConstants.WSS_KRB_KI_VALUE_TYPE, tok.getSHA1(), true);\n                    if (tokenType == null) {\n                        tokenType = WSConstants.WSS_GSS_KRB_V5_AP_REQ;\n                    }\n                } else {\n                    tokenRef.setKeyIdentifierEncKeySHA1(tok.getSHA1());\n                    if (tokenType == null) {\n                        tokenType = WSConstants.WSS_ENC_KEY_VALUE_TYPE;\n                    }\n                }\n                tokenRef.addTokenType(tokenType);\n            }\n            dkSign.setExternalKey(tok.getSecret(), tokenRef.getElement());\n        } else {\n            if ((!attached && !isRequestor()) || policyToken instanceof SecureConversationToken \n                || policyToken instanceof SecurityContextToken) {\n                dkSign.setTokenIdDirectId(true);\n            }\n            dkSign.setExternalKey(tok.getSecret(), tok.getId());\n        }\n\n        //Set the algo info\n        dkSign.setSignatureAlgorithm(sbinding.getAlgorithmSuite().getSymmetricSignature());\n        dkSign.setSigCanonicalization(sbinding.getAlgorithmSuite().getC14n().getValue());\n        AlgorithmSuiteType algType = sbinding.getAlgorithmSuite().getAlgorithmSuiteType();\n        dkSign.setDigestAlgorithm(algType.getDigest());\n        dkSign.setDerivedKeyLength(algType.getSignatureDerivedKeyLength() / 8);\n        \n        boolean includePrefixes = \n            MessageUtils.getContextualBoolean(\n                message, SecurityConstants.ADD_INCLUSIVE_PREFIXES, true\n            );\n        dkSign.setAddInclusivePrefixes(includePrefixes);\n        \n        if (tok.getSHA1() != null) {\n            //Set the value type of the reference\n            String tokenType = tok.getTokenType();\n            if (tokenType == null) {\n                tokenType = WSConstants.WSS_ENC_KEY_VALUE_TYPE;\n            }\n            dkSign.setCustomValueType(tokenType);\n        } else {\n            String tokenType = tok.getTokenType();\n            if (WSConstants.WSS_SAML_TOKEN_TYPE.equals(tokenType)\n                || WSConstants.SAML_NS.equals(tokenType)) {\n                dkSign.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                dkSign.setCustomValueType(WSConstants.WSS_SAML_KI_VALUE_TYPE);\n            } else if (WSConstants.WSS_SAML2_TOKEN_TYPE.equals(tokenType)\n                || WSConstants.SAML2_NS.equals(tokenType)) {\n                dkSign.setKeyIdentifierType(WSConstants.CUSTOM_KEY_IDENTIFIER);\n                dkSign.setCustomValueType(WSConstants.WSS_SAML2_KI_VALUE_TYPE);\n            } else if (policyToken instanceof UsernameToken) {\n                dkSign.setCustomValueType(WSConstants.WSS_USERNAME_TOKEN_VALUE_TYPE);\n            } else {\n                dkSign.setCustomValueType(tokenType);\n            }\n        }\n        \n        dkSign.prepare(doc, secHeader);\n        \n        if (sbinding.isProtectTokens()) {\n            String sigTokId = tok.getId();\n            if (included) {\n                sigTokId = tok.getWsuId();\n                if (sigTokId == null) {\n                    sigTokId = tok.getId();\n                }\n                if (sigTokId.startsWith(\"#\")) {\n                    sigTokId = sigTokId.substring(1);\n                }\n            }\n            sigs.add(new WSEncryptionPart(sigTokId));\n            assertPolicy(\n                new QName(sbinding.getName().getNamespaceURI(), SPConstants.PROTECT_TOKENS));\n        }\n        \n        dkSign.getParts().addAll(sigs);\n        List<Reference> referenceList = dkSign.addReferencesToSign(sigs, secHeader);\n        if (!referenceList.isEmpty()) {\n            //Add elements to header\n            Element el = dkSign.getdktElement();\n            addDerivedKeyElement(el);\n            \n            //Do signature\n            if (bottomUpElement == null) {\n                dkSign.computeSignature(referenceList, false, null);\n            } else {\n                dkSign.computeSignature(referenceList, true, bottomUpElement);\n            }\n            bottomUpElement = dkSign.getSignatureElement();\n            \n            this.mainSigId = dkSign.getSignatureId();\n    \n            return dkSign.getSignatureValue();\n        }\n        return null;\n    }","commit_id":"811f40df5523aee9eb938c2999aeac8d2fe7bf8d","url":"https://github.com/apache/cxf"},{"original_method":"protected byte[] getSymmetricKeyBytes(Message message, Element encDataElement) {\n        Crypto crypto = null;\n        try {\n            crypto = new CryptoLoader().getCrypto(message,\n                               SecurityConstants.ENCRYPT_CRYPTO,\n                               SecurityConstants.ENCRYPT_PROPERTIES);\n        } catch (Exception ex) {\n            throwFault(\"Crypto can not be loaded\", ex);\n        }\n        \n        Element encKeyElement = getNode(encDataElement, WSConstants.ENC_NS, \"EncryptedKey\", 0);\n        if (encKeyElement == null) {\n            //TODO: support EncryptedData/ds:KeyInfo - the encrypted key is passed out of band\n            throwFault(\"EncryptedKey element is not available\", null);\n        }\n        \n        X509Certificate cert = loadCertificate(crypto, encKeyElement);\n        \n        try {\n            new TrustValidator().validateTrust(crypto, cert, null);\n        } catch (Exception ex) {\n            throwFault(ex.getMessage(), ex);\n        }\n        \n        // now start decrypting\n        String algorithm = getEncodingMethodAlgorithm(encKeyElement);\n        String digestAlgorithm = getDigestMethodAlgorithm(encKeyElement);\n        Element cipherValue = getNode(encKeyElement, WSConstants.ENC_NS, \n                                               \"CipherValue\", 0);\n        if (cipherValue == null) {\n            throwFault(\"CipherValue element is not available\", null);\n        }\n        try {\n            return decryptSymmetricKey(cipherValue.getTextContent().trim(),\n                                       cert,\n                                       crypto,\n                                       algorithm,\n                                       digestAlgorithm,\n                                       message);\n        } catch (Exception ex) {\n            throwFault(ex.getMessage(), ex);\n        }\n        return null;\n    }","id":83871,"modified_method":"protected byte[] getSymmetricKeyBytes(Message message, Element encDataElement) {\n        \n        String cryptoKey = null; \n        String propKey = null;\n        if (SecurityUtils.isSignedAndEncryptedTwoWay(message)) {\n            cryptoKey = SecurityConstants.SIGNATURE_CRYPTO;\n            propKey = SecurityConstants.SIGNATURE_PROPERTIES;\n        } else {\n            cryptoKey = SecurityConstants.ENCRYPT_CRYPTO;\n            propKey = SecurityConstants.ENCRYPT_PROPERTIES;\n        }\n        \n        Crypto crypto = null;\n        try {\n            crypto = new CryptoLoader().getCrypto(message, cryptoKey, propKey);\n        } catch (Exception ex) {\n            throwFault(\"Crypto can not be loaded\", ex);\n        }\n        \n        Element encKeyElement = getNode(encDataElement, WSConstants.ENC_NS, \"EncryptedKey\", 0);\n        if (encKeyElement == null) {\n            //TODO: support EncryptedData/ds:KeyInfo - the encrypted key is passed out of band\n            throwFault(\"EncryptedKey element is not available\", null);\n        }\n        \n        X509Certificate cert = loadCertificate(crypto, encKeyElement);\n        \n        try {\n            new TrustValidator().validateTrust(crypto, cert, null);\n        } catch (Exception ex) {\n            throwFault(ex.getMessage(), ex);\n        }\n        \n        // now start decrypting\n        String algorithm = getEncodingMethodAlgorithm(encKeyElement);\n        String digestAlgorithm = getDigestMethodAlgorithm(encKeyElement);\n        Element cipherValue = getNode(encKeyElement, WSConstants.ENC_NS, \n                                               \"CipherValue\", 0);\n        if (cipherValue == null) {\n            throwFault(\"CipherValue element is not available\", null);\n        }\n        try {\n            return decryptSymmetricKey(cipherValue.getTextContent().trim(),\n                                       cert,\n                                       crypto,\n                                       algorithm,\n                                       digestAlgorithm,\n                                       message);\n        } catch (Exception ex) {\n            throwFault(ex.getMessage(), ex);\n        }\n        return null;\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"protected void checkSignature(Message message) {\n        \n        Document doc = getDocument(message);\n        if (doc == null) {\n            return;\n        }\n\n        Element root = doc.getDocumentElement();\n        Element signatureElement = getSignatureElement(root);\n        if (signatureElement == null) {\n            throwFault(\"XML Signature is not available\", null);\n        }\n        \n        Crypto crypto = null;\n        try {\n            CryptoLoader loader = new CryptoLoader();\n            crypto = loader.getCrypto(message, \n                               SecurityConstants.SIGNATURE_CRYPTO,\n                               SecurityConstants.SIGNATURE_PROPERTIES);\n            if (crypto == null) {\n                crypto = loader.getCrypto(message, \n                                   SecurityConstants.ENCRYPT_CRYPTO,\n                                   SecurityConstants.ENCRYPT_PROPERTIES);\n            }\n        } catch (Exception ex) {\n            throwFault(\"Crypto can not be loaded\", ex);\n        }\n        boolean valid = false;\n        Reference ref = null;\n        try {\n            XMLSignature signature = new XMLSignature(signatureElement, \"\", true);  \n            ref = getReference(signature);\n            Element signedElement = validateReference(root, ref);\n            if (signedElement.hasAttributeNS(null, \"ID\")) {\n                signedElement.setIdAttributeNS(null, \"ID\", true);\n            }\n            \n            // See also WSS4J SAMLUtil.getCredentialFromKeyInfo \n            KeyInfo keyInfo = signature.getKeyInfo();\n            \n            X509Certificate cert = keyInfo.getX509Certificate();\n            if (cert != null) {\n                valid = signature.checkSignatureValue(cert);\n            } else {\n                PublicKey pk = keyInfo.getPublicKey();\n                if (pk != null) {\n                    valid = signature.checkSignatureValue(pk);\n                }\n            }\n            \n            // validate trust \n            new TrustValidator().validateTrust(crypto, cert, keyInfo.getPublicKey());\n            \n            if (valid && persistSignature) {\n                message.setContent(XMLSignature.class, signature);\n                message.setContent(Element.class, signedElement);\n            }\n        } catch (Exception ex) {\n            throwFault(\"Signature validation failed\", ex);\n        }\n        if (!valid) {\n            throwFault(\"Signature validation failed\", null);\n        }\n        if (removeSignature) {\n            if (!isEnveloping(root)) {\n                Element signedEl = getSignedElement(root, ref);\n                signedEl.removeAttribute(\"ID\");\n                root.removeChild(signatureElement);\n            } else {\n                Element actualBody = getActualBody(root);\n                Document newDoc = DOMUtils.createDocument();\n                newDoc.adoptNode(actualBody);\n                root = actualBody;\n            }\n        }\n        message.setContent(XMLStreamReader.class, \n                           new W3CDOMStreamReader(root));\n        message.setContent(InputStream.class, null);\n        \n    }","id":83872,"modified_method":"protected void checkSignature(Message message) {\n        \n        Document doc = getDocument(message);\n        if (doc == null) {\n            return;\n        }\n\n        Element root = doc.getDocumentElement();\n        Element signatureElement = getSignatureElement(root);\n        if (signatureElement == null) {\n            throwFault(\"XML Signature is not available\", null);\n        }\n        \n        String cryptoKey = null; \n        String propKey = null;\n        if (SecurityUtils.isSignedAndEncryptedTwoWay(message)) {\n            cryptoKey = SecurityConstants.ENCRYPT_CRYPTO;\n            propKey = SecurityConstants.ENCRYPT_PROPERTIES;\n        } else {\n            cryptoKey = SecurityConstants.SIGNATURE_CRYPTO;\n            propKey = SecurityConstants.SIGNATURE_PROPERTIES;    \n        }\n        \n        Crypto crypto = null;\n        try {\n            CryptoLoader loader = new CryptoLoader();\n            crypto = loader.getCrypto(message, cryptoKey, propKey);\n        } catch (Exception ex) {\n            throwFault(\"Crypto can not be loaded\", ex);\n        }\n        boolean valid = false;\n        Reference ref = null;\n        try {\n            XMLSignature signature = new XMLSignature(signatureElement, \"\", true);  \n            ref = getReference(signature);\n            Element signedElement = validateReference(root, ref);\n            if (signedElement.hasAttributeNS(null, \"ID\")) {\n                signedElement.setIdAttributeNS(null, \"ID\", true);\n            }\n            \n            // See also WSS4J SAMLUtil.getCredentialFromKeyInfo \n            KeyInfo keyInfo = signature.getKeyInfo();\n            \n            X509Certificate cert = keyInfo.getX509Certificate();\n            if (cert != null) {\n                valid = signature.checkSignatureValue(cert);\n            } else {\n                PublicKey pk = keyInfo.getPublicKey();\n                if (pk != null) {\n                    valid = signature.checkSignatureValue(pk);\n                }\n            }\n            \n            // validate trust \n            new TrustValidator().validateTrust(crypto, cert, keyInfo.getPublicKey());\n            \n            if (valid && persistSignature) {\n                message.setContent(XMLSignature.class, signature);\n                message.setContent(Element.class, signedElement);\n            }\n        } catch (Exception ex) {\n            throwFault(\"Signature validation failed\", ex);\n        }\n        if (!valid) {\n            throwFault(\"Signature validation failed\", null);\n        }\n        if (removeSignature) {\n            if (!isEnveloping(root)) {\n                Element signedEl = getSignedElement(root, ref);\n                signedEl.removeAttribute(\"ID\");\n                root.removeChild(signatureElement);\n            } else {\n                Element actualBody = getActualBody(root);\n                Document newDoc = DOMUtils.createDocument();\n                newDoc.adoptNode(actualBody);\n                root = actualBody;\n            }\n        }\n        message.setContent(XMLStreamReader.class, \n                           new W3CDOMStreamReader(root));\n        message.setContent(InputStream.class, null);\n        \n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPostEncryptedSignedBook() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlsec/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        properties.put(\"ws-security.signature.username\", \"alice\");\n        properties.put(\"ws-security.signature.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/alice.properties\");\n        doTestPostEncryptedBook(address, properties);\n        \n    }","id":83873,"modified_method":"@Test\n    public void testPostEncryptedSignedBook() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlsec/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        properties.put(\"ws-security.signature.username\", \"alice\");\n        properties.put(\"ws-security.signature.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/alice.properties\");\n        doTestPostEncryptedBook(address, true, properties);\n        \n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"public void doTestPostEncryptedBook(\n        String address, Map<String, Object> properties,\n        String keyIdentifierType, String symmetricAlgorithm,\n        String digestAlgorithm\n    ) throws Exception {\n        JAXRSClientFactoryBean bean = new JAXRSClientFactoryBean();\n        bean.setAddress(address);\n        \n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = JAXRSXmlSecTest.class.getResource(\"client.xml\");\n        Bus springBus = bf.createBus(busFile.toString());\n        bean.setBus(springBus);\n\n        bean.setProperties(properties);\n        bean.getOutInterceptors().add(new XmlSigOutInterceptor());\n        XmlEncOutInterceptor encInterceptor = new XmlEncOutInterceptor();\n        encInterceptor.setKeyIdentifierType(keyIdentifierType);\n        encInterceptor.setSymmetricEncAlgorithm(symmetricAlgorithm);\n        encInterceptor.setDigestAlgorithm(digestAlgorithm);\n        bean.getOutInterceptors().add(encInterceptor);\n        \n        bean.getInInterceptors().add(new XmlEncInInterceptor());\n        \n        WebClient wc = bean.createWebClient();\n        try {\n            Book book = wc.post(new Book(\"CXF\", 126L), Book.class);\n            assertEquals(126L, book.getId());\n        } catch (ServerWebApplicationException ex) {\n            fail(ex.getMessage());\n        } catch (ClientWebApplicationException ex) {\n            if (ex.getCause() != null && ex.getCause().getMessage() != null) {\n                fail(ex.getCause().getMessage());\n            } else {\n                fail(ex.getMessage());\n            }\n        }\n        \n    }","id":83874,"modified_method":"public void doTestPostEncryptedBook(\n        String address, boolean sign, Map<String, Object> properties,\n        String keyIdentifierType, String symmetricAlgorithm,\n        String digestAlgorithm\n    ) throws Exception {\n        JAXRSClientFactoryBean bean = new JAXRSClientFactoryBean();\n        bean.setAddress(address);\n        \n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = JAXRSXmlSecTest.class.getResource(\"client.xml\");\n        Bus springBus = bf.createBus(busFile.toString());\n        bean.setBus(springBus);\n\n        bean.setProperties(properties);\n        if (sign) {\n            bean.getOutInterceptors().add(new XmlSigOutInterceptor());\n        }\n        XmlEncOutInterceptor encInterceptor = new XmlEncOutInterceptor();\n        encInterceptor.setKeyIdentifierType(keyIdentifierType);\n        encInterceptor.setSymmetricEncAlgorithm(symmetricAlgorithm);\n        encInterceptor.setDigestAlgorithm(digestAlgorithm);\n        bean.getOutInterceptors().add(encInterceptor);\n        \n        bean.getInInterceptors().add(new XmlEncInInterceptor());\n        if (sign) {\n            bean.getInInterceptors().add(new XmlSigInInterceptor());\n        }\n        \n        \n        WebClient wc = bean.createWebClient();\n        WebClient.getConfig(wc).getHttpConduit().getClient().setReceiveTimeout(10000000L);\n        try {\n            Book book = wc.post(new Book(\"CXF\", 126L), Book.class);\n            assertEquals(126L, book.getId());\n        } catch (ServerWebApplicationException ex) {\n            fail(ex.getMessage());\n        } catch (ClientWebApplicationException ex) {\n            if (ex.getCause() != null && ex.getCause().getMessage() != null) {\n                fail(ex.getCause().getMessage());\n            } else {\n                fail(ex.getMessage());\n            }\n        }\n        \n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPostEncryptedBookGCM() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlenc/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        String aes128GCM = \"http://www.w3.org/2009/xmlenc11#aes128-gcm\";\n        doTestPostEncryptedBook(address, properties, SecurityUtils.X509_KEY, aes128GCM, null);\n    }","id":83875,"modified_method":"@Test\n    public void testPostEncryptedBookGCM() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlenc/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        String aes128GCM = \"http://www.w3.org/2009/xmlenc11#aes128-gcm\";\n        doTestPostEncryptedBook(address, false, properties, SecurityUtils.X509_KEY, aes128GCM, null);\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPostEncryptedBookSHA256() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlenc/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        doTestPostEncryptedBook(\n            address, properties, SecurityUtils.X509_KEY, XMLCipher.AES_128, XMLCipher.SHA256\n        );\n    }","id":83876,"modified_method":"@Test\n    public void testPostEncryptedBookSHA256() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlenc/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        doTestPostEncryptedBook(\n            address, false, properties, SecurityUtils.X509_KEY, XMLCipher.AES_128, XMLCipher.SHA256\n        );\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    //Encryption properties are shared by encryption and signature handlers\n    public void testPostEncryptedSignedBookSharedProps() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlsec2/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        doTestPostEncryptedBook(address, properties);\n        \n    }","id":83877,"modified_method":"@Test\n    public void testPostEncryptedSignedBookUseReqSigCert() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlsec-useReqSigCert/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        properties.put(\"ws-security.signature.username\", \"alice\");\n        properties.put(\"ws-security.signature.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/alice.properties\");\n        doTestPostEncryptedBook(address, true, properties);\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPostEncryptedBookIssuerSerial() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlenc/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        doTestPostEncryptedBook(\n            address, properties, SecurityUtils.X509_ISSUER_SERIAL, XMLCipher.AES_128, null\n        );\n    }","id":83878,"modified_method":"@Test\n    public void testPostEncryptedBookIssuerSerial() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlenc/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        doTestPostEncryptedBook(\n            address, false, properties, SecurityUtils.X509_ISSUER_SERIAL, XMLCipher.AES_128, null\n        );\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPostEncryptedBook() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlenc/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        doTestPostEncryptedBook(address, properties);\n    }","id":83879,"modified_method":"@Test\n    public void testPostEncryptedBook() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlenc/bookstore/books\";\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.encryption.username\", \"bob\");\n        properties.put(\"ws-security.encryption.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/bob.properties\");\n        doTestPostEncryptedBook(address, false, properties);\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"public void doTestPostEncryptedBook(String address, Map<String, Object> properties) \n        throws Exception {\n        doTestPostEncryptedBook(\n            address, properties, SecurityUtils.X509_KEY, XMLCipher.AES_128, null\n        );\n    }","id":83880,"modified_method":"public void doTestPostEncryptedBook(String address, boolean sign, Map<String, Object> properties) \n        throws Exception {\n        doTestPostEncryptedBook(\n            address, sign, properties, SecurityUtils.X509_KEY, XMLCipher.AES_128, null\n        );\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"public static String getUserName(Message message, Crypto crypto, String userNameKey) {\n        String user = (String)message.getContextualProperty(userNameKey);\n        if (crypto != null && StringUtils.isEmpty(user)) {\n            try {\n                user = crypto.getDefaultX509Identifier();\n            } catch (WSSecurityException e1) {\n                throw new Fault(e1);\n            }\n        }\n        return user;\n    }","id":83881,"modified_method":"public static String getUserName(Message message, Crypto crypto, String userNameKey) {\n        String user = (String)message.getContextualProperty(userNameKey);\n        return getUserName(crypto, user);\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"protected Document encryptDocument(Message message, Document payloadDoc) \n        throws Exception {\n        \n        byte[] secretKey = getSymmetricKey();\n\n        Document encryptedDataDoc = DOMUtils.createDocument();\n        Element encryptedDataElement = createEncryptedDataElement(encryptedDataDoc);\n        if (encryptSymmetricKey) {\n            CryptoLoader loader = new CryptoLoader();\n            Crypto crypto = loader.getCrypto(message, \n                                      SecurityConstants.ENCRYPT_CRYPTO,\n                                      SecurityConstants.ENCRYPT_PROPERTIES);\n            \n            String user = \n                SecurityUtils.getUserName(message, crypto, SecurityConstants.ENCRYPT_USERNAME);\n            if (StringUtils.isEmpty(user)) {\n                return null;\n            }\n            X509Certificate cert = getReceiverCertificate(crypto, user);\n            byte[] encryptedSecretKey = encryptSymmetricKey(secretKey, cert, crypto);\n\n            addEncryptedKeyElement(encryptedDataElement, cert, encryptedSecretKey);\n        }\n               \n        // encrypt payloadDoc\n        XMLCipher xmlCipher = \n            EncryptionUtils.initXMLCipher(symEncAlgo, XMLCipher.ENCRYPT_MODE, symmetricKey);\n        \n        Document result = xmlCipher.doFinal(payloadDoc, payloadDoc.getDocumentElement(), false);\n        NodeList list = result.getElementsByTagNameNS(WSConstants.ENC_NS, \"CipherValue\");\n        if (list.getLength() != 1) {\n            throw new WSSecurityException(\"Payload CipherData is missing\", null);\n        }\n        String cipherText = ((Element)list.item(0)).getTextContent().trim();\n        Element cipherValue = \n            createCipherValue(encryptedDataDoc, encryptedDataDoc.getDocumentElement());\n        cipherValue.appendChild(encryptedDataDoc.createTextNode(cipherText));\n         \n        //StaxUtils.copy(new DOMSource(encryptedDataDoc), System.out);\n        return encryptedDataDoc;\n    }","id":83882,"modified_method":"protected Document encryptDocument(Message message, Document payloadDoc) \n        throws Exception {\n        \n        byte[] secretKey = getSymmetricKey();\n\n        Document encryptedDataDoc = DOMUtils.createDocument();\n        Element encryptedDataElement = createEncryptedDataElement(encryptedDataDoc);\n        if (encryptSymmetricKey) {\n            X509Certificate receiverCert = null;\n            \n            String userName = (String)message.getContextualProperty(SecurityConstants.ENCRYPT_USERNAME);\n            if (userName != null \n                && SecurityUtils.USE_REQUEST_SIGNATURE_CERT.equals(userName)\n                && !MessageUtils.isRequestor(message)) {\n                XMLSignature sig = message.getExchange().getInMessage().getContent(XMLSignature.class);\n                if (sig != null) {\n                    receiverCert = sig.getKeyInfo().getX509Certificate(); \n                }\n            } else {\n                CryptoLoader loader = new CryptoLoader();\n                Crypto crypto = loader.getCrypto(message, \n                                          SecurityConstants.ENCRYPT_CRYPTO,\n                                          SecurityConstants.ENCRYPT_PROPERTIES);\n                \n                userName = SecurityUtils.getUserName(crypto, userName);\n                if (StringUtils.isEmpty(userName)) {\n                    throw new WSSecurityException(\"User name is not available\");\n                }\n                receiverCert = getReceiverCertificateFromCrypto(crypto, userName);\n            }\n            if (receiverCert == null) {\n                throw new WSSecurityException(\"Receiver certificate is not available\");\n            }\n\n            byte[] encryptedSecretKey = encryptSymmetricKey(secretKey, receiverCert);\n            addEncryptedKeyElement(encryptedDataElement, receiverCert, encryptedSecretKey);\n        }\n               \n        // encrypt payloadDoc\n        XMLCipher xmlCipher = \n            EncryptionUtils.initXMLCipher(symEncAlgo, XMLCipher.ENCRYPT_MODE, symmetricKey);\n        \n        Document result = xmlCipher.doFinal(payloadDoc, payloadDoc.getDocumentElement(), false);\n        NodeList list = result.getElementsByTagNameNS(WSConstants.ENC_NS, \"CipherValue\");\n        if (list.getLength() != 1) {\n            throw new WSSecurityException(\"Payload CipherData is missing\", null);\n        }\n        String cipherText = ((Element)list.item(0)).getTextContent().trim();\n        Element cipherValue = \n            createCipherValue(encryptedDataDoc, encryptedDataDoc.getDocumentElement());\n        cipherValue.appendChild(encryptedDataDoc.createTextNode(cipherText));\n         \n        //StaxUtils.copy(new DOMSource(encryptedDataDoc), System.out);\n        return encryptedDataDoc;\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"private X509Certificate getReceiverCertificate(Crypto crypto, String user) throws Exception {\n        X509Certificate[] certs = SecurityUtils.getCertificates(crypto, user);\n        return certs[0];\n    }","id":83883,"modified_method":"private X509Certificate getReceiverCertificateFromCrypto(Crypto crypto, String user) throws Exception {\n        X509Certificate[] certs = SecurityUtils.getCertificates(crypto, user);\n        return certs[0];\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"protected byte[] encryptSymmetricKey(byte[] keyBytes, \n                                         X509Certificate remoteCert,\n                                         Crypto crypto) throws WSSecurityException {\n        Cipher cipher = \n            EncryptionUtils.initCipherWithCert(\n                keyEncAlgo, digestAlgo, Cipher.ENCRYPT_MODE, remoteCert\n            );\n        int blockSize = cipher.getBlockSize();\n        if (blockSize > 0 && blockSize < keyBytes.length) {\n            String message = \"Public key algorithm too weak to encrypt symmetric key\";\n            LOG.severe(message);\n            throw new WSSecurityException(\n                WSSecurityException.FAILURE,\n                \"unsupportedKeyTransp\",\n                new Object[] {message}\n            );\n        }\n        byte[] encryptedEphemeralKey = null;\n        try {\n            encryptedEphemeralKey = cipher.doFinal(keyBytes);\n        } catch (IllegalStateException ex) {\n            throw new WSSecurityException(\n                WSSecurityException.FAILED_ENCRYPTION, null, null, ex\n            );\n        } catch (IllegalBlockSizeException ex) {\n            throw new WSSecurityException(\n                WSSecurityException.FAILED_ENCRYPTION, null, null, ex\n            );\n        } catch (BadPaddingException ex) {\n            throw new WSSecurityException(\n                WSSecurityException.FAILED_ENCRYPTION, null, null, ex\n            );\n        }\n       \n        return encryptedEphemeralKey;\n       \n    }","id":83884,"modified_method":"protected byte[] encryptSymmetricKey(byte[] keyBytes, \n                                         X509Certificate remoteCert) throws WSSecurityException {\n        Cipher cipher = \n            EncryptionUtils.initCipherWithCert(\n                keyEncAlgo, digestAlgo, Cipher.ENCRYPT_MODE, remoteCert\n            );\n        int blockSize = cipher.getBlockSize();\n        if (blockSize > 0 && blockSize < keyBytes.length) {\n            String message = \"Public key algorithm too weak to encrypt symmetric key\";\n            LOG.severe(message);\n            throw new WSSecurityException(\n                WSSecurityException.FAILURE,\n                \"unsupportedKeyTransp\",\n                new Object[] {message}\n            );\n        }\n        byte[] encryptedEphemeralKey = null;\n        try {\n            encryptedEphemeralKey = cipher.doFinal(keyBytes);\n        } catch (IllegalStateException ex) {\n            throw new WSSecurityException(\n                WSSecurityException.FAILED_ENCRYPTION, null, null, ex\n            );\n        } catch (IllegalBlockSizeException ex) {\n            throw new WSSecurityException(\n                WSSecurityException.FAILED_ENCRYPTION, null, null, ex\n            );\n        } catch (BadPaddingException ex) {\n            throw new WSSecurityException(\n                WSSecurityException.FAILED_ENCRYPTION, null, null, ex\n            );\n        }\n       \n        return encryptedEphemeralKey;\n       \n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"private Document createSignature(Message message, Document doc) \n        throws Exception {\n        \n        String userNameKey = SecurityConstants.SIGNATURE_USERNAME;\n        \n        CryptoLoader loader = new CryptoLoader();\n        Crypto crypto = loader.getCrypto(message, \n                                         SecurityConstants.SIGNATURE_CRYPTO,\n                                         SecurityConstants.SIGNATURE_PROPERTIES);\n        if (crypto == null) {\n            crypto = loader.getCrypto(message, \n                                      SecurityConstants.ENCRYPT_CRYPTO,\n                                      SecurityConstants.ENCRYPT_PROPERTIES);\n            userNameKey = SecurityConstants.ENCRYPT_USERNAME;\n        }\n        String user = SecurityUtils.getUserName(message, crypto, userNameKey);\n         \n        if (StringUtils.isEmpty(user)) {\n            return null;\n        }\n\n        String password = \n            SecurityUtils.getPassword(message, user, WSPasswordCallback.SIGNATURE, this.getClass());\n    \n        X509Certificate[] issuerCerts = SecurityUtils.getCertificates(crypto, user);\n        \n        String sigAlgo = defaultSigAlgo;\n        String pubKeyAlgo = issuerCerts[0].getPublicKey().getAlgorithm();\n        if (pubKeyAlgo.equalsIgnoreCase(\"DSA\")) {\n            sigAlgo = XMLSignature.ALGO_ID_SIGNATURE_DSA;\n        }\n        PrivateKey privateKey = null;\n        try {\n            privateKey = crypto.getPrivateKey(user, password);\n        } catch (Exception ex) {\n            String errorMessage = \"Private key can not be loaded, user:\" + user;\n            LOG.severe(errorMessage);\n            throw new WSSecurityException(errorMessage, ex);\n        }\n        \n        String id = UUID.randomUUID().toString();\n        String referenceId = \"#\" + id;\n        \n        XMLSignature sig = null;\n        if (ENVELOPING_SIG.equals(sigStyle)) {\n            sig = prepareEnvelopingSignature(doc, id, referenceId, sigAlgo);\n        } else if (DETACHED_SIG.equals(sigStyle)) {\n            sig = prepareDetachedSignature(doc, id, referenceId, sigAlgo);\n        } else {\n            sig = prepareEnvelopedSignature(doc, id, referenceId, sigAlgo);\n        }\n        \n        \n        sig.addKeyInfo(issuerCerts[0]);\n        sig.addKeyInfo(issuerCerts[0].getPublicKey());\n        sig.sign(privateKey);\n        return sig.getElement().getOwnerDocument();\n    }","id":83885,"modified_method":"private Document createSignature(Message message, Document doc) \n        throws Exception {\n        \n        String userNameKey = SecurityConstants.SIGNATURE_USERNAME;\n        \n        CryptoLoader loader = new CryptoLoader();\n        Crypto crypto = loader.getCrypto(message, \n                                         SecurityConstants.SIGNATURE_CRYPTO,\n                                         SecurityConstants.SIGNATURE_PROPERTIES);\n        String user = SecurityUtils.getUserName(message, crypto, userNameKey);\n         \n        if (StringUtils.isEmpty(user) || SecurityUtils.USE_REQUEST_SIGNATURE_CERT.equals(user)) {\n            throw new WSSecurityException(\"User name is not available\");\n        }\n\n        String password = \n            SecurityUtils.getPassword(message, user, WSPasswordCallback.SIGNATURE, this.getClass());\n    \n        X509Certificate[] issuerCerts = SecurityUtils.getCertificates(crypto, user);\n        \n        String sigAlgo = defaultSigAlgo;\n        String pubKeyAlgo = issuerCerts[0].getPublicKey().getAlgorithm();\n        if (pubKeyAlgo.equalsIgnoreCase(\"DSA\")) {\n            sigAlgo = XMLSignature.ALGO_ID_SIGNATURE_DSA;\n        }\n        PrivateKey privateKey = null;\n        try {\n            privateKey = crypto.getPrivateKey(user, password);\n        } catch (Exception ex) {\n            String errorMessage = \"Private key can not be loaded, user:\" + user;\n            LOG.severe(errorMessage);\n            throw new WSSecurityException(errorMessage, ex);\n        }\n        \n        String id = UUID.randomUUID().toString();\n        String referenceId = \"#\" + id;\n        \n        XMLSignature sig = null;\n        if (ENVELOPING_SIG.equals(sigStyle)) {\n            sig = prepareEnvelopingSignature(doc, id, referenceId, sigAlgo);\n        } else if (DETACHED_SIG.equals(sigStyle)) {\n            sig = prepareDetachedSignature(doc, id, referenceId, sigAlgo);\n        } else {\n            sig = prepareEnvelopedSignature(doc, id, referenceId, sigAlgo);\n        }\n        \n        \n        sig.addKeyInfo(issuerCerts[0]);\n        sig.addKeyInfo(issuerCerts[0].getPublicKey());\n        sig.sign(privateKey);\n        return sig.getElement().getOwnerDocument();\n    }","commit_id":"696d5503452cf3199a029a4b961a4aad07739691","url":"https://github.com/apache/cxf"},{"original_method":"public void init() {\n    EditorEventMulticaster eventMulticaster = EditorFactory.getInstance().getEventMulticaster();\n    EditorMouseAdapter myEditorMouseListener = new EditorMouseAdapter() {\n      private EditorMouseEvent myMousePressedEvent;\n\n      @Nullable\n      private Breakpoint toggleBreakpoint(final boolean mostSuitingBreakpoint, final int line) {\n        final Editor editor = FileEditorManager.getInstance(myProject).getSelectedTextEditor();\n        if (editor == null) {\n          return null;\n        }\n        final Document document = editor.getDocument();\n        final PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n        if (psiFile == null) {\n          return null;\n        }\n        final FileType fileType = psiFile.getFileType();\n        boolean isInsideCompiledClass = StdFileTypes.CLASS.equals(fileType);\n        if (!isInsideCompiledClass && !DebuggerUtils.supportsJVMDebugging(fileType)) {\n          return null;\n        }\n        PsiDocumentManager.getInstance(myProject).commitDocument(document);\n\n        int offset = editor.getCaretModel().getOffset();\n        int editorLine = editor.getDocument().getLineNumber(offset);\n        if (editorLine != line) {\n          if (line < 0 || line >= document.getLineCount()) {\n            return null;\n          }\n          offset = editor.getDocument().getLineStartOffset(line);\n        }\n\n        ExpandRegionHandler.expandRegionAtCaret(myProject, editor);\n\n        Breakpoint breakpoint = findBreakpoint(document, offset, null);\n        if (breakpoint == null) {\n          if (mostSuitingBreakpoint || isInsideCompiledClass) {\n            breakpoint = addFieldBreakpoint(document, offset);\n            if (breakpoint == null) {\n              breakpoint = addMethodBreakpoint(document, line);\n            }\n            if (breakpoint == null && !isInsideCompiledClass) {\n              breakpoint = addLineBreakpoint(document, line);\n            }\n          }\n          else {\n            breakpoint = addLineBreakpoint(document, line);\n\n            if (breakpoint == null) {\n              breakpoint = addMethodBreakpoint(document, line);\n            }\n          }\n\n          if (breakpoint != null) {\n            RequestManagerImpl.createRequests(breakpoint);\n          }\n          return breakpoint;\n        }\n        else {\n          removeBreakpoint(breakpoint);\n          return null;\n        }\n      }\n\n      private boolean isFromMyProject(Editor editor) {\n        FileEditor[] allEditors = FileEditorManager.getInstance(myProject).getAllEditors();\n        for (FileEditor ed : allEditors) {\n          if (!(ed instanceof TextEditor)) {\n            continue;\n          }\n          if (((TextEditor)ed).getEditor().equals(editor)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      //mousePressed + mouseReleased is a hack to keep selection in editor when shift is pressed\n      public void mousePressed(EditorMouseEvent e) {\n        if (MarkupEditorFilterFactory.createIsDiffFilter().avaliableIn(e.getEditor())) return;\n\n        if (e.isConsumed()) return;\n\n        if (e.getArea() == EditorMouseEventArea.LINE_MARKERS_AREA && e.getMouseEvent().isShiftDown()) {\n          myMousePressedEvent = e;\n          e.consume();\n        }\n      }\n\n      public void mouseReleased(EditorMouseEvent e) {\n        if (myMousePressedEvent != null) {\n          mouseClicked(e);\n        }\n        myMousePressedEvent = null;\n      }\n\n      public void mouseClicked(final EditorMouseEvent e) {\n        if (MarkupEditorFilterFactory.createIsDiffFilter().avaliableIn(e.getEditor())) return;\n\n        if (e.isConsumed()) return;\n\n        if (e.getArea() == EditorMouseEventArea.LINE_MARKERS_AREA) {\n          PsiDocumentManager.getInstance(myProject).commitAndRunReadAction(new Runnable() {\n            public void run() {\n              final Editor editor = e.getEditor();\n              if (!isFromMyProject(editor)) {\n                return;\n              }\n              final int line = editor.xyToLogicalPosition(e.getMouseEvent().getPoint()).line;\n              if (line < 0 || line >= editor.getDocument().getLineCount()) {\n                return;\n              }\n              MouseEvent event = e.getMouseEvent();\n              if (event.isPopupTrigger()) {\n                return;\n              }\n              if (event.getButton() != 1) {\n                return;\n              }\n\n              e.consume();\n\n              DebuggerInvocationUtil.invokeLater(myProject, new Runnable() {\n                public void run() {\n                  Breakpoint breakpoint = toggleBreakpoint(e.getMouseEvent().isAltDown(), line);\n\n                  if (e.getMouseEvent().isShiftDown() && breakpoint != null) {\n                    breakpoint.LOG_EXPRESSION_ENABLED = true;\n                    final TextWithImports logMessage = DebuggerUtilsEx.getEditorText(editor);\n                    breakpoint.setLogMessage(logMessage != null\n                                             ? logMessage\n                                             : new TextWithImportsImpl(CodeFragmentKind.EXPRESSION,\n                                                                       DebuggerBundle.message(\"breakpoint.log.message\",\n                                                                                              breakpoint.getDisplayName())));\n                    breakpoint.SUSPEND_POLICY = DebuggerSettings.SUSPEND_NONE;\n\n                    DialogWrapper dialog = DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager()\n                      .createConfigurationDialog(breakpoint, BreakpointPropertiesPanel.CONTROL_LOG_MESSAGE);\n                    dialog.show();\n\n                    if (!dialog.isOK()) {\n                      removeBreakpoint(breakpoint);\n                    }\n                  }\n                }\n              });\n            }\n          });\n        }\n      }\n    };\n\n    eventMulticaster.addEditorMouseListener(myEditorMouseListener, myProject);\n\n    final DocumentListener myDocumentListener = new DocumentAdapter() {\n      private final Alarm myUpdateAlarm = new Alarm();\n\n      public void documentChanged(final DocumentEvent e) {\n        final Document document = e.getDocument();\n        synchronized (BreakpointManager.this) {\n          List<BreakpointWithHighlighter> breakpoints = myDocumentBreakpoints.get(document);\n\n          if(breakpoints != null) {\n            myUpdateAlarm.cancelAllRequests();\n            // must create new array in order to avoid \"concurrent modification\" errors\n            final List<BreakpointWithHighlighter> breakpointsToUpdate = new ArrayList<BreakpointWithHighlighter>(breakpoints);\n            myUpdateAlarm.addRequest(new Runnable() {\n              public void run() {\n                if (!myProject.isDisposed()) {\n                  PsiDocumentManager.getInstance(myProject).commitDocument(document);\n                  update(breakpointsToUpdate);\n                }\n              }\n            }, 300, ModalityState.NON_MODAL);\n          }\n        }\n      }\n    };\n\n    eventMulticaster.addDocumentListener(myDocumentListener, myProject);\n  }","id":83886,"modified_method":"public void init() {\n    EditorEventMulticaster eventMulticaster = EditorFactory.getInstance().getEventMulticaster();\n    EditorMouseAdapter myEditorMouseListener = new EditorMouseAdapter() {\n      private EditorMouseEvent myMousePressedEvent;\n\n      @Nullable\n      private Breakpoint toggleBreakpoint(final boolean mostSuitingBreakpoint, final int line) {\n        final Editor editor = FileEditorManager.getInstance(myProject).getSelectedTextEditor();\n        if (editor == null) {\n          return null;\n        }\n        final Document document = editor.getDocument();\n        final PsiFile psiFile = PsiDocumentManager.getInstance(myProject).getPsiFile(document);\n        if (psiFile == null) {\n          return null;\n        }\n        final FileType fileType = psiFile.getFileType();\n        boolean isInsideCompiledClass = StdFileTypes.CLASS.equals(fileType);\n        if (!isInsideCompiledClass && !(DebuggerUtils.supportsJVMDebugging(fileType) || DebuggerUtils.supportsJVMDebugging(psiFile))) {\n          return null;\n        }\n        PsiDocumentManager.getInstance(myProject).commitDocument(document);\n\n        int offset = editor.getCaretModel().getOffset();\n        int editorLine = editor.getDocument().getLineNumber(offset);\n        if (editorLine != line) {\n          if (line < 0 || line >= document.getLineCount()) {\n            return null;\n          }\n          offset = editor.getDocument().getLineStartOffset(line);\n        }\n\n        ExpandRegionHandler.expandRegionAtCaret(myProject, editor);\n\n        Breakpoint breakpoint = findBreakpoint(document, offset, null);\n        if (breakpoint == null) {\n          if (mostSuitingBreakpoint || isInsideCompiledClass) {\n            breakpoint = addFieldBreakpoint(document, offset);\n            if (breakpoint == null) {\n              breakpoint = addMethodBreakpoint(document, line);\n            }\n            if (breakpoint == null && !isInsideCompiledClass) {\n              breakpoint = addLineBreakpoint(document, line);\n            }\n          }\n          else {\n            breakpoint = addLineBreakpoint(document, line);\n\n            if (breakpoint == null) {\n              breakpoint = addMethodBreakpoint(document, line);\n            }\n          }\n\n          if (breakpoint != null) {\n            RequestManagerImpl.createRequests(breakpoint);\n          }\n          return breakpoint;\n        }\n        else {\n          removeBreakpoint(breakpoint);\n          return null;\n        }\n      }\n\n      private boolean isFromMyProject(Editor editor) {\n        FileEditor[] allEditors = FileEditorManager.getInstance(myProject).getAllEditors();\n        for (FileEditor ed : allEditors) {\n          if (!(ed instanceof TextEditor)) {\n            continue;\n          }\n          if (((TextEditor)ed).getEditor().equals(editor)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      //mousePressed + mouseReleased is a hack to keep selection in editor when shift is pressed\n      public void mousePressed(EditorMouseEvent e) {\n        if (MarkupEditorFilterFactory.createIsDiffFilter().avaliableIn(e.getEditor())) return;\n\n        if (e.isConsumed()) return;\n\n        if (e.getArea() == EditorMouseEventArea.LINE_MARKERS_AREA && e.getMouseEvent().isShiftDown()) {\n          myMousePressedEvent = e;\n          e.consume();\n        }\n      }\n\n      public void mouseReleased(EditorMouseEvent e) {\n        if (myMousePressedEvent != null) {\n          mouseClicked(e);\n        }\n        myMousePressedEvent = null;\n      }\n\n      public void mouseClicked(final EditorMouseEvent e) {\n        if (MarkupEditorFilterFactory.createIsDiffFilter().avaliableIn(e.getEditor())) return;\n\n        if (e.isConsumed()) return;\n\n        if (e.getArea() == EditorMouseEventArea.LINE_MARKERS_AREA) {\n          PsiDocumentManager.getInstance(myProject).commitAndRunReadAction(new Runnable() {\n            public void run() {\n              final Editor editor = e.getEditor();\n              if (!isFromMyProject(editor)) {\n                return;\n              }\n              final int line = editor.xyToLogicalPosition(e.getMouseEvent().getPoint()).line;\n              if (line < 0 || line >= editor.getDocument().getLineCount()) {\n                return;\n              }\n              MouseEvent event = e.getMouseEvent();\n              if (event.isPopupTrigger()) {\n                return;\n              }\n              if (event.getButton() != 1) {\n                return;\n              }\n\n              e.consume();\n\n              DebuggerInvocationUtil.invokeLater(myProject, new Runnable() {\n                public void run() {\n                  Breakpoint breakpoint = toggleBreakpoint(e.getMouseEvent().isAltDown(), line);\n\n                  if (e.getMouseEvent().isShiftDown() && breakpoint != null) {\n                    breakpoint.LOG_EXPRESSION_ENABLED = true;\n                    final TextWithImports logMessage = DebuggerUtilsEx.getEditorText(editor);\n                    breakpoint.setLogMessage(logMessage != null\n                                             ? logMessage\n                                             : new TextWithImportsImpl(CodeFragmentKind.EXPRESSION,\n                                                                       DebuggerBundle.message(\"breakpoint.log.message\",\n                                                                                              breakpoint.getDisplayName())));\n                    breakpoint.SUSPEND_POLICY = DebuggerSettings.SUSPEND_NONE;\n\n                    DialogWrapper dialog = DebuggerManagerEx.getInstanceEx(myProject).getBreakpointManager()\n                      .createConfigurationDialog(breakpoint, BreakpointPropertiesPanel.CONTROL_LOG_MESSAGE);\n                    dialog.show();\n\n                    if (!dialog.isOK()) {\n                      removeBreakpoint(breakpoint);\n                    }\n                  }\n                }\n              });\n            }\n          });\n        }\n      }\n    };\n\n    eventMulticaster.addEditorMouseListener(myEditorMouseListener, myProject);\n\n    final DocumentListener myDocumentListener = new DocumentAdapter() {\n      private final Alarm myUpdateAlarm = new Alarm();\n\n      public void documentChanged(final DocumentEvent e) {\n        final Document document = e.getDocument();\n        synchronized (BreakpointManager.this) {\n          List<BreakpointWithHighlighter> breakpoints = myDocumentBreakpoints.get(document);\n\n          if(breakpoints != null) {\n            myUpdateAlarm.cancelAllRequests();\n            // must create new array in order to avoid \"concurrent modification\" errors\n            final List<BreakpointWithHighlighter> breakpointsToUpdate = new ArrayList<BreakpointWithHighlighter>(breakpoints);\n            myUpdateAlarm.addRequest(new Runnable() {\n              public void run() {\n                if (!myProject.isDisposed()) {\n                  PsiDocumentManager.getInstance(myProject).commitDocument(document);\n                  update(breakpointsToUpdate);\n                }\n              }\n            }, 300, ModalityState.NON_MODAL);\n          }\n        }\n      }\n    };\n\n    eventMulticaster.addDocumentListener(myDocumentListener, myProject);\n  }","commit_id":"2aa32c1034e47258c7528b9f948e1be3fb766faa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isEnabled(final @NotNull Project project, final AnActionEvent event) {\n\n    Editor editor = event.getData(PlatformDataKeys.EDITOR);\n\n    if (editor == null) {\n      return false;\n    }\n\n    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    FileTypeManager fileTypeManager = FileTypeManager.getInstance();\n    if (file == null) {\n      return false;\n    }\n\n    final VirtualFile virtualFile = file.getVirtualFile();\n    FileType fileType = virtualFile != null ? fileTypeManager.getFileTypeByFile(virtualFile) : null;\n    if (DebuggerUtils.supportsJVMDebugging(fileType)) {\n      DebuggerSession debuggerSession = DebuggerManagerEx.getInstanceEx(project).getContext().getDebuggerSession();\n      return debuggerSession != null && debuggerSession.isPaused();\n    }\n\n    return false;\n  }","id":83887,"modified_method":"public boolean isEnabled(final @NotNull Project project, final AnActionEvent event) {\n\n    Editor editor = event.getData(PlatformDataKeys.EDITOR);\n\n    if (editor == null) {\n      return false;\n    }\n\n    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    FileTypeManager fileTypeManager = FileTypeManager.getInstance();\n    if (file == null) {\n      return false;\n    }\n\n    final VirtualFile virtualFile = file.getVirtualFile();\n    FileType fileType = virtualFile != null ? fileTypeManager.getFileTypeByFile(virtualFile) : null;\n    if (DebuggerUtils.supportsJVMDebugging(fileType) || DebuggerUtils.supportsJVMDebugging(file)) {\n      DebuggerSession debuggerSession = DebuggerManagerEx.getInstanceEx(project).getContext().getDebuggerSession();\n      return debuggerSession != null && debuggerSession.isPaused();\n    }\n\n    return false;\n  }","commit_id":"2aa32c1034e47258c7528b9f948e1be3fb766faa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent event){\n    final Presentation presentation = event.getPresentation();\n    Project project = event.getData(PlatformDataKeys.PROJECT);\n    if (project == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    Editor editor = FileEditorManager.getInstance(project).getSelectedTextEditor();\n    if (editor == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (file == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    FileTypeManager fileTypeManager = FileTypeManager.getInstance();\n    final VirtualFile virtualFile = file.getVirtualFile();\n    FileType fileType = virtualFile != null ? fileTypeManager.getFileTypeByFile(virtualFile) : null;\n    if (DebuggerUtils.supportsJVMDebugging(fileType)) {\n      Breakpoint breakpoint = findBreakpoint(project);\n      if (breakpoint == null) {\n        presentation.setEnabled(false);\n        return;\n      }\n      presentation.setEnabled(true);\n    }\n    else {\n      presentation.setEnabled(false);\n    }\n  }","id":83888,"modified_method":"public void update(AnActionEvent event){\n    final Presentation presentation = event.getPresentation();\n    Project project = event.getData(PlatformDataKeys.PROJECT);\n    if (project == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    Editor editor = FileEditorManager.getInstance(project).getSelectedTextEditor();\n    if (editor == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n    PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (file == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n\n    FileTypeManager fileTypeManager = FileTypeManager.getInstance();\n    final VirtualFile virtualFile = file.getVirtualFile();\n    FileType fileType = virtualFile != null ? fileTypeManager.getFileTypeByFile(virtualFile) : null;\n    if (DebuggerUtils.supportsJVMDebugging(fileType) || DebuggerUtils.supportsJVMDebugging(file)) {\n      Breakpoint breakpoint = findBreakpoint(project);\n      if (breakpoint == null) {\n        presentation.setEnabled(false);\n        return;\n      }\n      presentation.setEnabled(true);\n    }\n    else {\n      presentation.setEnabled(false);\n    }\n  }","commit_id":"2aa32c1034e47258c7528b9f948e1be3fb766faa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isEnabled(@NotNull final Project project, final AnActionEvent event) {\n    PlaceInDocument place = getPlace(project, event);\n    if (place != null) {\n      final Document document = place.getDocument();\n      final int offset = place.getOffset();\n      int line = document.getLineNumber(offset);\n\n      VirtualFile file = FileDocumentManager.getInstance().getFile(document);\n      if (DebuggerUtils.supportsJVMDebugging(file.getFileType())) {\n        final BreakpointManager breakpointManager = DebuggerManagerEx.getInstanceEx(project).getBreakpointManager();\n        return breakpointManager.findBreakpoint(document, offset, LineBreakpoint.CATEGORY) != null ||\n                   LineBreakpoint.canAddLineBreakpoint(project, document, line);\n      }\n    }\n\n    return false;\n  }","id":83889,"modified_method":"public boolean isEnabled(@NotNull final Project project, final AnActionEvent event) {\n    PlaceInDocument place = getPlace(project, event);\n    if (place != null) {\n      final Document document = place.getDocument();\n      final int offset = place.getOffset();\n      int line = document.getLineNumber(offset);\n\n      VirtualFile file = FileDocumentManager.getInstance().getFile(document);\n      PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n      if (DebuggerUtils.supportsJVMDebugging(file.getFileType()) || DebuggerUtils.supportsJVMDebugging(psiFile)) {\n        final BreakpointManager breakpointManager = DebuggerManagerEx.getInstanceEx(project).getBreakpointManager();\n        return breakpointManager.findBreakpoint(document, offset, LineBreakpoint.CATEGORY) != null ||\n                   LineBreakpoint.canAddLineBreakpoint(project, document, line);\n      }\n    }\n\n    return false;\n  }","commit_id":"2aa32c1034e47258c7528b9f948e1be3fb766faa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    if (!(file instanceof GroovyFileBase) || editor.getSelectionModel().hasBlockSelection()) {\n      return false;\n    }\n\n\n    if (editor.getSelectionModel().hasSelection()) return true;\n\n    int offset = editor.getCaretModel().getOffset();\n    if (offset >= editor.getDocument().getTextLength()) offset = editor.getDocument().getTextLength() - 1;\n    final PsiElement element = file.findElementAt(offset);\n    if (element == null) return false;\n    if (element.getNode().getElementType() == GroovyTokenTypes.mSEMI) return true;\n\n    final PsiElement next = PsiTreeUtil.nextLeaf(element);\n    if (next != null && next.getNode().getElementType() == GroovyTokenTypes.mSEMI) return true;\n\n\n    final PsiElement prev = PsiTreeUtil.prevLeaf(element);\n    if (prev != null && prev.getNode().getElementType() == GroovyTokenTypes.mSEMI) return true;\n\n    return false;\n  }","id":83890,"modified_method":"@Override\n  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    if (!(file instanceof GroovyFileBase)) return false;\n    if (selectionModel.hasBlockSelection()) return false;\n\n    if (selectionModel.hasSelection()) {\n      final HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(selectionModel.getSelectionStart());\n      final int end = selectionModel.getSelectionEnd();\n      while (!iterator.atEnd()) {\n        if (iterator.getTokenType() == GroovyTokenTypes.mSEMI) return true;\n        if (iterator.getStart() > end) return false;\n        iterator.advance();\n      }\n      return false;\n    }\n\n    int offset = editor.getCaretModel().getOffset();\n    if (offset >= editor.getDocument().getTextLength()) offset = editor.getDocument().getTextLength() - 1;\n    final PsiElement element = file.findElementAt(offset);\n    if (element == null) return false;\n    if (element.getNode().getElementType() == GroovyTokenTypes.mSEMI) return true;\n\n    final PsiElement next = PsiTreeUtil.nextLeaf(element);\n    if (next != null && next.getNode().getElementType() == GroovyTokenTypes.mSEMI) return true;\n\n\n    final PsiElement prev = PsiTreeUtil.prevLeaf(element);\n    if (prev != null && prev.getNode().getElementType() == GroovyTokenTypes.mSEMI) return true;\n\n    return false;\n  }","commit_id":"7ac7d20bec4bce34ced7e783b14de62471c6a07e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean invoke(final Project project, final Editor editor, PsiFile file, int startOffset, int endOffset) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.introduceVariable\");\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n\n    PsiExpression tempExpr = CodeInsightUtil.findExpressionInRange(file, startOffset, endOffset);\n    if (tempExpr == null) {\n      PsiElement[] statements = CodeInsightUtil.findStatementsInRange(file, startOffset, endOffset);\n      if (statements.length == 1) {\n        if (statements[0] instanceof PsiExpressionStatement) {\n          tempExpr = ((PsiExpressionStatement) statements[0]).getExpression();\n        } else if (statements[0] instanceof PsiReturnStatement) {\n          tempExpr = ((PsiReturnStatement)statements[0]).getReturnValue();\n        }\n      }\n    }\n\n    if (tempExpr == null) {\n      tempExpr = getSelectedExpression(project, file, startOffset, endOffset);\n    }\n    return invokeImpl(project, tempExpr, editor);\n  }","id":83891,"modified_method":"private boolean invoke(final Project project, final Editor editor, PsiFile file, int startOffset, int endOffset) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"refactoring.introduceVariable\");\n    PsiDocumentManager.getInstance(project).commitAllDocuments();\n\n\n    return invokeImpl(project, findExpressionInRange(project, file, startOffset, endOffset), editor);\n  }","commit_id":"3c0c433a119d260eecf81e3b4fa90890e4a4cb17","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file, DataContext dataContext) {\n    if (!editor.getSelectionModel().hasSelection()) {\n      final int offset = editor.getCaretModel().getOffset();\n      final PsiElement[] statementsInRange = findStatementsAtOffset(editor, file, offset);\n      if (statementsInRange.length == 1 && (PsiUtil.hasErrorElementChild(statementsInRange[0]) || isPreferStatements())) {\n        editor.getSelectionModel().selectLineAtCaret();\n      } else {\n        final List<PsiExpression> expressions = collectExpressions(file, editor, offset, statementsInRange);\n        if (expressions.isEmpty()) {\n          editor.getSelectionModel().selectLineAtCaret();\n        } else if (expressions.size() == 1) {\n          final TextRange textRange = expressions.get(0).getTextRange();\n          editor.getSelectionModel().setSelection(textRange.getStartOffset(), textRange.getEndOffset());\n        }\n        else {\n          showChooser(editor, expressions, new Pass<PsiExpression>(){\n            public void pass(final PsiExpression selectedValue) {\n              invoke(project, editor, file, selectedValue.getTextRange().getStartOffset(), selectedValue.getTextRange().getEndOffset());\n            }\n          });\n          return;\n        }\n      }\n    }\n    if (invoke(project, editor, file, editor.getSelectionModel().getSelectionStart(), editor.getSelectionModel().getSelectionEnd())) {\n      editor.getSelectionModel().removeSelection();\n    }\n  }","id":83892,"modified_method":"public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file, DataContext dataContext) {\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    if (!selectionModel.hasSelection()) {\n      final int offset = editor.getCaretModel().getOffset();\n      final PsiElement[] statementsInRange = findStatementsAtOffset(editor, file, offset);\n\n      //try line selection\n      if (statementsInRange.length == 1 && (PsiUtil.hasErrorElementChild(statementsInRange[0]) || isPreferStatements())) {\n        selectionModel.selectLineAtCaret();\n        if (findExpressionInRange(project, file, selectionModel.getSelectionStart(), selectionModel.getSelectionEnd()) == null) {\n          selectionModel.removeSelection();\n        }\n      }\n\n      if (!selectionModel.hasSelection()) {\n        final List<PsiExpression> expressions = collectExpressions(file, editor, offset, statementsInRange);\n        if (expressions.isEmpty()) {\n          selectionModel.selectLineAtCaret();\n        } else if (expressions.size() == 1) {\n          final TextRange textRange = expressions.get(0).getTextRange();\n          selectionModel.setSelection(textRange.getStartOffset(), textRange.getEndOffset());\n        }\n        else {\n          showChooser(editor, expressions, new Pass<PsiExpression>(){\n            public void pass(final PsiExpression selectedValue) {\n              invoke(project, editor, file, selectedValue.getTextRange().getStartOffset(), selectedValue.getTextRange().getEndOffset());\n            }\n          });\n          return;\n        }\n      }\n    }\n    if (invoke(project, editor, file, selectionModel.getSelectionStart(), selectionModel.getSelectionEnd())) {\n      selectionModel.removeSelection();\n    }\n  }","commit_id":"3c0c433a119d260eecf81e3b4fa90890e4a4cb17","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void executeWriteAction(Editor editor, DataContext dataContext) {\n      if (!editor.getSelectionModel().hasSelection()) {\n        editor.getSelectionModel().selectWordAtCaret(true);\n      }\n\n      int startOffset = editor.getSelectionModel().getSelectionStart();\n      int endOffset = editor.getSelectionModel().getSelectionEnd();\n\n      StringBuilder builder = StringBuilderSpinAllocator.alloc();\n      try {\n        final String text = editor.getDocument().getCharsSequence().subSequence(startOffset, endOffset).toString();\n        toCase(builder, text, true);\n        if (text.equals(builder.toString())) {\n          toCase(builder, text, false);\n        }\n        editor.getDocument().replaceString(startOffset, endOffset, builder.toString());\n        editor.getSelectionModel().setSelection(startOffset, endOffset);\n      }\n      finally {\n        StringBuilderSpinAllocator.dispose(builder);\n      }\n    }","id":83893,"modified_method":"public void executeWriteAction(Editor editor, DataContext dataContext) {\n      final SelectionModel selectionModel = editor.getSelectionModel();\n\n      final int[] starts;\n      final int[] ends;\n      LogicalPosition blockStart = null;\n      LogicalPosition blockEnd = null;\n\n      if (selectionModel.hasBlockSelection()) {\n        starts = selectionModel.getBlockSelectionStarts();\n        ends = selectionModel.getBlockSelectionEnds();\n        blockStart = selectionModel.getBlockStart();\n        blockEnd = selectionModel.getBlockEnd();\n      }\n      else {\n        if (!selectionModel.hasSelection()) {\n          selectionModel.selectWordAtCaret(true);\n        }\n\n        starts = new int[] {selectionModel.getSelectionStart()};\n        ends = new int[] {selectionModel.getSelectionEnd()};\n      }\n\n      selectionModel.removeBlockSelection();\n      selectionModel.removeSelection();\n\n      for (int i = 0; i < starts.length; i++) {\n        int startOffset = starts[i];\n        int endOffset = ends[i];\n        StringBuilder builder = StringBuilderSpinAllocator.alloc();\n        try {\n          final String text = editor.getDocument().getCharsSequence().subSequence(startOffset, endOffset).toString();\n          toCase(builder, text, true);\n          if (text.equals(builder.toString())) {\n            toCase(builder, text, false);\n          }\n          editor.getDocument().replaceString(startOffset, endOffset, builder.toString());\n\n        }\n        finally {\n          StringBuilderSpinAllocator.dispose(builder);\n        }\n      }\n\n      if (blockStart != null) {\n        selectionModel.setBlockSelection(blockStart, blockEnd);\n      }\n      else {\n        selectionModel.setSelection(starts[0], ends[0]);\n      }\n    }","commit_id":"9e47bd618186d372016b093389a0998ff8f71316","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Result checkAutoPopup(char c, Project project, Editor editor, PsiFile psiFile) {\n    // TODO[oleg] provide adequate API not to use this hack\n    // beforeCharTyped always works with removed selection\n    if(CodeInsightSettings.getInstance().SURROUND_SELECTION_ON_QUOTE_TYPED &&  editor.getSelectionModel().hasSelection() && isDelimiter(c)) {\n      String selectedText = editor.getSelectionModel().getSelectedText();\n      if (selectedText.length() < 1) {\n        return super.checkAutoPopup(c, project, editor, psiFile);\n      }\n      if (selectedText.length() > 1) {\n        final char firstChar = selectedText.charAt(0);\n        if (isSimilarDelimiters(firstChar, c) &&\n            selectedText.charAt(selectedText.length() - 1) == getMatchingDelimiter(firstChar) &&\n            (isQuote(firstChar) || firstChar != c) &&\n            !shouldSkipReplacementOfQuotesOrBraces(psiFile, editor, selectedText, c)\n          ) {\n          selectedText = selectedText.substring(1, selectedText.length() - 1);\n        }\n      }\n      final int caretOffset = editor.getSelectionModel().getSelectionStart();\n      final char c2 = getMatchingDelimiter(c);\n      final String newText = String.valueOf(c) + selectedText + c2;\n      EditorModificationUtil.insertStringAtCaret(editor, newText);\n      if (Registry.is(\"editor.smarterSelectionQuoting\")) {\n        myReplacedTextRange = new TextRange(caretOffset + 1, caretOffset + newText.length() - 1);\n      } else {\n        myReplacedTextRange = new TextRange(caretOffset, caretOffset + newText.length());\n      }\n      return Result.STOP;\n    }\n    return super.checkAutoPopup(c, project, editor, psiFile);\n  }","id":83894,"modified_method":"@Override\n  public Result checkAutoPopup(char c, Project project, Editor editor, PsiFile psiFile) {\n    // TODO[oleg] provide adequate API not to use this hack\n    // beforeCharTyped always works with removed selection\n    SelectionModel selectionModel = editor.getSelectionModel();\n    if(CodeInsightSettings.getInstance().SURROUND_SELECTION_ON_QUOTE_TYPED &&  selectionModel.hasSelection() && isDelimiter(c)) {\n      CaretModel caretModel = editor.getCaretModel();\n      String selectedText = selectionModel.getSelectedText();\n      if (selectedText.length() < 1) {\n        return super.checkAutoPopup(c, project, editor, psiFile);\n      }\n      if (selectedText.length() > 1) {\n        final char firstChar = selectedText.charAt(0);\n        if (isSimilarDelimiters(firstChar, c) &&\n            selectedText.charAt(selectedText.length() - 1) == getMatchingDelimiter(firstChar) &&\n            (isQuote(firstChar) || firstChar != c) &&\n            !shouldSkipReplacementOfQuotesOrBraces(psiFile, editor, selectedText, c)\n          ) {\n          selectedText = selectedText.substring(1, selectedText.length() - 1);\n        }\n      }\n      final int caretOffset = selectionModel.getSelectionStart();\n      final char c2 = getMatchingDelimiter(c);\n      final String newText = String.valueOf(c) + selectedText + c2;\n      myLtrSelection = selectionModel.getLeadSelectionOffset() != selectionModel.getSelectionEnd();\n      if (editor instanceof EditorEx) {\n        myRestoreStickySelection = ((EditorEx)editor).isStickySelection();\n      }\n      else {\n        myRestoreStickySelection = false;\n      }\n      selectionModel.removeSelection();\n      editor.getDocument().replaceString(caretOffset, caretOffset + selectedText.length(), newText);\n      if (Registry.is(\"editor.smarterSelectionQuoting\")) {\n        myReplacedTextRange = new TextRange(caretOffset + 1, caretOffset + newText.length() - 1);\n      } else {\n        myReplacedTextRange = new TextRange(caretOffset, caretOffset + newText.length());\n      }\n      return Result.STOP;\n    }\n    return super.checkAutoPopup(c, project, editor, psiFile);\n  }","commit_id":"c9499ae05c35d827fb7ee52c6e7b241a836b6104","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Result beforeCharTyped(final char charTyped, final Project project, final Editor editor, final PsiFile file, final FileType fileType) {\n    // TODO[oleg] remove this hack when API changes\n    if (myReplacedTextRange != null) {\n      if (myReplacedTextRange.getEndOffset() <= editor.getDocument().getTextLength()) {\n        editor.getSelectionModel().setSelection(myReplacedTextRange.getStartOffset(), myReplacedTextRange.getEndOffset());\n        if (Registry.is(\"editor.smarterSelectionQuoting\")) {\n          editor.getCaretModel().moveToOffset(myReplacedTextRange.getEndOffset());\n        }\n      }\n      myReplacedTextRange = null;\n      return Result.STOP;\n    }\n    return Result.CONTINUE;\n  }","id":83895,"modified_method":"@Override\n  public Result beforeCharTyped(final char charTyped, final Project project, final Editor editor, final PsiFile file, final FileType fileType) {\n    // TODO[oleg] remove this hack when API changes\n    if (myReplacedTextRange != null) {\n      if (myReplacedTextRange.getEndOffset() <= editor.getDocument().getTextLength()) {\n        if (myRestoreStickySelection && editor instanceof EditorEx) {\n          EditorEx editorEx = (EditorEx)editor;\n          CaretModel caretModel = editorEx.getCaretModel();\n          caretModel.moveToOffset(myLtrSelection ? myReplacedTextRange.getStartOffset() : myReplacedTextRange.getEndOffset());\n          editorEx.setStickySelection(true);\n          caretModel.moveToOffset(myLtrSelection ? myReplacedTextRange.getEndOffset() : myReplacedTextRange.getStartOffset());\n        }\n        else {\n          if (myLtrSelection) {\n            editor.getSelectionModel().setSelection(myReplacedTextRange.getStartOffset(), myReplacedTextRange.getEndOffset());\n          }\n          else {\n            editor.getSelectionModel().setSelection(myReplacedTextRange.getEndOffset(), myReplacedTextRange.getStartOffset());\n          }\n          if (Registry.is(\"editor.smarterSelectionQuoting\")) {\n            editor.getCaretModel().moveToOffset(myLtrSelection ? myReplacedTextRange.getEndOffset() : myReplacedTextRange.getStartOffset());\n          }\n        }\n      }\n      myReplacedTextRange = null;\n      return Result.STOP;\n    }\n    return Result.CONTINUE;\n  }","commit_id":"c9499ae05c35d827fb7ee52c6e7b241a836b6104","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void update(@NotNull AnActionEvent event) {\n    if (!CCProjectService.setCCActionAvailable(event)) {\n      return;\n    }\n    final Presentation presentation = event.getPresentation();\n    final Project project = event.getData(CommonDataKeys.PROJECT);\n    if (project == null) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    final Editor editor = CommonDataKeys.EDITOR.getData(event.getDataContext());\n    final PsiFile file = CommonDataKeys.PSI_FILE.getData(event.getDataContext());\n    if (editor == null || file == null) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    if (!editor.getSelectionModel().hasSelection()) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n\n    final CCProjectService service = CCProjectService.getInstance(project);\n    final Course course = service.getCourse();\n    final PsiDirectory taskDir = file.getContainingDirectory();\n    final PsiDirectory lessonDir = taskDir.getParent();\n    if (lessonDir == null) return;\n\n    final Lesson lesson = course.getLesson(lessonDir.getName());\n    if (lesson == null) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    final Task task = lesson.getTask(taskDir.getName());\n    if (task == null) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    TaskFile taskFile = task.getTaskFile(file.getName());\n    if (taskFile == null) {\n      LOG.info(\"could not find task file\");\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    presentation.setVisible(true);\n    presentation.setEnabled(true);\n  }","id":83896,"modified_method":"@Override\n  public void update(@NotNull AnActionEvent event) {\n    if (!CCProjectService.setCCActionAvailable(event)) {\n      return;\n    }\n    final Presentation presentation = event.getPresentation();\n    final Project project = event.getData(CommonDataKeys.PROJECT);\n    if (project == null) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    final Editor editor = CommonDataKeys.EDITOR.getData(event.getDataContext());\n    final PsiFile file = CommonDataKeys.PSI_FILE.getData(event.getDataContext());\n    if (editor == null || file == null) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    SelectionModel selectionModel = editor.getSelectionModel();\n    if (!selectionModel.hasSelection()) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    int start = selectionModel.getSelectionStart();\n    int end = selectionModel.getSelectionEnd();\n\n    final CCProjectService service = CCProjectService.getInstance(project);\n    final Course course = service.getCourse();\n    final PsiDirectory taskDir = file.getContainingDirectory();\n    final PsiDirectory lessonDir = taskDir.getParent();\n    if (lessonDir == null) return;\n\n    final Lesson lesson = course.getLesson(lessonDir.getName());\n    if (lesson == null) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    final Task task = lesson.getTask(taskDir.getName());\n    if (task == null) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    TaskFile taskFile = task.getTaskFile(file.getName());\n    if (taskFile == null) {\n      LOG.info(\"could not find task file\");\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    if (areTaskWindowsIntersect(taskFile, editor.getDocument(), start, end)) {\n      presentation.setVisible(false);\n      presentation.setEnabled(false);\n      return;\n    }\n    presentation.setVisible(true);\n    presentation.setEnabled(true);\n  }","commit_id":"1c5e8af32e92a647ebdcb9fa193f39bee6eb9da8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    final Project project = e.getData(CommonDataKeys.PROJECT);\n    if (project == null) {\n      return;\n    }\n    final PsiFile file = CommonDataKeys.PSI_FILE.getData(e.getDataContext());\n    if (file == null) return;\n    final Editor editor = CommonDataKeys.EDITOR.getData(e.getDataContext());\n    if (editor == null) return;\n\n    final SelectionModel model = editor.getSelectionModel();\n    final Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n    if (document == null) return;\n    final int start = model.getSelectionStart();\n    final int end = model.getSelectionEnd();\n    final int lineNumber = document.getLineNumber(start);\n    final int length = end - start;\n    int realStart = start - document.getLineStartOffset(lineNumber);\n\n    final CCProjectService service = CCProjectService.getInstance(project);\n    final Course course = service.getCourse();\n    final PsiDirectory taskDir = file.getContainingDirectory();\n    final PsiDirectory lessonDir = taskDir.getParent();\n    if (lessonDir == null) return;\n\n    final Lesson lesson = course.getLesson(lessonDir.getName());\n    final Task task = lesson.getTask(taskDir.getName());\n    final TaskFile taskFile = task.getTaskFile(file.getName());\n    final TaskWindow taskWindow = new TaskWindow(lineNumber, realStart, length, model.getSelectedText());\n    CreateTaskWindowDialog dlg = new CreateTaskWindowDialog(project, taskWindow, lesson.getIndex(), task.getIndex(), file.getVirtualFile().getNameWithoutExtension(), taskFile.getTaskWindows().size() + 1);\n    dlg.show();\n    if (dlg.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n      return;\n    }\n    int index = taskFile.getTaskWindows().size() + 1;\n    taskFile.addTaskWindow(taskWindow, index);\n    taskWindow.drawHighlighter(editor, false);\n    taskWindow.createGuardedBlocks(editor);\n  }","id":83897,"modified_method":"@Override\n  public void actionPerformed(@NotNull AnActionEvent e) {\n    final Project project = e.getData(CommonDataKeys.PROJECT);\n    if (project == null) {\n      return;\n    }\n    final PsiFile file = CommonDataKeys.PSI_FILE.getData(e.getDataContext());\n    if (file == null) return;\n    final Editor editor = CommonDataKeys.EDITOR.getData(e.getDataContext());\n    if (editor == null) return;\n    final SelectionModel model = editor.getSelectionModel();\n    final Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n    if (document == null) return;\n    final int start = model.getSelectionStart();\n    final int end = model.getSelectionEnd();\n    final int lineNumber = document.getLineNumber(start);\n    final int length = end - start;\n    int realStart = start - document.getLineStartOffset(lineNumber);\n\n    final CCProjectService service = CCProjectService.getInstance(project);\n    final Course course = service.getCourse();\n    final PsiDirectory taskDir = file.getContainingDirectory();\n    final PsiDirectory lessonDir = taskDir.getParent();\n    if (lessonDir == null) return;\n\n    final Lesson lesson = course.getLesson(lessonDir.getName());\n    final Task task = lesson.getTask(taskDir.getName());\n    final TaskFile taskFile = task.getTaskFile(file.getName());\n    if (taskFile == null) {\n      return;\n    }\n    if (areTaskWindowsIntersect(taskFile, document, start, end)) {\n      return;\n    }\n    final TaskWindow taskWindow = new TaskWindow(lineNumber, realStart, length, model.getSelectedText());\n    CreateTaskWindowDialog dlg = new CreateTaskWindowDialog(project, taskWindow, lesson.getIndex(),\n                                                            task.getIndex(), file.getVirtualFile().getNameWithoutExtension(),\n                                                            taskFile.getTaskWindows().size() + 1);\n    dlg.show();\n    if (dlg.getExitCode() != DialogWrapper.OK_EXIT_CODE) {\n      return;\n    }\n    int index = taskFile.getTaskWindows().size() + 1;\n    taskFile.addTaskWindow(taskWindow, index);\n    taskWindow.drawHighlighter(editor, false);\n    taskWindow.createGuardedBlocks(editor);\n  }","commit_id":"1c5e8af32e92a647ebdcb9fa193f39bee6eb9da8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean charDeleted(final char c, final PsiFile file, final Editor editor) {\n    if (myTargetPosition != null) {\n      // Remove all the following spaces before moving to targetPosition\n      final int offset = editor.getCaretModel().getOffset();\n      editor.getSelectionModel().setSelection(offset - editor.getCaretModel().getVisualPosition().column + myTargetPosition.column, offset);\n      EditorModificationUtil.deleteSelectedText(editor);\n      editor.getCaretModel().moveToLogicalPosition(myTargetPosition);\n      myTargetPosition = null;\n      return true;\n    }\n    return false;\n  }","id":83898,"modified_method":"public boolean charDeleted(final char c, final PsiFile file, final Editor editor) {\n    if (myTargetPosition != null) {\n      // Remove all the following spaces before moving to targetPosition\n      final int offset = editor.getCaretModel().getOffset();\n      if (EditorModificationUtil.calcAfterLineEnd(editor) == 0) {\n        int delta = editor.getCaretModel().getVisualPosition().column - myTargetPosition.column;\n        editor.getSelectionModel().setSelection(offset - delta, offset);\n        EditorModificationUtil.deleteSelectedText(editor);\n      }\n      editor.getCaretModel().moveToLogicalPosition(myTargetPosition);\n      myTargetPosition = null;\n      return true;\n    }\n    return false;\n  }","commit_id":"7441d8938f36139e63f59026a6e622fffc2fa29a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void executeWriteAction(Editor editor, DataContext dataContext) {\n    Project project = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(editor.getContentComponent()));\n    if (project == null) {\n      if (myOriginalHandler != null) {\n        myOriginalHandler.execute(editor, dataContext);\n      }\n      return;\n    }\n\n    final PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n\n    if (file == null) {\n      if (myOriginalHandler != null) {\n        myOriginalHandler.execute(editor, dataContext);\n      }\n      return;\n    }\n\n    VisualPosition positionToRestore = null;\n    SelectionModel selectionModel = editor.getSelectionModel();\n    if (!selectionModel.hasSelection() && !selectionModel.hasBlockSelection()) {\n      positionToRestore = editor.getCaretModel().getVisualPosition();\n      selectionModel.selectLineAtCaret();\n      if (!selectionModel.hasSelection()) return;\n    }\n\n    EditorActionManager.getInstance().getActionHandler(IdeActions.ACTION_EDITOR_COPY).execute(editor, dataContext);\n\n    EditorModificationUtil.deleteSelectedText(editor);\n    if (positionToRestore != null) {\n      editor.getCaretModel().moveToVisualPosition(positionToRestore);\n    }\n  }","id":83899,"modified_method":"@Override\n  public void executeWriteAction(Editor editor, DataContext dataContext) {\n    Project project = PlatformDataKeys.PROJECT.getData(DataManager.getInstance().getDataContext(editor.getContentComponent()));\n    if (project == null) {\n      if (myOriginalHandler != null) {\n        myOriginalHandler.execute(editor, dataContext);\n      }\n      return;\n    }\n\n    final PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n\n    if (file == null) {\n      if (myOriginalHandler != null) {\n        myOriginalHandler.execute(editor, dataContext);\n      }\n      return;\n    }\n\n    VisualPosition positionToRestore = null;\n    SelectionModel selectionModel = editor.getSelectionModel();\n    if (!selectionModel.hasSelection() && !selectionModel.hasBlockSelection()) {\n      positionToRestore = editor.getCaretModel().getVisualPosition();\n      selectionModel.selectLineAtCaret();\n      if (!selectionModel.hasSelection()) return;\n    }\n\n    int start = selectionModel.getSelectionStart();\n    int end = selectionModel.getSelectionEnd();\n\n    EditorActionManager.getInstance().getActionHandler(IdeActions.ACTION_EDITOR_COPY).execute(editor, dataContext);\n\n    if (start != end) {\n      // There is a possible case that 'sticky selection' is active. It's automatically removed on copying then, so, we explictly\n      // remove the text.\n      editor.getDocument().deleteString(start, end);\n    }\n    else {\n      EditorModificationUtil.deleteSelectedText(editor);\n    }\n    \n    if (positionToRestore != null) {\n      editor.getCaretModel().moveToVisualPosition(positionToRestore);\n    }\n  }","commit_id":"d0c1d0449b0c11234ad0eae1ead39acadf8c76f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean charDeleted(final char c, final PsiFile file, final Editor editor) {\n    if (myTargetPosition != null) {\n      // Remove all the following spaces before moving to targetPosition\n      final int offset = editor.getCaretModel().getOffset();\n      if (EditorModificationUtil.calcAfterLineEnd(editor) == 0) {\n        int delta = editor.getCaretModel().getVisualPosition().column - myTargetPosition.column;\n        editor.getSelectionModel().setSelection(offset - delta, offset);\n        EditorModificationUtil.deleteSelectedText(editor);\n      }\n      editor.getCaretModel().moveToLogicalPosition(myTargetPosition);\n      myTargetPosition = null;\n      return true;\n    }\n    return false;\n  }","id":83900,"modified_method":"public boolean charDeleted(final char c, final PsiFile file, final Editor editor) {\n    if (myTargetPosition != null) {\n      // Remove all the following spaces before moving to targetPosition\n      final int offset = editor.getCaretModel().getOffset();\n      if (EditorModificationUtil.calcAfterLineEnd(editor) == 0) {\n        int delta = editor.getCaretModel().getVisualPosition().column - myTargetPosition.column;\n        assert delta >= 0;\n        if (offset <= editor.getDocument().getTextLength()) {\n          editor.getSelectionModel().setSelection(offset - delta, offset);\n          EditorModificationUtil.deleteSelectedText(editor);\n        }\n      }\n      editor.getCaretModel().moveToLogicalPosition(myTargetPosition);\n      myTargetPosition = null;\n      return true;\n    }\n    return false;\n  }","commit_id":"8672e72bd720da6036c8bac3a7b131ef691f18f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = source.getSourceObject(game);         \r\n        if (controller != null && sourceObject != null) {\r\n            // move cards from library to exile\r\n            for (int i = 0; i < source.getManaCostsToPay().getX(); i++) {\r\n                if (controller.getLibrary().size() > 0) {\r\n                    Card topCard = controller.getLibrary().getFromTop(game);\r\n                    controller.moveCardToExileWithInfo(topCard, source.getSourceId(), sourceObject.getIdName(),  source.getSourceId(), game, Zone.LIBRARY, true);\r\n                }\r\n            }\r\n            // cast the possible cards without paying the mana\r\n            ExileZone epicExperimentExileZone = game.getExile().getExileZone(source.getSourceId());\r\n            FilterCard filter = filterStatic.copy();\r\n            filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, source.getManaCostsToPay().getX() + 1));\r\n            filter.setMessage(\"instant and sorcery cards with converted mana cost \"+ source.getManaCostsToPay().getX() +\" or less\");\r\n            while (epicExperimentExileZone != null && epicExperimentExileZone.count(filter, game) > 0\r\n                    && controller.chooseUse(Outcome.PlayForFree, \"Cast cards exiled with \" + sourceObject.getLogName() + \" without paying its mana cost?\", source, game)) {\r\n                TargetCardInExile target = new TargetCardInExile(filter, source.getSourceId());\r\n                while (epicExperimentExileZone.count(filter, game) > 0 && controller.choose(Outcome.PlayForFree, epicExperimentExileZone, target, game)) {\r\n                        Card card = game.getCard(target.getFirstTarget());\r\n                        if (card != null) {                            \r\n                            if (controller.cast(card.getSpellAbility(), game, true)) {\r\n                                game.getExile().removeCard(card, game);\r\n                            }\r\n                        }\r\n                        target.clearChosen();\r\n                }\r\n            }\r\n            // move cards not cast to graveyard\r\n            ExileZone exile = game.getExile().getExileZone(source.getSourceId());\r\n            if (exile != null) {\r\n                controller.moveCards(exile, Zone.EXILED, Zone.GRAVEYARD, source, game);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":83901,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = source.getSourceObject(game);\r\n        if (controller != null && sourceObject != null) {\r\n            // move cards from library to exile\r\n            controller.moveCardsToExile(controller.getLibrary().getTopCards(game, source.getManaCostsToPay().getX()), source, game, true, source.getSourceId(), sourceObject.getIdName());\r\n            // cast the possible cards without paying the mana\r\n            ExileZone epicExperimentExileZone = game.getExile().getExileZone(source.getSourceId());\r\n            FilterCard filter = new FilterInstantOrSorceryCard();\r\n            filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan, source.getManaCostsToPay().getX() + 1));\r\n            filter.setMessage(\"instant and sorcery cards with converted mana cost \" + source.getManaCostsToPay().getX() + \" or less\");\r\n            Cards cardsToCast = new CardsImpl();\r\n            if (epicExperimentExileZone == null) {\r\n                return true;\r\n            }\r\n            cardsToCast.addAll(epicExperimentExileZone.getCards(filter, source.getSourceId(), source.getControllerId(), game));\r\n            while (cardsToCast.size() > 0) {\r\n                if (!controller.chooseUse(Outcome.PlayForFree, \"Cast (another) a card exiled with \" + sourceObject.getLogName() + \" without paying its mana cost?\", source, game)) {\r\n                    break;\r\n                }\r\n                TargetCard targetCard = new TargetCard(1, Zone.EXILED, new FilterCard(\"instant or sorcery card to cast for free\"));\r\n                if (controller.choose(Outcome.PlayForFree, cardsToCast, targetCard, game)) {\r\n                    Card card = game.getCard(targetCard.getFirstTarget());\r\n                    if (card != null) {\r\n                        if (controller.cast(card.getSpellAbility(), game, true)) {\r\n                            cardsToCast.remove(card);\r\n                        } else {\r\n                            game.informPlayer(controller, \"You're not able to cast \" + card.getIdName() + \" or you canceled the casting.\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            // move cards not cast to graveyard\r\n            controller.moveCards(game.getExile().getExileZone(source.getSourceId()).getCards(game), Zone.GRAVEYARD, source, game);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"5262d8d35810d4b2ee5a9afb4914d79120976ee7","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            Card card = game.getCard(targetPointer.getFirst(game, source));\r\n            if (card != null) {\r\n                controller.moveCards(card, Zone.BATTLEFIELD, source, game, tapped, false, true, null);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":83902,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            controller.moveCards(new CardsImpl(getTargetPointer().getTargets(game, source)).getCards(game),\r\n                    Zone.BATTLEFIELD, source, game, tapped, false, true, null);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"70959ca22504eef94c6d20fd4df141c6f5dd05e4","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana) {\n        Player controller = game.getPlayer(controllerId);\n        if(controller != null) {\n            Library library = controller.getLibrary();\n            Cards cards = new CardsImpl();\n            for(int i = 0; i < amount; i++) {\n                cards.add(library.removeFromTop(game));\n            }\n            controller.moveCards(cards, Zone.LIBRARY, Zone.EXILED, ability, game);\n            paid = true;\n        }\n        return paid;\n    }","id":83903,"modified_method":"@Override\n    public boolean pay(Ability ability, Game game, UUID sourceId, UUID controllerId, boolean noMana) {\n        Player controller = game.getPlayer(controllerId);\n        if(controller != null) {\n            controller.moveCards(controller.getLibrary().getTopCards(game, amount), Zone.LIBRARY, Zone.EXILED, ability, game);\n            paid = true;\n        }\n        return paid;\n    }","commit_id":"3598f07caa4d3ad91101f0bdf9d1f84db3a93f57","url":"https://github.com/magefree/mage"},{"original_method":"private static int recurseFolders(final Iterator<String> it, String root, int count, final boolean next, final String prev) {\n\n        final String fn = (next) ? it.next() : prev;\n\n    \tif(\"\\uffff\".equals(fn)) {\n            int i = prev.replaceAll(\"[^/]\",\"\").length();\n            while( i>0 ){\n                prop.put(\"display_folderlist_\"+count+\"_folder\", \"<\/ul><\/li>\");\n                count++;\n                i--;\n            }\n            return count;\n    \t}\n\n    \tif (fn.startsWith((\"/\".equals(root) ? root : root + \"/\"))) {\n            prop.put(\"display_folderlist_\"+count+\"_folder\", \"<li>\"+fn.replaceFirst(root+\"/*\",\"\")+\"<ul class=\\\"folder\\\">\");\n            count++;\n            final Iterator<String> bit = sb.bookmarksDB.getBookmarksIterator(fn, isAdmin);\n\n            while (bit.hasNext()) {\n                Bookmark bookmark = null;\n                try {\n                    bookmark = sb.bookmarksDB.getBookmark(bit.next());\n                } catch (final IOException e) {\n                }\n                if (bookmark == null) break;\n                prop.put(\"display_folderlist_\" + count + \"_folder\", \"<li><a href=\\\"\" + bookmark.getUrl() + \"\\\" title=\\\"\" + bookmark.getDescription() + \"\\\">\" + bookmark.getTitle() + \"<\/a><\/li>\");\n                count++;\n            }\n\n            if (it.hasNext()) {\n                count = recurseFolders(it, fn, count, true, fn);\n            }\n\n    \t} else {\n            prop.put(\"display_folderlist_\"+count+\"_folder\", \"<\/ul><\/li>\");\n            count++;\n            root = root.replaceAll(\"(/.[^/]*$)\", \"\");\n            if (\"\".equals(root)) {\n                root = \"/\";\n            }\n            count = recurseFolders(it, root, count, false, fn);\n    \t}\n    \treturn count;\n    }","id":83904,"modified_method":"private static int recurseFolders(final Iterator<String> it, String root, int count, final boolean next, final String prev) {\n\n        final String fn = (next) ? it.next() : prev;\n\n    \tif(\"\\uffff\".equals(fn)) {\n            int i = prev.replaceAll(\"[^/]\",\"\").length();\n            while( i>0 ){\n                prop.put(\"display_folderlist_\"+count+\"_folder\", \"<\/ul><\/li>\");\n                count++;\n                i--;\n            }\n            return count;\n    \t}\n\n    \tif (fn.startsWith((\"/\".equals(root) ? root : root + \"/\"))) {\n            prop.put(\"display_folderlist_\"+count+\"_folder\", \"<li>\"+fn.replaceFirst(root+\"/*\",\"\")+\"<ul class=\\\"folder\\\">\");\n            count++;\n            final Iterator<String> bit = sb.bookmarksDB.getBookmarksIterator(fn, isAdmin);\n\n            while (bit.hasNext()) {\n                Bookmark bookmark = sb.bookmarksDB.getBookmark(bit.next());\n                if (bookmark == null) break;\n                prop.put(\"display_folderlist_\" + count + \"_folder\", \"<li><a href=\\\"\" + bookmark.getUrl() + \"\\\" title=\\\"\" + bookmark.getDescription() + \"\\\">\" + bookmark.getTitle() + \"<\/a><\/li>\");\n                count++;\n            }\n\n            if (it.hasNext()) {\n                count = recurseFolders(it, fn, count, true, fn);\n            }\n\n    \t} else {\n            prop.put(\"display_folderlist_\"+count+\"_folder\", \"<\/ul><\/li>\");\n            count++;\n            root = root.replaceAll(\"(/.[^/]*$)\", \"\");\n            if (\"\".equals(root)) {\n                root = \"/\";\n            }\n            count = recurseFolders(it, root, count, false, fn);\n    \t}\n    \treturn count;\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\n    \tint max_count = 10;\n    \tint start=0;\n    \tint display = 0;\n    \tString tagName = \"\";\n    \tString username=\"\";\n\n    \tprop.clear();\n    \tsb = (Switchboard) env;\n    \tuser = sb.userDB.getUser(header);\n    \tisAdmin = (sb.verifyAuthentication(header) || user!= null && user.hasRight(UserDB.AccessRight.BOOKMARK_RIGHT));\n\n    \t// set user name\n    \tif (user != null) {\n            username=user.getUserName();\n        } else if(isAdmin) {\n            username=\"admin\";\n        }\n    \tprop.putHTML(\"user\", username);\n\n    \t//redirect to userpage\n    \t/*\n    \tif(username!=\"\" &&(post == null || !post.containsKey(\"user\") && !post.containsKey(\"mode\")))\n        prop.put(\"LOCATION\", \"/Bookmarks.html?user=\"+username);\n    \t*/\n\n    \t// set peer address\n    \tprop.put(\"address\", sb.peers.mySeed().getPublicAddress(sb.peers.mySeed().getIP()));\n\n    \t//defaultvalues\n    \tif(isAdmin) {\n            prop.put(\"mode\", \"1\");\n            prop.put(\"admin\", \"1\");\n            prop.put(\"display\", \"0\");\n        } else {\n            prop.put(\"mode\", \"0\");\n            prop.put(\"admin\", \"0\");\n            prop.put(\"display\", \"0\");\n        }\n    \tprop.put(\"mode_edit\", \"0\");\n    \tprop.put(\"mode_title\", \"\");\n    \tprop.put(\"mode_description\", \"\");\n    \tprop.put(\"mode_url\", \"\");\n    \tprop.put(\"mode_tags\", \"\");\n    \tprop.put(\"mode_path\", \"\");\n    \tprop.put(\"mode_public\", \"1\"); //1=is public\n    \tprop.put(\"mode_feed\", \"0\"); //no newsfeed\n\n    \tif (post != null) {\n            if (!isAdmin) {\n                if(post.containsKey(\"login\")){\n                \tprop.authenticationRequired();\n                }\n            } else if (post.containsKey(\"mode\")) {\n                final String mode=post.get(\"mode\");\n                if (\"add\".equals(mode)) {\n                    prop.put(\"mode\", \"2\");\n                    prop.put(\"display\", \"1\");\n                    display = 1;\n                } else if (\"importxml\".equals(mode)){\n                    prop.put(\"mode\", \"3\");\n                    prop.put(\"display\", \"1\");\n                    display = 1;\n                }\n            } else if(post.containsKey(\"add\")) { //add an Entry\n                final String url=post.get(\"url\");\n                final String title=post.get(\"title\");\n                final String description=post.get(\"description\");\n                String tagsString = post.get(\"tags\");\n                String pathString = post.get(\"path\");\n                if(pathString == null || \"\".equals(pathString)){\n                    pathString=\"/unsorted\"; //default folder\n                }\n                tagsString = tagsString + \",\" + pathString;\n                final Set<String> tags=ListManager.string2set(BookmarkHelper.cleanTagsString(tagsString));\n                final BookmarksDB.Bookmark bookmark = sb.bookmarksDB.createorgetBookmark(url, username);\n\n                if (bookmark != null) {\n                    bookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_TITLE, title);\n                    bookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_DESCRIPTION, description);\n\n                    if (user!=null) {\n                        bookmark.setOwner(user.getUserName());\n                    }\n\n                    if (\"public\".equals(post.get(\"public\"))) {\n                        bookmark.setPublic(true);\n                        publishNews(url, title, description, tagsString);\n                    } else {\n                        bookmark.setPublic(false);\n                    }\n\n                    if(post.containsKey(\"feed\") && (\"true\".equals(post.get(\"feed\")))){\n                        bookmark.setFeed(true);\n                    } else {\n                        bookmark.setFeed(false);\n                    }\n\n                    bookmark.setTags(tags, true);\n                    \n                    if (post.containsKey(\"query\")) {\n                        bookmark.setProperty(Bookmark.BOOKMARK_QUERY, post.get(\"query\"));\n                        bookmark.setTimeStamp(System.currentTimeMillis());\n                    }\n                    sb.bookmarksDB.saveBookmark(bookmark);\n                }\n\n            } else if (post.containsKey(\"edit\")) {\n                final String urlHash = post.get(\"edit\");\n                prop.put(\"mode\", \"2\");\n                prop.put(\"display\", \"1\");\n                display = 1;\n                ClientIdentification.Agent agent = ClientIdentification.getAgent(post.get(\"agentName\", ClientIdentification.yacyInternetCrawlerAgentName));\n                if (urlHash.isEmpty()) {\n                    prop.put(\"mode_edit\", \"0\"); // create mode\n                    prop.putHTML(\"mode_title\", post.get(\"title\"));\n                    prop.putHTML(\"mode_description\", post.get(\"description\"));\n                    prop.putHTML(\"mode_url\", post.get(\"url\"));\n                    prop.putHTML(\"mode_tags\", post.get(\"tags\"));\n                    prop.putHTML(\"mode_path\", post.get(\"path\"));\n                    prop.put(\"mode_public\", \"0\");\n                    prop.put(\"mode_feed\", \"0\");\n                } else {\n                    BookmarksDB.Bookmark bookmark = null;\n                    try {\n                        bookmark = sb.bookmarksDB.getBookmark(urlHash);\n                    } catch (final IOException e1) {\n                    }\n                    if (bookmark == null) {\n                        // try to get the bookmark from the LURL database\n                        final URIMetadataNode urlentry = sb.index.fulltext().getMetadata(ASCII.getBytes(urlHash));\n                        if (urlentry != null) try {\n                            final Document document = Document.mergeDocuments(urlentry.url(), null, sb.loader.loadDocuments(sb.loader.request(urlentry.url(), true, false), CacheStrategy.IFEXIST, Integer.MAX_VALUE, null, agent));\n                            prop.put(\"mode_edit\", \"0\"); // create mode\n                            prop.put(\"mode_url\", urlentry.url().toNormalform(false));\n                            prop.putHTML(\"mode_title\", urlentry.dc_title());\n                            prop.putHTML(\"mode_description\", (document == null) ? urlentry.dc_title(): document.dc_title());\n                            prop.putHTML(\"mode_author\", urlentry.dc_creator());\n                            prop.putHTML(\"mode_tags\", (document == null) ? urlentry.dc_subject() : document.dc_subject(','));\n                            prop.putHTML(\"mode_path\",\"\");\n                            prop.put(\"mode_public\", \"0\");\n                            prop.put(\"mode_feed\", \"0\"); //TODO: check if it IS a feed\n                        } catch (final IOException e) {ConcurrentLog.logException(e);} catch (final Parser.Failure e) {ConcurrentLog.logException(e);}\n                    } else {\n                        // get from the bookmark database\n                        prop.put(\"mode_edit\", \"1\"); // edit mode\n                        prop.putHTML(\"mode_title\", bookmark.getTitle());\n                        prop.putHTML(\"mode_description\", bookmark.getDescription());\n                        prop.put(\"mode_url\", bookmark.getUrl()); //TODO: XSS protection - how is this stored?\n                        prop.putHTML(\"mode_tags\", bookmark.getTagsString());\n                        prop.putHTML(\"mode_path\",bookmark.getFoldersString());\n\n                        if (bookmark.getQuery() != null) {\n                            prop.put(\"mode_hasquery\",\"1\");\n                            prop.putHTML(\"mode_hasquery_query\", bookmark.getQuery());\n                        } else {\n                            prop.put(\"mode_hasquery\", \"0\");\n                        }\n\n                        if (bookmark.getPublic()) {\n                            prop.put(\"mode_public\", \"1\");\n                        } else {\n                            prop.put(\"mode_public\", \"0\");\n                        }\n\n                        if (bookmark.getFeed()) {\n                            prop.put(\"mode_feed\", \"1\");\n                        } else {\n                            prop.put(\"mode_feed\", \"0\");\n                        }\n                    }\n                }\n            } else if(post.containsKey(\"htmlfile\")){\n                final boolean isPublic = \"public\".equals(post.get(\"public\"));\n\n                String tags = post.get(\"tags\");\n                if(\"\".equals(tags)){\n                    tags=\"unsorted\";\n                }\n\n                ConcurrentLog.info(\"BOOKMARKS\", \"Trying to import bookmarks from HTML-file\");\n\n                try {\n                    final File file = new File(post.get(\"htmlfile\"));\n                    BookmarkHelper.importFromBookmarks(sb.bookmarksDB, new DigestURL(file), post.get(\"htmlfile$file\"), tags, isPublic);\n                } catch (final MalformedURLException e) {}\n\n                ConcurrentLog.info(\"BOOKMARKS\", \"success!!\");\n\n            } else if (post.containsKey(\"xmlfile\")) {\n\n                final boolean isPublic = \"public\".equals(post.get(\"public\"));\n                BookmarkHelper.importFromXML(sb.bookmarksDB, post.get(\"xmlfile$file\"), isPublic);\n\n            } else if (post.containsKey(\"delete\")) {\n\n                final String urlHash=post.get(\"delete\");\n                sb.bookmarksDB.removeBookmark(urlHash);\n\n            }\n\n            if (post.containsKey(\"tag\")) {\n                tagName = post.get(\"tag\");\n            }\n\n            if (post.containsKey(\"start\")) {\n                start = post.getInt(\"start\", 0);\n            }\n\n            if (post.containsKey(\"num\")) {\n                max_count = post.getInt(\"num\", 10);\n            }\n    \t} // END if(post != null)\n\n    \tif (display == 0) {\n\n\t    \t//-----------------------\n\t    \t// create tag list\n\t    \t//-----------------------\n\t    \tprintTagList(\"taglist\", tagName, SORT_SIZE, 25, false);\n\t    \tprintTagList(\"optlist\", tagName, SORT_ALPHA, SHOW_ALL, true);\n\n\t    \t//-----------------------\n\t    \t// create bookmark list\n\t    \t//-----------------------\n\t    \tint count = 0;\n\t        Iterator<String> it = null;\n\n                prop.put(\"display_num-bookmarks\", sb.bookmarksDB.bookmarksSize());\n\n\t       \tif(!\"\".equals(tagName)){\n                    prop.put(\"display_selected\", \"\");\n                    it = sb.bookmarksDB.getBookmarksIterator(tagName, isAdmin);\n\t       \t} else {\n                    prop.put(\"display_selected\", \" selected=\\\"selected\\\"\");\n                    it = sb.bookmarksDB.getBookmarksIterator(isAdmin);\n\t       \t}\n\n\t       \t//skip the first entries (display next page)\n\t       \tcount = 0;\n\t       \twhile(count < start && it.hasNext()){\n                    it.next();\n                    count++;\n\t       \t}\n\n\t       \tcount = 0;\n\t       \twhile(count < max_count && it.hasNext()) {\n                    Bookmark bookmark = null;\n                    try {\n                        bookmark = sb.bookmarksDB.getBookmark(it.next());\n                    } catch (final IOException e) {\n                    }\n\n                    if (bookmark != null){\n                        if (bookmark.getFeed() && isAdmin) {\n                            prop.putXML(\"display_bookmarks_\"+count+\"_link\", \"/FeedReader_p.html?url=\"+bookmark.getUrl());\n                        } else {\n                            prop.putXML(\"display_bookmarks_\"+count+\"_link\",bookmark.getUrl());\n                        }\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_title\", bookmark.getTitle());\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_description\", bookmark.getDescription());\n                        if (bookmark.getQuery() == null) {\n                            prop.put(\"display_bookmarks_\"+count+\"_hasquery\", false);\n                        } else {\n                            prop.put(\"display_bookmarks_\"+count+\"_hasquery\", true);\n                            prop.put(\"display_bookmarks_\"+count+\"_hasquery_query\", bookmark.getQuery());\n                        }\n                        prop.put(\"display_bookmarks_\"+count+\"_date\", ISO8601Formatter.FORMATTER.format(new Date(bookmark.getTimeStamp())));\n                        prop.put(\"display_bookmarks_\"+count+\"_rfc822date\", HeaderFramework.formatRFC1123(new Date(bookmark.getTimeStamp())));\n                        prop.put(\"display_bookmarks_\"+count+\"_public\", (bookmark.getPublic() ? \"1\" : \"0\"));\n\n                        //List Tags.\n                        final Set<String> tags = bookmark.getTags();\n                        int tagCount=0;\n                        for (final String tag : tags) {\n                            if (tag.length() > 0 && tag.charAt(0) != '/') {\n                                prop.putHTML(\"display_bookmarks_\" + count + \"_tags_\" + tagCount + \"_tag\", tag);\n                                tagCount++;\n                            }\n                        }\n                        prop.put(\"display_bookmarks_\"+count+\"_tags\", tagCount);\n                        prop.put(\"display_bookmarks_\"+count+\"_hash\", bookmark.getUrlHash());\n                        count++;\n                    }\n\t       \t}\n\n\t       \tprop.putHTML(\"display_tag\", tagName);\n\t       \tprop.put(\"display_start\", start);\n\n\t       \tif (it.hasNext()) {\n                    prop.put(\"display_next-page\", \"1\");\n                    prop.put(\"display_next-page_start\", start+max_count);\n                    prop.putHTML(\"display_next-page_tag\", tagName);\n                    prop.put(\"display_next-page_num\", max_count);\n\t       \t}\n\t       \tif (start >= max_count) {\n                    start = start-max_count;\n                    if (start <0){\n                        start = 0;\n                    }\n                    prop.put(\"display_prev-page\", \"1\");\n                    prop.put(\"display_prev-page_start\", start);\n                    prop.putHTML(\"display_prev-page_tag\", tagName);\n                    prop.put(\"display_prev-page_num\", max_count);\n\t       \t}\n\t       \tprop.put(\"display_bookmarks\", count);\n\n\n\t    \t//-----------------------\n\t    \t// create folder list\n\t    \t//-----------------------\n\n\t       \tcount = 0;\n\t       \tcount = recurseFolders(BookmarkHelper.getFolderList(\"/\", sb.bookmarksDB.getTagIterator(isAdmin)), \"/\", 0, true, \"\");\n\t       \tprop.put(\"display_folderlist\", count);\n\n            BusyThread bt = sb.getThread(\"autosearch\");\n            if (bt != null) {\n                prop.put(\"display_autosearchrunning\",\"1\");\n                prop.put(\"display_autosearchrunning_msg\", \"\" );\n                if (post != null && post.containsKey(\"stopautosearch\")) {\n                    sb.terminateThread(\"autosearch\", false);\n                    prop.put(\"display_autosearchrunning_msg\", \"autosearch will terminate\");\n                    prop.put(\"display_autosearchrunning\",\"0\");\n                }\n                int jobs = bt.getJobCount();\n                prop.put(\"display_autosearchrunning_jobcount\", jobs);\n                int cnt=0;\n                String qstr = \"\";\n                if (bt instanceof AutoSearch) {\n                    cnt = ((AutoSearch) bt).gotresults;\n                    qstr = ((AutoSearch) bt).currentQuery;\n                    if (qstr == null) qstr = \"---\";\n                }\n                prop.put(\"display_autosearchrunning_totalcount\", cnt);\n                prop.put(\"display_autosearchrunning_query\", qstr);\n\n            } else {\n                prop.put(\"display_autosearchrunning\", \"0\");\n                prop.put(\"display_autosearchrunning_msg\", \"\");\n                if (post != null && post.containsKey(\"startautosearch\")) {\n                    sb.deployThread(\n                            \"autosearch\",\n                            \"Auto Search\",\n                            \"query all peers for given search terms\",\n                            null,\n                            new AutoSearch(Switchboard.getSwitchboard()),\n                            1000);\n                    prop.put(\"display_autosearchrunning_msg\", \"autsearch job started\");\n                }\n            }\n    \t}\n       \treturn prop;    // return from serverObjects respond()\n    }","id":83905,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\n    \tint max_count = 10;\n    \tint start=0;\n    \tint display = 0;\n    \tString tagName = \"\";\n    \tString username=\"\";\n\n    \tprop.clear();\n    \tsb = (Switchboard) env;\n    \tuser = sb.userDB.getUser(header);\n    \tisAdmin = (sb.verifyAuthentication(header) || user!= null && user.hasRight(UserDB.AccessRight.BOOKMARK_RIGHT));\n\n    \t// set user name\n    \tif (user != null) {\n            username=user.getUserName();\n        } else if(isAdmin) {\n            username=\"admin\";\n        }\n    \tprop.putHTML(\"user\", username);\n\n    \t//redirect to userpage\n    \t/*\n    \tif(username!=\"\" &&(post == null || !post.containsKey(\"user\") && !post.containsKey(\"mode\")))\n        prop.put(\"LOCATION\", \"/Bookmarks.html?user=\"+username);\n    \t*/\n\n    \t// set peer address\n    \tprop.put(\"address\", sb.peers.mySeed().getPublicAddress(sb.peers.mySeed().getIP()));\n\n    \t//defaultvalues\n    \tif(isAdmin) {\n            prop.put(\"mode\", \"1\");\n            prop.put(\"admin\", \"1\");\n            prop.put(\"display\", \"0\");\n        } else {\n            prop.put(\"mode\", \"0\");\n            prop.put(\"admin\", \"0\");\n            prop.put(\"display\", \"0\");\n        }\n    \tprop.put(\"mode_edit\", \"0\");\n    \tprop.put(\"mode_title\", \"\");\n    \tprop.put(\"mode_description\", \"\");\n    \tprop.put(\"mode_url\", \"\");\n    \tprop.put(\"mode_tags\", \"\");\n    \tprop.put(\"mode_path\", \"\");\n    \tprop.put(\"mode_public\", \"1\"); //1=is public\n    \tprop.put(\"mode_feed\", \"0\"); //no newsfeed\n\n    \tif (post != null) {\n            if (!isAdmin) {\n                if(post.containsKey(\"login\")){\n                \tprop.authenticationRequired();\n                }\n            } else if (post.containsKey(\"mode\")) {\n                final String mode=post.get(\"mode\");\n                if (\"add\".equals(mode)) {\n                    prop.put(\"mode\", \"2\");\n                    prop.put(\"display\", \"1\");\n                    display = 1;\n                } else if (\"importxml\".equals(mode)){\n                    prop.put(\"mode\", \"3\");\n                    prop.put(\"display\", \"1\");\n                    display = 1;\n                }\n            } else if(post.containsKey(\"add\")) { //add an Entry\n                final String url=post.get(\"url\");\n                final String title=post.get(\"title\");\n                final String description=post.get(\"description\");\n                String tagsString = post.get(\"tags\");\n                String pathString = post.get(\"path\");\n                if(pathString == null || \"\".equals(pathString)){\n                    pathString=\"/unsorted\"; //default folder\n                }\n                tagsString = tagsString + \",\" + pathString;\n                final Set<String> tags=ListManager.string2set(BookmarkHelper.cleanTagsString(tagsString));\n                final BookmarksDB.Bookmark bookmark = sb.bookmarksDB.createorgetBookmark(url, username);\n\n                if (bookmark != null) {\n                    bookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_TITLE, title);\n                    bookmark.setProperty(BookmarksDB.Bookmark.BOOKMARK_DESCRIPTION, description);\n\n                    if (user!=null) {\n                        bookmark.setOwner(user.getUserName());\n                    }\n\n                    if (\"public\".equals(post.get(\"public\"))) {\n                        bookmark.setPublic(true);\n                        publishNews(url, title, description, tagsString);\n                    } else {\n                        bookmark.setPublic(false);\n                    }\n\n                    if(post.containsKey(\"feed\") && (\"true\".equals(post.get(\"feed\")))){\n                        bookmark.setFeed(true);\n                    } else {\n                        bookmark.setFeed(false);\n                    }\n\n                    bookmark.setTags(tags, true);\n                    \n                    if (post.containsKey(\"query\")) {\n                        bookmark.setProperty(Bookmark.BOOKMARK_QUERY, post.get(\"query\"));\n                        bookmark.setTimeStamp(System.currentTimeMillis());\n                    }\n                    sb.bookmarksDB.saveBookmark(bookmark);\n                }\n\n            } else if (post.containsKey(\"edit\")) {\n                final String urlHash = post.get(\"edit\");\n                prop.put(\"mode\", \"2\");\n                prop.put(\"display\", \"1\");\n                display = 1;\n                ClientIdentification.Agent agent = ClientIdentification.getAgent(post.get(\"agentName\", ClientIdentification.yacyInternetCrawlerAgentName));\n                if (urlHash.isEmpty()) {\n                    prop.put(\"mode_edit\", \"0\"); // create mode\n                    prop.putHTML(\"mode_title\", post.get(\"title\"));\n                    prop.putHTML(\"mode_description\", post.get(\"description\"));\n                    prop.putHTML(\"mode_url\", post.get(\"url\"));\n                    prop.putHTML(\"mode_tags\", post.get(\"tags\"));\n                    prop.putHTML(\"mode_path\", post.get(\"path\"));\n                    prop.put(\"mode_public\", \"0\");\n                    prop.put(\"mode_feed\", \"0\");\n                } else {\n                    BookmarksDB.Bookmark bookmark = sb.bookmarksDB.getBookmark(urlHash);\n\n                    if (bookmark == null) {\n                        // try to get the bookmark from the LURL database\n                        final URIMetadataNode urlentry = sb.index.fulltext().getMetadata(ASCII.getBytes(urlHash));\n                        if (urlentry != null) try {\n                            final Document document = Document.mergeDocuments(urlentry.url(), null, sb.loader.loadDocuments(sb.loader.request(urlentry.url(), true, false), CacheStrategy.IFEXIST, Integer.MAX_VALUE, null, agent));\n                            prop.put(\"mode_edit\", \"0\"); // create mode\n                            prop.put(\"mode_url\", urlentry.url().toNormalform(false));\n                            prop.putHTML(\"mode_title\", urlentry.dc_title());\n                            prop.putHTML(\"mode_description\", (document == null) ? urlentry.dc_title(): document.dc_title());\n                            prop.putHTML(\"mode_author\", urlentry.dc_creator());\n                            prop.putHTML(\"mode_tags\", (document == null) ? urlentry.dc_subject() : document.dc_subject(','));\n                            prop.putHTML(\"mode_path\",\"\");\n                            prop.put(\"mode_public\", \"0\");\n                            prop.put(\"mode_feed\", \"0\"); //TODO: check if it IS a feed\n                        } catch (final IOException e) {ConcurrentLog.logException(e);} catch (final Parser.Failure e) {ConcurrentLog.logException(e);}\n                    } else {\n                        // get from the bookmark database\n                        prop.put(\"mode_edit\", \"1\"); // edit mode\n                        prop.putHTML(\"mode_title\", bookmark.getTitle());\n                        prop.putHTML(\"mode_description\", bookmark.getDescription());\n                        prop.put(\"mode_url\", bookmark.getUrl()); //TODO: XSS protection - how is this stored?\n                        prop.putHTML(\"mode_tags\", bookmark.getTagsString());\n                        prop.putHTML(\"mode_path\",bookmark.getFoldersString());\n\n                        if (bookmark.getQuery() != null) {\n                            prop.put(\"mode_hasquery\",\"1\");\n                            prop.putHTML(\"mode_hasquery_query\", bookmark.getQuery());\n                        } else {\n                            prop.put(\"mode_hasquery\", \"0\");\n                        }\n\n                        if (bookmark.getPublic()) {\n                            prop.put(\"mode_public\", \"1\");\n                        } else {\n                            prop.put(\"mode_public\", \"0\");\n                        }\n\n                        if (bookmark.getFeed()) {\n                            prop.put(\"mode_feed\", \"1\");\n                        } else {\n                            prop.put(\"mode_feed\", \"0\");\n                        }\n                    }\n                }\n            } else if(post.containsKey(\"htmlfile\")){\n                final boolean isPublic = \"public\".equals(post.get(\"public\"));\n\n                String tags = post.get(\"tags\");\n                if(\"\".equals(tags)){\n                    tags=\"unsorted\";\n                }\n\n                ConcurrentLog.info(\"BOOKMARKS\", \"Trying to import bookmarks from HTML-file\");\n\n                try {\n                    final File file = new File(post.get(\"htmlfile\"));\n                    BookmarkHelper.importFromBookmarks(sb.bookmarksDB, new DigestURL(file), post.get(\"htmlfile$file\"), tags, isPublic);\n                } catch (final MalformedURLException e) {}\n\n                ConcurrentLog.info(\"BOOKMARKS\", \"success!!\");\n\n            } else if (post.containsKey(\"xmlfile\")) {\n\n                final boolean isPublic = \"public\".equals(post.get(\"public\"));\n                BookmarkHelper.importFromXML(sb.bookmarksDB, post.get(\"xmlfile$file\"), isPublic);\n\n            } else if (post.containsKey(\"delete\")) {\n\n                final String urlHash=post.get(\"delete\");\n                sb.bookmarksDB.removeBookmark(urlHash);\n\n            }\n\n            if (post.containsKey(\"tag\")) {\n                tagName = post.get(\"tag\");\n            }\n\n            if (post.containsKey(\"start\")) {\n                start = post.getInt(\"start\", 0);\n            }\n\n            if (post.containsKey(\"num\")) {\n                max_count = post.getInt(\"num\", 10);\n            }\n    \t} // END if(post != null)\n\n    \tif (display == 0) {\n\n\t    \t//-----------------------\n\t    \t// create tag list\n\t    \t//-----------------------\n\t    \tprintTagList(\"taglist\", tagName, SORT_SIZE, 25, false);\n\t    \tprintTagList(\"optlist\", tagName, SORT_ALPHA, SHOW_ALL, true);\n\n\t    \t//-----------------------\n\t    \t// create bookmark list\n\t    \t//-----------------------\n\t    \tint count = 0;\n\t        Iterator<String> it = null;\n\n                prop.put(\"display_num-bookmarks\", sb.bookmarksDB.bookmarksSize());\n\n\t       \tif(!\"\".equals(tagName)){\n                    prop.put(\"display_selected\", \"\");\n                    it = sb.bookmarksDB.getBookmarksIterator(tagName, isAdmin);\n\t       \t} else {\n                    prop.put(\"display_selected\", \" selected=\\\"selected\\\"\");\n                    it = sb.bookmarksDB.getBookmarksIterator(isAdmin);\n\t       \t}\n\n\t       \t//skip the first entries (display next page)\n\t       \tcount = 0;\n\t       \twhile(count < start && it.hasNext()){\n                    it.next();\n                    count++;\n\t       \t}\n\n\t       \tcount = 0;\n\t       \twhile(count < max_count && it.hasNext()) {\n                    Bookmark bookmark = bookmark = sb.bookmarksDB.getBookmark(it.next());\n\n                    if (bookmark != null){\n                        if (bookmark.getFeed() && isAdmin) {\n                            prop.putXML(\"display_bookmarks_\"+count+\"_link\", \"/FeedReader_p.html?url=\"+bookmark.getUrl());\n                        } else {\n                            prop.putXML(\"display_bookmarks_\"+count+\"_link\",bookmark.getUrl());\n                        }\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_title\", bookmark.getTitle());\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_description\", bookmark.getDescription());\n                        if (bookmark.getQuery() == null) {\n                            prop.put(\"display_bookmarks_\"+count+\"_hasquery\", false);\n                        } else {\n                            prop.put(\"display_bookmarks_\"+count+\"_hasquery\", true);\n                            prop.put(\"display_bookmarks_\"+count+\"_hasquery_query\", bookmark.getQuery());\n                        }\n                        prop.put(\"display_bookmarks_\"+count+\"_date\", ISO8601Formatter.FORMATTER.format(new Date(bookmark.getTimeStamp())));\n                        prop.put(\"display_bookmarks_\"+count+\"_rfc822date\", HeaderFramework.formatRFC1123(new Date(bookmark.getTimeStamp())));\n                        prop.put(\"display_bookmarks_\"+count+\"_public\", (bookmark.getPublic() ? \"1\" : \"0\"));\n\n                        //List Tags.\n                        final Set<String> tags = bookmark.getTags();\n                        int tagCount=0;\n                        for (final String tag : tags) {\n                            if (tag.length() > 0 && tag.charAt(0) != '/') {\n                                prop.putHTML(\"display_bookmarks_\" + count + \"_tags_\" + tagCount + \"_tag\", tag);\n                                tagCount++;\n                            }\n                        }\n                        prop.put(\"display_bookmarks_\"+count+\"_tags\", tagCount);\n                        prop.put(\"display_bookmarks_\"+count+\"_hash\", bookmark.getUrlHash());\n                        count++;\n                    }\n\t       \t}\n\n\t       \tprop.putHTML(\"display_tag\", tagName);\n\t       \tprop.put(\"display_start\", start);\n\n\t       \tif (it.hasNext()) {\n                    prop.put(\"display_next-page\", \"1\");\n                    prop.put(\"display_next-page_start\", start+max_count);\n                    prop.putHTML(\"display_next-page_tag\", tagName);\n                    prop.put(\"display_next-page_num\", max_count);\n\t       \t}\n\t       \tif (start >= max_count) {\n                    start = start-max_count;\n                    if (start <0){\n                        start = 0;\n                    }\n                    prop.put(\"display_prev-page\", \"1\");\n                    prop.put(\"display_prev-page_start\", start);\n                    prop.putHTML(\"display_prev-page_tag\", tagName);\n                    prop.put(\"display_prev-page_num\", max_count);\n\t       \t}\n\t       \tprop.put(\"display_bookmarks\", count);\n\n\n\t    \t//-----------------------\n\t    \t// create folder list\n\t    \t//-----------------------\n\n\t       \tcount = 0;\n\t       \tcount = recurseFolders(BookmarkHelper.getFolderList(\"/\", sb.bookmarksDB.getTagIterator(isAdmin)), \"/\", 0, true, \"\");\n\t       \tprop.put(\"display_folderlist\", count);\n\n            BusyThread bt = sb.getThread(\"autosearch\");\n            if (bt != null) {\n                prop.put(\"display_autosearchrunning\",\"1\");\n                prop.put(\"display_autosearchrunning_msg\", \"\" );\n                if (post != null && post.containsKey(\"stopautosearch\")) {\n                    sb.terminateThread(\"autosearch\", false);\n                    prop.put(\"display_autosearchrunning_msg\", \"autosearch will terminate\");\n                    prop.put(\"display_autosearchrunning\",\"0\");\n                }\n                int jobs = bt.getJobCount();\n                prop.put(\"display_autosearchrunning_jobcount\", jobs);\n                int cnt=0;\n                String qstr = \"\";\n                if (bt instanceof AutoSearch) {\n                    cnt = ((AutoSearch) bt).gotresults;\n                    qstr = ((AutoSearch) bt).currentQuery;\n                    if (qstr == null) qstr = \"---\";\n                }\n                prop.put(\"display_autosearchrunning_totalcount\", cnt);\n                prop.put(\"display_autosearchrunning_query\", qstr);\n\n            } else {\n                prop.put(\"display_autosearchrunning\", \"0\");\n                prop.put(\"display_autosearchrunning_msg\", \"\");\n                if (post != null && post.containsKey(\"startautosearch\")) {\n                    sb.deployThread(\n                            \"autosearch\",\n                            \"Auto Search\",\n                            \"query all peers for given search terms\",\n                            null,\n                            new AutoSearch(Switchboard.getSwitchboard()),\n                            1000);\n                    prop.put(\"display_autosearchrunning_msg\", \"autsearch job started\");\n                }\n            }\n    \t}\n       \treturn prop;    // return from serverObjects respond()\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Iterator<String> getBookmarksIterator(final String tagName, final boolean priv){\n        final TreeSet<String> set=new TreeSet<String>(new bookmarkComparator(true));\n        final String tagHash=BookmarkHelper.tagHash(tagName);\n        final Tag tag=getTag(tagHash);\n        RowHandleSet hashes = tag == null ? new RowHandleSet(Word.commonHashLength, Word.commonHashOrder, 10) : tag.getUrlHashes();\n        if (priv) {\n            for (byte[] hash: hashes) set.add(ASCII.String(hash));\n        } else {\n            for (byte[] hash: hashes) {\n                try {\n                    Bookmark bm = getBookmark(ASCII.String(hash));\n                    if (bm != null && bm.getPublic()) {\n                        set.add(bm.getUrlHash());\n                    }\n                } catch (final IOException e) {\n                }\n            }\n        }\n    \treturn set.iterator();\n    }","id":83906,"modified_method":"public Iterator<String> getBookmarksIterator(final String tagName, final boolean priv){\n        final TreeSet<String> set=new TreeSet<String>(new bookmarkComparator(true));\n        final String tagHash=BookmarkHelper.tagHash(tagName);\n        final Tag tag=getTag(tagHash);\n        RowHandleSet hashes = tag == null ? new RowHandleSet(Word.commonHashLength, Word.commonHashOrder, 10) : tag.getUrlHashes();\n        if (priv) {\n            for (byte[] hash: hashes) set.add(ASCII.String(hash));\n        } else {\n            for (byte[] hash: hashes) {\n                Bookmark bm = getBookmark(ASCII.String(hash));\n                if (bm != null && bm.getPublic()) {\n                    set.add(bm.getUrlHash());\n                }\n            }\n        }\n    \treturn set.iterator();\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public boolean renameTag(final String oldName, final String newName){\n\n    \tfinal Tag oldTag=getTag(BookmarkHelper.tagHash(oldName));\n    \tif (oldTag != null) {\n            final RowHandleSet urlHashes = oldTag.getUrlHashes();\t// preserve urlHashes of oldTag\n            removeTag(BookmarkHelper.tagHash(oldName));\t\t\t\t\t\t\t// remove oldHash from TagsDB\n\n            Bookmark bookmark;\n            Set<String> tagSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n            for (final byte[] urlHash : urlHashes) {\t\t\t\t\t\t\t\t\t// looping through all bookmarks which were tagged with oldName\n                try {\n                    bookmark = getBookmark(ASCII.String(urlHash));\n                    tagSet = bookmark.getTags();\n                    tagSet.remove(oldName);\n                    bookmark.setTags(tagSet, true);                     // might not be needed, but doesn't hurt\n                    if(!\"\".equals(newName)) bookmark.addTag(newName);\n                    saveBookmark(bookmark);\n                } catch (final IOException e) {\n                }\n            }\n            return true;\n    \t}\n    \treturn false;\n    }","id":83907,"modified_method":"public boolean renameTag(final String oldName, final String newName){\n\n    \tfinal Tag oldTag=getTag(BookmarkHelper.tagHash(oldName));\n    \tif (oldTag != null) {\n            final RowHandleSet urlHashes = oldTag.getUrlHashes();\t// preserve urlHashes of oldTag\n            removeTag(BookmarkHelper.tagHash(oldName));\t\t\t\t\t\t\t// remove oldHash from TagsDB\n\n            Set<String> tagSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\n            for (final byte[] urlHash : urlHashes) {\t\t\t\t\t\t\t\t\t// looping through all bookmarks which were tagged with oldName\n                Bookmark bookmark = getBookmark(ASCII.String(urlHash));\n                if (bookmark != null) {\n                    tagSet = bookmark.getTags();\n                    tagSet.remove(oldName);\n                    bookmark.setTags(tagSet, true);                     // might not be needed, but doesn't hurt\n                    if (!\"\".equals(newName)) {\n                        bookmark.addTag(newName);\n                    }\n                    saveBookmark(bookmark);\n                } \n            }\n            return true;\n    \t}\n    \treturn false;\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * create or get existing bookmark\n     * @param url\n     * @param user\n     * @return\n     */\n    public Bookmark createorgetBookmark(final String url, final String user){\n        if (url == null || url.isEmpty()) return null;\n        Bookmark bk;\n        try {\n            try {\n                DigestURL durl = new DigestURL((url.indexOf(\"://\") < 0) ? \"http://\" + url : url);\n                bk = this.getBookmark(ASCII.String(durl.hash()));\n            } catch (IOException ex) {\n                bk = null;\n            }\n            if (bk == null) {\n                bk = new Bookmark(url);\n            }\n            bk.setOwner(user);\n            return (bk.getUrlHash() == null || bk.toMap() == null) ? null : bk;\n        } catch (final MalformedURLException e) {\n            return null;\n        }\n    }","id":83908,"modified_method":"/**\n     * create or get existing bookmark\n     * @param url\n     * @param user\n     * @return\n     */\n    public Bookmark createorgetBookmark(final String url, final String user){\n        if (url == null || url.isEmpty()) return null;\n        try {\n            DigestURL durl = new DigestURL((url.indexOf(\"://\") < 0) ? \"http://\" + url : url);\n            Bookmark bk = this.getBookmark(ASCII.String(durl.hash()));\n            if (bk == null) {\n                bk = new Bookmark(url);\n            }\n            bk.setOwner(user);\n            return (bk.getUrlHash() == null || bk.toMap() == null) ? null : bk;\n        } catch (final MalformedURLException e) {\n            return null;\n        }\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public boolean removeBookmark(final String urlHash){\n        Bookmark bookmark;\n        try {\n            bookmark = getBookmark(urlHash);\n        } catch (final IOException e1) {\n            return false;\n        }\n        final Set<String> tagSet = bookmark.getTags();\n        BookmarksDB.Tag tag=null;\n        final Iterator<String> it=tagSet.iterator();\n        while(it.hasNext()){\n            tag=getTag(BookmarkHelper.tagHash(it.next()));\n            if(tag!=null){\n                tag.delete(urlHash);\n                putTag(tag);\n            }\n        }\n        Bookmark b;\n        try {\n            b = getBookmark(urlHash);\n            this.bookmarks.delete(ASCII.getBytes(urlHash));\n        } catch (final IOException e) {\n            b = null;\n        }\n        return b != null;\n    }","id":83909,"modified_method":"public boolean removeBookmark(final String urlHash){\n        Bookmark bookmark = getBookmark(urlHash);\n        if (bookmark == null) {\n            return false;\n        }\n        final Set<String> tagSet = bookmark.getTags();\n        BookmarksDB.Tag tag=null;\n        final Iterator<String> it=tagSet.iterator();\n        while(it.hasNext()){\n            tag=getTag(BookmarkHelper.tagHash(it.next()));\n            if(tag!=null){\n                tag.delete(urlHash);\n                putTag(tag);\n            }\n        }\n        Bookmark  b = getBookmark(urlHash);\n        try {\n            if (b != null) this.bookmarks.delete(ASCII.getBytes(urlHash));\n        } catch (final IOException e) {\n            b = null;\n        }\n        return b != null;\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Bookmark getBookmark(final String urlHash) throws IOException {\n        try {\n            final Map<String, String> map = this.bookmarks.get(ASCII.getBytes(urlHash));\n            if (map == null) throw new IOException(\"cannot get bookmark for url hash \" + urlHash);\n            return new Bookmark(map);\n        } catch (final Throwable e) {\n            throw new IOException(e.getMessage());\n        }\n    }","id":83910,"modified_method":"/**\n     * Get bookmark for urlHash\n     * @param urlHash\n     * @return bookmark or null if not exist\n     */\n    public Bookmark getBookmark(final String urlHash) {\n        try {\n            final Map<String, String> map = this.bookmarks.get(ASCII.getBytes(urlHash));\n            if (map == null) {\n                ConcurrentLog.info(\"BOOKMARKS\", \"cannot get bookmark for url hash \" + urlHash);\n                return null;\n            } else {\n                return new Bookmark(map);\n            }\n        } catch (final Throwable e) {\n            return null;\n        }\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n        public int compare(final String obj1, final String obj2) {\n            try {\n                Bookmark bm1 = getBookmark(obj1);\n                Bookmark bm2 = getBookmark(obj2);\n                if (bm1 == null || bm2 == null) {\n                    return 0; //XXX: i think this should not happen? maybe this needs further tracing of the bug\n                }\n                if (this.newestFirst){\n                    if (bm2.getTimeStamp() - bm1.getTimeStamp() >0) return 1;\n                    return -1;\n                }\n                if  (bm1.getTimeStamp() - bm2.getTimeStamp() > 0) return 1;\n            } catch (final IOException e) {\n            }\n            return -1;\n        }","id":83911,"modified_method":"@Override\n        public int compare(final String obj1, final String obj2) {\n            Bookmark bm1 = getBookmark(obj1);\n            Bookmark bm2 = getBookmark(obj2);\n            if (bm1 == null || bm2 == null) {\n                return 0; //XXX: i think this should not happen? maybe this needs further tracing of the bug\n            }\n            if (this.newestFirst){\n            if (bm2.getTimeStamp() - bm1.getTimeStamp() >0) return 1;\n                return -1;\n            }\n            if  (bm1.getTimeStamp() - bm2.getTimeStamp() > 0) return 1;\n            return -1;\n        }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public Bookmark(final DigestURL url) {\n            this.entry = new HashMap<String, String>();\n            this.urlHash = ASCII.String(url.hash());\n            this.entry.put(BOOKMARK_URL, url.toNormalform(false));\n            this.tagNames = new HashSet<String>();\n            this.timestamp = System.currentTimeMillis();\n            Bookmark oldBm;\n            try {\n                oldBm = getBookmark(this.urlHash);\n                if(oldBm!=null && oldBm.entry.containsKey(BOOKMARK_TIMESTAMP)){\n                    this.entry.put(BOOKMARK_TIMESTAMP, oldBm.entry.get(BOOKMARK_TIMESTAMP)); //preserve timestamp on edit\n                }else{\n                    this.entry.put(BOOKMARK_TIMESTAMP, String.valueOf(System.currentTimeMillis()));\n                }\n            } catch (final IOException e) {\n            }\n            final BookmarkDate.Entry bmDate=BookmarksDB.this.dates.getDate(this.entry.get(BOOKMARK_TIMESTAMP));\n            bmDate.add(this.urlHash);\n            bmDate.setDatesTable();\n\n            removeBookmark(this.urlHash); //prevent empty tags\n        }","id":83912,"modified_method":"public Bookmark(final DigestURL url) {\n            this.entry = new HashMap<String, String>();\n            this.urlHash = ASCII.String(url.hash());\n            this.entry.put(BOOKMARK_URL, url.toNormalform(false));\n            this.tagNames = new HashSet<String>();\n            this.timestamp = System.currentTimeMillis();\n\n            Bookmark oldBm = getBookmark(this.urlHash);\n            if (oldBm != null && oldBm.entry.containsKey(BOOKMARK_TIMESTAMP)) {\n                this.entry.put(BOOKMARK_TIMESTAMP, oldBm.entry.get(BOOKMARK_TIMESTAMP)); //preserve timestamp on edit\n            } else {\n                this.entry.put(BOOKMARK_TIMESTAMP, String.valueOf(System.currentTimeMillis()));\n            }\n            final BookmarkDate.Entry bmDate=BookmarksDB.this.dates.getDate(this.entry.get(BOOKMARK_TIMESTAMP));\n            bmDate.add(this.urlHash);\n            bmDate.setDatesTable();\n\n            removeBookmark(this.urlHash); //prevent empty tags\n        }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n        public Bookmark next() {\n            try {\n                return getBookmark(UTF8.String(this.bookmarkIter.next()));\n            } catch (final IOException e) {\n                this.bookmarkIter.remove();\n                return null;\n            }\n        }","id":83913,"modified_method":"@Override\n        public Bookmark next() {\n            return getBookmark(UTF8.String(this.bookmarkIter.next()));\n        }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void addTag(final String selectTag, final String newTag) {\n\n    \tBookmark bookmark;\n    \tfor (final byte[] urlHash : getTag(BookmarkHelper.tagHash(selectTag)).getUrlHashes()) {\t// looping through all bookmarks which were tagged with selectTag\n            try {\n                bookmark = getBookmark(ASCII.String(urlHash));\n                bookmark.addTag(newTag);\n                saveBookmark(bookmark);\n            } catch (final IOException e) {\n            }\n        }\n    }","id":83914,"modified_method":"public void addTag(final String selectTag, final String newTag) {\n\n        for (final byte[] urlHash : getTag(BookmarkHelper.tagHash(selectTag)).getUrlHashes()) {\t// looping through all bookmarks which were tagged with selectTag\n            Bookmark bookmark = getBookmark(ASCII.String(urlHash));\n            if (bookmark != null) {\n                bookmark.addTag(newTag);\n                saveBookmark(bookmark);\n            }\n        }\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private Iterator<Tag> getTagIterator(final String tagName, final boolean priv, final int comp) {\n    \tfinal TreeSet<Tag> set=new TreeSet<Tag>((comp == SORT_SIZE) ? tagSizeComparator : tagComparator);\n    \tIterator<String> it=null;\n    \tfinal Iterator<String> bit=getBookmarksIterator(tagName, priv);\n    \tBookmark bm;\n    \tTag tag;\n    \tSet<String> tagSet;\n    \twhile (bit.hasNext()) {\n            try {\n                bm = getBookmark(bit.next());\n                if (bm == null) continue;\n                tagSet = bm.getTags();\n                it = tagSet.iterator();\n                while (it.hasNext()) {\n                    tag=getTag(BookmarkHelper.tagHash(it.next()) );\n                    if((priv ||tag.hasPublicItems()) && tag != null){\n                            set.add(tag);\n                    }\n                }\n            } catch (final IOException e) {\n            }\n    \t}\n    \treturn set.iterator();\n    }","id":83915,"modified_method":"private Iterator<Tag> getTagIterator(final String tagName, final boolean priv, final int comp) {\n    \tfinal TreeSet<Tag> set=new TreeSet<Tag>((comp == SORT_SIZE) ? tagSizeComparator : tagComparator);\n    \tIterator<String> it=null;\n    \tfinal Iterator<String> bit=getBookmarksIterator(tagName, priv);\n    \tTag tag;\n    \tSet<String> tagSet;\n        while (bit.hasNext()) {\n            Bookmark bm = getBookmark(bit.next());\n            if (bm == null) continue;\n            tagSet = bm.getTags();\n            it = tagSet.iterator();\n            while (it.hasNext()) {\n                tag = getTag(BookmarkHelper.tagHash(it.next()));\n                if ((priv || tag.hasPublicItems()) && tag != null) {\n                    set.add(tag);\n                }\n            }\n        }\n    \treturn set.iterator();\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\n        final Switchboard switchboard = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        boolean isAdmin = false;\n        isAdmin = switchboard.verifyAuthentication(header);\n\n        prop.put(\"result\", \"0\");//error\n        //rename tags\n        if(post != null && isAdmin) {\n        \tif (post.containsKey(\"selectTag\") && post.containsKey(\"addTag\")) {\n                switchboard.bookmarksDB.addTag(post.get(\"selectTag\"), post.get(\"addTag\"));\n                prop.put(\"result\", \"1\");//success\n        \t} else if (post.containsKey(\"urlhash\") && post.containsKey(\"addTag\")) {\n                Bookmark bm;\n                try {\n                    bm = switchboard.bookmarksDB.getBookmark(post.get(\"urlhash\"));\n                    bm.addTag(post.get(\"addTag\"));\n                    prop.put(\"result\", \"1\");//success\n                } catch (final IOException e) {\n                    prop.put(\"result\", \"0\");//success\n                }\n        \t}\n        }\n        // return rewrite properties\n        return prop;\n    }","id":83916,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\n        final Switchboard switchboard = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        boolean isAdmin = false;\n        isAdmin = switchboard.verifyAuthentication(header);\n\n        prop.put(\"result\", \"0\");//error\n        //rename tags\n        if(post != null && isAdmin) {\n            if (post.containsKey(\"selectTag\") && post.containsKey(\"addTag\")) {\n                switchboard.bookmarksDB.addTag(post.get(\"selectTag\"), post.get(\"addTag\"));\n                prop.put(\"result\", \"1\");//success\n            } else if (post.containsKey(\"urlhash\") && post.containsKey(\"addTag\")) {\n                Bookmark bm = switchboard.bookmarksDB.getBookmark(post.get(\"urlhash\"));\n                if (bm != null) {\n                    bm.addTag(post.get(\"addTag\"));\n                    prop.put(\"result\", \"1\");//success\n                } else {\n                    prop.put(\"result\", \"0\");//success\n                }\n            }\n        }\n        // return rewrite properties\n        return prop;\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        // return variable that accumulates replacements\n        final Switchboard switchboard = (Switchboard) env;\n        final boolean isAdmin=switchboard.verifyAuthentication(header);\n        final serverObjects prop = new serverObjects();\n\n        Iterator<String> it;\n        if(post != null && post.containsKey(\"tag\")){\n            it=switchboard.bookmarksDB.getBookmarksIterator(post.get(\"tag\"), isAdmin);\n        }else{\n            it=switchboard.bookmarksDB.getBookmarksIterator(isAdmin);\n        }\n\n        // if an extended xml should be used\n        final boolean extendedXML = (post != null && post.containsKey(\"extendedXML\"));\n\n        int count=0;\n        BookmarksDB.Bookmark bookmark;\n        Date date;\n        while(it.hasNext()){\n            try {\n                bookmark=switchboard.bookmarksDB.getBookmark(it.next());\n                prop.putXML(\"posts_\"+count+\"_url\", bookmark.getUrl());\n                prop.putXML(\"posts_\"+count+\"_title\", bookmark.getTitle());\n                prop.putXML(\"posts_\"+count+\"_description\", bookmark.getDescription());\n                prop.putXML(\"posts_\"+count+\"_md5\", Digest.encodeMD5Hex(bookmark.getUrl()));\n                date = new Date(bookmark.getTimeStamp());\n                prop.putXML(\"posts_\"+count+\"_time\", ISO8601Formatter.FORMATTER.format(date));\n                prop.putXML(\"posts_\"+count+\"_tags\", bookmark.getTagsString().replaceAll(\",\",\" \"));\n\n                // additional XML tags\n                prop.put(\"posts_\"+count+\"_isExtended\",extendedXML ? \"1\" : \"0\");\n                if (extendedXML) {\n                    prop.put(\"posts_\"+count+\"_isExtended_private\", Boolean.toString(!bookmark.getPublic()));\n                }\n                count++;\n            } catch (final IOException e) {\n            }\n        }\n        prop.put(\"posts\", count);\n\n        // return rewrite properties\n        return prop;\n    }","id":83917,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        // return variable that accumulates replacements\n        final Switchboard switchboard = (Switchboard) env;\n        final boolean isAdmin=switchboard.verifyAuthentication(header);\n        final serverObjects prop = new serverObjects();\n\n        Iterator<String> it;\n        if(post != null && post.containsKey(\"tag\")){\n            it=switchboard.bookmarksDB.getBookmarksIterator(post.get(\"tag\"), isAdmin);\n        }else{\n            it=switchboard.bookmarksDB.getBookmarksIterator(isAdmin);\n        }\n\n        // if an extended xml should be used\n        final boolean extendedXML = (post != null && post.containsKey(\"extendedXML\"));\n\n        int count=0;\n        Date date;\n        while(it.hasNext()){\n            BookmarksDB.Bookmark bookmark=switchboard.bookmarksDB.getBookmark(it.next());\n            if (bookmark != null) {\n                prop.putXML(\"posts_\"+count+\"_url\", bookmark.getUrl());\n                prop.putXML(\"posts_\"+count+\"_title\", bookmark.getTitle());\n                prop.putXML(\"posts_\"+count+\"_description\", bookmark.getDescription());\n                prop.putXML(\"posts_\"+count+\"_md5\", Digest.encodeMD5Hex(bookmark.getUrl()));\n                date = new Date(bookmark.getTimeStamp());\n                prop.putXML(\"posts_\"+count+\"_time\", ISO8601Formatter.FORMATTER.format(date));\n                prop.putXML(\"posts_\"+count+\"_tags\", bookmark.getTagsString().replaceAll(\",\",\" \"));\n\n                // additional XML tags\n                prop.put(\"posts_\"+count+\"_isExtended\",extendedXML ? \"1\" : \"0\");\n                if (extendedXML) {\n                    prop.put(\"posts_\"+count+\"_isExtended_private\", Boolean.toString(!bookmark.getPublic()));\n                }\n                count++;\n            }\n        }\n        prop.put(\"posts\", count);\n\n        // return rewrite properties\n        return prop;\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        // return variable that accumulates replacements\n        final Switchboard switchboard = (Switchboard) env;\n        final boolean isAdmin=switchboard.verifyAuthentication(header);\n        final serverObjects prop = new serverObjects();\n        String tag = null;\n        final String date;\n        //String url=\"\"; //urlfilter not yet implemented\n\n        if (post != null && post.containsKey(\"tag\")) {\n            tag = post.get(\"tag\");\n        }\n        if (post != null && post.containsKey(\"date\")) {\n            date = post.get(\"date\");\n        } else {\n            date = ISO8601Formatter.FORMATTER.format();\n        }\n\n        // if an extended xml should be used\n        final boolean extendedXML = (post != null && post.containsKey(\"extendedXML\"));\n\n        int count=0;\n\n        Date parsedDate = null;\n        try {\n            parsedDate = ISO8601Formatter.FORMATTER.parse(date, 0).getTime();\n        } catch (final ParseException e) {\n            parsedDate = new Date();\n        }\n\n        final List<String> bookmark_hashes = switchboard.bookmarksDB.getDate(Long.toString(parsedDate.getTime())).getBookmarkList();\n        BookmarksDB.Bookmark bookmark = null;\n        for (final String bookmark_hash : bookmark_hashes){\n            try {\n                bookmark=switchboard.bookmarksDB.getBookmark(bookmark_hash);\n                if (ISO8601Formatter.FORMATTER.format(new Date(bookmark.getTimeStamp())).equals(date) &&\n                        tag==null || bookmark.getTags().contains(tag) &&\n                        isAdmin || bookmark.getPublic()){\n                    prop.putHTML(\"posts_\"+count+\"_url\", bookmark.getUrl());\n                    prop.putHTML(\"posts_\"+count+\"_title\", bookmark.getTitle());\n                    prop.putHTML(\"posts_\"+count+\"_description\", bookmark.getDescription());\n                    prop.put(\"posts_\"+count+\"_md5\", Digest.encodeMD5Hex(bookmark.getUrl()));\n                    prop.put(\"posts_\"+count+\"_time\", date);\n                    prop.putHTML(\"posts_\"+count+\"_tags\", bookmark.getTagsString().replaceAll(\",\",\" \"));\n\n                    // additional XML tags\n                    prop.put(\"posts_\"+count+\"_isExtended\",extendedXML ? \"1\" : \"0\");\n                    if (extendedXML) {\n                        prop.put(\"posts_\"+count+\"_isExtended_private\", Boolean.toString(!bookmark.getPublic()));\n                    }\n                    count++;\n                }\n            } catch (final IOException e) {\n            }\n        }\n        prop.put(\"posts\", count);\n\n        // return rewrite properties\n        return prop;\n    }","id":83918,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        // return variable that accumulates replacements\n        final Switchboard switchboard = (Switchboard) env;\n        final boolean isAdmin=switchboard.verifyAuthentication(header);\n        final serverObjects prop = new serverObjects();\n        String tag = null;\n        final String date;\n        //String url=\"\"; //urlfilter not yet implemented\n\n        if (post != null && post.containsKey(\"tag\")) {\n            tag = post.get(\"tag\");\n        }\n        if (post != null && post.containsKey(\"date\")) {\n            date = post.get(\"date\");\n        } else {\n            date = ISO8601Formatter.FORMATTER.format();\n        }\n\n        // if an extended xml should be used\n        final boolean extendedXML = (post != null && post.containsKey(\"extendedXML\"));\n\n        int count=0;\n\n        Date parsedDate = null;\n        try {\n            parsedDate = ISO8601Formatter.FORMATTER.parse(date, 0).getTime();\n        } catch (final ParseException e) {\n            parsedDate = new Date();\n        }\n\n        final List<String> bookmark_hashes = switchboard.bookmarksDB.getDate(Long.toString(parsedDate.getTime())).getBookmarkList();\n        for (final String bookmark_hash : bookmark_hashes){\n            Bookmark bookmark = switchboard.bookmarksDB.getBookmark(bookmark_hash);\n            if (bookmark != null) {\n                if (ISO8601Formatter.FORMATTER.format(new Date(bookmark.getTimeStamp())).equals(date) &&\n                        tag==null || bookmark.getTags().contains(tag) &&\n                        isAdmin || bookmark.getPublic()){\n                    prop.putHTML(\"posts_\"+count+\"_url\", bookmark.getUrl());\n                    prop.putHTML(\"posts_\"+count+\"_title\", bookmark.getTitle());\n                    prop.putHTML(\"posts_\"+count+\"_description\", bookmark.getDescription());\n                    prop.put(\"posts_\"+count+\"_md5\", Digest.encodeMD5Hex(bookmark.getUrl()));\n                    prop.put(\"posts_\"+count+\"_time\", date);\n                    prop.putHTML(\"posts_\"+count+\"_tags\", bookmark.getTagsString().replaceAll(\",\",\" \"));\n\n                    // additional XML tags\n                    prop.put(\"posts_\"+count+\"_isExtended\",extendedXML ? \"1\" : \"0\");\n                    if (extendedXML) {\n                        prop.put(\"posts_\"+count+\"_isExtended_private\", Boolean.toString(!bookmark.getPublic()));\n                    }\n                    count++;\n                }\n            }\n        }\n        prop.put(\"posts\", count);\n\n        // return rewrite properties\n        return prop;\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static int print_XBEL(final Iterator<String> bit, int count) {\n    \tBookmarksDB.Bookmark bookmark = null;\n    \tDate date;\n    \twhile(bit.hasNext()){\n            try {\n                bookmark = sb.bookmarksDB.getBookmark(bit.next());\n                date = new Date(bookmark.getTimeStamp());\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<bookmark id=\\\"\" + bookmark.getUrlHash()\n                    + \"\\\" href=\\\"\" + CharacterCoding.unicode2xml(bookmark.getUrl(), true)\n                    + \"\\\" added=\\\"\" + CharacterCoding.unicode2xml(ISO8601Formatter.FORMATTER.format(date), true)+\"\\\">\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<title>\");\n                count++;\n                prop.putXML(\"display_xbel_\"+count+\"_elements\", bookmark.getTitle());\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<\/title>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<info>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<metadata owner=\\\"Mozilla\\\" ShortcutURL=\\\"\"\n                    + CharacterCoding.unicode2xml(bookmark.getTagsString().replaceAll(\"/.*,\", \"\").toLowerCase(), true)\n                    + \"\\\"/>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<metadata owner=\\\"YaCy\\\" public=\\\"\"+Boolean.toString(bookmark.getPublic())+\"\\\"/>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<\/info>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<desc>\");\n                count++;\n                prop.putXML(\"display_xbel_\"+count+\"_elements\", bookmark.getDescription());\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<\/desc>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<\/bookmark>\");\n                count++;\n            } catch (final IOException e) {\n            }\n        }\n    \treturn count;\n    }","id":83919,"modified_method":"private static int print_XBEL(final Iterator<String> bit, int count) {\n    \tDate date;\n    \twhile(bit.hasNext()){\n            BookmarksDB.Bookmark bookmark = sb.bookmarksDB.getBookmark(bit.next());\n            if (bookmark != null) {\n                date = new Date(bookmark.getTimeStamp());\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<bookmark id=\\\"\" + bookmark.getUrlHash()\n                    + \"\\\" href=\\\"\" + CharacterCoding.unicode2xml(bookmark.getUrl(), true)\n                    + \"\\\" added=\\\"\" + CharacterCoding.unicode2xml(ISO8601Formatter.FORMATTER.format(date), true)+\"\\\">\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<title>\");\n                count++;\n                prop.putXML(\"display_xbel_\"+count+\"_elements\", bookmark.getTitle());\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<\/title>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<info>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<metadata owner=\\\"Mozilla\\\" ShortcutURL=\\\"\"\n                    + CharacterCoding.unicode2xml(bookmark.getTagsString().replaceAll(\"/.*,\", \"\").toLowerCase(), true)\n                    + \"\\\"/>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<metadata owner=\\\"YaCy\\\" public=\\\"\"+Boolean.toString(bookmark.getPublic())+\"\\\"/>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<\/info>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<desc>\");\n                count++;\n                prop.putXML(\"display_xbel_\"+count+\"_elements\", bookmark.getDescription());\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<\/desc>\");\n                count++;\n                prop.put(\"display_xbel_\"+count+\"_elements\", \"<\/bookmark>\");\n                count++;\n            }\n        }\n    \treturn count;\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\n        prop.clear();\n        sb = (Switchboard) env;\n        user = sb.userDB.getUser(header);\n        isAdmin = (sb.verifyAuthentication(header) || user != null && user.hasRight(UserDB.AccessRight.BOOKMARK_RIGHT));\n\n        // set user name\n        final String username;\n        if(user != null) username=user.getUserName();\n        else if(isAdmin) username=\"admin\";\n        else username = \"unknown\";\n        prop.putHTML(\"display_user\", username);\n\n        // set peer address\n        prop.put(\"display_address\", sb.peers.mySeed().getPublicAddress(sb.peers.mySeed().getIP()));\n        prop.put(\"display_peer\", sb.peers.mySeed().getName());\n\n        final int itemsPerPage;         // items per page\n        final int page;                 // page\n        final int display;              // default for JSON, XML or XHTML\n        // String sortorder = \"asc\";\n        // String sortname = \"date\";\n        final String qtype;\n        final String query;\n\n        // check for GET parameters\n        if (post != null){\n            itemsPerPage = (post.containsKey(\"rp\")) ? post.getInt(\"rp\", MAXRESULTS) : MAXRESULTS;\n            page = (post.containsKey(\"page\")) ? post.getInt(\"page\", 1): 1;\n            query = (post.containsKey(\"query\")) ? post.get(\"query\", \"\") : \"\";\n            qtype = (post.containsKey(\"qtype\")) ? post.get(\"qtype\", \"\") : \"\";\n            // if (post.containsKey(\"sortorder\")) sortorder = post.get(\"sortorder\");\n            if (post.containsKey(\"display\")) {\n                final String d = post.get(\"display\");\n                if (\"flexigrid\".equals(d) || \"1\".equals(d)) {\n                    display = DisplayType.FLEXIGRID.getValue();\n                } else if (\"xbel\".equals(d) || \"2\".equals(d)) {\n                    display = DisplayType.XBEL.getValue();\n                } else if (\"rss\".equals(d) || \"3\".equals(d)) {\n                    display = DisplayType.RSS.getValue();\n                } else {\n                    display = DisplayType.XML.getValue();\n                }\n            } else {\n                display = DisplayType.XML.getValue();\n            }\n            prop.put(\"display\", display);\n        } else {\n            query = \"\";\n            qtype = \"\";\n            page = 1;\n            itemsPerPage = MAXRESULTS;\n            display = DisplayType.XML.getValue();\n        }\n\n        int count = 0;\n        int total = 0;\n        int start = 0;\n\n        final Iterator<String> it;\n\n        if (display == DisplayType.XBEL.getValue()) {\n            String root = \"/\";\n            if (\"tags\".equals(qtype) && !\"\".equals(query)) {\n                prop.putHTML(\"display_folder\", \"1\");\n                prop.putHTML(\"display_folder_foldername\", query);\n                prop.putHTML(\"display_folder_folderhash\", BookmarkHelper.tagHash(query));\n                it = sb.bookmarksDB.getBookmarksIterator(query, isAdmin);\n                count = print_XBEL(it, count);\n                prop.put(\"display_xbel\", count);\n            } else if (query.length() > 0 && \"folders\".equals(qtype)) {\n                root = (query.charAt(0) == '/') ? query : \"/\" + query;\n            }\n            prop.putHTML(\"display_folder\", \"0\");\n            R = root.replaceAll(\"[^/]\",\"\").length() - 1;\n            count = recurseFolders(BookmarkHelper.getFolderList(root, sb.bookmarksDB.getTagIterator(isAdmin)),root,0,true,\"\");\n            prop.put(\"display_xbel\", count);\n        } else {\n            // covers all non XBEL formats\n\n            // set bookmark iterator according to query\n            if (\"tags\".equals(qtype) && !\"\".equals(query) && !\"/\".equals(query)) {\n                it = sb.bookmarksDB.getBookmarksIterator(query, isAdmin);\n            } else {\n                it = sb.bookmarksDB.getBookmarksIterator(isAdmin);\n            }\n\n            if (itemsPerPage < MAXRESULTS) {\n                //skip the first entries (display next page)\n                if (page > 1) {\n                    start = ((page - 1) * itemsPerPage) + 1;\n                }\n                count = 0;\n                while (count < start && it.hasNext()) {\n                    it.next();\n                    count++;\n                }\n                total += count;\n            }\n            count = 0;\n            BookmarksDB.Bookmark bookmark = null;\n            while (count < itemsPerPage && it.hasNext()) {\n                try {\n                    bookmark = sb.bookmarksDB.getBookmark(it.next());\n                    if (bookmark != null) {\n                        prop.put(\"display_bookmarks_\"+count+\"_id\",count);\n                        prop.put(\"display_bookmarks_\"+count+\"_link\",bookmark.getUrl());\n                        prop.put(\"display_bookmarks_\"+count+\"_date\", ISO8601Formatter.FORMATTER.format(new Date(bookmark.getTimeStamp())));\n                        prop.put(\"display_bookmarks_\"+count+\"_rfc822date\", HeaderFramework.formatRFC1123(new Date(bookmark.getTimeStamp())));\n                        prop.put(\"display_bookmarks_\"+count+\"_public\", (bookmark.getPublic() ? \"0\" : \"1\"));\n                        prop.put(\"display_bookmarks_\"+count+\"_hash\", bookmark.getUrlHash());\n                        prop.put(\"display_bookmarks_\"+count+\"_comma\", \",\");\n\n                        // offer HTML encoded\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_title-html\", bookmark.getTitle());\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_desc-html\", bookmark.getDescription());\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_tags-html\", bookmark.getTagsString().replaceAll(\",\", \", \"));\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_folders-html\", (bookmark.getFoldersString()));\n\n                        // XML encoded\n                        prop.putXML(\"display_bookmarks_\"+count+\"_title-xml\", bookmark.getTitle());\n                        prop.putXML(\"display_bookmarks_\"+count+\"_desc-xml\", bookmark.getDescription());\n                        prop.putXML(\"display_bookmarks_\"+count+\"_tags-xml\", bookmark.getTagsString());\n                        prop.putXML(\"display_bookmarks_\"+count+\"_folders-xml\", (bookmark.getFoldersString()));\n\n                        // and plain text (potentially unsecure)\n                        prop.put(\"display_bookmarks_\"+count+\"_title\", bookmark.getTitle());\n                        prop.put(\"display_bookmarks_\"+count+\"_desc\", bookmark.getDescription());\n                        prop.put(\"display_bookmarks_\"+count+\"_tags\", bookmark.getTagsString());\n                        prop.put(\"display_bookmarks_\"+count+\"_folders\", (bookmark.getFoldersString()));\n\n                        count++;\n                    }\n                } catch (final IOException e) {\n                }\n            }\n            // eliminate the trailing comma for Json output\n\n            prop.put(\"display_bookmarks_\" + (itemsPerPage - 1) + \"_comma\", \"\");\n            prop.put(\"display_bookmarks\", count);\n\n            while(it.hasNext()){\n                it.next();\n                count++;\n            }\n            total += count;\n            prop.put(\"display_page\", page);\n            prop.put(\"display_total\", total);\n        }\n\n        // return rewrite properties\n        return prop;\n    }","id":83920,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\n        prop.clear();\n        sb = (Switchboard) env;\n        user = sb.userDB.getUser(header);\n        isAdmin = (sb.verifyAuthentication(header) || user != null && user.hasRight(UserDB.AccessRight.BOOKMARK_RIGHT));\n\n        // set user name\n        final String username;\n        if(user != null) username=user.getUserName();\n        else if(isAdmin) username=\"admin\";\n        else username = \"unknown\";\n        prop.putHTML(\"display_user\", username);\n\n        // set peer address\n        prop.put(\"display_address\", sb.peers.mySeed().getPublicAddress(sb.peers.mySeed().getIP()));\n        prop.put(\"display_peer\", sb.peers.mySeed().getName());\n\n        final int itemsPerPage;         // items per page\n        final int page;                 // page\n        final int display;              // default for JSON, XML or XHTML\n        // String sortorder = \"asc\";\n        // String sortname = \"date\";\n        final String qtype;\n        final String query;\n\n        // check for GET parameters\n        if (post != null){\n            itemsPerPage = (post.containsKey(\"rp\")) ? post.getInt(\"rp\", MAXRESULTS) : MAXRESULTS;\n            page = (post.containsKey(\"page\")) ? post.getInt(\"page\", 1): 1;\n            query = (post.containsKey(\"query\")) ? post.get(\"query\", \"\") : \"\";\n            qtype = (post.containsKey(\"qtype\")) ? post.get(\"qtype\", \"\") : \"\";\n            // if (post.containsKey(\"sortorder\")) sortorder = post.get(\"sortorder\");\n            if (post.containsKey(\"display\")) {\n                final String d = post.get(\"display\");\n                if (\"flexigrid\".equals(d) || \"1\".equals(d)) {\n                    display = DisplayType.FLEXIGRID.getValue();\n                } else if (\"xbel\".equals(d) || \"2\".equals(d)) {\n                    display = DisplayType.XBEL.getValue();\n                } else if (\"rss\".equals(d) || \"3\".equals(d)) {\n                    display = DisplayType.RSS.getValue();\n                } else {\n                    display = DisplayType.XML.getValue();\n                }\n            } else {\n                display = DisplayType.XML.getValue();\n            }\n            prop.put(\"display\", display);\n        } else {\n            query = \"\";\n            qtype = \"\";\n            page = 1;\n            itemsPerPage = MAXRESULTS;\n            display = DisplayType.XML.getValue();\n        }\n\n        int count = 0;\n        int total = 0;\n        int start = 0;\n\n        final Iterator<String> it;\n\n        if (display == DisplayType.XBEL.getValue()) {\n            String root = \"/\";\n            if (\"tags\".equals(qtype) && !\"\".equals(query)) {\n                prop.putHTML(\"display_folder\", \"1\");\n                prop.putHTML(\"display_folder_foldername\", query);\n                prop.putHTML(\"display_folder_folderhash\", BookmarkHelper.tagHash(query));\n                it = sb.bookmarksDB.getBookmarksIterator(query, isAdmin);\n                count = print_XBEL(it, count);\n                prop.put(\"display_xbel\", count);\n            } else if (query.length() > 0 && \"folders\".equals(qtype)) {\n                root = (query.charAt(0) == '/') ? query : \"/\" + query;\n            }\n            prop.putHTML(\"display_folder\", \"0\");\n            R = root.replaceAll(\"[^/]\",\"\").length() - 1;\n            count = recurseFolders(BookmarkHelper.getFolderList(root, sb.bookmarksDB.getTagIterator(isAdmin)),root,0,true,\"\");\n            prop.put(\"display_xbel\", count);\n        } else {\n            // covers all non XBEL formats\n\n            // set bookmark iterator according to query\n            if (\"tags\".equals(qtype) && !\"\".equals(query) && !\"/\".equals(query)) {\n                it = sb.bookmarksDB.getBookmarksIterator(query, isAdmin);\n            } else {\n                it = sb.bookmarksDB.getBookmarksIterator(isAdmin);\n            }\n\n            if (itemsPerPage < MAXRESULTS) {\n                //skip the first entries (display next page)\n                if (page > 1) {\n                    start = ((page - 1) * itemsPerPage) + 1;\n                }\n                count = 0;\n                while (count < start && it.hasNext()) {\n                    it.next();\n                    count++;\n                }\n                total += count;\n            }\n            count = 0;\n            while (count < itemsPerPage && it.hasNext()) {\n           \n                    BookmarksDB.Bookmark bookmark = sb.bookmarksDB.getBookmark(it.next());\n                    if (bookmark != null) {\n                        prop.put(\"display_bookmarks_\"+count+\"_id\",count);\n                        prop.put(\"display_bookmarks_\"+count+\"_link\",bookmark.getUrl());\n                        prop.put(\"display_bookmarks_\"+count+\"_date\", ISO8601Formatter.FORMATTER.format(new Date(bookmark.getTimeStamp())));\n                        prop.put(\"display_bookmarks_\"+count+\"_rfc822date\", HeaderFramework.formatRFC1123(new Date(bookmark.getTimeStamp())));\n                        prop.put(\"display_bookmarks_\"+count+\"_public\", (bookmark.getPublic() ? \"0\" : \"1\"));\n                        prop.put(\"display_bookmarks_\"+count+\"_hash\", bookmark.getUrlHash());\n                        prop.put(\"display_bookmarks_\"+count+\"_comma\", \",\");\n\n                        // offer HTML encoded\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_title-html\", bookmark.getTitle());\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_desc-html\", bookmark.getDescription());\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_tags-html\", bookmark.getTagsString().replaceAll(\",\", \", \"));\n                        prop.putHTML(\"display_bookmarks_\"+count+\"_folders-html\", (bookmark.getFoldersString()));\n\n                        // XML encoded\n                        prop.putXML(\"display_bookmarks_\"+count+\"_title-xml\", bookmark.getTitle());\n                        prop.putXML(\"display_bookmarks_\"+count+\"_desc-xml\", bookmark.getDescription());\n                        prop.putXML(\"display_bookmarks_\"+count+\"_tags-xml\", bookmark.getTagsString());\n                        prop.putXML(\"display_bookmarks_\"+count+\"_folders-xml\", (bookmark.getFoldersString()));\n\n                        // and plain text (potentially unsecure)\n                        prop.put(\"display_bookmarks_\"+count+\"_title\", bookmark.getTitle());\n                        prop.put(\"display_bookmarks_\"+count+\"_desc\", bookmark.getDescription());\n                        prop.put(\"display_bookmarks_\"+count+\"_tags\", bookmark.getTagsString());\n                        prop.put(\"display_bookmarks_\"+count+\"_folders\", (bookmark.getFoldersString()));\n\n                        count++;\n                    }\n            }\n            // eliminate the trailing comma for Json output\n\n            prop.put(\"display_bookmarks_\" + (itemsPerPage - 1) + \"_comma\", \"\");\n            prop.put(\"display_bookmarks\", count);\n\n            while(it.hasNext()){\n                it.next();\n                count++;\n            }\n            total += count;\n            prop.put(\"display_page\", page);\n            prop.put(\"display_total\", total);\n        }\n\n        // return rewrite properties\n        return prop;\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\n\t\tprop.clear();\n    \tsb = (Switchboard) env;\n    \tuser = sb.userDB.getUser(header);\n    \tisAdmin = (sb.verifyAuthentication(header) || user != null && user.hasRight(UserDB.AccessRight.BOOKMARK_RIGHT));\n\n    \t// set user name\n    \tfinal String username;\n    \tif(user != null) username=user.getUserName();\n    \telse if(isAdmin) username=\"admin\";\n    \telse username = \"unknown\";\n    \tprop.putHTML(\"display_user\", username);\n\n    \t// set peer address\n    \tprop.put(\"display_address\", sb.peers.mySeed().getPublicAddress(sb.peers.mySeed().getIP()));\n    \tprop.put(\"display_peer\", sb.peers.mySeed().getName());\n\n    \tString root = \"/\";\n    \tString[] foldername = null;\n\n    \t// check for GET parameters\n    \tif (post != null){\n    \t\tif (post.containsKey(\"root\")) {\n        \t\tif (post.get(\"root\").equals(\"source\") || post.get(\"root\").equals(\"\")) root = \"/\";\n        \t\telse if (post.get(\"root\").startsWith(\"/\")) root = post.get(\"root\");\n    \t\t\telse root = \"/\" + post.get(\"root\");\n    \t\t}\n    \t}\n\n    \tIterator<String> it = null;\n\n    \t// loop through folderList\n    \tit = BookmarkHelper.getFolderList(root, sb.bookmarksDB.getTagIterator(isAdmin));\n    \tint n = CommonPattern.SLASH.split(root, 0).length;\n    \tif (n == 0) n = 1;\n    \tint count = 0;\n    \twhile (it.hasNext()) {\n    \t\tfinal String folder = it.next();\n    \t\tfoldername = CommonPattern.SLASH.split(folder, 0);\n    \t\tif (foldername.length == n+1) {\n\t    \t\tprop.put(\"folders_\"+count+\"_foldername\", foldername[n]);\n\t    \t\tprop.put(\"folders_\"+count+\"_expanded\", \"false\");\n\t    \t\tprop.put(\"folders_\"+count+\"_type\", \"folder\");\n\t    \t\tprop.put(\"folders_\"+count+\"_hash\", folder);\t\t\t\t//TODO: switch from pathString to folderHash\n\t    \t\tprop.put(\"folders_\"+count+\"_url\", \"\");\t\t\t\t\t//TODO: insert folder url\n\t    \t\tprop.put(\"folders_\"+count+\"_hasChildren\", \"true\");\t\t//TODO: determine if folder has children\n\t    \t\tprop.put(\"folders_\"+count+\"_comma\", \",\");\n\t    \t\tcount++;\n    \t\t}\n    \t}\n\n    \t// loop through bookmarkList\n    \tit = sb.bookmarksDB.getBookmarksIterator(root, isAdmin);\n    \tBookmarksDB.Bookmark bm;\n    \twhile (it.hasNext()) {\n    \t\ttry {\n                bm = sb.bookmarksDB.getBookmark(it.next());\n                // TODO: get rid of bmtype\n                if (post.containsKey(\"bmtype\")) {\n                    if (post.get(\"bmtype\").equals(\"title\")) {\n                        prop.put(\"folders_\"+count+\"_foldername\", bm.getTitle());\n                    } else if (post.get(\"bmtype\").equals(\"href\")) {\n                        prop.put(\"folders_\"+count+\"_foldername\", \"<a href='\"+bm.getUrl()+\" 'target='_blank'>\"+bm.getTitle()+\"<\/a>\");\n                    } else {\n                        prop.put(\"folders_\"+count+\"_foldername\", bm.getUrl());\n                    }\n                }\n                prop.put(\"folders_\"+count+\"_expanded\", \"false\");\n                prop.put(\"folders_\"+count+\"_url\", bm.getUrl());\n                prop.put(\"folders_\"+count+\"_type\", \"file\");\n                prop.put(\"folders_\"+count+\"_hash\", bm.getUrlHash());\n                prop.put(\"folders_\"+count+\"_hasChildren\", \"false\");\n                prop.put(\"folders_\"+count+\"_comma\", \",\");\n                count++;\n            } catch (final IOException e) {\n            }\n    \t}\n\n    \tcount--;\n    \tprop.put(\"folders_\"+count+\"_comma\", \"\");\n    \tcount++;\n    \tprop.put(\"folders\", count);\n\n        // return rewrite properties\n        return prop;\n\t}","id":83921,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n\n\t\tprop.clear();\n    \tsb = (Switchboard) env;\n    \tuser = sb.userDB.getUser(header);\n    \tisAdmin = (sb.verifyAuthentication(header) || user != null && user.hasRight(UserDB.AccessRight.BOOKMARK_RIGHT));\n\n    \t// set user name\n    \tfinal String username;\n    \tif(user != null) username=user.getUserName();\n    \telse if(isAdmin) username=\"admin\";\n    \telse username = \"unknown\";\n    \tprop.putHTML(\"display_user\", username);\n\n    \t// set peer address\n    \tprop.put(\"display_address\", sb.peers.mySeed().getPublicAddress(sb.peers.mySeed().getIP()));\n    \tprop.put(\"display_peer\", sb.peers.mySeed().getName());\n\n    \tString root = \"/\";\n    \tString[] foldername = null;\n\n    \t// check for GET parameters\n    \tif (post != null){\n    \t\tif (post.containsKey(\"root\")) {\n        \t\tif (post.get(\"root\").equals(\"source\") || post.get(\"root\").equals(\"\")) root = \"/\";\n        \t\telse if (post.get(\"root\").startsWith(\"/\")) root = post.get(\"root\");\n    \t\t\telse root = \"/\" + post.get(\"root\");\n    \t\t}\n    \t}\n\n    \tIterator<String> it = null;\n\n    \t// loop through folderList\n    \tit = BookmarkHelper.getFolderList(root, sb.bookmarksDB.getTagIterator(isAdmin));\n    \tint n = CommonPattern.SLASH.split(root, 0).length;\n    \tif (n == 0) n = 1;\n    \tint count = 0;\n    \twhile (it.hasNext()) {\n    \t\tfinal String folder = it.next();\n    \t\tfoldername = CommonPattern.SLASH.split(folder, 0);\n    \t\tif (foldername.length == n+1) {\n\t    \t\tprop.put(\"folders_\"+count+\"_foldername\", foldername[n]);\n\t    \t\tprop.put(\"folders_\"+count+\"_expanded\", \"false\");\n\t    \t\tprop.put(\"folders_\"+count+\"_type\", \"folder\");\n\t    \t\tprop.put(\"folders_\"+count+\"_hash\", folder);\t\t\t\t//TODO: switch from pathString to folderHash\n\t    \t\tprop.put(\"folders_\"+count+\"_url\", \"\");\t\t\t\t\t//TODO: insert folder url\n\t    \t\tprop.put(\"folders_\"+count+\"_hasChildren\", \"true\");\t\t//TODO: determine if folder has children\n\t    \t\tprop.put(\"folders_\"+count+\"_comma\", \",\");\n\t    \t\tcount++;\n    \t\t}\n    \t}\n\n    \t// loop through bookmarkList\n    \tit = sb.bookmarksDB.getBookmarksIterator(root, isAdmin);\n    \twhile (it.hasNext()) {\n            BookmarksDB.Bookmark bm = sb.bookmarksDB.getBookmark(it.next());\n            if (bm != null) {\n                // TODO: get rid of bmtype\n                if (post.containsKey(\"bmtype\")) {\n                    if (post.get(\"bmtype\").equals(\"title\")) {\n                        prop.put(\"folders_\"+count+\"_foldername\", bm.getTitle());\n                    } else if (post.get(\"bmtype\").equals(\"href\")) {\n                        prop.put(\"folders_\"+count+\"_foldername\", \"<a href='\"+bm.getUrl()+\" 'target='_blank'>\"+bm.getTitle()+\"<\/a>\");\n                    } else {\n                        prop.put(\"folders_\"+count+\"_foldername\", bm.getUrl());\n                    }\n                }\n                prop.put(\"folders_\"+count+\"_expanded\", \"false\");\n                prop.put(\"folders_\"+count+\"_url\", bm.getUrl());\n                prop.put(\"folders_\"+count+\"_type\", \"file\");\n                prop.put(\"folders_\"+count+\"_hash\", bm.getUrlHash());\n                prop.put(\"folders_\"+count+\"_hasChildren\", \"false\");\n                prop.put(\"folders_\"+count+\"_comma\", \",\");\n                count++;\n            }\n    \t}\n\n    \tcount--;\n    \tprop.put(\"folders_\"+count+\"_comma\", \"\");\n    \tcount++;\n    \tprop.put(\"folders\", count);\n\n        // return rewrite properties\n        return prop;\n\t}","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        final UserDB.Entry user = sb.userDB.getUser(header);\n        final boolean isAdmin = (sb.verifyAuthentication(header));\n        final boolean isAuthUser = user!= null && user.hasRight(UserDB.AccessRight.BOOKMARK_RIGHT);\n        final int queueSize = 200;\n\n        YMarkEntry bmk;\n        // String root = YMarkEntry.FOLDERS_IMPORTED;\n        String root = \"\";\n        ByteArrayInputStream stream = null;\n\n        if(isAdmin || isAuthUser) {\n        \tString bmk_user = (isAuthUser ? user.getUserName() : YMarkTables.USER_ADMIN);\n        \tfinal ArrayBlockingQueue<String> autoTaggingQueue = new ArrayBlockingQueue<String>(10*queueSize);\n            boolean autotag = false;\n        \tboolean merge = false;\n        \tboolean empty = false;\n        \tfinal String indexing = post.get(\"indexing\", \"off\");\n        \tfinal boolean medialink = post.getBoolean(\"medialink\");\n\n        \tif(post.containsKey(\"autotag\") && !post.get(\"autotag\", \"off\").equals(\"off\")) {\n        \t\tautotag = true;\n        \t\tif(post.get(\"autotag\").equals(\"merge\")) {\n                \tmerge = true;\n                }\n                if(post.get(\"autotag\").equals(\"empty\")) {\n                \tempty = true;\n                }\n                YMarkAutoTagger autoTagger = new YMarkAutoTagger(autoTaggingQueue, sb.loader, sb.tables.bookmarks, bmk_user, merge);\n                InstantBusyThread.oneTimeJob(autoTagger, 0);\n        \t}\n\n            if(isAdmin && post.containsKey(\"table\") && post.get(\"table\").length() > 0) {\n        \t\tbmk_user = post.get(\"table\").substring(0, post.get(\"table\").indexOf('_',0));\n        \t}\n            if(post.containsKey(\"redirect\") && post.get(\"redirect\").length() > 0) {\n                prop.put(\"redirect_url\", post.get(\"redirect\"));\n                prop.put(\"redirect\", \"1\");\n            }\n            if(post.containsKey(\"root\") && post.get(\"root\").length() > 0) {\n                root = post.get(\"root\");\n            }\n            ClientIdentification.Agent agent = ClientIdentification.getAgent(post.get(\"agentName\", ClientIdentification.yacyInternetCrawlerAgentName));\n        \tif(post.containsKey(\"bmkfile\") && !post.get(\"bmkfile\").isEmpty() && post.containsKey(\"importer\")){\n        \t\tfinal byte[] bytes = UTF8.getBytes(post.get(\"bmkfile$file\"));\n        \t\tstream = new ByteArrayInputStream(bytes);\n        \t\tif(post.get(\"importer\").equals(\"surro\") && stream != null) {\n                    SurrogateReader surrogateReader;\n                    try {\n                        surrogateReader = new SurrogateReader(stream, queueSize);\n                    } catch (final IOException e) {\n                        //TODO: display an error message\n                        ConcurrentLog.logException(e);\n                        prop.put(\"status\", \"0\");\n                        return prop;\n                    }\n                    InstantBusyThread.oneTimeJob(surrogateReader, 0);\n                    while ((bmk = new YMarkEntry(surrogateReader.take())) != YMarkEntry.POISON) {\n                        putBookmark(sb, bmk_user, bmk, autoTaggingQueue, autotag, empty, indexing, medialink);\n                    }\n                    prop.put(\"status\", \"1\");\n                } else {\n                    MonitoredReader reader = null;\n                    try {\n                        reader = new MonitoredReader(new InputStreamReader(stream,\"UTF-8\"), 1024*16, bytes.length);\n                    } catch (final UnsupportedEncodingException e1) {\n                        //TODO: display an error message\n                        ConcurrentLog.logException(e1);\n                        prop.put(\"status\", \"0\");\n                        return prop;\n                    }\n                    if(post.get(\"importer\").equals(\"html\") && reader != null) {\n                        final YMarkHTMLImporter htmlImporter = new YMarkHTMLImporter(reader, queueSize, root);\n                        InstantBusyThread.oneTimeJob(htmlImporter, 0);\n                        InstantBusyThread.oneTimeJob(htmlImporter.getConsumer(sb, bmk_user, autoTaggingQueue, autotag, empty, indexing, medialink), 0);\n                        prop.put(\"status\", \"1\");\n                    } else if(post.get(\"importer\").equals(\"xbel\") && reader != null) {\n                        final YMarkXBELImporter xbelImporter;\n                        try {\n                            //TODO: make RootFold\n                            xbelImporter = new YMarkXBELImporter(reader, queueSize, root);\n                        } catch (final SAXException e) {\n                            //TODO: display an error message\n                            ConcurrentLog.logException(e);\n                            prop.put(\"status\", \"0\");\n                            return prop;\n                        }\n                        InstantBusyThread.oneTimeJob(xbelImporter, 0);\n                        InstantBusyThread.oneTimeJob(xbelImporter.getConsumer(sb, bmk_user, autoTaggingQueue, autotag, empty, indexing, medialink), 0);\n                        prop.put(\"status\", \"1\");\n                    } else if(post.get(\"importer\").equals(\"json\") && reader != null) {\n                        YMarkJSONImporter jsonImporter;\n                        jsonImporter = new YMarkJSONImporter(reader, queueSize, root);\n                        InstantBusyThread.oneTimeJob(jsonImporter, 0);\n                        while ((bmk = jsonImporter.take()) != YMarkEntry.POISON) {\n                        \tputBookmark(sb, bmk_user, bmk, autoTaggingQueue, autotag, empty, indexing, medialink);\n                        }\n                        prop.put(\"status\", \"1\");\n                    }\n                }\n        \t} else if(post.containsKey(\"importer\") && post.get(\"importer\").equals(\"crawls\")) {\n        \t\tif(!isAdmin) {\n        \t\t\tprop.authenticationRequired();\n        \t\t\treturn prop;\n        \t\t}\n        \t\ttry {\n\t    \t\t\tfinal Pattern pattern = Pattern.compile(\"^crawl start for.*\");\n\t\t\t\t\tfinal Iterator<Tables.Row> APIcalls = sb.tables.iterator(WorkTables.TABLE_API_NAME, WorkTables.TABLE_API_COL_COMMENT, pattern);\n\t    \t\t\tTables.Row row = null;\n\t    \t\t\twhile(APIcalls.hasNext()) {\n\t    \t\t\t\trow = APIcalls.next();\n\t    \t\t\t\tif(row.get(WorkTables.TABLE_API_COL_TYPE, \"\").equals(\"crawler\")) {\n\t    \t\t\t\t\tfinal String url = row.get(WorkTables.TABLE_API_COL_COMMENT, \"\").substring(16);\n\t    \t\t\t\t\tsb.tables.bookmarks.createBookmark(sb.loader, url, agent, bmk_user, autotag, \"crawlStart\", \"/Crawl Start\");\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\tprop.put(\"status\", \"1\");\n\t\t\t\t} catch (final IOException e) {\n\t\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\t} catch (final Failure e) {\n\t\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\t}\n        \t} else if(post.containsKey(\"importer\") && post.get(\"importer\").equals(\"bmks\")) {\n        \t\tif(!isAdmin) {\n        \t\t\tprop.authenticationRequired();\n        \t\t\treturn prop;\n        \t\t}\n        \t\tfinal Iterator<String> bit=sb.bookmarksDB.getBookmarksIterator(isAdmin);\n            \tBookmarksDB.Bookmark bookmark;\n            \twhile(bit.hasNext()){\n        \t\t\ttry {\n                        bookmark=sb.bookmarksDB.getBookmark(bit.next());\n                        final YMarkEntry bmk_entry = new YMarkEntry(false);\n                        bmk_entry.put(YMarkEntry.BOOKMARK.URL.key(), bookmark.getUrl());\n                        try {\n                            if(!sb.tables.has(YMarkTables.TABLES.BOOKMARKS.tablename(bmk_user), YMarkUtil.getBookmarkId(bookmark.getUrl()))) {\n                                bmk_entry.put(YMarkEntry.BOOKMARK.PUBLIC.key(), bookmark.getPublic() ? \"true\" : \"false\");\n                                bmk_entry.put(YMarkEntry.BOOKMARK.TITLE.key(), bookmark.getTitle());\n                                bmk_entry.put(YMarkEntry.BOOKMARK.DESC.key(), bookmark.getDescription());\n                                bmk_entry.put(YMarkEntry.BOOKMARK.TAGS.key(), bookmark.getTagsString());\n                                bmk_entry.put(YMarkEntry.BOOKMARK.FOLDERS.key(), root+bookmark.getFoldersString().replaceAll(\".*\"+YMarkUtil.TAGS_SEPARATOR+YMarkUtil.FOLDERS_SEPARATOR, root+YMarkUtil.FOLDERS_SEPARATOR));\n                            }\n                            if(autotag) {\n                                bmk_entry.put(YMarkEntry.BOOKMARK.TAGS.key(), YMarkAutoTagger.autoTag(bookmark.getUrl(), sb.loader, agent, 3, sb.tables.bookmarks.getTags(bmk_user)));\n                            }\n                            sb.tables.bookmarks.addBookmark(bmk_user, bmk_entry, merge, true);\n                            prop.put(\"status\", \"1\");\n                        } catch (final MalformedURLException e) {\n                            ConcurrentLog.logException(e);\n                        } catch (final IOException e) {\n                            ConcurrentLog.logException(e);\n                        }\n                    } catch (final IOException e1) {\n                    }\n            \t}\n            } else if(post.containsKey(\"importer\") && post.get(\"importer\").equals(\"dmoz\")) {\n        \t\tif(!isAdmin) {\n        \t\t\tprop.authenticationRequired();\n        \t\t\treturn prop;\n        \t\t}\n        \t\ttry {\n        \t\t\tfinal File in = new File(sb.workPath, \"content.rdf.u8.gz\");\n        \t\t\tfinal InputStream gzip = new FileInputStream(in);\n        \t\t\tfinal InputStream content = new GZIPInputStream(gzip);\n        \t\t\tfinal InputStreamReader reader = new InputStreamReader(content, \"UTF-8\");\n        \t\t\tfinal BufferedReader breader = new BufferedReader(reader);\n        \t\t\tfinal MonitoredReader mreader = new MonitoredReader(breader, 1024*1024, in.length());\n\n        \t\t\tfinal String source = post.get(\"source\", \"\");\n        \t\t\tfinal YMarkDMOZImporter DMOZImporter = new YMarkDMOZImporter(mreader, queueSize, root, source);\n\n        \t\t\tmreader.addChangeListener(sb.tables.bookmarks.getProgressListener(\"DMOZImporter\"));\n        \t\t\tDMOZImporter.setDepth(6);\n        \t\t\tInstantBusyThread.oneTimeJob(DMOZImporter, 0);\n        \t\t\tInstantBusyThread.oneTimeJob(DMOZImporter.getConsumer(sb, bmk_user, autoTaggingQueue, autotag, empty, indexing, medialink), 0);\n\n        \t\t\tprop.put(\"status\", \"1\");\n\t\t\t\t} catch (final Exception e) {\n\t\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\t}\n            }\n        }  else {\n        \tprop.put(serverObjects.ACTION_AUTHENTICATE, YMarkTables.USER_AUTHENTICATE_MSG);\n        }\n        // return rewrite properties\n        return prop;\n\t}","id":83922,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        final UserDB.Entry user = sb.userDB.getUser(header);\n        final boolean isAdmin = (sb.verifyAuthentication(header));\n        final boolean isAuthUser = user!= null && user.hasRight(UserDB.AccessRight.BOOKMARK_RIGHT);\n        final int queueSize = 200;\n\n        YMarkEntry bmk;\n        // String root = YMarkEntry.FOLDERS_IMPORTED;\n        String root = \"\";\n        ByteArrayInputStream stream = null;\n\n        if(isAdmin || isAuthUser) {\n        \tString bmk_user = (isAuthUser ? user.getUserName() : YMarkTables.USER_ADMIN);\n        \tfinal ArrayBlockingQueue<String> autoTaggingQueue = new ArrayBlockingQueue<String>(10*queueSize);\n            boolean autotag = false;\n        \tboolean merge = false;\n        \tboolean empty = false;\n        \tfinal String indexing = post.get(\"indexing\", \"off\");\n        \tfinal boolean medialink = post.getBoolean(\"medialink\");\n\n        \tif(post.containsKey(\"autotag\") && !post.get(\"autotag\", \"off\").equals(\"off\")) {\n        \t\tautotag = true;\n        \t\tif(post.get(\"autotag\").equals(\"merge\")) {\n                \tmerge = true;\n                }\n                if(post.get(\"autotag\").equals(\"empty\")) {\n                \tempty = true;\n                }\n                YMarkAutoTagger autoTagger = new YMarkAutoTagger(autoTaggingQueue, sb.loader, sb.tables.bookmarks, bmk_user, merge);\n                InstantBusyThread.oneTimeJob(autoTagger, 0);\n        \t}\n\n            if(isAdmin && post.containsKey(\"table\") && post.get(\"table\").length() > 0) {\n        \t\tbmk_user = post.get(\"table\").substring(0, post.get(\"table\").indexOf('_',0));\n        \t}\n            if(post.containsKey(\"redirect\") && post.get(\"redirect\").length() > 0) {\n                prop.put(\"redirect_url\", post.get(\"redirect\"));\n                prop.put(\"redirect\", \"1\");\n            }\n            if(post.containsKey(\"root\") && post.get(\"root\").length() > 0) {\n                root = post.get(\"root\");\n            }\n            ClientIdentification.Agent agent = ClientIdentification.getAgent(post.get(\"agentName\", ClientIdentification.yacyInternetCrawlerAgentName));\n        \tif(post.containsKey(\"bmkfile\") && !post.get(\"bmkfile\").isEmpty() && post.containsKey(\"importer\")){\n        \t\tfinal byte[] bytes = UTF8.getBytes(post.get(\"bmkfile$file\"));\n        \t\tstream = new ByteArrayInputStream(bytes);\n        \t\tif(post.get(\"importer\").equals(\"surro\") && stream != null) {\n                    SurrogateReader surrogateReader;\n                    try {\n                        surrogateReader = new SurrogateReader(stream, queueSize);\n                    } catch (final IOException e) {\n                        //TODO: display an error message\n                        ConcurrentLog.logException(e);\n                        prop.put(\"status\", \"0\");\n                        return prop;\n                    }\n                    InstantBusyThread.oneTimeJob(surrogateReader, 0);\n                    while ((bmk = new YMarkEntry(surrogateReader.take())) != YMarkEntry.POISON) {\n                        putBookmark(sb, bmk_user, bmk, autoTaggingQueue, autotag, empty, indexing, medialink);\n                    }\n                    prop.put(\"status\", \"1\");\n                } else {\n                    MonitoredReader reader = null;\n                    try {\n                        reader = new MonitoredReader(new InputStreamReader(stream,\"UTF-8\"), 1024*16, bytes.length);\n                    } catch (final UnsupportedEncodingException e1) {\n                        //TODO: display an error message\n                        ConcurrentLog.logException(e1);\n                        prop.put(\"status\", \"0\");\n                        return prop;\n                    }\n                    if(post.get(\"importer\").equals(\"html\") && reader != null) {\n                        final YMarkHTMLImporter htmlImporter = new YMarkHTMLImporter(reader, queueSize, root);\n                        InstantBusyThread.oneTimeJob(htmlImporter, 0);\n                        InstantBusyThread.oneTimeJob(htmlImporter.getConsumer(sb, bmk_user, autoTaggingQueue, autotag, empty, indexing, medialink), 0);\n                        prop.put(\"status\", \"1\");\n                    } else if(post.get(\"importer\").equals(\"xbel\") && reader != null) {\n                        final YMarkXBELImporter xbelImporter;\n                        try {\n                            //TODO: make RootFold\n                            xbelImporter = new YMarkXBELImporter(reader, queueSize, root);\n                        } catch (final SAXException e) {\n                            //TODO: display an error message\n                            ConcurrentLog.logException(e);\n                            prop.put(\"status\", \"0\");\n                            return prop;\n                        }\n                        InstantBusyThread.oneTimeJob(xbelImporter, 0);\n                        InstantBusyThread.oneTimeJob(xbelImporter.getConsumer(sb, bmk_user, autoTaggingQueue, autotag, empty, indexing, medialink), 0);\n                        prop.put(\"status\", \"1\");\n                    } else if(post.get(\"importer\").equals(\"json\") && reader != null) {\n                        YMarkJSONImporter jsonImporter;\n                        jsonImporter = new YMarkJSONImporter(reader, queueSize, root);\n                        InstantBusyThread.oneTimeJob(jsonImporter, 0);\n                        while ((bmk = jsonImporter.take()) != YMarkEntry.POISON) {\n                        \tputBookmark(sb, bmk_user, bmk, autoTaggingQueue, autotag, empty, indexing, medialink);\n                        }\n                        prop.put(\"status\", \"1\");\n                    }\n                }\n        \t} else if(post.containsKey(\"importer\") && post.get(\"importer\").equals(\"crawls\")) {\n        \t\tif(!isAdmin) {\n        \t\t\tprop.authenticationRequired();\n        \t\t\treturn prop;\n        \t\t}\n        \t\ttry {\n\t    \t\t\tfinal Pattern pattern = Pattern.compile(\"^crawl start for.*\");\n\t\t\t\t\tfinal Iterator<Tables.Row> APIcalls = sb.tables.iterator(WorkTables.TABLE_API_NAME, WorkTables.TABLE_API_COL_COMMENT, pattern);\n\t    \t\t\tTables.Row row = null;\n\t    \t\t\twhile(APIcalls.hasNext()) {\n\t    \t\t\t\trow = APIcalls.next();\n\t    \t\t\t\tif(row.get(WorkTables.TABLE_API_COL_TYPE, \"\").equals(\"crawler\")) {\n\t    \t\t\t\t\tfinal String url = row.get(WorkTables.TABLE_API_COL_COMMENT, \"\").substring(16);\n\t    \t\t\t\t\tsb.tables.bookmarks.createBookmark(sb.loader, url, agent, bmk_user, autotag, \"crawlStart\", \"/Crawl Start\");\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t    \t\t\tprop.put(\"status\", \"1\");\n\t\t\t\t} catch (final IOException e) {\n\t\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\t} catch (final Failure e) {\n\t\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\t}\n        \t} else if(post.containsKey(\"importer\") && post.get(\"importer\").equals(\"bmks\")) {\n        \t\tif(!isAdmin) {\n        \t\t\tprop.authenticationRequired();\n        \t\t\treturn prop;\n        \t\t}\n        \t\tfinal Iterator<String> bit=sb.bookmarksDB.getBookmarksIterator(isAdmin);\n            \twhile(bit.hasNext()){\n                        Bookmark bookmark=sb.bookmarksDB.getBookmark(bit.next());\n                        if (bookmark != null) {\n                        final YMarkEntry bmk_entry = new YMarkEntry(false);\n                        bmk_entry.put(YMarkEntry.BOOKMARK.URL.key(), bookmark.getUrl());\n                        try {\n                            if(!sb.tables.has(YMarkTables.TABLES.BOOKMARKS.tablename(bmk_user), YMarkUtil.getBookmarkId(bookmark.getUrl()))) {\n                                bmk_entry.put(YMarkEntry.BOOKMARK.PUBLIC.key(), bookmark.getPublic() ? \"true\" : \"false\");\n                                bmk_entry.put(YMarkEntry.BOOKMARK.TITLE.key(), bookmark.getTitle());\n                                bmk_entry.put(YMarkEntry.BOOKMARK.DESC.key(), bookmark.getDescription());\n                                bmk_entry.put(YMarkEntry.BOOKMARK.TAGS.key(), bookmark.getTagsString());\n                                bmk_entry.put(YMarkEntry.BOOKMARK.FOLDERS.key(), root+bookmark.getFoldersString().replaceAll(\".*\"+YMarkUtil.TAGS_SEPARATOR+YMarkUtil.FOLDERS_SEPARATOR, root+YMarkUtil.FOLDERS_SEPARATOR));\n                            }\n                            if(autotag) {\n                                bmk_entry.put(YMarkEntry.BOOKMARK.TAGS.key(), YMarkAutoTagger.autoTag(bookmark.getUrl(), sb.loader, agent, 3, sb.tables.bookmarks.getTags(bmk_user)));\n                            }\n                            sb.tables.bookmarks.addBookmark(bmk_user, bmk_entry, merge, true);\n                            prop.put(\"status\", \"1\");\n                        } catch (final MalformedURLException e) {\n                            ConcurrentLog.logException(e);\n                        } catch (final IOException e) {\n                            ConcurrentLog.logException(e);\n                        }\n                    }\n            \t}\n            } else if(post.containsKey(\"importer\") && post.get(\"importer\").equals(\"dmoz\")) {\n        \t\tif(!isAdmin) {\n        \t\t\tprop.authenticationRequired();\n        \t\t\treturn prop;\n        \t\t}\n        \t\ttry {\n        \t\t\tfinal File in = new File(sb.workPath, \"content.rdf.u8.gz\");\n        \t\t\tfinal InputStream gzip = new FileInputStream(in);\n        \t\t\tfinal InputStream content = new GZIPInputStream(gzip);\n        \t\t\tfinal InputStreamReader reader = new InputStreamReader(content, \"UTF-8\");\n        \t\t\tfinal BufferedReader breader = new BufferedReader(reader);\n        \t\t\tfinal MonitoredReader mreader = new MonitoredReader(breader, 1024*1024, in.length());\n\n        \t\t\tfinal String source = post.get(\"source\", \"\");\n        \t\t\tfinal YMarkDMOZImporter DMOZImporter = new YMarkDMOZImporter(mreader, queueSize, root, source);\n\n        \t\t\tmreader.addChangeListener(sb.tables.bookmarks.getProgressListener(\"DMOZImporter\"));\n        \t\t\tDMOZImporter.setDepth(6);\n        \t\t\tInstantBusyThread.oneTimeJob(DMOZImporter, 0);\n        \t\t\tInstantBusyThread.oneTimeJob(DMOZImporter.getConsumer(sb, bmk_user, autoTaggingQueue, autotag, empty, indexing, medialink), 0);\n\n        \t\t\tprop.put(\"status\", \"1\");\n\t\t\t\t} catch (final Exception e) {\n\t\t\t\t\tConcurrentLog.logException(e);\n\t\t\t\t}\n            }\n        }  else {\n        \tprop.put(serverObjects.ACTION_AUTHENTICATE, YMarkTables.USER_AUTHENTICATE_MSG);\n        }\n        // return rewrite properties\n        return prop;\n\t}","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static int print_XBEL(final Iterator<String> bit, int count) {\n    \tBookmarksDB.Bookmark bookmark;\n    \tDate date;\n    \twhile(bit.hasNext()){\n\t\t\ttry {\n                bookmark=switchboard.bookmarksDB.getBookmark(bit.next());\n                date=new Date(bookmark.getTimeStamp());\n                prop.put(\"xbel_\"+count+\"_elements\", \"<bookmark id=\\\"\" + bookmark.getUrlHash()\n                        + \"\\\" href=\\\"\" + CharacterCoding.unicode2xml(bookmark.getUrl(), true)\n                        + \"\\\" added=\\\"\" + CharacterCoding.unicode2xml(ISO8601Formatter.FORMATTER.format(date), true)+\"\\\">\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<title>\");\n                count++;\n                prop.putXML(\"xbel_\"+count+\"_elements\", bookmark.getTitle());\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<\/title>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<info>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<metadata owner=\\\"Mozilla\\\" ShortcutURL=\\\"\"\n                    + CharacterCoding.unicode2xml(bookmark.getTagsString().replaceAll(\"/.*,\", \"\").toLowerCase(), true)\n                    + \"\\\"/>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<metadata owner=\\\"YaCy\\\" public=\\\"\"+Boolean.toString(bookmark.getPublic())+\"\\\"/>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<\/info>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<desc>\");\n                count++;\n                prop.putXML(\"xbel_\"+count+\"_elements\", bookmark.getDescription());\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<\/desc>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<\/bookmark>\");\n                count++;\n            } catch (final IOException e) {\n            }\n\t\t}\n    \treturn count;\n    }","id":83923,"modified_method":"private static int print_XBEL(final Iterator<String> bit, int count) {\n    \tDate date;\n    \twhile(bit.hasNext()){\n            BookmarksDB.Bookmark bookmark=switchboard.bookmarksDB.getBookmark(bit.next());\n            if (bookmark != null) {\n                date=new Date(bookmark.getTimeStamp());\n                prop.put(\"xbel_\"+count+\"_elements\", \"<bookmark id=\\\"\" + bookmark.getUrlHash()\n                        + \"\\\" href=\\\"\" + CharacterCoding.unicode2xml(bookmark.getUrl(), true)\n                        + \"\\\" added=\\\"\" + CharacterCoding.unicode2xml(ISO8601Formatter.FORMATTER.format(date), true)+\"\\\">\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<title>\");\n                count++;\n                prop.putXML(\"xbel_\"+count+\"_elements\", bookmark.getTitle());\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<\/title>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<info>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<metadata owner=\\\"Mozilla\\\" ShortcutURL=\\\"\"\n                    + CharacterCoding.unicode2xml(bookmark.getTagsString().replaceAll(\"/.*,\", \"\").toLowerCase(), true)\n                    + \"\\\"/>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<metadata owner=\\\"YaCy\\\" public=\\\"\"+Boolean.toString(bookmark.getPublic())+\"\\\"/>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<\/info>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<desc>\");\n                count++;\n                prop.putXML(\"xbel_\"+count+\"_elements\", bookmark.getDescription());\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<\/desc>\");\n                count++;\n                prop.put(\"xbel_\"+count+\"_elements\", \"<\/bookmark>\");\n                count++;\n            }\n\t}\n    \treturn count;\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n\n        final String eventID = post.get(\"eventID\", \"\");\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final int item = post.getInt(\"item\", -1);\n        final RequestHeader.FileType fileType = header.fileType();\n\n        // default settings for blank item\n        prop.put(\"content\", \"0\");\n        prop.put(\"rss\", \"0\");\n        prop.put(\"references\", \"0\");\n        prop.put(\"rssreferences\", \"0\");\n        prop.put(\"dynamic\", \"0\");\n\n        // find search event\n        final SearchEvent theSearch = SearchEventCache.getEvent(eventID);\n        if (theSearch == null) {\n            // the event does not exist, show empty page\n            return prop;\n        }\n\n        // dynamically update count values\n        prop.put(\"offset\", theSearch.query.neededResults() - theSearch.query.itemsPerPage() + 1);\n        prop.put(\"itemscount\", Formatter.number(Math.min((item < 0) ? theSearch.query.neededResults() : item + 1, theSearch.getResultCount())));\n        prop.put(\"itemsperpage\", Formatter.number(theSearch.query.itemsPerPage));\n        prop.put(\"totalcount\", Formatter.number(theSearch.getResultCount(), true));\n        prop.put(\"localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n        prop.put(\"remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n        prop.put(\"remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n        prop.put(\"remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n        prop.put(\"navurlBase\", QueryParams.navurlBase(RequestHeader.FileType.HTML, theSearch.query, null, false).toString());\n        final String target_special_pattern = sb.getConfig(SwitchboardConstants.SEARCH_TARGET_SPECIAL_PATTERN, \"\");\n\n        long timeout = item == 0 ? 10000 : (theSearch.query.isLocal() ? 1000 : 3000);\n        \n        if (theSearch.query.contentdom == Classification.ContentDomain.TEXT || theSearch.query.contentdom == Classification.ContentDomain.ALL) {\n            // text search\n\n            // generate result object\n            final ResultEntry result = theSearch.oneResult(item, timeout);\n            if (result == null) return prop; // no content\n            final String resultUrlstring = result.urlstring();\n            final DigestURL resultURL = result.url();\n            final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n            final int port = resultURL.getPort();\n            DigestURL faviconURL = null;\n            if ((fileType == FileType.HTML || fileType == FileType.JSON) && !sb.isIntranetMode()) try {\n                faviconURL = new DigestURL(resultURL.getProtocol() + \"://\" + resultURL.getHost() + ((port != -1) ? (\":\" + port) : \"\") + \"/favicon.ico\");\n            } catch (final MalformedURLException e1) {\n                ConcurrentLog.logException(e1);\n                faviconURL = null;\n            }\n            final String resource = theSearch.query.domType.toString();\n            final String origQ = theSearch.query.getQueryGoal().getQueryString(true);\n            prop.put(\"content\", 1); // switch on specific content\n            prop.put(\"content_authorized\", authenticated ? \"1\" : \"0\");\n            final String urlhash = ASCII.String(result.hash());\n            if (authenticated) { // only needed if authorized\n                boolean bookmarkexists;\n                try { // check url exists in bookkmarks\n                    bookmarkexists = sb.bookmarksDB.getBookmark(urlhash) != null;\n                } catch (IOException ex) {\n                    bookmarkexists = false;\n                }\n                prop.put(\"content_authorized_bookmark\", !bookmarkexists);\n                // bookmark icon check for YMarks\n                //prop.put(\"content_authorized_bookmark\", sb.tables.bookmarks.hasBookmark(\"admin\", urlhash) ? \"0\" : \"1\");\n                prop.putHTML(\"content_authorized_bookmark_bookmarklink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&resource=\" + resource + \"&time=3&bookmarkref=\" + urlhash + \"&bookmarkurl=\" + crypt.simpleEncode(resultUrlstring) + \"&urlmaskfilter=.*\");\n                prop.put(\"content_authorized_recommend\", (sb.peers.newsPool.getSpecific(NewsPool.OUTGOING_DB, NewsPool.CATEGORY_SURFTIPP_ADD, \"url\", resultUrlstring) == null) ? \"1\" : \"0\");\n                prop.putHTML(\"content_authorized_recommend_deletelink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&deleteref=\" + urlhash + \"&urlmaskfilter=.*\");\n                prop.putHTML(\"content_authorized_recommend_recommendlink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&recommendref=\" + urlhash + \"&urlmaskfilter=.*\");\n                prop.put(\"content_authorized_urlhash\", urlhash);\n            }\n            prop.putHTML(\"content_title\", result.title());\n            prop.putXML(\"content_title-xml\", result.title());\n            prop.putJSON(\"content_title-json\", result.title());\n            prop.putHTML(\"content_showPictures_link\", resultUrlstring);\n            //prop.putHTML(\"content_link\", resultUrlstring);\n\n// START interaction\n            if (sb.getConfigBool(\"proxyURL.useforresults\", false) && sb.getConfigBool(\"proxyURL\", false)) {\n                String modifyURL = resultUrlstring;\n                // check if url is allowed to view\n                final String tmprewritecfg = sb.getConfig(\"proxyURL.rewriteURLs\", \"all\");\n                if (tmprewritecfg.equals(\"all\")) {\n                    modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                } else if (tmprewritecfg.equals(\"domainlist\")) { // check if url is allowed to view\n                    try {\n                        if (sb.crawlStacker.urlInAcceptedDomain(new DigestURL(resultUrlstring)) == null) {\n                            modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                        }\n                    } catch (final MalformedURLException e) {\n                        ConcurrentLog.logException(e);\n                    }\n                } else if (tmprewritecfg.equals(\"yacy\")) {\n                    try {\n                        if ((new DigestURL(resultUrlstring).getHost().endsWith(\".yacy\"))) {\n                            modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                        }\n                    } catch (final MalformedURLException e) {\n                        ConcurrentLog.logException(e);\n                    }\n                }\n                prop.putXML(\"content_link\", modifyURL); // putXML for rss\n            } else {\n                prop.putXML(\"content_link\", resultUrlstring); // putXML for rss\n            }\n            \n//            prop.putHTML(\"content_value\", Interaction.TripleGet(result.urlstring(), \"http://virtual.x/hasvalue\", \"anonymous\"));\n// END interaction\n\n            boolean isAtomFeed = header.get(HeaderFramework.CONNECTION_PROP_EXT, \"\").equals(\"atom\");\n            String resultFileName = resultURL.getFileName();\n            prop.putHTML(\"content_target\", target);\n            //if (faviconURL != null && fileType == FileType.HTML) sb.loader.loadIfNotExistBackground(faviconURL, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n            prop.putHTML(\"content_faviconCode\", URLLicense.aquireLicense(faviconURL)); // acquire license for favicon url loading\n            prop.put(\"content_urlhash\", urlhash);\n            prop.put(\"content_ranking\", Float.toString(result.score()));\n            Date[] events = result.events();\n            boolean showEvent = events != null && events.length > 0 && sb.getConfig(\"search.navigation\", \"\").indexOf(\"date\",0) >= 0;\n            prop.put(\"content_showEvent\", showEvent ? 1 : 0);\n            if (fileType == FileType.HTML) { // html template specific settings\n                prop.put(\"content_showDate\", sb.getConfigBool(\"search.result.show.date\", true) && !showEvent ? 1 : 0);\n                prop.put(\"content_showSize\", sb.getConfigBool(\"search.result.show.size\", true) ? 1 : 0);\n                prop.put(\"content_showMetadata\", sb.getConfigBool(\"search.result.show.metadata\", true) ? 1 : 0);\n                prop.put(\"content_showParser\", sb.getConfigBool(\"search.result.show.parser\", true) ? 1 : 0);\n                prop.put(\"content_showCitation\", sb.getConfigBool(\"search.result.show.citation\", true) ? 1 : 0);\n                prop.put(\"content_showPictures\", sb.getConfigBool(\"search.result.show.pictures\", true) ? 1 : 0);\n                prop.put(\"content_showCache\", sb.getConfigBool(\"search.result.show.cache\", true) && Cache.has(resultURL.hash()) ? 1 : 0);\n                prop.put(\"content_showProxy\", sb.getConfigBool(\"search.result.show.proxy\", true) && sb.getConfigBool(\"proxyURL\", false) ? 1 : 0);\n                prop.put(\"content_showHostBrowser\", sb.getConfigBool(\"search.result.show.hostbrowser\", true) ? 1 : 0);\n                prop.put(\"content_showVocabulary\", sb.getConfigBool(\"search.result.show.vocabulary\", true) ? 1 : 0);\n\n                if (showEvent) prop.put(\"content_showEvent_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(events[0]));\n                prop.put(\"content_showDate_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(result.modified()));\n                prop.putHTML(\"content_showSize_sizename\", RSSMessage.sizename(result.filesize()));\n                prop.put(\"content_showMetadata_urlhash\", urlhash);\n                prop.put(\"content_showParser_urlhash\", urlhash);\n                prop.put(\"content_showCitation_urlhash\", urlhash);\n                prop.putHTML(\"content_showPictures_former\", origQ);\n                prop.put(\"content_showCache_link\", resultUrlstring);\n                prop.put(\"content_showProxy_link\", resultUrlstring);\n                prop.put(\"content_showHostBrowser_link\", resultUrlstring);\n                if (sb.getConfigBool(\"search.result.show.vocabulary\", true)) {\n                    URIMetadataNode node = result.getNode();\n                    int c = 0;\n                    for (Map.Entry<String, Object> entry: node.entrySet()) {\n                        String key = entry.getKey();\n                        if (key.startsWith(\"vocabulary_\") && key.endsWith(\"_sxt\")) {\n                            @SuppressWarnings(\"unchecked\")\n                            Collection<String> terms = (Collection<String>) entry.getValue();\n                            prop.putHTML(\"content_showVocabulary_vocabulary_\" + c + \"_name\", key.substring(11, key.length() - 4));\n                            prop.putHTML(\"content_showVocabulary_vocabulary_\" + c + \"_terms\", terms.toString());\n                            c++;\n                        }\n                    }\n                    prop.put(\"content_showVocabulary_vocabulary\", c);\n                    prop.put(\"content_showVocabulary\", 1);\n                } else {\n                    prop.put(\"content_showVocabulary_vocabulary\", 0);\n                    prop.put(\"content_showVocabulary\", 0);\n                }\n            }\n            prop.put(\"content_urlhexhash\", Seed.b64Hash2hexHash(urlhash));\n            prop.putHTML(\"content_urlname\", nxTools.shortenURLString(result.urlname(), MAX_URL_LENGTH));\n            prop.put(\"content_date822\", isAtomFeed ? ISO8601Formatter.FORMATTER.format(result.modified()) : HeaderFramework.formatRFC1123(result.modified()));\n            if (showEvent) prop.put(\"content_showEvent_date822\", isAtomFeed ? ISO8601Formatter.FORMATTER.format(events[0]) : HeaderFramework.formatRFC1123(events[0]));\n            //prop.put(\"content_ybr\", RankingProcess.ybr(result.hash()));\n            prop.putHTML(\"content_size\", Integer.toString(result.filesize())); // we don't use putNUM here because that number shall be usable as sorting key. To print the size, use 'sizename'\n            prop.putHTML(\"content_sizename\", RSSMessage.sizename(result.filesize()));            \n            prop.putHTML(\"content_host\", resultURL.getHost() == null ? \"\" : resultURL.getHost());\n            prop.putXML(\"content_file\", resultFileName); // putXML for rss\n            prop.putXML(\"content_path\", resultURL.getPath()); // putXML for rss\n            prop.put(\"content_nl\", (item == theSearch.query.offset) ? 0 : 1);\n            prop.putHTML(\"content_publisher\", result.publisher());\n            prop.putHTML(\"content_creator\", result.creator());// author\n            prop.putHTML(\"content_subject\", result.subject());\n            final Iterator<String> query = theSearch.query.getQueryGoal().getIncludeStrings();\n            final StringBuilder s = new StringBuilder(theSearch.query.getQueryGoal().getIncludeSize() * 20);\n            while (query.hasNext()) s.append('+').append(query.next());\n            final String words = (s.length() > 0) ? s.substring(1) : \"\";\n            prop.putHTML(\"content_words\", words);\n            prop.putHTML(\"content_showParser_words\", words);\n            prop.putHTML(\"content_former\", origQ);\n            final TextSnippet snippet = result.textSnippet();\n            final String desc = (snippet == null) ? \"\" : snippet.descriptionline(theSearch.query.getQueryGoal());\n            prop.put(\"content_description\", desc);\n            prop.putXML(\"content_description-xml\", desc);\n            prop.putJSON(\"content_description-json\", desc);\n            prop.put(\"content_mimetype\",result.getNode().mime()); // for atom <link> type attribute\n            final HeuristicResult heuristic = theSearch.getHeuristic(result.hash());\n            if (heuristic == null) {\n                prop.put(\"content_heuristic\", 0);\n            } else {\n                if (heuristic.redundant) {\n                    prop.put(\"content_heuristic\", 1);\n                } else {\n                    prop.put(\"content_heuristic\", 2);\n                }\n                prop.put(\"content_heuristic_name\", heuristic.heuristicName);\n            }\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theSearch.query.id(true), SearchEventType.FINALIZATION, \"\" + item, 0, 0), false);\n            final String ext = MultiProtocolURL.getFileExtension(resultFileName);\n            if (MultiProtocolURL.isImage(ext)) {\n                final String license = URLLicense.aquireLicense(resultURL);\n                prop.put(\"content_code\", license);\n            } else {\n                prop.put(\"content_code\", \"\");\n            }\n            if (result.lat() == 0.0d || result.lon() == 0.0d) {\n                prop.put(\"content_loc\", 0);\n            } else {\n                prop.put(\"content_loc\", 1);\n                prop.put(\"content_loc_lat\", result.lat());\n                prop.put(\"content_loc_lon\", result.lon());\n            }\n            final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n            final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW_SEARCH, true) || clustersearch;\n            boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n            boolean stealthmode = p2pmode && theSearch.query.isLocal();\n            if ((sb.getConfigBool(SwitchboardConstants.HEURISTIC_SEARCHRESULTS, false) ||\n                (sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ACTIVE, false) && sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ENABLED, false) && Memory.load() < 1.0)) &&\n                !stealthmode) sb.heuristicSearchResults(resultUrlstring);\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if (theSearch.query.contentdom == Classification.ContentDomain.IMAGE) {\n            // image search; shows thumbnails\n\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            SearchEvent.ImageResult image = null;\n            try {\n                image = theSearch.oneImageResult(item, timeout);\n                final String imageUrlstring = image.imageUrl.toNormalform(true);\n                final String imageUrlExt = MultiProtocolURL.getFileExtension(image.imageUrl.getFileName());\n                final String target = sb.getConfig(imageUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n                final String license = URLLicense.aquireLicense(image.imageUrl); // this is just the license key to get the image forwarded through the YaCy thumbnail viewer, not an actual lawful license\n                //sb.loader.loadIfNotExistBackground(image.imageUrl, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n                prop.putHTML(\"content_item_hrefCache\", \"/ViewImage.\" + (\"gif\".equals(imageUrlExt) ? \"gif\" : \"png\") + \"?maxwidth=128&maxheight=128&isStatic=true&quadratic=&url=\" + imageUrlstring);\n                prop.putHTML(\"content_item_href\", imageUrlstring);\n                prop.putHTML(\"content_item_target\", target);\n                prop.put(\"content_item_code\", license);\n                prop.putHTML(\"content_item_name\", shorten(image.imagetext, MAX_NAME_LENGTH));\n                prop.put(\"content_item_mimetype\", image.mimetype);\n                prop.put(\"content_item_fileSize\", 0);\n                prop.put(\"content_item_width\", image.width);\n                prop.put(\"content_item_height\", image.height);\n                prop.put(\"content_item_attr\", \"\"/*(ms.attr.equals(\"-1 x -1\")) ? \"\" : \"(\" + ms.attr + \")\"*/); // attributes, here: original size of image\n                prop.put(\"content_item_urlhash\", ASCII.String(image.imageUrl.hash()));\n                prop.put(\"content_item_source\", image.sourceUrl.toNormalform(true));\n                prop.putXML(\"content_item_source-xml\", image.sourceUrl.toNormalform(true));\n                prop.put(\"content_item_sourcedom\", image.sourceUrl.getHost());\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            } catch (MalformedURLException e) {\n                prop.put(\"content_item\", \"0\");\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if ((theSearch.query.contentdom == ContentDomain.AUDIO) ||\n            (theSearch.query.contentdom == ContentDomain.VIDEO) ||\n            (theSearch.query.contentdom == ContentDomain.APP)) {\n            // any other media content\n\n            // generate result object\n            final ResultEntry ms = theSearch.oneResult(item, timeout);\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            if (ms == null) {\n                prop.put(\"content_item\", \"0\");\n            } else {\n                final String resultUrlstring = ms.url().toNormalform(true);\n                final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n                prop.putHTML(\"content_item_href\", resultUrlstring);\n                prop.putHTML(\"content_item_hrefshort\", nxTools.shortenURLString(resultUrlstring, MAX_URL_LENGTH));\n                prop.putHTML(\"content_item_target\", target);\n                prop.putHTML(\"content_item_name\", shorten(ms.title(), MAX_NAME_LENGTH));\n                prop.put(\"content_item_col\", (item % 2 == 0) ? \"0\" : \"1\");\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        return prop;\n    }","id":83924,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n\n        final String eventID = post.get(\"eventID\", \"\");\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        final int item = post.getInt(\"item\", -1);\n        final RequestHeader.FileType fileType = header.fileType();\n\n        // default settings for blank item\n        prop.put(\"content\", \"0\");\n        prop.put(\"rss\", \"0\");\n        prop.put(\"references\", \"0\");\n        prop.put(\"rssreferences\", \"0\");\n        prop.put(\"dynamic\", \"0\");\n\n        // find search event\n        final SearchEvent theSearch = SearchEventCache.getEvent(eventID);\n        if (theSearch == null) {\n            // the event does not exist, show empty page\n            return prop;\n        }\n\n        // dynamically update count values\n        prop.put(\"offset\", theSearch.query.neededResults() - theSearch.query.itemsPerPage() + 1);\n        prop.put(\"itemscount\", Formatter.number(Math.min((item < 0) ? theSearch.query.neededResults() : item + 1, theSearch.getResultCount())));\n        prop.put(\"itemsperpage\", Formatter.number(theSearch.query.itemsPerPage));\n        prop.put(\"totalcount\", Formatter.number(theSearch.getResultCount(), true));\n        prop.put(\"localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n        prop.put(\"remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n        prop.put(\"remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n        prop.put(\"remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n        prop.put(\"navurlBase\", QueryParams.navurlBase(RequestHeader.FileType.HTML, theSearch.query, null, false).toString());\n        final String target_special_pattern = sb.getConfig(SwitchboardConstants.SEARCH_TARGET_SPECIAL_PATTERN, \"\");\n\n        long timeout = item == 0 ? 10000 : (theSearch.query.isLocal() ? 1000 : 3000);\n        \n        if (theSearch.query.contentdom == Classification.ContentDomain.TEXT || theSearch.query.contentdom == Classification.ContentDomain.ALL) {\n            // text search\n\n            // generate result object\n            final ResultEntry result = theSearch.oneResult(item, timeout);\n            if (result == null) return prop; // no content\n            final String resultUrlstring = result.urlstring();\n            final DigestURL resultURL = result.url();\n            final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n            final int port = resultURL.getPort();\n            DigestURL faviconURL = null;\n            if ((fileType == FileType.HTML || fileType == FileType.JSON) && !sb.isIntranetMode()) try {\n                faviconURL = new DigestURL(resultURL.getProtocol() + \"://\" + resultURL.getHost() + ((port != -1) ? (\":\" + port) : \"\") + \"/favicon.ico\");\n            } catch (final MalformedURLException e1) {\n                ConcurrentLog.logException(e1);\n                faviconURL = null;\n            }\n            final String resource = theSearch.query.domType.toString();\n            final String origQ = theSearch.query.getQueryGoal().getQueryString(true);\n            prop.put(\"content\", 1); // switch on specific content\n            prop.put(\"content_authorized\", authenticated ? \"1\" : \"0\");\n            final String urlhash = ASCII.String(result.hash());\n            if (authenticated) { // only needed if authorized\n                boolean bookmarkexists;\n                // check url exists in bookkmarks\n                bookmarkexists = sb.bookmarksDB.getBookmark(urlhash) != null;\n                prop.put(\"content_authorized_bookmark\", !bookmarkexists);\n                // bookmark icon check for YMarks\n                //prop.put(\"content_authorized_bookmark\", sb.tables.bookmarks.hasBookmark(\"admin\", urlhash) ? \"0\" : \"1\");\n                prop.putHTML(\"content_authorized_bookmark_bookmarklink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&resource=\" + resource + \"&time=3&bookmarkref=\" + urlhash + \"&bookmarkurl=\" + crypt.simpleEncode(resultUrlstring) + \"&urlmaskfilter=.*\");\n                prop.put(\"content_authorized_recommend\", (sb.peers.newsPool.getSpecific(NewsPool.OUTGOING_DB, NewsPool.CATEGORY_SURFTIPP_ADD, \"url\", resultUrlstring) == null) ? \"1\" : \"0\");\n                prop.putHTML(\"content_authorized_recommend_deletelink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&deleteref=\" + urlhash + \"&urlmaskfilter=.*\");\n                prop.putHTML(\"content_authorized_recommend_recommendlink\", \"yacysearch.html?query=\" + origQ.replace(' ', '+') + \"&Enter=Search&count=\" + theSearch.query.itemsPerPage() + \"&offset=\" + (theSearch.query.neededResults() - theSearch.query.itemsPerPage()) + \"&order=\" + crypt.simpleEncode(theSearch.query.ranking.toExternalString()) + \"&resource=\" + resource + \"&time=3&recommendref=\" + urlhash + \"&urlmaskfilter=.*\");\n                prop.put(\"content_authorized_urlhash\", urlhash);\n            }\n            prop.putHTML(\"content_title\", result.title());\n            prop.putXML(\"content_title-xml\", result.title());\n            prop.putJSON(\"content_title-json\", result.title());\n            prop.putHTML(\"content_showPictures_link\", resultUrlstring);\n            //prop.putHTML(\"content_link\", resultUrlstring);\n\n// START interaction\n            if (sb.getConfigBool(\"proxyURL.useforresults\", false) && sb.getConfigBool(\"proxyURL\", false)) {\n                String modifyURL = resultUrlstring;\n                // check if url is allowed to view\n                final String tmprewritecfg = sb.getConfig(\"proxyURL.rewriteURLs\", \"all\");\n                if (tmprewritecfg.equals(\"all\")) {\n                    modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                } else if (tmprewritecfg.equals(\"domainlist\")) { // check if url is allowed to view\n                    try {\n                        if (sb.crawlStacker.urlInAcceptedDomain(new DigestURL(resultUrlstring)) == null) {\n                            modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                        }\n                    } catch (final MalformedURLException e) {\n                        ConcurrentLog.logException(e);\n                    }\n                } else if (tmprewritecfg.equals(\"yacy\")) {\n                    try {\n                        if ((new DigestURL(resultUrlstring).getHost().endsWith(\".yacy\"))) {\n                            modifyURL = \"./proxy.html?url=\" + resultUrlstring;\n                        }\n                    } catch (final MalformedURLException e) {\n                        ConcurrentLog.logException(e);\n                    }\n                }\n                prop.putXML(\"content_link\", modifyURL); // putXML for rss\n            } else {\n                prop.putXML(\"content_link\", resultUrlstring); // putXML for rss\n            }\n            \n//            prop.putHTML(\"content_value\", Interaction.TripleGet(result.urlstring(), \"http://virtual.x/hasvalue\", \"anonymous\"));\n// END interaction\n\n            boolean isAtomFeed = header.get(HeaderFramework.CONNECTION_PROP_EXT, \"\").equals(\"atom\");\n            String resultFileName = resultURL.getFileName();\n            prop.putHTML(\"content_target\", target);\n            //if (faviconURL != null && fileType == FileType.HTML) sb.loader.loadIfNotExistBackground(faviconURL, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n            prop.putHTML(\"content_faviconCode\", URLLicense.aquireLicense(faviconURL)); // acquire license for favicon url loading\n            prop.put(\"content_urlhash\", urlhash);\n            prop.put(\"content_ranking\", Float.toString(result.score()));\n            Date[] events = result.events();\n            boolean showEvent = events != null && events.length > 0 && sb.getConfig(\"search.navigation\", \"\").indexOf(\"date\",0) >= 0;\n            prop.put(\"content_showEvent\", showEvent ? 1 : 0);\n            if (fileType == FileType.HTML) { // html template specific settings\n                prop.put(\"content_showDate\", sb.getConfigBool(\"search.result.show.date\", true) && !showEvent ? 1 : 0);\n                prop.put(\"content_showSize\", sb.getConfigBool(\"search.result.show.size\", true) ? 1 : 0);\n                prop.put(\"content_showMetadata\", sb.getConfigBool(\"search.result.show.metadata\", true) ? 1 : 0);\n                prop.put(\"content_showParser\", sb.getConfigBool(\"search.result.show.parser\", true) ? 1 : 0);\n                prop.put(\"content_showCitation\", sb.getConfigBool(\"search.result.show.citation\", true) ? 1 : 0);\n                prop.put(\"content_showPictures\", sb.getConfigBool(\"search.result.show.pictures\", true) ? 1 : 0);\n                prop.put(\"content_showCache\", sb.getConfigBool(\"search.result.show.cache\", true) && Cache.has(resultURL.hash()) ? 1 : 0);\n                prop.put(\"content_showProxy\", sb.getConfigBool(\"search.result.show.proxy\", true) && sb.getConfigBool(\"proxyURL\", false) ? 1 : 0);\n                prop.put(\"content_showHostBrowser\", sb.getConfigBool(\"search.result.show.hostbrowser\", true) ? 1 : 0);\n                prop.put(\"content_showVocabulary\", sb.getConfigBool(\"search.result.show.vocabulary\", true) ? 1 : 0);\n\n                if (showEvent) prop.put(\"content_showEvent_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(events[0]));\n                prop.put(\"content_showDate_date\", GenericFormatter.RFC1123_SHORT_FORMATTER.format(result.modified()));\n                prop.putHTML(\"content_showSize_sizename\", RSSMessage.sizename(result.filesize()));\n                prop.put(\"content_showMetadata_urlhash\", urlhash);\n                prop.put(\"content_showParser_urlhash\", urlhash);\n                prop.put(\"content_showCitation_urlhash\", urlhash);\n                prop.putHTML(\"content_showPictures_former\", origQ);\n                prop.put(\"content_showCache_link\", resultUrlstring);\n                prop.put(\"content_showProxy_link\", resultUrlstring);\n                prop.put(\"content_showHostBrowser_link\", resultUrlstring);\n                if (sb.getConfigBool(\"search.result.show.vocabulary\", true)) {\n                    URIMetadataNode node = result.getNode();\n                    int c = 0;\n                    for (Map.Entry<String, Object> entry: node.entrySet()) {\n                        String key = entry.getKey();\n                        if (key.startsWith(\"vocabulary_\") && key.endsWith(\"_sxt\")) {\n                            @SuppressWarnings(\"unchecked\")\n                            Collection<String> terms = (Collection<String>) entry.getValue();\n                            prop.putHTML(\"content_showVocabulary_vocabulary_\" + c + \"_name\", key.substring(11, key.length() - 4));\n                            prop.putHTML(\"content_showVocabulary_vocabulary_\" + c + \"_terms\", terms.toString());\n                            c++;\n                        }\n                    }\n                    prop.put(\"content_showVocabulary_vocabulary\", c);\n                    prop.put(\"content_showVocabulary\", 1);\n                } else {\n                    prop.put(\"content_showVocabulary_vocabulary\", 0);\n                    prop.put(\"content_showVocabulary\", 0);\n                }\n            }\n            prop.put(\"content_urlhexhash\", Seed.b64Hash2hexHash(urlhash));\n            prop.putHTML(\"content_urlname\", nxTools.shortenURLString(result.urlname(), MAX_URL_LENGTH));\n            prop.put(\"content_date822\", isAtomFeed ? ISO8601Formatter.FORMATTER.format(result.modified()) : HeaderFramework.formatRFC1123(result.modified()));\n            if (showEvent) prop.put(\"content_showEvent_date822\", isAtomFeed ? ISO8601Formatter.FORMATTER.format(events[0]) : HeaderFramework.formatRFC1123(events[0]));\n            //prop.put(\"content_ybr\", RankingProcess.ybr(result.hash()));\n            prop.putHTML(\"content_size\", Integer.toString(result.filesize())); // we don't use putNUM here because that number shall be usable as sorting key. To print the size, use 'sizename'\n            prop.putHTML(\"content_sizename\", RSSMessage.sizename(result.filesize()));            \n            prop.putHTML(\"content_host\", resultURL.getHost() == null ? \"\" : resultURL.getHost());\n            prop.putXML(\"content_file\", resultFileName); // putXML for rss\n            prop.putXML(\"content_path\", resultURL.getPath()); // putXML for rss\n            prop.put(\"content_nl\", (item == theSearch.query.offset) ? 0 : 1);\n            prop.putHTML(\"content_publisher\", result.publisher());\n            prop.putHTML(\"content_creator\", result.creator());// author\n            prop.putHTML(\"content_subject\", result.subject());\n            final Iterator<String> query = theSearch.query.getQueryGoal().getIncludeStrings();\n            final StringBuilder s = new StringBuilder(theSearch.query.getQueryGoal().getIncludeSize() * 20);\n            while (query.hasNext()) s.append('+').append(query.next());\n            final String words = (s.length() > 0) ? s.substring(1) : \"\";\n            prop.putHTML(\"content_words\", words);\n            prop.putHTML(\"content_showParser_words\", words);\n            prop.putHTML(\"content_former\", origQ);\n            final TextSnippet snippet = result.textSnippet();\n            final String desc = (snippet == null) ? \"\" : snippet.descriptionline(theSearch.query.getQueryGoal());\n            prop.put(\"content_description\", desc);\n            prop.putXML(\"content_description-xml\", desc);\n            prop.putJSON(\"content_description-json\", desc);\n            prop.put(\"content_mimetype\",result.getNode().mime()); // for atom <link> type attribute\n            final HeuristicResult heuristic = theSearch.getHeuristic(result.hash());\n            if (heuristic == null) {\n                prop.put(\"content_heuristic\", 0);\n            } else {\n                if (heuristic.redundant) {\n                    prop.put(\"content_heuristic\", 1);\n                } else {\n                    prop.put(\"content_heuristic\", 2);\n                }\n                prop.put(\"content_heuristic_name\", heuristic.heuristicName);\n            }\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theSearch.query.id(true), SearchEventType.FINALIZATION, \"\" + item, 0, 0), false);\n            final String ext = MultiProtocolURL.getFileExtension(resultFileName);\n            if (MultiProtocolURL.isImage(ext)) {\n                final String license = URLLicense.aquireLicense(resultURL);\n                prop.put(\"content_code\", license);\n            } else {\n                prop.put(\"content_code\", \"\");\n            }\n            if (result.lat() == 0.0d || result.lon() == 0.0d) {\n                prop.put(\"content_loc\", 0);\n            } else {\n                prop.put(\"content_loc\", 1);\n                prop.put(\"content_loc_lat\", result.lat());\n                prop.put(\"content_loc_lon\", result.lon());\n            }\n            final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n            final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW_SEARCH, true) || clustersearch;\n            boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n            boolean stealthmode = p2pmode && theSearch.query.isLocal();\n            if ((sb.getConfigBool(SwitchboardConstants.HEURISTIC_SEARCHRESULTS, false) ||\n                (sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ACTIVE, false) && sb.getConfigBool(SwitchboardConstants.GREEDYLEARNING_ENABLED, false) && Memory.load() < 1.0)) &&\n                !stealthmode) sb.heuristicSearchResults(resultUrlstring);\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if (theSearch.query.contentdom == Classification.ContentDomain.IMAGE) {\n            // image search; shows thumbnails\n\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            SearchEvent.ImageResult image = null;\n            try {\n                image = theSearch.oneImageResult(item, timeout);\n                final String imageUrlstring = image.imageUrl.toNormalform(true);\n                final String imageUrlExt = MultiProtocolURL.getFileExtension(image.imageUrl.getFileName());\n                final String target = sb.getConfig(imageUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n\n                final String license = URLLicense.aquireLicense(image.imageUrl); // this is just the license key to get the image forwarded through the YaCy thumbnail viewer, not an actual lawful license\n                //sb.loader.loadIfNotExistBackground(image.imageUrl, 1024 * 1024 * 10, null, ClientIdentification.yacyIntranetCrawlerAgent);\n                prop.putHTML(\"content_item_hrefCache\", \"/ViewImage.\" + (\"gif\".equals(imageUrlExt) ? \"gif\" : \"png\") + \"?maxwidth=128&maxheight=128&isStatic=true&quadratic=&url=\" + imageUrlstring);\n                prop.putHTML(\"content_item_href\", imageUrlstring);\n                prop.putHTML(\"content_item_target\", target);\n                prop.put(\"content_item_code\", license);\n                prop.putHTML(\"content_item_name\", shorten(image.imagetext, MAX_NAME_LENGTH));\n                prop.put(\"content_item_mimetype\", image.mimetype);\n                prop.put(\"content_item_fileSize\", 0);\n                prop.put(\"content_item_width\", image.width);\n                prop.put(\"content_item_height\", image.height);\n                prop.put(\"content_item_attr\", \"\"/*(ms.attr.equals(\"-1 x -1\")) ? \"\" : \"(\" + ms.attr + \")\"*/); // attributes, here: original size of image\n                prop.put(\"content_item_urlhash\", ASCII.String(image.imageUrl.hash()));\n                prop.put(\"content_item_source\", image.sourceUrl.toNormalform(true));\n                prop.putXML(\"content_item_source-xml\", image.sourceUrl.toNormalform(true));\n                prop.put(\"content_item_sourcedom\", image.sourceUrl.getHost());\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            } catch (MalformedURLException e) {\n                prop.put(\"content_item\", \"0\");\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        if ((theSearch.query.contentdom == ContentDomain.AUDIO) ||\n            (theSearch.query.contentdom == ContentDomain.VIDEO) ||\n            (theSearch.query.contentdom == ContentDomain.APP)) {\n            // any other media content\n\n            // generate result object\n            final ResultEntry ms = theSearch.oneResult(item, timeout);\n            prop.put(\"content\", theSearch.query.contentdom.getCode() + 1); // switch on specific content\n            if (ms == null) {\n                prop.put(\"content_item\", \"0\");\n            } else {\n                final String resultUrlstring = ms.url().toNormalform(true);\n                final String target = sb.getConfig(resultUrlstring.matches(target_special_pattern) ? SwitchboardConstants.SEARCH_TARGET_SPECIAL : SwitchboardConstants.SEARCH_TARGET_DEFAULT, \"_self\");\n                prop.putHTML(\"content_item_href\", resultUrlstring);\n                prop.putHTML(\"content_item_hrefshort\", nxTools.shortenURLString(resultUrlstring, MAX_URL_LENGTH));\n                prop.putHTML(\"content_item_target\", target);\n                prop.putHTML(\"content_item_name\", shorten(ms.title(), MAX_NAME_LENGTH));\n                prop.put(\"content_item_col\", (item % 2 == 0) ? \"0\" : \"1\");\n                prop.put(\"content_item_nl\", (item == theSearch.query.offset) ? 0 : 1);\n                prop.put(\"content_item\", 1);\n            }\n            theSearch.query.transmitcount = item + 1;\n            return prop;\n        }\n\n        return prop;\n    }","commit_id":"609c52e9878840d5938942857f23db4670449815","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * Register a new procedure.\n     *\n     * @param proc the procedure.\n     */\n    public void register( CallableProcedure proc, boolean overrideCurrentImplementation ) throws ProcedureException\n    {\n        ProcedureSignature signature = proc.signature();\n        QualifiedName name = signature.name();\n\n        String descriptiveName = signature.toString();\n        validateSignature( descriptiveName, signature.inputSignature(), \"input\" );\n        validateSignature( descriptiveName, signature.outputSignature(), \"output\" );\n\n        CallableProcedure oldImplementation = procedures.get( name );\n        if ( oldImplementation == null )\n        {\n            procedures.put( name, proc );\n        }\n        else\n        {\n            if ( overrideCurrentImplementation )\n            {\n                procedures.put( name, proc );\n            }\n            else\n            {\n                throw new ProcedureException( Status.Procedure.ProcedureRegistrationFailed,\n                        \"Unable to register procedure, because the name `%s` is already in use.\", name );\n            }\n        }\n    }","id":83925,"modified_method":"/**\n     * Register a new procedure.\n     *\n     * @param proc the procedure.\n     */\n    public void register( CallableProcedure proc, boolean overrideCurrentImplementation ) throws ProcedureException\n    {\n        ProcedureSignature signature = proc.signature();\n        QualifiedName name = signature.name();\n\n        String descriptiveName = signature.toString();\n        validateSignature( descriptiveName, signature.inputSignature(), \"input\" );\n        validateSignature( descriptiveName, signature.outputSignature(), \"output\" );\n\n        if ( ! signature.isVoid() && signature.outputSignature().isEmpty() )\n        {\n            throw new ProcedureException(\n                Status.Procedure.ProcedureRegistrationFailed,\n                \"Procedures with zero output fields must be declared as VOID\"\n            );\n        }\n\n        CallableProcedure oldImplementation = procedures.get( name );\n        if ( oldImplementation == null )\n        {\n            procedures.put( name, proc );\n        }\n        else\n        {\n            if ( overrideCurrentImplementation )\n            {\n                procedures.put( name, proc );\n            }\n            else\n            {\n                throw new ProcedureException( Status.Procedure.ProcedureRegistrationFailed,\n                        \"Unable to register procedure, because the name `%s` is already in use.\", name );\n            }\n        }\n    }","commit_id":"cca93ded2edcf0f8daa160a75ab4e09e22759fa5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGetAllProcedures() throws Throwable\n    {\n        // Given\n        kernel.registerProcedure( procedure );\n        kernel.registerProcedure( procedure( procedureSignature( \"example\", \"exampleProc2\" ).build() ) );\n        kernel.registerProcedure( procedure( procedureSignature( \"example\", \"exampleProc3\" ).build() ) );\n\n        // When\n        List<ProcedureSignature> signatures =\n                Iterables.asList( readOperationsInNewTransaction().proceduresGetAll() );\n\n        // Then\n        assertThat( signatures, hasItems(\n            procedure.signature(),\n            procedureSignature( \"example\", \"exampleProc2\" ).build(),\n            procedureSignature( \"example\", \"exampleProc3\" ).build() ) );\n    }","id":83926,"modified_method":"@Test\n    public void shouldGetAllProcedures() throws Throwable\n    {\n        // Given\n        kernel.registerProcedure( procedure );\n        kernel.registerProcedure( procedure( procedureSignature( \"example\", \"exampleProc2\" ).out( \"name\", NTString ).build() ) );\n        kernel.registerProcedure( procedure( procedureSignature( \"example\", \"exampleProc3\" ).out( \"name\", NTString ).build() ) );\n\n        // When\n        List<ProcedureSignature> signatures =\n                Iterables.asList( readOperationsInNewTransaction().proceduresGetAll() );\n\n        // Then\n        assertThat( signatures, hasItems(\n            procedure.signature(),\n            procedureSignature( \"example\", \"exampleProc2\" ).out( \"name\", NTString ).build(),\n            procedureSignature( \"example\", \"exampleProc3\" ).out( \"name\", NTString ).build() ) );\n    }","commit_id":"cca93ded2edcf0f8daa160a75ab4e09e22759fa5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGetBuiltInProcedureByName() throws Throwable\n    {\n        // When\n        ProcedureSignature found = readOperationsInNewTransaction()\n                .procedureGet( procedureName( \"db\", \"labels\" ) );\n\n        // Then\n        assertThat( found, equalTo( procedureSignature( procedureName( \"db\", \"labels\" ) )\n                .out(  \"label\", Neo4jTypes.NTString ).build() ) );\n    }","id":83927,"modified_method":"@Test\n    public void shouldGetBuiltInProcedureByName() throws Throwable\n    {\n        // When\n        ProcedureSignature found = readOperationsInNewTransaction()\n                .procedureGet( procedureName( \"db\", \"labels\" ) );\n\n        // Then\n        assertThat( found, equalTo( procedureSignature( procedureName( \"db\", \"labels\" ) )\n                .out(  \"label\", NTString ).build() ) );\n    }","commit_id":"cca93ded2edcf0f8daa160a75ab4e09e22759fa5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGetAllRegisteredProcedures() throws Throwable\n    {\n        // When\n        procs.register( procedure( procedureSignature( \"org\", \"myproc1\" ).build() ) );\n        procs.register( procedure( procedureSignature( \"org\", \"myproc2\" ).build() ) );\n        procs.register( procedure( procedureSignature( \"org\", \"myproc3\" ).build() ) );\n\n        // Then\n        List<ProcedureSignature> signatures = Iterables.asList( procs.getAllProcedures() );\n        assertThat( signatures, containsInAnyOrder(\n                procedureSignature( \"org\", \"myproc1\" ).build(),\n                procedureSignature( \"org\", \"myproc2\" ).build(),\n                procedureSignature( \"org\", \"myproc3\" ).build() ) );\n    }","id":83928,"modified_method":"@Test\n    public void shouldGetAllRegisteredProcedures() throws Throwable\n    {\n        // When\n        procs.register( procedure( procedureSignature( \"org\", \"myproc1\" ).out( \"age\", NTInteger ).build() ) );\n        procs.register( procedure( procedureSignature( \"org\", \"myproc2\" ).out( \"age\", NTInteger ).build() ) );\n        procs.register( procedure( procedureSignature( \"org\", \"myproc3\" ).out( \"age\", NTInteger ).build() ) );\n\n        // Then\n        List<ProcedureSignature> signatures = Iterables.asList( procs.getAllProcedures() );\n        assertThat( signatures, containsInAnyOrder(\n                procedureSignature( \"org\", \"myproc1\" ).out( \"age\", NTInteger ).build(),\n                procedureSignature( \"org\", \"myproc2\" ).out( \"age\", NTInteger ).build(),\n                procedureSignature( \"org\", \"myproc3\" ).out( \"age\", NTInteger ).build() ) );\n    }","commit_id":"cca93ded2edcf0f8daa160a75ab4e09e22759fa5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static List<S3ObjectSummary> listDirectory(final String bucketName, final String directory, final AmazonS3 client) {\n\n     List<S3ObjectSummary> objects = new ArrayList<S3ObjectSummary>();\n     ListObjectsRequest listObjectsRequest = new ListObjectsRequest().withBucketName(bucketName).withPrefix(directory + SEPARATOR);\n     ObjectListing objectListing;\n\n     do {\n      objectListing = client.listObjects(listObjectsRequest);\n      if (objectListing != null )\n        objects.addAll(objectListing.getObjectSummaries());\n      listObjectsRequest.setMarker(objectListing.getNextMarker());\n     } while (objectListing.isTruncated());\n        if (objects.isEmpty()) {\n            return emptyList();\n        }\n\n        return unmodifiableList(objects);\n\n    }","id":83929,"modified_method":"private static List<S3ObjectSummary> listDirectory(final String bucketName, final String directory, final AmazonS3 client) {\n\n        List<S3ObjectSummary> objects = new ArrayList<S3ObjectSummary>();\n        ListObjectsRequest listObjectsRequest = new ListObjectsRequest().withBucketName(bucketName).withPrefix(directory + SEPARATOR);\n\n        ObjectListing ol = client.listObjects(listObjectsRequest);\n        while (ol != null && ol.isTruncated()) {\n            objects.addAll(ol.getObjectSummaries());\n            listObjectsRequest.setMarker(ol.getNextMarker());\n            ol = client.listObjects(listObjectsRequest);\n        }\n\n        if (objects.isEmpty()) {\n            return emptyList();\n        }\n\n        return unmodifiableList(objects);\n    }","commit_id":"debcbcc1454789936407583fe0aba8e158b16cad","url":"https://github.com/apache/cloudstack"},{"original_method":"private static List<S3ObjectSummary> listDirectory(final String bucketName, final String directory, final AmazonS3 client) {\n\n     List<S3ObjectSummary> objects = new ArrayList<S3ObjectSummary>();\n     ListObjectsRequest listObjectsRequest = new ListObjectsRequest().withBucketName(bucketName).withPrefix(directory + SEPARATOR);\n     ObjectListing objectListing;\n\n     do {\n      objectListing = client.listObjects(listObjectsRequest);\n      if (objectListing != null )\n        objects.addAll(objectListing.getObjectSummaries());\n      listObjectsRequest.setMarker(objectListing.getNextMarker());\n     } while (objectListing.isTruncated());\n        if (objects.isEmpty()) {\n            return emptyList();\n        }\n\n        return unmodifiableList(objects);\n\n    }","id":83930,"modified_method":"private static List<S3ObjectSummary> listDirectory(final String bucketName, final String directory, final AmazonS3 client) {\n\n        List<S3ObjectSummary> objects = new ArrayList<S3ObjectSummary>();\n        ListObjectsRequest listObjectsRequest = new ListObjectsRequest().withBucketName(bucketName).withPrefix(directory + SEPARATOR);\n\n        ObjectListing ol = client.listObjects(listObjectsRequest);\n        while (ol != null && ol.isTruncated()) {\n            objects.addAll(ol.getObjectSummaries());\n            listObjectsRequest.setMarker(ol.getNextMarker());\n            ol = client.listObjects(listObjectsRequest);\n        }\n\n        if (objects.isEmpty()) {\n            return emptyList();\n        }\n\n        return unmodifiableList(objects);\n    }","commit_id":"04efdce9014ec60f7df8b77402b7dc39cc263ca4","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n  protected Response serve() {\n    JsonObject json = new JsonObject();\n\n    JsonArray succ = new JsonArray();\n    JsonArray fail = new JsonArray();\n    String bucket = _bucket.value();\n    AmazonS3 s3 = PersistS3.getClient();\n    for( S3ObjectSummary obj : s3.listObjects(bucket).getObjectSummaries() ) {\n      try {\n        Key k = PersistS3.loadKey(obj);\n        JsonObject o = new JsonObject();\n        o.addProperty(KEY, k.toString());\n        o.addProperty(FILE, obj.getKey());\n        o.addProperty(VALUE_SIZE, obj.getSize());\n        succ.add(o);\n      } catch( IOException e ) {\n        JsonObject o = new JsonObject();\n        o.addProperty(FILE, obj.getKey());\n        o.addProperty(ERROR, e.getMessage());\n        fail.add(o);\n      }\n    }\n    json.add(NUM_SUCCEEDED, new JsonPrimitive(succ.size()));\n    json.add(SUCCEEDED, succ);\n    json.add(NUM_FAILED, new JsonPrimitive(fail.size()));\n    json.add(FAILED, fail);\n    DKV.write_barrier();\n\n    Response r = Response.done(json);\n    r.setBuilder(SUCCEEDED + \".\" + KEY, new KeyCellBuilder());\n    return r;\n  }","id":83931,"modified_method":"@Override\n  protected Response serve() {\n    JsonObject json = new JsonObject();\n    JsonArray succ = new JsonArray();\n    JsonArray fail = new JsonArray();\n    String bucket = _bucket.value();\n    AmazonS3 s3 = PersistS3.getClient();\n    ObjectListing currentList = s3.listObjects(bucket);\n    processListing(currentList, succ, fail);\n    while(currentList.isTruncated()){\n      currentList = s3.listNextBatchOfObjects(currentList);\n      processListing(currentList, succ, fail);\n    }\n    json.add(NUM_SUCCEEDED, new JsonPrimitive(succ.size()));\n    json.add(SUCCEEDED, succ);\n    json.add(NUM_FAILED, new JsonPrimitive(fail.size()));\n    json.add(FAILED, fail);\n    DKV.write_barrier();\n    Response r = Response.done(json);\n    r.setBuilder(SUCCEEDED + \".\" + KEY, new KeyCellBuilder());\n    return r;\n  }","commit_id":"8420b73c10a088a4290494c8c0f9654cda8f901f","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n\tpublic void testReadOnlyTempFolderWithoutLog() {\n\t\tif (_shouldTest()) {\n\t\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tFIFOUtil.class.getName(), Level.OFF);\n\n\t\t\tFile tempFolder = new File(\"tempFolder\");\n\n\t\t\ttempFolder.mkdirs();\n\n\t\t\ttempFolder.setReadOnly();\n\n\t\t\tString oldTempFolder = System.getProperty(\"java.io.tmpdir\");\n\n\t\t\tSystem.setProperty(\"java.io.tmpdir\", tempFolder.getAbsolutePath());\n\n\t\t\ttry {\n\t\t\t\tAssert.assertFalse(FIFOUtil.isFIFOSupported());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tSystem.setProperty(\"java.io.tmpdir\", oldTempFolder);\n\t\t\t}\n\n\t\t\tAssert.assertTrue(logRecords.isEmpty());\n\t\t}\n\t}","id":83932,"modified_method":"@Test\n\tpublic void testReadOnlyTempFolderWithoutLog() {\n\t\tif (!_shouldTest()) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tFIFOUtil.class.getName(), Level.OFF);\n\n\t\tFile tempFolder = new File(\"tempFolder\");\n\n\t\ttempFolder.mkdirs();\n\n\t\ttempFolder.setReadOnly();\n\n\t\tString oldTempFolder = System.getProperty(\"java.io.tmpdir\");\n\n\t\tSystem.setProperty(\"java.io.tmpdir\", tempFolder.getAbsolutePath());\n\n\t\ttry {\n\t\t\tAssert.assertFalse(FIFOUtil.isFIFOSupported());\n\t\t}\n\t\tfinally {\n\t\t\tSystem.setProperty(\"java.io.tmpdir\", oldTempFolder);\n\t\t}\n\n\t\tAssert.assertTrue(logRecords.isEmpty());\n\t}","commit_id":"14dca8c8754c7d0e0f51671a8d755860d6e4749e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testReadOnlyTempFolderWithLog() {\n\t\tif (_shouldTest()) {\n\t\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\t\tFIFOUtil.class.getName(), Level.WARNING);\n\n\t\t\tFile tempFolder = new File(\"tempFolder\");\n\n\t\t\ttempFolder.mkdirs();\n\n\t\t\ttempFolder.setReadOnly();\n\n\t\t\tString oldTempFolder = System.getProperty(\"java.io.tmpdir\");\n\n\t\t\tSystem.setProperty(\"java.io.tmpdir\", tempFolder.getAbsolutePath());\n\n\t\t\ttry {\n\t\t\t\tAssert.assertFalse(FIFOUtil.isFIFOSupported());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tSystem.setProperty(\"java.io.tmpdir\", oldTempFolder);\n\t\t\t}\n\n\t\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to detect FIFO support\", logRecord.getMessage());\n\n\t\t\tThrowable throwable = logRecord.getThrown();\n\n\t\t\tAssert.assertEquals(Exception.class, throwable.getClass());\n\n\t\t\tString message = throwable.getMessage();\n\n\t\t\tAssert.assertTrue(\n\t\t\t\tmessage.startsWith(\n\t\t\t\t\t\"Unable to create FIFO with command \\\"mkfifo\\\", external \" +\n\t\t\t\t\t\t\"process returned \"));\n\t\t}\n\t}","id":83933,"modified_method":"@Test\n\tpublic void testReadOnlyTempFolderWithLog() {\n\t\tif (!_shouldTest()) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<LogRecord> logRecords = JDKLoggerTestUtil.configureJDKLogger(\n\t\t\tFIFOUtil.class.getName(), Level.WARNING);\n\n\t\tFile tempFolder = new File(\"tempFolder\");\n\n\t\ttempFolder.mkdirs();\n\n\t\ttempFolder.setReadOnly();\n\n\t\tString oldTempFolder = System.getProperty(\"java.io.tmpdir\");\n\n\t\tSystem.setProperty(\"java.io.tmpdir\", tempFolder.getAbsolutePath());\n\n\t\ttry {\n\t\t\tAssert.assertFalse(FIFOUtil.isFIFOSupported());\n\t\t}\n\t\tfinally {\n\t\t\tSystem.setProperty(\"java.io.tmpdir\", oldTempFolder);\n\t\t}\n\n\t\tAssert.assertEquals(1, logRecords.size());\n\n\t\tLogRecord logRecord = logRecords.get(0);\n\n\t\tAssert.assertEquals(\n\t\t\t\"Unable to detect FIFO support\", logRecord.getMessage());\n\n\t\tThrowable throwable = logRecord.getThrown();\n\n\t\tAssert.assertEquals(Exception.class, throwable.getClass());\n\n\t\tString message = throwable.getMessage();\n\n\t\tAssert.assertTrue(\n\t\t\tmessage.startsWith(\n\t\t\t\t\"Unable to create FIFO with command \\\"mkfifo\\\", external \" +\n\t\t\t\t\t\"process returned \"));\n\t}","commit_id":"14dca8c8754c7d0e0f51671a8d755860d6e4749e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testPhantomDeleteOnDetecting() {\n\t\tif (_shouldTest()) {\n\t\t\tfinal AtomicInteger checkDeleteCount = new AtomicInteger();\n\t\t\tfinal AtomicBoolean checkFlag = new AtomicBoolean();\n\n\t\t\tSecurityManager securityManager = new SecurityManager() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void checkDelete(String file) {\n\t\t\t\t\tif (!checkFlag.get() && file.contains(\"temp-fifo-\")) {\n\t\t\t\t\t\tcheckFlag.set(true);\n\n\t\t\t\t\t\tif (checkDeleteCount.getAndIncrement() == 0) {\n\t\t\t\t\t\t\tAssert.assertTrue(new File(file).delete());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcheckFlag.set(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void checkRead(String file) {\n\t\t\t\t\tif (!checkFlag.get() && file.contains(\"temp-fifo-\")) {\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcheckFlag.set(true);\n\n\t\t\t\t\t\t\tnew File(file).createNewFile();\n\n\t\t\t\t\t\t\tcheckFlag.set(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\t\tAssert.fail(ioe.getMessage());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void checkPermission(Permission permission) {\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tSystem.setSecurityManager(securityManager);\n\n\t\t\ttry {\n\t\t\t\tAssert.assertTrue(FIFOUtil.isFIFOSupported());\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tSystem.setSecurityManager(null);\n\t\t\t}\n\n\t\t\tAssert.assertEquals(2, checkDeleteCount.get());\n\t\t}\n\t}","id":83934,"modified_method":"@Test\n\tpublic void testPhantomDeleteOnDetecting() {\n\t\tif (!_shouldTest()) {\n\t\t\treturn;\n\t\t}\n\n\t\tfinal AtomicInteger checkDeleteCount = new AtomicInteger();\n\t\tfinal AtomicBoolean checkFlag = new AtomicBoolean();\n\n\t\tSecurityManager securityManager = new SecurityManager() {\n\n\t\t\t@Override\n\t\t\tpublic void checkDelete(String file) {\n\t\t\t\tif (!checkFlag.get() && file.contains(\"temp-fifo-\")) {\n\t\t\t\t\tcheckFlag.set(true);\n\n\t\t\t\t\tif (checkDeleteCount.getAndIncrement() == 0) {\n\t\t\t\t\t\tAssert.assertTrue(new File(file).delete());\n\t\t\t\t\t}\n\n\t\t\t\t\tcheckFlag.set(false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void checkRead(String file) {\n\t\t\t\tif (!checkFlag.get() && file.contains(\"temp-fifo-\")) {\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcheckFlag.set(true);\n\n\t\t\t\t\t\tnew File(file).createNewFile();\n\n\t\t\t\t\t\tcheckFlag.set(false);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\t\tAssert.fail(ioe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void checkPermission(Permission permission) {\n\t\t\t}\n\n\t\t};\n\n\t\tSystem.setSecurityManager(securityManager);\n\n\t\ttry {\n\t\t\tAssert.assertTrue(FIFOUtil.isFIFOSupported());\n\t\t}\n\t\tfinally {\n\t\t\tSystem.setSecurityManager(null);\n\t\t}\n\n\t\tAssert.assertEquals(2, checkDeleteCount.get());\n\t}","commit_id":"14dca8c8754c7d0e0f51671a8d755860d6e4749e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testCreateFIFOWithBrokenFile() throws Exception {\n\t\tif (_shouldTest()) {\n\t\t\ttry {\n\t\t\t\tFIFOUtil.createFIFO(\n\t\t\t\t\tnew File(\"\") {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic String getAbsolutePath() {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t});\n\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tcatch (NullPointerException npe) {\n\t\t\t}\n\t\t}\n\t}","id":83935,"modified_method":"@Test\n\tpublic void testCreateFIFOWithBrokenFile() throws Exception {\n\t\tif (!_shouldTest()) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tFIFOUtil.createFIFO(\n\t\t\t\tnew File(\"\") {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getAbsolutePath() {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (NullPointerException npe) {\n\t\t}\n\t}","commit_id":"14dca8c8754c7d0e0f51671a8d755860d6e4749e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static boolean _shouldTest() {\n\t\tif (OSDetector.isWindows()) {\n\t\t\t_log.warn(\"This test only runs on nonwindows OS\");\n\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}","id":83936,"modified_method":"private static boolean _shouldTest() {\n\t\tif (OSDetector.isWindows()) {\n\t\t\t_log.warn(\"This test only runs on nonwindows OS\");\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"14dca8c8754c7d0e0f51671a8d755860d6e4749e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testWeld() throws Exception {\n\n\t\t// Normal weld\n\n\t\tfinal FIFOWelder serverFifoWelder = new FIFOWelder();\n\t\tfinal FIFOWelder clientFIFOWelder = WelderTestUtil.transform(\n\t\t\tserverFifoWelder);\n\n\t\tFutureTask<MockRegistrationReference> serverWeldingTask =\n\t\t\tnew FutureTask<MockRegistrationReference>(\n\t\t\t\tnew Callable<MockRegistrationReference>() {\n\n\t\t\t\t\tpublic MockRegistrationReference call() throws Exception {\n\t\t\t\t\t\treturn (MockRegistrationReference)serverFifoWelder.weld(\n\t\t\t\t\t\t\tnew MockIntraBand());\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tnew Thread(serverWeldingTask).start();\n\n\t\tFutureTask<MockRegistrationReference> clientWeldingTask =\n\t\t\tnew FutureTask<MockRegistrationReference>(\n\t\t\t\tnew Callable<MockRegistrationReference>() {\n\n\t\t\t\t\tpublic MockRegistrationReference call() throws Exception {\n\t\t\t\t\t\treturn (MockRegistrationReference)clientFIFOWelder.weld(\n\t\t\t\t\t\t\tnew MockIntraBand());\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tnew Thread(clientWeldingTask).start();\n\n\t\tMockRegistrationReference serverMockRegistrationReference =\n\t\t\tserverWeldingTask.get();\n\n\t\tMockRegistrationReference clientMockRegistrationReference =\n\t\t\tclientWeldingTask.get();\n\n\t\tWelderTestUtil.assertConnectted(\n\t\t\tserverMockRegistrationReference.getScatteringByteChannel(),\n\t\t\tclientMockRegistrationReference.getGatheringByteChannel());\n\t\tWelderTestUtil.assertConnectted(\n\t\t\tclientMockRegistrationReference.getScatteringByteChannel(),\n\t\t\tserverMockRegistrationReference.getGatheringByteChannel());\n\n\t\tserverFifoWelder.destroy();\n\t\tclientFIFOWelder.destroy();\n\n\t\t// Weld on used Welder\n\n\t\ttry {\n\t\t\tserverFifoWelder.weld(new MockIntraBand());\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to weld a welder with state DESTROYED\",\n\t\t\t\tise.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tserverFifoWelder.inputFIFOFile.delete();\n\t\t\tserverFifoWelder.outputFIFOFile.delete();\n\t\t}\n\n\t\ttry {\n\t\t\tclientFIFOWelder.weld(new MockIntraBand());\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to weld a welder with state DESTROYED\",\n\t\t\t\tise.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tserverFifoWelder.inputFIFOFile.delete();\n\t\t\tserverFifoWelder.outputFIFOFile.delete();\n\t\t}\n\t}","id":83937,"modified_method":"@Test\n\tpublic void testWeld() throws Exception {\n\t\tfinal FIFOWelder serverFifoWelder = new FIFOWelder();\n\t\tfinal FIFOWelder clientFIFOWelder = WelderTestUtil.transform(\n\t\t\tserverFifoWelder);\n\n\t\tFutureTask<MockRegistrationReference> serverWeldingTask =\n\t\t\tnew FutureTask<MockRegistrationReference>(\n\t\t\t\tnew Callable<MockRegistrationReference>() {\n\n\t\t\t\t\tpublic MockRegistrationReference call() throws Exception {\n\t\t\t\t\t\treturn (MockRegistrationReference)serverFifoWelder.weld(\n\t\t\t\t\t\t\tnew MockIntraBand());\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tThread serverWeldingThread = new Thread(serverWeldingTask);\n\n\t\tserverWeldingThread.start();\n\n\t\tFutureTask<MockRegistrationReference> clientWeldingTask =\n\t\t\tnew FutureTask<MockRegistrationReference>(\n\t\t\t\tnew Callable<MockRegistrationReference>() {\n\n\t\t\t\t\tpublic MockRegistrationReference call() throws Exception {\n\t\t\t\t\t\treturn (MockRegistrationReference)clientFIFOWelder.weld(\n\t\t\t\t\t\t\tnew MockIntraBand());\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\tThread clientWeldingThread = new Thread(clientWeldingTask);\n\n\t\tclientWeldingThread.start();\n\n\t\tMockRegistrationReference serverMockRegistrationReference =\n\t\t\tserverWeldingTask.get();\n\n\t\tMockRegistrationReference clientMockRegistrationReference =\n\t\t\tclientWeldingTask.get();\n\n\t\tWelderTestUtil.assertConnectted(\n\t\t\tserverMockRegistrationReference.getScatteringByteChannel(),\n\t\t\tclientMockRegistrationReference.getGatheringByteChannel());\n\t\tWelderTestUtil.assertConnectted(\n\t\t\tclientMockRegistrationReference.getScatteringByteChannel(),\n\t\t\tserverMockRegistrationReference.getGatheringByteChannel());\n\n\t\tserverFifoWelder.destroy();\n\t\tclientFIFOWelder.destroy();\n\n\t\ttry {\n\t\t\tserverFifoWelder.weld(new MockIntraBand());\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to weld a welder with state DESTROYED\",\n\t\t\t\tise.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tserverFifoWelder.inputFIFOFile.delete();\n\t\t\tserverFifoWelder.outputFIFOFile.delete();\n\t\t}\n\n\t\ttry {\n\t\t\tclientFIFOWelder.weld(new MockIntraBand());\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (IllegalStateException ise) {\n\t\t\tAssert.assertEquals(\n\t\t\t\t\"Unable to weld a welder with state DESTROYED\",\n\t\t\t\tise.getMessage());\n\t\t}\n\t\tfinally {\n\t\t\tserverFifoWelder.inputFIFOFile.delete();\n\t\t\tserverFifoWelder.outputFIFOFile.delete();\n\t\t}\n\t}","commit_id":"14dca8c8754c7d0e0f51671a8d755860d6e4749e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void assertConnectted(\n\t\t\tfinal ScatteringByteChannel scatteringByteChannel,\n\t\t\tfinal GatheringByteChannel gatheringByteChannel)\n\t\tthrows Exception {\n\n\t\tRandom random = new Random();\n\n\t\tfinal byte[] data = new byte[1024 * 1024];\n\n\t\trandom.nextBytes(data);\n\n\t\tFutureTask<Void> writeFutureTask = new FutureTask<Void>(\n\t\t\tnew Callable<Void>() {\n\n\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\tByteBuffer byteBuffer = ByteBuffer.wrap(data);\n\n\t\t\t\t\twhile (byteBuffer.hasRemaining()) {\n\t\t\t\t\t\tgatheringByteChannel.write(byteBuffer);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t});\n\n\t\tFutureTask<byte[]> readFutureTask = new FutureTask<byte[]>(\n\t\t\tnew Callable<byte[]>() {\n\n\t\t\t\tpublic byte[] call() throws Exception {\n\t\t\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(data.length);\n\n\t\t\t\t\twhile (byteBuffer.hasRemaining()) {\n\t\t\t\t\t\tscatteringByteChannel.read(byteBuffer);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn byteBuffer.array();\n\t\t\t\t}\n\t\t\t});\n\n\t\tnew Thread(writeFutureTask).start();\n\t\tnew Thread(readFutureTask).start();\n\n\t\twriteFutureTask.get();\n\n\t\tAssert.assertArrayEquals(data, readFutureTask.get());\n\t}","id":83938,"modified_method":"public static void assertConnectted(\n\t\t\tfinal ScatteringByteChannel scatteringByteChannel,\n\t\t\tfinal GatheringByteChannel gatheringByteChannel)\n\t\tthrows Exception {\n\n\t\tRandom random = new Random();\n\n\t\tfinal byte[] data = new byte[1024 * 1024];\n\n\t\trandom.nextBytes(data);\n\n\t\tFutureTask<Void> writeFutureTask = new FutureTask<Void>(\n\t\t\tnew Callable<Void>() {\n\n\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\tByteBuffer byteBuffer = ByteBuffer.wrap(data);\n\n\t\t\t\t\twhile (byteBuffer.hasRemaining()) {\n\t\t\t\t\t\tgatheringByteChannel.write(byteBuffer);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t});\n\n\t\tThread writeThread = new Thread(writeFutureTask);\n\n\t\twriteThread.start();\n\n\t\tFutureTask<byte[]> readFutureTask = new FutureTask<byte[]>(\n\t\t\tnew Callable<byte[]>() {\n\n\t\t\t\tpublic byte[] call() throws Exception {\n\t\t\t\t\tByteBuffer byteBuffer = ByteBuffer.allocate(data.length);\n\n\t\t\t\t\twhile (byteBuffer.hasRemaining()) {\n\t\t\t\t\t\tscatteringByteChannel.read(byteBuffer);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn byteBuffer.array();\n\t\t\t\t}\n\t\t\t});\n\n\t\tThread readThread = new Thread(readFutureTask);\n\n\t\treadThread.start();\n\n\t\twriteFutureTask.get();\n\n\t\tAssert.assertArrayEquals(data, readFutureTask.get());\n\t}","commit_id":"14dca8c8754c7d0e0f51671a8d755860d6e4749e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void visitParameter(@NotNull PsiParameter parameter) {\n      super.visitParameter(parameter);\n      if (parameter.getType() instanceof PsiPrimitiveType ||\n          isNotNull(parameter) || isNullable(parameter)) {\n        return;\n      }\n      final PsiElement grandParent = parameter.getParent().getParent();\n      if (grandParent instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)grandParent;\n        if (method.getBody() != null) {\n\n          for (PsiReference reference : ReferencesSearch.search(parameter, new LocalSearchScope(method))) {\n            final PsiElement place = reference.getElement();\n            if (place instanceof PsiReferenceExpression) {\n              final PsiReferenceExpression expr = (PsiReferenceExpression)place;\n              if (PsiUtil.isAccessedForWriting(expr)) return;\n              final PsiElement parent = PsiTreeUtil.skipParentsOfType(expr, PsiParenthesizedExpression.class, PsiTypeCastExpression.class);\n              if (parent instanceof PsiBinaryExpression) {   //todo check if comparison operation\n                PsiExpression opposite = null;\n                final PsiExpression lOperand = ((PsiBinaryExpression)parent).getLOperand();\n                final PsiExpression rOperand = ((PsiBinaryExpression)parent).getROperand();\n                if (lOperand == expr) {\n                  opposite = rOperand;\n                }\n                else if (rOperand == expr) {\n                  opposite = lOperand;\n                }\n                if (opposite != null && opposite.getType() == PsiType.NULL) {\n                  registerNullableAnnotation(parameter);\n                  return;\n                }\n              }\n              else if (parent instanceof PsiReferenceExpression) {\n                if (((PsiReferenceExpression)parent).getQualifierExpression() == expr) {\n                  registerNotNullAnnotation(parameter);\n                  return;\n                }\n              }\n              else if (parent instanceof PsiAssignmentExpression) {\n                if (((PsiAssignmentExpression)parent).getRExpression() == expr) {\n                  final PsiExpression expression = ((PsiAssignmentExpression)parent).getLExpression();\n                  if (expression instanceof PsiReferenceExpression) {\n                    final PsiElement resolve = ((PsiReferenceExpression)expression).resolve();\n                    if (resolve instanceof PsiVariable) {\n                      final PsiVariable localVar = (PsiVariable)resolve;\n                      if (isNotNull(localVar)) {\n                        registerNotNullAnnotation(parameter);\n                        return;\n                      }\n                    }\n                  }\n                }\n              }\n\n              if (isNotNull(method)) {\n                PsiElement toReturn = parent;\n                if (parent instanceof PsiConditionalExpression &&\n                    ((PsiConditionalExpression)parent).getCondition() != expr) {  //todo check conditional operations\n                  toReturn = parent.getParent();\n                }\n                if (toReturn instanceof PsiReturnStatement) {\n                  registerNotNullAnnotation(parameter);\n                  return;\n                }\n              }\n\n              final PsiCall call = PsiTreeUtil.getParentOfType(expr, PsiCall.class);\n              if (call != null) {\n                final PsiExpressionList argumentList = call.getArgumentList();\n                if (argumentList != null) {\n                  final PsiExpression[] args = argumentList.getExpressions();\n                  int idx = ArrayUtil.find(args, expr);\n                  if (idx >= 0) {\n                    final PsiMethod resolvedMethod = call.resolveMethod();\n                    if (resolvedMethod != null) {\n                      final PsiParameter[] parameters = resolvedMethod.getParameterList().getParameters();\n                      if (idx < parameters.length) { //not vararg\n                        final PsiParameter resolvedToParam = parameters[idx];\n                        if (isNotNull(resolvedToParam) && !resolvedToParam.isVarArgs()) {\n                          registerNotNullAnnotation(parameter);\n                          return;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      else {\n        if (variableNeverAssignedNull(parameter)) {\n          if (myAnnotateLocalVariables) {\n            registerNotNullAnnotation(parameter);\n          }\n          else {\n            myNotNullSet.add(myPointerManager.createLazyPointer((PsiModifierListOwner)parameter));\n            numAnnotationsAdded++;\n          }\n        }\n        if (variableSometimesAssignedNull(parameter)) {\n          if (myAnnotateLocalVariables) {\n            registerNullableAnnotation(parameter);\n          }\n          else {\n            myNullableSet.add(myPointerManager.createLazyPointer((PsiModifierListOwner)parameter));\n            numAnnotationsAdded++;\n          }\n        }\n      }\n    }","id":83939,"modified_method":"@Override\n    public void visitParameter(@NotNull PsiParameter parameter) {\n      super.visitParameter(parameter);\n      if (parameter.getType() instanceof PsiPrimitiveType ||\n          isNotNull(parameter) || isNullable(parameter)) {\n        return;\n      }\n      final PsiElement grandParent = parameter.getParent().getParent();\n      if (grandParent instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)grandParent;\n        if (method.getBody() != null) {\n\n          for (PsiReference reference : ReferencesSearch.search(parameter, new LocalSearchScope(method))) {\n            final PsiElement place = reference.getElement();\n            if (place instanceof PsiReferenceExpression) {\n              final PsiReferenceExpression expr = (PsiReferenceExpression)place;\n              if (PsiUtil.isAccessedForWriting(expr)) return;\n              final PsiElement parent = PsiTreeUtil.skipParentsOfType(expr, PsiParenthesizedExpression.class, PsiTypeCastExpression.class);\n              if (parent instanceof PsiBinaryExpression) {   //todo check if comparison operation\n                PsiExpression opposite = null;\n                final PsiExpression lOperand = ((PsiBinaryExpression)parent).getLOperand();\n                final PsiExpression rOperand = ((PsiBinaryExpression)parent).getROperand();\n                if (lOperand == expr) {\n                  opposite = rOperand;\n                }\n                else if (rOperand == expr) {\n                  opposite = lOperand;\n                }\n                if (opposite != null && opposite.getType() == PsiType.NULL) {\n                  registerNullableAnnotation(parameter);\n                  return;\n                }\n              }\n              else if (parent instanceof PsiReferenceExpression) {\n                if (((PsiReferenceExpression)parent).getQualifierExpression() == expr) {\n                  registerNotNullAnnotation(parameter);\n                  return;\n                }\n              }\n              else if (parent instanceof PsiAssignmentExpression) {\n                if (((PsiAssignmentExpression)parent).getRExpression() == expr) {\n                  final PsiExpression expression = ((PsiAssignmentExpression)parent).getLExpression();\n                  if (expression instanceof PsiReferenceExpression) {\n                    final PsiElement resolve = ((PsiReferenceExpression)expression).resolve();\n                    if (resolve instanceof PsiVariable) {\n                      final PsiVariable localVar = (PsiVariable)resolve;\n                      if (isNotNull(localVar)) {\n                        registerNotNullAnnotation(parameter);\n                        return;\n                      }\n                    }\n                  }\n                }\n              }\n\n              if (isNotNull(method)) {\n                PsiElement toReturn = parent;\n                if (parent instanceof PsiConditionalExpression &&\n                    ((PsiConditionalExpression)parent).getCondition() != expr) {  //todo check conditional operations\n                  toReturn = parent.getParent();\n                }\n                if (toReturn instanceof PsiReturnStatement) {\n                  registerNotNullAnnotation(parameter);\n                  return;\n                }\n              }\n\n              final PsiCall call = PsiTreeUtil.getParentOfType(expr, PsiCall.class);\n              if (call != null) {\n                final PsiExpressionList argumentList = call.getArgumentList();\n                if (argumentList != null) {\n                  final PsiExpression[] args = argumentList.getExpressions();\n                  int idx = ArrayUtil.find(args, expr);\n                  if (idx >= 0) {\n                    final PsiMethod resolvedMethod = call.resolveMethod();\n                    if (resolvedMethod != null) {\n                      final PsiParameter[] parameters = resolvedMethod.getParameterList().getParameters();\n                      if (idx < parameters.length) { //not vararg\n                        final PsiParameter resolvedToParam = parameters[idx];\n                        if (isNotNull(resolvedToParam) && !resolvedToParam.isVarArgs()) {\n                          registerNotNullAnnotation(parameter);\n                          return;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      else {\n        if (variableNeverAssignedNull(parameter)) {\n          registerNotNullAnnotation(parameter);\n        }\n        if (variableSometimesAssignedNull(parameter)) {\n          registerNullableAnnotation(parameter);\n        }\n      }\n    }","commit_id":"58eae8963e1b0f6e4242f3a081aa1e5f3c30da01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitLocalVariable(@NotNull PsiLocalVariable variable) {\n      super.visitLocalVariable(variable);\n      if (variable.getType() instanceof PsiPrimitiveType ||\n          isNotNull(variable) || isNullable(variable)) {\n        return;\n      }\n\n      final SmartPsiElementPointer<PsiModifierListOwner> pointer = myPointerManager.createLazyPointer((PsiModifierListOwner)variable);\n      if (variableNeverAssignedNull(variable)) {\n        if (myAnnotateLocalVariables) {\n          registerNotNullAnnotation(variable);\n        }\n        else {\n          myNotNullSet.add(pointer);\n          numAnnotationsAdded++;\n        }\n      }\n      if (variableSometimesAssignedNull(variable)) {\n        if (myAnnotateLocalVariables) {\n          registerNullableAnnotation(variable);\n        }\n        else {\n          myNullableSet.add(pointer);\n          numAnnotationsAdded++;\n        }\n      }\n    }","id":83940,"modified_method":"@Override\n    public void visitLocalVariable(@NotNull PsiLocalVariable variable) {\n      super.visitLocalVariable(variable);\n      if (variable.getType() instanceof PsiPrimitiveType ||\n          isNotNull(variable) || isNullable(variable)) {\n        return;\n      }\n\n      if (variableNeverAssignedNull(variable)) {\n        registerNotNullAnnotation(variable);\n      }\n      if (variableSometimesAssignedNull(variable)) {\n        registerNullableAnnotation(variable);\n      }\n    }","commit_id":"58eae8963e1b0f6e4242f3a081aa1e5f3c30da01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitAssignmentExpression(@NotNull PsiAssignmentExpression expression) {\n      sometimesNull = expressionIsSometimesNull(expression.getRExpression());\n    }","id":83941,"modified_method":"@Override\n    public void visitAssignmentExpression(@NotNull PsiAssignmentExpression expression) {\n      super.visitExpression(expression.getRExpression());\n    }","commit_id":"58eae8963e1b0f6e4242f3a081aa1e5f3c30da01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitConditionalExpression(@NotNull PsiConditionalExpression expression) {\n      sometimesNull = expressionIsSometimesNull(expression.getThenExpression()) ||\n                      expressionIsSometimesNull(expression.getElseExpression());\n    }","id":83942,"modified_method":"@Override\n    public void visitConditionalExpression(@NotNull PsiConditionalExpression expression) {\n      super.visitExpression(expression.getThenExpression());\n      super.visitExpression(expression.getElseExpression());\n    }","commit_id":"58eae8963e1b0f6e4242f3a081aa1e5f3c30da01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void collect(@NotNull PsiFile file) {\n    int prevNumAnnotationsAdded;\n    int pass = 0;\n    do {\n      final JavaRecursiveElementVisitor visitor = new NullityInferrerVisitor();\n      prevNumAnnotationsAdded = numAnnotationsAdded;\n      file.accept(visitor);\n      pass++;\n    }\n    while (prevNumAnnotationsAdded < numAnnotationsAdded && pass < MAX_PASSES);\n  }","id":83943,"modified_method":"public void collect(@NotNull PsiFile file) {\n    int prevNumAnnotationsAdded;\n    int pass = 0;\n    do {\n      final NullityInferrerVisitor visitor = new NullityInferrerVisitor();\n      prevNumAnnotationsAdded = numAnnotationsAdded;\n      file.accept(visitor);\n      pass++;\n    }\n    while (prevNumAnnotationsAdded < numAnnotationsAdded && pass < MAX_PASSES);\n  }","commit_id":"58eae8963e1b0f6e4242f3a081aa1e5f3c30da01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isNotNull(PsiModifierListOwner owner) {\n    return AnnotationUtil.isNotNull(owner) || myNotNullSet.contains(myPointerManager.createLazyPointer(owner));\n  }","id":83944,"modified_method":"private boolean isNotNull(PsiModifierListOwner owner) {\n    if (AnnotationUtil.isNotNull(owner)) {\n      return true;\n    }\n    final SmartPsiElementPointer<PsiModifierListOwner> pointer = myPointerManager.createLazyPointer(owner);\n    return myNotNullSet.contains(pointer);\n  }","commit_id":"58eae8963e1b0f6e4242f3a081aa1e5f3c30da01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isNullable(PsiModifierListOwner owner) {\n    return AnnotationUtil.isNullable(owner) || myNullableSet.contains(myPointerManager.createLazyPointer(owner));\n  }","id":83945,"modified_method":"private boolean isNullable(PsiModifierListOwner owner) {\n    if (AnnotationUtil.isNullable(owner)) {\n      return true;\n    }\n    final SmartPsiElementPointer<PsiModifierListOwner> pointer = myPointerManager.createLazyPointer(owner);\n    return myNullableSet.contains(pointer);\n  }","commit_id":"58eae8963e1b0f6e4242f3a081aa1e5f3c30da01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitReferenceExpression(@NotNull PsiReferenceExpression expression) {\n      final PsiElement referent = expression.resolve();\n      if (referent instanceof PsiVariable) {\n        final PsiVariable var = (PsiVariable)referent;\n        if (myNotNullSet.contains(myPointerManager.createLazyPointer(var)) ||\n            var instanceof PsiEnumConstant ||\n            NullityInferrer.this.isNotNull(var)) {\n          neverNull = true;\n          return;\n        }\n      }\n      neverNull = false;\n    }","id":83946,"modified_method":"@Override\n    public void visitReferenceExpression(@NotNull PsiReferenceExpression expression) {\n      final PsiElement referent = expression.resolve();\n      if (referent instanceof PsiVariable) {\n        final PsiVariable var = (PsiVariable)referent;\n        if (var instanceof PsiEnumConstant || isNotNull(var)) {\n          neverNull = true;\n          return;\n        }\n      }\n      neverNull = false;\n    }","commit_id":"58eae8963e1b0f6e4242f3a081aa1e5f3c30da01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitReferenceExpression(@NotNull PsiReferenceExpression expression) {\n      final PsiElement referent = expression.resolve();\n      if (referent instanceof PsiVariable) {\n        final PsiVariable var = (PsiVariable)referent;\n        if (myNullableSet.contains(myPointerManager.createLazyPointer(var)) || isNullable(var)) {\n          sometimesNull = true;\n        }\n      }\n    }","id":83947,"modified_method":"@Override\n    public void visitReferenceExpression(@NotNull PsiReferenceExpression expression) {\n      final PsiElement referent = expression.resolve();\n      if (referent instanceof PsiVariable) {\n        final PsiVariable var = (PsiVariable)referent;\n        if (isNullable(var)) {\n          sometimesNull = true;\n        }\n      }\n    }","commit_id":"58eae8963e1b0f6e4242f3a081aa1e5f3c30da01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * A work-around of the generic nullability problem in the type checker\n     * @return true if a value of this type can be null\n     */\n    public static boolean isNullableType(@NotNull JetType type) {\n        if (type.getConstructor().getDeclarationDescriptor() instanceof TypeParameterDescriptor) {\n            return TypeUtils.hasNullableSuperType(type);\n        }\n        return type.isNullable();\n    }","id":83948,"modified_method":"/**\n     * A work-around of the generic nullability problem in the type checker\n     * @return true if a value of this type can be null\n     */\n    public static boolean isNullableType(@NotNull JetType type) {\n        if (type.isNullable()) {\n            return true;\n        }\n        if (type.getConstructor().getDeclarationDescriptor() instanceof TypeParameterDescriptor) {\n            return TypeUtils.hasNullableSuperType(type);\n        }\n        return false;\n    }","commit_id":"1f8d42ab498c2f5a4c653d29119b6b37763d4ac4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void updateWorkflowDefinition(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadPortletRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tMap<Locale, String> titleMap = LocalizationUtil.getLocalizationMap(\n\t\t\tactionRequest, \"title\");\n\n\t\tFile file = uploadPortletRequest.getFile(\"file\");\n\n\t\tWorkflowDefinition workflowDefinition = null;\n\n\t\tif (!file.exists()) {\n\t\t\tString name = ParamUtil.getString(actionRequest, \"name\");\n\t\t\tint version = ParamUtil.getInteger(actionRequest, \"version\");\n\n\t\t\tworkflowDefinition =\n\t\t\t\tWorkflowDefinitionManagerUtil.getWorkflowDefinition(\n\t\t\t\t\tthemeDisplay.getCompanyId(), name, version);\n\n\t\t\tWorkflowDefinitionManagerUtil.updateTitle(\n\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(), name,\n\t\t\t\tversion, getTitle(titleMap));\n\t\t}\n\t\telse {\n\t\t\tworkflowDefinition =\n\t\t\t\tWorkflowDefinitionManagerUtil.deployWorkflowDefinition(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\tgetTitle(titleMap), new FileInputStream(file));\n\t\t}\n\n\t\tactionRequest.setAttribute(\n\t\t\tWebKeys.WORKFLOW_DEFINITION, workflowDefinition);\n\t}","id":83949,"modified_method":"protected void updateWorkflowDefinition(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tUploadPortletRequest uploadPortletRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tMap<Locale, String> titleMap = LocalizationUtil.getLocalizationMap(\n\t\t\tactionRequest, \"title\");\n\n\t\tInputStream inputStream = null;\n\n\t\ttry {\n\t\t\tinputStream = uploadPortletRequest.getFileAsStream(\"file\");\n\n\t\t\tWorkflowDefinition workflowDefinition = null;\n\n\t\t\tif (inputStream != null) {\n\t\t\t\tString name = ParamUtil.getString(actionRequest, \"name\");\n\t\t\t\tint version = ParamUtil.getInteger(actionRequest, \"version\");\n\n\t\t\t\tworkflowDefinition =\n\t\t\t\t\tWorkflowDefinitionManagerUtil.getWorkflowDefinition(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(), name, version);\n\n\t\t\t\tWorkflowDefinitionManagerUtil.updateTitle(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(), name,\n\t\t\t\t\tversion, getTitle(titleMap));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tworkflowDefinition =\n\t\t\t\t\tWorkflowDefinitionManagerUtil.deployWorkflowDefinition(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\t\tgetTitle(titleMap), inputStream);\n\t\t\t}\n\n\t\t\tactionRequest.setAttribute(\n\t\t\t\tWebKeys.WORKFLOW_DEFINITION, workflowDefinition);\n\t\t}\n\t\tfinally {\n\t\t\tif (inputStream != null) {\n\t\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"0da6a4c63b19f21156a84ba5f047a5809fb25c7f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tupdateWorkflowDefinition(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DEACTIVATE) ||\n\t\t\t\t\t cmd.equals(Constants.DELETE) ||\n\t\t\t\t\t cmd.equals(Constants.RESTORE)) {\n\n\t\t\t\tdeleteWorkflowDefinition(actionRequest);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof FileNotFoundException ||\n\t\t\t\te instanceof WorkflowDefinitionFileException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t\t}\n\t\t\telse if (e instanceof WorkflowException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.workflow_definitions.error\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":83950,"modified_method":"@Override\n\tpublic void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tupdateWorkflowDefinition(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DEACTIVATE) ||\n\t\t\t\t\t cmd.equals(Constants.DELETE) ||\n\t\t\t\t\t cmd.equals(Constants.RESTORE)) {\n\n\t\t\t\tdeleteWorkflowDefinition(actionRequest);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof WorkflowDefinitionFileException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t\t}\n\t\t\telse if (e instanceof WorkflowException) {\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.workflow_definitions.error\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"0da6a4c63b19f21156a84ba5f047a5809fb25c7f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected MissingReferences validateFile(\n\t\t\tActionRequest actionRequest, File file)\n\t\tthrows Exception {\n\n\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\n\t\tPortlet portlet = ActionUtil.getPortlet(actionRequest);\n\n\t\treturn LayoutServiceUtil.validateImportPortletInfo(\n\t\t\tplid, groupId, portlet.getPortletId(),\n\t\t\tactionRequest.getParameterMap(), file);\n\t}","id":83951,"modified_method":"@Override\n\tprotected MissingReferences validateFile(\n\t\t\tActionRequest actionRequest, InputStream inputStream)\n\t\tthrows Exception {\n\n\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\n\t\tPortlet portlet = ActionUtil.getPortlet(actionRequest);\n\n\t\treturn LayoutServiceUtil.validateImportPortletInfo(\n\t\t\tplid, groupId, portlet.getPortletId(),\n\t\t\tactionRequest.getParameterMap(), inputStream);\n\t}","commit_id":"e0d7fdea3244d469be8a73d9c031caac179d196b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void importData(ActionRequest actionRequest, File file)\n\t\tthrows Exception {\n\n\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\n\t\tPortlet portlet = ActionUtil.getPortlet(actionRequest);\n\n\t\tLayoutServiceUtil.importPortletInfoInBackground(\n\t\t\tportlet.getPortletId(), plid, groupId, portlet.getPortletId(),\n\t\t\tactionRequest.getParameterMap(), file);\n\t}","id":83952,"modified_method":"@Override\n\tprotected void importData(\n\t\t\tActionRequest actionRequest, InputStream inputStream,\n\t\t\tString fileName)\n\t\tthrows Exception {\n\n\t\tlong plid = ParamUtil.getLong(actionRequest, \"plid\");\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\n\t\tPortlet portlet = ActionUtil.getPortlet(actionRequest);\n\n\t\tLayoutServiceUtil.importPortletInfoInBackground(\n\t\t\tportlet.getPortletId(), plid, groupId, portlet.getPortletId(),\n\t\t\tactionRequest.getParameterMap(), inputStream);\n\t}","commit_id":"e0d7fdea3244d469be8a73d9c031caac179d196b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic ManifestSummary getManifestSummary(\n\t\t\tlong userId, long groupId, Map<String, String[]> parameterMap,\n\t\t\tFileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tFile file = DLFileEntryLocalServiceUtil.getFile(\n\t\t\tuserId, fileEntry.getFileEntryId(), fileEntry.getVersion(), false);\n\t\tFile newFile = null;\n\t\tboolean rename = false;\n\n\t\tManifestSummary manifestSummary = null;\n\n\t\ttry {\n\t\t\tString newFileName = StringUtil.replace(\n\t\t\t\tfile.getPath(), file.getName(), fileEntry.getTitle());\n\n\t\t\tnewFile = new File(newFileName);\n\n\t\t\trename = file.renameTo(newFile);\n\n\t\t\tif (!rename) {\n\t\t\t\tnewFile = FileUtil.createTempFile(fileEntry.getExtension());\n\n\t\t\t\tFileUtil.copyFile(file, newFile);\n\t\t\t}\n\n\t\t\tmanifestSummary = getManifestSummary(\n\t\t\t\tuserId, groupId, parameterMap, newFile);\n\t\t}\n\t\tfinally {\n\t\t\tif (rename) {\n\t\t\t\tnewFile.renameTo(file);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileUtil.delete(newFile);\n\t\t\t}\n\t\t}\n\n\t\treturn manifestSummary;\n\t}","id":83953,"modified_method":"@Override\n\tpublic ManifestSummary getManifestSummary(\n\t\t\tlong userId, long groupId, Map<String, String[]> parameterMap,\n\t\t\tFileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tInputStream inputStream = DLFileEntryLocalServiceUtil.getFileAsStream(\n\t\t\tuserId, fileEntry.getFileEntryId(), fileEntry.getVersion(), false);\n\n\t\tFile file = FileUtil.createTempFile(\"lar\");\n\n\t\tManifestSummary manifestSummary = null;\n\n\t\ttry {\n\t\t\tFileUtil.write(file, inputStream);\n\n\t\t\tmanifestSummary = getManifestSummary(\n\t\t\t\tuserId, groupId, parameterMap, file);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t\tFileUtil.delete(file);\n\t\t}\n\n\t\treturn manifestSummary;\n\t}","commit_id":"e0d7fdea3244d469be8a73d9c031caac179d196b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importData(ActionRequest actionRequest, File file)\n\t\tthrows Exception {\n\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"privateLayout\");\n\n\t\tLayoutServiceUtil.importLayoutsInBackground(\n\t\t\tfile.getName(), groupId, privateLayout,\n\t\t\tactionRequest.getParameterMap(), file);\n\t}","id":83954,"modified_method":"protected void importData(\n\t\t\tActionRequest actionRequest, InputStream inputStream,\n\t\t\tString fileName)\n\t\tthrows Exception {\n\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"privateLayout\");\n\n\t\tLayoutServiceUtil.importLayoutsInBackground(\n\t\t\tfileName, groupId, privateLayout, actionRequest.getParameterMap(),\n\t\t\tinputStream);\n\t}","commit_id":"e0d7fdea3244d469be8a73d9c031caac179d196b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importData(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse,\n\t\t\tString folderName)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\n\t\tFileEntry fileEntry = ExportImportHelperUtil.getTempFileEntry(\n\t\t\tgroupId, themeDisplay.getUserId(), folderName);\n\n\t\tFile file = DLFileEntryLocalServiceUtil.getFile(\n\t\t\tthemeDisplay.getUserId(), fileEntry.getFileEntryId(),\n\t\t\tfileEntry.getVersion(), false);\n\n\t\tif ((file == null) || !file.exists()) {\n\t\t\tthrow new LARFileException(\"Import file does not exist\");\n\t\t}\n\n\t\tboolean successfulRename = false;\n\n\t\tFile newFile = null;\n\n\t\ttry {\n\t\t\tString newFileName = StringUtil.replace(\n\t\t\t\tfile.getPath(), file.getName(), fileEntry.getTitle());\n\n\t\t\tnewFile = new File(newFileName);\n\n\t\t\tsuccessfulRename = file.renameTo(newFile);\n\n\t\t\tif (!successfulRename) {\n\t\t\t\tnewFile = FileUtil.createTempFile(fileEntry.getExtension());\n\n\t\t\t\tFileUtil.copyFile(file, newFile);\n\t\t\t}\n\n\t\t\timportData(actionRequest, newFile);\n\n\t\t\tdeleteTempFileEntry(groupId, folderName);\n\n\t\t\taddSuccessMessage(actionRequest, actionResponse);\n\t\t}\n\t\tfinally {\n\t\t\tif (successfulRename) {\n\t\t\t\tsuccessfulRename = newFile.renameTo(file);\n\n\t\t\t\tif (!successfulRename) {\n\t\t\t\t\tFileUtil.copyFile(newFile, file);\n\n\t\t\t\t\tFileUtil.delete(newFile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileUtil.delete(newFile);\n\t\t\t}\n\t\t}\n\t}","id":83955,"modified_method":"protected void importData(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse,\n\t\t\tString folderName)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\n\t\tFileEntry fileEntry = ExportImportHelperUtil.getTempFileEntry(\n\t\t\tgroupId, themeDisplay.getUserId(), folderName);\n\n\t\tInputStream inputStream = null;\n\n\t\ttry {\n\t\t\tinputStream = DLFileEntryLocalServiceUtil.getFileAsStream(\n\t\t\t\tthemeDisplay.getUserId(), fileEntry.getFileEntryId(),\n\t\t\t\tfileEntry.getVersion(), false);\n\n\t\t\timportData(actionRequest, inputStream, fileEntry.getTitle());\n\n\t\t\tdeleteTempFileEntry(groupId, folderName);\n\n\t\t\taddSuccessMessage(actionRequest, actionResponse);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\t}","commit_id":"e0d7fdea3244d469be8a73d9c031caac179d196b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected MissingReferences validateFile(\n\t\t\tActionRequest actionRequest, File file)\n\t\tthrows Exception {\n\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"privateLayout\");\n\n\t\treturn LayoutServiceUtil.validateImportLayoutsFile(\n\t\t\tgroupId, privateLayout, actionRequest.getParameterMap(), file);\n\t}","id":83956,"modified_method":"protected MissingReferences validateFile(\n\t\t\tActionRequest actionRequest, InputStream inputStream)\n\t\tthrows Exception {\n\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\tactionRequest, \"privateLayout\");\n\n\t\treturn LayoutServiceUtil.validateImportLayoutsFile(\n\t\t\tgroupId, privateLayout, actionRequest.getParameterMap(),\n\t\t\tinputStream);\n\t}","commit_id":"e0d7fdea3244d469be8a73d9c031caac179d196b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validateFile(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse,\n\t\t\tString folderName)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\n\t\tFileEntry fileEntry = ExportImportHelperUtil.getTempFileEntry(\n\t\t\tgroupId, themeDisplay.getUserId(), folderName);\n\n\t\tFile file = DLFileEntryLocalServiceUtil.getFile(\n\t\t\tthemeDisplay.getUserId(), fileEntry.getFileEntryId(),\n\t\t\tfileEntry.getVersion(), false);\n\n\t\tif ((file == null) || !file.exists()) {\n\t\t\tthrow new LARFileException(\"Import file does not exist\");\n\t\t}\n\n\t\tboolean successfulRename = false;\n\n\t\tFile newFile = null;\n\n\t\ttry {\n\t\t\tString newFileName = StringUtil.replace(\n\t\t\t\tfile.getPath(), file.getName(), fileEntry.getTitle());\n\n\t\t\tnewFile = new File(newFileName);\n\n\t\t\tsuccessfulRename = file.renameTo(newFile);\n\n\t\t\tif (!successfulRename) {\n\t\t\t\tnewFile = FileUtil.createTempFile(fileEntry.getExtension());\n\n\t\t\t\tFileUtil.copyFile(file, newFile);\n\t\t\t}\n\n\t\t\tMissingReferences missingReferences = validateFile(\n\t\t\t\tactionRequest, newFile);\n\n\t\t\tMap<String, MissingReference> weakMissingReferences =\n\t\t\t\tmissingReferences.getWeakMissingReferences();\n\n\t\t\tif (weakMissingReferences.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tif ((weakMissingReferences != null) &&\n\t\t\t\t(weakMissingReferences.size() > 0)) {\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"warningMessages\",\n\t\t\t\t\tStagingUtil.getWarningMessagesJSONArray(\n\t\t\t\t\t\tthemeDisplay.getLocale(), weakMissingReferences, null));\n\t\t\t}\n\n\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t}\n\t\tfinally {\n\t\t\tif (successfulRename) {\n\t\t\t\tsuccessfulRename = newFile.renameTo(file);\n\n\t\t\t\tif (!successfulRename) {\n\t\t\t\t\tFileUtil.copyFile(newFile, file);\n\n\t\t\t\t\tFileUtil.delete(newFile);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileUtil.delete(newFile);\n\t\t\t}\n\t\t}\n\t}","id":83957,"modified_method":"protected void validateFile(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse,\n\t\t\tString folderName)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = ParamUtil.getLong(actionRequest, \"groupId\");\n\n\t\tFileEntry fileEntry = ExportImportHelperUtil.getTempFileEntry(\n\t\t\tgroupId, themeDisplay.getUserId(), folderName);\n\n\t\tInputStream inputStream = null;\n\n\t\ttry {\n\t\t\tinputStream = DLFileEntryLocalServiceUtil.getFileAsStream(\n\t\t\t\tthemeDisplay.getUserId(), fileEntry.getFileEntryId(),\n\t\t\t\tfileEntry.getVersion(), false);\n\n\t\t\tboolean privateLayout = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"privateLayout\");\n\n\t\t\tMissingReferences missingReferences = validateFile(\n\t\t\t\tactionRequest, inputStream);\n\n\t\t\tMap<String, MissingReference> weakMissingReferences =\n\t\t\t\tmissingReferences.getWeakMissingReferences();\n\n\t\t\tif (weakMissingReferences.isEmpty()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tif ((weakMissingReferences != null) &&\n\t\t\t\t(weakMissingReferences.size() > 0)) {\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"warningMessages\",\n\t\t\t\t\tStagingUtil.getWarningMessagesJSONArray(\n\t\t\t\t\t\tthemeDisplay.getLocale(), weakMissingReferences, null));\n\t\t\t}\n\n\t\t\twriteJSON(actionRequest, actionResponse, jsonObject);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.cleanUp(inputStream);\n\t\t}\n\t}","commit_id":"e0d7fdea3244d469be8a73d9c031caac179d196b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void dispatch(BaseCmd cmd, Map<String, String> params) {\n        boolean success = false;\n        String errorMsg = \"\";\n        setupParameters(cmd, params);\n        try {\n            if(cmd instanceof BaseAsyncCmd){\n                ((BaseAsyncCmd)cmd).saveStartedEvent();\n            }\n            cmd.execute();\n            success = true;\n        } catch (Throwable t) {\n            if (t instanceof  InvalidParameterValueException || t instanceof IllegalArgumentException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Parameter error\";\n                throw new ServerApiException(BaseCmd.PARAM_ERROR, t.getMessage());\n            }else if (t instanceof PermissionDeniedException) {\n                s_logger.info(\"PermissionDenied: \" + t.getMessage());\n                errorMsg = \"Permission denied\";\n                throw new ServerApiException(BaseCmd.ACCOUNT_ERROR, t.getMessage());\n            }else if (t instanceof AccountLimitException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Account resource limit error\";\n                throw new ServerApiException(BaseCmd.ACCOUNT_RESOURCE_LIMIT_ERROR, t.getMessage());\n            }else if (t instanceof InsufficientCapacityException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Insufficient capacity\";\n                throw new ServerApiException(BaseCmd.INSUFFICIENT_CAPACITY_ERROR, t.getMessage());\n            }else if (t instanceof ResourceAllocationException) {\n                s_logger.warn(\"Exception: \", t);\n                errorMsg = \"Resource allocation error\";\n                throw new ServerApiException(BaseCmd.RESOURCE_ALLOCATION_ERROR, t.getMessage());\n            }else if (t instanceof ResourceUnavailableException) {\n                s_logger.warn(\"Exception: \", t);\n                errorMsg = \"Resource unavailable error\";\n                throw new ServerApiException(BaseCmd.RESOURCE_UNAVAILABLE_ERROR, t.getMessage());\n            }else if (t instanceof ServerApiException) {\n                errorMsg = ((ServerApiException) t).getDescription();\n                s_logger.warn(t.getClass()  + \" : \" + ((ServerApiException) t).getDescription());\n                throw new ServerApiException(((ServerApiException) t).getErrorCode(), ((ServerApiException) t).getDescription());\n            } else if (t instanceof AsyncCommandQueued) {\n                throw (AsyncCommandQueued)t;\n            }else {\n                errorMsg = \"Internal error\";\n                s_logger.error(\"Exception while executing \" + cmd.getClass().getSimpleName() + \":\", t);\n                if (UserContext.current().getAccount() == null || UserContext.current().getAccount().getType() == Account.ACCOUNT_TYPE_ADMIN)\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, t.getMessage());\n                else\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, BaseCmd.USER_ERROR_MESSAGE);\n            }\n        } finally {\n            if(cmd instanceof BaseAsyncCmd){\n                BaseAsyncCmd asyncCmd = (BaseAsyncCmd)cmd;\n                if(success){\n                    asyncCmd.saveCompletedEvent(EventVO.LEVEL_INFO, asyncCmd.getEventDescription()+\" completed successfully\");\n                } else {\n                    asyncCmd.saveCompletedEvent(EventVO.LEVEL_ERROR, asyncCmd.getEventDescription()+\" failed. \"+errorMsg);\n                }            \n            }\n        }\n    }","id":83958,"modified_method":"public void dispatch(BaseCmd cmd, Map<String, String> params) {\n        boolean success = false;\n        String errorMsg = \"\";\n        setupParameters(cmd, params);\n        try {\n            if(cmd instanceof BaseAsyncCmd){\n                ((BaseAsyncCmd)cmd).saveStartedEvent();\n            }\n            cmd.execute();\n            success = true;\n        } catch (Throwable t) {\n            if (t instanceof  InvalidParameterValueException || t instanceof IllegalArgumentException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Parameter error\";\n                throw new ServerApiException(BaseCmd.PARAM_ERROR, t.getMessage());\n            } else if (t instanceof PermissionDeniedException) {\n                s_logger.info(\"PermissionDenied: \" + t.getMessage());\n                errorMsg = \"Permission denied\";\n                throw new ServerApiException(BaseCmd.ACCOUNT_ERROR, t.getMessage());\n            } else if (t instanceof AccountLimitException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Account resource limit error\";\n                throw new ServerApiException(BaseCmd.ACCOUNT_RESOURCE_LIMIT_ERROR, t.getMessage());\n            } else if (t instanceof InsufficientCapacityException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Insufficient capacity\";\n                throw new ServerApiException(BaseCmd.INSUFFICIENT_CAPACITY_ERROR, t.getMessage());\n            } else if (t instanceof ResourceAllocationException) {\n                s_logger.warn(\"Exception: \", t);\n                errorMsg = \"Resource allocation error\";\n                throw new ServerApiException(BaseCmd.RESOURCE_ALLOCATION_ERROR, t.getMessage());\n            } else if (t instanceof ResourceUnavailableException) {\n                s_logger.warn(\"Exception: \", t);\n                errorMsg = \"Resource unavailable error\";\n                throw new ServerApiException(BaseCmd.RESOURCE_UNAVAILABLE_ERROR, t.getMessage());\n            } else if (t instanceof AsyncCommandQueued) {\n                throw (AsyncCommandQueued)t;\n            } else if (t instanceof ServerApiException) {\n                errorMsg = ((ServerApiException) t).getDescription();\n                s_logger.warn(t.getClass()  + \" : \" + ((ServerApiException) t).getDescription());\n                if (UserContext.current().getAccount().getType() == Account.ACCOUNT_TYPE_ADMIN)\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, t.getMessage());\n                else\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, BaseCmd.USER_ERROR_MESSAGE);\n            } else {\n                errorMsg = \"Internal error\";\n                s_logger.error(\"Exception while executing \" + cmd.getClass().getSimpleName() + \":\", t);\n                if (UserContext.current().getAccount().getType() == Account.ACCOUNT_TYPE_ADMIN)\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, t.getMessage());\n                else\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, BaseCmd.USER_ERROR_MESSAGE);\n            }\n        } finally {\n            if(cmd instanceof BaseAsyncCmd){\n                BaseAsyncCmd asyncCmd = (BaseAsyncCmd)cmd;\n                if(success){\n                    asyncCmd.saveCompletedEvent(EventVO.LEVEL_INFO, asyncCmd.getEventDescription()+\" completed successfully\");\n                } else {\n                    asyncCmd.saveCompletedEvent(EventVO.LEVEL_ERROR, asyncCmd.getEventDescription()+\" failed. \"+errorMsg);\n                }            \n            }\n        }\n    }","commit_id":"7b3b9076b04517f70358cca8d1950caae67f9663","url":"https://github.com/apache/cloudstack"},{"original_method":"public void dispatchCreateCmd(BaseAsyncCreateCmd cmd, Map<String, String> params) {\n        \n        boolean created = false;\n        String errorMsg = \"\";\n        long startId = 0;\n        \n        if(cmd.getCreateEventType() != null){\n            startId = cmd.saveStartedEvent(cmd.getCreateEventType(), cmd.getCreateEventDescription(), 0L);\n        }\n        \n        setupParameters(cmd, params);\n\n        try {\n            cmd.create();\n            created = true;\n        } catch (Throwable t) {\n            if (t instanceof  InvalidParameterValueException || t instanceof IllegalArgumentException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Parameter error\";\n                throw new ServerApiException(BaseCmd.PARAM_ERROR, t.getMessage());\n            }else if (t instanceof PermissionDeniedException) {\n                s_logger.info(\"PermissionDenied: \" + t.getMessage());\n                errorMsg = \"Permission denied\";\n                throw new ServerApiException(BaseCmd.ACCOUNT_ERROR, t.getMessage());\n            }else if (t instanceof AccountLimitException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Account resource limit error\";\n                throw new ServerApiException(BaseCmd.ACCOUNT_RESOURCE_LIMIT_ERROR, t.getMessage());\n            }else if (t instanceof InsufficientCapacityException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Insufficient capacity\";\n                throw new ServerApiException(BaseCmd.INSUFFICIENT_CAPACITY_ERROR, t.getMessage());\n            }else if (t instanceof ResourceAllocationException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Resource allocation error\";\n                throw new ServerApiException(BaseCmd.RESOURCE_ALLOCATION_ERROR, t.getMessage());\n            }else if (t instanceof ResourceUnavailableException) {\n                s_logger.warn(\"Exception: \", t);\n                errorMsg = \"Resource unavailable error\";\n                throw new ServerApiException(BaseCmd.RESOURCE_UNAVAILABLE_ERROR, t.getMessage());\n            }else if (t instanceof ServerApiException) {\n                s_logger.warn(t.getClass() + \" : \" + ((ServerApiException) t).getDescription());\n                errorMsg = ((ServerApiException) t).getDescription();\n                throw new ServerApiException(((ServerApiException) t).getErrorCode(), ((ServerApiException) t).getDescription());\n            }else if (t instanceof AsyncCommandQueued) {\n                throw (AsyncCommandQueued)t;\n            }else {\n                errorMsg = \"Internal error\";\n                s_logger.error(\"Exception while executing \" + cmd.getClass().getSimpleName() + \":\", t);\n                if (UserContext.current().getAccount() == null || UserContext.current().getAccount().getType() == Account.ACCOUNT_TYPE_ADMIN)\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, t.getMessage());\n                else\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, BaseCmd.USER_ERROR_MESSAGE);                \n            }\n        } finally {\n            if(cmd.getCreateEventType() != null){\n                if (created){\n                    cmd.saveCompletedEvent(EventVO.LEVEL_INFO, cmd.getCreateEventType(), cmd.getCreateEventDescription()+\" successfull. Id: \"+cmd.getEntityId(), startId);\n                } else {\n                    cmd.saveCompletedEvent(EventVO.LEVEL_ERROR, cmd.getCreateEventType(), cmd.getCreateEventDescription()+\" failed. \"+errorMsg, startId);\n                }\n            }\n        }\n    }","id":83959,"modified_method":"public void dispatchCreateCmd(BaseAsyncCreateCmd cmd, Map<String, String> params) {\n        \n        boolean created = false;\n        String errorMsg = \"\";\n        long startId = 0;\n        \n        if(cmd.getCreateEventType() != null){\n            startId = cmd.saveStartedEvent(cmd.getCreateEventType(), cmd.getCreateEventDescription(), 0L);\n        }\n        \n        setupParameters(cmd, params);\n\n        try {\n            cmd.create();\n            created = true;\n        } catch (Throwable t) {\n            if (t instanceof  InvalidParameterValueException || t instanceof IllegalArgumentException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Parameter error\";\n                throw new ServerApiException(BaseCmd.PARAM_ERROR, t.getMessage());\n            } else if (t instanceof PermissionDeniedException) {\n                s_logger.info(\"PermissionDenied: \" + t.getMessage());\n                errorMsg = \"Permission denied\";\n                throw new ServerApiException(BaseCmd.ACCOUNT_ERROR, t.getMessage());\n            } else if (t instanceof AccountLimitException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Account resource limit error\";\n                throw new ServerApiException(BaseCmd.ACCOUNT_RESOURCE_LIMIT_ERROR, t.getMessage());\n            }else if (t instanceof InsufficientCapacityException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Insufficient capacity\";\n                throw new ServerApiException(BaseCmd.INSUFFICIENT_CAPACITY_ERROR, t.getMessage());\n            } else if (t instanceof ResourceAllocationException) {\n                s_logger.info(t.getMessage());\n                errorMsg = \"Resource allocation error\";\n                throw new ServerApiException(BaseCmd.RESOURCE_ALLOCATION_ERROR, t.getMessage());\n            } else if (t instanceof ResourceUnavailableException) {\n                s_logger.warn(\"Exception: \", t);\n                errorMsg = \"Resource unavailable error\";\n                throw new ServerApiException(BaseCmd.RESOURCE_UNAVAILABLE_ERROR, t.getMessage());\n            } else if (t instanceof AsyncCommandQueued) {\n                throw (AsyncCommandQueued)t;\n            } else if (t instanceof ServerApiException) {\n                s_logger.warn(t.getClass() + \" : \" + ((ServerApiException) t).getDescription());\n                errorMsg = ((ServerApiException) t).getDescription();\n                if (UserContext.current().getAccount().getType() == Account.ACCOUNT_TYPE_ADMIN)\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, t.getMessage());\n                else\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, BaseCmd.USER_ERROR_MESSAGE);      \n            } else {\n                errorMsg = \"Internal error\";\n                s_logger.error(\"Exception while executing \" + cmd.getClass().getSimpleName() + \":\", t);\n                if (UserContext.current().getAccount().getType() == Account.ACCOUNT_TYPE_ADMIN)\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, t.getMessage());\n                else\n                    throw new ServerApiException(BaseCmd.INTERNAL_ERROR, BaseCmd.USER_ERROR_MESSAGE);                \n            }\n        } finally {\n            if(cmd.getCreateEventType() != null){\n                if (created){\n                    cmd.saveCompletedEvent(EventVO.LEVEL_INFO, cmd.getCreateEventType(), cmd.getCreateEventDescription()+\" successfull. Id: \"+cmd.getEntityId(), startId);\n                } else {\n                    cmd.saveCompletedEvent(EventVO.LEVEL_ERROR, cmd.getCreateEventType(), cmd.getCreateEventDescription()+\" failed. \"+errorMsg, startId);\n                }\n            }\n        }\n    }","commit_id":"7b3b9076b04517f70358cca8d1950caae67f9663","url":"https://github.com/apache/cloudstack"},{"original_method":"private String queueCommand(BaseCmd cmdObj, Map<String, String> params) {\r\n    \tUserContext ctx = UserContext.current();\r\n        Long userId = ctx.getUserId();\r\n        Account account = ctx.getAccount();\r\n        if (cmdObj instanceof BaseAsyncCmd) {\r\n            Long objectId = null;\r\n            if (cmdObj instanceof BaseAsyncCreateCmd) {\r\n                BaseAsyncCreateCmd createCmd = (BaseAsyncCreateCmd)cmdObj;\r\n                _dispatcher.dispatchCreateCmd(createCmd, params);\r\n                objectId = createCmd.getEntityId();\r\n                params.put(\"id\", objectId.toString());\r\n            } else {\r\n                ApiDispatcher.setupParameters(cmdObj, params);\r\n            }\r\n\r\n            BaseAsyncCmd asyncCmd = (BaseAsyncCmd)cmdObj;\r\n\r\n            if (userId != null) {\r\n                params.put(\"ctxUserId\", userId.toString());\r\n            }\r\n            if (account != null) {\r\n                params.put(\"ctxAccountId\", String.valueOf(account.getId()));\r\n            }\r\n\r\n            // save the scheduled event\r\n            Long eventId = EventUtils.saveScheduledEvent((userId == null) ? User.UID_SYSTEM : userId, asyncCmd.getEntityOwnerId(),\r\n                    asyncCmd.getEventType(), asyncCmd.getEventDescription());\r\n\r\n            if (eventId != null) {\r\n                params.put(\"starteventid\", eventId.toString());\r\n            }\r\n\r\n            AsyncJobVO job = new AsyncJobVO();\r\n            job.setInstanceId((objectId == null) ? asyncCmd.getInstanceId() : objectId);\r\n            job.setInstanceType(asyncCmd.getInstanceType());\r\n            job.setUserId(userId);\r\n            if (account != null) {\r\n                job.setAccountId(ctx.getAccount().getId());\r\n            } else {\r\n                // Just have SYSTEM own the job for now.  Users won't be able to see this job,\r\n                // but in an admin case (like domain admin) they won't be able to see it anyway\r\n                // so no loss of service.\r\n                job.setAccountId(1L);\r\n            }\r\n            job.setCmd(cmdObj.getClass().getName());\r\n            job.setCmdInfo(ApiGsonHelper.getBuilder().create().toJson(params));\r\n\r\n            long jobId = _asyncMgr.submitAsyncJob(job);\r\n            if (objectId != null) {\r\n                return ((BaseAsyncCreateCmd)asyncCmd).getResponse(jobId, objectId);\r\n            }\r\n            return ApiResponseSerializer.toSerializedString(asyncCmd.getResponse(jobId), asyncCmd.getResponseType());\r\n        } else {\r\n            _dispatcher.dispatch(cmdObj, params);\r\n            \r\n            // if the command is of the listXXXCommand, we will need to also return the \r\n            // the job id and status if possible\r\n            if (cmdObj instanceof BaseListCmd) {\r\n            \tbuildAsyncListResponse((BaseListCmd)cmdObj, account);\r\n            }\r\n            return ApiResponseSerializer.toSerializedString((ResponseObject)cmdObj.getResponseObject(), cmdObj.getResponseType());    \r\n        }\r\n    }","id":83960,"modified_method":"private String queueCommand(BaseCmd cmdObj, Map<String, String> params) {\r\n    \tUserContext ctx = UserContext.current();\r\n        Long userId = ctx.getUserId();\r\n        Account account = ctx.getAccount();\r\n        if (cmdObj instanceof BaseAsyncCmd) {\r\n            Long objectId = null;\r\n            if (cmdObj instanceof BaseAsyncCreateCmd) {\r\n                BaseAsyncCreateCmd createCmd = (BaseAsyncCreateCmd)cmdObj;\r\n                _dispatcher.dispatchCreateCmd(createCmd, params);\r\n                objectId = createCmd.getEntityId();\r\n                params.put(\"id\", objectId.toString());\r\n            } else {\r\n                ApiDispatcher.setupParameters(cmdObj, params);\r\n            }\r\n\r\n            BaseAsyncCmd asyncCmd = (BaseAsyncCmd)cmdObj;\r\n\r\n            if (userId != null) {\r\n                params.put(\"ctxUserId\", userId.toString());\r\n            }\r\n            if (account != null) {\r\n                params.put(\"ctxAccountId\", String.valueOf(account.getId()));\r\n            }\r\n\r\n            // save the scheduled event\r\n            Long eventId = EventUtils.saveScheduledEvent((userId == null) ? User.UID_SYSTEM : userId, asyncCmd.getEntityOwnerId(),\r\n                    asyncCmd.getEventType(), asyncCmd.getEventDescription());\r\n\r\n            if (eventId != null) {\r\n                params.put(\"starteventid\", eventId.toString());\r\n            }\r\n\r\n            AsyncJobVO job = new AsyncJobVO();\r\n            job.setInstanceId((objectId == null) ? asyncCmd.getInstanceId() : objectId);\r\n            job.setInstanceType(asyncCmd.getInstanceType());\r\n            job.setUserId(userId);\r\n            if (account != null) {\r\n                job.setAccountId(ctx.getAccount().getId());\r\n            } else {\r\n                // Just have SYSTEM own the job for now.  Users won't be able to see this job,\r\n                // but in an admin case (like domain admin) they won't be able to see it anyway\r\n                // so no loss of service.\r\n                job.setAccountId(1L);\r\n            }\r\n            job.setCmd(cmdObj.getClass().getName());\r\n            job.setCmdInfo(ApiGsonHelper.getBuilder().create().toJson(params));\r\n\r\n            long jobId = _asyncMgr.submitAsyncJob(job);\r\n            \r\n            if (jobId == 0L) {\r\n                String errorMsg = \"Unable to schedule async job for command \" + job.getCmd();\r\n                s_logger.warn(errorMsg);\r\n                throw new ServerApiException(BaseCmd.INTERNAL_ERROR, errorMsg);\r\n            }\r\n            \r\n            if (objectId != null) {\r\n                return ((BaseAsyncCreateCmd)asyncCmd).getResponse(jobId, objectId);\r\n            }\r\n            return ApiResponseSerializer.toSerializedString(asyncCmd.getResponse(jobId), asyncCmd.getResponseType());\r\n        } else {\r\n            _dispatcher.dispatch(cmdObj, params);\r\n            \r\n            // if the command is of the listXXXCommand, we will need to also return the \r\n            // the job id and status if possible\r\n            if (cmdObj instanceof BaseListCmd) {\r\n            \tbuildAsyncListResponse((BaseListCmd)cmdObj, account);\r\n            }\r\n            return ApiResponseSerializer.toSerializedString((ResponseObject)cmdObj.getResponseObject(), cmdObj.getResponseType());    \r\n        }\r\n    }","commit_id":"7b3b9076b04517f70358cca8d1950caae67f9663","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override @DB\r\n    public long submitAsyncJob(AsyncJobVO job, boolean scheduleJobExecutionInContext) {\n    \tTransaction txt = Transaction.currentTxn();\r\n    \ttry {\r\n    \t    txt.start();\r\n    \t    job.setInitMsid(getMsid());\n    \t    _jobDao.persist(job);\r\n    \t    txt.commit();\r\n\n    \t    // no sync source originally\n    \t    job.setSyncSource(null);\r\n    \t    scheduleExecution(job, scheduleJobExecutionInContext);\n    \t    if(s_logger.isDebugEnabled()) {\n                s_logger.debug(\"submit async job-\" + job.getId() + \", details: \" + job.toString());\n            }\n    \t    return job.getId();\r\n    \t} catch(Exception e) {\r\n    \t    s_logger.error(\"Unexpected exception: \", e);\r\n    \t    txt.rollback();\n    \t}\r\n    \treturn 0L;\r\n    }","id":83961,"modified_method":"@Override @DB\r\n    public long submitAsyncJob(AsyncJobVO job, boolean scheduleJobExecutionInContext) {\n    \tTransaction txt = Transaction.currentTxn();\r\n    \ttry {\r\n    \t    txt.start();\r\n    \t    job.setInitMsid(getMsid());\n    \t    _jobDao.persist(job);\r\n    \t    txt.commit();\r\n\n    \t    // no sync source originally\n    \t    job.setSyncSource(null);\r\n    \t    scheduleExecution(job, scheduleJobExecutionInContext);\n    \t    if(s_logger.isDebugEnabled()) {\n                s_logger.debug(\"submit async job-\" + job.getId() + \", details: \" + job.toString());\n            }\n    \t    return job.getId();\r\n    \t} catch(Exception e) { \n    \t    txt.rollback();\n    \t    String errMsg = \"Unable to schedule async job for command \" + job.getCmd() + \", unexpected exception.\";\n            s_logger.warn(errMsg, e);\n            throw new CloudRuntimeException(errMsg);\n    \t}\r\n    }","commit_id":"7b3b9076b04517f70358cca8d1950caae67f9663","url":"https://github.com/apache/cloudstack"},{"original_method":"private void emailValidate(String var1, String var2)\n   {\n      Random ran = new Random();\n      String var = var1 + \";\" + ran.nextInt() + \";\" + var2;\n      activationKey = Base64UrlSafe.encode(var);\n      log.info(\"generate activate key:\" + activationKey);\n      renderer.render(\"/WEB-INF/facelets/email/email_validation.xhtml\");\n      FacesMessages.instance().add(\"You will soon receive an email with a link to activate your email account change.\");\n   }","id":83962,"modified_method":"private void emailValidate(String var1, String var2)\n   {\n      Random ran = new Random();\n      String var = var1 + \";\" + ran.nextInt() + \";\" + var2;\n      activationKey = Base64UrlSafe.encode(var);\n      renderer.render(\"/WEB-INF/facelets/email/email_validation.xhtml\");\n      FacesMessages.instance().add(\"You will soon receive an email with a link to activate your email account change.\");\n   }","commit_id":"067cad58a7d91c501132a0090a22137d67f5e44b","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void execute()\n   {\n      if (!fliesInit.isSpNego())\n      {\n         return;\n      }\n      try\n      {\n         String username = FacesContext.getCurrentInstance().getExternalContext().getRemoteUser();\n         identity.getCredentials().setUsername(username);\n         log.debug(\"username: \" + identity.getCredentials().getUsername());\n         identity.getCredentials().setPassword(\"\");\n\n         Field field = Identity.class.getDeclaredField(PRINCIPAL);\n         field.setAccessible(true);\n         field.set(identity, SecurityAssociation.getCallerPrincipal());\n\n         field = Identity.class.getDeclaredField(SUBJECT);\n         field.setAccessible(true);\n         field.set(identity, SecurityAssociation.getSubject());\n\n\n         if (Events.exists())\n            Events.instance().raiseEvent(Identity.EVENT_LOGIN_SUCCESSFUL);\n\n      }\n      catch (Exception e)\n      {\n         log.info(e.getMessage());\n      }\n   }","id":83963,"modified_method":"public void execute()\n   {\n      if (!fliesInit.isSpNego())\n      {\n         return;\n      }\n      try\n      {\n         String username = FacesContext.getCurrentInstance().getExternalContext().getRemoteUser();\n         identity.getCredentials().setUsername(username);\n         log.debug(\"username: \" + identity.getCredentials().getUsername());\n         identity.getCredentials().setPassword(\"\");\n\n         Field field = Identity.class.getDeclaredField(PRINCIPAL);\n         field.setAccessible(true);\n         field.set(identity, SecurityAssociation.getCallerPrincipal());\n\n         field = Identity.class.getDeclaredField(SUBJECT);\n         field.setAccessible(true);\n         field.set(identity, SecurityAssociation.getSubject());\n\n         identity.setPreAuthenticated(true);\n         if (Events.exists())\n            Events.instance().raiseEvent(Identity.EVENT_LOGIN_SUCCESSFUL);\n\n      }\n      catch (Exception e)\n      {\n         log.info(e.getMessage());\n      }\n   }","commit_id":"067cad58a7d91c501132a0090a22137d67f5e44b","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Transactional\n   public String validate() throws LoginException\n   {\n      if (activationKey != null && !activationKey.isEmpty())\n      {\n         log.info(\"validate key:\" + activationKey);\n         String var = Base64UrlSafe.decode(activationKey);\n         String[] array = var.split(\";\");\n         String id = array[0];\n         String email = array[2];\n\n         HPerson person = personDAO.findById(new Long(id), true);\n         person.setEmail(email);\n         person.getAccount().setEnabled(true);\n         personDAO.makePersistent(person);\n         personDAO.flush();\n         FacesMessages.instance().add(\"You have successfully changed your email account.\");\n         log.info(\"update email address to \" + email + \" successfully\");\n      }\n      return \"/home.xhtml\";\n   }","id":83964,"modified_method":"@Transactional\n   public String validate() throws LoginException\n   {\n      if (activationKey != null && !activationKey.isEmpty())\n      {\n         String var = Base64UrlSafe.decode(activationKey);\n         String[] array = var.split(\";\");\n         String id = array[0];\n         String email = array[2];\n\n         HPerson person = personDAO.findById(new Long(id), true);\n         HAccount account = person.getAccount();\n         if (!account.getUsername().equals(identity.getCredentials().getUsername()))\n         {\n            throw new LoginException();\n         }\n         person.setEmail(email);\n         account.setEnabled(true);\n         personDAO.makePersistent(person);\n         personDAO.flush();\n         FacesMessages.instance().add(\"You have successfully changed your email account.\");\n         log.info(\"update email address to {0}  successfully\", email);\n      }\n      return \"/home.xhtml\";\n   }","commit_id":"067cad58a7d91c501132a0090a22137d67f5e44b","url":"https://github.com/zanata/zanata-server"},{"original_method":"static PsiElement inlineReferenceImpl(GrCallExpression call, GrMethod method, boolean replaceCall, boolean isTailMethodCall) {\n    try {\n\n      GrMethod newMethod = prepareNewMethod(call, method);\n      GrExpression result = getAloneResultExpression(newMethod);\n      if (result != null) {\n        return call.replaceWithExpression(result, true);\n      }\n\n      String resultName = InlineMethodConflictSolver.suggestNewName(\"result\", newMethod, call);\n      GroovyElementFactory factory = GroovyElementFactory.getInstance(call.getProject());\n\n      // Add variable for method result\n      Collection<GrReturnStatement> returnStatements = GroovyRefactoringUtil.findReturnStatements(newMethod);\n      boolean hasTailExpr = GroovyRefactoringUtil.hasTailReturnExpression(method);\n      boolean hasReturnStatements = returnStatements.size() > 0;\n      PsiType methodType = method.getReturnType();\n      GrOpenBlock body = newMethod.getBlock();\n      assert body != null;\n      GrStatement[] statements = body.getStatements();\n      GrExpression replaced = null;\n      if (replaceCall && !isTailMethodCall) {\n        GrExpression resultExpr;\n        if (PsiType.VOID == methodType) {\n          resultExpr = factory.createExpressionFromText(\"null\");\n        } else if (hasReturnStatements) {\n          resultExpr = factory.createExpressionFromText(resultName);\n        } else if (hasTailExpr) {\n          GrExpression expr = (GrExpression) statements[statements.length - 1];\n          resultExpr = factory.createExpressionFromText(expr.getText());\n        } else {\n          resultExpr = factory.createExpressionFromText(\"null\");\n        }\n        replaced = call.replaceWithExpression(resultExpr, true);\n      }\n\n      // Calculate anchor to insert before\n      GrExpression enclosingExpr = changeEnclosingStatement(replaced != null ? replaced : call);\n      GrVariableDeclarationOwner owner = PsiTreeUtil.getParentOfType(enclosingExpr, GrVariableDeclarationOwner.class);\n      PsiElement element = enclosingExpr;\n      assert owner != null;\n      while (element != null && element.getParent() != owner) {\n        element = element.getParent();\n      }\n      assert element != null && element instanceof GrStatement;\n      GrStatement anchor = (GrStatement) element;\n\n      if (!replaceCall) {\n        assert anchor == enclosingExpr;\n      }\n\n      // Process method return statements\n      if (hasReturnStatements && PsiType.VOID != methodType && !isTailMethodCall) {\n        GrVariableDeclaration resultDecl = factory.createVariableDeclaration(new String[0], resultName, null, methodType, false);\n        owner.addStatementBefore(resultDecl, anchor);\n\n        // Replace all return statements with assignments to 'result' variable\n        for (GrReturnStatement returnStatement : returnStatements) {\n          GrExpression value = returnStatement.getReturnValue();\n          if (value != null) {\n            GrExpression assignment = factory.createExpressionFromText(resultName + \" = \" + value.getText());\n            returnStatement.replaceWithStatement(assignment);\n          } else {\n            returnStatement.replaceWithStatement(factory.createExpressionFromText(resultName + \" = null\"));\n          }\n        }\n      }\n      if (PsiType.VOID == methodType && !isTailMethodCall) {\n        for (GrReturnStatement returnStatement : returnStatements) {\n          returnStatement.removeStatement();\n        }\n      }\n\n      // Add all method statements\n      statements = body.getStatements();\n      for (GrStatement statement : statements) {\n        if (!(statements.length > 0 && statement == statements[statements.length - 1] && hasTailExpr)) {\n          owner.addStatementBefore(statement, anchor);\n        }\n      }\n      if (replaceCall && !isTailMethodCall) {\n        return replaced;\n      } else {\n        GrStatement stmt;\n        if (isTailMethodCall && enclosingExpr.getParent() instanceof GrReturnStatement) {\n          stmt = ((GrReturnStatement) enclosingExpr.getParent());\n        } else {\n          stmt = enclosingExpr;\n        }\n        stmt.removeStatement();\n        return owner;\n      }\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return null;\n  }","id":83965,"modified_method":"static SmartPsiElementPointer<GrExpression> inlineReferenceImpl(GrCallExpression call, GrMethod method, boolean replaceCall, boolean isTailMethodCall) {\n    try {\n\n      GrMethod newMethod = prepareNewMethod(call, method);\n      GrExpression result = getAloneResultExpression(newMethod);\n      if (result != null) {\n        GrExpression expression = call.replaceWithExpression(result, true);\n        return SmartPointerManager.getInstance(result.getProject()).createSmartPsiElementPointer(expression);\n      }\n\n      String resultName = InlineMethodConflictSolver.suggestNewName(\"result\", newMethod, call);\n      GroovyElementFactory factory = GroovyElementFactory.getInstance(call.getProject());\n\n      // Add variable for method result\n      Collection<GrReturnStatement> returnStatements = GroovyRefactoringUtil.findReturnStatements(newMethod);\n      boolean hasTailExpr = GroovyRefactoringUtil.hasTailReturnExpression(method);\n      boolean hasReturnStatements = returnStatements.size() > 0;\n      PsiType methodType = method.getReturnType();\n      GrOpenBlock body = newMethod.getBlock();\n      assert body != null;\n      GrStatement[] statements = body.getStatements();\n      GrExpression replaced = null;\n      if (replaceCall && !isTailMethodCall) {\n        GrExpression resultExpr;\n        if (PsiType.VOID == methodType) {\n          resultExpr = factory.createExpressionFromText(\"null\");\n        } else if (hasReturnStatements) {\n          resultExpr = factory.createExpressionFromText(resultName);\n        } else if (hasTailExpr) {\n          GrExpression expr = (GrExpression) statements[statements.length - 1];\n          resultExpr = factory.createExpressionFromText(expr.getText());\n        } else {\n          resultExpr = factory.createExpressionFromText(\"null\");\n        }\n        replaced = call.replaceWithExpression(resultExpr, true);\n      }\n\n      // Calculate anchor to insert before\n      GrExpression enclosingExpr = changeEnclosingStatement(replaced != null ? replaced : call);\n      GrVariableDeclarationOwner owner = PsiTreeUtil.getParentOfType(enclosingExpr, GrVariableDeclarationOwner.class);\n      PsiElement element = enclosingExpr;\n      assert owner != null;\n      while (element != null && element.getParent() != owner) {\n        element = element.getParent();\n      }\n      assert element != null && element instanceof GrStatement;\n      GrStatement anchor = (GrStatement) element;\n\n      if (!replaceCall) {\n        assert anchor == enclosingExpr;\n      }\n\n      // Process method return statements\n      if (hasReturnStatements && PsiType.VOID != methodType && !isTailMethodCall) {\n        GrVariableDeclaration resultDecl = factory.createVariableDeclaration(new String[0], resultName, null, methodType, false);\n        owner.addStatementBefore(resultDecl, anchor);\n\n        // Replace all return statements with assignments to 'result' variable\n        for (GrReturnStatement returnStatement : returnStatements) {\n          GrExpression value = returnStatement.getReturnValue();\n          if (value != null) {\n            GrExpression assignment = factory.createExpressionFromText(resultName + \" = \" + value.getText());\n            returnStatement.replaceWithStatement(assignment);\n          } else {\n            returnStatement.replaceWithStatement(factory.createExpressionFromText(resultName + \" = null\"));\n          }\n        }\n      }\n      if (PsiType.VOID == methodType && !isTailMethodCall) {\n        for (GrReturnStatement returnStatement : returnStatements) {\n          returnStatement.removeStatement();\n        }\n      }\n\n      // Add all method statements\n      statements = body.getStatements();\n      for (GrStatement statement : statements) {\n        if (!(statements.length > 0 && statement == statements[statements.length - 1] && hasTailExpr)) {\n          owner.addStatementBefore(statement, anchor);\n        }\n      }\n      if (replaceCall && !isTailMethodCall) {\n        assert replaced != null;\n        SmartPsiElementPointer<GrExpression> pointer = SmartPointerManager.getInstance(replaced.getProject()).createSmartPsiElementPointer(replaced);\n        reformatOwner(owner);\n        return pointer;\n      } else {\n        GrStatement stmt;\n        if (isTailMethodCall && enclosingExpr.getParent() instanceof GrReturnStatement) {\n          stmt = ((GrReturnStatement) enclosingExpr.getParent());\n        } else {\n          stmt = enclosingExpr;\n        }\n        stmt.removeStatement();\n        reformatOwner(owner);\n        return null;\n      }\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return null;\n  }","commit_id":"252abe0a9675b73a45c52dde22d78206b39aea02","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void inlineReference(PsiReference reference, PsiElement referenced) {\n    PsiElement element = reference.getElement();\n    assert element instanceof GrExpression && element.getParent() instanceof GrCallExpression;\n    GrCallExpression call = (GrCallExpression) element.getParent();\n    PsiElement position = inlineReferenceImpl(call, myMethod, isOnExpressionOrReturnPlace(call), GroovyInlineMethodUtil.isTailMethodCall(call));\n\n    // highilght replaced result\n    if (position != null && position instanceof GrExpression) {\n      Project project = referenced.getProject();\n      FileEditorManager manager = FileEditorManager.getInstance(project);\n      Editor editor = manager.getSelectedTextEditor();\n      GroovyRefactoringUtil.highlightOccurrences(project, editor, new PsiElement[]{position});\n      WindowManager.getInstance().getStatusBar(project).setInfo(GroovyRefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n    }\n    if (position != null) {\n      GrVariableDeclarationOwner owner = position instanceof GrVariableDeclarationOwner ?\n          ((GrVariableDeclarationOwner) position) :\n          PsiTreeUtil.getParentOfType(position, GrVariableDeclarationOwner.class);\n      if (owner != null) {\n        try {\n          reformatOwner(owner);\n        } catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","id":83966,"modified_method":"public void inlineReference(PsiReference reference, PsiElement referenced) {\n    PsiElement element = reference.getElement();\n    assert element instanceof GrExpression && element.getParent() instanceof GrCallExpression;\n    GrCallExpression call = (GrCallExpression) element.getParent();\n    SmartPsiElementPointer<GrExpression> pointer =\n        inlineReferenceImpl(call, myMethod, isOnExpressionOrReturnPlace(call), GroovyInlineMethodUtil.isTailMethodCall(call));\n\n    // highilght replaced result\n    if (pointer != null && pointer.getElement() != null) {\n      Project project = referenced.getProject();\n      FileEditorManager manager = FileEditorManager.getInstance(project);\n      Editor editor = manager.getSelectedTextEditor();\n      GroovyRefactoringUtil.highlightOccurrences(project, editor, new PsiElement[]{pointer.getElement()});\n      WindowManager.getInstance().getStatusBar(project).setInfo(GroovyRefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n      GrExpression expression = pointer.getElement();\n      if (editor != null && expression != null) {\n        editor.getCaretModel().moveToOffset(expression.getTextRange().getEndOffset());\n      }\n    }\n  }","commit_id":"252abe0a9675b73a45c52dde22d78206b39aea02","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected TextRange surroundExpression(GrExpression expression, PsiElement context) {\n    GrUnaryExpression result = (GrUnaryExpression)GroovyPsiElementFactory.getInstance(expression.getProject()).createExpressionFromText(\"!(a)\", context);\n    GroovyExpressionSurrounder.replaceToOldExpression(((GrParenthesizedExpression)result.getOperand()).getOperand(), expression);\n    result = (GrUnaryExpression)expression.replaceWithExpression(result, true);\n    return new TextRange(result.getTextRange().getEndOffset(), result.getTextRange().getEndOffset());\n  }","id":83967,"modified_method":"@Override\n  protected TextRange surroundExpression(GrExpression expression, PsiElement context) {\n    final GroovyPsiElementFactory factory = GroovyPsiElementFactory.getInstance(expression.getProject());\n    final GrUnaryExpression template = (GrUnaryExpression)factory.createExpressionFromText(\"!(a)\", context);\n    assert template.getOperand() != null;\n    GroovyExpressionSurrounder.replaceToOldExpression(((GrParenthesizedExpression)template.getOperand()).getOperand(), expression);\n    final GrExpression result = expression.replaceWithExpression(template, true);\n    final int endOffset = result.getTextRange().getEndOffset();\n    return new TextRange(endOffset, endOffset);\n  }","commit_id":"18f624aafb2e0aa22b34ff061e175a6417b113f4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrStatement addStatementBefore(@NotNull GrStatement element, @NotNull GrStatement anchor) throws IncorrectOperationException {\n\n    if (!this.equals(anchor.getParent())) {\n      throw new IncorrectOperationException();\n    }\n\n    ASTNode elemNode = element.getNode();\n    final ASTNode anchorNode = anchor.getNode();\n    getNode().addChild(elemNode, anchorNode);\n    if (mayUseNewLinesAsSeparators()) {\n      getNode().addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchorNode);\n    } else {\n      getNode().addLeaf(GroovyTokenTypes.mSEMI, \";\", anchorNode);\n    }\n    PsiFile file = anchor.getContainingFile();\n    assert file != null;\n    PsiDocumentManager manager = PsiDocumentManager.getInstance(getProject());\n    Document document = manager.getDocument(file);\n    if (document != null) {\n      manager.doPostponedOperationsAndUnblockDocument(document);\n    }\n    CodeStyleManager.getInstance(getProject()).adjustLineIndent(file, getTextRange());\n    return (GrStatement) elemNode.getPsi();\n  }","id":83968,"modified_method":"public GrStatement addStatementBefore(@NotNull GrStatement element, GrStatement anchor) throws IncorrectOperationException {\n\n    if (anchor == null && getRBrace() == null) {\n      throw new IncorrectOperationException();\n    }\n\n    if (anchor != null && !this.equals(anchor.getParent())) {\n      throw new IncorrectOperationException();\n    }\n\n    ASTNode elemNode = element.getNode();\n    final ASTNode anchorNode = anchor != null ? anchor.getNode() : getRBrace().getNode();\n    getNode().addChild(elemNode, anchorNode);\n    if (mayUseNewLinesAsSeparators()) {\n      getNode().addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchorNode);\n    } else {\n      getNode().addLeaf(GroovyTokenTypes.mSEMI, \";\", anchorNode);\n    }\n    PsiFile file = getContainingFile();\n    assert file != null;\n    return (GrStatement) elemNode.getPsi();\n  }","commit_id":"319f6cbe9cc2acb2ed2a3950bf63eed13249177a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrStatement addStatementBefore(@NotNull GrStatement element, @NotNull GrStatement anchor) throws IncorrectOperationException {\n\n    if (anchor != null && !this.equals(anchor.getParent())) {\n      throw new IncorrectOperationException();\n    }\n    ASTNode elemNode = element.getNode();\n    final ASTNode anchorNode = anchor != null ? anchor.getNode() : getLastChild().getNode();\n    getNode().addChild(elemNode, anchorNode);\n    if (mayUseNewLinesAsSeparators()) {\n      getNode().addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchorNode);\n    } else {\n      getNode().addLeaf(GroovyTokenTypes.mSEMI, \";\", anchorNode);\n    }\n    PsiFile file = anchor.getContainingFile();\n    assert file != null;\n    PsiDocumentManager manager = PsiDocumentManager.getInstance(getProject());\n    Document document = manager.getDocument(file);\n    if (document != null) {\n      manager.doPostponedOperationsAndUnblockDocument(document);\n    }\n    CodeStyleManager.getInstance(getProject()).adjustLineIndent(file, getTextRange());\n\n    return (GrStatement) elemNode.getPsi();\n  }","id":83969,"modified_method":"public GrStatement addStatementBefore(@NotNull GrStatement element, @NotNull GrStatement anchor) throws IncorrectOperationException {\n\n    if (anchor != null && !this.equals(anchor.getParent())) {\n      throw new IncorrectOperationException();\n    }\n    ASTNode elemNode = element.getNode();\n    final ASTNode anchorNode = anchor != null ? anchor.getNode() : getLastChild().getNode();\n    getNode().addChild(elemNode, anchorNode);\n    if (mayUseNewLinesAsSeparators()) {\n      getNode().addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchorNode);\n    } else {\n      getNode().addLeaf(GroovyTokenTypes.mSEMI, \";\", anchorNode);\n    }\n    return (GrStatement) elemNode.getPsi();\n  }","commit_id":"319f6cbe9cc2acb2ed2a3950bf63eed13249177a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrStatement addStatementBefore(@NotNull GrStatement statement, @NotNull GrStatement anchor) throws IncorrectOperationException {\n    final PsiElement result = addBefore(statement, anchor);\n    getNode().addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchor.getNode());\n    PsiDocumentManager manager = PsiDocumentManager.getInstance(getProject());\n    Document document = manager.getDocument(this);\n    if (document != null) {\n      manager.doPostponedOperationsAndUnblockDocument(document);\n    }\n    CodeStyleManager.getInstance(getProject()).adjustLineIndent(this, result.getTextRange());\n    return (GrStatement) result;\n  }","id":83970,"modified_method":"public GrStatement addStatementBefore(@NotNull GrStatement statement, @NotNull GrStatement anchor) throws IncorrectOperationException {\n    final PsiElement result = addBefore(statement, anchor);\n    getNode().addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchor.getNode());\n    return (GrStatement) result;\n  }","commit_id":"319f6cbe9cc2acb2ed2a3950bf63eed13249177a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static InlineHandler.Settings inlineMethodSettings(GrMethod method, Editor editor, boolean invokedOnReference) {\n\n    final Project project = method.getProject();\n    PsiReference reference = editor != null ? TargetElementUtil.findReference(editor, editor.getCaretModel().getOffset()) : null;\n    if (!invokedOnReference || reference == null) {\n      String message = GroovyRefactoringBundle.message(\"multiple.method.inline.is.not.suppored\", REFACTORING_NAME);\n      showErrorMessage(message, project);\n      return null;\n    }\n\n    final Collection<PsiReference> refs = ReferencesSearch.search(method, GlobalSearchScope.projectScope(method.getProject()), false).findAll();\n    ArrayList<PsiElement> exprs = new ArrayList<PsiElement>();\n    PsiElement element = reference.getElement();\n    if (element != null && element.getContainingFile() instanceof GroovyFile) {\n      if (isStaticMethod(method) || areInSameClass(element, method)) { // todo implement for other cases\n        exprs.add(element);\n      }\n    }\n    if (element instanceof GrExpression && PsiTreeUtil.getParentOfType(element, GrParameter.class) != null) {\n      String message = GroovyRefactoringBundle.message(\"refactoring.is.not.supported.in.parameter.initializers\", REFACTORING_NAME);\n      showErrorMessage(message, project);\n      return null;\n    }\n\n\n    GroovyRefactoringUtil.highlightOccurrences(project, editor, exprs.toArray(PsiElement.EMPTY_ARRAY));\n    if (method.getBlock() == null) {\n      String message;\n      if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        message = GroovyRefactoringBundle.message(\"refactoring.cannot.be.applied.to.abstract.methods\", REFACTORING_NAME);\n      } else {\n        message = GroovyRefactoringBundle.message(\"refactoring.cannot.be.applied.no.sources.attached\", REFACTORING_NAME);\n      }\n      showErrorMessage(message, project);\n      return null;\n    }\n\n    if (hasBadReturns(method)) { //todo process tail method calls\n      String message = GroovyRefactoringBundle.message(\"refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow\", REFACTORING_NAME);\n      showErrorMessage(message, project);\n      return null;\n    }\n\n    if (method.isConstructor()) {\n      String message = GroovyRefactoringBundle.message(\"refactoring.cannot.be.applied.to.constructors\", REFACTORING_NAME);\n      showErrorMessage(message, project);\n      return null;\n    }\n\n    return inlineMethodDialogResult(GroovyRefactoringUtil.getMethodSignature(method), project);\n  }","id":83971,"modified_method":"public static InlineHandler.Settings inlineMethodSettings(GrMethod method, Editor editor, boolean invokedOnReference) {\n\n    final Project project = method.getProject();\n    if (method.isConstructor()) {\n      String message = GroovyRefactoringBundle.message(\"refactoring.cannot.be.applied.to.constructors\", REFACTORING_NAME);\n      showErrorMessage(message, project);\n      return null;\n    }\n\n    PsiReference reference = editor != null ? TargetElementUtil.findReference(editor, editor.getCaretModel().getOffset()) : null;\n    if (!invokedOnReference || reference == null) {\n      String message = GroovyRefactoringBundle.message(\"multiple.method.inline.is.not.suppored\", REFACTORING_NAME);\n      showErrorMessage(message, project);\n      return null;\n    }\n\n    PsiElement element = reference.getElement();\n\n    if (element.getContainingFile() instanceof GroovyFile) {\n      if (!(isStaticMethod(method) || areInSameClass(element, method))) { // todo implement for other cases\n//        showErrorMessage(\"Other class support will be implemented soon\", project);\n//        return null;\n      }\n    }\n\n    if (!(element instanceof GrExpression && element.getParent() instanceof GrCallExpression)) {\n      String message = GroovyRefactoringBundle.message(\"refactoring.is.available.only.for.method.calls\", REFACTORING_NAME);\n      showErrorMessage(message, project);\n      return null;\n    }\n\n    GrCallExpression call = (GrCallExpression) element.getParent();\n\n    if (PsiTreeUtil.getParentOfType(element, GrParameter.class) != null) {\n      String message = GroovyRefactoringBundle.message(\"refactoring.is.not.supported.in.parameter.initializers\", REFACTORING_NAME);\n      showErrorMessage(message, project);\n      return null;\n    }\n\n\n    GroovyRefactoringUtil.highlightOccurrences(project, editor, new GrExpression[]{call});\n    if (method.getBlock() == null) {\n      String message;\n      if (method.hasModifierProperty(PsiModifier.ABSTRACT)) {\n        message = GroovyRefactoringBundle.message(\"refactoring.cannot.be.applied.to.abstract.methods\", REFACTORING_NAME);\n      } else {\n        message = GroovyRefactoringBundle.message(\"refactoring.cannot.be.applied.no.sources.attached\", REFACTORING_NAME);\n      }\n      showErrorMessage(message, project);\n      return null;\n    }\n\n    if (hasBadReturns(method) && !isTailMethodCall(call)) { \n      String message = GroovyRefactoringBundle.message(\"refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow\", REFACTORING_NAME);\n      showErrorMessage(message, project);\n      return null;\n    }\n\n    return inlineMethodDialogResult(GroovyRefactoringUtil.getMethodSignature(method), project);\n  }","commit_id":"319f6cbe9cc2acb2ed2a3950bf63eed13249177a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void inlineReference(PsiReference reference, PsiElement referenced) {\n    PsiElement element = reference.getElement();\n    assert element instanceof GrExpression && element.getParent() instanceof GrCallExpression;\n    GrCallExpression call = (GrCallExpression) element.getParent();\n    PsiElement position = inlineReferenceImpl(call, myMethod, isOnExpressionOrReturnPlace(call));\n    if (position != null) {\n      Project project = position.getProject();\n      FileEditorManager manager = FileEditorManager.getInstance(project);\n      Editor editor = manager.getSelectedTextEditor();\n      GroovyRefactoringUtil.highlightOccurrences(project, editor, new PsiElement[]{position});\n      WindowManager.getInstance().getStatusBar(project).setInfo(GroovyRefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n    }\n\n  }","id":83972,"modified_method":"public void inlineReference(PsiReference reference, PsiElement referenced) {\n    PsiElement element = reference.getElement();\n    assert element instanceof GrExpression && element.getParent() instanceof GrCallExpression;\n    GrCallExpression call = (GrCallExpression) element.getParent();\n    PsiElement position = inlineReferenceImpl(call, myMethod, isOnExpressionOrReturnPlace(call), GroovyInlineMethodUtil.isTailMethodCall(call));\n\n    // highilght replaced result\n    if (position != null && position instanceof GrExpression) {\n      Project project = referenced.getProject();\n      FileEditorManager manager = FileEditorManager.getInstance(project);\n      Editor editor = manager.getSelectedTextEditor();\n      GroovyRefactoringUtil.highlightOccurrences(project, editor, new PsiElement[]{position});\n      WindowManager.getInstance().getStatusBar(project).setInfo(GroovyRefactoringBundle.message(\"press.escape.to.remove.the.highlighting\"));\n    }\n    if (position != null) {\n      GrVariableDeclarationOwner owner = position instanceof GrVariableDeclarationOwner ?\n          ((GrVariableDeclarationOwner) position) :\n          PsiTreeUtil.getParentOfType(position, GrVariableDeclarationOwner.class);\n      if (owner != null) {\n        try {\n          reformatOwner(owner);\n        } catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","commit_id":"319f6cbe9cc2acb2ed2a3950bf63eed13249177a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static PsiElement inlineReferenceImpl(GrCallExpression call, GrMethod method, boolean replaceCall) {\n    try {\n\n      GrMethod newMethod = prepareNewMethod(call, method);\n      GrExpression result = getAloneResultExpression(newMethod);\n      if (result != null) {\n        return call.replaceWithExpression(result, true);\n      }\n\n      String resultName = InlineMethodConflictSolver.suggestNewName(\"result\", newMethod, call);\n      GrVariableDeclarationOwner owner = PsiTreeUtil.getParentOfType(call, GrVariableDeclarationOwner.class);\n      PsiElement element = call;\n      assert owner != null;\n      while (element != null && element.getParent() != owner) {\n        element = element.getParent();\n      }\n      assert element != null && element instanceof GrStatement;\n      GrStatement anchor = (GrStatement) element;\n\n      if (!replaceCall) {\n        assert anchor == call;\n      }\n\n      GroovyElementFactory factory = GroovyElementFactory.getInstance(call.getProject());\n\n      // Add variable for method result\n      Collection<GrReturnStatement> returnStatements = GroovyRefactoringUtil.findReturnStatements(newMethod);\n\n      boolean hasTailExpr = GroovyRefactoringUtil.hasTailReturnExpression(method);\n      boolean hasReturnStatements = returnStatements.size() > 0;\n      PsiType methodType = method.getReturnType();\n      if (hasReturnStatements && PsiType.VOID != methodType) {\n        GrVariableDeclaration resultDecl = factory.createVariableDeclaration(new String[0], resultName, null, methodType, false);\n        owner.addStatementBefore(resultDecl, anchor);\n\n        // Replace all return statements with assignments to 'reslut' variable\n        for (GrReturnStatement returnStatement : returnStatements) {\n          GrExpression value = returnStatement.getReturnValue();\n          if (value != null) {\n            GrExpression assignment = factory.createExpressionFromText(resultName + \" = \" + value.getText());\n            returnStatement.replaceWithStatement(assignment);\n          } else {\n            returnStatement.replaceWithStatement(factory.createExpressionFromText(resultName + \" = null\"));\n          }\n        }\n      }\n      if (PsiType.VOID == methodType) {\n        for (GrReturnStatement returnStatement : returnStatements) {\n          returnStatement.removeStatement();\n        }\n      }\n\n      // Add all method statements\n      GrOpenBlock body = newMethod.getBlock();\n      assert body != null;\n      GrStatement[] statements = body.getStatements();\n      for (GrStatement statement : statements) {\n        if (!(statements.length > 0 && statement == statements[statements.length-1] && hasTailExpr)) {\n          owner.addStatementBefore(statement, anchor);\n        }\n      }\n      if (replaceCall) {\n        GrExpression resultExpr;\n        if (PsiType.VOID == methodType) {\n          resultExpr = factory.createExpressionFromText(\"null\");\n        } else if (hasReturnStatements) {\n          resultExpr = factory.createExpressionFromText(resultName);\n        } else if (hasTailExpr){\n          resultExpr = ((GrExpression) statements[statements.length - 1]);\n        } else {\n          resultExpr = factory.createExpressionFromText(\"null\");\n        }\n        return call.replaceWithExpression(resultExpr, true);\n      } else {\n        // remove method call\n//        PsiElement prev = call.getPrevSibling();\n        call.removeStatement();\n//        return prev;\n        return null;\n      }\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return null;\n  }","id":83973,"modified_method":"static PsiElement inlineReferenceImpl(GrCallExpression call, GrMethod method, boolean replaceCall, boolean isTailMethodCall) {\n    try {\n\n      GrMethod newMethod = prepareNewMethod(call, method);\n      GrExpression result = getAloneResultExpression(newMethod);\n      if (result != null) {\n        return call.replaceWithExpression(result, true);\n      }\n\n      String resultName = InlineMethodConflictSolver.suggestNewName(\"result\", newMethod, call);\n      GroovyElementFactory factory = GroovyElementFactory.getInstance(call.getProject());\n\n      // Add variable for method result\n      Collection<GrReturnStatement> returnStatements = GroovyRefactoringUtil.findReturnStatements(newMethod);\n      boolean hasTailExpr = GroovyRefactoringUtil.hasTailReturnExpression(method);\n      boolean hasReturnStatements = returnStatements.size() > 0;\n      PsiType methodType = method.getReturnType();\n      GrOpenBlock body = newMethod.getBlock();\n      assert body != null;\n      GrStatement[] statements = body.getStatements();\n      GrExpression replaced = null;\n      if (replaceCall && !isTailMethodCall) {\n        GrExpression resultExpr;\n        if (PsiType.VOID == methodType) {\n          resultExpr = factory.createExpressionFromText(\"null\");\n        } else if (hasReturnStatements) {\n          resultExpr = factory.createExpressionFromText(resultName);\n        } else if (hasTailExpr) {\n          GrExpression expr = (GrExpression) statements[statements.length - 1];\n          resultExpr = factory.createExpressionFromText(expr.getText());\n        } else {\n          resultExpr = factory.createExpressionFromText(\"null\");\n        }\n        replaced = call.replaceWithExpression(resultExpr, true);\n      }\n\n      // Calculate anchor to insert before\n      GrExpression enclosingExpr = changeEnclosingStatement(replaced != null ? replaced : call);\n      GrVariableDeclarationOwner owner = PsiTreeUtil.getParentOfType(enclosingExpr, GrVariableDeclarationOwner.class);\n      PsiElement element = enclosingExpr;\n      assert owner != null;\n      while (element != null && element.getParent() != owner) {\n        element = element.getParent();\n      }\n      assert element != null && element instanceof GrStatement;\n      GrStatement anchor = (GrStatement) element;\n\n      if (!replaceCall) {\n        assert anchor == enclosingExpr;\n      }\n\n      // Process method return statements\n      if (hasReturnStatements && PsiType.VOID != methodType && !isTailMethodCall) {\n        GrVariableDeclaration resultDecl = factory.createVariableDeclaration(new String[0], resultName, null, methodType, false);\n        owner.addStatementBefore(resultDecl, anchor);\n\n        // Replace all return statements with assignments to 'result' variable\n        for (GrReturnStatement returnStatement : returnStatements) {\n          GrExpression value = returnStatement.getReturnValue();\n          if (value != null) {\n            GrExpression assignment = factory.createExpressionFromText(resultName + \" = \" + value.getText());\n            returnStatement.replaceWithStatement(assignment);\n          } else {\n            returnStatement.replaceWithStatement(factory.createExpressionFromText(resultName + \" = null\"));\n          }\n        }\n      }\n      if (PsiType.VOID == methodType && !isTailMethodCall) {\n        for (GrReturnStatement returnStatement : returnStatements) {\n          returnStatement.removeStatement();\n        }\n      }\n\n      // Add all method statements\n      statements = body.getStatements();\n      for (GrStatement statement : statements) {\n        if (!(statements.length > 0 && statement == statements[statements.length - 1] && hasTailExpr)) {\n          owner.addStatementBefore(statement, anchor);\n        }\n      }\n      if (replaceCall && !isTailMethodCall) {\n        return replaced;\n      } else {\n        GrStatement stmt;\n        if (isTailMethodCall && enclosingExpr.getParent() instanceof GrReturnStatement) {\n          stmt = ((GrReturnStatement) enclosingExpr.getParent());\n        } else {\n          stmt = enclosingExpr;\n        }\n        stmt.removeStatement();\n        return owner;\n      }\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return null;\n  }","commit_id":"319f6cbe9cc2acb2ed2a3950bf63eed13249177a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void removeStatement() throws IncorrectOperationException {\n    if (getParent() == null ||\n        getParent().getNode() == null) {\n      throw new IncorrectOperationException();\n    }\n    ASTNode parentNode = getParent().getNode();\n    parentNode.removeChild(this.getNode());\n  }","id":83974,"modified_method":"public void removeStatement() throws IncorrectOperationException {\n    if (getParent() == null ||\n        getParent().getNode() == null) {\n      throw new IncorrectOperationException();\n    }\n    ASTNode parentNode = getParent().getNode();\n    ASTNode prevNode = getNode().getTreePrev();\n    parentNode.removeChild(this.getNode());\n    if (prevNode != null && TokenSets.SEPARATORS.contains(prevNode.getElementType())) {\n      parentNode.removeChild(prevNode);\n    }\n  }","commit_id":"319f6cbe9cc2acb2ed2a3950bf63eed13249177a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isValidNameUp(@NotNull String name, PsiElement startElement, GrCallExpression call) {\n    PsiElement prevSibling = startElement.getPrevSibling();\n    while (prevSibling != null) {\n      if (!isValidNameDown(name, prevSibling, call)) return false;\n      prevSibling = prevSibling.getPrevSibling();\n    }\n\n    PsiElement parent = startElement.getParent();\n    return parent == null || parent instanceof PsiDirectory || isValidNameUp(name, parent, call);\n  }","id":83975,"modified_method":"private static boolean isValidNameUp(@NotNull String name, PsiElement startElement, GrCallExpression call) {\n    if (startElement instanceof PsiFile) {\n      return true;\n    }\n    \n    PsiElement prevSibling = startElement.getPrevSibling();\n    while (prevSibling != null) {\n      if (!isValidNameDown(name, prevSibling, call)) {\n        return false;\n      }\n      prevSibling = prevSibling.getPrevSibling();\n    }\n\n    PsiElement parent = startElement.getParent();\n    return parent == null || parent instanceof PsiDirectory || isValidNameUp(name, parent, call);\n  }","commit_id":"319f6cbe9cc2acb2ed2a3950bf63eed13249177a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected String processFile(String fileText) throws IncorrectOperationException, InvalidDataException, IOException {\n    String result = \"\";\n    int startOffset = fileText.indexOf(BEGIN_MARKER);\n    fileText = TestUtils.removeBeginMarker(fileText, startOffset);\n    int endOffset = fileText.indexOf(END_MARKER);\n    fileText = TestUtils.removeEndMarker(fileText, endOffset);\n    PsiFile file = TestUtils.createPseudoPhysicalFile(myProject, fileText);\n\n    Assert.assertNotNull(file);\n\n    // Create physical file\n    String modulePath = myFixture.getTempDirPath();\n    File realFile = new File(modulePath + \"/\" + TestUtils.TEMP_FILE);\n    FileWriter fstream = new FileWriter(realFile);\n    BufferedWriter out = new BufferedWriter(fstream);\n    out.write(file.getText());\n    out.close();\n\n    VirtualFileManager fileManager = VirtualFileManager.getInstance();\n    fileManager.refresh(false);\n    VirtualFile virtualFile = fileManager.findFileByUrl(\"file://\" + modulePath + \"/\" + TestUtils.TEMP_FILE);\n\n    assert virtualFile != null;\n\n    FileEditorManager fileEditorManager = FileEditorManager.getInstance(myProject);\n    Editor myEditor = fileEditorManager.openTextEditor(new OpenFileDescriptor(myProject, virtualFile, 0), false);\n    assert myEditor != null;\n\n\n    file = PsiManager.getInstance(myProject).findFile(virtualFile);\n    Assert.assertTrue(file instanceof GroovyFileBase);\n\n    PsiDocumentManager manager = PsiDocumentManager.getInstance(myProject);\n    try {\n      myEditor.getSelectionModel().setSelection(startOffset, endOffset);\n      myEditor.getCaretModel().moveToOffset(endOffset);\n\n      GroovyPsiElement selectedArea = GroovyRefactoringUtil.findElementInRange(((GroovyFileBase) file), startOffset, endOffset, GrReferenceExpression.class);\n      if (selectedArea == null) {\n        PsiElement identifier = GroovyRefactoringUtil.findElementInRange(((GroovyFileBase) file), startOffset,\n            endOffset, PsiElement.class);\n        if (identifier != null){\n          Assert.assertTrue(\"Selected area doesn't point to method\", identifier.getParent() instanceof GrVariable);\n          selectedArea = (GrMethod)identifier.getParent();\n        }\n      }\n      Assert.assertNotNull(\"Selected area reference points to nothing\", selectedArea);\n      PsiReference reference = selectedArea.getReference();\n      assert reference != null;\n      PsiElement element = selectedArea instanceof GrExpression ? reference.resolve() : selectedArea;\n      Assert.assertNotNull(\"Cannot resolve selected reference expression\", element);\n      Assert.assertTrue(element instanceof GrMethod);\n\n      // handling inline refactoring\n      GenericInlineHandler.invoke(element, myEditor, new GroovyInlineHandler());\n      result = myEditor.getDocument().getText();\n      int caretOffset = myEditor.getCaretModel().getOffset();\n      String invokedResult = GroovyInlineMethodUtil.getInvokedResult();\n      result = \"ok\".equals(invokedResult) ?\n          result : //result.substring(0, caretOffset) + CARET_MARKER + result.substring(caretOffset) :\n          \"FAIL: \" + invokedResult;\n    } finally {\n      fileEditorManager.closeFile(virtualFile);\n      realFile.delete();\n      myEditor = null;\n    }\n\n    return result;\n  }","id":83976,"modified_method":"protected String processFile(String fileText) throws IncorrectOperationException, InvalidDataException, IOException {\n    String result = \"\";\n    int startOffset = fileText.indexOf(BEGIN_MARKER);\n    fileText = TestUtils.removeBeginMarker(fileText, startOffset);\n    int endOffset = fileText.indexOf(END_MARKER);\n    fileText = TestUtils.removeEndMarker(fileText, endOffset);\n    PsiFile file = TestUtils.createPseudoPhysicalFile(myProject, fileText);\n\n    Assert.assertNotNull(file);\n\n    // Create physical file\n    String modulePath = myFixture.getTempDirPath();\n    File realFile = new File(modulePath + \"/\" + TestUtils.TEMP_FILE);\n    FileWriter fstream = new FileWriter(realFile);\n    BufferedWriter out = new BufferedWriter(fstream);\n    out.write(file.getText());\n    out.close();\n\n    VirtualFileManager fileManager = VirtualFileManager.getInstance();\n    fileManager.refresh(false);\n    VirtualFile virtualFile = fileManager.findFileByUrl(\"file://\" + modulePath + \"/\" + TestUtils.TEMP_FILE);\n\n    assert virtualFile != null;\n\n    FileEditorManager fileEditorManager = FileEditorManager.getInstance(myProject);\n    Editor myEditor = fileEditorManager.openTextEditor(new OpenFileDescriptor(myProject, virtualFile, 0), false);\n    assert myEditor != null;\n\n\n    file = PsiManager.getInstance(myProject).findFile(virtualFile);\n    Assert.assertTrue(file instanceof GroovyFileBase);\n\n    setIndentationToNode(file.getNode());\n    PsiDocumentManager manager = PsiDocumentManager.getInstance(myProject);\n    try {\n      myEditor.getSelectionModel().setSelection(startOffset, endOffset);\n      myEditor.getCaretModel().moveToOffset(endOffset);\n\n      GroovyPsiElement selectedArea = GroovyRefactoringUtil.findElementInRange(((GroovyFileBase) file), startOffset, endOffset, GrReferenceExpression.class);\n      if (selectedArea == null) {\n        PsiElement identifier = GroovyRefactoringUtil.findElementInRange(((GroovyFileBase) file), startOffset,\n            endOffset, PsiElement.class);\n        if (identifier != null){\n          Assert.assertTrue(\"Selected area doesn't point to method\", identifier.getParent() instanceof GrVariable);\n          selectedArea = (GrMethod)identifier.getParent();\n        }\n      }\n      Assert.assertNotNull(\"Selected area reference points to nothing\", selectedArea);\n      PsiReference reference = selectedArea.getReference();\n      assert reference != null;\n      PsiElement element = selectedArea instanceof GrExpression ? reference.resolve() : selectedArea;\n      Assert.assertNotNull(\"Cannot resolve selected reference expression\", element);\n      Assert.assertTrue(element instanceof GrMethod);\n\n      // handling inline refactoring\n      GenericInlineHandler.invoke(element, myEditor, new GroovyInlineHandler());\n      result = myEditor.getDocument().getText();\n      int caretOffset = myEditor.getCaretModel().getOffset();\n      String invokedResult = GroovyInlineMethodUtil.getInvokedResult();\n      result = \"ok\".equals(invokedResult) ?\n          result : //result.substring(0, caretOffset) + CARET_MARKER + result.substring(caretOffset) :\n          \"FAIL: \" + invokedResult;\n    } finally {\n      fileEditorManager.closeFile(virtualFile);\n      realFile.delete();\n      myEditor = null;\n    }\n\n    return result;\n  }","commit_id":"319f6cbe9cc2acb2ed2a3950bf63eed13249177a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static <T extends PsiElement> ElementManipulator<T> getManipulator(T currentElement){\n    return ElementManipulators.getManipulator(currentElement);\n  }","id":83977,"modified_method":"@NotNull\n  public static <T extends PsiElement> ElementManipulator<T> getManipulator(T currentElement){\n    ElementManipulator<T> manipulator = ElementManipulators.getManipulator(currentElement);\n    if (manipulator == null) {\n      throw new IncorrectOperationException(\"Manipulator for this element is not defined: \" + currentElement);\n    }\n    return manipulator;\n  }","commit_id":"4d76a4ba8d16347d79d96c448072589c805117f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n    final ElementManipulator<PsiElement> manipulator = CachingReference.getManipulator(getElement());\n    if (manipulator != null) {\n      myFileReferenceSet.setElement(manipulator.handleContentChange(getElement(), getRangeInElement(), newElementName));\n      //Correct ranges\n      int delta = newElementName.length() - myRange.getLength();\n      myRange = new TextRange(getRangeInElement().getStartOffset(), getRangeInElement().getStartOffset() + newElementName.length());\n      FileReference[] references = myFileReferenceSet.getAllReferences();\n      for (int idx = myIndex + 1; idx < references.length; idx++) {\n        references[idx].myRange = references[idx].myRange.shiftRight(delta);\n      }\n      return myFileReferenceSet.getElement();\n    }\n    throw new IncorrectOperationException(\"Manipulator for this element is not defined: \" + getElement());\n  }","id":83978,"modified_method":"@Override\n  public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n    final ElementManipulator<PsiElement> manipulator = CachingReference.getManipulator(getElement());\n    myFileReferenceSet.setElement(manipulator.handleContentChange(getElement(), getRangeInElement(), newElementName));\n    //Correct ranges\n    int delta = newElementName.length() - myRange.getLength();\n    myRange = new TextRange(getRangeInElement().getStartOffset(), getRangeInElement().getStartOffset() + newElementName.length());\n    FileReference[] references = myFileReferenceSet.getAllReferences();\n    for (int idx = myIndex + 1; idx < references.length; idx++) {\n      references[idx].myRange = references[idx].myRange.shiftRight(delta);\n    }\n    return myFileReferenceSet.getElement();\n  }","commit_id":"4d76a4ba8d16347d79d96c448072589c805117f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n    if (isReferenceTo(element)) return getElement();\n\n    final String newName;\n    if (element instanceof PsiClass) {\n      PsiClass psiClass = (PsiClass)element;\n      final boolean jvmFormat = Boolean.TRUE.equals(JavaClassReferenceProvider.JVM_FORMAT.getValue(getOptions()));\n      newName = jvmFormat ? ClassUtil.getJVMClassName(psiClass) : psiClass.getQualifiedName();\n    }\n    else if (element instanceof PsiPackage) {\n      PsiPackage psiPackage = (PsiPackage)element;\n      newName = psiPackage.getQualifiedName();\n    }\n    else {\n      throw new IncorrectOperationException(\"Cannot bind to \" + element);\n    }\n    assert newName != null;\n\n    int end = getRangeInElement().getEndOffset();\n    String text = getElement().getText();\n    int lt = text.indexOf('<', getRangeInElement().getStartOffset());\n    if (lt >= 0 && lt < end) {\n      end = CharArrayUtil.shiftBackward(text, lt - 1, \"\\n\\t \") + 1;\n    }\n    TextRange range = new TextRange(myJavaClassReferenceSet.getReference(0).getRangeInElement().getStartOffset(), end);\n    final ElementManipulator<PsiElement> manipulator = getManipulator(getElement());\n    if (manipulator != null) {\n      final PsiElement finalElement = manipulator.handleContentChange(getElement(), range, newName);\n      myJavaClassReferenceSet.reparse(finalElement, TextRange.from(range.getStartOffset(), newName.length()));\n      return finalElement;\n    }\n    return element;\n  }","id":83979,"modified_method":"@Override\n  public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n    if (isReferenceTo(element)) return getElement();\n\n    final String newName;\n    if (element instanceof PsiClass) {\n      PsiClass psiClass = (PsiClass)element;\n      final boolean jvmFormat = Boolean.TRUE.equals(JavaClassReferenceProvider.JVM_FORMAT.getValue(getOptions()));\n      newName = jvmFormat ? ClassUtil.getJVMClassName(psiClass) : psiClass.getQualifiedName();\n    }\n    else if (element instanceof PsiPackage) {\n      PsiPackage psiPackage = (PsiPackage)element;\n      newName = psiPackage.getQualifiedName();\n    }\n    else {\n      throw new IncorrectOperationException(\"Cannot bind to \" + element);\n    }\n    assert newName != null;\n\n    int end = getRangeInElement().getEndOffset();\n    String text = getElement().getText();\n    int lt = text.indexOf('<', getRangeInElement().getStartOffset());\n    if (lt >= 0 && lt < end) {\n      end = CharArrayUtil.shiftBackward(text, lt - 1, \"\\n\\t \") + 1;\n    }\n    TextRange range = new TextRange(myJavaClassReferenceSet.getReference(0).getRangeInElement().getStartOffset(), end);\n    final ElementManipulator<PsiElement> manipulator = getManipulator(getElement());\n    final PsiElement finalElement = manipulator.handleContentChange(getElement(), range, newName);\n    myJavaClassReferenceSet.reparse(finalElement, TextRange.from(range.getStartOffset(), newName.length()));\n    return finalElement;\n  }","commit_id":"4d76a4ba8d16347d79d96c448072589c805117f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n    final ElementManipulator<PsiElement> manipulator = getManipulator(getElement());\n    if (manipulator != null) {\n      final PsiElement element = manipulator.handleContentChange(getElement(), getRangeInElement(), newElementName);\n      myRange = new TextRange(getRangeInElement().getStartOffset(), getRangeInElement().getStartOffset() + newElementName.length());\n      return element;\n    }\n    throw new IncorrectOperationException(\"Manipulator for this element is not defined: \" + getElement());\n  }","id":83980,"modified_method":"@Override\n  public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n    final ElementManipulator<PsiElement> manipulator = getManipulator(getElement());\n    final PsiElement element = manipulator.handleContentChange(getElement(), getRangeInElement(), newElementName);\n    myRange = new TextRange(getRangeInElement().getStartOffset(), getRangeInElement().getStartOffset() + newElementName.length());\n    return element;\n  }","commit_id":"4d76a4ba8d16347d79d96c448072589c805117f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected static PsiLanguageInjectionHost findInjectionHost(Editor editor, PsiFile file) {\n    if (editor instanceof EditorWindow) return null;\n    final int offset = editor.getCaretModel().getOffset();\n    final PsiLanguageInjectionHost host = PsiTreeUtil.getParentOfType(file.findElementAt(offset), PsiLanguageInjectionHost.class, false);\n    if (host == null) return null;\n    final TextRange textRange = ElementManipulators.getManipulator(host).getRangeInElement(host);\n    if (textRange.getStartOffset() == 0) return null;\n    return host;\n  }","id":83981,"modified_method":"@Nullable\n  protected static PsiLanguageInjectionHost findInjectionHost(Editor editor, PsiFile file) {\n    if (editor instanceof EditorWindow) return null;\n    final int offset = editor.getCaretModel().getOffset();\n    final PsiLanguageInjectionHost host = PsiTreeUtil.getParentOfType(file.findElementAt(offset), PsiLanguageInjectionHost.class, false);\n    if (host == null) return null;\n    final ElementManipulator<PsiLanguageInjectionHost> manipulator = ElementManipulators.getManipulator(host);\n    if (manipulator == null) return null;\n    final TextRange textRange = manipulator.getRangeInElement(host);\n    if (textRange.getStartOffset() == 0) return null;\n    return host;\n  }","commit_id":"fc5e52367e1de3063c0f10faa68e8ffb5451ad84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  ElementManipulator<T> getManipulator() {\n    return ElementManipulators.getManipulator(myElement);\n  }","id":83982,"modified_method":"ElementManipulator<T> getManipulator() {\n    ElementManipulator<T> manipulator = ElementManipulators.getManipulator(myElement);\n    if (manipulator == null) {\n      LOG.error(\"Cannot find manipulator for \" + myElement + \" in \" + this + \" class \" + getClass());\n    }\n    return manipulator;\n  }","commit_id":"45cfecd3cfc43c08467ba6ee3ed7c5be9e0b1063","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n    final ElementManipulator<T> manipulator = getManipulator();\n    assert manipulator != null: \"Cannot find manipulator for \" + myElement;\n    return manipulator.handleContentChange(myElement, getRangeInElement(), newElementName);\n  }","id":83983,"modified_method":"public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n    return getManipulator().handleContentChange(myElement, getRangeInElement(), newElementName);\n  }","commit_id":"45cfecd3cfc43c08467ba6ee3ed7c5be9e0b1063","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected TextRange calculateDefaultRangeInElement() {\n    final ElementManipulator<T> manipulator = getManipulator();\n    assert manipulator != null: \"Cannot find manipulator for \" + myElement;\n    return manipulator.getRangeInElement(myElement);\n  }","id":83984,"modified_method":"protected TextRange calculateDefaultRangeInElement() {\n    return getManipulator().getRangeInElement(myElement);\n  }","commit_id":"45cfecd3cfc43c08467ba6ee3ed7c5be9e0b1063","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement bindToElement(PsiElement element) throws IncorrectOperationException{\n    if (!(element instanceof PsiFileSystemItem)) throw new IncorrectOperationException(\"Cannot bind to element\");\n\n    final String newName = JspUtil.getDeploymentPath((PsiFileSystemItem)element);\n    final TextRange range = new TextRange(myFileReferenceSet.getStartInElement(), getRangeInElement().getEndOffset());\n    return getManipulator(getElement()).handleContentChange(getElement(), range, newName);\n  }","id":83985,"modified_method":"public PsiElement bindToElement(PsiElement element) throws IncorrectOperationException{\n    if (!(element instanceof PsiFileSystemItem)) throw new IncorrectOperationException(\"Cannot bind to element\");\n\n    final String newName = JspUtil.getDeploymentPath((PsiFileSystemItem)element);\n    final TextRange range = new TextRange(myFileReferenceSet.getStartInElement(), getRangeInElement().getEndOffset());\n    final ElementManipulator<PsiElement> manipulator = getManipulator(getElement());\n    if (manipulator == null) {\n      throw new IncorrectOperationException(\"Manipulator not defined for: \" + getElement());\n    }\n    return manipulator.handleContentChange(getElement(), range, newName);\n  }","commit_id":"3c73c0bc219330288b677f6b2254d7b268e7c209","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void warnIfRegexpSyntaxNotKosher(final List<Element> elements,\r\n            final String ruleId,final String ruleSubId, final Language lang) {\r\n        int i = 0;\r\n        for (final Element element : elements) {\r\n          i++;\r\n\r\n          if (element.isReferenceElement()) {\r\n              continue;\r\n          }\r\n\r\n          // Check whether token value is consistent with regexp=\"...\"\r\n          warnIfElementNotKosher(\r\n            element.getString(),\r\n            element.isRegularExpression(),\r\n            element.isCaseSensitive(),\r\n            element.getNegation(),\r\n            element.isInflected(),\r\n            false,  // not a POS\r\n            lang, ruleId + \":\" + ruleSubId,\r\n            i);\r\n\r\n          // Check postag=\"...\" is consistent with postag_regexp=\"...\"\r\n          warnIfElementNotKosher(\r\n            element.getPOStag() == null ? \"\" : element.getPOStag(),\r\n            element.isPOStagRegularExpression(),\r\n            element.isCaseSensitive(),\r\n            element.getPOSNegation(),\r\n            false,\r\n            true,   // a POS.\r\n            lang, ruleId + \":\" + ruleSubId + \" (POS tag)\",\r\n            i);\r\n\r\n          final List<Element> exceptionElements = new ArrayList<>();\r\n          if (element.getExceptionList() != null) {\r\n            for (final Element exception: element.getExceptionList()) {\r\n              // Detect useless exception or missing skip=\"...\". I.e. things like this:\r\n              // <token postag=\"...\"><exception scope=\"next\">foo<\/exception<\/token>\r\n              if (exception.hasNextException() && element.getSkipNext() == 0) {\r\n                System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                    + ruleId + \":\" + ruleSubId\r\n                    + \" (exception in token [\" + i + \"])\"\r\n                    + \" has no skip=\\\"...\\\" and yet contains scope=\\\"next\\\"\"\r\n                    + \" so the exception never applies.\"\r\n                    + \" Did you forget skip=\\\"...\\\"?\");\r\n              }\r\n\r\n              // Detect exception that can't possibly be matched. Example:\r\n              // <token>foo<exception>bar<\/exception><\/token>\r\n              // This could be improved to detect for example useless\r\n              // exception in :\r\n              // <token regexp=\"yes\">foo|bar<exception>xxx<\/exception><\/token>\r\n              if (!element.isRegularExpression()\r\n                && !element.getString().isEmpty()\r\n                && !element.getNegation()\r\n                && !element.isInflected()\r\n                && element.getSkipNext() == 0\r\n                && element.getPOStag() == null\r\n                && exception.getPOStag() == null\r\n                && element.isCaseSensitive() == exception.isCaseSensitive()) {\r\n                System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                    + ruleId + \":\" + ruleSubId\r\n                    + \" exception in token [\" + i + \"] seems useless.\"\r\n                    + \" Did you forget skip=\\\"...\\\" or scope=\\\"previous\\\"?\");\r\n              }\r\n\r\n              // Check whether exception value is consistent with regexp=\"...\"\r\n              // Don't check string \".\" since it is sometimes used as a regexp\r\n              // and sometimes used as non regexp.\r\n              if (!exception.getString().equals(\".\")) {\r\n                warnIfElementNotKosher(\r\n                  exception.getString(),\r\n                  exception.isRegularExpression(),\r\n                  exception.isCaseSensitive(),\r\n                  exception.getNegation(),\r\n                  exception.isInflected(),\r\n                  false,  // not a POS\r\n                  lang,\r\n                  ruleId + \":\" + ruleSubId+ \" (exception in token [\" + i + \"])\",\r\n                  i);\r\n              }\r\n              // Check postag=\"...\" of exception is consistent with postag_regexp=\"...\"\r\n              warnIfElementNotKosher(\r\n                exception.getPOStag() == null ? \"\" : exception.getPOStag(),\r\n                exception.isPOStagRegularExpression(),\r\n                exception.isCaseSensitive(),\r\n                exception.getPOSNegation(),\r\n                false,\r\n                true,  // a POS\r\n                lang,\r\n                ruleId + \":\" + ruleSubId + \" (exception in POS tag of token [\" + i + \"])\",\r\n                i);\r\n\r\n              // Search for duplicate exceptions (which are useless).\r\n              // Since there are 2 nested loops on the list of exceptions,\r\n              // this has thus a O(n^2) complexity, where n is the number\r\n              // of exceptions in a token. But n is small and it is also\r\n              // for testing only so that's OK.\r\n              for (final Element otherException: exceptionElements) {\r\n                if (equalException(exception, otherException)) {\r\n                  System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                      + ruleId + \":\" + ruleSubId\r\n                      + \" in token [\" + i + \"]\"\r\n                      + \" contains duplicate exceptions with\"\r\n                      + \" string=[\" + exception.getString() + \"]\"\r\n                      + \" POS tag=[\" + exception.getPOStag() + \"]\"\r\n                      + \" negate=[\" + exception.getNegation() + \"]\"\r\n                      + \" POS negate=[\" + exception.getPOSNegation() + \"]\");\r\n                  break;\r\n                }\r\n              }\r\n              exceptionElements.add(exception);\r\n            }\r\n          }\r\n        }\r\n\r\n    }","id":83986,"modified_method":"public static void warnIfRegexpSyntaxNotKosher(final List<Element> elements,\r\n            final String ruleId,final String ruleSubId, final Language lang) {\r\n        int i = 0;\r\n        for (final Element element : elements) {\r\n          i++;\r\n\r\n          if (element.isReferenceElement()) {\r\n              continue;\r\n          }\r\n\r\n          // Check whether token value is consistent with regexp=\"...\"\r\n          warnIfElementNotKosher(\r\n            element.getString(),\r\n            element.isRegularExpression(),\r\n            element.isCaseSensitive(),\r\n            element.getNegation(),\r\n            element.isInflected(),\r\n            false,  // not a POS\r\n            lang, ruleId + \":\" + ruleSubId,\r\n            i);\r\n\r\n          // Check postag=\"...\" is consistent with postag_regexp=\"...\"\r\n          warnIfElementNotKosher(\r\n            element.getPOStag() == null ? \"\" : element.getPOStag(),\r\n            element.isPOStagRegularExpression(),\r\n            element.isCaseSensitive(),\r\n            element.getPOSNegation(),\r\n            false,\r\n            true,   // a POS.\r\n            lang, ruleId + \":\" + ruleSubId + \" (POS tag)\",\r\n            i);\r\n\r\n          final List<Element> exceptionElements = new ArrayList<>();\r\n          if (element.getExceptionList() != null) {\r\n            for (final Element exception: element.getExceptionList()) {\r\n              // Detect useless exception or missing skip=\"...\". I.e. things like this:\r\n              // <token postag=\"...\"><exception scope=\"next\">foo<\/exception<\/token>\r\n              if (exception.hasNextException() && element.getSkipNext() == 0) {\r\n                System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                    + ruleId + \":\" + ruleSubId\r\n                    + \" (exception in token [\" + i + \"])\"\r\n                    + \" has no skip=\\\"...\\\" and yet contains scope=\\\"next\\\"\"\r\n                    + \" so the exception never applies.\"\r\n                    + \" Did you forget skip=\\\"...\\\"?\");\r\n              }\r\n\r\n              // Detect exception that can't possibly be matched.\r\n              if ( !element.getString().isEmpty()\r\n                && !element.getNegation()\r\n                && !element.isInflected()\r\n                && element.getSkipNext() == 0\r\n                && element.getPOStag() == null\r\n                && exception.getPOStag() == null\r\n                && !exception.isRegularExpression()\r\n                && element.isCaseSensitive() == exception.isCaseSensitive()) {\r\n                if (element.isRegularExpression()) {\r\n                  // An exception that cannot match a token regexp is useless.\r\n                  // Example: <token regexp=\"yes\">foo|bar<exception>xxx<\/exception><\/token>\r\n                  // Here exception word xxx cannot possibly match the regexp \"foo|bar\".\r\n                  if (!exception.getString().matches(\r\n                      (exception.isCaseSensitive() ? \"\" : \"(?i)\") +  element.getString())) {\r\n                    System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                        + ruleId + \":\" + ruleSubId\r\n                        + \" exception word [\" +  exception.getString() \r\n                        + \"] cannot match the regexp token [\" + i + \"] [\" + element.getString() \r\n                        + \"] so exception seems useless. \"\r\n                        + \"Did you forget skip=\\\"...\\\" or scope=\\\"previous\\\"?\");\r\n                  }\r\n                } else {\r\n                  // An exception that cannot match a token string is useless,\r\n                  // Example: <token>foo<exception>bar<\/exception><\/token>\r\n                  System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                      + ruleId + \":\" + ruleSubId\r\n                      + \" exception word [\" + exception.getString() \r\n                      + \"] in token word [\" + i + \"] [\" + element.getString() \r\n                      + \"] seems useless. Did you forget skip=\\\"...\\\" or scope=\\\"previous\\\"?\");\r\n                }\r\n              }\r\n\r\n              // Check whether exception value is consistent with regexp=\"...\"\r\n              // Don't check string \".\" since it is sometimes used as a regexp\r\n              // and sometimes used as non regexp.\r\n              if (!exception.getString().equals(\".\")) {\r\n                warnIfElementNotKosher(\r\n                  exception.getString(),\r\n                  exception.isRegularExpression(),\r\n                  exception.isCaseSensitive(),\r\n                  exception.getNegation(),\r\n                  exception.isInflected(),\r\n                  false,  // not a POS\r\n                  lang,\r\n                  ruleId + \":\" + ruleSubId+ \" (exception in token [\" + i + \"])\",\r\n                  i);\r\n              }\r\n              // Check postag=\"...\" of exception is consistent with postag_regexp=\"...\"\r\n              warnIfElementNotKosher(\r\n                exception.getPOStag() == null ? \"\" : exception.getPOStag(),\r\n                exception.isPOStagRegularExpression(),\r\n                exception.isCaseSensitive(),\r\n                exception.getPOSNegation(),\r\n                false,\r\n                true,  // a POS\r\n                lang,\r\n                ruleId + \":\" + ruleSubId + \" (exception in POS tag of token [\" + i + \"])\",\r\n                i);\r\n\r\n              // Search for duplicate exceptions (which are useless).\r\n              // Since there are 2 nested loops on the list of exceptions,\r\n              // this has thus a O(n^2) complexity, where n is the number\r\n              // of exceptions in a token. But n is small and it is also\r\n              // for testing only so that's OK.\r\n              for (final Element otherException: exceptionElements) {\r\n                if (equalException(exception, otherException)) {\r\n                  System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                      + ruleId + \":\" + ruleSubId\r\n                      + \" in token [\" + i + \"]\"\r\n                      + \" contains duplicate exceptions with\"\r\n                      + \" string=[\" + exception.getString() + \"]\"\r\n                      + \" POS tag=[\" + exception.getPOStag() + \"]\"\r\n                      + \" negate=[\" + exception.getNegation() + \"]\"\r\n                      + \" POS negate=[\" + exception.getPOSNegation() + \"]\");\r\n                  break;\r\n                }\r\n              }\r\n              exceptionElements.add(exception);\r\n            }\r\n          }\r\n        }\r\n\r\n    }","commit_id":"58c9511765db335cc89f8516b820be34d0090624","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public static void warnIfRegexpSyntaxNotKosher(final List<Element> elements,\r\n            final String ruleId,final String ruleSubId, final Language lang) {\r\n        int i = 0;\r\n        for (final Element element : elements) {\r\n          i++;\r\n\r\n          if (element.isReferenceElement()) {\r\n              continue;\r\n          }\r\n\r\n          // Check whether token value is consistent with regexp=\"...\"\r\n          warnIfElementNotKosher(\r\n            element.getString(),\r\n            element.isRegularExpression(),\r\n            element.isCaseSensitive(),\r\n            element.getNegation(),\r\n            element.isInflected(),\r\n            false,  // not a POS\r\n            lang, ruleId + \":\" + ruleSubId,\r\n            i);\r\n\r\n          // Check postag=\"...\" is consistent with postag_regexp=\"...\"\r\n          warnIfElementNotKosher(\r\n            element.getPOStag() == null ? \"\" : element.getPOStag(),\r\n            element.isPOStagRegularExpression(),\r\n            element.isCaseSensitive(),\r\n            element.getPOSNegation(),\r\n            false,\r\n            true,   // a POS.\r\n            lang, ruleId + \":\" + ruleSubId + \" (POS tag)\",\r\n            i);\r\n\r\n          final List<Element> exceptionElements = new ArrayList<>();\r\n          if (element.getExceptionList() != null) {\r\n            for (final Element exception: element.getExceptionList()) {\r\n              // Detect useless exception or missing skip=\"...\". I.e. things like this:\r\n              // <token postag=\"...\"><exception scope=\"next\">foo<\/exception<\/token>\r\n              if (exception.hasNextException() && element.getSkipNext() == 0) {\r\n                System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                    + ruleId + \":\" + ruleSubId\r\n                    + \" (exception in token [\" + i + \"])\"\r\n                    + \" has no skip=\\\"...\\\" and yet contains scope=\\\"next\\\"\"\r\n                    + \" so the exception never applies.\"\r\n                    + \" Did you forget skip=\\\"...\\\"?\");\r\n              }\r\n\r\n              // Detect exception that can't possibly be matched.\r\n              if ( !element.getString().isEmpty()\r\n                && !element.getNegation()\r\n                && !element.isInflected()\r\n                && element.getSkipNext() == 0\r\n                && element.getPOStag() == null\r\n                && exception.getPOStag() == null\r\n                && !exception.isRegularExpression()\r\n                && element.isCaseSensitive() == exception.isCaseSensitive()) {\r\n                if (element.isRegularExpression()) {\r\n                  // An exception that cannot match a token regexp is useless.\r\n                  // Example: <token regexp=\"yes\">foo|bar<exception>xxx<\/exception><\/token>\r\n                  // Here exception word xxx cannot possibly match the regexp \"foo|bar\".\r\n                  if (!exception.getString().matches(\r\n                      (exception.isCaseSensitive() ? \"\" : \"(?i)\") +  element.getString())) {\r\n                    System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                        + ruleId + \":\" + ruleSubId\r\n                        + \" exception word [\" +  exception.getString() \r\n                        + \"] cannot match the regexp token [\" + i + \"] [\" + element.getString() \r\n                        + \"] so exception seems useless. \"\r\n                        + \"Did you forget skip=\\\"...\\\" or scope=\\\"previous\\\"?\");\r\n                  }\r\n                } else {\r\n                  // An exception that cannot match a token string is useless,\r\n                  // Example: <token>foo<exception>bar<\/exception><\/token>\r\n                  System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                      + ruleId + \":\" + ruleSubId\r\n                      + \" exception word [\" + exception.getString() \r\n                      + \"] in token word [\" + i + \"] [\" + element.getString() \r\n                      + \"] seems useless. Did you forget skip=\\\"...\\\" or scope=\\\"previous\\\"?\");\r\n                }\r\n              }\r\n\r\n              // Check whether exception value is consistent with regexp=\"...\"\r\n              // Don't check string \".\" since it is sometimes used as a regexp\r\n              // and sometimes used as non regexp.\r\n              if (!exception.getString().equals(\".\")) {\r\n                warnIfElementNotKosher(\r\n                  exception.getString(),\r\n                  exception.isRegularExpression(),\r\n                  exception.isCaseSensitive(),\r\n                  exception.getNegation(),\r\n                  exception.isInflected(),\r\n                  false,  // not a POS\r\n                  lang,\r\n                  ruleId + \":\" + ruleSubId+ \" (exception in token [\" + i + \"])\",\r\n                  i);\r\n              }\r\n              // Check postag=\"...\" of exception is consistent with postag_regexp=\"...\"\r\n              warnIfElementNotKosher(\r\n                exception.getPOStag() == null ? \"\" : exception.getPOStag(),\r\n                exception.isPOStagRegularExpression(),\r\n                exception.isCaseSensitive(),\r\n                exception.getPOSNegation(),\r\n                false,\r\n                true,  // a POS\r\n                lang,\r\n                ruleId + \":\" + ruleSubId + \" (exception in POS tag of token [\" + i + \"])\",\r\n                i);\r\n\r\n              // Search for duplicate exceptions (which are useless).\r\n              // Since there are 2 nested loops on the list of exceptions,\r\n              // this has thus a O(n^2) complexity, where n is the number\r\n              // of exceptions in a token. But n is small and it is also\r\n              // for testing only so that's OK.\r\n              for (final Element otherException: exceptionElements) {\r\n                if (equalException(exception, otherException)) {\r\n                  System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                      + ruleId + \":\" + ruleSubId\r\n                      + \" in token [\" + i + \"]\"\r\n                      + \" contains duplicate exceptions with\"\r\n                      + \" string=[\" + exception.getString() + \"]\"\r\n                      + \" POS tag=[\" + exception.getPOStag() + \"]\"\r\n                      + \" negate=[\" + exception.getNegation() + \"]\"\r\n                      + \" POS negate=[\" + exception.getPOSNegation() + \"]\");\r\n                  break;\r\n                }\r\n              }\r\n              exceptionElements.add(exception);\r\n            }\r\n          }\r\n        }\r\n\r\n    }","id":83987,"modified_method":"public static void warnIfRegexpSyntaxNotKosher(final List<Element> elements,\r\n            final String ruleId,final String ruleSubId, final Language lang) {\r\n        int i = 0;\r\n        for (final Element element : elements) {\r\n          i++;\r\n\r\n          if (element.isReferenceElement()) {\r\n              continue;\r\n          }\r\n\r\n          // Check whether token value is consistent with regexp=\"...\"\r\n          warnIfElementNotKosher(\r\n            element.getString(),\r\n            element.isRegularExpression(),\r\n            element.isCaseSensitive(),\r\n            element.getNegation(),\r\n            element.isInflected(),\r\n            false,  // not a POS\r\n            lang, ruleId + \":\" + ruleSubId,\r\n            i);\r\n\r\n          // Check postag=\"...\" is consistent with postag_regexp=\"...\"\r\n          warnIfElementNotKosher(\r\n            element.getPOStag() == null ? \"\" : element.getPOStag(),\r\n            element.isPOStagRegularExpression(),\r\n            element.isCaseSensitive(),\r\n            element.getPOSNegation(),\r\n            false,\r\n            true,   // a POS.\r\n            lang, ruleId + \":\" + ruleSubId + \" (POS tag)\",\r\n            i);\r\n\r\n          final List<Element> exceptionElements = new ArrayList<>();\r\n          if (element.getExceptionList() != null) {\r\n            for (final Element exception: element.getExceptionList()) {\r\n              // Detect useless exception or missing skip=\"...\". I.e. things like this:\r\n              // <token postag=\"...\"><exception scope=\"next\">foo<\/exception<\/token>\r\n              if (exception.hasNextException() && element.getSkipNext() == 0) {\r\n                System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                    + ruleId + \":\" + ruleSubId\r\n                    + \" (exception in token [\" + i + \"])\"\r\n                    + \" has no skip=\\\"...\\\" and yet contains scope=\\\"next\\\"\"\r\n                    + \" so the exception never applies.\"\r\n                    + \" Did you forget skip=\\\"...\\\"?\");\r\n              }\r\n\r\n              // Detect exception that can't possibly be matched.\r\n              if ( !element.getString().isEmpty()\r\n                && !element.getNegation()\r\n                && !element.isInflected()\r\n                && element.getSkipNext() == 0\r\n                && element.getPOStag() == null\r\n                && exception.getPOStag() == null) {\r\n                if (exception.isRegularExpression()) {\r\n                  if (element.isRegularExpression()) {\r\n                    // Both exception and token are regexp.  In that case, we only\r\n                    // check sanity when exception regexp is a simple disjunction as\r\n                    // in this example:\r\n                    // <token regexp=\"yes\">...some regexp...<exception regexp=\"yes\">foo|bar|xxx<\/exception><\/token>\r\n                    // All the words foo, bar, xxx should match the token regexp, or else they\r\n                    // are useless.\r\n                    if ( exception.getString().contains(\"|\")\r\n                      && exception.getString().matches(\"[^()]*\")) {\r\n                      final String[] alt = exception.getString().split(\"\\\\|\");\r\n                      for (final String part : alt) {\r\n                        if (part.matches(\"[^.*?{}\\\\[\\\\]]+\")) {\r\n                          if (!part.matches(\"(?i)\" + element.getString())) {\r\n                            System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                                + ruleId + \":\" + ruleSubId\r\n                                + \" has exception regexp [\" + exception.getString() \r\n                                + \"] which contains disjunction part [\" + part + \"] \"\r\n                                + \"which seems useless since it does not match \"\r\n                                + \"the regexp of token word [\" + i + \"] [\" + element.getString() \r\n                                + \"]. Did you forget skip=\\\"...\\\" or scope=\\\"previous\\\"?\");\r\n                          }\r\n                        }\r\n                      }\r\n                    }\r\n                  } else {\r\n                    // It does not make sense to to have a regexp exception\r\n                    // with a token which is not a regexp!?\r\n                    // Example <token>foo<exception regexp=\"xxx|yyy\"/><\/token>\r\n                    System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                        + ruleId + \":\" + ruleSubId\r\n                        + \" has exception regexp [\" + exception.getString() \r\n                        + \"] in token word [\" + i + \"] [\" + element.getString() \r\n                        + \"] which seems useless. \"\r\n                        + \"Did you forget skip=\\\"...\\\" or scope=\\\"previous\\\"?\");\r\n                  }\r\n                } else {\r\n                  if (element.isRegularExpression()) {\r\n                    // An exception that cannot match a token regexp is useless.\r\n                    // Example: <token regexp=\"yes\">foo|bar<exception>xxx<\/exception><\/token>\r\n                    // Here exception word xxx cannot possibly match the regexp \"foo|bar\".\r\n                    if (!exception.getString().matches(\r\n                        (exception.isCaseSensitive() ? \"\" : \"(?i)\") +  element.getString())) {\r\n                      System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                          + ruleId + \":\" + ruleSubId\r\n                          + \" has exception word [\" +  exception.getString() \r\n                          + \"] which cannot match the regexp token [\" + i + \"] [\" + element.getString() \r\n                          + \"] so exception seems useless. \"\r\n                          + \"Did you forget skip=\\\"...\\\" or scope=\\\"previous\\\"?\");\r\n                    }\r\n                  } else {\r\n                    // An exception that cannot match a token string is useless,\r\n                    // Example: <token>foo<exception>bar<\/exception><\/token>\r\n                    System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                        + ruleId + \":\" + ruleSubId\r\n                        + \" has exception word [\" + exception.getString() \r\n                        + \"] in token word [\" + i + \"] [\" + element.getString() \r\n                        + \"] which seems useless. \"\r\n                        + \"Did you forget skip=\\\"...\\\" or scope=\\\"previous\\\"?\");\r\n                  }\r\n                }\r\n              }\r\n\r\n              // Check whether exception value is consistent with regexp=\"...\"\r\n              // Don't check string \".\" since it is sometimes used as a regexp\r\n              // and sometimes used as non regexp.\r\n              if (!exception.getString().equals(\".\")) {\r\n                warnIfElementNotKosher(\r\n                  exception.getString(),\r\n                  exception.isRegularExpression(),\r\n                  exception.isCaseSensitive(),\r\n                  exception.getNegation(),\r\n                  exception.isInflected(),\r\n                  false,  // not a POS\r\n                  lang,\r\n                  ruleId + \":\" + ruleSubId+ \" (exception in token [\" + i + \"])\",\r\n                  i);\r\n              }\r\n              // Check postag=\"...\" of exception is consistent with postag_regexp=\"...\"\r\n              warnIfElementNotKosher(\r\n                exception.getPOStag() == null ? \"\" : exception.getPOStag(),\r\n                exception.isPOStagRegularExpression(),\r\n                exception.isCaseSensitive(),\r\n                exception.getPOSNegation(),\r\n                false,\r\n                true,  // a POS\r\n                lang,\r\n                ruleId + \":\" + ruleSubId + \" (exception in POS tag of token [\" + i + \"])\",\r\n                i);\r\n\r\n              // Search for duplicate exceptions (which are useless).\r\n              // Since there are 2 nested loops on the list of exceptions,\r\n              // this has thus a O(n^2) complexity, where n is the number\r\n              // of exceptions in a token. But n is small and it is also\r\n              // for testing only so that's OK.\r\n              for (final Element otherException: exceptionElements) {\r\n                if (equalException(exception, otherException)) {\r\n                  System.err.println(\"The \" + lang.toString() + \" rule: \"\r\n                      + ruleId + \":\" + ruleSubId\r\n                      + \" in token [\" + i + \"]\"\r\n                      + \" contains duplicate exceptions with\"\r\n                      + \" string=[\" + exception.getString() + \"]\"\r\n                      + \" POS tag=[\" + exception.getPOStag() + \"]\"\r\n                      + \" negate=[\" + exception.getNegation() + \"]\"\r\n                      + \" POS negate=[\" + exception.getPOSNegation() + \"]\");\r\n                  break;\r\n                }\r\n              }\r\n              exceptionElements.add(exception);\r\n            }\r\n          }\r\n        }\r\n\r\n    }","commit_id":"9b30b18258dfccd1bf158d64fee352392a0e7028","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"/** Gets the actor that will receive key events. */\r\n\tpublic Actor getKeyboardFocus () {\r\n\t\treturn keyboardFocus;\r\n\t}","id":83988,"modified_method":"/** Gets the actor that will receive key events.\r\n\t * @return May be null. */\r\n\tpublic Actor getKeyboardFocus () {\r\n\t\treturn keyboardFocus;\r\n\t}","commit_id":"6b560baddc3c9c85365d58d7d22a692b974ad5f4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Applies a key up event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns true\r\n\t * if the event was {@link Event#handle() handled}. */\r\n\tpublic boolean keyUp (int keyCode) {\r\n\t\tif (keyboardFocus == null) return false;\r\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(InputEvent.Type.keyUp);\r\n\t\tevent.setKeyCode(keyCode);\r\n\t\tboolean handled = keyboardFocus.fire(event);\r\n\t\tPools.free(event);\r\n\t\treturn event.isHandled();\r\n\t}","id":83989,"modified_method":"/** Applies a key up event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns true\r\n\t * if the event was {@link Event#handle() handled}. */\r\n\tpublic boolean keyUp (int keyCode) {\r\n\t\tif (keyboardFocus == null) return false;\r\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(InputEvent.Type.keyUp);\r\n\t\tevent.setKeyCode(keyCode);\r\n\t\tkeyboardFocus.fire(event);\r\n\t\tboolean handled = event.isHandled();\r\n\t\tPools.free(event);\r\n\t\treturn handled;\r\n\t}","commit_id":"6b560baddc3c9c85365d58d7d22a692b974ad5f4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Applies a key down event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns\r\n\t * true if the event was {@link Event#handle() handled}. */\r\n\tpublic boolean keyDown (int keyCode) {\r\n\t\tif (keyboardFocus == null) return false;\r\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(InputEvent.Type.keyDown);\r\n\t\tevent.setKeyCode(keyCode);\r\n\t\tboolean handled = keyboardFocus.fire(event);\r\n\t\tPools.free(event);\r\n\t\treturn event.isHandled();\r\n\t}","id":83990,"modified_method":"/** Applies a key down event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns\r\n\t * true if the event was {@link Event#handle() handled}. */\r\n\tpublic boolean keyDown (int keyCode) {\r\n\t\tif (keyboardFocus == null) return false;\r\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(InputEvent.Type.keyDown);\r\n\t\tevent.setKeyCode(keyCode);\r\n\t\tkeyboardFocus.fire(event);\r\n\t\tboolean handled = event.isHandled();\r\n\t\tPools.free(event);\r\n\t\treturn handled;\r\n\t}","commit_id":"6b560baddc3c9c85365d58d7d22a692b974ad5f4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Applies a mouse scroll event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the\r\n\t * event. This event only occurs on the desktop. */\r\n\tpublic boolean scrolled (int amount) {\r\n\t\tif (scrollFocus == null) return false;\r\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(InputEvent.Type.scrolled);\r\n\t\tevent.setScrollAmount(amount);\r\n\t\tscrollFocus.fire(event);\r\n\t\tPools.free(event);\r\n\t\treturn event.isHandled();\r\n\t}","id":83991,"modified_method":"/** Applies a mouse scroll event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the\r\n\t * event. This event only occurs on the desktop. */\r\n\tpublic boolean scrolled (int amount) {\r\n\t\tif (scrollFocus == null) return false;\r\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(InputEvent.Type.scrolled);\r\n\t\tevent.setScrollAmount(amount);\r\n\t\tscrollFocus.fire(event);\r\n\t\tboolean handled = event.isHandled();\r\n\t\tPools.free(event);\r\n\t\treturn handled;\r\n\t}","commit_id":"6b560baddc3c9c85365d58d7d22a692b974ad5f4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Gets the actor that will receive scroll events. */\r\n\tpublic Actor getScrollFocus () {\r\n\t\treturn scrollFocus;\r\n\t}","id":83992,"modified_method":"/** Gets the actor that will receive scroll events.\r\n\t * @return May be null. */\r\n\tpublic Actor getScrollFocus () {\r\n\t\treturn scrollFocus;\r\n\t}","commit_id":"6b560baddc3c9c85365d58d7d22a692b974ad5f4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Sets the actor that will receive scroll events. */\r\n\tpublic void setScrollFocus (Actor actor) {\r\n\t\tthis.scrollFocus = actor;\r\n\t}","id":83993,"modified_method":"/** Sets the actor that will receive scroll events.\r\n\t * @param actor May be null. */\r\n\tpublic void setScrollFocus (Actor actor) {\r\n\t\tthis.scrollFocus = actor;\r\n\t}","commit_id":"6b560baddc3c9c85365d58d7d22a692b974ad5f4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Applies a key typed event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns\r\n\t * true if the event was {@link Event#handle() handled}. */\r\n\tpublic boolean keyTyped (char character) {\r\n\t\tif (keyboardFocus == null) return false;\r\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(InputEvent.Type.keyTyped);\r\n\t\tevent.setCharacter(character);\r\n\t\tboolean handled = keyboardFocus.fire(event);\r\n\t\tPools.free(event);\r\n\t\treturn event.isHandled();\r\n\t}","id":83994,"modified_method":"/** Applies a key typed event to the actor that has {@link Stage#setKeyboardFocus(Actor) keyboard focus}, if any, and returns\r\n\t * true if the event was {@link Event#handle() handled}. */\r\n\tpublic boolean keyTyped (char character) {\r\n\t\tif (keyboardFocus == null) return false;\r\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(InputEvent.Type.keyTyped);\r\n\t\tevent.setCharacter(character);\r\n\t\tkeyboardFocus.fire(event);\r\n\t\tboolean handled = event.isHandled();\r\n\t\tPools.free(event);\r\n\t\treturn handled;\r\n\t}","commit_id":"6b560baddc3c9c85365d58d7d22a692b974ad5f4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Applies a mouse moved event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event.\r\n\t * This event only occurs on the desktop. */\r\n\tpublic boolean mouseMoved (int screenX, int screenY) {\r\n\t\tscreenToStageCoordinates(stageCoords.set(screenX, screenY));\r\n\r\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(Type.mouseMoved);\r\n\t\tevent.setStageX(stageCoords.x);\r\n\t\tevent.setStageY(stageCoords.y);\r\n\r\n\t\tActor target = hit(stageCoords.x, stageCoords.y);\r\n\t\tif (target == null) target = root;\r\n\r\n\t\ttarget.fire(event);\r\n\t\tPools.free(event);\r\n\t\treturn event.isHandled();\r\n\t}","id":83995,"modified_method":"/** Applies a mouse moved event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event.\r\n\t * This event only occurs on the desktop. */\r\n\tpublic boolean mouseMoved (int screenX, int screenY) {\r\n\t\tscreenToStageCoordinates(stageCoords.set(screenX, screenY));\r\n\r\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(Type.mouseMoved);\r\n\t\tevent.setStageX(stageCoords.x);\r\n\t\tevent.setStageY(stageCoords.y);\r\n\r\n\t\tActor target = hit(stageCoords.x, stageCoords.y);\r\n\t\tif (target == null) target = root;\r\n\r\n\t\ttarget.fire(event);\r\n\t\tboolean handled = event.isHandled();\r\n\t\tPools.free(event);\r\n\t\treturn handled;\r\n\t}","commit_id":"6b560baddc3c9c85365d58d7d22a692b974ad5f4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Sets the actor that will receive key events. */\r\n\tpublic void setKeyboardFocus (Actor actor) {\r\n\t\tthis.keyboardFocus = actor;\r\n\t}","id":83996,"modified_method":"/** Sets the actor that will receive key events.\r\n\t * @param actor May be null. */\r\n\tpublic void setKeyboardFocus (Actor actor) {\r\n\t\tthis.keyboardFocus = actor;\r\n\t}","commit_id":"6b560baddc3c9c85365d58d7d22a692b974ad5f4","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Applies a touch down event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event. */\r\n\tpublic boolean touchDown (int screenX, int screenY, int pointer, int button) {\r\n\t\tscreenToStageCoordinates(stageCoords.set(screenX, screenY));\r\n\r\n\t\tActorEvent event = Pools.obtain(ActorEvent.class);\r\n\t\tevent.setType(Type.touchDown);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setStageX(stageCoords.x);\r\n\t\tevent.setStageY(stageCoords.y);\r\n\t\tevent.setPointer(pointer);\r\n\t\tevent.setButton(button);\r\n\r\n\t\tActor target = hit(stageCoords.x, stageCoords.y);\r\n\t\twhile (target != null && (!target.isTouchable() || !target.isVisible()))\r\n\t\t\ttarget = target.getParent();\r\n\t\tif (target == null) target = root;\r\n\r\n\t\ttarget.fire(event);\r\n\t\tPools.free(event);\r\n\t\treturn event.isHandled();\r\n\t}","id":83997,"modified_method":"/** Applies a touch down event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event. */\r\n\tpublic boolean touchDown (int screenX, int screenY, int pointer, int button) {\r\n\t\tscreenToStageCoordinates(stageCoords.set(screenX, screenY));\r\n\r\n\t\tActorEvent event = Pools.obtain(ActorEvent.class);\r\n\t\tevent.setType(Type.touchDown);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setStageX(stageCoords.x);\r\n\t\tevent.setStageY(stageCoords.y);\r\n\t\tevent.setPointer(pointer);\r\n\t\tevent.setButton(button);\r\n\r\n\t\tActor target = hit(stageCoords.x, stageCoords.y);\r\n\t\twhile (target != null && (!target.isTouchable() || !target.isVisible()))\r\n\t\t\ttarget = target.getParent();\r\n\t\tif (target == null) target = root;\r\n\r\n\t\ttarget.fire(event);\r\n\t\tboolean handled = event.isHandled();\r\n\t\tPools.free(event);\r\n\t\treturn handled;\r\n\t}","commit_id":"9f2d678891ad4062ae992d5898e28ea7568690de","url":"https://github.com/libgdx/libgdx"},{"original_method":"static private boolean areVerticesClockwise (float[] vertices, int offset, int count) {\r\n\t\tif (count <= 2) return false;\r\n\t\tfloat area = 0;\r\n\t\tfor (int i = offset, n = offset + count - 3; i < n; i += 2) {\r\n\t\t\tfloat p1x = vertices[i];\r\n\t\t\tfloat p1y = vertices[i + 1];\r\n\t\t\tfloat p2x = vertices[i + 2];\r\n\t\t\tfloat p2y = vertices[i + 3];\r\n\t\t\tarea += p1x * p2y - p2x * p1y;\r\n\t\t}\r\n\t\tfloat p1x = vertices[count - 2];\r\n\t\tfloat p1y = vertices[count - 1];\r\n\t\tfloat p2x = vertices[0];\r\n\t\tfloat p2y = vertices[1];\r\n\t\tarea += p1x * p2y - p2x * p1y;\r\n\t\treturn area < 0;\r\n\t}","id":83998,"modified_method":"static private boolean areVerticesClockwise (float[] vertices, int offset, int count) {\r\n\t\tif (count <= 2) return false;\r\n\t\tfloat area = 0, p1x, p1y, p2x, p2y;\r\n\t\tfor (int i = offset, n = offset + count - 3; i < n; i += 2) {\r\n\t\t\tp1x = vertices[i];\r\n\t\t\tp1y = vertices[i + 1];\r\n\t\t\tp2x = vertices[i + 2];\r\n\t\t\tp2y = vertices[i + 3];\r\n\t\t\tarea += p1x * p2y - p2x * p1y;\r\n\t\t}\r\n\t\tp1x = vertices[count - 2];\r\n\t\tp1y = vertices[count - 1];\r\n\t\tp2x = vertices[0];\r\n\t\tp2y = vertices[1];\r\n\t\treturn area + p1x * p2y - p2x * p1y < 0;\r\n\t}","commit_id":"c657d2b24498f4ab6830716c5c128562f015019d","url":"https://github.com/libgdx/libgdx"},{"original_method":"private boolean isEarTip (int earTipIndex) {\r\n\t\tIntArray vertexTypes = this.vertexTypes;\r\n\t\tif (vertexTypes.get(earTipIndex) == CONCAVE) return false;\r\n\r\n\t\tint previousIndex = previousIndex(earTipIndex);\r\n\t\tint nextIndex = nextIndex(earTipIndex);\r\n\t\tfloat[] vertices = this.vertices;\r\n\t\tfloat p1x = vertices[previousIndex * 2];\r\n\t\tfloat p1y = vertices[previousIndex * 2 + 1];\r\n\t\tfloat p2x = vertices[earTipIndex * 2];\r\n\t\tfloat p2y = vertices[earTipIndex * 2 + 1];\r\n\t\tfloat p3x = vertices[nextIndex * 2];\r\n\t\tfloat p3y = vertices[nextIndex * 2 + 1];\r\n\r\n\t\t// Check if any point is inside the triangle formed by previous, current and next vertices.\r\n\t\t// Only consider vertices that are not part of this triangle, or else we'll always find one inside.\r\n\t\tfor (int i = nextIndex(nextIndex); i != previousIndex; i = nextIndex(i)) {\r\n\t\t\t// Concave vertices can obviously be inside the candidate ear, but so can tangential vertices\r\n\t\t\t// if they coincide with one of the triangle's vertices.\r\n\t\t\tif (vertexTypes.get(i) != CONVEX) {\r\n\t\t\t\tfloat vx = vertices[i * 2];\r\n\t\t\t\tfloat vy = vertices[i * 2 + 1];\r\n\t\t\t\t// Because the polygon has clockwise winding order, the area sign will be positive if the point is strictly inside.\r\n\t\t\t\t// It will be 0 on the edge, which we want to include as well.\r\n\t\t\t\tint areaSign1 = computeSpannedAreaSign(p1x, p1y, p2x, p2y, vx, vy);\r\n\t\t\t\tif (areaSign1 >= 0) {\r\n\t\t\t\t\tint areaSign2 = computeSpannedAreaSign(p2x, p2y, p3x, p3y, vx, vy);\r\n\t\t\t\t\tif (areaSign2 >= 0) {\r\n\t\t\t\t\t\tint areaSign3 = computeSpannedAreaSign(p3x, p3y, p1x, p1y, vx, vy);\r\n\t\t\t\t\t\tif (areaSign3 >= 0) return false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}","id":83999,"modified_method":"private boolean isEarTip (int earTipIndex) {\r\n\t\tIntArray vertexTypes = this.vertexTypes;\r\n\t\tif (vertexTypes.get(earTipIndex) == CONCAVE) return false;\r\n\r\n\t\tint previousIndex = previousIndex(earTipIndex);\r\n\t\tint nextIndex = nextIndex(earTipIndex);\r\n\t\tfloat[] vertices = this.vertices;\r\n\t\tfloat p1x = vertices[previousIndex * 2];\r\n\t\tfloat p1y = vertices[previousIndex * 2 + 1];\r\n\t\tfloat p2x = vertices[earTipIndex * 2];\r\n\t\tfloat p2y = vertices[earTipIndex * 2 + 1];\r\n\t\tfloat p3x = vertices[nextIndex * 2];\r\n\t\tfloat p3y = vertices[nextIndex * 2 + 1];\r\n\r\n\t\t// Check if any point is inside the triangle formed by previous, current and next vertices.\r\n\t\t// Only consider vertices that are not part of this triangle, or else we'll always find one inside.\r\n\t\tfor (int i = nextIndex(nextIndex); i != previousIndex; i = nextIndex(i)) {\r\n\t\t\t// Concave vertices can obviously be inside the candidate ear, but so can tangential vertices\r\n\t\t\t// if they coincide with one of the triangle's vertices.\r\n\t\t\tif (vertexTypes.get(i) != CONVEX) {\r\n\t\t\t\tfloat vx = vertices[i * 2];\r\n\t\t\t\tfloat vy = vertices[i * 2 + 1];\r\n\t\t\t\t// Because the polygon has clockwise winding order, the area sign will be positive if the point is strictly inside.\r\n\t\t\t\t// It will be 0 on the edge, which we want to include as well.\r\n\t\t\t\tif (computeSpannedAreaSign(p1x, p1y, p2x, p2y, vx, vy) >= 0) {\r\n\t\t\t\t\tif (computeSpannedAreaSign(p2x, p2y, p3x, p3y, vx, vy) >= 0) {\r\n\t\t\t\t\t\tif (computeSpannedAreaSign(p3x, p3y, p1x, p1y, vx, vy) >= 0) return false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}","commit_id":"c657d2b24498f4ab6830716c5c128562f015019d","url":"https://github.com/libgdx/libgdx"}]