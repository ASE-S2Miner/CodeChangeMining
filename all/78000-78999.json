[{"original_method":"@Test(expected = NullPointerException.class)\n  public void constructor_throws_NPE_if_name_arg_is_null() {\n    new MetricImpl(SOME_KEY, null, Metric.MetricType.BOOL);\n  }","id":78000,"modified_method":"@Test(expected = NullPointerException.class)\n  public void constructor_throws_NPE_if_name_arg_is_null() {\n    new MetricImpl(SOME_ID, SOME_KEY, null, Metric.MetricType.BOOL);\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test(expected = NullPointerException.class)\n  public void constructor_throws_NPE_if_valueType_arg_is_null() {\n    new MetricImpl(SOME_KEY, SOME_NAME, null);\n  }","id":78001,"modified_method":"@Test(expected = NullPointerException.class)\n  public void constructor_throws_NPE_if_valueType_arg_is_null() {\n    new MetricImpl(SOME_ID, SOME_KEY, SOME_NAME, null);\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void verify_getters() {\n    MetricImpl metric = new MetricImpl(SOME_KEY, SOME_NAME, Metric.MetricType.FLOAT);\n\n    assertThat(metric.getKey()).isEqualTo(SOME_KEY);\n    assertThat(metric.getName()).isEqualTo(SOME_NAME);\n    assertThat(metric.getType()).isEqualTo(Metric.MetricType.FLOAT);\n  }","id":78002,"modified_method":"@Test\n  public void verify_getters() {\n    MetricImpl metric = new MetricImpl(SOME_ID, SOME_KEY, SOME_NAME, Metric.MetricType.FLOAT);\n\n    assertThat(metric.getId()).isEqualTo(SOME_ID);\n    assertThat(metric.getKey()).isEqualTo(SOME_KEY);\n    assertThat(metric.getName()).isEqualTo(SOME_NAME);\n    assertThat(metric.getType()).isEqualTo(Metric.MetricType.FLOAT);\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test(expected = NullPointerException.class)\n  public void constructor_throws_NPE_if_key_arg_is_null() {\n    new MetricImpl(null, SOME_NAME, Metric.MetricType.BOOL);\n  }","id":78003,"modified_method":"@Test(expected = NullPointerException.class)\n  public void constructor_throws_NPE_if_key_arg_is_null() {\n    new MetricImpl(SOME_ID, null, SOME_NAME, Metric.MetricType.BOOL);\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void hashcode_uses_only_key() {\n    int expected = new MetricImpl(SOME_KEY, SOME_NAME, Metric.MetricType.FLOAT).hashCode();\n\n    assertThat(new MetricImpl(SOME_KEY, \"some other name\", Metric.MetricType.FLOAT).hashCode()).isEqualTo(expected);\n    assertThat(new MetricImpl(SOME_KEY, \"some other name\", Metric.MetricType.BOOL).hashCode()).isEqualTo(expected);\n  }","id":78004,"modified_method":"@Test\n  public void hashcode_uses_only_key() {\n    int expected = new MetricImpl(SOME_ID, SOME_KEY, SOME_NAME, Metric.MetricType.FLOAT).hashCode();\n\n    assertThat(new MetricImpl(SOME_ID, SOME_KEY, \"some other name\", Metric.MetricType.FLOAT).hashCode()).isEqualTo(expected);\n    assertThat(new MetricImpl(SOME_ID, SOME_KEY, \"some other name\", Metric.MetricType.BOOL).hashCode()).isEqualTo(expected);\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void all_fields_are_displayed_in_toString() {\n    assertThat(new MetricImpl(SOME_KEY, SOME_NAME, Metric.MetricType.FLOAT).toString())\n      .isEqualTo(\"MetricImpl{key=key, name=name, type=FLOAT}\");\n\n  }","id":78005,"modified_method":"@Test\n  public void all_fields_are_displayed_in_toString() {\n    assertThat(new MetricImpl(SOME_ID, SOME_KEY, SOME_NAME, Metric.MetricType.FLOAT).toString())\n      .isEqualTo(\"MetricImpl{id=42, key=key, name=name, type=FLOAT}\");\n\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static Metric toMetric(MetricDto metricDto) {\n    return new MetricImpl(metricDto.getKey(), metricDto.getShortName(), Metric.MetricType.valueOf(metricDto.getValueType()));\n  }","id":78006,"modified_method":"private static Metric toMetric(MetricDto metricDto) {\n    return new MetricImpl(metricDto.getId(), metricDto.getKey(), metricDto.getShortName(), Metric.MetricType.valueOf(metricDto.getValueType()));\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void verify_mapping_and_valueType_conversion_from_DB_impl(String valueType, Metric.MetricType expected) {\n    MetricDto metricDto = new MetricDto().setKey(SOME_KEY + valueType).setShortName(SOME_NAME).setValueType(valueType);\n\n    dbClient.metricDao().insert(dbSession, metricDto);\n    dbSession.commit();\n\n    Metric metric = underTest.getByKey(metricDto.getKey());\n\n    assertThat(metric.getKey()).isEqualTo(metricDto.getKey());\n    assertThat(metric.getName()).isEqualTo(metricDto.getShortName());\n    assertThat(metric.getType()).isEqualTo(expected);\n  }","id":78007,"modified_method":"private void verify_mapping_and_valueType_conversion_from_DB_impl(String valueType, Metric.MetricType expected) {\n    MetricDto metricDto = new MetricDto().setId(SOME_KEY.hashCode()).setKey(SOME_KEY + valueType).setShortName(SOME_NAME).setValueType(valueType);\n\n    dbClient.metricDao().insert(dbSession, metricDto);\n    dbSession.commit();\n\n    Metric metric = underTest.getByKey(metricDto.getKey());\n\n    assertThat(metric.getId()).isEqualTo(metricDto.getId());\n    assertThat(metric.getKey()).isEqualTo(metricDto.getKey());\n    assertThat(metric.getName()).isEqualTo(metricDto.getShortName());\n    assertThat(metric.getType()).isEqualTo(expected);\n  }","commit_id":"5ab09f814612b081c31222a2c0ada09673bf96f5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public QueueEntrySet getDequeueEntrySet() {\n      return dequeueEntrySet;\n    }","id":78008,"modified_method":"public DequeuedEntrySet getDequeueEntrySet() {\n      return dequeueEntrySet;\n    }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public DequeueResult dequeue(QueueConsumer consumer, ReadPointer readPointer) throws OperationException {\n    final QueueConfig config = consumer.getQueueConfig();\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(getLogMessage(\"Attempting dequeue [curNumDequeues=\" + this.dequeueReturns.get() +\n                  \"] (\" + consumer + \", \" + config + \", \" + readPointer + \")\"));\n    }\n\n    // Determine what dequeue strategy to use based on the partitioner\n    final DequeueStrategy dequeueStrategy = getDequeueStrategy(config.getPartitionerType().getPartitioner());\n    final QueueStateImpl queueState = getQueueState(consumer, readPointer);\n\n    // If single entry mode return the previously dequeued entry that was not acked, otherwise dequeue the next entry\n    if(config.isSingleEntry()) {\n      final QueueEntrySet dequeueEntrySet = queueState.getDequeueEntrySet();\n      final ClaimedEntryList claimedEntryList = queueState.getClaimedEntryList();\n      final Map<Long, byte[]> cachedEntries = queueState.getCachedEntries();\n\n      Preconditions.checkState(dequeueEntrySet.size() <= 1,\n                               \"More than 1 entry dequeued in single entry mode - %s\", dequeueEntrySet);\n      if(!dequeueEntrySet.isEmpty()) {\n        long returnEntryId = dequeueEntrySet.min().getEntryId();\n        if(claimedEntryList.hasNext() && claimedEntryList.peekNext().getEntryId() == returnEntryId) {\n          // Crash recovery case.\n          // The claimed entry list would not have been incremented for the first time in single entry mode\n          claimedEntryList.next();\n        }\n\n        byte[] entryBytes = cachedEntries.get(returnEntryId);\n        if(entryBytes == null) {\n          throw new OperationException(StatusCode.INTERNAL_ERROR,\n                  getLogMessage(String.format(\"Cannot fetch dequeue entry id %d from cached entries\", returnEntryId)));\n        }\n        QueueEntry entry = new QueueEntry(entryBytes);\n        dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n        DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                                                        new QueueEntryPointer(this.queueName, returnEntryId), entry);\n        return dequeueResult;\n      }\n    }\n\n    // If no more cached entries, read entries from storage\n    if(!queueState.getClaimedEntryList().hasNext()) {\n      // TODO: return a list of DequeueEntry instead of list of Long\n      List<Long> entryIds = dequeueStrategy.fetchNextEntries(consumer, config, queueState, readPointer);\n      readEntries(consumer, config, queueState, readPointer, entryIds);\n    }\n\n    if(queueState.getClaimedEntryList().hasNext()) {\n      DequeueEntry dequeueEntry = queueState.getClaimedEntryList().next();\n      this.dequeueReturns.incrementAndGet();\n      queueState.getDequeueEntrySet().add(dequeueEntry);\n      QueueEntry entry = new QueueEntry(queueState.getCachedEntries().get(dequeueEntry.getEntryId()));\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                               new QueueEntryPointer(this.queueName, dequeueEntry.getEntryId()), entry);\n      return dequeueResult;\n    } else {\n      // No queue entries available to dequue, return queue empty\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(getLogMessage(\"End of queue reached using \" + \"read pointer \" + readPointer));\n      }\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.EMPTY);\n      return dequeueResult;\n    }\n  }","id":78009,"modified_method":"@Override\n  public DequeueResult dequeue(QueueConsumer consumer, ReadPointer readPointer) throws OperationException {\n    final QueueConfig config = consumer.getQueueConfig();\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(getLogMessage(\"Attempting dequeue [curNumDequeues=\" + this.dequeueReturns.get() +\n                  \"] (\" + consumer + \", \" + config + \", \" + readPointer + \")\"));\n    }\n\n    // Determine what dequeue strategy to use based on the partitioner\n    final DequeueStrategy dequeueStrategy = getDequeueStrategy(config.getPartitionerType().getPartitioner());\n    final QueueStateImpl queueState = getQueueState(consumer, readPointer);\n\n    // If single entry mode return the previously dequeued entry that was not acked, otherwise dequeue the next entry\n    if(config.isSingleEntry()) {\n      final DequeuedEntrySet dequeueEntrySet = queueState.getDequeueEntrySet();\n      final WorkingEntryList workingEntryList = queueState.getWorkingEntryList();\n      final Map<Long, byte[]> cachedEntries = queueState.getCachedEntries();\n\n      Preconditions.checkState(dequeueEntrySet.size() <= 1,\n                               \"More than 1 entry dequeued in single entry mode - %s\", dequeueEntrySet);\n      if(!dequeueEntrySet.isEmpty()) {\n        long returnEntryId = dequeueEntrySet.min().getEntryId();\n        if(workingEntryList.hasNext() && workingEntryList.peekNext().getEntryId() == returnEntryId) {\n          // Crash recovery case.\n          // The cached entry list would not have been incremented for the first time in single entry mode\n          workingEntryList.next();\n        }\n\n        byte[] entryBytes = cachedEntries.get(returnEntryId);\n        if(entryBytes == null) {\n          throw new OperationException(StatusCode.INTERNAL_ERROR,\n                  getLogMessage(String.format(\"Cannot fetch dequeue entry id %d from cached entries\", returnEntryId)));\n        }\n        QueueEntry entry = new QueueEntry(entryBytes);\n        dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n        DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                                                        new QueueEntryPointer(this.queueName, returnEntryId), entry);\n        return dequeueResult;\n      }\n    }\n\n    // If no more cached entries, read entries from storage\n    if(!queueState.getWorkingEntryList().hasNext()) {\n      // TODO: return a list of DequeueEntry instead of list of Long\n      List<Long> entryIds = dequeueStrategy.fetchNextEntries(consumer, config, queueState, readPointer);\n      readEntries(consumer, config, queueState, readPointer, entryIds);\n    }\n\n    if(queueState.getWorkingEntryList().hasNext()) {\n      DequeueEntry dequeueEntry = queueState.getWorkingEntryList().next();\n      this.dequeueReturns.incrementAndGet();\n      queueState.getDequeueEntrySet().add(dequeueEntry);\n      QueueEntry entry = new QueueEntry(queueState.getCachedEntries().get(dequeueEntry.getEntryId()));\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                               new QueueEntryPointer(this.queueName, dequeueEntry.getEntryId()), entry);\n      return dequeueResult;\n    } else {\n      // No queue entries available to dequue, return queue empty\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(getLogMessage(\"End of queue reached using \" + \"read pointer \" + readPointer));\n      }\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.EMPTY);\n      return dequeueResult;\n    }\n  }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void unack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Ack gets rolled back with tries=0. Need to fix this by fixing point 2 above.\n\n    QueuePartitioner partitioner = consumer.getQueueConfig().getPartitionerType().getPartitioner();\n    final DequeueStrategy dequeueStrategy = getDequeueStrategy(partitioner);\n\n    // Get queue state\n    QueueStateImpl queueState = getQueueState(consumer, readPointer);\n\n    // Set unack state\n    queueState.getClaimedEntryList().add(new DequeueEntry(entryPointer.getEntryId(), 0)); // TODO: add tries\n\n    // Write unack state\n    dequeueStrategy.saveDequeueState(consumer, consumer.getQueueConfig(), queueState, readPointer);\n  }","id":78010,"modified_method":"@Override\n  public void unack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Ack gets rolled back with tries=0. Need to fix this by fixing point 2 above.\n\n    QueuePartitioner partitioner = consumer.getQueueConfig().getPartitionerType().getPartitioner();\n    final DequeueStrategy dequeueStrategy = getDequeueStrategy(partitioner);\n\n    // Get queue state\n    QueueStateImpl queueState = getQueueState(consumer, readPointer);\n\n    // Set unack state\n    queueState.getWorkingEntryList().add(new DequeueEntry(entryPointer.getEntryId(), 0)); // TODO: add tries\n\n    // Write unack state\n    dequeueStrategy.saveDequeueState(consumer, consumer.getQueueConfig(), queueState, readPointer);\n  }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"private long getEvictEntryForConsumer(OperationResult<Map<byte[], Map<byte[], byte[]>>> operationResult, int consumerId, long groupId)\n                                                                                        throws OperationException {\n    // evictEntry determination logic: evictEntry = (activeEntry != INVALID_ENTRY ? activeEntry - 1 : consumerReadPointer - 1)\n\n    // Read the ACTIVE_ENTRY and CONSUMER_READ_POINTER for the consumer consumerId\n    Map<byte[], byte[]> readPointerMap = operationResult.getValue().get(makeRowKey(CONSUMER_META_PREFIX, groupId, consumerId));\n    if(readPointerMap == null) {\n      if(LOG.isTraceEnabled()) {\n        LOG.trace(getLogMessage(String.format(\"Not able to fetch readPointer/activeEntry for consumerId %d, groupId %d\", consumerId, groupId)));\n      }\n      return INVALID_ENTRY_ID;\n    }\n    final byte[] activeEntryBytes = readPointerMap.get(DEQUEUE_ENTRY_SET);\n    if(activeEntryBytes == null) {\n      if(LOG.isTraceEnabled()) {\n        LOG.trace(getLogMessage(String.format(\"Not able to decode activeEntry for consumerId %d, groupId %d\", consumerId, groupId)));\n      }\n      return INVALID_ENTRY_ID;\n    }\n    long evictEntry;\n    QueueEntrySet dequeueEntrySet;\n    try {\n       dequeueEntrySet = QueueEntrySet.decode(new BinaryDecoder(new ByteArrayInputStream(activeEntryBytes)));\n    } catch (IOException e) {\n      throw new OperationException(StatusCode.INTERNAL_ERROR, getLogMessage(\"Exception while deserializing dequeue entry list during finalize\"), e);\n    }\n    if(!dequeueEntrySet.isEmpty()) {\n      evictEntry = dequeueEntrySet.min().getEntryId() - 1;\n    } else {\n      byte[] consumerReadPointerBytes = readPointerMap.get(CONSUMER_READ_POINTER);\n      if(consumerReadPointerBytes == null) {\n        if(LOG.isTraceEnabled()) {\n          LOG.trace(getLogMessage(String.format(\"Not able to decode readPointer for consumerId %d, groupId %d\", consumerId, groupId)));\n        }\n        return INVALID_ENTRY_ID;\n      }\n      evictEntry = Bytes.toLong(consumerReadPointerBytes) - 1;\n    }\n    return evictEntry;\n  }","id":78011,"modified_method":"private long getEvictEntryForConsumer(OperationResult<Map<byte[], Map<byte[], byte[]>>> operationResult, int consumerId, long groupId)\n                                                                                        throws OperationException {\n    // evictEntry determination logic: evictEntry = (activeEntry != INVALID_ENTRY ? activeEntry - 1 : consumerReadPointer - 1)\n\n    // Read the ACTIVE_ENTRY and CONSUMER_READ_POINTER for the consumer consumerId\n    Map<byte[], byte[]> readPointerMap = operationResult.getValue().get(makeRowKey(CONSUMER_META_PREFIX, groupId, consumerId));\n    if(readPointerMap == null) {\n      if(LOG.isTraceEnabled()) {\n        LOG.trace(getLogMessage(String.format(\"Not able to fetch readPointer/activeEntry for consumerId %d, groupId %d\", consumerId, groupId)));\n      }\n      return INVALID_ENTRY_ID;\n    }\n    final byte[] activeEntryBytes = readPointerMap.get(DEQUEUE_ENTRY_SET);\n    if(activeEntryBytes == null) {\n      if(LOG.isTraceEnabled()) {\n        LOG.trace(getLogMessage(String.format(\"Not able to decode activeEntry for consumerId %d, groupId %d\", consumerId, groupId)));\n      }\n      return INVALID_ENTRY_ID;\n    }\n    long evictEntry;\n    DequeuedEntrySet dequeueEntrySet;\n    try {\n       dequeueEntrySet = DequeuedEntrySet.decode(new BinaryDecoder(new ByteArrayInputStream(activeEntryBytes)));\n    } catch (IOException e) {\n      throw new OperationException(StatusCode.INTERNAL_ERROR, getLogMessage(\"Exception while deserializing dequeue entry list during finalize\"), e);\n    }\n    if(!dequeueEntrySet.isEmpty()) {\n      evictEntry = dequeueEntrySet.min().getEntryId() - 1;\n    } else {\n      byte[] consumerReadPointerBytes = readPointerMap.get(CONSUMER_READ_POINTER);\n      if(consumerReadPointerBytes == null) {\n        if(LOG.isTraceEnabled()) {\n          LOG.trace(getLogMessage(String.format(\"Not able to decode readPointer for consumerId %d, groupId %d\", consumerId, groupId)));\n        }\n        return INVALID_ENTRY_ID;\n      }\n      evictEntry = Bytes.toLong(consumerReadPointerBytes) - 1;\n    }\n    return evictEntry;\n  }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public String toString() {\n      return Objects.toStringHelper(this)\n        .add(\"dequeueEntrySet\", dequeueEntrySet)\n        .add(\"consumerReadPointer\", consumerReadPointer)\n        .add(\"claimedEntryBegin\", claimedEntryBegin)\n        .add(\"claimedEntryEnd\", claimedEntryEnd)\n        .add(\"queueWritePointer\", queueWrtiePointer)\n        .add(\"lastEvictTimeInSecs\", lastEvictTimeInSecs)\n        .add(\"cachedEntries\", cachedEntries)\n        .toString();\n    }","id":78012,"modified_method":"@Override\n    public String toString() {\n      return Objects.toStringHelper(this)\n        .add(\"workingEntryList\", workingEntryList)\n        .add(\"dequeueEntrySet\", dequeueEntrySet)\n        .add(\"consumerReadPointer\", consumerReadPointer)\n        .add(\"claimedEntryBegin\", claimedEntryBegin)\n        .add(\"claimedEntryEnd\", claimedEntryEnd)\n        .add(\"queueWritePointer\", queueWrtiePointer)\n        .add(\"lastEvictTimeInSecs\", lastEvictTimeInSecs)\n        .add(\"cachedEntries\", cachedEntries)\n        .toString();\n    }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"public ClaimedEntryList getClaimedEntryList() {\n      return claimedEntryList;\n    }","id":78013,"modified_method":"public WorkingEntryList getWorkingEntryList() {\n      return workingEntryList;\n    }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"public QueueStateImpl() {\n      dequeueEntrySet = new QueueEntrySet();\n      cachedEntries = Collections.emptyMap();\n    }","id":78014,"modified_method":"public QueueStateImpl() {\n      dequeueEntrySet = new DequeuedEntrySet();\n      cachedEntries = Collections.emptyMap();\n    }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"public void setClaimedEntriesById(List<Long> entryIds) {\n      List<DequeueEntry> entries = Lists.newArrayList();\n      for(long id : entryIds) {\n        entries.add(new DequeueEntry(id, 0));\n      }\n      this.claimedEntryList = new ClaimedEntryList(entries);\n    }","id":78015,"modified_method":"public void setClaimedEntriesById(List<Long> entryIds) {\n      List<DequeueEntry> entries = Lists.newArrayList();\n      for(long id : entryIds) {\n        entries.add(new DequeueEntry(id, 0));\n      }\n      this.workingEntryList = new WorkingEntryList(entries);\n    }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public QueueStateImpl constructQueueState(QueueConsumer consumer, QueueConfig config, ReadPointer readPointer)\n                                                       throws OperationException {\n      readQueueStateStore.setRowKey(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()));\n      readQueueStateStore.addColumnName(DEQUEUE_ENTRY_SET);\n      readQueueStateStore.addColumnName(CONSUMER_READ_POINTER);\n      readQueueStateStore.addColumnName(LAST_EVICT_TIME_IN_SECS);\n      readQueueStateStore.read(readPointer);\n\n      OperationResult<Map<byte[], byte[]>> stateBytes = readQueueStateStore.getReadResult();\n      QueueStateImpl queueState = new QueueStateImpl();\n      if(!stateBytes.isEmpty()) {\n        // Read active entry\n        ByteArrayInputStream bin = new ByteArrayInputStream(stateBytes.getValue().get(DEQUEUE_ENTRY_SET));\n        BinaryDecoder decoder = new BinaryDecoder(bin);\n        // TODO: Read and check schema\n        try {\n          queueState.setDequeueEntrySet(QueueEntrySet.decode(decoder));\n        } catch (IOException e) {\n          throw new OperationException(StatusCode.INTERNAL_ERROR, getLogMessage(\"Exception while deserializing dequeue entry list\"), e);\n        }\n\n        // Read consumer read pointer\n        byte[] consumerReadPointerBytes = stateBytes.getValue().get(CONSUMER_READ_POINTER);\n        if(consumerReadPointerBytes != null) {\n          queueState.setConsumerReadPointer(Bytes.toLong(consumerReadPointerBytes));\n        }\n\n        // Note: last evict time is read while constructing state, but it is only saved after finalize\n        byte[] lastEvictTimeInSecsBytes = stateBytes.getValue().get(LAST_EVICT_TIME_IN_SECS);\n        if(lastEvictTimeInSecsBytes != null) {\n          queueState.setLastEvictTimeInSecs(Bytes.toLong(lastEvictTimeInSecsBytes));\n        }\n      }\n\n      // Read queue write pointer\n      // TODO: use raw Get instead of the workaround of incrementing zero\n      long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n      queueState.setQueueWritePointer(queueWritePointer);\n\n      // If dequeue entries present, read them from storage\n      // This is the crash recovery case, the consumer has stopped processing before acking the previous dequeues\n      if(!queueState.getDequeueEntrySet().isEmpty()) {\n        droppedEntries = queueState.getDequeueEntrySet().startNewTry(MAX_CRASH_DEQUEUE_TRIES);\n        // TODO: what do we do with the dropped entries?\n        if(!droppedEntries.isEmpty() && LOG.isTraceEnabled()) {\n          LOG.trace(getLogMessage(String.format(\"Dropping entries %s after %d tries\", droppedEntries.toString(), MAX_CRASH_DEQUEUE_TRIES)));\n        }\n\n        // TODO: Do we still need the entries to be in dequeue list? If not, what happens if the consumer crashes again before the claimed entries are processed?\n        // Any previously dequeued entries will now need to be dequeued again\n        readEntries(consumer, config, queueState, readPointer, queueState.getDequeueEntrySet().getEntryIds());\n      }\n      if(LOG.isTraceEnabled()) {\n        LOG.trace(getLogMessage(String.format(\"Constructed new QueueState - %s\", queueState)));\n      }\n      return queueState;\n    }","id":78016,"modified_method":"@Override\n    public QueueStateImpl constructQueueState(QueueConsumer consumer, QueueConfig config, ReadPointer readPointer)\n                                                       throws OperationException {\n      readQueueStateStore.setRowKey(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()));\n      readQueueStateStore.addColumnName(DEQUEUE_ENTRY_SET);\n      readQueueStateStore.addColumnName(CONSUMER_READ_POINTER);\n      readQueueStateStore.addColumnName(LAST_EVICT_TIME_IN_SECS);\n      readQueueStateStore.read(readPointer);\n\n      OperationResult<Map<byte[], byte[]>> stateBytes = readQueueStateStore.getReadResult();\n      QueueStateImpl queueState = new QueueStateImpl();\n      if(!stateBytes.isEmpty()) {\n        // Read active entry\n        ByteArrayInputStream bin = new ByteArrayInputStream(stateBytes.getValue().get(DEQUEUE_ENTRY_SET));\n        BinaryDecoder decoder = new BinaryDecoder(bin);\n        // TODO: Read and check schema\n        try {\n          queueState.setDequeueEntrySet(DequeuedEntrySet.decode(decoder));\n        } catch (IOException e) {\n          throw new OperationException(StatusCode.INTERNAL_ERROR, getLogMessage(\"Exception while deserializing dequeue entry list\"), e);\n        }\n\n        // Read consumer read pointer\n        byte[] consumerReadPointerBytes = stateBytes.getValue().get(CONSUMER_READ_POINTER);\n        if(consumerReadPointerBytes != null) {\n          queueState.setConsumerReadPointer(Bytes.toLong(consumerReadPointerBytes));\n        }\n\n        // Note: last evict time is read while constructing state, but it is only saved after finalize\n        byte[] lastEvictTimeInSecsBytes = stateBytes.getValue().get(LAST_EVICT_TIME_IN_SECS);\n        if(lastEvictTimeInSecsBytes != null) {\n          queueState.setLastEvictTimeInSecs(Bytes.toLong(lastEvictTimeInSecsBytes));\n        }\n      }\n\n      // Read queue write pointer\n      // TODO: use raw Get instead of the workaround of incrementing zero\n      long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n      queueState.setQueueWritePointer(queueWritePointer);\n\n      // If dequeue entries present, read them from storage\n      // This is the crash recovery case, the consumer has stopped processing before acking the previous dequeues\n      if(!queueState.getDequeueEntrySet().isEmpty()) {\n        droppedEntries = queueState.getDequeueEntrySet().startNewTry(MAX_CRASH_DEQUEUE_TRIES);\n        // TODO: what do we do with the dropped entries?\n        if(!droppedEntries.isEmpty() && LOG.isTraceEnabled()) {\n          LOG.trace(getLogMessage(String.format(\"Dropping entries %s after %d tries\", droppedEntries.toString(), MAX_CRASH_DEQUEUE_TRIES)));\n        }\n\n        // TODO: Do we still need the entries to be in dequeue list? If not, what happens if the consumer crashes again before the claimed entries are processed?\n        // Any previously dequeued entries will now need to be dequeued again\n        readEntries(consumer, config, queueState, readPointer, queueState.getDequeueEntrySet().getEntryIds());\n      }\n      if(LOG.isTraceEnabled()) {\n        LOG.trace(getLogMessage(String.format(\"Constructed new QueueState - %s\", queueState)));\n      }\n      return queueState;\n    }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"public void setDequeueEntrySet(QueueEntrySet dequeueEntrySet) {\n      this.dequeueEntrySet = dequeueEntrySet;\n    }","id":78017,"modified_method":"public void setDequeueEntrySet(DequeuedEntrySet dequeueEntrySet) {\n      this.dequeueEntrySet = dequeueEntrySet;\n    }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testClaimedEntryList() {\n    final int MAX = 10;\n    ClaimedEntryList claimedEntryList = new ClaimedEntryList(Lists.<DequeueEntry>newArrayList());\n    assertFalse(claimedEntryList.hasNext());\n\n    for(int i = 0; i < MAX; ++i) {\n      claimedEntryList.add(new DequeueEntry(i));\n    }\n\n    for(int i = 0; i < MAX; ++i) {\n      assertTrue(claimedEntryList.hasNext());\n      assertEquals(new DequeueEntry(i), claimedEntryList.peekNext());\n      assertEquals(new DequeueEntry(i), claimedEntryList.next());\n    }\n    assertFalse(claimedEntryList.hasNext());\n\n    for(int i = 0; i < MAX; ++i) {\n      claimedEntryList.add(new DequeueEntry(i));\n    }\n\n    for(int i = 0; i < MAX; ++i) {\n      assertTrue(claimedEntryList.hasNext());\n      assertEquals(new DequeueEntry(i), claimedEntryList.peekNext());\n      assertEquals(new DequeueEntry(i), claimedEntryList.next());\n    }\n    assertFalse(claimedEntryList.hasNext());\n  }","id":78018,"modified_method":"@Test\n  public void testWorkingEntryList() {\n    final int MAX = 10;\n    WorkingEntryList workingEntryList = new WorkingEntryList(Lists.<DequeueEntry>newArrayList());\n    assertFalse(workingEntryList.hasNext());\n\n    for(int i = 0; i < MAX; ++i) {\n      workingEntryList.add(new DequeueEntry(i));\n    }\n\n    for(int i = 0; i < MAX; ++i) {\n      assertTrue(workingEntryList.hasNext());\n      assertEquals(new DequeueEntry(i), workingEntryList.peekNext());\n      assertEquals(new DequeueEntry(i), workingEntryList.next());\n    }\n    assertFalse(workingEntryList.hasNext());\n\n    for(int i = 0; i < MAX; ++i) {\n      workingEntryList.add(new DequeueEntry(i));\n    }\n\n    for(int i = 0; i < MAX; ++i) {\n      assertTrue(workingEntryList.hasNext());\n      assertEquals(new DequeueEntry(i), workingEntryList.peekNext());\n      assertEquals(new DequeueEntry(i), workingEntryList.next());\n    }\n    assertFalse(workingEntryList.hasNext());\n  }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testQueueEntrySet() throws Exception {\n    final int MAX = 10;\n    QueueEntrySet entrySet = new QueueEntrySet();\n    List<Long> expectedEntryIds = Lists.newArrayListWithCapacity(MAX);\n    List<DequeueEntry> expectedEntryList = Lists.newArrayListWithCapacity(MAX);\n    Set<Long> expectedDroppedEntries = Sets.newHashSetWithExpectedSize(MAX);\n\n    for(int i = 0; i < MAX; ++i) {\n      entrySet.add(new DequeueEntry(i, i %2));\n      expectedEntryIds.add((long) i);\n      expectedEntryList.add(new DequeueEntry(i, i % 2));\n\n      if(i % 2 == 1) {\n        expectedDroppedEntries.add((long) i);\n      }\n    }\n\n    // Verify created lists\n    assertEquals(MAX, entrySet.size());\n    assertEquals(MAX, expectedEntryIds.size());\n    assertEquals(MAX, expectedEntryList.size());\n    assertEquals(MAX/2, expectedDroppedEntries.size());\n\n    // Verify QueueEntrySet\n    assertEquals(expectedEntryIds, entrySet.getEntryIds());\n    assertEquals(expectedEntryList, entrySet.getEntryList());\n\n    Set<Long> actualDroppedEntries = entrySet.startNewTry(1);\n    assertEquals(expectedDroppedEntries, actualDroppedEntries);\n\n    List<Long> actualRemainingEntries = Lists.newArrayListWithCapacity(MAX);\n    for(int i = 0; i < MAX; ++i) {\n      if(i % 2 == 0) {\n        actualRemainingEntries.add((long) i);\n      }\n    }\n    assertEquals(actualRemainingEntries, entrySet.getEntryIds());\n  }","id":78019,"modified_method":"@Test\n  public void testQueueEntrySet() throws Exception {\n    final int MAX = 10;\n    DequeuedEntrySet entrySet = new DequeuedEntrySet();\n    List<Long> expectedEntryIds = Lists.newArrayListWithCapacity(MAX);\n    List<DequeueEntry> expectedEntryList = Lists.newArrayListWithCapacity(MAX);\n    Set<Long> expectedDroppedEntries = Sets.newHashSetWithExpectedSize(MAX);\n\n    for(int i = 0; i < MAX; ++i) {\n      entrySet.add(new DequeueEntry(i, i %2));\n      expectedEntryIds.add((long) i);\n      expectedEntryList.add(new DequeueEntry(i, i % 2));\n\n      if(i % 2 == 1) {\n        expectedDroppedEntries.add((long) i);\n      }\n    }\n\n    // Verify created lists\n    assertEquals(MAX, entrySet.size());\n    assertEquals(MAX, expectedEntryIds.size());\n    assertEquals(MAX, expectedEntryList.size());\n    assertEquals(MAX/2, expectedDroppedEntries.size());\n\n    // Verify QueueEntrySet\n    assertEquals(expectedEntryIds, entrySet.getEntryIds());\n    assertEquals(expectedEntryList, entrySet.getEntryList());\n\n    Set<Long> actualDroppedEntries = entrySet.startNewTry(1);\n    assertEquals(expectedDroppedEntries, actualDroppedEntries);\n\n    List<Long> actualRemainingEntries = Lists.newArrayListWithCapacity(MAX);\n    for(int i = 0; i < MAX; ++i) {\n      if(i % 2 == 0) {\n        actualRemainingEntries.add((long) i);\n      }\n    }\n    assertEquals(actualRemainingEntries, entrySet.getEntryIds());\n  }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testQueueEntrySetEncode() throws Exception {\n    final int MAX = 10;\n    QueueEntrySet expectedEntrySet = new QueueEntrySet();\n    for(int i = 0; i < MAX; ++i) {\n      expectedEntrySet.add(new DequeueEntry(i, i % 2));\n    }\n\n    assertEquals(MAX, expectedEntrySet.size());\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    expectedEntrySet.encode(new BinaryEncoder(bos));\n    byte[] encodedValue = bos.toByteArray();\n\n    QueueEntrySet actualEntrySet = QueueEntrySet.decode(new BinaryDecoder(new ByteArrayInputStream(encodedValue)));\n    assertEquals(expectedEntrySet.size(), actualEntrySet.size());\n    for(int i = 0; i < MAX; ++i) {\n      DequeueEntry expectedEntry = expectedEntrySet.min();\n      expectedEntrySet.remove(expectedEntry.getEntryId());\n\n      DequeueEntry actualEntry = actualEntrySet.min();\n      actualEntrySet.remove(actualEntry.getEntryId());\n\n      assertEquals(expectedEntry.getEntryId(), actualEntry.getEntryId());\n      assertEquals(expectedEntry.getTries(), actualEntry.getTries());\n    }\n  }","id":78020,"modified_method":"@Test\n  public void testQueueEntrySetEncode() throws Exception {\n    final int MAX = 10;\n    DequeuedEntrySet expectedEntrySet = new DequeuedEntrySet();\n    for(int i = 0; i < MAX; ++i) {\n      expectedEntrySet.add(new DequeueEntry(i, i % 2));\n    }\n\n    assertEquals(MAX, expectedEntrySet.size());\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    expectedEntrySet.encode(new BinaryEncoder(bos));\n    byte[] encodedValue = bos.toByteArray();\n\n    DequeuedEntrySet actualEntrySet = DequeuedEntrySet.decode(new BinaryDecoder(new ByteArrayInputStream(encodedValue)));\n    assertEquals(expectedEntrySet.size(), actualEntrySet.size());\n    for(int i = 0; i < MAX; ++i) {\n      DequeueEntry expectedEntry = expectedEntrySet.min();\n      expectedEntrySet.remove(expectedEntry.getEntryId());\n\n      DequeueEntry actualEntry = actualEntrySet.min();\n      actualEntrySet.remove(actualEntry.getEntryId());\n\n      assertEquals(expectedEntry.getEntryId(), actualEntry.getEntryId());\n      assertEquals(expectedEntry.getTries(), actualEntry.getTries());\n    }\n  }","commit_id":"05f49218c130f5f1ba5772cec2ebd98827360bc5","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public HashMap<String, Pair<Long, Long>> syncNetworkGroups(String hostGuid) {\n        HashMap<String, Pair<Long, Long>> maps = new HashMap<String, Pair<Long, Long>>();\n        List<MockSecurityRulesVO> rules = _mockSecurityDao.findByHost(hostGuid);\n        for (MockSecurityRulesVO rule : rules) {\n            maps.put(rule.getVmName(), new Pair<Long, Long>(rule.getVmId(), rule.getSeqNum()));\n        }\n        return maps;\n    }","id":78021,"modified_method":"@Override\n    public HashMap<String, Pair<Long, Long>> syncNetworkGroups(String hostGuid) {\n        HashMap<String, Pair<Long, Long>> maps = new HashMap<String, Pair<Long, Long>>();\n        \n        List<Ternary<String, Long, Long>> rules = _securityRules.get(hostGuid);\n        if (rules == null) {\n            return maps;\n        }\n        for (Ternary<String, Long, Long> rule : rules) {\n            maps.put(rule.first(), new Pair<Long, Long>(rule.second(), rule.third()));\n        }\n        return maps;\n    }","commit_id":"cefae498dc655417a875af69e8a5e4b425da4327","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public SecurityIngressRuleAnswer AddSecurityIngressRules(SecurityIngressRulesCmd cmd, String hostGuid) {\n        MockVMVO vm = _mockVmDao.findByVmName(cmd.getVmName());\n        if (vm == null) {\n            return new SecurityIngressRuleAnswer(cmd, false, \"cant' find the vm: \" + cmd.getVmName());\n        }\n        boolean update = logSecurityGroupAction(cmd);\n         MockSecurityRulesVO rules = _mockSecurityDao.findByVmId(cmd.getVmId());\n        if (rules == null) {\n            rules = new MockSecurityRulesVO();\n            rules.setRuleSet(cmd.stringifyRules());\n            rules.setSeqNum(cmd.getSeqNum());\n            rules.setSignature(cmd.getSignature());\n            rules.setVmId(cmd.getVmId());\n            rules.setHostId(hostGuid);\n\n            _mockSecurityDao.persist(rules);\n        } else if (update){\n            rules.setSeqNum(cmd.getSeqNum());\n            rules.setSignature(cmd.getSignature());\n            rules.setRuleSet(cmd.stringifyRules());\n            rules.setVmId(cmd.getVmId());\n            rules.setHostId(hostGuid);\n            _mockSecurityDao.update(rules.getId(), rules);\n        }\n        \n        return new SecurityIngressRuleAnswer(cmd);\n    }","id":78022,"modified_method":"@Override\n    public SecurityIngressRuleAnswer AddSecurityIngressRules(SecurityIngressRulesCmd cmd, String hostGuid) {\n        logSecurityGroupAction(cmd);\n        List<Ternary<String,Long, Long>> rules = _securityRules.get(hostGuid);\n        if (rules == null) {\n            rules = new ArrayList<Ternary<String, Long, Long>>();\n            rules.add(new Ternary<String,Long, Long>(cmd.getVmName(), cmd.getVmId(), cmd.getSeqNum()));\n            _securityRules.put(hostGuid, rules);\n        } else {\n            rules.add(new Ternary<String, Long,Long>(cmd.getVmName(), cmd.getVmId(), cmd.getSeqNum()));\n        }\n        \n        return new SecurityIngressRuleAnswer(cmd);\n    }","commit_id":"cefae498dc655417a875af69e8a5e4b425da4327","url":"https://github.com/apache/cloudstack"},{"original_method":"@DB\n    @Override\n    @ActionEvent(eventType = EventTypes.EVENT_VM_MOVE, eventDescription = \"move VM to another user\", async = false)\n    public UserVm moveVMToUser(AssignVMCmd cmd) throws ResourceAllocationException, ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {\n        // VERIFICATIONS and VALIDATIONS\n\n        //VV 1: verify the two users\n        Account caller = UserContext.current().getCaller();\n        if (caller.getType() != Account.ACCOUNT_TYPE_ADMIN  && caller.getType() != Account.ACCOUNT_TYPE_DOMAIN_ADMIN){ // only root admin can assign VMs\n        \tthrow new InvalidParameterValueException(\"Only domain admins are allowed to assign VMs and not \" + caller.getType());\n        }\n\n        //get and check the valid VM\n        UserVmVO vm = _vmDao.findById(cmd.getVmId());\n        if (vm == null){\n            throw new InvalidParameterValueException(\"There is no vm by that id \" + cmd.getVmId());\n        } else if (vm.getState() == State.Running) {  // VV 3: check if vm is running\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is Running, unable to move the vm \" + vm);\n            }\n            throw new InvalidParameterValueException(\"VM is Running, unable to move the vm \" + vm);\n        }\n\n        Account oldAccount = _accountService.getActiveAccountById(vm.getAccountId());\n        if (oldAccount == null) {\n            throw new InvalidParameterValueException(\"Invalid account for VM \" + vm.getAccountId() + \" in domain.\");\n        }\n        //don't allow to move the vm from the project\n        if (oldAccount.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Vm id=\" + cmd.getVmId() + \" belongs to the project and can't be moved\");\n        }\n        Account newAccount = _accountService.getActiveAccountByName(cmd.getAccountName(), cmd.getDomainId());\n        if (newAccount == null || newAccount.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Invalid accountid=\" + cmd.getAccountName() + \" in domain \" + cmd.getDomainId());\n        }\n        \n        if (newAccount.getState() == Account.State.disabled) {\n            throw new InvalidParameterValueException(\"The new account owner \" + cmd.getAccountName() + \" is disabled.\");\n        }\n        \n        // make sure the accounts are under same domain\n        if (oldAccount.getDomainId() != newAccount.getDomainId()){\n        \t throw new InvalidParameterValueException(\"The account should be under same domain for moving VM between two accounts. Old owner domain =\" + oldAccount.getDomainId() +\n        \t\t\t \" New owner domain=\" + newAccount.getDomainId());\n        }\n        \n        // make sure the accounts are not same\n        if (oldAccount.getAccountId() == newAccount.getAccountId()){\n       \t    throw new InvalidParameterValueException(\"The account should be same domain for moving VM between two accounts. Account id =\" + oldAccount.getAccountId());\n        }\n        \n        // don't allow to move the vm if there are existing PF/LB/Static Nat rules, existing Security groups or vm is assigned to static Nat ip\n        IPAddressVO ip = _ipAddressDao.findByAssociatedVmId(cmd.getVmId());\n        if (ip != null){\n\t        List<FirewallRuleVO> firewall_rules = _rulesDao.listByIpAndPurposeAndNotRevoked(ip.getId(), FirewallRule.Purpose.Firewall);\n\t        if (firewall_rules.size() > 0){\n\t        \tthrow new InvalidParameterValueException(\"Remove the Firewall rules for this VM before assigning to another user.\");\n\t        }\n\t        List<FirewallRuleVO> lb_rules = _rulesDao.listByIpAndPurposeAndNotRevoked(ip.getId(), FirewallRule.Purpose.LoadBalancing);\n\t        if (lb_rules.size() > 0){\n\t        \tthrow new InvalidParameterValueException(\"Remove the LoadBalancing rules for this VM before assigning to another user.\");\n\t        }\n\t        List<FirewallRuleVO> nat_rules = _rulesDao.listByIpAndPurposeAndNotRevoked(ip.getId(), FirewallRule.Purpose.StaticNat);\n\t        if (nat_rules.size() > 0){\n\t        \tthrow new InvalidParameterValueException(\"Remove the StaticNat rules for this VM before assigning to another user.\");\n\t        }\n\t        List<FirewallRuleVO> vpn_rules = _rulesDao.listByIpAndPurposeAndNotRevoked(ip.getId(), FirewallRule.Purpose.Vpn);\n\t        if (vpn_rules.size() > 0){\n\t        \tthrow new InvalidParameterValueException(\"Remove the Vpn rules for this VM before assigning to another user.\");\n\t        }\n\t        List<SecurityGroupVMMapVO> securityGroupsToVmMap = _securityGroupVMMapDao.listByInstanceId(cmd.getVmId());\n\t        if (securityGroupsToVmMap.size() > 0){\n\t        \tthrow new InvalidParameterValueException(\"Remove the VM from security groups before assigning to another user.\");\n\t        }\n        }\n\n        DataCenterVO zone = _dcDao.findById(vm.getDataCenterIdToDeployIn());\n    \n        //Remove vm from instance group\n        removeInstanceFromInstanceGroup(cmd.getVmId());\n\n        //VV 2: check if account/domain is with in resource limits to create a new vm\n        _resourceLimitMgr.checkResourceLimit(newAccount, ResourceType.user_vm);\n\n        // VV 4: Check if new owner can use the vm template\n        VirtualMachineTemplate template = _templateDao.findById(vm.getTemplateId());\n        if (!template.isPublicTemplate()) {\n            Account templateOwner = _accountMgr.getAccount(template.getAccountId());\n            _accountMgr.checkAccess(newAccount, null, true, templateOwner);\n        }\n\n        // VV 5: check the new account can create vm in the domain\n        DomainVO domain = _domainDao.findById(cmd.getDomainId());\n        _accountMgr.checkAccess(newAccount, domain);\n\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        //generate destroy vm event for usage\n        _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VM_DESTROY, vm.getAccountId(), vm.getDataCenterIdToDeployIn(), vm.getId(), \n                vm.getHostName(), vm.getServiceOfferingId(), vm.getTemplateId(), vm.getHypervisorType().toString()));\n        // update resource counts\n        _resourceLimitMgr.decrementResourceCount(oldAccount.getAccountId(), ResourceType.user_vm);\n\n        // OWNERSHIP STEP 1: update the vm owner\n        vm.setAccountId(newAccount.getAccountId());\n        vm.setDomainId(cmd.getDomainId());\n        _vmDao.persist(vm);\n        \n        // OS 2: update volume\n        List<VolumeVO> volumes = _volsDao.findByInstance(cmd.getVmId());\n        for (VolumeVO volume : volumes) {\n            _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VOLUME_DELETE, volume.getAccountId(), volume.getDataCenterId(), volume.getId(), volume.getName()));\n            _resourceLimitMgr.decrementResourceCount(oldAccount.getAccountId(), ResourceType.volume);\n            volume.setAccountId(newAccount.getAccountId());\n            _volsDao.persist(volume);\n            _resourceLimitMgr.incrementResourceCount(newAccount.getAccountId(), ResourceType.volume);\n            _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VOLUME_CREATE, volume.getAccountId(), volume.getDataCenterId(), volume.getId(), volume.getName(),\n            \t\tvolume.getDiskOfferingId(), volume.getTemplateId(), volume.getSize()));\n        }\n\n        _resourceLimitMgr.incrementResourceCount(newAccount.getAccountId(), ResourceType.user_vm);\n        //generate usage events to account for this change\n        _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VM_CREATE, vm.getAccountId(), vm.getDataCenterIdToDeployIn(), vm.getId(), \n                vm.getHostName(), vm.getServiceOfferingId(),  vm.getTemplateId(), vm.getHypervisorType().toString()));\n\n        txn.commit();\n\n        VMInstanceVO vmoi = _itMgr.findByIdAndType(vm.getType(), vm.getId());\n        VirtualMachineProfileImpl<VMInstanceVO> vmOldProfile = new VirtualMachineProfileImpl<VMInstanceVO>(vmoi);\n\n        // OS 3: update the network\n        List<Long> networkIdList = cmd.getNetworkIds();\n        List<Long> securityGroupIdList = cmd.getSecurityGroupIdList();\n        \n        if (zone.getNetworkType() == NetworkType.Basic) {\n        \t if (networkIdList != null && !networkIdList.isEmpty()) {\n                 throw new InvalidParameterValueException(\"Can't move vm with network Ids; this is a basic zone VM\");\n             }\n         \t//cleanup the old security groups\n             _securityGroupMgr.removeInstanceFromGroups(cmd.getVmId());\n       \t \t//cleanup the network for the oldOwner\n            _networkMgr.cleanupNics(vmOldProfile);\n            _networkMgr.expungeNics(vmOldProfile);\n        \t//security groups will be recreated for the new account, when the VM is started\n            List<NetworkVO> networkList = new ArrayList<NetworkVO>();\n\n            // Get default guest network in Basic zone\n            Network defaultNetwork = _networkMgr.getExclusiveGuestNetwork(zone.getId());\n\n            if (defaultNetwork == null) {\n                throw new InvalidParameterValueException(\"Unable to find a default network to start a vm\");\n            } else {\n                networkList.add(_networkDao.findById(defaultNetwork.getId()));\n            }\n\n            boolean isVmWare = (template.getHypervisorType() == HypervisorType.VMware);\n\n            if (securityGroupIdList != null && isVmWare) {\n                throw new InvalidParameterValueException(\"Security group feature is not supported for vmWare hypervisor\");\n            } else if (!isVmWare && _networkMgr.isSecurityGroupSupportedInNetwork(defaultNetwork) && _networkMgr.canAddDefaultSecurityGroup()) {\n                if (securityGroupIdList == null) {\n                    securityGroupIdList = new ArrayList<Long>();\n                }\n                SecurityGroup defaultGroup = _securityGroupMgr.getDefaultSecurityGroup(newAccount.getId());\n                if (defaultGroup != null) {\n                    //check if security group id list already contains Default security group, and if not - add it\n                    boolean defaultGroupPresent = false;\n                    for (Long securityGroupId : securityGroupIdList) {\n                        if (securityGroupId.longValue() == defaultGroup.getId()) {\n                            defaultGroupPresent = true;\n                            break;\n                        }\n                    }\n\n                    if (!defaultGroupPresent) {\n                        securityGroupIdList.add(defaultGroup.getId());\n                    }\n\n                } else {\n                    //create default security group for the account\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Couldn't find default security group for the account \" + newAccount + \" so creating a new one\");\n                    }\n                    defaultGroup = _securityGroupMgr.createSecurityGroup(SecurityGroupManager.DEFAULT_GROUP_NAME, SecurityGroupManager.DEFAULT_GROUP_DESCRIPTION, newAccount.getDomainId(), newAccount.getId(), newAccount.getAccountName());\n                    securityGroupIdList.add(defaultGroup.getId());\n                }\n            }\n            \n\n            List<Pair<NetworkVO, NicProfile>> networks = new ArrayList<Pair<NetworkVO, NicProfile>>();\n            NicProfile profile = new NicProfile();\n            profile.setDefaultNic(true);\n            networks.add(new Pair<NetworkVO, NicProfile>(networkList.get(0), profile));\n           \n            VMInstanceVO vmi = _itMgr.findByIdAndType(vm.getType(), vm.getId());\n            VirtualMachineProfileImpl<VMInstanceVO> vmProfile = new VirtualMachineProfileImpl<VMInstanceVO>(vmi);\n            _networkMgr.allocate(vmProfile, networks);\n\n            _securityGroupMgr.addInstanceToGroups(vm.getId(), securityGroupIdList);\n        } else {\n            if (zone.isSecurityGroupEnabled())  {\n            \tthrow new InvalidParameterValueException(\"not yet tested for SecurityGroupEnabled advanced networks.\");\n            } else {\n                if (securityGroupIdList != null && !securityGroupIdList.isEmpty()) {\n                    throw new InvalidParameterValueException(\"Can't move vm with security groups; security group feature is not enabled in this zone\");\n                }\n            \t //cleanup the network for the oldOwner\n                _networkMgr.cleanupNics(vmOldProfile);\n                _networkMgr.expungeNics(vmOldProfile);\n                \n                Set<NetworkVO> applicableNetworks = new HashSet<NetworkVO>();\n            \n                if (networkIdList != null && !networkIdList.isEmpty()){\n\t                // add any additional networks\n\t                for (Long networkId : networkIdList) {\n\t                    NetworkVO network = _networkDao.findById(networkId);\n\t                    if (network == null) {\n\t                        throw new InvalidParameterValueException(\"Unable to find network by id \" + networkId);\n\t                    }\n\t\n\t                    _networkMgr.checkNetworkPermissions(newAccount, network);\n\t\n\t                    //don't allow to use system networks \n\t                    NetworkOffering networkOffering = _configMgr.getNetworkOffering(network.getNetworkOfferingId());\n\t                    if (networkOffering.isSystemOnly()) {\n\t                        throw new InvalidParameterValueException(\"Network id=\" + networkId + \" is system only and can't be used for vm deployment\");\n\t                    }\n\t                    applicableNetworks.add(network);\n\t                }\n                }\n                else {\n                \tNetworkVO defaultNetwork = null;\n                    List<NetworkOfferingVO> requiredOfferings = _networkOfferingDao.listByAvailability(Availability.Required, false);\n                    if (requiredOfferings.size() < 1) {\n                    \tthrow new InvalidParameterValueException(\"Unable to find network offering with availability=\" + Availability.Required + \" to automatically create the network as a part of vm creation\");\n                    }\n                    \n                    PhysicalNetwork physicalNetwork = _networkMgr.translateZoneIdToPhysicalNetwork(zone.getId());\n                    if (requiredOfferings.get(0).getState() == NetworkOffering.State.Enabled) {\n                        // get Virtual networks\n                        List<NetworkVO> virtualNetworks = _networkMgr.listNetworksForAccount(newAccount.getId(), zone.getId(), Network.GuestType.Isolated);\n\n                        if (virtualNetworks.isEmpty()) {\n                            s_logger.debug(\"Creating network for account \" + newAccount + \" from the network offering id=\" + requiredOfferings.get(0).getId() + \" as a part of deployVM process\");\n                            Network newNetwork = _networkMgr.createGuestNetwork(requiredOfferings.get(0).getId(), newAccount.getAccountName() + \"-network\", newAccount.getAccountName() + \"-network\", null, null,\n                                    null, null, newAccount, false, null, physicalNetwork, zone.getId(), ACLType.Account, null);\n                            defaultNetwork = _networkDao.findById(newNetwork.getId());\n                        } else if (virtualNetworks.size() > 1) {\n                            throw new InvalidParameterValueException(\"More than 1 default Isolated networks are found for account \" + newAccount + \"; please specify networkIds\");\n                        } else {\n                            defaultNetwork = virtualNetworks.get(0);\n                        }\n                    } else {\n                    \tthrow new InvalidParameterValueException(\"Required network offering id=\" + requiredOfferings.get(0).getId() + \" is not in \" + NetworkOffering.State.Enabled); \n                    }\n\n                    applicableNetworks.add(defaultNetwork);\n                }\n\n                // add the new nics\n                List<Pair<NetworkVO, NicProfile>> networks = new ArrayList<Pair<NetworkVO, NicProfile>>();\n                int toggle=0;\n                for (NetworkVO appNet: applicableNetworks){                    \n                    NicProfile defaultNic = new NicProfile();\n                    if (toggle==0){\n                        defaultNic.setDefaultNic(true);\n                        toggle++;\n                    }\n                    networks.add(new Pair<NetworkVO, NicProfile>(appNet, defaultNic));\n                }\n                VMInstanceVO vmi = _itMgr.findByIdAndType(vm.getType(), vm.getId());\n                VirtualMachineProfileImpl<VMInstanceVO> vmProfile = new VirtualMachineProfileImpl<VMInstanceVO>(vmi);\n                _networkMgr.allocate(vmProfile, networks);\n            } //END IF NON SEC GRP ENABLED\n        } // END IF ADVANCED\n        return vm;\n    }","id":78023,"modified_method":"@DB\n    @Override\n    @ActionEvent(eventType = EventTypes.EVENT_VM_MOVE, eventDescription = \"move VM to another user\", async = false)\n    public UserVm moveVMToUser(AssignVMCmd cmd) throws ResourceAllocationException, ConcurrentOperationException, ResourceUnavailableException, InsufficientCapacityException {\n        // VERIFICATIONS and VALIDATIONS\n\n        //VV 1: verify the two users\n        Account caller = UserContext.current().getCaller();\n        if (caller.getType() != Account.ACCOUNT_TYPE_ADMIN  && caller.getType() != Account.ACCOUNT_TYPE_DOMAIN_ADMIN){ // only root admin can assign VMs\n        \tthrow new InvalidParameterValueException(\"Only domain admins are allowed to assign VMs and not \" + caller.getType());\n        }\n\n        //get and check the valid VM\n        UserVmVO vm = _vmDao.findById(cmd.getVmId());\n        if (vm == null){\n            throw new InvalidParameterValueException(\"There is no vm by that id \" + cmd.getVmId());\n        } else if (vm.getState() == State.Running) {  // VV 3: check if vm is running\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"VM is Running, unable to move the vm \" + vm);\n            }\n            throw new InvalidParameterValueException(\"VM is Running, unable to move the vm \" + vm);\n        }\n\n        Account oldAccount = _accountService.getActiveAccountById(vm.getAccountId());\n        if (oldAccount == null) {\n            throw new InvalidParameterValueException(\"Invalid account for VM \" + vm.getAccountId() + \" in domain.\");\n        }\n        //don't allow to move the vm from the project\n        if (oldAccount.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Vm id=\" + cmd.getVmId() + \" belongs to the project and can't be moved\");\n        }\n        Account newAccount = _accountService.getActiveAccountByName(cmd.getAccountName(), cmd.getDomainId());\n        if (newAccount == null || newAccount.getType() == Account.ACCOUNT_TYPE_PROJECT) {\n            throw new InvalidParameterValueException(\"Invalid accountid=\" + cmd.getAccountName() + \" in domain \" + cmd.getDomainId());\n        }\n        \n        if (newAccount.getState() == Account.State.disabled) {\n            throw new InvalidParameterValueException(\"The new account owner \" + cmd.getAccountName() + \" is disabled.\");\n        }\n        \n        // make sure the accounts are under same domain\n        if (oldAccount.getDomainId() != newAccount.getDomainId()){\n        \t throw new InvalidParameterValueException(\"The account should be under same domain for moving VM between two accounts. Old owner domain =\" + oldAccount.getDomainId() +\n        \t\t\t \" New owner domain=\" + newAccount.getDomainId());\n        }\n        \n        // make sure the accounts are not same\n        if (oldAccount.getAccountId() == newAccount.getAccountId()){\n       \t    throw new InvalidParameterValueException(\"The account should be same domain for moving VM between two accounts. Account id =\" + oldAccount.getAccountId());\n        }\n\n        \n        // don't allow to move the vm if there are existing PF/LB/Static Nat rules, or vm is assigned to static Nat ip\n        List<PortForwardingRuleVO> pfrules = _portForwardingDao.listByVm(cmd.getVmId());\n        if (pfrules != null && pfrules.size() > 0){\n        \tthrow new InvalidParameterValueException(\"Remove the Port forwarding rules for this VM before assigning to another user.\");\n        }\n        List<FirewallRuleVO> snrules = _rulesDao.listStaticNatByVmId(vm.getId());\n        if (snrules != null && snrules.size() > 0){\n        \tthrow new InvalidParameterValueException(\"Remove the StaticNat rules for this VM before assigning to another user.\");\n        }\n        List<LoadBalancerVMMapVO> maps = _loadBalancerVMMapDao.listByInstanceId(vm.getId());\n        if (maps != null && maps.size() > 0) {\n        \tthrow new InvalidParameterValueException(\"Remove the load balancing rules for this VM before assigning to another user.\");\n        }\n        // check for one on one nat\n        IPAddressVO ip = _ipAddressDao.findByAssociatedVmId(cmd.getVmId());\n        if (ip != null){\n        \tif (ip.isOneToOneNat()){\n        \t\tthrow new InvalidParameterValueException(\"Remove the one to one nat rule for this VM for ip \" + ip.toString());\n        \t}\n        }\n        \n        DataCenterVO zone = _dcDao.findById(vm.getDataCenterIdToDeployIn());\n    \n        //Remove vm from instance group\n        removeInstanceFromInstanceGroup(cmd.getVmId());\n\n        //VV 2: check if account/domain is with in resource limits to create a new vm\n        _resourceLimitMgr.checkResourceLimit(newAccount, ResourceType.user_vm);\n\n        // VV 4: Check if new owner can use the vm template\n        VirtualMachineTemplate template = _templateDao.findById(vm.getTemplateId());\n        if (!template.isPublicTemplate()) {\n            Account templateOwner = _accountMgr.getAccount(template.getAccountId());\n            _accountMgr.checkAccess(newAccount, null, true, templateOwner);\n        }\n\n        // VV 5: check the new account can create vm in the domain\n        DomainVO domain = _domainDao.findById(cmd.getDomainId());\n        _accountMgr.checkAccess(newAccount, domain);\n\n        Transaction txn = Transaction.currentTxn();\n        txn.start();\n        //generate destroy vm event for usage\n        _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VM_DESTROY, vm.getAccountId(), vm.getDataCenterIdToDeployIn(), vm.getId(), \n                vm.getHostName(), vm.getServiceOfferingId(), vm.getTemplateId(), vm.getHypervisorType().toString()));\n        // update resource counts\n        _resourceLimitMgr.decrementResourceCount(oldAccount.getAccountId(), ResourceType.user_vm);\n\n        // OWNERSHIP STEP 1: update the vm owner\n        vm.setAccountId(newAccount.getAccountId());\n        vm.setDomainId(cmd.getDomainId());\n        _vmDao.persist(vm);\n        \n        // OS 2: update volume\n        List<VolumeVO> volumes = _volsDao.findByInstance(cmd.getVmId());\n        for (VolumeVO volume : volumes) {\n            _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VOLUME_DELETE, volume.getAccountId(), volume.getDataCenterId(), volume.getId(), volume.getName()));\n            _resourceLimitMgr.decrementResourceCount(oldAccount.getAccountId(), ResourceType.volume);\n            volume.setAccountId(newAccount.getAccountId());\n            _volsDao.persist(volume);\n            _resourceLimitMgr.incrementResourceCount(newAccount.getAccountId(), ResourceType.volume);\n            _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VOLUME_CREATE, volume.getAccountId(), volume.getDataCenterId(), volume.getId(), volume.getName(),\n            \t\tvolume.getDiskOfferingId(), volume.getTemplateId(), volume.getSize()));\n        }\n\n        _resourceLimitMgr.incrementResourceCount(newAccount.getAccountId(), ResourceType.user_vm);\n        //generate usage events to account for this change\n        _usageEventDao.persist(new UsageEventVO(EventTypes.EVENT_VM_CREATE, vm.getAccountId(), vm.getDataCenterIdToDeployIn(), vm.getId(), \n                vm.getHostName(), vm.getServiceOfferingId(),  vm.getTemplateId(), vm.getHypervisorType().toString()));\n\n        txn.commit();\n\n        VMInstanceVO vmoi = _itMgr.findByIdAndType(vm.getType(), vm.getId());\n        VirtualMachineProfileImpl<VMInstanceVO> vmOldProfile = new VirtualMachineProfileImpl<VMInstanceVO>(vmoi);\n\n        // OS 3: update the network\n        List<Long> networkIdList = cmd.getNetworkIds();\n        List<Long> securityGroupIdList = cmd.getSecurityGroupIdList();\n        \n        if (zone.getNetworkType() == NetworkType.Basic) {\n        \t if (networkIdList != null && !networkIdList.isEmpty()) {\n                 throw new InvalidParameterValueException(\"Can't move vm with network Ids; this is a basic zone VM\");\n             }\n         \t//cleanup the old security groups\n             _securityGroupMgr.removeInstanceFromGroups(cmd.getVmId());\n       \t \t//cleanup the network for the oldOwner\n            _networkMgr.cleanupNics(vmOldProfile);\n            _networkMgr.expungeNics(vmOldProfile);\n        \t//security groups will be recreated for the new account, when the VM is started\n            List<NetworkVO> networkList = new ArrayList<NetworkVO>();\n\n            // Get default guest network in Basic zone\n            Network defaultNetwork = _networkMgr.getExclusiveGuestNetwork(zone.getId());\n\n            if (defaultNetwork == null) {\n                throw new InvalidParameterValueException(\"Unable to find a default network to start a vm\");\n            } else {\n                networkList.add(_networkDao.findById(defaultNetwork.getId()));\n            }\n\n            boolean isVmWare = (template.getHypervisorType() == HypervisorType.VMware);\n\n            if (securityGroupIdList != null && isVmWare) {\n                throw new InvalidParameterValueException(\"Security group feature is not supported for vmWare hypervisor\");\n            } else if (!isVmWare && _networkMgr.isSecurityGroupSupportedInNetwork(defaultNetwork) && _networkMgr.canAddDefaultSecurityGroup()) {\n                if (securityGroupIdList == null) {\n                    securityGroupIdList = new ArrayList<Long>();\n                }\n                SecurityGroup defaultGroup = _securityGroupMgr.getDefaultSecurityGroup(newAccount.getId());\n                if (defaultGroup != null) {\n                    //check if security group id list already contains Default security group, and if not - add it\n                    boolean defaultGroupPresent = false;\n                    for (Long securityGroupId : securityGroupIdList) {\n                        if (securityGroupId.longValue() == defaultGroup.getId()) {\n                            defaultGroupPresent = true;\n                            break;\n                        }\n                    }\n\n                    if (!defaultGroupPresent) {\n                        securityGroupIdList.add(defaultGroup.getId());\n                    }\n\n                } else {\n                    //create default security group for the account\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Couldn't find default security group for the account \" + newAccount + \" so creating a new one\");\n                    }\n                    defaultGroup = _securityGroupMgr.createSecurityGroup(SecurityGroupManager.DEFAULT_GROUP_NAME, SecurityGroupManager.DEFAULT_GROUP_DESCRIPTION, newAccount.getDomainId(), newAccount.getId(), newAccount.getAccountName());\n                    securityGroupIdList.add(defaultGroup.getId());\n                }\n            }\n            \n\n            List<Pair<NetworkVO, NicProfile>> networks = new ArrayList<Pair<NetworkVO, NicProfile>>();\n            NicProfile profile = new NicProfile();\n            profile.setDefaultNic(true);\n            networks.add(new Pair<NetworkVO, NicProfile>(networkList.get(0), profile));\n           \n            VMInstanceVO vmi = _itMgr.findByIdAndType(vm.getType(), vm.getId());\n            VirtualMachineProfileImpl<VMInstanceVO> vmProfile = new VirtualMachineProfileImpl<VMInstanceVO>(vmi);\n            _networkMgr.allocate(vmProfile, networks);\n\n            _securityGroupMgr.addInstanceToGroups(vm.getId(), securityGroupIdList);\n        } else {\n            if (zone.isSecurityGroupEnabled())  {\n            \tthrow new InvalidParameterValueException(\"not yet tested for SecurityGroupEnabled advanced networks.\");\n            } else {\n                if (securityGroupIdList != null && !securityGroupIdList.isEmpty()) {\n                    throw new InvalidParameterValueException(\"Can't move vm with security groups; security group feature is not enabled in this zone\");\n                }\n            \t //cleanup the network for the oldOwner\n                _networkMgr.cleanupNics(vmOldProfile);\n                _networkMgr.expungeNics(vmOldProfile);\n                \n                Set<NetworkVO> applicableNetworks = new HashSet<NetworkVO>();\n            \n                if (networkIdList != null && !networkIdList.isEmpty()){\n\t                // add any additional networks\n\t                for (Long networkId : networkIdList) {\n\t                    NetworkVO network = _networkDao.findById(networkId);\n\t                    if (network == null) {\n\t                        throw new InvalidParameterValueException(\"Unable to find network by id \" + networkId);\n\t                    }\n\t\n\t                    _networkMgr.checkNetworkPermissions(newAccount, network);\n\t\n\t                    //don't allow to use system networks \n\t                    NetworkOffering networkOffering = _configMgr.getNetworkOffering(network.getNetworkOfferingId());\n\t                    if (networkOffering.isSystemOnly()) {\n\t                        throw new InvalidParameterValueException(\"Network id=\" + networkId + \" is system only and can't be used for vm deployment\");\n\t                    }\n\t                    applicableNetworks.add(network);\n\t                }\n                }\n                else {\n                \tNetworkVO defaultNetwork = null;\n                    List<NetworkOfferingVO> requiredOfferings = _networkOfferingDao.listByAvailability(Availability.Required, false);\n                    if (requiredOfferings.size() < 1) {\n                    \tthrow new InvalidParameterValueException(\"Unable to find network offering with availability=\" + Availability.Required + \" to automatically create the network as a part of vm creation\");\n                    }\n                    \n                    PhysicalNetwork physicalNetwork = _networkMgr.translateZoneIdToPhysicalNetwork(zone.getId());\n                    if (requiredOfferings.get(0).getState() == NetworkOffering.State.Enabled) {\n                        // get Virtual networks\n                        List<NetworkVO> virtualNetworks = _networkMgr.listNetworksForAccount(newAccount.getId(), zone.getId(), Network.GuestType.Isolated);\n\n                        if (virtualNetworks.isEmpty()) {\n                            s_logger.debug(\"Creating network for account \" + newAccount + \" from the network offering id=\" + requiredOfferings.get(0).getId() + \" as a part of deployVM process\");\n                            Network newNetwork = _networkMgr.createGuestNetwork(requiredOfferings.get(0).getId(), newAccount.getAccountName() + \"-network\", newAccount.getAccountName() + \"-network\", null, null,\n                                    null, null, newAccount, false, null, physicalNetwork, zone.getId(), ACLType.Account, null);\n                            defaultNetwork = _networkDao.findById(newNetwork.getId());\n                        } else if (virtualNetworks.size() > 1) {\n                            throw new InvalidParameterValueException(\"More than 1 default Isolated networks are found for account \" + newAccount + \"; please specify networkIds\");\n                        } else {\n                            defaultNetwork = virtualNetworks.get(0);\n                        }\n                    } else {\n                    \tthrow new InvalidParameterValueException(\"Required network offering id=\" + requiredOfferings.get(0).getId() + \" is not in \" + NetworkOffering.State.Enabled); \n                    }\n\n                    applicableNetworks.add(defaultNetwork);\n                }\n\n                // add the new nics\n                List<Pair<NetworkVO, NicProfile>> networks = new ArrayList<Pair<NetworkVO, NicProfile>>();\n                int toggle=0;\n                for (NetworkVO appNet: applicableNetworks){                    \n                    NicProfile defaultNic = new NicProfile();\n                    if (toggle==0){\n                        defaultNic.setDefaultNic(true);\n                        toggle++;\n                    }\n                    networks.add(new Pair<NetworkVO, NicProfile>(appNet, defaultNic));\n                }\n                VMInstanceVO vmi = _itMgr.findByIdAndType(vm.getType(), vm.getId());\n                VirtualMachineProfileImpl<VMInstanceVO> vmProfile = new VirtualMachineProfileImpl<VMInstanceVO>(vmi);\n                _networkMgr.allocate(vmProfile, networks);\n            } //END IF NON SEC GRP ENABLED\n        } // END IF ADVANCED\n        return vm;\n    }","commit_id":"b6e54193702fcafbc97abf8057abd39841fccb9e","url":"https://github.com/apache/cloudstack"},{"original_method":"protected List<HandlerMethodArgumentResolver> initArgumentResolvers() {\n\t\tList<HandlerMethodArgumentResolver> resolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\t\tConfigurableBeanFactory cbf = (this.beanFactory instanceof ConfigurableBeanFactory ?\n\t\t\t\t(ConfigurableBeanFactory) this.beanFactory : null);\n\n\t\t// Annotation-based argument resolution\n\t\tresolvers.add(new HeaderMethodArgumentResolver(this.conversionService, cbf));\n\t\tresolvers.add(new HeadersMethodArgumentResolver());\n\n\t\t// Type-based argument resolution\n\t\tresolvers.add(new MessageMethodArgumentResolver());\n\n\t\tif (this.customArgumentResolvers != null) {\n\t\t\tresolvers.addAll(this.customArgumentResolvers);\n\t\t}\n\t\tresolvers.add(new PayloadArgumentResolver(this.messageConverter, this.validator));\n\n\t\treturn resolvers;\n\t}","id":78024,"modified_method":"protected List<HandlerMethodArgumentResolver> initArgumentResolvers() {\n\t\tList<HandlerMethodArgumentResolver> resolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\t\tConfigurableBeanFactory cbf = (this.beanFactory instanceof ConfigurableBeanFactory ?\n\t\t\t\t(ConfigurableBeanFactory) this.beanFactory : null);\n\n\t\t// Annotation-based argument resolution\n\t\tresolvers.add(new HeaderMethodArgumentResolver(this.conversionService, cbf));\n\t\tresolvers.add(new HeadersMethodArgumentResolver());\n\n\t\t// Type-based argument resolution\n\t\tresolvers.add(new MessageMethodArgumentResolver(this.messageConverter));\n\n\t\tif (this.customArgumentResolvers != null) {\n\t\t\tresolvers.addAll(this.customArgumentResolvers);\n\t\t}\n\t\tresolvers.add(new PayloadArgumentResolver(this.messageConverter, this.validator));\n\n\t\treturn resolvers;\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Object resolveArgument(MethodParameter parameter, Message<?> message) throws Exception {\n\t\tClass<?> paramType = parameter.getParameterType();\n\t\tif (!paramType.isAssignableFrom(message.getClass())) {\n\t\t\tString actual = ClassUtils.getQualifiedName(message.getClass());\n\t\t\tString expected = ClassUtils.getQualifiedName(paramType);\n\t\t\tthrow new MethodArgumentTypeMismatchException(message, parameter, \"The actual message type \" +\n\t\t\t\t\t\"[\" + actual + \"] does not match the expected type [\" + expected + \"]\");\n\t\t}\n\n\t\tClass<?> targetPayloadType = getPayloadType(parameter);\n\t\tObject payload = message.getPayload();\n\t\tif (payload != null && !targetPayloadType.isInstance(payload)) {\n\t\t\tthrow new MethodArgumentTypeMismatchException(message, parameter,\n\t\t\t\t\t\"The expected Message<?> payload type [\" + ClassUtils.getQualifiedName(targetPayloadType) +\n\t\t\t\t\t\"] does not match the actual payload type [\" + ClassUtils.getQualifiedName(payload.getClass()) + \"]\");\n\t\t}\n\n\t\treturn message;\n\t}","id":78025,"modified_method":"@Override\n\tpublic Object resolveArgument(MethodParameter parameter, Message<?> message) throws Exception {\n\n\t\tClass<?> targetMessageType = parameter.getParameterType();\n\t\tClass<?> targetPayloadType = getPayloadType(parameter);\n\n\t\tif (!targetMessageType.isAssignableFrom(message.getClass())) {\n\t\t\tString actual = ClassUtils.getQualifiedName(message.getClass());\n\t\t\tString expected = ClassUtils.getQualifiedName(targetMessageType);\n\t\t\tthrow new MethodArgumentTypeMismatchException(message, parameter, \"The actual message type \" +\n\t\t\t\t\t\"[\" + actual + \"] does not match the expected type [\" + expected + \"]\");\n\t\t}\n\n\t\tObject payload = message.getPayload();\n\t\tif (payload == null || targetPayloadType.isInstance(payload)) {\n\t\t\treturn message;\n\t\t}\n\n\t\tif (isEmptyPayload(payload)) {\n\t\t\tString actual = ClassUtils.getQualifiedName(payload.getClass());\n\t\t\tString expected = ClassUtils.getQualifiedName(targetPayloadType);\n\t\t\tthrow new MessageConversionException(message, \"Cannot convert from the \" +\n\t\t\t\t\t\"expected payload type [\" + expected + \"] to the \" +\n\t\t\t\t\t\"actual payload type [\" + actual + \"] when the payload is empty.\");\n\t\t}\n\n\t\tpayload = convertPayload(message, parameter, targetPayloadType);\n\t\treturn MessageBuilder.createMessage(payload, message.getHeaders());\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolveMessageSubTypeSubClass() throws Exception {\n\t\tErrorMessage message = new ErrorMessage(new UnsupportedOperationException());\n\t\tMethodParameter parameter = new MethodParameter(this.method, 0);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tassertSame(message, this.resolver.resolveArgument(parameter, message));\n\t}","id":78026,"modified_method":"@Test\n\tpublic void resolveMessageSubClassMatch() throws Exception {\n\t\tErrorMessage message = new ErrorMessage(new UnsupportedOperationException());\n\t\tMethodParameter parameter = new MethodParameter(this.method, 4);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tassertSame(message, this.resolver.resolveArgument(parameter, message));\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolveWrongMessageType() throws Exception {\n\t\tUnsupportedOperationException ex = new UnsupportedOperationException();\n\t\tMessage<? extends Throwable> message = new GenericMessage<Throwable>(ex);\n\t\tMethodParameter parameter = new MethodParameter(this.method, 4);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tthrown.expect(MethodArgumentTypeMismatchException.class);\n\t\tthrown.expectMessage(ErrorMessage.class.getName());\n\t\tthrown.expectMessage(GenericMessage.class.getName());\n\t\tassertSame(message, this.resolver.resolveArgument(parameter, message));\n\t}","id":78027,"modified_method":"@Test\n\tpublic void resolveWithWrongMessageType() throws Exception {\n\t\tUnsupportedOperationException ex = new UnsupportedOperationException();\n\t\tMessage<? extends Throwable> message = new GenericMessage<Throwable>(ex);\n\t\tMethodParameter parameter = new MethodParameter(this.method, 4);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tthrown.expect(MethodArgumentTypeMismatchException.class);\n\t\tthrown.expectMessage(ErrorMessage.class.getName());\n\t\tthrown.expectMessage(GenericMessage.class.getName());\n\t\tassertSame(message, this.resolver.resolveArgument(parameter, message));\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolveAnyPayloadType() throws Exception {\n\t\tMessage<String> message = MessageBuilder.withPayload(\"test\").build();\n\t\tMethodParameter parameter = new MethodParameter(this.method, 0);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tassertSame(message, this.resolver.resolveArgument(parameter, message));\n\t}","id":78028,"modified_method":"@Test\n\tpublic void resolveWithMatchingPayloadType() throws Exception {\n\t\tMessage<Integer> message = MessageBuilder.withPayload(123).build();\n\t\tMethodParameter parameter = new MethodParameter(this.method, 1);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tassertSame(message, this.resolver.resolveArgument(parameter, message));\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unused\")\n\tprivate void handleMessage(\n\t\t\tMessage<?> wildcardPayload,\n\t\t\tMessage<Integer> integerPayload,\n\t\t\tMessage<Number> numberPayload,\n\t\t\tMessage<? extends Number> anyNumberPayload,\n\t\t\tErrorMessage subClass) {\n\t}","id":78029,"modified_method":"@SuppressWarnings(\"unused\")\n\tprivate void handle(\n\t\t\tMessage<?> wildcardPayload,\n\t\t\tMessage<Integer> integerPayload,\n\t\t\tMessage<Number> numberPayload,\n\t\t\tMessage<? extends Number> anyNumberPayload,\n\t\t\tErrorMessage subClass) {\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setup() throws Exception {\n\t\tthis.method = MessageMethodArgumentResolverTests.class.getDeclaredMethod(\"handleMessage\",\n\t\t\t\tMessage.class, Message.class, Message.class, Message.class, ErrorMessage.class);\n\t}","id":78030,"modified_method":"@Before\n\tpublic void setup() throws Exception {\n\n\t\tthis.method = MessageMethodArgumentResolverTests.class.getDeclaredMethod(\"handle\",\n\t\t\t\tMessage.class, Message.class, Message.class, Message.class,\n\t\t\t\tErrorMessage.class);\n\n\t\tthis.converter = mock(MessageConverter.class);\n\t\tthis.resolver = new MessageMethodArgumentResolver(this.converter);\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolveOutOfBoundPayloadType() throws Exception {\n\t\tMessage<Locale> message = MessageBuilder.withPayload(Locale.getDefault()).build();\n\t\tMethodParameter parameter = new MethodParameter(this.method, 3);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tthrown.expect(MethodArgumentTypeMismatchException.class);\n\t\tthrown.expectMessage(Number.class.getName());\n\t\tthrown.expectMessage(Locale.class.getName());\n\t\tthis.resolver.resolveArgument(parameter, message);\n\t}","id":78031,"modified_method":"@Test\n\tpublic void resolveWithPayloadTypeOutOfBound() throws Exception {\n\t\tMessage<Locale> message = MessageBuilder.withPayload(Locale.getDefault()).build();\n\t\tMethodParameter parameter = new MethodParameter(this.method, 3);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tthrown.expect(MessageConversionException.class);\n\t\tthrown.expectMessage(Number.class.getName());\n\t\tthrown.expectMessage(Locale.class.getName());\n\t\tthis.resolver.resolveArgument(parameter, message);\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolvePayloadTypeSubClass() throws Exception {\n\t\tMessage<Integer> message = MessageBuilder.withPayload(123).build();\n\t\tMethodParameter parameter = new MethodParameter(this.method, 2);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tassertSame(message, this.resolver.resolveArgument(parameter, message));\n\t}","id":78032,"modified_method":"@Test\n\tpublic void resolveWithPayloadTypeSubClass() throws Exception {\n\t\tMessage<Integer> message = MessageBuilder.withPayload(123).build();\n\t\tMethodParameter parameter = new MethodParameter(this.method, 2);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tassertSame(message, this.resolver.resolveArgument(parameter, message));\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resolveUpperBoundPayloadType() throws Exception {\n\t\tMessage<Integer> message = MessageBuilder.withPayload(123).build();\n\t\tMethodParameter parameter = new MethodParameter(this.method, 3);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tassertSame(message, this.resolver.resolveArgument(parameter, message));\n\t}","id":78033,"modified_method":"@Test\n\tpublic void resolveWithPayloadTypeUpperBound() throws Exception {\n\t\tMessage<Integer> message = MessageBuilder.withPayload(123).build();\n\t\tMethodParameter parameter = new MethodParameter(this.method, 3);\n\n\t\tassertTrue(this.resolver.supportsParameter(parameter));\n\t\tassertSame(message, this.resolver.resolveArgument(parameter, message));\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tprotected List<? extends HandlerMethodArgumentResolver> initArgumentResolvers() {\n\t\t\tList<HandlerMethodArgumentResolver> resolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\t\t\tresolvers.add(new MessageMethodArgumentResolver());\n\t\t\tresolvers.addAll(getCustomArgumentResolvers());\n\t\t\treturn resolvers;\n\t\t}","id":78034,"modified_method":"@Override\n\t\tprotected List<? extends HandlerMethodArgumentResolver> initArgumentResolvers() {\n\t\t\tList<HandlerMethodArgumentResolver> resolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\t\t\tresolvers.add(new MessageMethodArgumentResolver(new SimpleMessageConverter()));\n\t\t\tresolvers.addAll(getCustomArgumentResolvers());\n\t\t\treturn resolvers;\n\t\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected List<HandlerMethodArgumentResolver> initArgumentResolvers() {\n\t\tConfigurableBeanFactory beanFactory = (getApplicationContext() instanceof ConfigurableApplicationContext ?\n\t\t\t\t((ConfigurableApplicationContext) getApplicationContext()).getBeanFactory() : null);\n\n\t\tList<HandlerMethodArgumentResolver> resolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\n\t\t// Annotation-based argument resolution\n\t\tresolvers.add(new HeaderMethodArgumentResolver(this.conversionService, beanFactory));\n\t\tresolvers.add(new HeadersMethodArgumentResolver());\n\t\tresolvers.add(new DestinationVariableMethodArgumentResolver(this.conversionService));\n\n\t\t// Type-based argument resolution\n\t\tresolvers.add(new PrincipalMethodArgumentResolver());\n\t\tresolvers.add(new MessageMethodArgumentResolver());\n\n\t\tresolvers.addAll(getCustomArgumentResolvers());\n\t\tresolvers.add(new PayloadArgumentResolver(this.messageConverter, this.validator));\n\n\t\treturn resolvers;\n\t}","id":78035,"modified_method":"protected List<HandlerMethodArgumentResolver> initArgumentResolvers() {\n\t\tConfigurableBeanFactory beanFactory = (getApplicationContext() instanceof ConfigurableApplicationContext ?\n\t\t\t\t((ConfigurableApplicationContext) getApplicationContext()).getBeanFactory() : null);\n\n\t\tList<HandlerMethodArgumentResolver> resolvers = new ArrayList<HandlerMethodArgumentResolver>();\n\n\t\t// Annotation-based argument resolution\n\t\tresolvers.add(new HeaderMethodArgumentResolver(this.conversionService, beanFactory));\n\t\tresolvers.add(new HeadersMethodArgumentResolver());\n\t\tresolvers.add(new DestinationVariableMethodArgumentResolver(this.conversionService));\n\n\t\t// Type-based argument resolution\n\t\tresolvers.add(new PrincipalMethodArgumentResolver());\n\t\tresolvers.add(new MessageMethodArgumentResolver(this.messageConverter));\n\n\t\tresolvers.addAll(getCustomArgumentResolvers());\n\t\tresolvers.add(new PayloadArgumentResolver(this.messageConverter, this.validator));\n\n\t\treturn resolvers;\n\t}","commit_id":"416966d943300c1155d4202196096ced535f6586","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n    public Object getValue(Object adaptable, String name, Type declaredType, AnnotatedElement element,\n            DisposalCallbackRegistry callbackRegistry) {\n        if (adaptable instanceof Resource) {\n            return ((Resource) adaptable).getChild(name);\n        } else {\n            return null;\n        }\n    }","id":78036,"modified_method":"@Override\n    public Object getValue(Object adaptable, String name, Type declaredType, AnnotatedElement element,\n            DisposalCallbackRegistry callbackRegistry) {\n        if (adaptable instanceof Resource) {\n            Resource child = ((Resource) adaptable).getChild(name);\n            if (child != null) {\n                return getValue(child, declaredType);\n            }\n        }\n        return null;\n    }","commit_id":"61d5aaf1557e39d6b14d29f93f2744c0ba2642dc","url":"https://github.com/apache/sling"},{"original_method":"private static boolean setField(Field field, Object createdObject, Object value) {\n        if (value != null) {\n            if (!isAcceptableType(field.getType(), value) && value instanceof Adaptable) {\n                value = ((Adaptable) value).adaptTo(field.getType());\n                if (value == null) {\n                    return false;\n                }\n            }\n            boolean accessible = field.isAccessible();\n            try {\n                if (!accessible) {\n                    field.setAccessible(true);\n                }\n                field.set(createdObject, value);\n                return true;\n            } catch (Exception e) {\n                log.error(\"unable to inject field\", e);\n                return false;\n            } finally {\n                if (!accessible) {\n                    field.setAccessible(false);\n                }\n            }\n        } else {\n            return false;\n        }\n    }","id":78037,"modified_method":"private static boolean setField(Field field, Object createdObject, Object value) {\n        if (value != null) {\n            if (!isAcceptableType(field.getType(), field.getGenericType(), value)) {\n                Class<?> declaredType = field.getType();\n                Type genericType = field.getGenericType();\n                if (value instanceof Adaptable) {\n                    value = ((Adaptable) value).adaptTo(field.getType());\n                    if (value == null) {\n                        return false;\n                    }\n                } else if (genericType instanceof ParameterizedType) {\n                    ParameterizedType type = (ParameterizedType) genericType;\n                    Class<?> collectionType = (Class<?>) declaredType;\n                    if (value instanceof Collection &&\n                            (collectionType.equals(Collection.class) || collectionType.equals(List.class)) &&\n                            type.getActualTypeArguments().length == 1) {\n                        List<Object> result = new ArrayList<Object>();\n                        for (Object valueObject : (Collection<?>) value) {\n                            if (valueObject instanceof Adaptable) {\n                                Object adapted = ((Adaptable) valueObject).adaptTo((Class<?>) type.getActualTypeArguments()[0]);\n                                if (adapted != null) {\n                                    result.add(adapted);\n                                }\n                            }\n                        }\n                        value = result;\n                    }\n                }\n            }\n            boolean accessible = field.isAccessible();\n            try {\n                if (!accessible) {\n                    field.setAccessible(true);\n                }\n                field.set(createdObject, value);\n                return true;\n            } catch (Exception e) {\n                log.error(\"unable to inject field\", e);\n                return false;\n            } finally {\n                if (!accessible) {\n                    field.setAccessible(false);\n                }\n            }\n        } else {\n            return false;\n        }\n    }","commit_id":"61d5aaf1557e39d6b14d29f93f2744c0ba2642dc","url":"https://github.com/apache/sling"},{"original_method":"private static boolean setMethod(Method method, Map<Method, Object> methods, Object value) {\n        if (value != null) {\n            if (!isAcceptableType(method.getReturnType(), value) && value instanceof Adaptable) {\n                value = ((Adaptable) value).adaptTo(method.getReturnType());\n                if (value == null) {\n                    return false;\n                }\n            }\n            methods.put(method, value);\n            return true;\n        } else {\n            return false;\n        }\n    }","id":78038,"modified_method":"private static boolean setMethod(Method method, Map<Method, Object> methods, Object value) {\n        if (value != null) {\n            if (!isAcceptableType(method.getReturnType(), method.getGenericReturnType(), value) && value instanceof Adaptable) {\n                value = ((Adaptable) value).adaptTo(method.getReturnType());\n                if (value == null) {\n                    return false;\n                }\n            }\n            methods.put(method, value);\n            return true;\n        } else {\n            return false;\n        }\n    }","commit_id":"61d5aaf1557e39d6b14d29f93f2744c0ba2642dc","url":"https://github.com/apache/sling"},{"original_method":"private static boolean isAcceptableType(Class<?> type, Object value) {\n        if (type.isInstance(value)) {\n            return true;\n        }\n\n        if (type == Integer.TYPE) {\n            return Integer.class.isInstance(value);\n        }\n        if (type == Long.TYPE) {\n            return Long.class.isInstance(value);\n        }\n        if (type == Boolean.TYPE) {\n            return Boolean.class.isInstance(value);\n        }\n        if (type == Double.TYPE) {\n            return Double.class.isInstance(value);\n        }\n        if (type == Float.TYPE) {\n            return Float.class.isInstance(value);\n        }\n        if (type == Short.TYPE) {\n            return Short.class.isInstance(value);\n        }\n        if (type == Character.TYPE) {\n            return Character.class.isInstance(value);\n        }\n\n        return false;\n    }","id":78039,"modified_method":"private static boolean isAcceptableType(Class<?> type, Type genericType, Object value) {\n        if (type.isInstance(value)) {\n            if ((type == Collection.class || type == List.class) && genericType instanceof ParameterizedType &&\n                    value instanceof Collection) {\n                Iterator<?> it = ((Collection<?>) value).iterator();\n                if (!it.hasNext()) {\n                    // empty collection, so it doesn't really matter\n                    return true;\n                } else {\n                    // this is not an ideal way to get the actual component type, but erasure...\n                    Class<?> actualComponentType = it.next().getClass();\n                    Class<?> desiredComponentType = (Class<?>) ((ParameterizedType) genericType).getActualTypeArguments()[0];\n                    return desiredComponentType.isAssignableFrom(actualComponentType);\n                }\n            } else {\n                return true;\n            }\n        }\n\n        if (type == Integer.TYPE) {\n            return Integer.class.isInstance(value);\n        }\n        if (type == Long.TYPE) {\n            return Long.class.isInstance(value);\n        }\n        if (type == Boolean.TYPE) {\n            return Boolean.class.isInstance(value);\n        }\n        if (type == Double.TYPE) {\n            return Double.class.isInstance(value);\n        }\n        if (type == Float.TYPE) {\n            return Float.class.isInstance(value);\n        }\n        if (type == Short.TYPE) {\n            return Short.class.isInstance(value);\n        }\n        if (type == Character.TYPE) {\n            return Character.class.isInstance(value);\n        }\n\n        return false;\n    }","commit_id":"61d5aaf1557e39d6b14d29f93f2744c0ba2642dc","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testChildModel() {\n        Object value = RandomStringUtils.randomAlphabetic(10);\n        Map<String, Object> props = Collections.singletonMap(\"property\", value);\n        ValueMap map = new ValueMapDecorator(props);\n\n        final Resource child = mock(Resource.class);\n        when(child.adaptTo(ValueMap.class)).thenReturn(map);\n        when(child.adaptTo(ChildModel.class)).thenAnswer(new Answer<ChildModel>() {\n\n            @Override\n            public ChildModel answer(InvocationOnMock invocation) throws Throwable {\n                return factory.getAdapter(child, ChildModel.class);\n            }\n\n        });\n\n        Resource res = mock(Resource.class);\n        when(res.getChild(\"firstChild\")).thenReturn(child);\n\n        ParentModel model = factory.getAdapter(res, ParentModel.class);\n        assertNotNull(model);\n\n        ChildModel childModel = model.getFirstChild();\n        assertNotNull(childModel);\n        assertEquals(value, childModel.getProperty());\n    }","id":78040,"modified_method":"@Test\n    public void testChildModel() {\n        Object firstValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap firstMap = new ValueMapDecorator(Collections.singletonMap(\"property\", firstValue));\n\n        final Resource firstChild = mock(Resource.class);\n        when(firstChild.adaptTo(ValueMap.class)).thenReturn(firstMap);\n        when(firstChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildMap());\n\n        Object firstGrandChildValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap firstGrandChildMap = new ValueMapDecorator(Collections.singletonMap(\"property\", firstGrandChildValue));\n        Object secondGrandChildValue = RandomStringUtils.randomAlphabetic(10);\n        ValueMap secondGrandChildMap = new ValueMapDecorator(Collections.singletonMap(\"property\", secondGrandChildValue));\n\n        final Resource firstGrandChild = mock(Resource.class);\n        when(firstGrandChild.adaptTo(ValueMap.class)).thenReturn(firstGrandChildMap);\n        when(firstGrandChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildMap());\n\n        final Resource secondGrandChild = mock(Resource.class);\n        when(secondGrandChild.adaptTo(ValueMap.class)).thenReturn(secondGrandChildMap);\n        when(secondGrandChild.adaptTo(ChildModel.class)).thenAnswer(new AdaptToChildMap());\n\n        Resource secondChild = mock(Resource.class);\n        when(secondChild.listChildren()).thenReturn(Arrays.asList(firstGrandChild, secondGrandChild).iterator());\n\n        Resource emptyChild = mock(Resource.class);\n        when(emptyChild.listChildren()).thenReturn(Collections.<Resource>emptySet().iterator());\n\n        Resource res = mock(Resource.class);\n        when(res.getChild(\"firstChild\")).thenReturn(firstChild);\n        when(res.getChild(\"secondChild\")).thenReturn(secondChild);\n        when(res.getChild(\"emptyChild\")).thenReturn(emptyChild);\n\n        ParentModel model = factory.getAdapter(res, ParentModel.class);\n        assertNotNull(model);\n\n        ChildModel childModel = model.getFirstChild();\n        assertNotNull(childModel);\n        assertEquals(firstValue, childModel.getProperty());\n        assertEquals(2, model.getGrandChildren().size());\n        assertEquals(firstGrandChildValue, model.getGrandChildren().get(0).getProperty());\n        assertEquals(secondGrandChildValue, model.getGrandChildren().get(1).getProperty());\n    }","commit_id":"61d5aaf1557e39d6b14d29f93f2744c0ba2642dc","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testChildResource() {\n        Resource child = mock(Resource.class);\n\n        Resource res = mock(Resource.class);\n        when(res.getChild(\"firstChild\")).thenReturn(child);\n\n        ChildResourceModel model = factory.getAdapter(res, ChildResourceModel.class);\n        assertNotNull(model);\n        assertEquals(child, model.getFirstChild());\n    }","id":78041,"modified_method":"@Test\n    public void testChildResource() {\n        Resource child = mock(Resource.class);\n        Resource secondChild = mock(Resource.class);\n        Resource emptyChild = mock(Resource.class);\n\n        Resource firstGrandChild = mock(Resource.class);\n        Resource secondGrandChild = mock(Resource.class);\n        when(secondChild.listChildren()).thenReturn(Arrays.asList(firstGrandChild, secondGrandChild).iterator());\n        when(emptyChild.listChildren()).thenReturn(Collections.<Resource>emptySet().iterator());\n\n        Resource res = mock(Resource.class);\n        when(res.getChild(\"firstChild\")).thenReturn(child);\n        when(res.getChild(\"secondChild\")).thenReturn(secondChild);\n        when(res.getChild(\"emptyChild\")).thenReturn(emptyChild);\n\n        ChildResourceModel model = factory.getAdapter(res, ChildResourceModel.class);\n        assertNotNull(model);\n        assertEquals(child, model.getFirstChild());\n        assertEquals(2, model.getGrandChildren().size());\n        assertEquals(firstGrandChild, model.getGrandChildren().get(0));\n        assertEquals(secondGrandChild, model.getGrandChildren().get(1));\n        assertEquals(0, model.getEmptyGrandChildren().size());\n    }","commit_id":"61d5aaf1557e39d6b14d29f93f2744c0ba2642dc","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\n        Object originalValue = configMap.get(key);\n        if(originalValue != null && !targetType.isInstance(originalValue)) {\n            if(!(originalValue instanceof NavigableMap)) {\n\n                try {\n                    T value = conversionService.convert(originalValue, targetType);\n                    return DefaultGroovyMethods.asBoolean(value) ? value : defaultValue;\n                } catch (ConversionException e) {\n                    // ignore, return default value\n                }\n            }\n        }\n        return defaultValue;\n    }","id":78042,"modified_method":"@Override\n    public <T> T getProperty(String key, Class<T> targetType, T defaultValue) {\n        Object originalValue = configMap.get(key);\n        if(originalValue != null) {\n            if(targetType.isInstance(originalValue)) {\n                return (T)originalValue;\n            }\n            else {\n                if(!(originalValue instanceof NavigableMap)) {\n\n                    try {\n                        T value = conversionService.convert(originalValue, targetType);\n                        return DefaultGroovyMethods.asBoolean(value) ? value : defaultValue;\n                    } catch (ConversionException e) {\n                        // ignore, return default value\n                    }\n                }\n            }\n        }\n        return defaultValue;\n    }","commit_id":"13827686ca192d13c32bc5f4ba0da86cb78927d2","url":"https://github.com/grails/grails-core"},{"original_method":"private void submitAndVerifyStreamBatchJob(Class<? extends AbstractApplication> appClass,\n                                             String streamWriter, String mapReduceName, int timeout) throws Exception {\n    ApplicationManager applicationManager = deployApplication(appClass);\n    StreamManager streamManager = getStreamManager(streamWriter);\n    for (int i = 0; i < 50; i++) {\n      streamManager.send(String.valueOf(i));\n    }\n\n    MapReduceManager mapReduceManager = applicationManager.getMapReduceManager(mapReduceName);\n    mapReduceManager.start();\n    mapReduceManager.waitForFinish(timeout, TimeUnit.SECONDS);\n\n    // The MR job simply turns every stream event body into key/value pairs, with key==value.\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"results\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 0; i < 50; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertArrayEquals(key, results.read(key));\n    }\n  }","id":78043,"modified_method":"private void submitAndVerifyStreamBatchJob(Class<? extends AbstractApplication> appClass,\n                                             String streamWriter, String mapReduceName, int timeout) throws Exception {\n    ApplicationManager applicationManager = deployApplication(appClass);\n    StreamManager streamManager = getStreamManager(streamWriter);\n    for (int i = 0; i < 50; i++) {\n      streamManager.send(String.valueOf(i));\n    }\n\n    MapReduceManager mapReduceManager = applicationManager.getMapReduceManager(mapReduceName).start();\n    mapReduceManager.waitForFinish(timeout, TimeUnit.SECONDS);\n\n    // The MR job simply turns every stream event body into key/value pairs, with key==value.\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"results\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 0; i < 50; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertArrayEquals(key, results.read(key));\n    }\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testWordCountOnFileSet() throws Exception {\n\n    // deploy the application\n    ApplicationManager applicationManager = deployApplication(FileSetExample.class);\n\n    final String line1 = \"a b a\";\n    final String line2 = \"b a b\";\n\n    // discover the file set service\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"FileSetService\");\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n    URL serviceURL = serviceManager.getServiceURL();\n\n    // write a file to the file set using the service\n    HttpURLConnection connection = (HttpURLConnection) new URL(serviceURL, \"lines?path=nn.1\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(line1.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // run word count over that file only\n    Map<String, String> runtimeArguments = Maps.newHashMap();\n    Map<String, String> inputArgs = Maps.newHashMap();\n    FileSetArguments.setInputPaths(inputArgs, \"nn.1\");\n    Map<String, String> outputArgs = Maps.newHashMap();\n    FileSetArguments.setOutputPath(outputArgs, \"out.1\");\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"lines\", inputArgs));\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"counts\", outputArgs));\n\n    MapReduceManager mapReduceManager = applicationManager.getMapReduceManager(\"WordCount\");\n    mapReduceManager.start(runtimeArguments);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // retrieve the counts through the service and verify\n    Map<String, Integer> counts = Maps.newHashMap();\n    connection = (HttpURLConnection) new URL(serviceURL, \"counts?path=out.1/part-r-00000\").openConnection();\n    try {\n      connection.setRequestMethod(\"GET\");\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n      readCounts(connection.getInputStream(), counts);\n    } finally {\n      connection.disconnect();\n    }\n    // \"a b a\" should yield \"a\":2, \"b\":1\n    Assert.assertEquals(2, counts.size());\n    Assert.assertEquals(new Integer(2), counts.get(\"a\"));\n    Assert.assertEquals(new Integer(1), counts.get(\"b\"));\n\n    // write a file to the file set using the dataset directly\n    DataSetManager<FileSet> linesManager = getDataset(\"lines\");\n    OutputStream output = linesManager.get().getLocation(\"nn.2\").getOutputStream();\n    try {\n      output.write(line2.getBytes(Charsets.UTF_8));\n    } finally {\n      output.close();\n    }\n\n    // run word count over both files\n    FileSetArguments.setInputPath(inputArgs, \"nn.1\");\n    FileSetArguments.addInputPath(inputArgs, \"nn.2\");\n    FileSetArguments.setOutputPath(outputArgs, \"out.2\");\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"lines\", inputArgs));\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"counts\", outputArgs));\n\n    mapReduceManager = applicationManager.getMapReduceManager(\"WordCount\");\n    mapReduceManager.start(runtimeArguments);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // retrieve the counts through the dataset API and verify\n    // write a file to the file set using the dataset directly\n    DataSetManager<FileSet> countsManager = getDataset(\"counts\");\n\n    counts.clear();\n    Location resultLocation = countsManager.get().getLocation(\"out.2\");\n    Assert.assertTrue(resultLocation.isDirectory());\n    for (Location child : resultLocation.list()) {\n      if (child.getName().startsWith(\"part-\")) { // only read part files, no check sums or done files\n        readCounts(child.getInputStream(), counts);\n      }\n    }\n    // \"a b a\" and \"b a b\" should yield \"a\":3, \"b\":3\n    Assert.assertEquals(2, counts.size());\n    Assert.assertEquals(new Integer(3), counts.get(\"a\"));\n    Assert.assertEquals(new Integer(3), counts.get(\"b\"));\n\n    serviceManager.stop();\n  }","id":78044,"modified_method":"@Test\n  public void testWordCountOnFileSet() throws Exception {\n\n    // deploy the application\n    ApplicationManager applicationManager = deployApplication(FileSetExample.class);\n\n    final String line1 = \"a b a\";\n    final String line2 = \"b a b\";\n\n    // discover the file set service\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"FileSetService\").start();\n    serviceManager.waitForStatus(true);\n    URL serviceURL = serviceManager.getServiceURL();\n\n    // write a file to the file set using the service\n    HttpURLConnection connection = (HttpURLConnection) new URL(serviceURL, \"lines?path=nn.1\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(line1.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // run word count over that file only\n    Map<String, String> runtimeArguments = Maps.newHashMap();\n    Map<String, String> inputArgs = Maps.newHashMap();\n    FileSetArguments.setInputPaths(inputArgs, \"nn.1\");\n    Map<String, String> outputArgs = Maps.newHashMap();\n    FileSetArguments.setOutputPath(outputArgs, \"out.1\");\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"lines\", inputArgs));\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"counts\", outputArgs));\n\n    MapReduceManager mapReduceManager = applicationManager.getMapReduceManager(\"WordCount\").start(runtimeArguments);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // retrieve the counts through the service and verify\n    Map<String, Integer> counts = Maps.newHashMap();\n    connection = (HttpURLConnection) new URL(serviceURL, \"counts?path=out.1/part-r-00000\").openConnection();\n    try {\n      connection.setRequestMethod(\"GET\");\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n      readCounts(connection.getInputStream(), counts);\n    } finally {\n      connection.disconnect();\n    }\n    // \"a b a\" should yield \"a\":2, \"b\":1\n    Assert.assertEquals(2, counts.size());\n    Assert.assertEquals(new Integer(2), counts.get(\"a\"));\n    Assert.assertEquals(new Integer(1), counts.get(\"b\"));\n\n    // write a file to the file set using the dataset directly\n    DataSetManager<FileSet> linesManager = getDataset(\"lines\");\n    OutputStream output = linesManager.get().getLocation(\"nn.2\").getOutputStream();\n    try {\n      output.write(line2.getBytes(Charsets.UTF_8));\n    } finally {\n      output.close();\n    }\n\n    // run word count over both files\n    FileSetArguments.setInputPath(inputArgs, \"nn.1\");\n    FileSetArguments.addInputPath(inputArgs, \"nn.2\");\n    FileSetArguments.setOutputPath(outputArgs, \"out.2\");\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"lines\", inputArgs));\n    runtimeArguments.putAll(RuntimeArguments.addScope(Scope.DATASET, \"counts\", outputArgs));\n\n    mapReduceManager = applicationManager.getMapReduceManager(\"WordCount\").start(runtimeArguments);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // retrieve the counts through the dataset API and verify\n    // write a file to the file set using the dataset directly\n    DataSetManager<FileSet> countsManager = getDataset(\"counts\");\n\n    counts.clear();\n    Location resultLocation = countsManager.get().getLocation(\"out.2\");\n    Assert.assertTrue(resultLocation.isDirectory());\n    for (Location child : resultLocation.list()) {\n      if (child.getName().startsWith(\"part-\")) { // only read part files, no check sums or done files\n        readCounts(child.getInputStream(), counts);\n      }\n    }\n    // \"a b a\" and \"b a b\" should yield \"a\":3, \"b\":3\n    Assert.assertEquals(2, counts.size());\n    Assert.assertEquals(new Integer(3), counts.get(\"a\"));\n    Assert.assertEquals(new Integer(3), counts.get(\"b\"));\n\n    serviceManager.stop();\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    // Deploy the HelloWorld application\n    ApplicationManager appManager = deployApplication(HelloWorld.class);\n\n    // Start WhoFlow\n    FlowManager flowManager = appManager.getFlowManager(\"WhoFlow\");\n    flowManager.start();\n    Assert.assertTrue(flowManager.isRunning());\n\n    // Send stream events to the \"who\" Stream\n    StreamManager streamManager = getStreamManager(\"who\");\n    streamManager.send(\"1\");\n    streamManager.send(\"2\");\n    streamManager.send(\"3\");\n    streamManager.send(\"4\");\n    streamManager.send(\"5\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"HelloWorld\", \"WhoFlow\", \"saver\");\n      metrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // Start Greeting service and use it\n    ServiceManager serviceManager = appManager.getServiceManager(HelloWorld.Greeting.SERVICE_NAME);\n    serviceManager.start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    URL url = new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"greet\");\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    String response;\n    try {\n      response = new String(ByteStreams.toByteArray(connection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      connection.disconnect();\n    }\n    Assert.assertEquals(\"Hello 5!\", response);\n  }","id":78045,"modified_method":"@Test\n  public void test() throws Exception {\n    // Deploy the HelloWorld application\n    ApplicationManager appManager = deployApplication(HelloWorld.class);\n\n    // Start WhoFlow\n    FlowManager flowManager = appManager.getFlowManager(\"WhoFlow\").start();\n    Assert.assertTrue(flowManager.isRunning());\n\n    // Send stream events to the \"who\" Stream\n    StreamManager streamManager = getStreamManager(\"who\");\n    streamManager.send(\"1\");\n    streamManager.send(\"2\");\n    streamManager.send(\"3\");\n    streamManager.send(\"4\");\n    streamManager.send(\"5\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"HelloWorld\", \"WhoFlow\", \"saver\");\n      metrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // Start Greeting service and use it\n    ServiceManager serviceManager = appManager.getServiceManager(HelloWorld.Greeting.SERVICE_NAME).start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    URL url = new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"greet\");\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    String response;\n    try {\n      response = new String(ByteStreams.toByteArray(connection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      connection.disconnect();\n    }\n    Assert.assertEquals(\"Hello 5!\", response);\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testFlowManager() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestApplication.class);\n    FlowManager flowManager = applicationManager.getFlowManager(TestFlow.NAME);\n    flowManager.start();\n    flowManager.stop();\n  }","id":78046,"modified_method":"@Test\n  public void testFlowManager() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestApplication.class);\n    FlowManager flowManager = applicationManager.getFlowManager(TestFlow.NAME).start();\n    flowManager.stop();\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestMapReduceServiceIntegrationApp.class);\n    ServiceManager serviceManager =\n      applicationManager.getServiceManager(TestMapReduceServiceIntegrationApp.SERVICE_NAME);\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> inDataSet =\n      applicationManager.getDataSet(TestMapReduceServiceIntegrationApp.INPUT_DATASET);\n    inDataSet.get().write(\"key1\", \"Two words\");\n    inDataSet.get().write(\"key2\", \"Plus three words\");\n    inDataSet.flush();\n\n    MapReduceManager mrManager = applicationManager.getMapReduceManager(TestMapReduceServiceIntegrationApp.MR_NAME);\n    mrManager.start();\n    mrManager.waitForFinish(180, TimeUnit.SECONDS);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> outDataSet =\n      applicationManager.getDataSet(TestMapReduceServiceIntegrationApp.OUTPUT_DATASET);\n    MyKeyValueTableDefinition.KeyValueTable results = outDataSet.get();\n\n    String total = results.get(TestMapReduceServiceIntegrationApp.SQUARED_TOTAL_WORDS_COUNT);\n    Assert.assertEquals(25, Integer.parseInt(total));\n  }","id":78047,"modified_method":"@Test\n  public void test() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestMapReduceServiceIntegrationApp.class);\n    ServiceManager serviceManager =\n      applicationManager.getServiceManager(TestMapReduceServiceIntegrationApp.SERVICE_NAME).start();\n    serviceManager.waitForStatus(true);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> inDataSet =\n      applicationManager.getDataSet(TestMapReduceServiceIntegrationApp.INPUT_DATASET);\n    inDataSet.get().write(\"key1\", \"Two words\");\n    inDataSet.get().write(\"key2\", \"Plus three words\");\n    inDataSet.flush();\n\n    MapReduceManager mrManager =\n      applicationManager.getMapReduceManager(TestMapReduceServiceIntegrationApp.MR_NAME).start();\n    mrManager.waitForFinish(180, TimeUnit.SECONDS);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> outDataSet =\n      applicationManager.getDataSet(TestMapReduceServiceIntegrationApp.OUTPUT_DATASET);\n    MyKeyValueTableDefinition.KeyValueTable results = outDataSet.get();\n\n    String total = results.get(TestMapReduceServiceIntegrationApp.SQUARED_TOTAL_WORDS_COUNT);\n    Assert.assertEquals(25, Integer.parseInt(total));\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n\n    ApplicationManager applicationManager = deployApplication(AppWithMapReduceUsingStream.class);\n    Schema schema = new Schema.Parser().parse(AppWithMapReduceUsingStream.SCHEMA.toString());\n    StreamManager streamManager = getStreamManager(\"mrStream\");\n    streamManager.send(createEvent(schema, \"YHOO\", 100, 10.0f));\n    streamManager.send(createEvent(schema, \"YHOO\", 10, 10.1f));\n    streamManager.send(createEvent(schema, \"YHOO\", 13, 9.9f));\n    float yhooTotal = 100 * 10.0f + 10 * 10.1f + 13 * 9.9f;\n    streamManager.send(createEvent(schema, \"AAPL\", 5, 300.0f));\n    streamManager.send(createEvent(schema, \"AAPL\", 3, 298.34f));\n    streamManager.send(createEvent(schema, \"AAPL\", 50, 305.23f));\n    streamManager.send(createEvent(schema, \"AAPL\", 1000, 284.13f));\n    float aaplTotal = 5 * 300.0f + 3 * 298.34f + 50 * 305.23f + 1000 * 284.13f;\n\n    MapReduceManager mrManager = applicationManager.getMapReduceManager(\"BodyTracker\");\n    mrManager.start();\n    mrManager.waitForFinish(180, TimeUnit.SECONDS);\n\n    KeyValueTable pricesDS = (KeyValueTable) getDataset(\"prices\").get();\n    float yhooVal = Bytes.toFloat(pricesDS.read(Bytes.toBytes(\"YHOO\")));\n    float aaplVal = Bytes.toFloat(pricesDS.read(Bytes.toBytes(\"AAPL\")));\n    Assert.assertTrue(Math.abs(yhooTotal - yhooVal) < 0.0000001);\n    Assert.assertTrue(Math.abs(aaplTotal - aaplVal) < 0.0000001);\n  }","id":78048,"modified_method":"@Test\n  public void test() throws Exception {\n\n    ApplicationManager applicationManager = deployApplication(AppWithMapReduceUsingStream.class);\n    Schema schema = new Schema.Parser().parse(AppWithMapReduceUsingStream.SCHEMA.toString());\n    StreamManager streamManager = getStreamManager(\"mrStream\");\n    streamManager.send(createEvent(schema, \"YHOO\", 100, 10.0f));\n    streamManager.send(createEvent(schema, \"YHOO\", 10, 10.1f));\n    streamManager.send(createEvent(schema, \"YHOO\", 13, 9.9f));\n    float yhooTotal = 100 * 10.0f + 10 * 10.1f + 13 * 9.9f;\n    streamManager.send(createEvent(schema, \"AAPL\", 5, 300.0f));\n    streamManager.send(createEvent(schema, \"AAPL\", 3, 298.34f));\n    streamManager.send(createEvent(schema, \"AAPL\", 50, 305.23f));\n    streamManager.send(createEvent(schema, \"AAPL\", 1000, 284.13f));\n    float aaplTotal = 5 * 300.0f + 3 * 298.34f + 50 * 305.23f + 1000 * 284.13f;\n\n    MapReduceManager mrManager = applicationManager.getMapReduceManager(\"BodyTracker\").start();\n    mrManager.waitForFinish(180, TimeUnit.SECONDS);\n\n    KeyValueTable pricesDS = (KeyValueTable) getDataset(\"prices\").get();\n    float yhooVal = Bytes.toFloat(pricesDS.read(Bytes.toBytes(\"YHOO\")));\n    float aaplVal = Bytes.toFloat(pricesDS.read(Bytes.toBytes(\"AAPL\")));\n    Assert.assertTrue(Math.abs(yhooTotal - yhooVal) < 0.0000001);\n    Assert.assertTrue(Math.abs(aaplTotal - aaplVal) < 0.0000001);\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    // Deploy the PurchaseApp application\n    ApplicationManager appManager = deployApplication(PurchaseApp.class);\n\n    // Start PurchaseFlow\n    FlowManager flowManager = appManager.getFlowManager(\"PurchaseFlow\");\n    flowManager.start();\n\n    // Send stream events to the \"purchaseStream\" Stream\n    StreamManager streamManager = getStreamManager(\"purchaseStream\");\n    streamManager.send(\"bob bought 3 apples for $30\");\n    streamManager.send(\"joe bought 1 apple for $100\");\n    streamManager.send(\"joe bought 10 pineapples for $20\");\n    streamManager.send(\"cat bought 3 bottles for $12\");\n    streamManager.send(\"cat bought 2 pops for $14\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"PurchaseHistory\", \"PurchaseFlow\", \"collector\");\n      metrics.waitForProcessed(5, 15, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n    }\n\n    ServiceManager userProfileServiceManager = getUserProfileServiceManager(appManager);\n\n    // Add customer's profile information\n    URL userProfileUrl = new URL(userProfileServiceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                    UserProfileServiceHandler.USER_ENDPOINT);\n    HttpURLConnection userProfileConnection = (HttpURLConnection) userProfileUrl.openConnection();\n    String userProfileJson = \"{'id' : 'joe', 'firstName': 'joe', 'lastName':'bernard', 'categories': ['fruits']}\";\n\n    try {\n      userProfileConnection.setDoOutput(true);\n      userProfileConnection.setRequestMethod(\"POST\");\n      userProfileConnection.getOutputStream().write(userProfileJson.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, userProfileConnection.getResponseCode());\n    } finally {\n      userProfileConnection.disconnect();\n    }\n\n    // Test service to retrieve customer's profile information\n    userProfileUrl = new URL(userProfileServiceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                    UserProfileServiceHandler.USER_ENDPOINT + \"/joe\");\n    userProfileConnection = (HttpURLConnection) userProfileUrl.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, userProfileConnection.getResponseCode());\n    String customerJson;\n    try {\n      customerJson = new String(ByteStreams.toByteArray(userProfileConnection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      userProfileConnection.disconnect();\n    }\n\n    UserProfile profileFromService = GSON.fromJson(customerJson, UserProfile.class);\n    Assert.assertEquals(profileFromService.getFirstName(), \"joe\");\n    Assert.assertEquals(profileFromService.getLastName(), \"bernard\");\n\n    // Run PurchaseHistoryWorkflow which will process the data\n    MapReduceManager mapReduceManager = appManager.getMapReduceManager(\"PurchaseHistoryBuilder\");\n    mapReduceManager.start();\n    mapReduceManager.waitForFinish(3, TimeUnit.MINUTES);\n\n    // Start PurchaseHistoryService\n    ServiceManager purchaseHistoryServiceManager = appManager.getServiceManager(PurchaseHistoryService.SERVICE_NAME);\n    purchaseHistoryServiceManager.start();\n\n    // Wait for service startup\n    purchaseHistoryServiceManager.waitForStatus(true);\n\n    // Test service to retrieve a customer's purchase history\n    URL url = new URL(purchaseHistoryServiceManager.getServiceURL(15, TimeUnit.SECONDS), \"history/joe\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\n    String historyJson;\n    try {\n      historyJson = new String(ByteStreams.toByteArray(conn.getInputStream()), Charsets.UTF_8);\n    } finally {\n      conn.disconnect();\n    }\n    PurchaseHistory history = GSON.fromJson(historyJson, PurchaseHistory.class);\n    Assert.assertEquals(\"joe\", history.getCustomer());\n    Assert.assertEquals(2, history.getPurchases().size());\n\n    UserProfile profileFromPurchaseHistory = history.getUserProfile();\n    Assert.assertEquals(profileFromPurchaseHistory.getFirstName(), \"joe\");\n    Assert.assertEquals(profileFromPurchaseHistory.getLastName(), \"bernard\");\n  }","id":78049,"modified_method":"@Test\n  public void test() throws Exception {\n    // Deploy the PurchaseApp application\n    ApplicationManager appManager = deployApplication(PurchaseApp.class);\n\n    // Start PurchaseFlow\n    FlowManager flowManager = appManager.getFlowManager(\"PurchaseFlow\").start();\n\n    // Send stream events to the \"purchaseStream\" Stream\n    StreamManager streamManager = getStreamManager(\"purchaseStream\");\n    streamManager.send(\"bob bought 3 apples for $30\");\n    streamManager.send(\"joe bought 1 apple for $100\");\n    streamManager.send(\"joe bought 10 pineapples for $20\");\n    streamManager.send(\"cat bought 3 bottles for $12\");\n    streamManager.send(\"cat bought 2 pops for $14\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"PurchaseHistory\", \"PurchaseFlow\", \"collector\");\n      metrics.waitForProcessed(5, 15, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n    }\n\n    ServiceManager userProfileServiceManager = getUserProfileServiceManager(appManager);\n\n    // Add customer's profile information\n    URL userProfileUrl = new URL(userProfileServiceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                    UserProfileServiceHandler.USER_ENDPOINT);\n    HttpURLConnection userProfileConnection = (HttpURLConnection) userProfileUrl.openConnection();\n    String userProfileJson = \"{'id' : 'joe', 'firstName': 'joe', 'lastName':'bernard', 'categories': ['fruits']}\";\n\n    try {\n      userProfileConnection.setDoOutput(true);\n      userProfileConnection.setRequestMethod(\"POST\");\n      userProfileConnection.getOutputStream().write(userProfileJson.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, userProfileConnection.getResponseCode());\n    } finally {\n      userProfileConnection.disconnect();\n    }\n\n    // Test service to retrieve customer's profile information\n    userProfileUrl = new URL(userProfileServiceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                    UserProfileServiceHandler.USER_ENDPOINT + \"/joe\");\n    userProfileConnection = (HttpURLConnection) userProfileUrl.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, userProfileConnection.getResponseCode());\n    String customerJson;\n    try {\n      customerJson = new String(ByteStreams.toByteArray(userProfileConnection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      userProfileConnection.disconnect();\n    }\n\n    UserProfile profileFromService = GSON.fromJson(customerJson, UserProfile.class);\n    Assert.assertEquals(profileFromService.getFirstName(), \"joe\");\n    Assert.assertEquals(profileFromService.getLastName(), \"bernard\");\n\n    // Run PurchaseHistoryWorkflow which will process the data\n    MapReduceManager mapReduceManager = appManager.getMapReduceManager(\"PurchaseHistoryBuilder\").start();\n    mapReduceManager.waitForFinish(3, TimeUnit.MINUTES);\n\n    // Start PurchaseHistoryService\n    ServiceManager purchaseHistoryServiceManager =\n      appManager.getServiceManager(PurchaseHistoryService.SERVICE_NAME).start();\n\n    // Wait for service startup\n    purchaseHistoryServiceManager.waitForStatus(true);\n\n    // Test service to retrieve a customer's purchase history\n    URL url = new URL(purchaseHistoryServiceManager.getServiceURL(15, TimeUnit.SECONDS), \"history/joe\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, conn.getResponseCode());\n    String historyJson;\n    try {\n      historyJson = new String(ByteStreams.toByteArray(conn.getInputStream()), Charsets.UTF_8);\n    } finally {\n      conn.disconnect();\n    }\n    PurchaseHistory history = GSON.fromJson(historyJson, PurchaseHistory.class);\n    Assert.assertEquals(\"joe\", history.getCustomer());\n    Assert.assertEquals(2, history.getPurchases().size());\n\n    UserProfile profileFromPurchaseHistory = history.getUserProfile();\n    Assert.assertEquals(profileFromPurchaseHistory.getFirstName(), \"joe\");\n    Assert.assertEquals(profileFromPurchaseHistory.getLastName(), \"bernard\");\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"private ServiceManager getUserProfileServiceManager(ApplicationManager appManager) throws InterruptedException {\n    // Start UserProfileService\n    ServiceManager userProfileServiceManager = appManager.getServiceManager(UserProfileServiceHandler.SERVICE_NAME);\n    userProfileServiceManager.start();\n\n    // Wait for service startup\n    userProfileServiceManager.waitForStatus(true);\n    return userProfileServiceManager;\n  }","id":78050,"modified_method":"private ServiceManager getUserProfileServiceManager(ApplicationManager appManager) throws InterruptedException {\n    // Start UserProfileService\n    ServiceManager userProfileServiceManager =\n      appManager.getServiceManager(UserProfileServiceHandler.SERVICE_NAME).start();\n\n    // Wait for service startup\n    userProfileServiceManager.waitForStatus(true);\n    return userProfileServiceManager;\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    // Deploy the Application\n    ApplicationManager appManager = deployApplication(SparkKMeansApp.class);\n    // Start the Flow\n    FlowManager flowManager = appManager.getFlowManager(\"PointsFlow\");\n    flowManager.start();\n    // Send a few points to the stream\n    StreamManager streamManager = getStreamManager(\"pointsStream\");\n    streamManager.send(\"10.6 519.2 110.3\");\n    streamManager.send(\"10.6 518.1 110.1\");\n    streamManager.send(\"10.6 519.6 109.9\");\n    streamManager.send(\"10.6 517.9 108.9\");\n    streamManager.send(\"10.7 518 109.2\");\n\n    //  Wait for the events to be processed, or at most 5 seconds\n    RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"SparkKMeans\", \"PointsFlow\", \"reader\");\n    metrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n    // Start a Spark Program\n    SparkManager sparkManager = appManager.getSparkManager(\"SparkKMeansProgram\");\n    sparkManager.start();\n    sparkManager.waitForFinish(60, TimeUnit.SECONDS);\n\n    flowManager.stop();\n\n    // Start CentersService\n    ServiceManager serviceManager = appManager.getServiceManager(SparkKMeansApp.CentersService.SERVICE_NAME);\n    serviceManager.start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    // Request data and verify it\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"centers/1\"));\n    String[] coordinates = response.split(\",\");\n    Assert.assertTrue(coordinates.length == 3);\n    for (String coordinate : coordinates) {\n      double value = Double.parseDouble(coordinate);\n      Assert.assertTrue(value > 0);\n    }\n\n    // Request data by incorrect index and verify response\n    URL url = new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"centers/10\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    try {\n      Assert.assertEquals(HttpURLConnection.HTTP_NO_CONTENT, conn.getResponseCode());\n    } finally {\n      conn.disconnect();\n    }\n  }","id":78051,"modified_method":"@Test\n  public void test() throws Exception {\n    // Deploy the Application\n    ApplicationManager appManager = deployApplication(SparkKMeansApp.class);\n    // Start the Flow\n    FlowManager flowManager = appManager.getFlowManager(\"PointsFlow\").start();\n    // Send a few points to the stream\n    StreamManager streamManager = getStreamManager(\"pointsStream\");\n    streamManager.send(\"10.6 519.2 110.3\");\n    streamManager.send(\"10.6 518.1 110.1\");\n    streamManager.send(\"10.6 519.6 109.9\");\n    streamManager.send(\"10.6 517.9 108.9\");\n    streamManager.send(\"10.7 518 109.2\");\n\n    //  Wait for the events to be processed, or at most 5 seconds\n    RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"SparkKMeans\", \"PointsFlow\", \"reader\");\n    metrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n    // Start a Spark Program\n    SparkManager sparkManager = appManager.getSparkManager(\"SparkKMeansProgram\").start();\n    sparkManager.waitForFinish(60, TimeUnit.SECONDS);\n\n    flowManager.stop();\n\n    // Start CentersService\n    ServiceManager serviceManager = appManager.getServiceManager(SparkKMeansApp.CentersService.SERVICE_NAME).start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    // Request data and verify it\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"centers/1\"));\n    String[] coordinates = response.split(\",\");\n    Assert.assertTrue(coordinates.length == 3);\n    for (String coordinate : coordinates) {\n      double value = Double.parseDouble(coordinate);\n      Assert.assertTrue(value > 0);\n    }\n\n    // Request data by incorrect index and verify response\n    URL url = new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"centers/10\");\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    try {\n      Assert.assertEquals(HttpURLConnection.HTTP_NO_CONTENT, conn.getResponseCode());\n    } finally {\n      conn.disconnect();\n    }\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSparkMetrics() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkMetricsIntegrationApp.class);\n    SparkManager sparkManager = applicationManager.getSparkManager(TestSparkMetricsIntegrationApp.APP_SPARK_NAME);\n    sparkManager.start();\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    Assert.assertTrue(getSparkMetric(TestSparkMetricsIntegrationApp.APP_NAME,\n                                     TestSparkMetricsIntegrationApp.APP_SPARK_NAME, METRICS_KEY) > 0);\n    //TODO: Add test to check user metrics once the support is added: CDAP-765\n  }","id":78052,"modified_method":"@Test\n  public void testSparkMetrics() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkMetricsIntegrationApp.class);\n    SparkManager sparkManager =\n      applicationManager.getSparkManager(TestSparkMetricsIntegrationApp.APP_SPARK_NAME).start();\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    Assert.assertTrue(getSparkMetric(TestSparkMetricsIntegrationApp.APP_NAME,\n                                     TestSparkMetricsIntegrationApp.APP_SPARK_NAME, METRICS_KEY) > 0);\n    //TODO: Add test to check user metrics once the support is added: CDAP-765\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    // Deploy the SparkPageRankApp\n    ApplicationManager appManager = deployApplication(SparkPageRankApp.class);\n\n    // Send a stream events to the Stream\n    StreamManager streamManager = getStreamManager(\"backlinkURLStream\");\n    streamManager.send(URL_PAIR12);\n    streamManager.send(URL_PAIR13);\n    streamManager.send(URL_PAIR21);\n    streamManager.send(URL_PAIR31);\n\n    // Start GoogleTypePR\n    ServiceManager transformServiceManager = appManager.getServiceManager(SparkPageRankApp.GOOGLE_TYPE_PR_SERVICE_NAME);\n    transformServiceManager.start();\n    // Start CentersService\n    ServiceManager serviceManager = appManager.getServiceManager(SparkPageRankApp.RANKS_SERVICE_NAME);\n    serviceManager.start();\n\n    // Wait for GoogleTypePR service to start since the Spark program needs it\n    transformServiceManager.waitForStatus(true);\n\n    // Start the SparkPageRankProgram\n    SparkManager sparkManager = appManager.getSparkManager(\"SparkPageRankProgram\");\n    sparkManager.start();\n    sparkManager.waitForFinish(60, TimeUnit.SECONDS);\n\n    // Wait for ranks service to start\n    serviceManager.waitForStatus(true);\n\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                             \"rank?url=http://example.com/page1\"));\n    Assert.assertEquals(RANK, response);\n  }","id":78053,"modified_method":"@Test\n  public void test() throws Exception {\n    // Deploy the SparkPageRankApp\n    ApplicationManager appManager = deployApplication(SparkPageRankApp.class);\n\n    // Send a stream events to the Stream\n    StreamManager streamManager = getStreamManager(\"backlinkURLStream\");\n    streamManager.send(URL_PAIR12);\n    streamManager.send(URL_PAIR13);\n    streamManager.send(URL_PAIR21);\n    streamManager.send(URL_PAIR31);\n\n    // Start GoogleTypePR\n    ServiceManager transformServiceManager =\n      appManager.getServiceManager(SparkPageRankApp.GOOGLE_TYPE_PR_SERVICE_NAME).start();\n    // Start CentersService\n    ServiceManager serviceManager = appManager.getServiceManager(SparkPageRankApp.RANKS_SERVICE_NAME).start();\n\n    // Wait for GoogleTypePR service to start since the Spark program needs it\n    transformServiceManager.waitForStatus(true);\n\n    // Start the SparkPageRankProgram\n    SparkManager sparkManager = appManager.getSparkManager(\"SparkPageRankProgram\").start();\n    sparkManager.waitForFinish(60, TimeUnit.SECONDS);\n\n    // Wait for ranks service to start\n    serviceManager.waitForStatus(true);\n\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS),\n                                             \"rank?url=http://example.com/page1\"));\n    Assert.assertEquals(RANK, response);\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSparkWithService() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkServiceIntegrationApp.class);\n    startService(applicationManager);\n\n    SparkManager sparkManager = applicationManager.getSparkManager(\n      TestSparkServiceIntegrationApp.SparkServiceProgram.class.getSimpleName());\n    sparkManager.start();\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"result\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 1; i <= 5; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertEquals((i * i), Integer.parseInt(Bytes.toString(results.read(key))));\n    }\n  }","id":78054,"modified_method":"@Test\n  public void testSparkWithService() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkServiceIntegrationApp.class);\n    startService(applicationManager);\n\n    SparkManager sparkManager = applicationManager.getSparkManager(\n      TestSparkServiceIntegrationApp.SparkServiceProgram.class.getSimpleName()).start();\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"result\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 1; i <= 5; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertEquals((i * i), Integer.parseInt(Bytes.toString(results.read(key))));\n    }\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Starts a Service\n   */\n  private void startService(ApplicationManager applicationManager) {\n    ServiceManager serviceManager = applicationManager.getServiceManager(TestSparkServiceIntegrationApp.SERVICE_NAME);\n    try {\n      serviceManager.start();\n      serviceManager.waitForStatus(true);\n    } catch (InterruptedException e) {\n      LOG.error(\"Failed to start {} service\", TestSparkServiceIntegrationApp.SERVICE_NAME, e);\n      throw Throwables.propagate(e);\n    }\n  }","id":78055,"modified_method":"/**\n   * Starts a Service\n   */\n  private void startService(ApplicationManager applicationManager) {\n    ServiceManager serviceManager =\n      applicationManager.getServiceManager(TestSparkServiceIntegrationApp.SERVICE_NAME).start();\n    try {\n      serviceManager.waitForStatus(true);\n    } catch (InterruptedException e) {\n      LOG.error(\"Failed to start {} service\", TestSparkServiceIntegrationApp.SERVICE_NAME, e);\n      throw Throwables.propagate(e);\n    }\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSparkWithStream() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkStreamIntegrationApp.class);\n    StreamManager streamManager = getStreamManager(\"testStream\");\n    for (int i = 0; i < 50; i++) {\n      streamManager.send(String.valueOf(i));\n    }\n\n    SparkManager sparkManager = applicationManager.getSparkManager(\"SparkStreamProgram\");\n    sparkManager.start();\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    // The Spark job simply turns every stream event body into key/value pairs, with key==value.\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"result\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 0; i < 50; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertArrayEquals(key, results.read(key));\n    }\n  }","id":78056,"modified_method":"@Test\n  public void testSparkWithStream() throws Exception {\n    ApplicationManager applicationManager = deployApplication(TestSparkStreamIntegrationApp.class);\n    StreamManager streamManager = getStreamManager(\"testStream\");\n    for (int i = 0; i < 50; i++) {\n      streamManager.send(String.valueOf(i));\n    }\n\n    SparkManager sparkManager = applicationManager.getSparkManager(\"SparkStreamProgram\").start();\n    sparkManager.waitForFinish(120, TimeUnit.SECONDS);\n\n    // The Spark job simply turns every stream event body into key/value pairs, with key==value.\n    DataSetManager<KeyValueTable> datasetManager = applicationManager.getDataSet(\"result\");\n    KeyValueTable results = datasetManager.get();\n    for (int i = 0; i < 50; i++) {\n      byte[] key = String.valueOf(i).getBytes(Charsets.UTF_8);\n      Assert.assertArrayEquals(key, results.read(key));\n    }\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testPartitionedCounting() throws Exception {\n\n    // deploy the application and start the upload service\n    ApplicationManager appManager = deployApplication(SportResults.class);\n    ServiceManager serviceManager = appManager.getServiceManager(\"UploadService\");\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n\n    // upload a few dummy results\n    URL url = serviceManager.getServiceURL();\n    uploadResults(url, \"fantasy\", 2014, FANTASY_2014);\n    uploadResults(url, \"fantasy\", 2015, FANTASY_2015);\n    uploadResults(url, \"critters\", 2014, CRITTERS_2014);\n\n    // start a map/reduce that counts all seasons for the fantasy league\n    MapReduceManager mrManager = appManager.getMapReduceManager(\"ScoreCounter\");\n    mrManager.start(ImmutableMap.of(\"league\", \"fantasy\"));\n    mrManager.waitForFinish(5, TimeUnit.MINUTES); // should be much faster, though\n\n    // validate the output by reading directly from the file set\n    DataSetManager<PartitionedFileSet> dataSetManager = getDataset(\"totals\");\n    PartitionedFileSet totals = dataSetManager.get();\n    Partition partition = totals.getPartition(PartitionKey.builder().addStringField(\"league\", \"fantasy\").build());\n    Assert.assertNotNull(partition);\n    Location location = partition.getLocation();\n\n    // find the part file that has the actual results\n    Assert.assertTrue(location.isDirectory());\n    for (Location file : location.list()) {\n      if (file.getName().startsWith(\"part\")) {\n        location = file;\n      }\n    }\n    BufferedReader reader = new BufferedReader(new InputStreamReader(location.getInputStream()));\n\n    // validate each line\n    Map<String, String[]> expected = ImmutableMap.of(\n      \"My Team\", new String[] { \"My Team\", \"2\", \"0\", \"1\", \"53\", \"65\" },\n      \"Your Team\", new String[] { \"Your Team\", \"1\", \"0\", \"2\", \"63\", \"60\" },\n      \"Other Team\", new String[] { \"Other Team\", \"1\", \"0\", \"1\", \"40\", \"31\" });\n    while (true) {\n      String line = reader.readLine();\n      if (line == null) {\n        break;\n      }\n      String[] fields = line.split(\",\");\n      Assert.assertArrayEquals(expected.get(fields[0]), fields);\n    }\n\n    // verify using SQL\n    // query with SQL\n    Connection connection = getQueryClient();\n    ResultSet results = connection\n      .prepareStatement(\"SELECT wins, ties, losses, scored, conceded \" +\n                          \"FROM dataset_totals WHERE team = 'My Team' AND league = 'fantasy'\")\n      .executeQuery();\n\n    // should return only one row, with correct time fields\n    Assert.assertTrue(results.next());\n    Assert.assertEquals(2, results.getInt(1));\n    Assert.assertEquals(0, results.getInt(2));\n    Assert.assertEquals(1, results.getInt(3));\n    Assert.assertEquals(53, results.getInt(4));\n    Assert.assertEquals(65, results.getInt(5));\n    Assert.assertFalse(results.next());\n  }","id":78057,"modified_method":"@Test\n  public void testPartitionedCounting() throws Exception {\n\n    // deploy the application and start the upload service\n    ApplicationManager appManager = deployApplication(SportResults.class);\n    ServiceManager serviceManager = appManager.getServiceManager(\"UploadService\").start();\n    serviceManager.waitForStatus(true);\n\n    // upload a few dummy results\n    URL url = serviceManager.getServiceURL();\n    uploadResults(url, \"fantasy\", 2014, FANTASY_2014);\n    uploadResults(url, \"fantasy\", 2015, FANTASY_2015);\n    uploadResults(url, \"critters\", 2014, CRITTERS_2014);\n\n    // start a map/reduce that counts all seasons for the fantasy league\n    MapReduceManager mrManager =\n      appManager.getMapReduceManager(\"ScoreCounter\").start(ImmutableMap.of(\"league\", \"fantasy\"));\n    mrManager.waitForFinish(5, TimeUnit.MINUTES); // should be much faster, though\n\n    // validate the output by reading directly from the file set\n    DataSetManager<PartitionedFileSet> dataSetManager = getDataset(\"totals\");\n    PartitionedFileSet totals = dataSetManager.get();\n    Partition partition = totals.getPartition(PartitionKey.builder().addStringField(\"league\", \"fantasy\").build());\n    Assert.assertNotNull(partition);\n    Location location = partition.getLocation();\n\n    // find the part file that has the actual results\n    Assert.assertTrue(location.isDirectory());\n    for (Location file : location.list()) {\n      if (file.getName().startsWith(\"part\")) {\n        location = file;\n      }\n    }\n    BufferedReader reader = new BufferedReader(new InputStreamReader(location.getInputStream()));\n\n    // validate each line\n    Map<String, String[]> expected = ImmutableMap.of(\n      \"My Team\", new String[] { \"My Team\", \"2\", \"0\", \"1\", \"53\", \"65\" },\n      \"Your Team\", new String[] { \"Your Team\", \"1\", \"0\", \"2\", \"63\", \"60\" },\n      \"Other Team\", new String[] { \"Other Team\", \"1\", \"0\", \"1\", \"40\", \"31\" });\n    while (true) {\n      String line = reader.readLine();\n      if (line == null) {\n        break;\n      }\n      String[] fields = line.split(\",\");\n      Assert.assertArrayEquals(expected.get(fields[0]), fields);\n    }\n\n    // verify using SQL\n    // query with SQL\n    Connection connection = getQueryClient();\n    ResultSet results = connection\n      .prepareStatement(\"SELECT wins, ties, losses, scored, conceded \" +\n                          \"FROM dataset_totals WHERE team = 'My Team' AND league = 'fantasy'\")\n      .executeQuery();\n\n    // should return only one row, with correct time fields\n    Assert.assertTrue(results.next());\n    Assert.assertEquals(2, results.getInt(1));\n    Assert.assertEquals(0, results.getInt(2));\n    Assert.assertEquals(1, results.getInt(3));\n    Assert.assertEquals(53, results.getInt(4));\n    Assert.assertEquals(65, results.getInt(5));\n    Assert.assertFalse(results.next());\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testStreamConversion() throws Exception {\n\n    // Deploy the PurchaseApp application\n    ApplicationManager appManager = deployApplication(StreamConversionApp.class);\n\n    // send some data to the events stream\n    StreamManager streamManager = getStreamManager(\"events\");\n    streamManager.send(\"15\");\n    streamManager.send(\"16\");\n    streamManager.send(\"17\");\n\n    // record the current time\n    final long startTime = System.currentTimeMillis();\n\n    // run the mapreduce\n    MapReduceManager mapReduceManager = appManager.getMapReduceManager(\"StreamConversionMapReduce\");\n    mapReduceManager.start(RuntimeArguments.NO_ARGUMENTS);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // verify the single partition in the file set\n    long partitionTime = assertWithRetry(new Callable<Long>() {\n      @Override\n      public Long call() throws Exception {\n        DataSetManager<TimePartitionedFileSet> fileSetManager = getDataset(\"converted\");\n        TimePartitionedFileSet converted = fileSetManager.get();\n        Set<TimePartition> partitions = converted.getPartitionsByTime(startTime, System.currentTimeMillis());\n        Assert.assertEquals(1, partitions.size());\n        return partitions.iterator().next().getTime();\n      }\n    }, 15L, TimeUnit.SECONDS, 100L, TimeUnit.MILLISECONDS);\n\n    // we must round down the start time to the full minute before we compare the partition time\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTimeInMillis(startTime);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    long startMinute = calendar.getTimeInMillis();\n\n    // partition time should be the logical start time of the MapReduce. That is between start and now.\n    Assert.assertTrue(partitionTime >= startMinute);\n    Assert.assertTrue(partitionTime <= System.currentTimeMillis());\n\n    // extract fields from partition time\n    calendar.setTimeInMillis(partitionTime);\n    int year = calendar.get(Calendar.YEAR);\n    int month = calendar.get(Calendar.MONTH) + 1;\n    int day = calendar.get(Calendar.DAY_OF_MONTH);\n    int hour = calendar.get(Calendar.HOUR_OF_DAY);\n    int minute = calendar.get(Calendar.MINUTE);\n\n    // query with SQL\n    Connection connection = getQueryClient();\n    ResultSet results = connection.prepareStatement(\"SELECT year, month, day, hour, minute \" +\n                                                      \"FROM dataset_converted \" +\n                                                      \"WHERE body = '17'\").executeQuery();\n\n    // should return only one row, with correct time fields\n    Assert.assertTrue(results.next());\n    Assert.assertEquals(year, results.getInt(1));\n    Assert.assertEquals(month, results.getInt(2));\n    Assert.assertEquals(day, results.getInt(3));\n    Assert.assertEquals(hour, results.getInt(4));\n    Assert.assertEquals(minute, results.getInt(5));\n    Assert.assertFalse(results.next());\n  }","id":78058,"modified_method":"@Test\n  public void testStreamConversion() throws Exception {\n\n    // Deploy the PurchaseApp application\n    ApplicationManager appManager = deployApplication(StreamConversionApp.class);\n\n    // send some data to the events stream\n    StreamManager streamManager = getStreamManager(\"events\");\n    streamManager.send(\"15\");\n    streamManager.send(\"16\");\n    streamManager.send(\"17\");\n\n    // record the current time\n    final long startTime = System.currentTimeMillis();\n\n    // run the mapreduce\n    MapReduceManager mapReduceManager =\n      appManager.getMapReduceManager(\"StreamConversionMapReduce\").start(RuntimeArguments.NO_ARGUMENTS);\n    mapReduceManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // verify the single partition in the file set\n    long partitionTime = assertWithRetry(new Callable<Long>() {\n      @Override\n      public Long call() throws Exception {\n        DataSetManager<TimePartitionedFileSet> fileSetManager = getDataset(\"converted\");\n        TimePartitionedFileSet converted = fileSetManager.get();\n        Set<TimePartition> partitions = converted.getPartitionsByTime(startTime, System.currentTimeMillis());\n        Assert.assertEquals(1, partitions.size());\n        return partitions.iterator().next().getTime();\n      }\n    }, 15L, TimeUnit.SECONDS, 100L, TimeUnit.MILLISECONDS);\n\n    // we must round down the start time to the full minute before we compare the partition time\n    Calendar calendar = Calendar.getInstance();\n    calendar.setTimeInMillis(startTime);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MILLISECOND, 0);\n    long startMinute = calendar.getTimeInMillis();\n\n    // partition time should be the logical start time of the MapReduce. That is between start and now.\n    Assert.assertTrue(partitionTime >= startMinute);\n    Assert.assertTrue(partitionTime <= System.currentTimeMillis());\n\n    // extract fields from partition time\n    calendar.setTimeInMillis(partitionTime);\n    int year = calendar.get(Calendar.YEAR);\n    int month = calendar.get(Calendar.MONTH) + 1;\n    int day = calendar.get(Calendar.DAY_OF_MONTH);\n    int hour = calendar.get(Calendar.HOUR_OF_DAY);\n    int minute = calendar.get(Calendar.MINUTE);\n\n    // query with SQL\n    Connection connection = getQueryClient();\n    ResultSet results = connection.prepareStatement(\"SELECT year, month, day, hour, minute \" +\n                                                      \"FROM dataset_converted \" +\n                                                      \"WHERE body = '17'\").executeQuery();\n\n    // should return only one row, with correct time fields\n    Assert.assertTrue(results.next());\n    Assert.assertEquals(year, results.getInt(1));\n    Assert.assertEquals(month, results.getInt(2));\n    Assert.assertEquals(day, results.getInt(3));\n    Assert.assertEquals(hour, results.getInt(4));\n    Assert.assertEquals(minute, results.getInt(5));\n    Assert.assertFalse(results.next());\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testApp() throws Exception {\n    // Deploy the application\n    ApplicationManager appManager = deployApplication(AppWithCube.class);\n\n    ServiceManager serviceManager = appManager.getServiceManager(AppWithCube.SERVICE_NAME);\n    try {\n      serviceManager.start();\n      serviceManager.waitForStatus(true);\n      URL url = serviceManager.getServiceURL();\n\n      long tsInSec = System.currentTimeMillis() / 1000;\n\n      // round to a minute for testing minute resolution\n      tsInSec = (tsInSec / 60) * 60;\n\n      // add couple facts\n      add(url, ImmutableList.of(new CubeFact(tsInSec)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1)));\n\n      add(url, ImmutableList.of(new CubeFact(tsInSec)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1),\n                                new CubeFact(tsInSec + 1)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"back\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1),\n                                new CubeFact(tsInSec + 2)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1)));\n\n      // search for tags\n      Collection<DimensionValue> tags =\n        searchDimensionValue(url, new CubeExploreQuery(tsInSec - 60, tsInSec + 60, 1, 100,\n                                                       new ArrayList<DimensionValue>()));\n      Assert.assertEquals(1, tags.size());\n      DimensionValue tv = tags.iterator().next();\n      Assert.assertEquals(\"user\", tv.getName());\n      Assert.assertEquals(\"alex\", tv.getValue());\n\n      tags = searchDimensionValue(url,\n                                  CubeExploreQuery.builder()\n                                    .from()\n                                      .resolution(1, TimeUnit.SECONDS)\n                                    .where()\n                                      .dimension(\"user\", \"alex\")\n                                      .timeRange(tsInSec - 60, tsInSec + 60)\n                                    .limit(100)\n                                    .build());\n      Assert.assertEquals(2, tags.size());\n      Iterator<DimensionValue> iterator = tags.iterator();\n      tv = iterator.next();\n      Assert.assertEquals(\"action\", tv.getName());\n      Assert.assertEquals(\"back\", tv.getValue());\n      tv = iterator.next();\n      Assert.assertEquals(\"action\", tv.getName());\n      Assert.assertEquals(\"click\", tv.getValue());\n\n      // search for measures\n      Collection<String> measures =\n        searchMeasure(url, new CubeExploreQuery(tsInSec - 60, tsInSec + 60, 1, 100,\n                                                ImmutableList.of(new DimensionValue(\"user\", \"alex\"))));\n      Assert.assertEquals(1, measures.size());\n      String measure = measures.iterator().next();\n      Assert.assertEquals(\"count\", measure);\n\n      // query for data\n\n      // 1-sec resolution\n      Collection<TimeSeries> data =\n        query(url,\n              CubeQuery.builder()\n                .select()\n                  .measurement(\"count\", AggregationFunction.SUM)\n                .from(null)\n                  .resolution(1, TimeUnit.SECONDS)\n                .where()\n                  .dimension(\"action\", \"click\")\n                  .timeRange(tsInSec - 60, tsInSec + 60)\n                .limit(100)\n                .build());\n      Assert.assertEquals(1, data.size());\n      TimeSeries series = data.iterator().next();\n      List<TimeValue> timeValues = series.getTimeValues();\n      Assert.assertEquals(2, timeValues.size());\n      TimeValue timeValue = timeValues.get(0);\n      Assert.assertEquals(tsInSec, timeValue.getTimestamp());\n      Assert.assertEquals(2, timeValue.getValue());\n      timeValue = timeValues.get(1);\n      Assert.assertEquals(tsInSec + 2, timeValue.getTimestamp());\n      Assert.assertEquals(1, timeValue.getValue());\n\n      // 60-sec resolution\n      data = query(url, new CubeQuery(null, tsInSec - 60, tsInSec + 60, 60, 100,\n                                      ImmutableMap.of(\"count\", AggregationFunction.SUM),\n                                      ImmutableMap.of(\"action\", \"click\"), new ArrayList<String>(), null));\n      Assert.assertEquals(1, data.size());\n      series = data.iterator().next();\n      timeValues = series.getTimeValues();\n      Assert.assertEquals(1, timeValues.size());\n      timeValue = timeValues.get(0);\n      Assert.assertEquals(tsInSec, timeValue.getTimestamp());\n      Assert.assertEquals(3, timeValue.getValue());\n\n    } finally {\n      serviceManager.stop();\n      serviceManager.waitForStatus(false);\n    }\n  }","id":78059,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testApp() throws Exception {\n    // Deploy the application\n    ApplicationManager appManager = deployApplication(AppWithCube.class);\n\n    ServiceManager serviceManager = appManager.getServiceManager(AppWithCube.SERVICE_NAME).start();\n    try {\n      serviceManager.waitForStatus(true);\n      URL url = serviceManager.getServiceURL();\n\n      long tsInSec = System.currentTimeMillis() / 1000;\n\n      // round to a minute for testing minute resolution\n      tsInSec = (tsInSec / 60) * 60;\n\n      // add couple facts\n      add(url, ImmutableList.of(new CubeFact(tsInSec)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1)));\n\n      add(url, ImmutableList.of(new CubeFact(tsInSec)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1),\n                                new CubeFact(tsInSec + 1)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"back\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1),\n                                new CubeFact(tsInSec + 2)\n                                  .addDimensionValue(\"user\", \"alex\").addDimensionValue(\"action\", \"click\")\n                                  .addMeasurement(\"count\", MeasureType.COUNTER, 1)));\n\n      // search for tags\n      Collection<DimensionValue> tags =\n        searchDimensionValue(url, new CubeExploreQuery(tsInSec - 60, tsInSec + 60, 1, 100,\n                                                       new ArrayList<DimensionValue>()));\n      Assert.assertEquals(1, tags.size());\n      DimensionValue tv = tags.iterator().next();\n      Assert.assertEquals(\"user\", tv.getName());\n      Assert.assertEquals(\"alex\", tv.getValue());\n\n      tags = searchDimensionValue(url,\n                                  CubeExploreQuery.builder()\n                                    .from()\n                                      .resolution(1, TimeUnit.SECONDS)\n                                    .where()\n                                      .dimension(\"user\", \"alex\")\n                                      .timeRange(tsInSec - 60, tsInSec + 60)\n                                    .limit(100)\n                                    .build());\n      Assert.assertEquals(2, tags.size());\n      Iterator<DimensionValue> iterator = tags.iterator();\n      tv = iterator.next();\n      Assert.assertEquals(\"action\", tv.getName());\n      Assert.assertEquals(\"back\", tv.getValue());\n      tv = iterator.next();\n      Assert.assertEquals(\"action\", tv.getName());\n      Assert.assertEquals(\"click\", tv.getValue());\n\n      // search for measures\n      Collection<String> measures =\n        searchMeasure(url, new CubeExploreQuery(tsInSec - 60, tsInSec + 60, 1, 100,\n                                                ImmutableList.of(new DimensionValue(\"user\", \"alex\"))));\n      Assert.assertEquals(1, measures.size());\n      String measure = measures.iterator().next();\n      Assert.assertEquals(\"count\", measure);\n\n      // query for data\n\n      // 1-sec resolution\n      Collection<TimeSeries> data =\n        query(url,\n              CubeQuery.builder()\n                .select()\n                  .measurement(\"count\", AggregationFunction.SUM)\n                .from(null)\n                  .resolution(1, TimeUnit.SECONDS)\n                .where()\n                  .dimension(\"action\", \"click\")\n                  .timeRange(tsInSec - 60, tsInSec + 60)\n                .limit(100)\n                .build());\n      Assert.assertEquals(1, data.size());\n      TimeSeries series = data.iterator().next();\n      List<TimeValue> timeValues = series.getTimeValues();\n      Assert.assertEquals(2, timeValues.size());\n      TimeValue timeValue = timeValues.get(0);\n      Assert.assertEquals(tsInSec, timeValue.getTimestamp());\n      Assert.assertEquals(2, timeValue.getValue());\n      timeValue = timeValues.get(1);\n      Assert.assertEquals(tsInSec + 2, timeValue.getTimestamp());\n      Assert.assertEquals(1, timeValue.getValue());\n\n      // 60-sec resolution\n      data = query(url, new CubeQuery(null, tsInSec - 60, tsInSec + 60, 60, 100,\n                                      ImmutableMap.of(\"count\", AggregationFunction.SUM),\n                                      ImmutableMap.of(\"action\", \"click\"), new ArrayList<String>(), null));\n      Assert.assertEquals(1, data.size());\n      series = data.iterator().next();\n      timeValues = series.getTimeValues();\n      Assert.assertEquals(1, timeValues.size());\n      timeValue = timeValues.get(0);\n      Assert.assertEquals(tsInSec, timeValue.getTimestamp());\n      Assert.assertEquals(3, timeValue.getValue());\n\n    } finally {\n      serviceManager.stop();\n      serviceManager.waitForStatus(false);\n    }\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testBundleJar() throws Exception {\n    File helloWorldJar = new File(TestBundleJarApp.class.getClassLoader().getResource(\"helloworld.jar\").toURI());\n    ApplicationManager applicationManager = deployApplication(BundleJarApp.class, helloWorldJar);\n    FlowManager flowManager = applicationManager.getFlowManager(\"SimpleFlow\");\n    flowManager.start();\n    StreamManager streamManager = getStreamManager(\"simpleInputStream\");\n    for (int i = 0; i < 5; i++) {\n      streamManager.send(\"test\" + i + \":\" + i);\n    }\n\n    // Check the flowlet metrics\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"BundleJarApp\", \"SimpleFlow\", \"simpleFlowlet\");\n    flowletMetrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, flowletMetrics.getException());\n    flowManager.stop();\n\n    // Query the result\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"SimpleGetInput\");\n    serviceManager.start();\n\n    // Verify the query result\n    String queryResult = callServiceGet(serviceManager.getServiceURL(), \"/get/test1\");\n    String expectedQueryResult = new Gson().toJson(\n      ImmutableMap.of(\"test1\", \"1\" + BundleJarApp.EXPECTED_LOAD_TEST_CLASSES_OUTPUT));\n    Assert.assertEquals(expectedQueryResult, queryResult);\n    serviceManager.stop();\n\n    serviceManager = applicationManager.getServiceManager(\"PrintService\");\n    serviceManager.start();\n\n    String helloWorldClassName = \"hello.HelloWorld\";\n    String result = callServiceGet(serviceManager.getServiceURL(), \"/load/\" + helloWorldClassName);\n    String expected = new Gson().toJson(\n      ImmutableMap.of(\"Class.forName\", helloWorldClassName));\n    Assert.assertEquals(expected, result);\n  }","id":78060,"modified_method":"@Test\n  public void testBundleJar() throws Exception {\n    File helloWorldJar = new File(TestBundleJarApp.class.getClassLoader().getResource(\"helloworld.jar\").toURI());\n    ApplicationManager applicationManager = deployApplication(BundleJarApp.class, helloWorldJar);\n    FlowManager flowManager = applicationManager.getFlowManager(\"SimpleFlow\").start();\n    StreamManager streamManager = getStreamManager(\"simpleInputStream\");\n    for (int i = 0; i < 5; i++) {\n      streamManager.send(\"test\" + i + \":\" + i);\n    }\n\n    // Check the flowlet metrics\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"BundleJarApp\", \"SimpleFlow\", \"simpleFlowlet\");\n    flowletMetrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, flowletMetrics.getException());\n    flowManager.stop();\n\n    // Query the result\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"SimpleGetInput\").start();\n\n    // Verify the query result\n    String queryResult = callServiceGet(serviceManager.getServiceURL(), \"/get/test1\");\n    String expectedQueryResult = new Gson().toJson(\n      ImmutableMap.of(\"test1\", \"1\" + BundleJarApp.EXPECTED_LOAD_TEST_CLASSES_OUTPUT));\n    Assert.assertEquals(expectedQueryResult, queryResult);\n    serviceManager.stop();\n\n    serviceManager = applicationManager.getServiceManager(\"PrintService\").start();\n\n    String helloWorldClassName = \"hello.HelloWorld\";\n    String result = callServiceGet(serviceManager.getServiceURL(), \"/load/\" + helloWorldClassName);\n    String expected = new Gson().toJson(\n      ImmutableMap.of(\"Class.forName\", helloWorldClassName));\n    Assert.assertEquals(expected, result);\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 60000L)\n  public void testFlowletInitAndSetInstances() throws Exception {\n    ApplicationManager appManager = deployApplication(testSpace, DataSetInitApp.class);\n    FlowManager flowManager = appManager.getFlowManager(\"DataSetFlow\");\n    flowManager.start();\n\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(), \"DataSetInitApp\",\n                                                                   \"DataSetFlow\", \"Consumer\");\n\n    flowletMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n\n    String generator = \"Generator\";\n    Assert.assertEquals(1, flowManager.getFlowletInstances(generator));\n    // Now change generator to 3 instances\n    flowManager.setFlowletInstances(generator, 3);\n    Assert.assertEquals(3, flowManager.getFlowletInstances(generator));\n\n    // Now should have 3 processed from the consumer flowlet\n    flowletMetrics.waitForProcessed(3, 10, TimeUnit.SECONDS);\n\n    // Now reset to 1 instances\n    flowManager.setFlowletInstances(generator, 1);\n    Assert.assertEquals(1, flowManager.getFlowletInstances(generator));\n\n    // Shouldn't have new item\n    TimeUnit.SECONDS.sleep(3);\n    Assert.assertEquals(3, flowletMetrics.getProcessed());\n\n    // Now set to 2 instances again. Since there is a new instance, expect one new item emitted\n    flowManager.setFlowletInstances(generator, 2);\n    Assert.assertEquals(2, flowManager.getFlowletInstances(generator));\n    flowletMetrics.waitForProcessed(4, 10, TimeUnit.SECONDS);\n\n    flowManager.stop();\n\n    DataSetManager<Table> dataSetManager = getDataset(testSpace, \"conf\");\n    Table confTable = dataSetManager.get();\n\n    Assert.assertEquals(\"generator\", confTable.get(new Get(\"key\", \"column\")).getString(\"column\"));\n\n    dataSetManager.flush();\n  }","id":78061,"modified_method":"@Test(timeout = 60000L)\n  public void testFlowletInitAndSetInstances() throws Exception {\n    ApplicationManager appManager = deployApplication(testSpace, DataSetInitApp.class);\n    FlowManager flowManager = appManager.getFlowManager(\"DataSetFlow\").start();\n\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(), \"DataSetInitApp\",\n                                                                   \"DataSetFlow\", \"Consumer\");\n\n    flowletMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n\n    String generator = \"Generator\";\n    Assert.assertEquals(1, flowManager.getFlowletInstances(generator));\n    // Now change generator to 3 instances\n    flowManager.setFlowletInstances(generator, 3);\n    Assert.assertEquals(3, flowManager.getFlowletInstances(generator));\n\n    // Now should have 3 processed from the consumer flowlet\n    flowletMetrics.waitForProcessed(3, 10, TimeUnit.SECONDS);\n\n    // Now reset to 1 instances\n    flowManager.setFlowletInstances(generator, 1);\n    Assert.assertEquals(1, flowManager.getFlowletInstances(generator));\n\n    // Shouldn't have new item\n    TimeUnit.SECONDS.sleep(3);\n    Assert.assertEquals(3, flowletMetrics.getProcessed());\n\n    // Now set to 2 instances again. Since there is a new instance, expect one new item emitted\n    flowManager.setFlowletInstances(generator, 2);\n    Assert.assertEquals(2, flowManager.getFlowletInstances(generator));\n    flowletMetrics.waitForProcessed(4, 10, TimeUnit.SECONDS);\n\n    flowManager.stop();\n\n    DataSetManager<Table> dataSetManager = getDataset(testSpace, \"conf\");\n    Table confTable = dataSetManager.get();\n\n    Assert.assertEquals(\"generator\", confTable.get(new Get(\"key\", \"column\")).getString(\"column\"));\n\n    dataSetManager.flush();\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testApp(Class<? extends Application> app, String streamName) throws Exception {\n\n    ApplicationManager applicationManager = deployApplication(app);\n    applicationManager.getFlowManager(\"WordCountFlow\").start();\n\n    // Send some inputs to streams\n    StreamManager streamManager = getStreamManager(streamName);\n    for (int i = 0; i < 100; i++) {\n      streamManager.send(ImmutableMap.of(\"title\", \"title \" + i), \"testing message \" + i);\n    }\n\n    // Check the flowlet metrics\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WordCountApp\",\n                                                                   \"WordCountFlow\",\n                                                                   \"CountByField\");\n    flowletMetrics.waitForProcessed(500, 10, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, flowletMetrics.getException());\n\n    // Query the result\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"WordFrequency\");\n    serviceManager.start();\n    serviceManager.waitForStatus(true, 2, 1);\n\n    // Verify the query result\n    Type resultType = new TypeToken<Map<String, Long>>() { }.getType();\n    Map<String, Long> result = new Gson().fromJson(\n      callServiceGet(serviceManager.getServiceURL(), \"wordfreq/\" + streamName + \":testing\"), resultType);\n    Assert.assertEquals(100L, result.get(streamName + \":testing\").longValue());\n\n    // check the metrics\n    RuntimeMetrics serviceMetrics = RuntimeStats.getServiceMetrics(\"WordCountApp\", \"WordFrequency\");\n    serviceMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, serviceMetrics.getException());\n\n    // Run mapreduce job\n    MapReduceManager mrManager = applicationManager.getMapReduceManager(\"countTotal\");\n    mrManager.start();\n    mrManager.waitForFinish(1800L, TimeUnit.SECONDS);\n\n    long totalCount = Long.valueOf(callServiceGet(serviceManager.getServiceURL(), \"total\"));\n    // every event has 5 tokens\n    Assert.assertEquals(5 * 100L, totalCount);\n\n    // Run mapreduce from stream\n    mrManager = applicationManager.getMapReduceManager(\"countFromStream\");\n    mrManager.start();\n    mrManager.waitForFinish(120L, TimeUnit.SECONDS);\n\n    totalCount = Long.valueOf(callServiceGet(serviceManager.getServiceURL(), \"stream_total\"));\n    // The stream MR only consume the body, not the header.\n    Assert.assertEquals(3 * 100L, totalCount);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> mydatasetManager = getDataset(\"mydataset\");\n    Assert.assertEquals(100L, Long.valueOf(mydatasetManager.get().get(\"title:title\")).longValue());\n  }","id":78062,"modified_method":"private void testApp(Class<? extends Application> app, String streamName) throws Exception {\n\n    ApplicationManager applicationManager = deployApplication(app);\n    applicationManager.getFlowManager(\"WordCountFlow\").start();\n\n    // Send some inputs to streams\n    StreamManager streamManager = getStreamManager(streamName);\n    for (int i = 0; i < 100; i++) {\n      streamManager.send(ImmutableMap.of(\"title\", \"title \" + i), \"testing message \" + i);\n    }\n\n    // Check the flowlet metrics\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"WordCountApp\",\n                                                                   \"WordCountFlow\",\n                                                                   \"CountByField\");\n    flowletMetrics.waitForProcessed(500, 10, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, flowletMetrics.getException());\n\n    // Query the result\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"WordFrequency\").start();\n    serviceManager.waitForStatus(true, 2, 1);\n\n    // Verify the query result\n    Type resultType = new TypeToken<Map<String, Long>>() { }.getType();\n    Map<String, Long> result = new Gson().fromJson(\n      callServiceGet(serviceManager.getServiceURL(), \"wordfreq/\" + streamName + \":testing\"), resultType);\n    Assert.assertEquals(100L, result.get(streamName + \":testing\").longValue());\n\n    // check the metrics\n    RuntimeMetrics serviceMetrics = RuntimeStats.getServiceMetrics(\"WordCountApp\", \"WordFrequency\");\n    serviceMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(0L, serviceMetrics.getException());\n\n    // Run mapreduce job\n    MapReduceManager mrManager = applicationManager.getMapReduceManager(\"countTotal\").start();\n    mrManager.waitForFinish(1800L, TimeUnit.SECONDS);\n\n    long totalCount = Long.valueOf(callServiceGet(serviceManager.getServiceURL(), \"total\"));\n    // every event has 5 tokens\n    Assert.assertEquals(5 * 100L, totalCount);\n\n    // Run mapreduce from stream\n    mrManager = applicationManager.getMapReduceManager(\"countFromStream\").start();\n    mrManager.waitForFinish(120L, TimeUnit.SECONDS);\n\n    totalCount = Long.valueOf(callServiceGet(serviceManager.getServiceURL(), \"stream_total\"));\n    // The stream MR only consume the body, not the header.\n    Assert.assertEquals(3 * 100L, totalCount);\n\n    DataSetManager<MyKeyValueTableDefinition.KeyValueTable> mydatasetManager = getDataset(\"mydataset\");\n    Assert.assertEquals(100L, Long.valueOf(mydatasetManager.get().get(\"title:title\")).longValue());\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testFlowRuntimeArguments() throws Exception {\n    ApplicationManager applicationManager = deployApplication(FilterApp.class);\n    Map<String, String> args = Maps.newHashMap();\n    args.put(\"threshold\", \"10\");\n    applicationManager.getFlowManager(\"FilterFlow\").start(args);\n\n    StreamManager input = getStreamManager(\"input\");\n    input.send(\"1\");\n    input.send(\"11\");\n\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"CountService\");\n    serviceManager.start();\n    serviceManager.waitForStatus(true, 2, 1);\n\n    Assert.assertEquals(\"1\", new Gson().fromJson(\n      callServiceGet(serviceManager.getServiceURL(), \"result\"), String.class));\n  }","id":78063,"modified_method":"@Test\n  public void testFlowRuntimeArguments() throws Exception {\n    ApplicationManager applicationManager = deployApplication(FilterApp.class);\n    Map<String, String> args = Maps.newHashMap();\n    args.put(\"threshold\", \"10\");\n    applicationManager.getFlowManager(\"FilterFlow\").start(args);\n\n    StreamManager input = getStreamManager(\"input\");\n    input.send(\"1\");\n    input.send(\"11\");\n\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"CountService\").start();\n    serviceManager.waitForStatus(true, 2, 1);\n\n    Assert.assertEquals(\"1\", new Gson().fromJson(\n      callServiceGet(serviceManager.getServiceURL(), \"result\"), String.class));\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithWorker() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithWorker.class);\n    LOG.info(\"Deployed.\");\n    WorkerManager manager = applicationManager.getWorkerManager(AppWithWorker.WORKER);\n    manager.start();\n    TimeUnit.MILLISECONDS.sleep(200);\n    manager.stop();\n    applicationManager.stopAll();\n    DataSetManager<KeyValueTable> dataSetManager = getDataset(testSpace, AppWithWorker.DATASET);\n    KeyValueTable table = dataSetManager.get();\n    Assert.assertEquals(AppWithWorker.INITIALIZE, Bytes.toString(table.read(AppWithWorker.INITIALIZE)));\n    Assert.assertEquals(AppWithWorker.RUN, Bytes.toString(table.read(AppWithWorker.RUN)));\n    Assert.assertEquals(AppWithWorker.STOP, Bytes.toString(table.read(AppWithWorker.STOP)));\n  }","id":78064,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithWorker() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithWorker.class);\n    LOG.info(\"Deployed.\");\n    WorkerManager manager = applicationManager.getWorkerManager(AppWithWorker.WORKER).start();\n    TimeUnit.MILLISECONDS.sleep(200);\n    manager.stop();\n    applicationManager.stopAll();\n    DataSetManager<KeyValueTable> dataSetManager = getDataset(testSpace, AppWithWorker.DATASET);\n    KeyValueTable table = dataSetManager.get();\n    Assert.assertEquals(AppWithWorker.INITIALIZE, Bytes.toString(table.read(AppWithWorker.INITIALIZE)));\n    Assert.assertEquals(AppWithWorker.RUN, Bytes.toString(table.read(AppWithWorker.RUN)));\n    Assert.assertEquals(AppWithWorker.STOP, Bytes.toString(table.read(AppWithWorker.STOP)));\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testWorkerInstances() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppUsingGetServiceURL.class);\n    WorkerManager workerManager = applicationManager.getWorkerManager(AppUsingGetServiceURL.PINGING_WORKER);\n    workerManager.start();\n    workerManager.waitForStatus(true);\n\n    int retries = 5;\n\n    // Should be 5 instances when first started.\n    workerInstancesCheck(workerManager, 5, retries);\n\n    // Test increasing instances.\n    workerManager.setInstances(10);\n    workerInstancesCheck(workerManager, 10, retries);\n\n    // Test decreasing instances.\n    workerManager.setInstances(2);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    // Test requesting same number of instances.\n    workerManager.setInstances(2);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    WorkerManager lifecycleWorkerManager = applicationManager.getWorkerManager(AppUsingGetServiceURL.LIFECYCLE_WORKER);\n    lifecycleWorkerManager.start();\n    lifecycleWorkerManager.waitForStatus(true);\n\n    // Set 5 instances for the LifecycleWorker\n    lifecycleWorkerManager.setInstances(5);\n    workerInstancesCheck(lifecycleWorkerManager, 5, retries);\n\n    lifecycleWorkerManager.stop();\n    lifecycleWorkerManager.waitForStatus(false);\n\n    workerManager.stop();\n    workerManager.waitForStatus(false);\n\n    // Should be same instances after being stopped.\n    workerInstancesCheck(lifecycleWorkerManager, 5, retries);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    // Assert the LifecycleWorker dataset writes\n    // 3 workers should have started with 3 total instances. 2 more should later start with 5 total instances.\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init.2\")), 3, 3);\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init.3\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init\")), 2, 5);\n\n    // Test that the worker had 5 instances when stopped, and each knew that there were 5 instances\n    byte[] startRow = Bytes.toBytes(\"stop\");\n    assertWorkerDatasetWrites(applicationManager, startRow, Bytes.stopKeyForPrefix(startRow), 5, 5);\n  }","id":78065,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testWorkerInstances() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppUsingGetServiceURL.class);\n    WorkerManager workerManager = applicationManager.getWorkerManager(AppUsingGetServiceURL.PINGING_WORKER).start();\n    workerManager.waitForStatus(true);\n\n    int retries = 5;\n\n    // Should be 5 instances when first started.\n    workerInstancesCheck(workerManager, 5, retries);\n\n    // Test increasing instances.\n    workerManager.setInstances(10);\n    workerInstancesCheck(workerManager, 10, retries);\n\n    // Test decreasing instances.\n    workerManager.setInstances(2);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    // Test requesting same number of instances.\n    workerManager.setInstances(2);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    WorkerManager lifecycleWorkerManager =\n      applicationManager.getWorkerManager(AppUsingGetServiceURL.LIFECYCLE_WORKER).start();\n    lifecycleWorkerManager.waitForStatus(true);\n\n    // Set 5 instances for the LifecycleWorker\n    lifecycleWorkerManager.setInstances(5);\n    workerInstancesCheck(lifecycleWorkerManager, 5, retries);\n\n    lifecycleWorkerManager.stop();\n    lifecycleWorkerManager.waitForStatus(false);\n\n    workerManager.stop();\n    workerManager.waitForStatus(false);\n\n    // Should be same instances after being stopped.\n    workerInstancesCheck(lifecycleWorkerManager, 5, retries);\n    workerInstancesCheck(workerManager, 2, retries);\n\n    // Assert the LifecycleWorker dataset writes\n    // 3 workers should have started with 3 total instances. 2 more should later start with 5 total instances.\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init.2\")), 3, 3);\n    assertWorkerDatasetWrites(applicationManager, Bytes.toBytes(\"init.3\"),\n                              Bytes.stopKeyForPrefix(Bytes.toBytes(\"init\")), 2, 5);\n\n    // Test that the worker had 5 instances when stopped, and each knew that there were 5 instances\n    byte[] startRow = Bytes.toBytes(\"stop\");\n    assertWorkerDatasetWrites(applicationManager, startRow, Bytes.stopKeyForPrefix(startRow), 5, 5);\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test(timeout = 60000L)\n  public void testFlowletMetricsReset() throws Exception {\n    ApplicationManager appManager = deployApplication(DataSetInitApp.class);\n    FlowManager flowManager = appManager.getFlowManager(\"DataSetFlow\");\n    flowManager.start();\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"DataSetInitApp\", \"DataSetFlow\", \"Consumer\");\n    flowletMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    flowManager.stop();\n    Assert.assertEquals(1, flowletMetrics.getProcessed());\n    RuntimeStats.resetAll();\n    // check the metrics were deleted after reset\n    Assert.assertEquals(0, flowletMetrics.getProcessed());\n  }","id":78066,"modified_method":"@Test(timeout = 60000L)\n  public void testFlowletMetricsReset() throws Exception {\n    ApplicationManager appManager = deployApplication(DataSetInitApp.class);\n    FlowManager flowManager = appManager.getFlowManager(\"DataSetFlow\").start();\n    RuntimeMetrics flowletMetrics = RuntimeStats.getFlowletMetrics(\"DataSetInitApp\", \"DataSetFlow\", \"Consumer\");\n    flowletMetrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    flowManager.stop();\n    Assert.assertEquals(1, flowletMetrics.getProcessed());\n    RuntimeStats.resetAll();\n    // check the metrics were deleted after reset\n    Assert.assertEquals(0, flowletMetrics.getProcessed());\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(XSlowTests.class)\n  @Test\n  public void testByteCodeClassLoader() throws Exception {\n    // This test verify bytecode generated classes ClassLoading\n\n    ApplicationManager appManager = deployApplication(testSpace, ClassLoaderTestApp.class);\n    FlowManager flowManager = appManager.getFlowManager(\"BasicFlow\");\n    flowManager.start();\n\n    // Wait for at least 10 records being generated\n    RuntimeMetrics flowMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(), \"ClassLoaderTestApp\",\n                                                                \"BasicFlow\", \"Sink\");\n    flowMetrics.waitForProcessed(10, 5000, TimeUnit.MILLISECONDS);\n    flowManager.stop();\n\n    ServiceManager serviceManager = appManager.getServiceManager(\"RecordQuery\");\n    serviceManager.start();\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Query record\n    URL url = new URL(serviceURL, \"query?type=public\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    long count = Long.parseLong(response.getResponseBodyAsString());\n    serviceManager.stop();\n\n    // Verify the record count with dataset\n    DataSetManager<KeyValueTable> recordsManager = getDataset(testSpace, \"records\");\n    KeyValueTable records = recordsManager.get();\n    Assert.assertTrue(count == Bytes.toLong(records.read(\"PUBLIC\")));\n  }","id":78067,"modified_method":"@Category(XSlowTests.class)\n  @Test\n  public void testByteCodeClassLoader() throws Exception {\n    // This test verify bytecode generated classes ClassLoading\n\n    ApplicationManager appManager = deployApplication(testSpace, ClassLoaderTestApp.class);\n    FlowManager flowManager = appManager.getFlowManager(\"BasicFlow\").start();\n\n    // Wait for at least 10 records being generated\n    RuntimeMetrics flowMetrics = RuntimeStats.getFlowletMetrics(testSpace.getId(), \"ClassLoaderTestApp\",\n                                                                \"BasicFlow\", \"Sink\");\n    flowMetrics.waitForProcessed(10, 5000, TimeUnit.MILLISECONDS);\n    flowManager.stop();\n\n    ServiceManager serviceManager = appManager.getServiceManager(\"RecordQuery\").start();\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Query record\n    URL url = new URL(serviceURL, \"query?type=public\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    long count = Long.parseLong(response.getResponseBodyAsString());\n    serviceManager.stop();\n\n    // Verify the record count with dataset\n    DataSetManager<KeyValueTable> recordsManager = getDataset(testSpace, \"records\");\n    KeyValueTable records = recordsManager.get();\n    Assert.assertTrue(count == Bytes.toLong(records.read(\"PUBLIC\")));\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(XSlowTests.class)\n  @Test(timeout = 240000)\n  @Ignore\n  // TODO: Investigate why this fails in Bamboo, but not locally\n  public void testMultiInput() throws Exception {\n    ApplicationManager applicationManager = deployApplication(JoinMultiStreamApp.class);\n    applicationManager.getFlowManager(\"JoinMultiFlow\").start();\n\n    StreamManager s1 = getStreamManager(\"s1\");\n    StreamManager s2 = getStreamManager(\"s2\");\n    StreamManager s3 = getStreamManager(\"s3\");\n\n    s1.send(\"testing 1\");\n    s2.send(\"testing 2\");\n    s3.send(\"testing 3\");\n\n    RuntimeMetrics terminalMetrics = RuntimeStats.getFlowletMetrics(\"JoinMulti\",\n                                                                    \"JoinMultiFlow\", \"Terminal\");\n    terminalMetrics.waitForProcessed(3, 60, TimeUnit.SECONDS);\n    TimeUnit.SECONDS.sleep(1);\n\n    ServiceManager queryManager = applicationManager.getServiceManager(\"QueryService\");\n    queryManager.start();\n    queryManager.waitForStatus(true, 2, 1);\n    URL serviceURL = queryManager.getServiceURL();\n    Gson gson = new Gson();\n\n    Assert.assertEquals(\"testing 1\", gson.fromJson(callServiceGet(serviceURL, \"input1\"), String.class));\n    Assert.assertEquals(\"testing 2\", gson.fromJson(callServiceGet(serviceURL, \"input2\"), String.class));\n    Assert.assertEquals(\"testing 3\", gson.fromJson(callServiceGet(serviceURL, \"input3\"), String.class));\n  }","id":78068,"modified_method":"@Category(XSlowTests.class)\n  @Test(timeout = 240000)\n  @Ignore\n  // TODO: Investigate why this fails in Bamboo, but not locally\n  public void testMultiInput() throws Exception {\n    ApplicationManager applicationManager = deployApplication(JoinMultiStreamApp.class);\n    applicationManager.getFlowManager(\"JoinMultiFlow\").start();\n\n    StreamManager s1 = getStreamManager(\"s1\");\n    StreamManager s2 = getStreamManager(\"s2\");\n    StreamManager s3 = getStreamManager(\"s3\");\n\n    s1.send(\"testing 1\");\n    s2.send(\"testing 2\");\n    s3.send(\"testing 3\");\n\n    RuntimeMetrics terminalMetrics = RuntimeStats.getFlowletMetrics(\"JoinMulti\",\n                                                                    \"JoinMultiFlow\", \"Terminal\");\n    terminalMetrics.waitForProcessed(3, 60, TimeUnit.SECONDS);\n    TimeUnit.SECONDS.sleep(1);\n\n    ServiceManager queryManager = applicationManager.getServiceManager(\"QueryService\").start();\n    queryManager.waitForStatus(true, 2, 1);\n    URL serviceURL = queryManager.getServiceURL();\n    Gson gson = new Gson();\n\n    Assert.assertEquals(\"testing 1\", gson.fromJson(callServiceGet(serviceURL, \"input1\"), String.class));\n    Assert.assertEquals(\"testing 2\", gson.fromJson(callServiceGet(serviceURL, \"input2\"), String.class));\n    Assert.assertEquals(\"testing 3\", gson.fromJson(callServiceGet(serviceURL, \"input3\"), String.class));\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testMapperDatasetAccess() throws Exception {\n    addDatasetInstance(\"keyValueTable\", \"table1\").create();\n    addDatasetInstance(\"keyValueTable\", \"table2\").create();\n    DataSetManager<KeyValueTable> tableManager = getDataset(\"table1\");\n    KeyValueTable inputTable = tableManager.get();\n    inputTable.write(\"hello\", \"world\");\n    tableManager.flush();\n\n    ApplicationManager appManager = deployApplication(DatasetWithMRApp.class);\n    Map<String, String> argsForMR = ImmutableMap.of(DatasetWithMRApp.INPUT_KEY, \"table1\",\n                                                    DatasetWithMRApp.OUTPUT_KEY, \"table2\");\n    MapReduceManager mrManager = appManager.getMapReduceManager(DatasetWithMRApp.MAPREDUCE_PROGRAM);\n    mrManager.start(argsForMR);\n    mrManager.waitForFinish(5, TimeUnit.MINUTES);\n    appManager.stopAll();\n\n    DataSetManager<KeyValueTable> outTableManager = getDataset(\"table2\");\n    KeyValueTable outputTable = outTableManager.get();\n    Assert.assertEquals(\"world\", Bytes.toString(outputTable.read(\"hello\")));\n  }","id":78069,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testMapperDatasetAccess() throws Exception {\n    addDatasetInstance(\"keyValueTable\", \"table1\").create();\n    addDatasetInstance(\"keyValueTable\", \"table2\").create();\n    DataSetManager<KeyValueTable> tableManager = getDataset(\"table1\");\n    KeyValueTable inputTable = tableManager.get();\n    inputTable.write(\"hello\", \"world\");\n    tableManager.flush();\n\n    ApplicationManager appManager = deployApplication(DatasetWithMRApp.class);\n    Map<String, String> argsForMR = ImmutableMap.of(DatasetWithMRApp.INPUT_KEY, \"table1\",\n                                                    DatasetWithMRApp.OUTPUT_KEY, \"table2\");\n    MapReduceManager mrManager = appManager.getMapReduceManager(DatasetWithMRApp.MAPREDUCE_PROGRAM).start(argsForMR);\n    mrManager.waitForFinish(5, TimeUnit.MINUTES);\n    appManager.stopAll();\n\n    DataSetManager<KeyValueTable> outTableManager = getDataset(\"table2\");\n    KeyValueTable outputTable = outTableManager.get();\n    Assert.assertEquals(\"world\", Bytes.toString(outputTable.read(\"hello\")));\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testGetServiceURL() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppUsingGetServiceURL.class);\n    ServiceManager centralServiceManager = applicationManager.getServiceManager(AppUsingGetServiceURL.CENTRAL_SERVICE);\n    centralServiceManager.start();\n    centralServiceManager.waitForStatus(true);\n\n    WorkerManager pingingWorker = applicationManager.getWorkerManager(AppUsingGetServiceURL.PINGING_WORKER);\n    pingingWorker.start();\n    pingingWorker.waitForStatus(true);\n\n    // Test service's getServiceURL\n    ServiceManager serviceManager = applicationManager.getServiceManager(AppUsingGetServiceURL.FORWARDING);\n    serviceManager.start();\n    String result = callServiceGet(serviceManager.getServiceURL(), \"ping\");\n    String decodedResult = new Gson().fromJson(result, String.class);\n    // Verify that the service was able to hit the CentralService and retrieve the answer.\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n\n    result = callServiceGet(serviceManager.getServiceURL(), \"read/\" + AppUsingGetServiceURL.DATASET_KEY);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n\n    serviceManager.stop();\n\n    pingingWorker.stop();\n    pingingWorker.waitForStatus(false);\n\n    centralServiceManager.stop();\n    centralServiceManager.waitForStatus(false);\n  }","id":78070,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testGetServiceURL() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppUsingGetServiceURL.class);\n    ServiceManager centralServiceManager =\n      applicationManager.getServiceManager(AppUsingGetServiceURL.CENTRAL_SERVICE).start();\n    centralServiceManager.waitForStatus(true);\n\n    WorkerManager pingingWorker = applicationManager.getWorkerManager(AppUsingGetServiceURL.PINGING_WORKER).start();\n    pingingWorker.waitForStatus(true);\n\n    // Test service's getServiceURL\n    ServiceManager serviceManager = applicationManager.getServiceManager(AppUsingGetServiceURL.FORWARDING).start();\n    String result = callServiceGet(serviceManager.getServiceURL(), \"ping\");\n    String decodedResult = new Gson().fromJson(result, String.class);\n    // Verify that the service was able to hit the CentralService and retrieve the answer.\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n\n    result = callServiceGet(serviceManager.getServiceURL(), \"read/\" + AppUsingGetServiceURL.DATASET_KEY);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppUsingGetServiceURL.ANSWER, decodedResult);\n\n    serviceManager.stop();\n\n    pingingWorker.stop();\n    pingingWorker.waitForStatus(false);\n\n    centralServiceManager.stop();\n    centralServiceManager.waitForStatus(false);\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testAppWithDataset(Class<? extends Application> app, String serviceName) throws Exception {\n    ApplicationManager applicationManager = deployApplication(app);\n    // Query the result\n    ServiceManager serviceManager = applicationManager.getServiceManager(serviceName);\n    serviceManager.start();\n    serviceManager.waitForStatus(true, 2, 1);\n    callServicePut(serviceManager.getServiceURL(), \"key1\", \"value1\");\n    String response = callServiceGet(serviceManager.getServiceURL(), \"key1\");\n    Assert.assertEquals(\"value1\", new Gson().fromJson(response, String.class));\n  }","id":78071,"modified_method":"private void testAppWithDataset(Class<? extends Application> app, String serviceName) throws Exception {\n    ApplicationManager applicationManager = deployApplication(app);\n    // Query the result\n    ServiceManager serviceManager = applicationManager.getServiceManager(serviceName).start();\n    serviceManager.waitForStatus(true, 2, 1);\n    callServicePut(serviceManager.getServiceURL(), \"key1\", \"value1\");\n    String response = callServiceGet(serviceManager.getServiceURL(), \"key1\");\n    Assert.assertEquals(\"value1\", new Gson().fromJson(response, String.class));\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithServices() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.getServiceManager(AppWithServices.SERVICE_NAME);\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Call the ping endpoint\n    URL url = new URL(serviceURL, \"ping2\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    // Call the failure endpoint\n    url = new URL(serviceURL, \"failure\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(500, response.getResponseCode());\n    Assert.assertTrue(response.getResponseBodyAsString().contains(\"Transaction failure\"));\n\n    // Call the verify ClassLoader endpoint\n    url = new URL(serviceURL, \"verifyClassLoader\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    RuntimeMetrics serviceMetrics = RuntimeStats.getServiceMetrics(AppWithServices.APP_NAME,\n                                                                   AppWithServices.SERVICE_NAME);\n    serviceMetrics.waitForinput(3, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(3, serviceMetrics.getInput());\n    Assert.assertEquals(2, serviceMetrics.getProcessed());\n    Assert.assertEquals(1, serviceMetrics.getException());\n\n    // in the AppWithServices the handlerName is same as the serviceName - \"ServerService\" handler\n    RuntimeMetrics handlerMetrics = RuntimeStats.getServiceHandlerMetrics(AppWithServices.APP_NAME,\n                                                                          AppWithServices.SERVICE_NAME,\n                                                                          AppWithServices.SERVICE_NAME);\n    handlerMetrics.waitForinput(3, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(3, handlerMetrics.getInput());\n    Assert.assertEquals(2, handlerMetrics.getProcessed());\n    Assert.assertEquals(1, handlerMetrics.getException());\n\n    // we can verify metrics, by adding getServiceMetrics in RuntimeStats and then disabling the system scope test in\n    // TestMetricsCollectionService\n\n    LOG.info(\"DatasetUpdateService Started\");\n    Map<String, String> args\n      = ImmutableMap.of(AppWithServices.WRITE_VALUE_RUN_KEY, AppWithServices.DATASET_TEST_VALUE,\n                        AppWithServices.WRITE_VALUE_STOP_KEY, AppWithServices.DATASET_TEST_VALUE_STOP);\n    ServiceManager datasetWorkerServiceManager = applicationManager\n      .getServiceManager(AppWithServices.DATASET_WORKER_SERVICE_NAME);\n    datasetWorkerServiceManager.start(args);\n    WorkerManager datasetWorker = applicationManager.getWorkerManager(AppWithServices.DATASET_UPDATE_WORKER);\n    datasetWorker.start(args);\n    datasetWorkerServiceManager.waitForStatus(true);\n\n    ServiceManager noopManager = applicationManager.getServiceManager(\"NoOpService\");\n    noopManager.start();\n    serviceManager.waitForStatus(true, 2, 1);\n\n    String result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY);\n    String decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE, decodedResult);\n\n    handlerMetrics = RuntimeStats.getServiceHandlerMetrics(AppWithServices.APP_NAME,\n                                                                          \"NoOpService\",\n                                                                          \"NoOpHandler\");\n    handlerMetrics.waitForinput(1, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(1, handlerMetrics.getInput());\n    Assert.assertEquals(1, handlerMetrics.getProcessed());\n    Assert.assertEquals(0, handlerMetrics.getException());\n\n    // Test that a service can discover another service\n    String path = String.format(\"discover/%s/%s\",\n                                AppWithServices.APP_NAME, AppWithServices.DATASET_WORKER_SERVICE_NAME);\n    url = new URL(serviceURL, path);\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    datasetWorker.stop();\n    datasetWorkerServiceManager.stop();\n    datasetWorkerServiceManager.waitForStatus(false);\n    LOG.info(\"DatasetUpdateService Stopped\");\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n    LOG.info(\"ServerService Stopped\");\n\n    result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY_STOP);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP, decodedResult);\n\n    result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY_STOP_2);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP_2, decodedResult);\n  }","id":78072,"modified_method":"@Category(SlowTests.class)\n  @Test\n  public void testAppWithServices() throws Exception {\n    ApplicationManager applicationManager = deployApplication(AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.getServiceManager(AppWithServices.SERVICE_NAME).start();\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n    URL serviceURL = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(serviceURL);\n\n    // Call the ping endpoint\n    URL url = new URL(serviceURL, \"ping2\");\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    // Call the failure endpoint\n    url = new URL(serviceURL, \"failure\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(500, response.getResponseCode());\n    Assert.assertTrue(response.getResponseBodyAsString().contains(\"Transaction failure\"));\n\n    // Call the verify ClassLoader endpoint\n    url = new URL(serviceURL, \"verifyClassLoader\");\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    RuntimeMetrics serviceMetrics = RuntimeStats.getServiceMetrics(AppWithServices.APP_NAME,\n                                                                   AppWithServices.SERVICE_NAME);\n    serviceMetrics.waitForinput(3, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(3, serviceMetrics.getInput());\n    Assert.assertEquals(2, serviceMetrics.getProcessed());\n    Assert.assertEquals(1, serviceMetrics.getException());\n\n    // in the AppWithServices the handlerName is same as the serviceName - \"ServerService\" handler\n    RuntimeMetrics handlerMetrics = RuntimeStats.getServiceHandlerMetrics(AppWithServices.APP_NAME,\n                                                                          AppWithServices.SERVICE_NAME,\n                                                                          AppWithServices.SERVICE_NAME);\n    handlerMetrics.waitForinput(3, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(3, handlerMetrics.getInput());\n    Assert.assertEquals(2, handlerMetrics.getProcessed());\n    Assert.assertEquals(1, handlerMetrics.getException());\n\n    // we can verify metrics, by adding getServiceMetrics in RuntimeStats and then disabling the system scope test in\n    // TestMetricsCollectionService\n\n    LOG.info(\"DatasetUpdateService Started\");\n    Map<String, String> args\n      = ImmutableMap.of(AppWithServices.WRITE_VALUE_RUN_KEY, AppWithServices.DATASET_TEST_VALUE,\n                        AppWithServices.WRITE_VALUE_STOP_KEY, AppWithServices.DATASET_TEST_VALUE_STOP);\n    ServiceManager datasetWorkerServiceManager = applicationManager\n      .getServiceManager(AppWithServices.DATASET_WORKER_SERVICE_NAME).start(args);\n    WorkerManager datasetWorker =\n      applicationManager.getWorkerManager(AppWithServices.DATASET_UPDATE_WORKER).start(args);\n    datasetWorkerServiceManager.waitForStatus(true);\n\n    ServiceManager noopManager = applicationManager.getServiceManager(\"NoOpService\").start();\n    serviceManager.waitForStatus(true, 2, 1);\n\n    String result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY);\n    String decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE, decodedResult);\n\n    handlerMetrics = RuntimeStats.getServiceHandlerMetrics(AppWithServices.APP_NAME,\n                                                                          \"NoOpService\",\n                                                                          \"NoOpHandler\");\n    handlerMetrics.waitForinput(1, 5, TimeUnit.SECONDS);\n    Assert.assertEquals(1, handlerMetrics.getInput());\n    Assert.assertEquals(1, handlerMetrics.getProcessed());\n    Assert.assertEquals(0, handlerMetrics.getException());\n\n    // Test that a service can discover another service\n    String path = String.format(\"discover/%s/%s\",\n                                AppWithServices.APP_NAME, AppWithServices.DATASET_WORKER_SERVICE_NAME);\n    url = new URL(serviceURL, path);\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n\n    datasetWorker.stop();\n    datasetWorkerServiceManager.stop();\n    datasetWorkerServiceManager.waitForStatus(false);\n    LOG.info(\"DatasetUpdateService Stopped\");\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n    LOG.info(\"ServerService Stopped\");\n\n    result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY_STOP);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP, decodedResult);\n\n    result = callServiceGet(noopManager.getServiceURL(), \"ping/\" + AppWithServices.DATASET_TEST_KEY_STOP_2);\n    decodedResult = new Gson().fromJson(result, String.class);\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE_STOP_2, decodedResult);\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testTransactionHandlerService() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager = applicationManager.getServiceManager(AppWithServices.TRANSACTIONS_SERVICE_NAME);\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n\n    final URL baseUrl = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(baseUrl);\n\n    // Make a request to write in a separate thread and wait for it to return.\n    ExecutorService executorService = Executors.newSingleThreadExecutor();\n    Future<Integer> requestFuture = executorService.submit(new Callable<Integer>() {\n      @Override\n      public Integer call() throws Exception {\n        try {\n          URL url = new URL(String.format(\"%s/write/%s/%s/%d\",\n                                          baseUrl,\n                                          AppWithServices.DATASET_TEST_KEY,\n                                          AppWithServices.DATASET_TEST_VALUE,\n                                          10000));\n          HttpRequest request = HttpRequest.get(url).build();\n          HttpResponse response = HttpRequests.execute(request);\n          return response.getResponseCode();\n        } catch (Exception e) {\n          LOG.error(\"Request thread got exception.\", e);\n          throw Throwables.propagate(e);\n        }\n      }\n    });\n\n    // The dataset should not be written by the time this request is made, since the transaction to write\n    // has not been committed yet.\n    URL url = new URL(String.format(\"%s/read/%s\", baseUrl, AppWithServices.DATASET_TEST_KEY));\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(204, response.getResponseCode());\n\n    // Wait for the transaction to commit.\n    Integer writeStatusCode = requestFuture.get();\n    Assert.assertEquals(200, writeStatusCode.intValue());\n\n    // Make the same request again. By now the transaction should've completed.\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE,\n                        new Gson().fromJson(response.getResponseBodyAsString(), String.class));\n\n    executorService.shutdown();\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n\n    DataSetManager<KeyValueTable> dsManager = getDataset(testSpace, AppWithServices.TRANSACTIONS_DATASET_NAME);\n    String value = Bytes.toString(dsManager.get().read(AppWithServices.DESTROY_KEY));\n    Assert.assertEquals(AppWithServices.VALUE, value);\n  }","id":78073,"modified_method":"@Test\n  public void testTransactionHandlerService() throws Exception {\n    ApplicationManager applicationManager = deployApplication(testSpace, AppWithServices.class);\n    LOG.info(\"Deployed.\");\n    ServiceManager serviceManager =\n      applicationManager.getServiceManager(AppWithServices.TRANSACTIONS_SERVICE_NAME).start();\n    serviceManager.waitForStatus(true);\n\n    LOG.info(\"Service Started\");\n\n\n    final URL baseUrl = serviceManager.getServiceURL(15, TimeUnit.SECONDS);\n    Assert.assertNotNull(baseUrl);\n\n    // Make a request to write in a separate thread and wait for it to return.\n    ExecutorService executorService = Executors.newSingleThreadExecutor();\n    Future<Integer> requestFuture = executorService.submit(new Callable<Integer>() {\n      @Override\n      public Integer call() throws Exception {\n        try {\n          URL url = new URL(String.format(\"%s/write/%s/%s/%d\",\n                                          baseUrl,\n                                          AppWithServices.DATASET_TEST_KEY,\n                                          AppWithServices.DATASET_TEST_VALUE,\n                                          10000));\n          HttpRequest request = HttpRequest.get(url).build();\n          HttpResponse response = HttpRequests.execute(request);\n          return response.getResponseCode();\n        } catch (Exception e) {\n          LOG.error(\"Request thread got exception.\", e);\n          throw Throwables.propagate(e);\n        }\n      }\n    });\n\n    // The dataset should not be written by the time this request is made, since the transaction to write\n    // has not been committed yet.\n    URL url = new URL(String.format(\"%s/read/%s\", baseUrl, AppWithServices.DATASET_TEST_KEY));\n    HttpRequest request = HttpRequest.get(url).build();\n    HttpResponse response = HttpRequests.execute(request);\n    Assert.assertEquals(204, response.getResponseCode());\n\n    // Wait for the transaction to commit.\n    Integer writeStatusCode = requestFuture.get();\n    Assert.assertEquals(200, writeStatusCode.intValue());\n\n    // Make the same request again. By now the transaction should've completed.\n    request = HttpRequest.get(url).build();\n    response = HttpRequests.execute(request);\n    Assert.assertEquals(200, response.getResponseCode());\n    Assert.assertEquals(AppWithServices.DATASET_TEST_VALUE,\n                        new Gson().fromJson(response.getResponseBodyAsString(), String.class));\n\n    executorService.shutdown();\n    serviceManager.stop();\n    serviceManager.waitForStatus(false);\n\n    DataSetManager<KeyValueTable> dsManager = getDataset(testSpace, AppWithServices.TRANSACTIONS_DATASET_NAME);\n    String value = Bytes.toString(dsManager.get().read(AppWithServices.DESTROY_KEY));\n    Assert.assertEquals(AppWithServices.VALUE, value);\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testUserProfiles() throws Exception {\n\n    // deploy the app\n    ApplicationManager applicationManager = deployApplication(UserProfiles.class);\n\n    // run the service and the flow\n    FlowManager flowManager = applicationManager.getFlowManager(\"ActivityFlow\");\n    flowManager.start();\n\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"UserProfileService\");\n    serviceManager.start();\n    serviceManager.waitForStatus(true);\n    URL serviceURL = serviceManager.getServiceURL();\n\n    // create a user through the service\n    String userJson = new Gson().toJson(ImmutableMap.of(\"id\", \"1234\", \"name\", \"joe\", \"email\", \"joe@bla.ck\"));\n    HttpURLConnection connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(userJson.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_CREATED, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // read the user through the dataset\n    DataSetManager<Table> tableManager = getDataset(\"profiles\");\n    Row row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@bla.ck\", row.getString(\"email\"));\n    Assert.assertNull(row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // update email address through service\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234/email\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(\"joe@black.com\".getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the updated email address\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertNull(row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // send a login event\n    long loginTime = System.currentTimeMillis();\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234/lastLogin\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(Long.toString(loginTime).getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the login time through the dataset\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertEquals(new Long(loginTime), row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // send an event to the stream\n    long activeTime = System.currentTimeMillis();\n    StreamManager streamManager = getStreamManager(\"events\");\n    streamManager.send(new Gson().toJson(new Event(activeTime, \"1234\", \"/some/path\")));\n\n    try {\n      // Wait for the last Flowlet processing 1 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"UserProfiles\", \"ActivityFlow\", \"updater\");\n      metrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // verify the last active time for the user\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertEquals(new Long(loginTime), row.getLong(\"login\"));\n    Assert.assertEquals(new Long(activeTime), row.getLong(\"active\"));\n\n    // delete the user\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234\").openConnection();\n    try {\n      connection.setRequestMethod(\"DELETE\");\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the user is gone\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertTrue(row.isEmpty());\n\n    // stop the service and the flow\n    serviceManager.stop();\n  }","id":78074,"modified_method":"@Test\n  public void testUserProfiles() throws Exception {\n\n    // deploy the app\n    ApplicationManager applicationManager = deployApplication(UserProfiles.class);\n\n    // run the service and the flow\n    FlowManager flowManager = applicationManager.getFlowManager(\"ActivityFlow\").start();\n\n    ServiceManager serviceManager = applicationManager.getServiceManager(\"UserProfileService\").start();\n    serviceManager.waitForStatus(true);\n    URL serviceURL = serviceManager.getServiceURL();\n\n    // create a user through the service\n    String userJson = new Gson().toJson(ImmutableMap.of(\"id\", \"1234\", \"name\", \"joe\", \"email\", \"joe@bla.ck\"));\n    HttpURLConnection connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(userJson.getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_CREATED, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // read the user through the dataset\n    DataSetManager<Table> tableManager = getDataset(\"profiles\");\n    Row row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@bla.ck\", row.getString(\"email\"));\n    Assert.assertNull(row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // update email address through service\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234/email\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(\"joe@black.com\".getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the updated email address\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertNull(row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // send a login event\n    long loginTime = System.currentTimeMillis();\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234/lastLogin\").openConnection();\n    try {\n      connection.setDoOutput(true);\n      connection.setRequestMethod(\"PUT\");\n      connection.getOutputStream().write(Long.toString(loginTime).getBytes(Charsets.UTF_8));\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the login time through the dataset\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertEquals(new Long(loginTime), row.getLong(\"login\"));\n    Assert.assertNull(row.getLong(\"active\"));\n\n    // send an event to the stream\n    long activeTime = System.currentTimeMillis();\n    StreamManager streamManager = getStreamManager(\"events\");\n    streamManager.send(new Gson().toJson(new Event(activeTime, \"1234\", \"/some/path\")));\n\n    try {\n      // Wait for the last Flowlet processing 1 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"UserProfiles\", \"ActivityFlow\", \"updater\");\n      metrics.waitForProcessed(1, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // verify the last active time for the user\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertEquals(\"1234\", row.getString(\"id\"));\n    Assert.assertEquals(\"joe\", row.getString(\"name\"));\n    Assert.assertEquals(\"joe@black.com\", row.getString(\"email\"));\n    Assert.assertEquals(new Long(loginTime), row.getLong(\"login\"));\n    Assert.assertEquals(new Long(activeTime), row.getLong(\"active\"));\n\n    // delete the user\n    connection = (HttpURLConnection) new URL(serviceURL, \"profiles/1234\").openConnection();\n    try {\n      connection.setRequestMethod(\"DELETE\");\n      Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    } finally {\n      connection.disconnect();\n    }\n\n    // verify the user is gone\n    tableManager.flush();\n    row = tableManager.get().get(new Get(\"1234\"));\n    Assert.assertTrue(row.isEmpty());\n\n    // stop the service and the flow\n    serviceManager.stop();\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testWordCount() throws Exception {\n    // Deploy the Application\n    ApplicationManager appManager = deployApplication(WordCount.class);\n\n    // Start the Flow\n    appManager.getFlowManager(\"WordCounter\").start();\n\n    // Send a few events to the stream\n    StreamManager streamManager = getStreamManager(\"wordStream\");\n    streamManager.send(\"hello world\");\n    streamManager.send(\"a wonderful world\");\n    streamManager.send(\"the world says hello\");\n\n    // Wait for the events to be processed, or at most 5 seconds\n    RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"WordCount\", \"WordCounter\", \"associator\");\n    metrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n    // Start RetrieveCounts service\n    ServiceManager serviceManager = appManager.getServiceManager(RetrieveCounts.SERVICE_NAME);\n    serviceManager.start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    // First verify global statistics\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"stats\"));\n    Map<String, String> map = new Gson().fromJson(response, stringMapType);\n    Assert.assertEquals(\"9\", map.get(\"totalWords\"));\n    Assert.assertEquals(\"6\", map.get(\"uniqueWords\"));\n    Assert.assertEquals(((double) 42) / 9, Double.valueOf(map.get(\"averageLength\")), 0.001);\n\n    // Now verify statistics for a specific word\n    response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"count/world\"));\n    Map<String, Object> omap = new Gson().fromJson(response, objectMapType);\n    Assert.assertEquals(\"world\", omap.get(\"word\"));\n    Assert.assertEquals(3.0, omap.get(\"count\"));\n\n    // The associations are a map within the map\n    @SuppressWarnings(\"unchecked\")\n    Map<String, Double> assocs = (Map<String, Double>) omap.get(\"assocs\");\n    Assert.assertEquals(2.0, assocs.get(\"hello\"), 0.000001);\n    Assert.assertTrue(assocs.containsKey(\"hello\"));\n  }","id":78075,"modified_method":"@Test\n  public void testWordCount() throws Exception {\n    // Deploy the Application\n    ApplicationManager appManager = deployApplication(WordCount.class);\n\n    // Start the Flow\n    appManager.getFlowManager(\"WordCounter\").start();\n\n    // Send a few events to the stream\n    StreamManager streamManager = getStreamManager(\"wordStream\");\n    streamManager.send(\"hello world\");\n    streamManager.send(\"a wonderful world\");\n    streamManager.send(\"the world says hello\");\n\n    // Wait for the events to be processed, or at most 5 seconds\n    RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"WordCount\", \"WordCounter\", \"associator\");\n    metrics.waitForProcessed(3, 5, TimeUnit.SECONDS);\n\n    // Start RetrieveCounts service\n    ServiceManager serviceManager = appManager.getServiceManager(RetrieveCounts.SERVICE_NAME).start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    // First verify global statistics\n    String response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"stats\"));\n    Map<String, String> map = new Gson().fromJson(response, stringMapType);\n    Assert.assertEquals(\"9\", map.get(\"totalWords\"));\n    Assert.assertEquals(\"6\", map.get(\"uniqueWords\"));\n    Assert.assertEquals(((double) 42) / 9, Double.valueOf(map.get(\"averageLength\")), 0.001);\n\n    // Now verify statistics for a specific word\n    response = requestService(new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"count/world\"));\n    Map<String, Object> omap = new Gson().fromJson(response, objectMapType);\n    Assert.assertEquals(\"world\", omap.get(\"word\"));\n    Assert.assertEquals(3.0, omap.get(\"count\"));\n\n    // The associations are a map within the map\n    @SuppressWarnings(\"unchecked\")\n    Map<String, Double> assocs = (Map<String, Double>) omap.get(\"assocs\");\n    Assert.assertEquals(2.0, assocs.get(\"hello\"), 0.000001);\n    Assert.assertTrue(assocs.containsKey(\"hello\"));\n  }","commit_id":"0206f6ee37133c41b7f64c80eff45e3482a4c84b","url":"https://github.com/caskdata/cdap"},{"original_method":"private void handleOperationFailedException(OperationFailedException ex)\n        {\n            String errorMessage = \"\";\n\n            switch (ex.getErrorCode())\n            {\n            case OperationFailedException.GENERAL_ERROR:\n            {\n                logger.error(\"Provider could not be registered\"\n                    + \" due to the following general error: \", ex);\n\n                AccountID accountID = protocolProvider.getAccountID();\n                errorMessage =\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.LOGIN_GENERAL_ERROR\",\n                        new String[]\n                           { accountID.getUserID(), accountID.getService() });\n\n                new ErrorDialog(mainFrame,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.ERROR\"), errorMessage, ex)\n                .showDialog();\n            }\n                break;\n            case OperationFailedException.INTERNAL_ERROR:\n            {\n                logger.error(\"Provider could not be registered\"\n                    + \" due to the following internal error: \", ex);\n\n                AccountID accountID = protocolProvider.getAccountID();\n                errorMessage =\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.LOGIN_INTERNAL_ERROR\",\n                        new String[]\n                           { accountID.getUserID(), accountID.getService() });\n\n                new ErrorDialog(mainFrame,\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.ERROR\"), errorMessage, ex).showDialog();\n            }\n                break;\n            case OperationFailedException.NETWORK_FAILURE:\n            {\n                logger.error(\"Provider could not be registered\"\n                    + \" due to a network failure: \" + ex);\n\n                AccountID accountID = protocolProvider.getAccountID();\n                errorMessage = GuiActivator.getResources().getI18NString(\n                    \"service.gui.LOGIN_NETWORK_ERROR\",\n                    new String[]\n                       { accountID.getUserID(), accountID.getService() });\n\n                int result =\n                    new MessageDialog(\n                        null,\n                        GuiActivator.getResources()\n                            .getI18NString(\"service.gui.ERROR\"),\n                        errorMessage,\n                        GuiActivator.getResources()\n                            .getI18NString(\"service.gui.RETRY\"), false)\n                    .showDialog();\n\n                if (result == MessageDialog.OK_RETURN_CODE)\n                {\n                    login(protocolProvider);\n                }\n            }\n                break;\n            case OperationFailedException.INVALID_ACCOUNT_PROPERTIES:\n            {\n                logger.error(\"Provider could not be registered\"\n                    + \" due to an invalid account property: \", ex);\n\n                AccountID accountID = protocolProvider.getAccountID();\n                errorMessage =\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.LOGIN_INVALID_PROPERTIES_ERROR\",\n                        new String[]\n                        { accountID.getUserID(), accountID.getService() });\n\n                new ErrorDialog(mainFrame,\n                    GuiActivator.getResources().getI18NString(\"service.gui.ERROR\"),\n                    errorMessage, ex).showDialog();\n            }\n                break;\n            default:\n                logger.error(\"Provider could not be registered.\", ex);\n            }\n        }","id":78076,"modified_method":"private void handleOperationFailedException(OperationFailedException ex)\n        {\n            String errorMessage = \"\";\n\n            switch (ex.getErrorCode())\n            {\n            case OperationFailedException.GENERAL_ERROR:\n            {\n                logger.error(\"Provider could not be registered\"\n                    + \" due to the following general error: \", ex);\n\n                AccountID accountID = protocolProvider.getAccountID();\n                errorMessage =\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.LOGIN_GENERAL_ERROR\",\n                        new String[]\n                           { accountID.getUserID(), accountID.getService() });\n\n                new ErrorDialog(mainFrame,\n                    GuiActivator.getResources()\n                        .getI18NString(\"service.gui.ERROR\"), errorMessage, ex)\n                .showDialog();\n            }\n                break;\n            case OperationFailedException.INTERNAL_ERROR:\n            {\n                logger.error(\"Provider could not be registered\"\n                    + \" due to the following internal error: \", ex);\n\n                AccountID accountID = protocolProvider.getAccountID();\n                errorMessage =\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.LOGIN_INTERNAL_ERROR\",\n                        new String[]\n                           { accountID.getUserID(), accountID.getService() });\n\n                new ErrorDialog(mainFrame,\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.ERROR\"), errorMessage, ex).showDialog();\n            }\n                break;\n            case OperationFailedException.NETWORK_FAILURE:\n            {\n                if (logger.isInfoEnabled())\n                {\n                    logger.info(\"Provider could not be registered\"\n                            + \" due to a network failure: \" + ex);\n                }\n\n                AccountID accountID = protocolProvider.getAccountID();\n                errorMessage = GuiActivator.getResources().getI18NString(\n                    \"service.gui.LOGIN_NETWORK_ERROR\",\n                    new String[]\n                       { accountID.getUserID(), accountID.getService() });\n\n                int result =\n                    new MessageDialog(\n                        null,\n                        GuiActivator.getResources()\n                            .getI18NString(\"service.gui.ERROR\"),\n                        errorMessage,\n                        GuiActivator.getResources()\n                            .getI18NString(\"service.gui.RETRY\"), false)\n                    .showDialog();\n\n                if (result == MessageDialog.OK_RETURN_CODE)\n                {\n                    login(protocolProvider);\n                }\n            }\n                break;\n            case OperationFailedException.INVALID_ACCOUNT_PROPERTIES:\n            {\n                logger.error(\"Provider could not be registered\"\n                    + \" due to an invalid account property: \", ex);\n\n                AccountID accountID = protocolProvider.getAccountID();\n                errorMessage =\n                    GuiActivator.getResources().getI18NString(\n                        \"service.gui.LOGIN_INVALID_PROPERTIES_ERROR\",\n                        new String[]\n                        { accountID.getUserID(), accountID.getService() });\n\n                new ErrorDialog(mainFrame,\n                    GuiActivator.getResources().getI18NString(\"service.gui.ERROR\"),\n                    errorMessage, ex).showDialog();\n            }\n                break;\n            default:\n                logger.error(\"Provider could not be registered.\", ex);\n            }\n        }","commit_id":"9bcac1a4357537b790d99a38fb24745302042661","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Connects and logins to the server\n     * @param authority SecurityAuthority\n     * @param reasonCode the authentication reason code. Indicates the reason of\n     * this authentication.\n     * @throws XMPPException if we cannot connect to the server - network problem\n     * @throws  OperationFailedException if login parameters\n     *          as server port are not correct\n     */\n    private synchronized void connectAndLogin(SecurityAuthority authority,\n                                              int reasonCode)\n        throws XMPPException, OperationFailedException\n    {\n        synchronized(initializationLock)\n        {\n            //verify whether a password has already been stored for this account\n            String password = JabberActivator.\n                getProtocolProviderFactory().loadPassword(getAccountID());\n\n            //decode\n            if (password == null)\n            {\n                //create a default credentials object\n                UserCredentials credentials = new UserCredentials();\n                credentials.setUserName(getAccountID().getUserID());\n\n                //request a password from the user\n                credentials = authority.obtainCredentials(\n                    ProtocolNames.JABBER,\n                    credentials,\n                    reasonCode);\n\n                // in case user has canceled the login window\n                if(credentials == null)\n                {\n                    fireRegistrationStateChanged(\n                        getRegistrationState(),\n                        RegistrationState.UNREGISTERED,\n                        RegistrationStateChangeEvent.REASON_USER_REQUEST, \"\");\n                    return;\n                }\n\n                //extract the password the user passed us.\n                char[] pass = credentials.getPassword();\n\n                // the user didn't provide us a password (canceled the operation)\n                if(pass == null)\n                {\n                    fireRegistrationStateChanged(\n                        getRegistrationState(),\n                        RegistrationState.UNREGISTERED,\n                        RegistrationStateChangeEvent.REASON_USER_REQUEST, \"\");\n                    return;\n                }\n                password = new String(pass);\n\n\n                if (credentials.isPasswordPersistent())\n                {\n                    JabberActivator.getProtocolProviderFactory()\n                        .storePassword(getAccountID(), password);\n                }\n            }\n\n            //init the necessary objects\n            try\n            {\n                //XMPPConnection.DEBUG_ENABLED = true;\n                String userID =\n                    StringUtils.parseName(getAccountID().getUserID());\n                String serviceName =\n                    StringUtils.parseServer(getAccountID().getUserID());\n\n                String serverAddress =\n                    getAccountID().getAccountPropertyString(\n                        ProtocolProviderFactory.SERVER_ADDRESS);\n\n                String serverPort =\n                    getAccountID().getAccountPropertyString(\n                        ProtocolProviderFactory.SERVER_PORT);\n\n                String accountResource =\n                    getAccountID().getAccountPropertyString(\n                        ProtocolProviderFactory.RESOURCE);\n\n                // check to see is there SRV records for this server domain\n                try\n                {\n                    InetSocketAddress srvAddress = NetworkUtils\n                        .getSRVRecord(\"xmpp-client\", \"tcp\", serviceName);\n\n                    if (srvAddress != null)\n                        serverAddress = srvAddress.getHostName();\n\n                }\n                catch (ParseException ex1)\n                {\n                    logger.error(\"Domain not resolved \" + ex1.getMessage());\n                }\n\n                Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);\n\n                try\n                {\n                    ConnectionConfiguration confConn =\n                    new ConnectionConfiguration(\n                            serverAddress,\n                            Integer.parseInt(serverPort),\n                            serviceName\n                    );\n                    confConn.setReconnectionAllowed(false);\n                    connection = new XMPPConnection(confConn);\n\n                    connection.connect();\n                }\n                catch (XMPPException exc)\n                {\n                    logger.error(\"Failed to establish a Jabber connection for \"\n                        + getAccountID().getAccountUniqueID(), exc);\n\n                    throw new OperationFailedException(\n                        \"Failed to establish a Jabber connection for \"\n                        + getAccountID().getAccountUniqueID()\n                        , OperationFailedException.NETWORK_FAILURE\n                        , exc);\n                }\n\n                connection.addConnectionListener(\n                    new JabberConnectionListener());\n\n                fireRegistrationStateChanged(\n                        getRegistrationState()\n                        , RegistrationState.REGISTERING\n                        , RegistrationStateChangeEvent.REASON_NOT_SPECIFIED\n                        , null);\n\n                if(accountResource == null || accountResource.equals(\"\"))\n                    accountResource = \"sip-comm\";\n\n                SASLAuthentication.supportSASLMechanism(\"PLAIN\", 0);\n\n                try\n                {\n                    connection.login(userID, password, accountResource);\n                } catch (XMPPException e1)\n                {\n                    // after updating to new smack lib\n                    // login mechanisum changed\n                    // this is a way to avoid the problem\n                    try\n                    {\n                        // server disconnect us after such un error\n                        // cleanup\n                        try\n                        {\n                            connection.disconnect();\n                        } catch (Exception e)\n                        {}\n                        // and connect again\n                        connection.connect();\n                        // logging in to google need and service name\n                        connection.login(userID + \"@\" + serviceName,\n                                password, accountResource);\n                    } catch (XMPPException e2)\n                    {\n                        // if it happens once again throw the original exception\n                        throw e1;\n                    }\n                }\n\n                if(connection.isAuthenticated())\n                {\n                    this.reconnecting = false;\n\n                    connection.getRoster().\n                        setSubscriptionMode(Roster.SubscriptionMode.manual);\n\n                    fireRegistrationStateChanged(\n                        getRegistrationState(),\n                        RegistrationState.REGISTERED,\n                        RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n                }\n                else\n                {\n                    fireRegistrationStateChanged(\n                        getRegistrationState()\n                        , RegistrationState.UNREGISTERED\n                        , RegistrationStateChangeEvent.REASON_NOT_SPECIFIED\n                        , null);\n                }\n\n            }\n            catch (NumberFormatException ex)\n            {\n                throw new OperationFailedException(\"Wrong port\",\n                    OperationFailedException.INVALID_ACCOUNT_PROPERTIES, ex);\n            }\n        }\n\n        // we setup supported features\n        // List of features that smack already supports:\n        // http://jabber.org/protocol/xhtml-im\n        // http://jabber.org/protocol/muc\n        // http://jabber.org/protocol/commands\n        // http://jabber.org/protocol/chatstates\n        // http://jabber.org/protocol/si/profile/file-transfer\n        // http://jabber.org/protocol/si\n        // http://jabber.org/protocol/bytestreams\n        // http://jabber.org/protocol/ibb\n        if (getRegistrationState() == RegistrationState.REGISTERED)\n        {\n            discoveryManager = ServiceDiscoveryManager.\n                    getInstanceFor(connection);\n\n            ServiceDiscoveryManager.setIdentityName(\"sip-comm\");\n            ServiceDiscoveryManager.setIdentityType(\"pc\");\n            Iterator<String> it = supportedFeatures.iterator();\n\n            // Remove features supported by smack, but not supported in\n            // SIP Communicator.\n            discoveryManager.removeFeature(\n                \"http://jabber.org/protocol/commands\");\n\n            // Add features the SIP Communicator supports in plus of smack.\n            while (it.hasNext())\n            {\n                String feature = it.next();\n\n                if (!discoveryManager.includesFeature(feature))\n                    discoveryManager.addFeature(feature);\n            }\n        }\n\n    }","id":78077,"modified_method":"/**\n     * Connects and logins to the server\n     * @param authority SecurityAuthority\n     * @param reasonCode the authentication reason code. Indicates the reason of\n     * this authentication.\n     * @throws XMPPException if we cannot connect to the server - network problem\n     * @throws  OperationFailedException if login parameters\n     *          as server port are not correct\n     */\n    private synchronized void connectAndLogin(SecurityAuthority authority,\n                                              int reasonCode)\n        throws XMPPException, OperationFailedException\n    {\n        synchronized(initializationLock)\n        {\n            //verify whether a password has already been stored for this account\n            String password = JabberActivator.\n                getProtocolProviderFactory().loadPassword(getAccountID());\n\n            //decode\n            if (password == null)\n            {\n                //create a default credentials object\n                UserCredentials credentials = new UserCredentials();\n                credentials.setUserName(getAccountID().getUserID());\n\n                //request a password from the user\n                credentials = authority.obtainCredentials(\n                    ProtocolNames.JABBER,\n                    credentials,\n                    reasonCode);\n\n                // in case user has canceled the login window\n                if(credentials == null)\n                {\n                    fireRegistrationStateChanged(\n                        getRegistrationState(),\n                        RegistrationState.UNREGISTERED,\n                        RegistrationStateChangeEvent.REASON_USER_REQUEST, \"\");\n                    return;\n                }\n\n                //extract the password the user passed us.\n                char[] pass = credentials.getPassword();\n\n                // the user didn't provide us a password (canceled the operation)\n                if(pass == null)\n                {\n                    fireRegistrationStateChanged(\n                        getRegistrationState(),\n                        RegistrationState.UNREGISTERED,\n                        RegistrationStateChangeEvent.REASON_USER_REQUEST, \"\");\n                    return;\n                }\n                password = new String(pass);\n\n\n                if (credentials.isPasswordPersistent())\n                {\n                    JabberActivator.getProtocolProviderFactory()\n                        .storePassword(getAccountID(), password);\n                }\n            }\n\n            //init the necessary objects\n            try\n            {\n                //XMPPConnection.DEBUG_ENABLED = true;\n                String userID =\n                    StringUtils.parseName(getAccountID().getUserID());\n                String serviceName =\n                    StringUtils.parseServer(getAccountID().getUserID());\n\n                String serverAddress =\n                    getAccountID().getAccountPropertyString(\n                        ProtocolProviderFactory.SERVER_ADDRESS);\n\n                String serverPort =\n                    getAccountID().getAccountPropertyString(\n                        ProtocolProviderFactory.SERVER_PORT);\n\n                String accountResource =\n                    getAccountID().getAccountPropertyString(\n                        ProtocolProviderFactory.RESOURCE);\n\n                // check to see is there SRV records for this server domain\n                try\n                {\n                    InetSocketAddress srvAddress = NetworkUtils\n                        .getSRVRecord(\"xmpp-client\", \"tcp\", serviceName);\n\n                    if (srvAddress != null)\n                        serverAddress = srvAddress.getHostName();\n\n                }\n                catch (ParseException ex1)\n                {\n                    logger.error(\"Domain not resolved \" + ex1.getMessage());\n                }\n\n                Roster.setDefaultSubscriptionMode(Roster.SubscriptionMode.manual);\n\n                try\n                {\n                    ConnectionConfiguration confConn =\n                    new ConnectionConfiguration(\n                            serverAddress,\n                            Integer.parseInt(serverPort),\n                            serviceName\n                    );\n                    confConn.setReconnectionAllowed(false);\n                    connection = new XMPPConnection(confConn);\n\n                    connection.connect();\n                }\n                catch (XMPPException exc)\n                {\n                    if (logger.isInfoEnabled()) \n                    {\n                        logger.info(\"Failed to establish a Jabber connection for \"\n                                + getAccountID().getAccountUniqueID(), exc);\n                    }\n\n                    throw new OperationFailedException(\n                        \"Failed to establish a Jabber connection for \"\n                        + getAccountID().getAccountUniqueID()\n                        , OperationFailedException.NETWORK_FAILURE\n                        , exc);\n                }\n\n                connection.addConnectionListener(\n                    new JabberConnectionListener());\n\n                fireRegistrationStateChanged(\n                        getRegistrationState()\n                        , RegistrationState.REGISTERING\n                        , RegistrationStateChangeEvent.REASON_NOT_SPECIFIED\n                        , null);\n\n                if(accountResource == null || accountResource.equals(\"\"))\n                    accountResource = \"sip-comm\";\n\n                SASLAuthentication.supportSASLMechanism(\"PLAIN\", 0);\n\n                try\n                {\n                    connection.login(userID, password, accountResource);\n                } catch (XMPPException e1)\n                {\n                    // after updating to new smack lib\n                    // login mechanisum changed\n                    // this is a way to avoid the problem\n                    try\n                    {\n                        // server disconnect us after such un error\n                        // cleanup\n                        try\n                        {\n                            connection.disconnect();\n                        } catch (Exception e)\n                        {}\n                        // and connect again\n                        connection.connect();\n                        // logging in to google need and service name\n                        connection.login(userID + \"@\" + serviceName,\n                                password, accountResource);\n                    } catch (XMPPException e2)\n                    {\n                        // if it happens once again throw the original exception\n                        throw e1;\n                    }\n                }\n\n                if(connection.isAuthenticated())\n                {\n                    this.reconnecting = false;\n\n                    connection.getRoster().\n                        setSubscriptionMode(Roster.SubscriptionMode.manual);\n\n                    fireRegistrationStateChanged(\n                        getRegistrationState(),\n                        RegistrationState.REGISTERED,\n                        RegistrationStateChangeEvent.REASON_NOT_SPECIFIED, null);\n                }\n                else\n                {\n                    fireRegistrationStateChanged(\n                        getRegistrationState()\n                        , RegistrationState.UNREGISTERED\n                        , RegistrationStateChangeEvent.REASON_NOT_SPECIFIED\n                        , null);\n                }\n\n            }\n            catch (NumberFormatException ex)\n            {\n                throw new OperationFailedException(\"Wrong port\",\n                    OperationFailedException.INVALID_ACCOUNT_PROPERTIES, ex);\n            }\n        }\n\n        // we setup supported features\n        // List of features that smack already supports:\n        // http://jabber.org/protocol/xhtml-im\n        // http://jabber.org/protocol/muc\n        // http://jabber.org/protocol/commands\n        // http://jabber.org/protocol/chatstates\n        // http://jabber.org/protocol/si/profile/file-transfer\n        // http://jabber.org/protocol/si\n        // http://jabber.org/protocol/bytestreams\n        // http://jabber.org/protocol/ibb\n        if (getRegistrationState() == RegistrationState.REGISTERED)\n        {\n            discoveryManager = ServiceDiscoveryManager.\n                    getInstanceFor(connection);\n\n            ServiceDiscoveryManager.setIdentityName(\"sip-comm\");\n            ServiceDiscoveryManager.setIdentityType(\"pc\");\n            Iterator<String> it = supportedFeatures.iterator();\n\n            // Remove features supported by smack, but not supported in\n            // SIP Communicator.\n            discoveryManager.removeFeature(\n                \"http://jabber.org/protocol/commands\");\n\n            // Add features the SIP Communicator supports in plus of smack.\n            while (it.hasNext())\n            {\n                String feature = it.next();\n\n                if (!discoveryManager.includesFeature(feature))\n                    discoveryManager.addFeature(feature);\n            }\n        }\n\n    }","commit_id":"9bcac1a4357537b790d99a38fb24745302042661","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void validate(PortletPreferences preferences)\n\t\tthrows ValidatorException {\n\n\t\tList<String> badIsbns = new ArrayList<String>();\n\n\t\tString[] isbns = preferences.getValues(\"isbns\", new String[0]);\n\n\t\tfor (String isbn : isbns) {\n\t\t\tAmazonRankings amazonRankings =\n\t\t\t\tAmazonRankingsUtil.getAmazonRankings(isbn);\n\n\t\t\tif (amazonRankings == null) {\n\t\t\t\tbadIsbns.add(isbn);\n\t\t\t\t_log.error(\"Invalid ISBN \" + isbn);\n\t\t\t}\n\t\t}\n\n\t\tif (badIsbns.size() > 0) {\n\t\t\tthrow new ValidatorException(\n\t\t\t\t\"Failed to retrieve ISBNs\", badIsbns);\n\t\t}\n\t}","id":78078,"modified_method":"public void validate(PortletPreferences preferences)\n\t\tthrows ValidatorException {\n\n\t\tList<String> badIsbns = new ArrayList<String>();\n\n\t\tString[] isbns = preferences.getValues(\"isbns\", new String[0]);\n\n\t\tfor (String isbn : isbns) {\n\t\t\tAmazonRankings amazonRankings =\n\t\t\t\tAmazonRankingsUtil.getAmazonRankings(isbn);\n\n\t\t\tif (amazonRankings == null) {\n\t\t\t\tbadIsbns.add(isbn);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Invalid ISBN \" + isbn);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (badIsbns.size() > 0) {\n\t\t\tthrow new ValidatorException(\n\t\t\t\t\"Failed to retrieve ISBNs\", badIsbns);\n\t\t}\n\t}","commit_id":"81f4a49baed56e5e15dabc230fd72a280c37c8d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean hasErrorMessage(Element parentElement) {\n\t\t\n\t\tElement errorElement = parentElement.element(\"Error\");\n\n\t\tif (errorElement != null) {\n\t\t\tElement messageElement = errorElement.element(\"Message\");\n\n\t\t\tif (messageElement != null) {\n\t\t\t\t_log.error(messageElement.getText());\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}","id":78079,"modified_method":"protected boolean hasErrorMessage(Element element) {\n\t\tif (element == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tElement errorElement = element.element(\"Error\");\n\n\t\tif (errorElement == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tElement messageElement = errorElement.element(\"Message\");\n\n\t\tif (messageElement == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\t_log.error(messageElement.getText());\n\n\t\treturn true;\n\t}","commit_id":"81f4a49baed56e5e15dabc230fd72a280c37c8d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected AmazonRankings doConvert(String key) throws Exception {\n\t\tMap<String, String> parameters = new HashMap<String, String>();\n\n\t\tparameters.put(\n\t\t\t\"AWSAccessKeyId\", AmazonRankingsUtil.getAmazonAccessKeyId());\n\t\tparameters.put(\"IdType\", \"ASIN\");\n\t\tparameters.put(\"ItemId\", _isbn);\n\t\tparameters.put(\"Operation\", \"ItemLookup\");\n\t\tparameters.put(\n\t\t\t\"ResponseGroup\", \"Images,ItemAttributes,Offers,SalesRank\");\n\t\tparameters.put(\"Service\", \"AWSECommerceService\");\n\t\tparameters.put(\"Timestamp\", AmazonRankingsUtil.getTimestamp());\n\n\t\tString urlWithSignature =\n\t\t\tAmazonSignedRequestsUtil.generateUrlWithSignature(parameters);\n\n\t\tString xml = HttpUtil.URLtoString(urlWithSignature);\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tif (rootElement == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (rootElement != null) {\n\t\t\tif (hasErrorMessage(rootElement)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tElement itemsElement = rootElement.element(\"Items\");\n\n\t\tif (itemsElement == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tElement requestElement = itemsElement.element(\"Request\");\n\n\t\tif (requestElement != null) {\n\t\t\tElement errorsElement = requestElement.element(\"Errors\");\n\n\t\t\tif (errorsElement != null) {\n\t\t\t\tif (hasErrorMessage(errorsElement)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tElement itemElement = itemsElement.element(\"Item\");\n\n\t\tif (itemElement == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tElement itemAttributesElement = itemElement.element(\"ItemAttributes\");\n\n\t\tif (itemAttributesElement == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString productName = itemAttributesElement.elementText(\"Title\");\n\t\tString catalog = StringPool.BLANK;\n\t\tString[] authors = getAuthors(itemAttributesElement);\n\t\tString releaseDateAsString = itemAttributesElement.elementText(\n\t\t\t\"PublicationDate\");\n\t\tDate releaseDate = getReleaseDate(releaseDateAsString);\n\t\tString manufacturer = itemAttributesElement.elementText(\"Manufacturer\");\n\t\tString smallImageURL = getImageURL(itemElement, \"SmallImage\");\n\t\tString mediumImageURL = getImageURL(itemElement, \"MediumImage\");\n\t\tString largeImageURL = getImageURL(itemElement, \"LargeImage\");\n\t\tdouble listPrice = getPrice(itemAttributesElement.element(\"ListPrice\"));\n\n\t\tdouble ourPrice = 0;\n\n\t\tElement offerListingElement = getOfferListing(itemElement);\n\n\t\tif (offerListingElement != null) {\n\t\t\tourPrice = getPrice(offerListingElement.element(\"Price\"));\n\t\t}\n\n\t\tdouble usedPrice = 0;\n\t\tdouble collectiblePrice = 0;\n\t\tdouble thirdPartyNewPrice = 0;\n\n\t\tElement offerSummaryElement = itemElement.element(\"OfferSummary\");\n\n\t\tif (offerSummaryElement != null) {\n\t\t\tusedPrice = getPrice(\n\t\t\t\tofferSummaryElement.element(\"LowestUsedPrice\"));\n\n\t\t\tcollectiblePrice = getPrice(\n\t\t\t\tofferSummaryElement.element(\"LowestCollectiblePrice\"));\n\n\t\t\tthirdPartyNewPrice = getPrice(\n\t\t\t\tofferSummaryElement.element(\"LowestNewPrice\"));\n\t\t}\n\n\t\tint salesRank = GetterUtil.getInteger(\n\t\t\titemElement.elementText(\"SalesRank\"));\n\t\tString media = StringPool.BLANK;\n\t\tString availability = getAvailability(offerListingElement);\n\n\t\treturn new AmazonRankings(\n\t\t\t_isbn, productName, catalog, authors, releaseDate,\n\t\t\treleaseDateAsString, manufacturer, smallImageURL, mediumImageURL,\n\t\t\tlargeImageURL, listPrice, ourPrice, usedPrice, collectiblePrice,\n\t\t\tthirdPartyNewPrice, salesRank, media, availability);\n\t}","id":78080,"modified_method":"protected AmazonRankings doConvert(String key) throws Exception {\n\t\tMap<String, String> parameters = new HashMap<String, String>();\n\n\t\tparameters.put(\n\t\t\t\"AWSAccessKeyId\", AmazonRankingsUtil.getAmazonAccessKeyId());\n\t\tparameters.put(\"IdType\", \"ASIN\");\n\t\tparameters.put(\"ItemId\", _isbn);\n\t\tparameters.put(\"Operation\", \"ItemLookup\");\n\t\tparameters.put(\n\t\t\t\"ResponseGroup\", \"Images,ItemAttributes,Offers,SalesRank\");\n\t\tparameters.put(\"Service\", \"AWSECommerceService\");\n\t\tparameters.put(\"Timestamp\", AmazonRankingsUtil.getTimestamp());\n\n\t\tString urlWithSignature =\n\t\t\tAmazonSignedRequestsUtil.generateUrlWithSignature(parameters);\n\n\t\tString xml = HttpUtil.URLtoString(urlWithSignature);\n\n\t\tDocument document = SAXReaderUtil.read(xml);\n\n\t\tElement rootElement = document.getRootElement();\n\n\t\tif (rootElement == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (hasErrorMessage(rootElement)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tElement itemsElement = rootElement.element(\"Items\");\n\n\t\tif (itemsElement == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tElement requestElement = itemsElement.element(\"Request\");\n\n\t\tif (requestElement != null) {\n\t\t\tElement errorsElement = requestElement.element(\"Errors\");\n\n\t\t\tif (hasErrorMessage(errorsElement)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tElement itemElement = itemsElement.element(\"Item\");\n\n\t\tif (itemElement == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tElement itemAttributesElement = itemElement.element(\"ItemAttributes\");\n\n\t\tif (itemAttributesElement == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString productName = itemAttributesElement.elementText(\"Title\");\n\t\tString catalog = StringPool.BLANK;\n\t\tString[] authors = getAuthors(itemAttributesElement);\n\t\tString releaseDateAsString = itemAttributesElement.elementText(\n\t\t\t\"PublicationDate\");\n\t\tDate releaseDate = getReleaseDate(releaseDateAsString);\n\t\tString manufacturer = itemAttributesElement.elementText(\"Manufacturer\");\n\t\tString smallImageURL = getImageURL(itemElement, \"SmallImage\");\n\t\tString mediumImageURL = getImageURL(itemElement, \"MediumImage\");\n\t\tString largeImageURL = getImageURL(itemElement, \"LargeImage\");\n\t\tdouble listPrice = getPrice(itemAttributesElement.element(\"ListPrice\"));\n\n\t\tdouble ourPrice = 0;\n\n\t\tElement offerListingElement = getOfferListing(itemElement);\n\n\t\tif (offerListingElement != null) {\n\t\t\tourPrice = getPrice(offerListingElement.element(\"Price\"));\n\t\t}\n\n\t\tdouble usedPrice = 0;\n\t\tdouble collectiblePrice = 0;\n\t\tdouble thirdPartyNewPrice = 0;\n\n\t\tElement offerSummaryElement = itemElement.element(\"OfferSummary\");\n\n\t\tif (offerSummaryElement != null) {\n\t\t\tusedPrice = getPrice(\n\t\t\t\tofferSummaryElement.element(\"LowestUsedPrice\"));\n\n\t\t\tcollectiblePrice = getPrice(\n\t\t\t\tofferSummaryElement.element(\"LowestCollectiblePrice\"));\n\n\t\t\tthirdPartyNewPrice = getPrice(\n\t\t\t\tofferSummaryElement.element(\"LowestNewPrice\"));\n\t\t}\n\n\t\tint salesRank = GetterUtil.getInteger(\n\t\t\titemElement.elementText(\"SalesRank\"));\n\t\tString media = StringPool.BLANK;\n\t\tString availability = getAvailability(offerListingElement);\n\n\t\treturn new AmazonRankings(\n\t\t\t_isbn, productName, catalog, authors, releaseDate,\n\t\t\treleaseDateAsString, manufacturer, smallImageURL, mediumImageURL,\n\t\t\tlargeImageURL, listPrice, ourPrice, usedPrice, collectiblePrice,\n\t\t\tthirdPartyNewPrice, salesRank, media, availability);\n\t}","commit_id":"81f4a49baed56e5e15dabc230fd72a280c37c8d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static String _canonicalizeParameters(\n\t\t\tMap<String, String> parameters)\n\t\tthrows Exception {\n\n\t\tif (parameters.isEmpty()) {\n\t\t\treturn StringPool.EMPTY;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tSet<Map.Entry<String, String>> parametersSet = parameters.entrySet();\n\n\t\tIterator<Map.Entry<String, String>> itr = parametersSet.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tMap.Entry<String, String> parameter = itr.next();\n\n\t\t\tsb.append(_rfc3986Encode(parameter.getKey()));\n\t\t\tsb.append(StringPool.EQUALS);\n\t\t\tsb.append(_rfc3986Encode(parameter.getValue()));\n\n\t\t\tif (itr.hasNext()) {\n\t\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":78081,"modified_method":"private static String _canonicalizeParameters(\n\t\t\tMap<String, String> parameters)\n\t\tthrows Exception {\n\n\t\tif (parameters.isEmpty()) {\n\t\t\treturn StringPool.EMPTY;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler();\n\n\t\tparameters = new TreeMap<String, String>(parameters);\n\n\t\tSet<Map.Entry<String, String>> parametersSet = parameters.entrySet();\n\n\t\tIterator<Map.Entry<String, String>> itr = parametersSet.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tMap.Entry<String, String> parameter = itr.next();\n\n\t\t\tsb.append(_rfc3986Encode(parameter.getKey()));\n\t\t\tsb.append(StringPool.EQUALS);\n\t\t\tsb.append(_rfc3986Encode(parameter.getValue()));\n\n\t\t\tif (itr.hasNext()) {\n\t\t\t\tsb.append(StringPool.AMPERSAND);\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"81f4a49baed56e5e15dabc230fd72a280c37c8d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String generateUrlWithSignature(\n\t\t\tMap<String, String> parameters)\n\t\tthrows Exception {\n\n\t\tSortedMap<String, String> sortedParameters =\n\t\t\tnew TreeMap<String, String>(parameters);\n\n\t\tString canonicalizedParameters = _canonicalizeParameters(sortedParameters);\n\n\t\tString signature = _generateSignature(\n\t\t\t\"GET\\necs.amazonaws.com\\n/onca/xml\\n\" + canonicalizedParameters);\n\n\t\treturn \"http://ecs.amazonaws.com/onca/xml?\" + canonicalizedParameters +\n\t\t\t\"&Signature=\" + signature;\n\t}","id":78082,"modified_method":"public static String generateUrlWithSignature(\n\t\t\tMap<String, String> parameters)\n\t\tthrows Exception {\n\n\t\tString canonicalizedParameters = _canonicalizeParameters(parameters);\n\n\t\tString signature = _generateSignature(\n\t\t\t\"GET\\necs.amazonaws.com\\n/onca/xml\\n\" + canonicalizedParameters);\n\n\t\treturn \"http://ecs.amazonaws.com/onca/xml?\" + canonicalizedParameters +\n\t\t\t\"&Signature=\" + signature;\n\t}","commit_id":"81f4a49baed56e5e15dabc230fd72a280c37c8d6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void installApp(long remoteAppId)\n\t\tthrows PortalException, SystemException {\n\n\t\tApp app = appPersistence.findByRemoteAppId(remoteAppId);\n\n\t\tif (!DLStoreUtil.hasFile(\n\t\t\t\tapp.getCompanyId(), CompanyConstants.SYSTEM,\n\t\t\t\tapp.getFilePath())) {\n\n\t\t\tthrow new NoSuchFileException();\n\t\t}\n\n\t\tString tmpDir =\n\t\t\tSystemProperties.get(SystemProperties.TMP_DIR) + StringPool.SLASH +\n\t\t\t\tTime.getTimestamp();\n\n\t\ttry {\n\t\t\tFile liferayPackageFile = DLStoreUtil.getFile(\n\t\t\t\tapp.getCompanyId(), CompanyConstants.SYSTEM, app.getFilePath());\n\n\t\t\tZipFile zipFile = new ZipFile(liferayPackageFile);\n\n\t\t\tEnumeration<ZipEntry> enu =\n\t\t\t\t(Enumeration<ZipEntry>)zipFile.entries();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tZipEntry zipEntry = enu.nextElement();\n\n\t\t\t\tAutoDeploymentContext autoDeploymentContext =\n\t\t\t\t\tnew AutoDeploymentContext();\n\n\t\t\t\tString fileName = zipEntry.getName();\n\n\t\t\t\tString contextName = getContextName(fileName);\n\n\t\t\t\tautoDeploymentContext.setContext(contextName);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Extracting \" + fileName + \" from app \" +\n\t\t\t\t\t\t\tapp.getAppId());\n\t\t\t\t}\n\n\t\t\t\tInputStream inputStream = zipFile.getInputStream(zipEntry);\n\n\t\t\t\tFile pluginPackageFile = new File(\n\t\t\t\t\ttmpDir + StringPool.SLASH + fileName);\n\n\t\t\t\tFileUtil.write(pluginPackageFile, inputStream);\n\n\t\t\t\tautoDeploymentContext.setFile(pluginPackageFile);\n\n\t\t\t\tDeployManagerUtil.deploy(autoDeploymentContext);\n\n\t\t\t\tmoduleLocalService.addModule(\n\t\t\t\t\tapp.getUserId(), app.getAppId(), contextName);\n\t\t\t}\n\t\t}\n\t\tcatch (ZipException ze) {\n\t\t\t_log.error(\n\t\t\t\t\"Deleting corrupt package from app \" + app.getAppId(), ze);\n\n\t\t\tdeleteApp(app);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.deltree(tmpDir);\n\t\t}\n\t}","id":78083,"modified_method":"public void installApp(long remoteAppId)\n\t\tthrows PortalException, SystemException {\n\n\t\tApp app = appPersistence.findByRemoteAppId(remoteAppId);\n\n\t\tif (!DLStoreUtil.hasFile(\n\t\t\t\tapp.getCompanyId(), CompanyConstants.SYSTEM,\n\t\t\t\tapp.getFilePath())) {\n\n\t\t\tthrow new NoSuchFileException();\n\t\t}\n\n\t\tString tmpDir =\n\t\t\tSystemProperties.get(SystemProperties.TMP_DIR) + StringPool.SLASH +\n\t\t\t\tTime.getTimestamp();\n\n\t\ttry {\n\t\t\tFile liferayPackageFile = DLStoreUtil.getFile(\n\t\t\t\tapp.getCompanyId(), CompanyConstants.SYSTEM, app.getFilePath());\n\n\t\t\tZipFile zipFile = new ZipFile(liferayPackageFile);\n\n\t\t\tEnumeration<ZipEntry> enu =\n\t\t\t\t(Enumeration<ZipEntry>)zipFile.entries();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tZipEntry zipEntry = enu.nextElement();\n\n\t\t\t\tAutoDeploymentContext autoDeploymentContext =\n\t\t\t\t\tnew AutoDeploymentContext();\n\n\t\t\t\tString fileName = zipEntry.getName();\n\n\t\t\t\tString contextName = getContextName(fileName);\n\n\t\t\t\tautoDeploymentContext.setContext(contextName);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\"Extracting \" + fileName + \" from app \" +\n\t\t\t\t\t\t\tapp.getAppId());\n\t\t\t\t}\n\n\t\t\t\tInputStream inputStream = zipFile.getInputStream(zipEntry);\n\n\t\t\t\tFile pluginPackageFile = new File(\n\t\t\t\t\ttmpDir + StringPool.SLASH + fileName);\n\n\t\t\t\tFileUtil.write(pluginPackageFile, inputStream);\n\n\t\t\t\tautoDeploymentContext.setFile(pluginPackageFile);\n\n\t\t\t\tDeployManagerUtil.deploy(autoDeploymentContext);\n\n\t\t\t\tmoduleLocalService.addModule(\n\t\t\t\t\tapp.getUserId(), app.getAppId(), contextName);\n\t\t\t}\n\t\t}\n\t\tcatch (ZipException ze) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Deleting corrupt package from app \" + app.getAppId(), ze);\n\t\t\t}\n\n\t\t\tdeleteApp(app);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t\tfinally {\n\t\t\tFileUtil.deltree(tmpDir);\n\t\t}\n\t}","commit_id":"df5a403f5fb476e45c5f9d82f58f2038fc802729","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t/*if (actionRequest.getRemoteUser() != null) {\n\t\t\tactionResponse.sendRedirect(themeDisplay.getPathMain());\n\n\t\t\treturn;\n\t\t}*/\n\n\t\ttry {\n\t\t\tPortletPreferences preferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(actionRequest);\n\n\t\t\tlogin(themeDisplay, actionRequest, actionResponse, preferences);\n\n\t\t\tboolean doActionAfterLogin = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"doActionAfterLogin\");\n\n\t\t\tif (doActionAfterLogin) {\n\t\t\t\tsetForward(actionRequest, \"portlet.login.login_redirect\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof AuthException) {\n\t\t\t\tThrowable cause = e.getCause();\n\n\t\t\t\tif (cause instanceof PasswordExpiredException ||\n\t\t\t\t\tcause instanceof UserLockoutException) {\n\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, cause.getClass().getName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.error(\"Authentication failed\");\n\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e instanceof CookieNotSupportedException ||\n\t\t\t\t\t e instanceof NoSuchUserException ||\n\t\t\t\t\t e instanceof PasswordExpiredException ||\n\t\t\t\t\t e instanceof UserEmailAddressException ||\n\t\t\t\t\t e instanceof UserIdException ||\n\t\t\t\t\t e instanceof UserLockoutException ||\n\t\t\t\t\t e instanceof UserPasswordException ||\n\t\t\t\t\t e instanceof UserScreenNameException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.error(e, e);\n\n\t\t\t\tPortalUtil.sendError(e, actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t}","id":78084,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t/*if (actionRequest.getRemoteUser() != null) {\n\t\t\tactionResponse.sendRedirect(themeDisplay.getPathMain());\n\n\t\t\treturn;\n\t\t}*/\n\n\t\ttry {\n\t\t\tPortletPreferences preferences =\n\t\t\t\tPortletPreferencesFactoryUtil.getPortletSetup(actionRequest);\n\n\t\t\tlogin(themeDisplay, actionRequest, actionResponse, preferences);\n\n\t\t\tboolean doActionAfterLogin = ParamUtil.getBoolean(\n\t\t\t\tactionRequest, \"doActionAfterLogin\");\n\n\t\t\tif (doActionAfterLogin) {\n\t\t\t\tsetForward(actionRequest, \"portlet.login.login_redirect\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof AuthException) {\n\t\t\t\tThrowable cause = e.getCause();\n\n\t\t\t\tif (cause instanceof PasswordExpiredException ||\n\t\t\t\t\tcause instanceof UserLockoutException) {\n\n\t\t\t\t\tSessionErrors.add(\n\t\t\t\t\t\tactionRequest, cause.getClass().getName());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\"Authentication failed\");\n\t\t\t\t\t}\n\n\t\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (e instanceof CookieNotSupportedException ||\n\t\t\t\t\t e instanceof NoSuchUserException ||\n\t\t\t\t\t e instanceof PasswordExpiredException ||\n\t\t\t\t\t e instanceof UserEmailAddressException ||\n\t\t\t\t\t e instanceof UserIdException ||\n\t\t\t\t\t e instanceof UserLockoutException ||\n\t\t\t\t\t e instanceof UserPasswordException ||\n\t\t\t\t\t e instanceof UserScreenNameException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.error(e, e);\n\n\t\t\t\tPortalUtil.sendError(e, actionRequest, actionResponse);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c09cdd4a11f5d2a2030b438b09e11985bd2e3bfc","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected IRegion getLineRegion(int offset, int length) {\n\t\tIRegion position = null;\n\t\ttry {\n\t\t\tint startLine = xtextDocument.getLineOfOffset(offset);\n\t\t\tint endLine = xtextDocument.getLineOfOffset(offset + length);\n\t\t\tif (startLine < endLine) {\n\t\t\t\tint start = xtextDocument.getLineOffset(startLine);\n\t\t\t\tint end = xtextDocument.getLineOffset(endLine) + xtextDocument.getLineLength(endLine);\n\t\t\t\tposition = new Region(start, end - start);\n\t\t\t}\n\t\t} catch (BadLocationException e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t}\n\t\treturn position;\n\t}","id":78085,"modified_method":"protected IRegion getLineRegion(int offset, int length) {\n\t\tIRegion position = null;\n\t\ttry {\n\t\t\tint startLine = xtextDocument.getLineOfOffset(offset);\n\t\t\tint endLine = xtextDocument.getLineOfOffset(offset + length);\n\t\t\tif (startLine < endLine) {\n\t\t\t\tint start = xtextDocument.getLineOffset(startLine);\n\t\t\t\tint end = xtextDocument.getLineOffset(endLine) + xtextDocument.getLineLength(endLine);\n\t\t\t\tposition = new Region(start, end - start);\n\t\t\t}\n\t\t} catch (BadLocationException e) {\n\t\t\tif (log.isInfoEnabled())\n\t\t\t\tlog.info(e.getMessage(), e);\n\t\t}\n\t\treturn position;\n\t}","commit_id":"21dbbf2d4bd86ef16390cdf5a441dfde45fe08bf","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public void initialize()\n    {\n        super.initialize();\n        try {\n            syzyFileReader = new BufferedReader(new FileReader(pathToSyzygyFile));\n            for(int clear = 0; clear < clrLines; clear++) {\n                syzyFileReader.readLine();\n            }\n        } catch (FileNotFoundException e) {\n            String newErrMsg = \"Syzygy input file \" + pathToSyzygyFile + \" could be incorrect. File not found.\";\n            throw new StingException(newErrMsg,e);\n        } catch (IOException e) {\n            String newErrMsg = \"Syzygy input file error: could not read first line of \"+pathToSyzygyFile;\n            throw new StingException(newErrMsg,e);\n        }\n\n    }","id":78086,"modified_method":"@Override\n    public void initialize()\n    {\n        super.initialize();\n        try {\n            syzyFileReader = new BufferedReader(new FileReader(pathToSyzygyFile));\n            syzyFileReader.readLine();\n        } catch (FileNotFoundException e) {\n            String newErrMsg = \"Syzygy input file \" + pathToSyzygyFile + \" could be incorrect. File not found.\";\n            throw new StingException(newErrMsg,e);\n        } catch (IOException e) {\n            String newErrMsg = \"Syzygy input file error: could not read first line of \"+pathToSyzygyFile;\n            throw new StingException(newErrMsg,e);\n        }\n\n    }","commit_id":"bd1e679bc5a3994c4fe5b6aadb3327fc1e6ecd1f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context)\n    {\n        if ( !super.suppress_printing )\n        {\n            Pair<Double,Byte> powpair = super.boostrapSamplingPowerCalc(context);\n\n            boolean syzyFileIsReady;\n            try {\n                syzyFileIsReady = syzyFileReader.ready();\n            }\n            catch(IOException e) {\n                syzyFileIsReady = false;\n            }\n\n            if(!syzyFileIsReady) {\n                throw new StingException(\"Input file reader was not ready before an attempt to read from it.\");\n            } else if(!outOfLinesInSyzyFile) {\n                Pair<Double,String> syzyPow = getSyzyPowFromFile();\n                out.printf(\"%s: %d %d %f %f (%s)%n\", context.getLocation(), context.getReads().size(),powpair.second,powpair.first,syzyPow.first,syzyPow.second);\n            } else {\n                out.printf(\"%s: %d %d %f%n\", context.getLocation(), context.getReads().size(),powpair.second,powpair.first);\n            }\n        }\n\n        return context.getReads().size();\n    }","id":78087,"modified_method":"@Override\n    public Pair<Integer,Integer> map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context)\n    {\n\n        Pair<Pair<List<SAMRecord>, List<SAMRecord>>,Pair<List<Integer>,List<Integer>>> splitReads = PoolUtils.splitReadsByReadDirection(context.getReads(),context.getOffsets());\n        if ( !super.suppress_printing )\n        {\n            Pair<double[],byte[]> powpair = super.calculatePower(splitReads,false,context);\n\n            boolean syzyFileIsReady;\n            try {\n                syzyFileIsReady = syzyFileReader.ready();\n            }\n            catch(IOException e) {\n                syzyFileIsReady = false;\n            }\n\n            if(!syzyFileIsReady) {\n                throw new StingException(\"Input file reader was not ready before an attempt to read from it.\");\n            } else if(!outOfLinesInSyzyFile) {\n                Pair<Double,String> syzyPow = getSyzyPowFromFile();\n                out.printf(\"%s: %d %d %f %f (%s)%n\", context.getLocation(), context.getReads().size(),powpair.second,powpair.first,syzyPow.first,syzyPow.second);\n            } else {\n                out.printf(\"%s: %d %d %f%n\", context.getLocation(), context.getReads().size(),powpair.second,powpair.first);\n            }\n        }\n\n        return new Pair(splitReads.getFirst().getFirst().size(), splitReads.getFirst().getFirst().size());\n    }","commit_id":"bd1e679bc5a3994c4fe5b6aadb3327fc1e6ecd1f","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Long,Long> reduceInit() {\n        return new Pair(0l,0l);\n    }","id":78088,"modified_method":"public Pair<Long,Long> reduceInit() {\n        if ( ! suppress_printing ) { // print header\n            out.printf(\"%s%n\",createHeaderString());\n        }\n        return new Pair(0l,0l);\n    }","commit_id":"bd1e679bc5a3994c4fe5b6aadb3327fc1e6ecd1f","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Integer map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context)\n    {\n        if ( !suppress_printing )\n        {\n            Pair<Double,Byte> powpair = boostrapSamplingPowerCalc(context);\n            out.printf(\"%s: %d %d %f%n\", context.getLocation(), context.getReads().size(),powpair.second,powpair.first);\n        }\n\n        return context.getReads().size();\n    }","id":78089,"modified_method":"public Pair<Integer,Integer> map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        Pair<Pair<List<SAMRecord>,List<SAMRecord>>,Pair<List<Integer>,List<Integer>>> readsByDirection = PoolUtils.splitReadsByReadDirection(context.getReads(),context.getOffsets());\n        if ( ! suppress_printing) {\n            Pair<double[],byte[]> powers = calculatePower(readsByDirection, useBootstrap, context);\n            out.printf(\"%s: %d %d %d %d %d %d %f %f %f%n\", context.getLocation(), readsByDirection.getFirst().getFirst().size(), readsByDirection.getFirst().getSecond().size(),\n            context.getReads().size(), powers.getSecond()[0], powers.getSecond()[1], powers.getSecond()[2],\n            powers.getFirst()[0], powers.getFirst()[1], powers.getFirst()[2]);\n        }\n        return new Pair(readsByDirection.getFirst().getFirst().size(),readsByDirection.getFirst().getSecond().size());\n    }","commit_id":"8740124cda7ca4cbe3beb4db05296a6daf242769","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Long, Long> reduce(Integer value, Pair<Long, Long> sum)\n    {\n        long left = value.longValue() + sum.getFirst();\n        long right = sum.getSecond() + 1l;\n        return new Pair<Long,Long>(left, right);\n    }","id":78090,"modified_method":"public Pair<Long,Long> reduce(Pair<Integer,Integer> newCvg, Pair<Long,Long> prevCvg) {\n        return new Pair(prevCvg.first + newCvg.first, prevCvg.second + newCvg.second);\n    }","commit_id":"8740124cda7ca4cbe3beb4db05296a6daf242769","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Long, Long> reduceInit() {\n\n        return new Pair<Long,Long>(0l,0l); }","id":78091,"modified_method":"public Pair<Long,Long> reduceInit() {\n        return new Pair(0l,0l);\n    }","commit_id":"8740124cda7ca4cbe3beb4db05296a6daf242769","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Double,Double> qListToSumLogProbabilities(boolean listRepresentsSNPObservations, List<Byte> qList)\n    {\n        double logProbObserveXAndSNPTrue = 0; // note \"error\" for SNP is observing a ref\n        double logProbObserveXAndRefTrue = 0;// and \"error\" for ref is observing a SNP\n        final double denom = 2*((double)num_individuals);\n\n        for (byte qual : qList) {\n            double p_err = QualityUtils.qualToErrorProb(qual);\n            if (listRepresentsSNPObservations) {\n                logProbObserveXAndSNPTrue += Math.log10((1 - p_err) / denom +((denom - 1)*p_err) / denom);\n                logProbObserveXAndRefTrue += Math.log10(p_err);\n            } else {\n                logProbObserveXAndSNPTrue += Math.log10((denom - 1) * (1 - p_err)/denom + p_err/denom);\n                logProbObserveXAndRefTrue+= Math.log10(1 -p_err);\n            }\n        }\n\n        return new Pair<Double,Double>(logProbObserveXAndSNPTrue,logProbObserveXAndRefTrue);\n    }","id":78092,"modified_method":"public static Pair<Double,Double> qListToSumLogProbabilities(boolean listRepresentsSNPObservations, List<Byte> qList, double denom)\n    {\n        double logProbObserveXAndSNPTrue = 0; // note \"error\" for SNP is observing a ref\n        double logProbObserveXAndRefTrue = 0;// and \"error\" for ref is observing a SNP\n\n        for (byte qual : qList) {\n            double p_err = QualityUtils.qualToErrorProb(qual);\n            if (listRepresentsSNPObservations) {\n                logProbObserveXAndSNPTrue += Math.log10((1 - p_err) / denom +((denom - 1)*p_err) / denom);\n                logProbObserveXAndRefTrue += Math.log10(p_err);\n            } else {\n                logProbObserveXAndSNPTrue += Math.log10((denom - 1) * (1 - p_err)/denom + p_err/denom);\n                logProbObserveXAndRefTrue+= Math.log10(1 -p_err);\n            }\n        }\n\n        return new Pair<Double,Double>(logProbObserveXAndSNPTrue,logProbObserveXAndRefTrue);\n    }","commit_id":"8740124cda7ca4cbe3beb4db05296a6daf242769","url":"https://github.com/broadgsa/gatk"},{"original_method":"public Pair<Double,Byte> powerTheoretical(int depth, List<SAMRecord> reads, List<Integer> offsets, double snp_prop)\n    {\n        // get the median Q score for these reads\n\n        byte medQ = ListUtils.getQScoreMedian(reads,offsets);\n        // System.out.println(\"Median Q: \" + medQ); //TODO: remove this line\n        double p_error = QualityUtils.qualToErrorProb(medQ);\n\n        // variable names from here on out come from the mathematics of a log likelihood test\n        // with binomial probabilities, of observing k bases consistent with the same SNP\n        // given that SNP occurs in one of the alleles, versus it does not occur.\n        // Numerator and denominator will each have a term raised to the kth power\n        // and a term raised to the (depth - kth) (or d-kth) power. Thus the names.\n        // Taking a log then brings those powers out as coefficients, where they can be solved for.\n\n\n        double kterm_num = Math.log10(snp_prop * (1 - p_error) + (1 - snp_prop) * (p_error/3));\n        double kterm_denom = Math.log10(p_error/3);\n        double dkterm_num = Math.log10(snp_prop*(p_error/3) + (1 - snp_prop) * (1 - p_error));\n        double dkterm_denom = Math.log10(1 - p_error);\n\n        int kaccept = (int) Math.ceil((threshold-((double)depth)*(dkterm_num-dkterm_denom))/(kterm_num-kterm_denom-dkterm_num+dkterm_denom));\n\n        // we will reject the null hypothesis if we see kaccept or more SNPs, the power is the probability that this occurs\n        // we can optimize this by checking to see which sum is smaller\n\n        double pow = 0;\n\n        if(depth - kaccept < kaccept) {// kaccept > depth/2 - calculate power as P[hits between k and depth]\n            for(int k = kaccept; k < depth; k++) {\n                pow += MathUtils.binomialProbabilityLog(k, depth, snp_prop);\n            }\n\n            return new Pair(pow,medQ);\n        } else { // kaccept < depth/2 - calculate power as 1-P[hits between 0 and k]\n            for(int k = 0; k < kaccept; k++) {\n                pow += MathUtils.binomialProbabilityLog(k,depth,snp_prop);\n            }\n\n            return new Pair(1.0-pow,medQ);\n        }\n    }","id":78093,"modified_method":"public double calculatePowerTheoretical(List<SAMRecord> reads, List<Integer> offsets, byte medQ, double thresh) {\n        double p_error = QualityUtils.qualToErrorProb(medQ);\n        int depth = reads.size();\n        if(depth <= 0) {\n            return 0;\n        }\n        double snpProp = this.getSNPProportion(1);\n\n        // variable names from here on out come from the mathematics of a log likelihood test\n        // with binomial probabilities, of observing k bases consistent with the same SNP\n        // given that SNP occurs in one of the alleles, versus it does not occur.\n        // Numerator and denominator will each have a term raised to the kth power\n        // and a term raised to the (depth - kth) (or d-kth) power. Thus the names.\n        // Taking a log then brings those powers out as coefficients, where they can be solved for.\n\n\n        double kterm_num = Math.log10( snpProp * (1 - p_error) + (1 - snpProp) * (p_error/3) );\n        double kterm_denom = Math.log10( p_error/3 );\n        double dkterm_num = Math.log10( snpProp * (p_error/3) + (1 - snpProp) * (1 - p_error) );\n        double dkterm_denom = Math.log10( 1 - p_error);\n\n        int kaccept = (int) Math.ceil( ( thresh - ( (double) depth ) * ( dkterm_num - dkterm_denom ) )/( kterm_num - kterm_denom- dkterm_num + dkterm_denom ) );\n\n        // we will reject the null hypothesis if we see kaccept or more SNPs, the power is the probability that this occurs\n        // we can optimize this by checking to see which sum is smaller\n\n        double pow = 0;\n\n        if ( depth - kaccept < kaccept ) {// kaccept > depth/2 - calculate power as P[hits between kaccept and depth]\n            return MathUtils.cumBinomialProbLog(kaccept, depth, depth, snpProp);\n        } else { // kaccept < depth/2 - calculate power as 1-P[hits between 0 and kaccept]\n            return 1-MathUtils.cumBinomialProbLog(0,kaccept,depth,snpProp);\n        }\n    }","commit_id":"8740124cda7ca4cbe3beb4db05296a6daf242769","url":"https://github.com/broadgsa/gatk"},{"original_method":"public static byte getQScoreOrderStatistic(List<SAMRecord> reads, List<Integer> offsets, int k) {\n        // version of the order statistic calculator for SAMRecord/Integer lists, where the\n        // list index maps to a q-score only through the offset index\n        // returns the kth-largest q-score.\n\n\n        ArrayList lessThanQReads = new ArrayList();\n        ArrayList equalToQReads = new ArrayList();\n        ArrayList greaterThanQReads = new ArrayList();\n        ArrayList lessThanQOffsets = new ArrayList();\n        ArrayList greaterThanQOffsets = new ArrayList();\n\n        final byte qk = reads.get(k).getBaseQualities()[offsets.get(k)];\n\n        for(int iter = 0; iter < reads.size(); iter ++) {\n            SAMRecord read = reads.get(iter);\n            int offset = offsets.get(iter);\n            byte quality = read.getBaseQualities()[offset];\n\n            if(quality < qk) {\n                lessThanQReads.add(read);\n                lessThanQOffsets.add(offset);\n            } else if(quality > qk) {\n                greaterThanQReads.add(read);\n                greaterThanQOffsets.add(offset);\n            } else {\n                equalToQReads.add(reads.get(iter));\n            }\n        }\n\n        if(lessThanQReads.size() > k)\n            return getQScoreOrderStatistic(lessThanQReads, lessThanQOffsets, k);\n        else if(equalToQReads.size() + lessThanQReads.size() >= k)\n            return qk;\n        else\n            return getQScoreOrderStatistic(greaterThanQReads, greaterThanQOffsets, k - lessThanQReads.size() - equalToQReads.size());\n\n    }","id":78094,"modified_method":"public static byte getQScoreOrderStatistic(List<SAMRecord> reads, List<Integer> offsets, int k) {\n        // version of the order statistic calculator for SAMRecord/Integer lists, where the\n        // list index maps to a q-score only through the offset index\n        // returns the kth-largest q-score.\n\n        if( reads.size() == 0) {\n            return 0;\n        }\n        \n        ArrayList lessThanQReads = new ArrayList();\n        ArrayList equalToQReads = new ArrayList();\n        ArrayList greaterThanQReads = new ArrayList();\n        ArrayList lessThanQOffsets = new ArrayList();\n        ArrayList greaterThanQOffsets = new ArrayList();\n\n        final byte qk = reads.get(k).getBaseQualities()[offsets.get(k)];\n\n        for(int iter = 0; iter < reads.size(); iter ++) {\n            SAMRecord read = reads.get(iter);\n            int offset = offsets.get(iter);\n            byte quality = read.getBaseQualities()[offset];\n\n            if(quality < qk) {\n                lessThanQReads.add(read);\n                lessThanQOffsets.add(offset);\n            } else if(quality > qk) {\n                greaterThanQReads.add(read);\n                greaterThanQOffsets.add(offset);\n            } else {\n                equalToQReads.add(reads.get(iter));\n            }\n        }\n\n        if(lessThanQReads.size() > k)\n            return getQScoreOrderStatistic(lessThanQReads, lessThanQOffsets, k);\n        else if(equalToQReads.size() + lessThanQReads.size() >= k)\n            return qk;\n        else\n            return getQScoreOrderStatistic(greaterThanQReads, greaterThanQOffsets, k - lessThanQReads.size() - equalToQReads.size());\n\n    }","commit_id":"8740124cda7ca4cbe3beb4db05296a6daf242769","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * calculate the rms , given the read pileup\n     *\n     * @param pileup\n     *\n     * @return\n     */\n    private double calculateRMS(ReadBackedPileup pileup) {\n        double rms = 0.0;\n        for (SAMRecord r : pileup.getReads()) {\n            rms += r.getMappingQuality() * r.getMappingQuality();\n        }\n        rms /= pileup.getReads().size();\n        rms = Math.sqrt(rms);\n        return rms;\n    }","id":78095,"modified_method":"/**\n     * calculate the rms , given the read pileup\n     *\n     * @param pileup\n     *\n     * @return\n     */\n    private double calculateRMS(ReadBackedPileup pileup) {\n        List<SAMRecord> reads = pileup.getReads();\n        int[] qualities = new int[reads.size()];\n        for (int i=0; i < reads.size(); i++)\n            qualities[i] = reads.get(i).getMappingQuality();\n        return MathUtils.rms(qualities);\n    }","commit_id":"e3b08f245fb707a41d9627f590a6f361deeeeb63","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void compute(char ref, LocusContext context, rodVariants variant) {\n        List<SAMRecord> reads = context.getReads();\n\n        rms = 0.0;\n        for (int readIndex = 0; readIndex < reads.size(); readIndex++) {\n            int qual = reads.get(readIndex).getMappingQuality();\n            rms += qual * qual;\n        }\n        rms /= reads.size();\n        rms = Math.sqrt(rms);\n    }","id":78096,"modified_method":"public void compute(char ref, LocusContext context, rodVariants variant) {\n        List<SAMRecord> reads = context.getReads();\n        int[] qualities = new int[reads.size()];\n        for (int i=0; i < reads.size(); i++)\n            qualities[i] = reads.get(i).getMappingQuality();\n        rms = MathUtils.rms(qualities);\n        exclude = rms < minQuality;        \n    }","commit_id":"e3b08f245fb707a41d9627f590a6f361deeeeb63","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create IDEA (.ipr) project files.\n     *\n     * @throws MojoExecutionException\n     */\n    private void rewriteProject()\n        throws MojoExecutionException\n    {\n        File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n        try\n        {\n            Reader reader;\n            if ( projectFile.exists() && !overwrite )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            // Set the jdk name if set\n            if ( jdkName != null )\n            {\n                setJdkName( module, jdkName );\n            }\n            else\n            {\n                String javaVersion = System.getProperty( \"java.version\" );\n                String defaultJdkName;\n\n                if ( ideaVersion.startsWith( \"4\" ) )\n                {\n                    defaultJdkName = \"java version &quot;\" + javaVersion + \"&quot;\";\n                }\n                else\n                {\n                    defaultJdkName = javaVersion.substring( 0, 3 );\n                }\n                getLog().info( \"jdkName is not set, using [java version\" + javaVersion + \"] as default.\" );\n                setJdkName( module, defaultJdkName );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            if ( project.getCollectedProjects().size() > 0 )\n            {\n                removeOldElements( modules, \"module\" );\n\n                for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    Xpp3Dom m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( project.getBasedir(),\n                                              project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n    }","id":78097,"modified_method":"/**\n     * Create IDEA (.ipr) project files.\n     *\n     * @throws MojoExecutionException\n     */\n    private void rewriteProject()\n        throws MojoExecutionException\n    {\n        File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n        try\n        {\n            Reader reader;\n            if ( projectFile.exists() && !overwrite )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            // Set the jdk name if set\n            if ( jdkName != null )\n            {\n                setJdkName( module, jdkName );\n            }\n            else\n            {\n                String javaVersion = System.getProperty( \"java.version\" );\n                String defaultJdkName;\n\n                if ( ideaVersion.startsWith( \"4\" ) )\n                {\n                    defaultJdkName = \"java version &quot;\" + javaVersion + \"&quot;\";\n                }\n                else\n                {\n                    defaultJdkName = javaVersion.substring( 0, 3 );\n                }\n                getLog().info( \"jdkName is not set, using [java version\" + javaVersion + \"] as default.\" );\n                setJdkName( module, defaultJdkName );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            if ( project.getCollectedProjects().size() > 0 )\n            {\n                removeOldElements( modules, \"module\" );\n\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String projectPath = new File( project.getBasedir(),\n                                               project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), projectPath ) );\n\n                for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( project.getBasedir(),\n                                              project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n    }","commit_id":"114bb76346fe984ca97392e9f89a9b6ca21bce0e","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void rewriteProject()\n        throws PluginExecutionException\n    {\n        try\n        {\n            File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n            Reader reader;\n            if ( projectFile.exists() )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            removeOldElements( modules, \"module\" );\n\n            for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n            {\n                MavenProject p = (MavenProject) i.next();\n\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new PluginExecutionException( \"Error parsing existing IML file\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new PluginExecutionException( \"Error parsing existing IML file\", e );\n        }\n    }","id":78098,"modified_method":"private void rewriteProject()\n        throws PluginExecutionException\n    {\n        try\n        {\n            File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n            Reader reader;\n            if ( projectFile.exists() )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            if ( project.getCollectedProjects().size() > 0 )\n            {\n                removeOldElements( modules, \"module\" );\n\n                for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    Xpp3Dom m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( project.getBasedir(), project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new PluginExecutionException( \"Error parsing existing IML file\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new PluginExecutionException( \"Error parsing existing IML file\", e );\n        }\n    }","commit_id":"62030d0283a09d1b057521ed7dfa0e387e8506d9","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Create IDEA (.ipr) project files.\n     *\n     * @throws MojoExecutionException\n     */\n    private void rewriteProject()\n        throws MojoExecutionException\n    {\n        File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n        try\n        {\n            Reader reader;\n            if ( projectFile.exists() && !overwrite )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            // Set the jdk name if set\n            if ( jdkName != null )\n            {\n                setJdkName( module, jdkName );\n            }\n            else\n            {\n                String javaVersion = System.getProperty( \"java.version\" );\n                String defaultJdkName;\n\n                if ( ideaVersion.startsWith( \"4\" ) )\n                {\n                    defaultJdkName = \"java version &quot;\" + javaVersion + \"&quot;\";\n                }\n                else\n                {\n                    defaultJdkName = javaVersion.substring( 0, 3 );\n                }\n                getLog().info( \"jdkName is not set, using [java version\" + javaVersion + \"] as default.\" );\n                setJdkName( module, defaultJdkName );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            if ( project.getCollectedProjects().size() > 0 )\n            {\n                removeOldElements( modules, \"module\" );\n\n                for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    Xpp3Dom m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( project.getBasedir(),\n                                              project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n    }","id":78099,"modified_method":"/**\n     * Create IDEA (.ipr) project files.\n     *\n     * @throws MojoExecutionException\n     */\n    private void rewriteProject()\n        throws MojoExecutionException\n    {\n        File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n        try\n        {\n            Reader reader;\n            if ( projectFile.exists() && !overwrite )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            // Set the jdk name if set\n            if ( jdkName != null )\n            {\n                setJdkName( module, jdkName );\n            }\n            else\n            {\n                String javaVersion = System.getProperty( \"java.version\" );\n                String defaultJdkName;\n\n                if ( ideaVersion.startsWith( \"4\" ) )\n                {\n                    defaultJdkName = \"java version &quot;\" + javaVersion + \"&quot;\";\n                }\n                else\n                {\n                    defaultJdkName = javaVersion.substring( 0, 3 );\n                }\n                getLog().info( \"jdkName is not set, using [java version\" + javaVersion + \"] as default.\" );\n                setJdkName( module, defaultJdkName );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            if ( project.getCollectedProjects().size() > 0 )\n            {\n                removeOldElements( modules, \"module\" );\n\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String projectPath = new File( project.getBasedir(),\n                                               project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), projectPath ) );\n\n                for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( project.getBasedir(),\n                                              project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IPR file: \" + projectFile.getAbsolutePath(), e );\n        }\n    }","commit_id":"bcb11b18fc2d74458bfb589739875712a813f0c1","url":"https://github.com/apache/maven"},{"original_method":"private void rewriteProject()\n        throws PluginExecutionException\n    {\n        try\n        {\n            File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n            Reader reader;\n            if ( projectFile.exists() )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            removeOldElements( modules, \"module\" );\n\n            for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n            {\n                MavenProject p = (MavenProject) i.next();\n\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new PluginExecutionException( \"Error parsing existing IML file\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new PluginExecutionException( \"Error parsing existing IML file\", e );\n        }\n    }","id":78100,"modified_method":"private void rewriteProject()\n        throws PluginExecutionException\n    {\n        try\n        {\n            File projectFile = new File( project.getBasedir(), project.getArtifactId() + \".ipr\" );\n            Reader reader;\n            if ( projectFile.exists() )\n            {\n                reader = new FileReader( projectFile );\n            }\n            else\n            {\n                reader = new InputStreamReader( getClass().getResourceAsStream( \"/templates/default/project.xml\" ) );\n            }\n\n            Xpp3Dom module;\n            try\n            {\n                module = Xpp3DomBuilder.build( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            Xpp3Dom component = findComponent( module, \"ProjectModuleManager\" );\n            Xpp3Dom modules = findElement( component, \"modules\" );\n\n            if ( project.getCollectedProjects().size() > 0 )\n            {\n                removeOldElements( modules, \"module\" );\n\n                for ( Iterator i = project.getCollectedProjects().iterator(); i.hasNext(); )\n                {\n                    MavenProject p = (MavenProject) i.next();\n\n                    Xpp3Dom m = createElement( modules, \"module\" );\n                    String modulePath = new File( p.getBasedir(), p.getArtifactId() + \".iml\" ).getAbsolutePath();\n                    m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n                }\n            }\n            else\n            {\n                Xpp3Dom m = createElement( modules, \"module\" );\n                String modulePath = new File( project.getBasedir(), project.getArtifactId() + \".iml\" ).getAbsolutePath();\n                m.setAttribute( \"filepath\", \"$PROJECT_DIR$/\" + toRelative( project.getBasedir(), modulePath ) );\n            }\n\n            FileWriter writer = new FileWriter( projectFile );\n            try\n            {\n                Xpp3DomWriter.write( writer, module );\n            }\n            finally\n            {\n                IOUtil.close( writer );\n            }\n        }\n        catch ( XmlPullParserException e )\n        {\n            throw new PluginExecutionException( \"Error parsing existing IML file\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new PluginExecutionException( \"Error parsing existing IML file\", e );\n        }\n    }","commit_id":"4361a69db022787ff0156efad3aceb9e8135f740","url":"https://github.com/apache/maven"},{"original_method":"@Nullable\n  @Override\n  public PyType getReturnType(@NotNull TypeEvalContext context, @NotNull TypeEvalContext.Key key) {\n    for (PyTypeProvider typeProvider : Extensions.getExtensions(PyTypeProvider.EP_NAME)) {\n      final Ref<PyType> returnTypeRef = typeProvider.getReturnType(this, context);\n      if (returnTypeRef != null) {\n        final PyType returnType = returnTypeRef.get();\n        if (returnType != null) {\n          returnType.assertValid(typeProvider.toString());\n        }\n        return returnType;\n      }\n    }\n    final PyType docStringType = getReturnTypeFromDocString();\n    if (docStringType != null) {\n      docStringType.assertValid(\"from docstring\");\n      return docStringType;\n    }\n    if (context.allowReturnTypes(this)) {\n      final Ref<? extends PyType> yieldTypeRef = getYieldStatementType(context);\n      if (yieldTypeRef != null) {\n        return yieldTypeRef.get();\n      }\n      return getReturnStatementType(context);\n    }\n    else if (isAsync()) {\n      return createCoroutineType(null);\n    }\n    return null;\n  }","id":78101,"modified_method":"@Nullable\n  @Override\n  public PyType getReturnType(@NotNull TypeEvalContext context, @NotNull TypeEvalContext.Key key) {\n    final PyType type = getReturnType(context);\n    return isAsync() ? createCoroutineType(type) : type;\n  }","commit_id":"17db5621d6e406db3ab9b985ec2b86defde5bb8e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private PyType createCoroutineType(@Nullable PyType returnType) {\n    final PyBuiltinCache cache = PyBuiltinCache.getInstance(this);\n    final PyClass generator = cache.getClass(PyNames.FAKE_COROUTINE);\n    return generator != null ? new PyCollectionTypeImpl(generator, false, Collections.singletonList(returnType)) : null;\n  }","id":78102,"modified_method":"@Nullable\n  private PyType createCoroutineType(@Nullable PyType returnType) {\n    final PyBuiltinCache cache = PyBuiltinCache.getInstance(this);\n    if (returnType instanceof PyClassLikeType && PyNames.FAKE_COROUTINE.equals(((PyClassLikeType)returnType).getClassQName())) {\n      return returnType;\n    }\n    final PyClass generator = cache.getClass(PyNames.FAKE_COROUTINE);\n    return generator != null ? new PyCollectionTypeImpl(generator, false, Collections.singletonList(returnType)) : null;\n  }","commit_id":"17db5621d6e406db3ab9b985ec2b86defde5bb8e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PyType getReturnStatementType(TypeEvalContext typeEvalContext) {\n    final ReturnVisitor visitor = new ReturnVisitor(this, typeEvalContext);\n    final PyStatementList statements = getStatementList();\n    statements.accept(visitor);\n    if (isGeneratedStub() && !visitor.myHasReturns) {\n      if (PyNames.INIT.equals(getName())) {\n        return PyNoneType.INSTANCE;\n      }\n      return null;\n    }\n    final PyType returnType = visitor.result();\n    if (isAsync()) {\n      return createCoroutineType(returnType);\n    }\n    return returnType;\n  }","id":78103,"modified_method":"@Nullable\n  public PyType getReturnStatementType(TypeEvalContext typeEvalContext) {\n    final ReturnVisitor visitor = new ReturnVisitor(this, typeEvalContext);\n    final PyStatementList statements = getStatementList();\n    statements.accept(visitor);\n    if (isGeneratedStub() && !visitor.myHasReturns) {\n      if (PyNames.INIT.equals(getName())) {\n        return PyNoneType.INSTANCE;\n      }\n      return null;\n    }\n    return visitor.result();\n  }","commit_id":"17db5621d6e406db3ab9b985ec2b86defde5bb8e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public ServiceClientResponse get(String hashKey, String uri, Map<String, String> headers) throws AkkaServiceClientException {\n        ServiceClientResponse serviceClientResponse = null;\n        AuthGetRequest authGetRequest = new AuthGetRequest(hashKey, uri, headers);\n        try {\n            Timeout timeout = new Timeout(serviceClient.getSocketTimeout() + CONNECTION_TIMEOUT_BUFFER_MILLIS, TimeUnit.MILLISECONDS);\n            Future<ServiceClientResponse> future = getFuture(authGetRequest, timeout);\n            serviceClientResponse = Await.result(future, timeout.duration());\n        } catch (Exception e) {\n            LOG.error(\"Error acquiring value from akka (GET) or the cache. Reason: {}\", e.getLocalizedMessage());\n            LOG.trace(\"\", e);\n            throw new AkkaServiceClientException(\"Error acquiring value from akka (GET) or the cache.\", e);\n        }\n        return serviceClientResponse;\n    }","id":78104,"modified_method":"@Override\n    public ServiceClientResponse get(String hashKey, String uri, Map<String, String> headers) throws AkkaServiceClientException {\n        AuthGetRequest authGetRequest = new AuthGetRequest(hashKey, uri, headers);\n        try {\n            Timeout timeout = new Timeout(serviceClient.getSocketTimeout() + CONNECTION_TIMEOUT_BUFFER_MILLIS, TimeUnit.MILLISECONDS);\n            Future<ServiceClientResponse> future = getFuture(authGetRequest, timeout);\n            return Await.result(future, timeout.duration());\n        } catch (Exception e) {\n            LOG.error(\"Error acquiring value from akka (GET) or the cache. Reason: {}\", e.getLocalizedMessage());\n            LOG.trace(\"\", e);\n            throw new AkkaServiceClientException(\"Error acquiring value from akka (GET) or the cache.\", e);\n        }\n    }","commit_id":"82382bee5e1ff3bc09d3d586bec51cd2006f679e","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public ServiceClientResponse post(String hashKey, String uri, Map<String, String> headers, String payload, MediaType contentMediaType) throws AkkaServiceClientException {\n        ServiceClientResponse serviceClientResponse = null;\n        AuthPostRequest authPostRequest = new AuthPostRequest(hashKey, uri, headers, payload, contentMediaType);\n        try {\n            Timeout timeout = new Timeout(serviceClient.getSocketTimeout() + CONNECTION_TIMEOUT_BUFFER_MILLIS, TimeUnit.MILLISECONDS);\n            Future<ServiceClientResponse> future = getFuture(authPostRequest, timeout);\n            serviceClientResponse = Await.result(future, timeout.duration());\n        } catch (Exception e) {\n            LOG.error(\"Error acquiring value from akka (POST) or the cache. Reason: {}\", e.getLocalizedMessage());\n            LOG.trace(\"\", e);\n            throw new AkkaServiceClientException(\"Error acquiring value from akka (POST) or the cache.\", e);\n        }\n        return serviceClientResponse;\n    }","id":78105,"modified_method":"@Override\n    public ServiceClientResponse post(String hashKey, String uri, Map<String, String> headers, String payload, MediaType contentMediaType) throws AkkaServiceClientException {\n        AuthPostRequest authPostRequest = new AuthPostRequest(hashKey, uri, headers, payload, contentMediaType);\n        try {\n            Timeout timeout = new Timeout(serviceClient.getSocketTimeout() + CONNECTION_TIMEOUT_BUFFER_MILLIS, TimeUnit.MILLISECONDS);\n            Future<ServiceClientResponse> future = getFuture(authPostRequest, timeout);\n            return Await.result(future, timeout.duration());\n        } catch (Exception e) {\n            LOG.error(\"Error acquiring value from akka (POST) or the cache. Reason: {}\", e.getLocalizedMessage());\n            LOG.trace(\"\", e);\n            throw new AkkaServiceClientException(\"Error acquiring value from akka (POST) or the cache.\", e);\n        }\n    }","commit_id":"82382bee5e1ff3bc09d3d586bec51cd2006f679e","url":"https://github.com/rackerlabs/repose"},{"original_method":"private void addWithinFuncs() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(IN_DEF_BODY)\n        .and(IN_BEGIN_STMT)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"global\", \"return\", \"yield\"};\n          putKeywords(space_strings, TailType.SPACE, result);\n        }\n      }\n    );\n  }","id":78106,"modified_method":"private void addWithinFuncs() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(IN_DEF_BODY)\n        .and(IN_BEGIN_STMT)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new PyKeywordCompletionProvider(\"global\", \"return\", \"yield\")\n    );\n  }","commit_id":"ed03a68bcd802c0fb7ee85e6fc77a4dc5e6e0ef5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addContinue() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(IN_BEGIN_STMT)\n        .andNot(AFTER_QUALIFIER)\n        .andNot(IN_PARAM_LIST)\n        .andNot(IN_ARG_LIST)\n        .andNot(IN_FINALLY_NO_LOOP)\n        .andOr(IN_LOOP, AFTER_LOOP_NO_ELSE)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] strings = {\"continue\"};\n          putKeywords(strings, TailType.NONE, result);\n        }\n      }\n    );\n  }","id":78107,"modified_method":"private void addContinue() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(IN_BEGIN_STMT)\n        .andNot(AFTER_QUALIFIER)\n        .andNot(IN_PARAM_LIST)\n        .andNot(IN_ARG_LIST)\n        .andNot(IN_FINALLY_NO_LOOP)\n        .andOr(IN_LOOP, AFTER_LOOP_NO_ELSE)\n      ,\n      new PyKeywordCompletionProvider(TailType.NONE, \"continue\")\n    );\n  }","commit_id":"ed03a68bcd802c0fb7ee85e6fc77a4dc5e6e0ef5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addNot() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .andNot(IN_COMMENT)\n        .andNot(IN_IMPORT_STMT)\n        .andNot(IN_PARAM_LIST)\n        .andNot(IN_DEFINITION)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(@NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"not\"};\n          putKeywords(space_strings, TailType.SPACE, result);\n        }\n      }\n    );\n  }","id":78108,"modified_method":"private void addNot() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .andNot(IN_COMMENT)\n        .andNot(IN_IMPORT_STMT)\n        .andNot(IN_PARAM_LIST)\n        .andNot(IN_DEFINITION)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new PyKeywordCompletionProvider(\"not\")\n    );\n  }","commit_id":"ed03a68bcd802c0fb7ee85e6fc77a4dc5e6e0ef5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addBreak() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(IN_BEGIN_STMT)\n        .andNot(AFTER_QUALIFIER)\n        .andNot(IN_PARAM_LIST)\n        .andNot(IN_ARG_LIST)\n        .andOr(IN_LOOP, AFTER_LOOP_NO_ELSE)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] strings = {\"break\"};\n          putKeywords(strings, TailType.NONE, result);\n        }\n      }\n    );\n  }","id":78109,"modified_method":"private void addBreak() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(IN_BEGIN_STMT)\n        .andNot(AFTER_QUALIFIER)\n        .andNot(IN_PARAM_LIST)\n        .andNot(IN_ARG_LIST)\n        .andOr(IN_LOOP, AFTER_LOOP_NO_ELSE)\n      ,\n      new PyKeywordCompletionProvider(TailType.NONE, \"break\")\n    );\n  }","commit_id":"ed03a68bcd802c0fb7ee85e6fc77a4dc5e6e0ef5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addAs() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .andOr(IN_IMPORT_AFTER_REF, IN_WITH_AFTER_REF) \n        .andNot(AFTER_QUALIFIER)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"as\"};\n          putKeywords(space_strings, TailType.SPACE, result);\n        }\n      }\n    );\n  }","id":78110,"modified_method":"private void addAs() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .andOr(IN_IMPORT_AFTER_REF, IN_WITH_AFTER_REF) \n        .andNot(AFTER_QUALIFIER)\n      ,\n      new PyKeywordCompletionProvider(\"as\")\n    );\n  }","commit_id":"ed03a68bcd802c0fb7ee85e6fc77a4dc5e6e0ef5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PyKeywordCompletionContributor() {\n    addStatements();\n    addPreColonStatements();\n    addWithinIf();\n    addElse();\n    addBreak();\n    addContinue();\n    addWithinFuncs();\n    addWithinTry();\n    addInfixOperators();\n    addNot();\n    addAs();\n    addImportInFrom();\n    //addExprIf();\n    //addExprElse();\n  }","id":78111,"modified_method":"public PyKeywordCompletionContributor() {\n    addStatements();\n    addPreColonStatements();\n    addWithinIf();\n    addElse();\n    addBreak();\n    addContinue();\n    addWithinFuncs();\n    addWithinTry();\n    addInfixOperators();\n    addNot();\n    addAs();\n    addImportInFrom();\n    addPy3kLiterals();\n    //addExprIf();\n    //addExprElse();\n  }","commit_id":"ed03a68bcd802c0fb7ee85e6fc77a4dc5e6e0ef5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addImportInFrom() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(IN_FROM_IMPORT_AFTER_REF)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"import\"};\n          putKeywords(space_strings, TailType.SPACE, result);\n        }\n      }\n    );\n  }","id":78112,"modified_method":"private void addImportInFrom() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .and(IN_FROM_IMPORT_AFTER_REF)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new PyKeywordCompletionProvider(\"import\")\n    );\n  }","commit_id":"ed03a68bcd802c0fb7ee85e6fc77a4dc5e6e0ef5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addInfixOperators() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .andNot(IN_COMMENT)\n        .andNot(BEFORE_COND)\n        .andNot(IN_IMPORT_STMT) // expressions there are not logical anyway\n        .andNot(IN_PARAM_LIST)\n        .andNot(IN_DEFINITION)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(@NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"and\", \"or\", \"is\", \"in\"};\n          putKeywords(space_strings, TailType.SPACE, result);\n        }\n      }\n    );\n  }","id":78113,"modified_method":"private void addInfixOperators() {\n    extend(\n      CompletionType.BASIC, psiElement()\n        .withLanguage(PythonLanguage.getInstance())\n        .andNot(IN_COMMENT)\n        .andNot(BEFORE_COND)\n        .andNot(IN_IMPORT_STMT) // expressions there are not logical anyway\n        .andNot(IN_PARAM_LIST)\n        .andNot(IN_DEFINITION)\n        .andNot(AFTER_QUALIFIER)\n      ,\n      new PyKeywordCompletionProvider(\"and\", \"or\", \"is\", \"in\")\n    );\n  }","commit_id":"ed03a68bcd802c0fb7ee85e6fc77a4dc5e6e0ef5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addStatements() {\n    PsiElementPattern.Capture<PsiElement> inStatement = psiElement()\n      .withLanguage(PythonLanguage.getInstance())\n      .and(IN_BEGIN_STMT)\n      .andNot(IN_IMPORT_STMT)\n      .andNot(IN_PARAM_LIST)\n      .andNot(IN_ARG_LIST)\n      .andNot(IN_DEFINITION)\n      .andNot(BEFORE_COND)\n      .andNot(AFTER_QUALIFIER);\n\n    extend(\n      CompletionType.BASIC,\n      inStatement,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"assert\", \"del\", \"exec\", \"from\", \"import\", \"raise\"};\n          final @NonNls String[] just_strings = {\"pass\"};\n          putKeywords(space_strings, TailType.SPACE, result);\n          putKeywords(just_strings, TailType.NONE, result);\n        }\n      }\n    );\n\n    extend(CompletionType.BASIC, inStatement.andNot(PY3K),\n           new CompletionProvider<CompletionParameters>() {\n             @Override\n             protected void addCompletions(@NotNull CompletionParameters parameters,\n                                           ProcessingContext context,\n                                           @NotNull CompletionResultSet result) {\n               putKeywords(new String[]{\"print\"}, TailType.SPACE, result);\n             }\n           });\n  }","id":78114,"modified_method":"private void addStatements() {\n    PsiElementPattern.Capture<PsiElement> inStatement = psiElement()\n      .withLanguage(PythonLanguage.getInstance())\n      .and(IN_BEGIN_STMT)\n      .andNot(IN_IMPORT_STMT)\n      .andNot(IN_PARAM_LIST)\n      .andNot(IN_ARG_LIST)\n      .andNot(IN_DEFINITION)\n      .andNot(BEFORE_COND)\n      .andNot(AFTER_QUALIFIER);\n\n    extend(\n      CompletionType.BASIC,\n      inStatement,\n      new CompletionProvider<CompletionParameters>() {\n        protected void addCompletions(\n          @NotNull final CompletionParameters parameters, final ProcessingContext context, @NotNull final CompletionResultSet result\n        ) {\n          final @NonNls String[] space_strings = {\"assert\", \"del\", \"exec\", \"from\", \"import\", \"raise\"};\n          final @NonNls String[] just_strings = {\"pass\"};\n          putKeywords(space_strings, TailType.SPACE, result);\n          putKeywords(just_strings, TailType.NONE, result);\n        }\n      }\n    );\n\n    extend(CompletionType.BASIC, inStatement.andNot(PY3K), new PyKeywordCompletionProvider(TailType.SPACE, \"print\"));\n  }","commit_id":"4062d5a8571127b493268f7dd6953c15a375e494","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrVariableDeclaration createVariableDeclaration(@Nullable String[] modifiers,\n                                                         @Nullable GrExpression initializer,\n                                                         @Nullable PsiType type,\n                                                         String... identifiers) {\n    StringBuilder text = writeModifiers(modifiers);\n    if (modifiers == null || modifiers.length == 0) {\n      text.append(\"def \");\n    }\n    if (type != null) {\n      type = TypesUtil.unboxPrimitiveTypeWrapper(type);\n      final String typeText = getTypeText(type);\n      text.append(typeText).append(\" \");\n    }\n\n    if (identifiers.length > 1 && initializer != null) {\n      text.append('(');\n    }\n    for (int i = 0; i < identifiers.length; i++) {\n      if (i > 0) text.append(\", \");\n      String identifier = identifiers[i];\n      text.append(identifier);\n    }\n\n    if (identifiers.length > 1 && initializer != null) {\n      text.append(')');\n    }\n\n    if (initializer != null) {\n      if (initializer instanceof GrApplicationStatement &&\n          !GroovyConfigUtils.getInstance().isVersionAtLeast(initializer, GroovyConfigUtils.GROOVY1_8)) {\n        initializer = createMethodCallByAppCall((GrApplicationStatement)initializer);\n      }\n      assert initializer != null;\n      text.append(\" = \").append(initializer.getText());\n    }\n\n    PsiFile file = createGroovyFile(text.toString());\n    GrTopStatement[] topStatements = ((GroovyFileBase)file).getTopStatements();\n    if (topStatements.length == 0 || !(topStatements[0] instanceof GrVariableDeclaration)) {\n      throw new RuntimeException(\"Invalid arguments, text = \" + text.toString());\n    }\n\n    final GrVariableDeclaration declaration = (GrVariableDeclaration)topStatements[0];\n    if (declaration.getTypeElementGroovy() != null) {\n      declaration.getModifierList().setModifierProperty(GrModifier.DEF, false);\n    }\n    return declaration;\n  }","id":78115,"modified_method":"public GrVariableDeclaration createVariableDeclaration(@Nullable String[] modifiers,\n                                                         @Nullable GrExpression initializer,\n                                                         @Nullable PsiType type,\n                                                         String... identifiers) {\n    StringBuilder text = writeModifiers(modifiers);\n\n    if (type != null) {\n      final PsiType unboxed = TypesUtil.unboxPrimitiveTypeWrapper(type);\n      final String typeText = getTypeText(unboxed);\n      text.append(typeText).append(\" \");\n    } else if (text.length() == 0) {\n      text.insert(0, \"def \");\n    }\n\n    if (identifiers.length > 1 && initializer != null) {\n      text.append('(');\n    }\n    for (int i = 0; i < identifiers.length; i++) {\n      if (i > 0) text.append(\", \");\n      String identifier = identifiers[i];\n      text.append(identifier);\n    }\n\n    if (identifiers.length > 1 && initializer != null) {\n      text.append(')');\n    }\n\n    if (initializer != null) {\n      if (initializer instanceof GrApplicationStatement &&\n          !GroovyConfigUtils.getInstance().isVersionAtLeast(initializer, GroovyConfigUtils.GROOVY1_8)) {\n        initializer = createMethodCallByAppCall((GrApplicationStatement)initializer);\n      }\n      assert initializer != null;\n      text.append(\" = \").append(initializer.getText());\n    }\n\n    GrTopStatement[] topStatements = ((GroovyFileBase)createGroovyFile(text.toString())).getTopStatements();\n    if (topStatements.length == 0 || !(topStatements[0] instanceof GrVariableDeclaration)) {\n      topStatements = ((GroovyFileBase)createGroovyFile(\"def \" + text)).getTopStatements();\n    }\n    if (topStatements.length == 0 || !(topStatements[0] instanceof GrVariableDeclaration)) {\n      throw new RuntimeException(\"Invalid arguments, text = \" + text);\n    }\n\n    final GrVariableDeclaration statement = (GrVariableDeclaration)topStatements[0];\n    //todo switch-case formatting should work without this hack\n    CodeEditUtil.markToReformatBefore(statement.getNode().findLeafElementAt(0), true);\n    return statement;\n  }","commit_id":"8450ac155088d7af2ccb383ab64364c2c507dda3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrVariableDeclaration createVariableDeclaration(String[] modifiers, GrExpression initializer, PsiType type, String... identifiers) {\n    StringBuffer text = writeModifiers(modifiers);\n\n    if (type != null) {\n      type = TypesUtil.unboxPrimitiveTypeWrapper(type);\n      final String typeText = getTypeText(type);\n      int lastDot = typeText.lastIndexOf('.');\n      int idx = 0 < lastDot && lastDot < typeText.length() - 1 ? lastDot + 1 : 0;\n      char c = typeText.charAt(idx);\n      if (!Character.isLetter(c) || Character.isLowerCase(c) &&\n          !GroovyNamesUtil.isKeyword(typeText)) { //primitive type\n        text.append(\"def \");\n      }\n      text.append(typeText).append(\" \");\n    } else {\n      text.append(\"def \");\n    }\n\n    for (int i = 0; i < identifiers.length; i++) {\n      if (i > 0) text.append(\", \");\n      String identifier = identifiers[i];\n      text.append(identifier);\n    }\n    GrExpression expr;\n\n    if (initializer != null) {\n      if (initializer instanceof GrApplicationStatement) {\n        expr = createMethodCallByAppCall(((GrApplicationStatement) initializer));\n      } else {\n        expr = initializer;\n      }\n      text.append(\" = \").append(expr.getText());\n    }\n\n    PsiFile file = createGroovyFile(text.toString());\n    return ((GrVariableDeclaration) ((GroovyFileBase) file).getTopStatements()[0]);\n  }","id":78116,"modified_method":"public GrVariableDeclaration createVariableDeclaration(String[] modifiers, GrExpression initializer, PsiType type, String... identifiers) {\n    StringBuffer text = writeModifiers(modifiers);\n\n    if (type != null) {\n      type = TypesUtil.unboxPrimitiveTypeWrapper(type);\n      final String typeText = getTypeText(type);\n      int lastDot = typeText.lastIndexOf('.');\n      int idx = 0 < lastDot && lastDot < typeText.length() - 1 ? lastDot + 1 : 0;\n      char c = typeText.charAt(idx);\n      if (!Character.isLetter(c) || Character.isLowerCase(c) &&\n          !GroovyNamesUtil.isKeyword(typeText)) { //primitive type\n        text.append(\"def \");\n      }\n      text.append(typeText).append(\" \");\n    } else {\n      text.append(\"def \");\n    }\n\n    for (int i = 0; i < identifiers.length; i++) {\n      if (i > 0) text.append(\", \");\n      String identifier = identifiers[i];\n      text.append(identifier);\n    }\n    GrExpression expr;\n\n    if (initializer != null) {\n      if (initializer instanceof GrApplicationStatement) {\n        expr = createMethodCallByAppCall(((GrApplicationStatement) initializer));\n      } else {\n        expr = initializer;\n      }\n      text.append(\" = \").append(expr.getText());\n    }\n\n    PsiFile file = createGroovyFile(text.toString());\n    GrTopStatement[] topStatements = ((GroovyFileBase) file).getTopStatements();\n    if (topStatements.length == 0 || !(topStatements[0] instanceof GrVariableDeclaration)) {\n      throw new RuntimeException(\"Invalid arguments, text = \" + text.toString()); \n    }\n    return (GrVariableDeclaration) topStatements[0];\n  }","commit_id":"90e6ae0050ed5edeed1e8d8b5d3f545dc32a5712","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrReferenceExpression createReferenceExpressionFromText(String idText) {\n    PsiFile file = createGroovyFile(idText);\n    return (GrReferenceExpression) ((GroovyFileBase) file).getTopStatements()[0];\n  }","id":78117,"modified_method":"public GrReferenceExpression createReferenceExpressionFromText(String idText) {\n    PsiFile file = createGroovyFile(idText);\n    final GrTopStatement[] statements = ((GroovyFileBase)file).getTopStatements();\n    LOG.assertTrue(statements.length == 1 && statements[0] instanceof GrReferenceExpression, idText);\n    return (GrReferenceExpression) statements[0];\n  }","commit_id":"1a56741f7bba168d7764c5366439f0d74b645643","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException\n    {\n        if (request.getRemoteUser()==null)\n        {\n            try\n            {\n                request.login(\"user\", \"password\");\n            }\n            catch(ServletException se)\n            {\n            \tse.printStackTrace();\n            }\n        }\n\n        // Handle a dump of data\n        final String data= request.getParameter(\"data\");\n        final String chars= request.getParameter(\"chars\");\n        final String block= request.getParameter(\"block\");\n        final String dribble= request.getParameter(\"dribble\");\n        final boolean flush= request.getParameter(\"flush\")!=null?Boolean.parseBoolean(request.getParameter(\"flush\")):false;\n\n\n        if(request.getPathInfo()!=null && request.getPathInfo().toLowerCase(Locale.ENGLISH).indexOf(\"script\")!=-1)\n        {\n            response.sendRedirect(response.encodeRedirectURL(getServletContext().getContextPath() + \"/dump/info\"));\n            return;\n        }\n\n        request.setCharacterEncoding(\"UTF-8\");\n\n        if (request.getParameter(\"busy\")!=null)\n        {\n            long end = System.currentTimeMillis()+Long.parseLong(request.getParameter(\"busy\"));\n            while(System.currentTimeMillis()<end)\n            {}\n        }\n\n        if (request.getParameter(\"empty\")!=null)\n        {\n            response.setStatus(200);\n            response.flushBuffer();\n            return;\n        }\n\n        if (request.getParameter(\"sleep\")!=null)\n        {\n            try\n            {\n                long s = Long.parseLong(request.getParameter(\"sleep\"));\n                if (request.getHeader(\"Expect\")!=null && request.getHeader(\"Expect\").indexOf(\"102\")>=0)\n                {\n                    Thread.sleep(s/2);\n                    response.sendError(102);\n                    Thread.sleep(s/2);\n                }\n                else\n                    Thread.sleep(s);\n            }\n            catch (InterruptedException e)\n            {\n                return;\n            }\n            catch (Exception e)\n            {\n                throw new ServletException(e);\n            }\n        }\n\n        if (request.getAttribute(\"RESUME\")==null && request.getParameter(\"resume\")!=null)\n        {\n            request.setAttribute(\"RESUME\",Boolean.TRUE);\n\n            final long resume=Long.parseLong(request.getParameter(\"resume\"));\n            final Continuation continuation = ContinuationSupport.getContinuation(request);\n            _timer.schedule(new TimerTask()\n            {\n                @Override\n                public void run()\n                {\n                    continuation.resume();\n                }\n            },resume);\n\n        }\n\n        if (request.getParameter(\"complete\")!=null)\n        {\n            final long complete=Long.parseLong(request.getParameter(\"complete\"));\n            _timer.schedule(new TimerTask()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        response.setContentType(\"text/html\");\n                        response.getOutputStream().println(\"<h1>COMPLETED<\/h1>\");\n                        Continuation continuation = ContinuationSupport.getContinuation(request);\n                        continuation.complete();\n                    }\n                    catch(Exception e)\n                    {\n                        e.printStackTrace();\n                    }\n                }\n            },complete);\n        }\n\n        if (request.getParameter(\"suspend\")!=null && request.getAttribute(\"SUSPEND\")!=Boolean.TRUE)\n        {\n            request.setAttribute(\"SUSPEND\",Boolean.TRUE);\n            try\n            {\n                Continuation continuation = ContinuationSupport.getContinuation(request);\n                continuation.setTimeout(Long.parseLong(request.getParameter(\"suspend\")));\n                continuation.suspend();\n\n                continuation.addContinuationListener(new ContinuationListener()\n                {\n                    @Override\n                    public void onTimeout(Continuation continuation)\n                    {\n                        response.addHeader(\"Dump\",\"onTimeout\");\n                        try\n                        {\n                            if (!dump(response,data,chars,block,dribble,flush))\n                            {\n                                response.setContentType(\"text/plain\");\n                                response.getOutputStream().println(\"EXPIRED\");\n                            }\n                            continuation.complete();\n                        }\n                        catch (IOException e)\n                        {\n                            getServletContext().log(\"\",e);\n                        }\n                    }\n\n                    @Override\n                    public void onComplete(Continuation continuation)\n                    {\n                        response.addHeader(\"Dump\",\"onComplete\");\n                    }\n                });\n\n                continuation.undispatch();\n            }\n            catch(Exception e)\n            {\n                throw new ServletException(e);\n            }\n        }\n\n        request.setAttribute(\"Dump\", this);\n        getServletContext().setAttribute(\"Dump\",this);\n        // getServletContext().log(\"dump \"+request.getRequestURI());\n\n        // Force a content length response\n        String length= request.getParameter(\"length\");\n        if (length != null && length.length() > 0)\n        {\n            response.setContentLength(Integer.parseInt(length));\n        }\n\n        // Handle a dump of data\n        if (dump(response,data,chars,block,dribble,flush))\n            return;\n\n        // handle an exception\n        String info= request.getPathInfo();\n        if (info != null && info.endsWith(\"Exception\"))\n        {\n            try\n            {\n                throw (Throwable) Thread.currentThread().getContextClassLoader().loadClass(info.substring(1)).newInstance();\n            }\n            catch (Throwable th)\n            {\n                throw new ServletException(th);\n            }\n        }\n\n        // test a reset\n        String reset= request.getParameter(\"reset\");\n        if (reset != null && reset.length() > 0)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.setHeader(\"SHOULD_NOT\",\"BE SEEN\");\n            response.reset();\n        }\n\n\n        // handle an redirect\n        String redirect= request.getParameter(\"redirect\");\n        if (redirect != null && redirect.length() > 0)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.sendRedirect(response.encodeRedirectURL(redirect));\n            try\n            {\n                response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            }\n            catch(IOException e)\n            {\n                // ignored as stream is closed.\n            }\n            return;\n        }\n\n        // handle an error\n        String error= request.getParameter(\"error\");\n        if (error != null && error.length() > 0 && request.getAttribute(\"javax.servlet.error.status_code\")==null)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.sendError(Integer.parseInt(error));\n            try\n            {\n                response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            }\n            catch(IllegalStateException e)\n            {\n                try\n                {\n                    response.getWriter().println(\"NOR THIS!!\");\n                }\n                catch(IOException e2){}\n            }\n            catch(IOException e){}\n            return;\n        }\n\n        // Handle a extra headers\n        String headers= request.getParameter(\"headers\");\n        if (headers != null && headers.length() > 0)\n        {\n            long h=Long.parseLong(headers);\n            for (int i=0;i<h;i++)\n                response.addHeader(\"Header\"+i,\"Value\"+i);\n        }\n\n        String buffer= request.getParameter(\"buffer\");\n        if (buffer != null && buffer.length() > 0)\n            response.setBufferSize(Integer.parseInt(buffer));\n\n        String charset= request.getParameter(\"charset\");\n        if (charset==null)\n            charset=\"UTF-8\";\n        response.setCharacterEncoding(charset);\n        response.setContentType(\"text/html\");\n\n        if (info != null && info.indexOf(\"Locale/\") >= 0)\n        {\n            try\n            {\n                String locale_name= info.substring(info.indexOf(\"Locale/\") + 7);\n                Field f= java.util.Locale.class.getField(locale_name);\n                response.setLocale((Locale)f.get(null));\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n                response.setLocale(Locale.getDefault());\n            }\n        }\n\n        String cn= request.getParameter(\"cookie\");\n        String cv=request.getParameter(\"cookiev\");\n        if (cn!=null && cv!=null)\n        {\n            Cookie cookie= new Cookie(cn, cv);\n            if (request.getParameter(\"version\")!=null)\n                cookie.setVersion(Integer.parseInt(request.getParameter(\"version\")));\n            cookie.setComment(\"Cookie from dump servlet\");\n            response.addCookie(cookie);\n        }\n\n        String pi= request.getPathInfo();\n        if (pi != null && pi.startsWith(\"/ex\"))\n        {\n            OutputStream out= response.getOutputStream();\n            out.write(\"<\/H1>This text should be reset<\/H1>\".getBytes());\n            if (\"/ex0\".equals(pi))\n                throw new ServletException(\"test ex0\", new Throwable());\n            else if (\"/ex1\".equals(pi))\n                throw new IOException(\"test ex1\");\n            else if (\"/ex2\".equals(pi))\n                throw new UnavailableException(\"test ex2\");\n            else if (pi.startsWith(\"/ex3/\"))\n                throw new UnavailableException(\"test ex3\",Integer.parseInt(pi.substring(5)));\n            throw new RuntimeException(\"test\");\n        }\n\n        if (\"true\".equals(request.getParameter(\"close\")))\n            response.setHeader(\"Connection\",\"close\");\n\n        String buffered= request.getParameter(\"buffered\");\n\n        PrintWriter pout=null;\n\n        try\n        {\n            pout =response.getWriter();\n        }\n        catch(IllegalStateException e)\n        {\n            pout=new PrintWriter(new OutputStreamWriter(response.getOutputStream(),charset));\n        }\n        if (buffered!=null)\n            pout = new PrintWriter(new BufferedWriter(pout,Integer.parseInt(buffered)));\n\n        try\n        {\n            pout.write(\"<html>\\n<body>\\n\");\n            pout.write(\"<h1>Dump Servlet<\/h1>\\n\");\n            pout.write(\"<table width=\\\"95%\\\">\");\n            pout.write(\"<tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getMethod:&nbsp;<\/th>\");\n            pout.write(\"<td>\" + notag(request.getMethod())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContentLength:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getContentLength())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContentType:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getContentType())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestURI:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getRequestURI())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestURL:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getRequestURL().toString())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContextPath:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getContextPath()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServletPath:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getServletPath())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getPathInfo:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getPathInfo())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getPathTranslated:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getPathTranslated())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getQueryString:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getQueryString())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n\n            pout.write(\"<th align=\\\"right\\\">getProtocol:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getProtocol()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getScheme:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getScheme()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServerName:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getServerName())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServerPort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getServerPort())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalName:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocalName()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalAddr:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocalAddr()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalPort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getLocalPort())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteUser:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteUser()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getUserPrincipal:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getUserPrincipal()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteAddr:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteAddr()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteHost:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteHost()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemotePort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemotePort()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestedSessionId:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRequestedSessionId()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">isSecure():&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.isSecure()+\"<\/td>\");\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">encodeRedirectURL(/foo?bar):&nbsp;<\/th>\");\n            pout.write(\"<td>\"+response.encodeRedirectURL(\"/foo?bar\")+\"<\/td>\");\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">isUserInRole(admin):&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.isUserInRole(\"admin\")+\"<\/td>\");\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocale:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocale()+\"<\/td>\");\n\n            Enumeration<Locale> locales= request.getLocales();\n            while (locales.hasMoreElements())\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getLocales:&nbsp;<\/th>\");\n                pout.write(\"<td>\"+locales.nextElement()+\"<\/td>\");\n            }\n            pout.write(\"<\/tr><tr>\\n\");\n\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Other HTTP Headers:<\/big><\/th>\");\n            Enumeration<String> h= request.getHeaderNames();\n            String name;\n            while (h.hasMoreElements())\n            {\n                name= (String)h.nextElement();\n\n                Enumeration<String> h2= request.getHeaders(name);\n                while (h2.hasMoreElements())\n                {\n                    String hv= (String)h2.nextElement();\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\":&nbsp;<\/th>\");\n                    pout.write(\"<td>\"+notag(hv)+\"<\/td>\");\n                }\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Request Parameters:<\/big><\/th>\");\n            h= request.getParameterNames();\n            while (h.hasMoreElements())\n            {\n                name= (String)h.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+notag(request.getParameter(name))+\"<\/td>\");\n                String[] values= request.getParameterValues(name);\n                if (values == null)\n                {\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\" Values:&nbsp;<\/th>\");\n                    pout.write(\"<td>\"+\"NULL!\"+\"<\/td>\");\n                }\n                else if (values.length > 1)\n                {\n                    for (int i= 0; i < values.length; i++)\n                    {\n                        pout.write(\"<\/tr><tr>\\n\");\n                        pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\"[\"+i+\"]:&nbsp;<\/th>\");\n                        pout.write(\"<td>\"+notag(values[i])+\"<\/td>\");\n                    }\n                }\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Cookies:<\/big><\/th>\");\n            Cookie[] cookies = request.getCookies();\n            for (int i=0; cookies!=null && i<cookies.length;i++)\n            {\n                Cookie cookie = cookies[i];\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+notag(cookie.getName())+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+notag(cookie.getValue())+\"<\/td>\");\n            }\n\n            String content_type=request.getContentType();\n            if (content_type!=null &&\n                !content_type.startsWith(\"application/x-www-form-urlencoded\") &&\n                !content_type.startsWith(\"multipart/form-data\"))\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"left\\\" valign=\\\"top\\\" colspan=\\\"2\\\"><big><br/>Content:<\/big><\/th>\");\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<td><pre>\");\n                char[] content= new char[4096];\n                int len;\n                try{\n                    Reader in=request.getReader();\n\n                    while((len=in.read(content))>=0)\n                        pout.write(notag(new String(content,0,len)));\n                }\n                catch(IOException e)\n                {\n                    pout.write(e.toString());\n                }\n\n                pout.write(\"<\/pre><\/td>\");\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Request Attributes:<\/big><\/th>\");\n            Enumeration<String> a= request.getAttributeNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                Object value=request.getAttribute(name);\n                if (value instanceof File)\n                {\n                    File file = (File)value;\n                    pout.write(\"<td>\"+\"<pre>\" + file.getName()+\" (\"+file.length()+\" \"+new Date(file.lastModified())+ \")<\/pre>\"+\"<\/td>\");\n                }\n                else\n                    pout.write(\"<td>\"+\"<pre>\" + toString(request.getAttribute(name)) + \"<\/pre>\"+\"<\/td>\");\n            }\n            request.setAttribute(\"org.eclipse.jetty.servlet.MultiPartFilter.files\",null);\n\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Servlet InitParameters:<\/big><\/th>\");\n            a= getInitParameterNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+name+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+ toString(getInitParameter(name)) +\"<\/td>\");\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Context InitParameters:<\/big><\/th>\");\n            a= getServletContext().getInitParameterNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+ toString(getServletContext().getInitParameter(name)) + \"<\/td>\");\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Context Attributes:<\/big><\/th>\");\n            a= getServletContext().getAttributeNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+\"<pre>\" + toString(getServletContext().getAttribute(name)) + \"<\/pre>\"+\"<\/td>\");\n            }\n\n            String res= request.getParameter(\"resource\");\n            if (res != null && res.length() > 0)\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Get Resource: \\\"\"+res+\"\\\"<\/big><\/th>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getServletContext().getResource(...):&nbsp;<\/th>\");\n                try{pout.write(\"<td>\"+getServletContext().getResource(res)+\"<\/td>\");}\n                catch(Exception e) {pout.write(\"<td>\"+\"\" +e+\"<\/td>\");}\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getServletContext().getResourcePaths(...):&nbsp;<\/th>\");\n                try{pout.write(\"<td>\"+getServletContext().getResourcePaths(res)+\"<\/td>\");}\n                catch(Exception e) {pout.write(\"<td>\"+\"\" +e+\"<\/td>\");}\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getServletContext().getContext(...):&nbsp;<\/th>\");\n\n                ServletContext context = getServletContext().getContext(res);\n                pout.write(\"<td>\"+context+\"<\/td>\");\n\n                if (context!=null)\n                {\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">getServletContext().getContext(...).getResource(...):&nbsp;<\/th>\");\n                    try{pout.write(\"<td>\"+context.getResource(res)+\"<\/td>\");}\n                    catch(Exception e) {pout.write(\"<td>\"+\"\" +e+\"<\/td>\");}\n\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">getServletContext().getContext(...).getResourcePaths(...):&nbsp;<\/th>\");\n                    try{pout.write(\"<td>\"+context.getResourcePaths(res)+\"<\/td>\");}\n                    catch(Exception e) {pout.write(\"<td>\"+\"\" +e+\"<\/td>\");}\n\n                    String cp=context.getContextPath();\n                    if (cp==null || \"/\".equals(cp))\n                        cp=\"\";\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">getServletContext().getContext(...),getRequestDispatcher(...):&nbsp;<\/th>\");\n                    pout.write(\"<td>\"+getServletContext().getContext(res).getRequestDispatcher(res.substring(cp.length()))+\"<\/td>\");\n                }\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">this.getClass().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+this.getClass().getResource(res)+\"<\/td>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">this.getClass().getClassLoader().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+this.getClass().getClassLoader().getResource(res)+\"<\/td>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">Thread.currentThread().getContextClassLoader().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+Thread.currentThread().getContextClassLoader().getResource(res)+\"<\/td>\");\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">Thread.currentThread().getContextClassLoader().getResources(...):&nbsp;<\/th>\");\n                Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(res);\n                if (urls==null)\n                    pout.write(\"<td>null<\/td>\");\n                else\n                    pout.write(\"<td>\"+Collections.list(urls)+\"<\/td>\");\n\n            }\n\n            pout.write(\"<\/tr><\/table>\\n\");\n\n            /* ------------------------------------------------------------ */\n            pout.write(\"<h2>Request Wrappers<\/h2>\\n\");\n            ServletRequest rw=request;\n            int w=0;\n            while (rw !=null)\n            {\n                pout.write((w++)+\": \"+rw.getClass().getName()+\"<br/>\");\n                if (rw instanceof HttpServletRequestWrapper)\n                    rw=((HttpServletRequestWrapper)rw).getRequest();\n                else if (rw instanceof ServletRequestWrapper)\n                    rw=((ServletRequestWrapper)rw).getRequest();\n                else\n                    rw=null;\n            }\n\n            /* ------------------------------------------------------------ */\n            pout.write(\"<h2>Response Wrappers<\/h2>\\n\");\n            ServletResponse rsw=response;\n            w=0;\n            while (rsw !=null)\n            {\n                pout.write((w++)+\": \"+rsw.getClass().getName()+\"<br/>\");\n                if (rsw instanceof HttpServletResponseWrapper)\n                    rsw=((HttpServletResponseWrapper)rsw).getResponse();\n                else if (rsw instanceof ServletResponseWrapper)\n                    rsw=((ServletResponseWrapper)rsw).getResponse();\n                else\n                    rsw=null;\n            }\n\n            pout.write(\"<br/>\");\n            pout.write(\"<h2>International Characters (UTF-8)<\/h2>\");\n            pout.write(\"LATIN LETTER SMALL CAPITAL AE<br/>\\n\");\n            pout.write(\"Directly uni encoded(\\\\u1d01): \\u1d01<br/>\");\n            pout.write(\"HTML reference (&amp;AElig;): &AElig;<br/>\");\n            pout.write(\"Decimal (&amp;#7425;): &#7425;<br/>\");\n            pout.write(\"Javascript unicode (\\\\u1d01) : <script language='javascript'>document.write(\\\"\\u1d01\\\");<\/script><br/>\");\n            pout.write(\"<br/>\");\n            pout.write(\"<h2>Form to generate GET content<\/h2>\");\n            pout.write(\"<form method=\\\"GET\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"value\\\"/><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\">\");\n            pout.write(\"<\/form>\");\n\n            pout.write(\"<br/>\");\n\n            pout.write(\"<h2>Form to generate POST content<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" accept-charset=\\\"utf-8\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"value\\\"/><br/>\\n\");\n            pout.write(\"Select: <select multiple name=\\\"Select\\\">\\n\");\n            pout.write(\"<option>ValueA<\/option>\");\n            pout.write(\"<option>ValueB1,ValueB2<\/option>\");\n            pout.write(\"<option>ValueC<\/option>\");\n            pout.write(\"<\/select><br/>\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\"><br/>\");\n            pout.write(\"<\/form>\");\n            pout.write(\"<br/>\");\n\n            pout.write(\"<h2>Form to generate UPLOAD content<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" enctype=\\\"multipart/form-data\\\" accept-charset=\\\"utf-8\\\" action=\\\"\"+\n                    response.encodeURL(getURI(request))+(request.getQueryString()==null?\"\":(\"?\"+request.getQueryString()))+\n                    \"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"comment\\\"/><br/>\\n\");\n            pout.write(\"File 1: <input type=\\\"file\\\" name=\\\"file1\\\" /><br/>\\n\");\n            pout.write(\"File 2: <input type=\\\"file\\\" name=\\\"file2\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\"><br/>\");\n            pout.write(\"<\/form>\");\n\n            pout.write(\"<h2>Form to set Cookie<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"cookie: <input type=\\\"text\\\" name=\\\"cookie\\\" /><br/>\\n\");\n            pout.write(\"value: <input type=\\\"text\\\" name=\\\"cookiev\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"setCookie\\\">\");\n            pout.write(\"<\/form>\\n\");\n\n            pout.write(\"<h2>Form to get Resource<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"resource: <input type=\\\"text\\\" name=\\\"resource\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"getResource\\\">\");\n            pout.write(\"<\/form>\\n\");\n        }\n        catch (Exception e)\n        {\n            getServletContext().log(\"dump \"+e);\n        }\n\n        String lines= request.getParameter(\"lines\");\n        if (lines!=null)\n        {\n            char[] line = \"<span>A line of characters. Blah blah blah blah.  blooble blooble<\/span><\/br>\\n\".toCharArray();\n            for (int l=Integer.parseInt(lines);l-->0;)\n            {\n                pout.write(\"<span>\"+l+\" <\/span>\");\n                pout.write(line);\n            }\n        }\n\n        pout.write(\"<\/body>\\n<\/html>\\n\");\n\n        pout.close();\n\n        if (pi != null)\n        {\n            if (\"/ex4\".equals(pi))\n                throw new ServletException(\"test ex4\", new Throwable());\n            if (\"/ex5\".equals(pi))\n                throw new IOException(\"test ex5\");\n            if (\"/ex6\".equals(pi))\n                throw new UnavailableException(\"test ex6\");\n        }\n\n\n    }","id":78118,"modified_method":"@Override\n    public void doGet(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException\n    {\n        if (request.getRemoteUser()==null)\n        {\n            try\n            {\n                request.login(\"user\", \"password\");\n            }\n            catch(ServletException se)\n            {\n            \tse.printStackTrace();\n            }\n        }\n\n        // Handle a dump of data\n        final String data= request.getParameter(\"data\");\n        final String chars= request.getParameter(\"chars\");\n        final String block= request.getParameter(\"block\");\n        final String dribble= request.getParameter(\"dribble\");\n        final boolean flush= request.getParameter(\"flush\")!=null?Boolean.parseBoolean(request.getParameter(\"flush\")):false;\n\n\n        if(request.getPathInfo()!=null && request.getPathInfo().toLowerCase(Locale.ENGLISH).indexOf(\"script\")!=-1)\n        {\n            response.sendRedirect(response.encodeRedirectURL(getServletContext().getContextPath() + \"/dump/info\"));\n            return;\n        }\n\n        request.setCharacterEncoding(\"UTF-8\");\n\n        if (request.getParameter(\"busy\")!=null)\n        {\n            long end = System.currentTimeMillis()+Long.parseLong(request.getParameter(\"busy\"));\n            while(System.currentTimeMillis()<end)\n            {}\n        }\n\n        if (request.getParameter(\"empty\")!=null)\n        {\n            response.setStatus(200);\n            response.flushBuffer();\n            return;\n        }\n\n        if (request.getParameter(\"sleep\")!=null)\n        {\n            try\n            {\n                long s = Long.parseLong(request.getParameter(\"sleep\"));\n                if (request.getHeader(\"Expect\")!=null && request.getHeader(\"Expect\").indexOf(\"102\")>=0)\n                {\n                    Thread.sleep(s/2);\n                    response.sendError(102);\n                    Thread.sleep(s/2);\n                }\n                else\n                    Thread.sleep(s);\n            }\n            catch (InterruptedException e)\n            {\n                return;\n            }\n            catch (Exception e)\n            {\n                throw new ServletException(e);\n            }\n        }\n\n        if (request.getParameter(\"startAsync\")!=null && request.getAttribute(\"ASYNC\")!=Boolean.TRUE)\n        {\n            request.setAttribute(\"ASYNC\",Boolean.TRUE);\n            try\n            {\n                final AsyncContext async=request.startAsync(request,response);\n                async.setTimeout(Long.parseLong(request.getParameter(\"startAsync\")));\n                async.addListener(new AsyncListener()\n                {\n                    \n                    @Override\n                    public void onTimeout(AsyncEvent event) throws IOException\n                    {\n                        response.addHeader(\"Dump\",\"onTimeout\");\n                        try\n                        {\n                            if (!dump(response,data,chars,block,dribble,flush))\n                            {\n                                response.setContentType(\"text/plain\");\n                                response.getOutputStream().println(\"EXPIRED\");\n                            }\n                            async.complete();\n                        }\n                        catch (IOException e)\n                        {\n                            getServletContext().log(\"\",e);\n                        }\n                    }\n                    \n                    @Override\n                    public void onStartAsync(AsyncEvent event) throws IOException\n                    {\n                        response.addHeader(\"Dump\",\"onStartAsync\");\n                    }\n                    \n                    @Override\n                    public void onError(AsyncEvent event) throws IOException\n                    {\n                        response.addHeader(\"Dump\",\"onError\");\n                    }\n                    \n                    @Override\n                    public void onComplete(AsyncEvent event) throws IOException\n                    {\n                        response.addHeader(\"Dump\",\"onComplete\");\n                    }\n                });\n\n                if (request.getParameter(\"dispatch\")!=null)\n                {\n                    request.setAttribute(\"RESUME\",Boolean.TRUE);\n\n                    final long resume=Long.parseLong(request.getParameter(\"dispatch\"));\n                    _timer.schedule(new TimerTask()\n                    {\n                        @Override\n                        public void run()\n                        {\n                            async.dispatch();\n                        }\n                    },resume);\n                }\n\n                if (request.getParameter(\"complete\")!=null)\n                {\n                    final long complete=Long.parseLong(request.getParameter(\"complete\"));\n                    _timer.schedule(new TimerTask()\n                    {\n                        @Override\n                        public void run()\n                        {\n                            try\n                            {\n                                response.setContentType(\"text/html\");\n                                response.getOutputStream().println(\"<h1>COMPLETED<\/h1>\");\n                                async.complete();\n                            }\n                            catch(Exception e)\n                            {\n                                e.printStackTrace();\n                            }\n                        }\n                    },complete);\n                }\n\n                \n                \n                return;\n            }\n            catch(Exception e)\n            {\n                throw new ServletException(e);\n            }\n        }\n\n        request.setAttribute(\"Dump\", this);\n        getServletContext().setAttribute(\"Dump\",this);\n        // getServletContext().log(\"dump \"+request.getRequestURI());\n\n        // Force a content length response\n        String length= request.getParameter(\"length\");\n        if (length != null && length.length() > 0)\n        {\n            response.setContentLength(Integer.parseInt(length));\n        }\n\n        // Handle a dump of data\n        if (dump(response,data,chars,block,dribble,flush))\n            return;\n\n        // handle an exception\n        String info= request.getPathInfo();\n        if (info != null && info.endsWith(\"Exception\"))\n        {\n            try\n            {\n                throw (Throwable) Thread.currentThread().getContextClassLoader().loadClass(info.substring(1)).newInstance();\n            }\n            catch (Throwable th)\n            {\n                throw new ServletException(th);\n            }\n        }\n\n        // test a reset\n        String reset= request.getParameter(\"reset\");\n        if (reset != null && reset.length() > 0)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.setHeader(\"SHOULD_NOT\",\"BE SEEN\");\n            response.reset();\n        }\n\n\n        // handle an redirect\n        String redirect= request.getParameter(\"redirect\");\n        if (redirect != null && redirect.length() > 0)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.sendRedirect(response.encodeRedirectURL(redirect));\n            try\n            {\n                response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            }\n            catch(IOException e)\n            {\n                // ignored as stream is closed.\n            }\n            return;\n        }\n\n        // handle an error\n        String error= request.getParameter(\"error\");\n        if (error != null && error.length() > 0 && request.getAttribute(\"javax.servlet.error.status_code\")==null)\n        {\n            response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            response.sendError(Integer.parseInt(error));\n            try\n            {\n                response.getOutputStream().println(\"THIS SHOULD NOT BE SEEN!\");\n            }\n            catch(IllegalStateException e)\n            {\n                try\n                {\n                    response.getWriter().println(\"NOR THIS!!\");\n                }\n                catch(IOException e2){}\n            }\n            catch(IOException e){}\n            return;\n        }\n\n        // Handle a extra headers\n        String headers= request.getParameter(\"headers\");\n        if (headers != null && headers.length() > 0)\n        {\n            long h=Long.parseLong(headers);\n            for (int i=0;i<h;i++)\n                response.addHeader(\"Header\"+i,\"Value\"+i);\n        }\n\n        String buffer= request.getParameter(\"buffer\");\n        if (buffer != null && buffer.length() > 0)\n            response.setBufferSize(Integer.parseInt(buffer));\n\n        String charset= request.getParameter(\"charset\");\n        if (charset==null)\n            charset=\"UTF-8\";\n        response.setCharacterEncoding(charset);\n        response.setContentType(\"text/html\");\n\n        if (info != null && info.indexOf(\"Locale/\") >= 0)\n        {\n            try\n            {\n                String locale_name= info.substring(info.indexOf(\"Locale/\") + 7);\n                Field f= java.util.Locale.class.getField(locale_name);\n                response.setLocale((Locale)f.get(null));\n            }\n            catch (Exception e)\n            {\n                e.printStackTrace();\n                response.setLocale(Locale.getDefault());\n            }\n        }\n\n        String cn= request.getParameter(\"cookie\");\n        String cv=request.getParameter(\"cookiev\");\n        if (cn!=null && cv!=null)\n        {\n            Cookie cookie= new Cookie(cn, cv);\n            if (request.getParameter(\"version\")!=null)\n                cookie.setVersion(Integer.parseInt(request.getParameter(\"version\")));\n            cookie.setComment(\"Cookie from dump servlet\");\n            response.addCookie(cookie);\n        }\n\n        String pi= request.getPathInfo();\n        if (pi != null && pi.startsWith(\"/ex\"))\n        {\n            OutputStream out= response.getOutputStream();\n            out.write(\"<\/H1>This text should be reset<\/H1>\".getBytes());\n            if (\"/ex0\".equals(pi))\n                throw new ServletException(\"test ex0\", new Throwable());\n            else if (\"/ex1\".equals(pi))\n                throw new IOException(\"test ex1\");\n            else if (\"/ex2\".equals(pi))\n                throw new UnavailableException(\"test ex2\");\n            else if (pi.startsWith(\"/ex3/\"))\n                throw new UnavailableException(\"test ex3\",Integer.parseInt(pi.substring(5)));\n            throw new RuntimeException(\"test\");\n        }\n\n        if (\"true\".equals(request.getParameter(\"close\")))\n            response.setHeader(\"Connection\",\"close\");\n\n        String buffered= request.getParameter(\"buffered\");\n\n        PrintWriter pout=null;\n\n        try\n        {\n            pout =response.getWriter();\n        }\n        catch(IllegalStateException e)\n        {\n            pout=new PrintWriter(new OutputStreamWriter(response.getOutputStream(),charset));\n        }\n        if (buffered!=null)\n            pout = new PrintWriter(new BufferedWriter(pout,Integer.parseInt(buffered)));\n\n        try\n        {\n            pout.write(\"<html>\\n<body>\\n\");\n            pout.write(\"<h1>Dump Servlet<\/h1>\\n\");\n            pout.write(\"<table width=\\\"95%\\\">\");\n            pout.write(\"<tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContentLength:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getContentLength())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContentType:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getContentType())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getContextPath:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getContextPath()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getDispatcherType:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getDispatcherType()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocale:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocale()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalName:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocalName()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalAddr:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getLocalAddr()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getLocalPort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getLocalPort())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getMethod:&nbsp;<\/th>\");\n            pout.write(\"<td>\" + notag(request.getMethod())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getPathInfo:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getPathInfo())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getPathTranslated:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getPathTranslated())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getProtocol:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getProtocol()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getQueryString:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getQueryString())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteAddr:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteAddr()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteHost:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteHost()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemotePort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemotePort()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRemoteUser:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRemoteUser()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestedSessionId:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getRequestedSessionId()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestURI:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getRequestURI())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getRequestURL:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getRequestURL().toString())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getScheme:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getScheme()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServerName:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getServerName())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServletPath:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+notag(request.getServletPath())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getServerPort:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+Integer.toString(request.getServerPort())+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">getUserPrincipal:&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.getUserPrincipal()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">isAsyncStarted():&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.isAsyncStarted()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">isAsyncSupported():&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.isAsyncSupported()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">isSecure():&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.isSecure()+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">isUserInRole(admin):&nbsp;<\/th>\");\n            pout.write(\"<td>\"+request.isUserInRole(\"admin\")+\"<\/td>\");\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"right\\\">encodeRedirectURL(/foo?bar):&nbsp;<\/th>\");\n            pout.write(\"<td>\"+response.encodeRedirectURL(\"/foo?bar\")+\"<\/td>\");\n\n\n            Enumeration<Locale> locales= request.getLocales();\n            while (locales.hasMoreElements())\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getLocales:&nbsp;<\/th>\");\n                pout.write(\"<td>\"+locales.nextElement()+\"<\/td>\");\n            }\n            pout.write(\"<\/tr><tr>\\n\");\n\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Other HTTP Headers:<\/big><\/th>\");\n            Enumeration<String> h= request.getHeaderNames();\n            String name;\n            while (h.hasMoreElements())\n            {\n                name= (String)h.nextElement();\n\n                Enumeration<String> h2= request.getHeaders(name);\n                while (h2.hasMoreElements())\n                {\n                    String hv= (String)h2.nextElement();\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\":&nbsp;<\/th>\");\n                    pout.write(\"<td>\"+notag(hv)+\"<\/td>\");\n                }\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Request Parameters:<\/big><\/th>\");\n            h= request.getParameterNames();\n            while (h.hasMoreElements())\n            {\n                name= (String)h.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+notag(request.getParameter(name))+\"<\/td>\");\n                String[] values= request.getParameterValues(name);\n                if (values == null)\n                {\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\" Values:&nbsp;<\/th>\");\n                    pout.write(\"<td>\"+\"NULL!\"+\"<\/td>\");\n                }\n                else if (values.length > 1)\n                {\n                    for (int i= 0; i < values.length; i++)\n                    {\n                        pout.write(\"<\/tr><tr>\\n\");\n                        pout.write(\"<th align=\\\"right\\\">\"+notag(name)+\"[\"+i+\"]:&nbsp;<\/th>\");\n                        pout.write(\"<td>\"+notag(values[i])+\"<\/td>\");\n                    }\n                }\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Cookies:<\/big><\/th>\");\n            Cookie[] cookies = request.getCookies();\n            for (int i=0; cookies!=null && i<cookies.length;i++)\n            {\n                Cookie cookie = cookies[i];\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+notag(cookie.getName())+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+notag(cookie.getValue())+\"<\/td>\");\n            }\n\n            String content_type=request.getContentType();\n            if (content_type!=null &&\n                !content_type.startsWith(\"application/x-www-form-urlencoded\") &&\n                !content_type.startsWith(\"multipart/form-data\"))\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"left\\\" valign=\\\"top\\\" colspan=\\\"2\\\"><big><br/>Content:<\/big><\/th>\");\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<td><pre>\");\n                char[] content= new char[4096];\n                int len;\n                try{\n                    Reader in=request.getReader();\n\n                    while((len=in.read(content))>=0)\n                        pout.write(notag(new String(content,0,len)));\n                }\n                catch(IOException e)\n                {\n                    pout.write(e.toString());\n                }\n\n                pout.write(\"<\/pre><\/td>\");\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Request Attributes:<\/big><\/th>\");\n            Enumeration<String> a= request.getAttributeNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                Object value=request.getAttribute(name);\n                if (value instanceof File)\n                {\n                    File file = (File)value;\n                    pout.write(\"<td>\"+\"<pre>\" + file.getName()+\" (\"+file.length()+\" \"+new Date(file.lastModified())+ \")<\/pre>\"+\"<\/td>\");\n                }\n                else\n                    pout.write(\"<td>\"+\"<pre>\" + toString(request.getAttribute(name)) + \"<\/pre>\"+\"<\/td>\");\n            }\n            request.setAttribute(\"org.eclipse.jetty.servlet.MultiPartFilter.files\",null);\n\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Servlet InitParameters:<\/big><\/th>\");\n            a= getInitParameterNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">\"+name+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+ toString(getInitParameter(name)) +\"<\/td>\");\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Context InitParameters:<\/big><\/th>\");\n            a= getServletContext().getInitParameterNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+ toString(getServletContext().getInitParameter(name)) + \"<\/td>\");\n            }\n\n            pout.write(\"<\/tr><tr>\\n\");\n            pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Context Attributes:<\/big><\/th>\");\n            a= getServletContext().getAttributeNames();\n            while (a.hasMoreElements())\n            {\n                name= (String)a.nextElement();\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\" valign=\\\"top\\\">\"+name.replace(\".\",\" .\")+\":&nbsp;<\/th>\");\n                pout.write(\"<td>\"+\"<pre>\" + toString(getServletContext().getAttribute(name)) + \"<\/pre>\"+\"<\/td>\");\n            }\n\n            String res= request.getParameter(\"resource\");\n            if (res != null && res.length() > 0)\n            {\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"left\\\" colspan=\\\"2\\\"><big><br/>Get Resource: \\\"\"+res+\"\\\"<\/big><\/th>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getServletContext().getResource(...):&nbsp;<\/th>\");\n                try{pout.write(\"<td>\"+getServletContext().getResource(res)+\"<\/td>\");}\n                catch(Exception e) {pout.write(\"<td>\"+\"\" +e+\"<\/td>\");}\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getServletContext().getResourcePaths(...):&nbsp;<\/th>\");\n                try{pout.write(\"<td>\"+getServletContext().getResourcePaths(res)+\"<\/td>\");}\n                catch(Exception e) {pout.write(\"<td>\"+\"\" +e+\"<\/td>\");}\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">getServletContext().getContext(...):&nbsp;<\/th>\");\n\n                ServletContext context = getServletContext().getContext(res);\n                pout.write(\"<td>\"+context+\"<\/td>\");\n\n                if (context!=null)\n                {\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">getServletContext().getContext(...).getResource(...):&nbsp;<\/th>\");\n                    try{pout.write(\"<td>\"+context.getResource(res)+\"<\/td>\");}\n                    catch(Exception e) {pout.write(\"<td>\"+\"\" +e+\"<\/td>\");}\n\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">getServletContext().getContext(...).getResourcePaths(...):&nbsp;<\/th>\");\n                    try{pout.write(\"<td>\"+context.getResourcePaths(res)+\"<\/td>\");}\n                    catch(Exception e) {pout.write(\"<td>\"+\"\" +e+\"<\/td>\");}\n\n                    String cp=context.getContextPath();\n                    if (cp==null || \"/\".equals(cp))\n                        cp=\"\";\n                    pout.write(\"<\/tr><tr>\\n\");\n                    pout.write(\"<th align=\\\"right\\\">getServletContext().getContext(...),getRequestDispatcher(...):&nbsp;<\/th>\");\n                    pout.write(\"<td>\"+getServletContext().getContext(res).getRequestDispatcher(res.substring(cp.length()))+\"<\/td>\");\n                }\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">this.getClass().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+this.getClass().getResource(res)+\"<\/td>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">this.getClass().getClassLoader().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+this.getClass().getClassLoader().getResource(res)+\"<\/td>\");\n\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">Thread.currentThread().getContextClassLoader().getResource(...):&nbsp;<\/th>\");\n                pout.write(\"<td>\"+Thread.currentThread().getContextClassLoader().getResource(res)+\"<\/td>\");\n                pout.write(\"<\/tr><tr>\\n\");\n                pout.write(\"<th align=\\\"right\\\">Thread.currentThread().getContextClassLoader().getResources(...):&nbsp;<\/th>\");\n                Enumeration<URL> urls = Thread.currentThread().getContextClassLoader().getResources(res);\n                if (urls==null)\n                    pout.write(\"<td>null<\/td>\");\n                else\n                    pout.write(\"<td>\"+Collections.list(urls)+\"<\/td>\");\n\n            }\n\n            pout.write(\"<\/tr><\/table>\\n\");\n\n            /* ------------------------------------------------------------ */\n            pout.write(\"<h2>Request Wrappers<\/h2>\\n\");\n            ServletRequest rw=request;\n            int w=0;\n            while (rw !=null)\n            {\n                pout.write((w++)+\": \"+rw.getClass().getName()+\"<br/>\");\n                if (rw instanceof HttpServletRequestWrapper)\n                    rw=((HttpServletRequestWrapper)rw).getRequest();\n                else if (rw instanceof ServletRequestWrapper)\n                    rw=((ServletRequestWrapper)rw).getRequest();\n                else\n                    rw=null;\n            }\n\n            /* ------------------------------------------------------------ */\n            pout.write(\"<h2>Response Wrappers<\/h2>\\n\");\n            ServletResponse rsw=response;\n            w=0;\n            while (rsw !=null)\n            {\n                pout.write((w++)+\": \"+rsw.getClass().getName()+\"<br/>\");\n                if (rsw instanceof HttpServletResponseWrapper)\n                    rsw=((HttpServletResponseWrapper)rsw).getResponse();\n                else if (rsw instanceof ServletResponseWrapper)\n                    rsw=((ServletResponseWrapper)rsw).getResponse();\n                else\n                    rsw=null;\n            }\n\n            pout.write(\"<br/>\");\n            pout.write(\"<h2>International Characters (UTF-8)<\/h2>\");\n            pout.write(\"LATIN LETTER SMALL CAPITAL AE<br/>\\n\");\n            pout.write(\"Directly uni encoded(\\\\u1d01): \\u1d01<br/>\");\n            pout.write(\"HTML reference (&amp;AElig;): &AElig;<br/>\");\n            pout.write(\"Decimal (&amp;#7425;): &#7425;<br/>\");\n            pout.write(\"Javascript unicode (\\\\u1d01) : <script language='javascript'>document.write(\\\"\\u1d01\\\");<\/script><br/>\");\n            pout.write(\"<br/>\");\n            pout.write(\"<h2>Form to generate GET content<\/h2>\");\n            pout.write(\"<form method=\\\"GET\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"value\\\"/><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\">\");\n            pout.write(\"<\/form>\");\n\n            pout.write(\"<br/>\");\n\n            pout.write(\"<h2>Form to generate POST content<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" accept-charset=\\\"utf-8\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"value\\\"/><br/>\\n\");\n            pout.write(\"Select: <select multiple name=\\\"Select\\\">\\n\");\n            pout.write(\"<option>ValueA<\/option>\");\n            pout.write(\"<option>ValueB1,ValueB2<\/option>\");\n            pout.write(\"<option>ValueC<\/option>\");\n            pout.write(\"<\/select><br/>\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\"><br/>\");\n            pout.write(\"<\/form>\");\n            pout.write(\"<br/>\");\n\n            pout.write(\"<h2>Form to generate UPLOAD content<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" enctype=\\\"multipart/form-data\\\" accept-charset=\\\"utf-8\\\" action=\\\"\"+\n                    response.encodeURL(getURI(request))+(request.getQueryString()==null?\"\":(\"?\"+request.getQueryString()))+\n                    \"\\\">\");\n            pout.write(\"TextField: <input type=\\\"text\\\" name=\\\"TextField\\\" value=\\\"comment\\\"/><br/>\\n\");\n            pout.write(\"File 1: <input type=\\\"file\\\" name=\\\"file1\\\" /><br/>\\n\");\n            pout.write(\"File 2: <input type=\\\"file\\\" name=\\\"file2\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"Submit\\\"><br/>\");\n            pout.write(\"<\/form>\");\n\n            pout.write(\"<h2>Form to set Cookie<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"cookie: <input type=\\\"text\\\" name=\\\"cookie\\\" /><br/>\\n\");\n            pout.write(\"value: <input type=\\\"text\\\" name=\\\"cookiev\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"setCookie\\\">\");\n            pout.write(\"<\/form>\\n\");\n\n            pout.write(\"<h2>Form to get Resource<\/h2>\");\n            pout.write(\"<form method=\\\"POST\\\" action=\\\"\"+response.encodeURL(getURI(request))+\"\\\">\");\n            pout.write(\"resource: <input type=\\\"text\\\" name=\\\"resource\\\" /><br/>\\n\");\n            pout.write(\"<input type=\\\"submit\\\" name=\\\"Action\\\" value=\\\"getResource\\\">\");\n            pout.write(\"<\/form>\\n\");\n        }\n        catch (Exception e)\n        {\n            getServletContext().log(\"dump \"+e);\n        }\n\n        String lines= request.getParameter(\"lines\");\n        if (lines!=null)\n        {\n            char[] line = \"<span>A line of characters. Blah blah blah blah.  blooble blooble<\/span><\/br>\\n\".toCharArray();\n            for (int l=Integer.parseInt(lines);l-->0;)\n            {\n                pout.write(\"<span>\"+l+\" <\/span>\");\n                pout.write(line);\n            }\n        }\n\n        pout.write(\"<\/body>\\n<\/html>\\n\");\n\n        pout.close();\n\n        if (pi != null)\n        {\n            if (\"/ex4\".equals(pi))\n                throw new ServletException(\"test ex4\", new Throwable());\n            if (\"/ex5\".equals(pi))\n                throw new IOException(\"test ex5\");\n            if (\"/ex6\".equals(pi))\n                throw new UnavailableException(\"test ex6\");\n        }\n\n\n    }","commit_id":"7dec90fafb8c219ca4a2a98b3b97afe470eec397","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void contextInitialized(ServletContextEvent sce)\n    {\t\n        // System.err.println(\"contextInitialized \"+sce);\n        _called.put(\"contextInitialized\",new Throwable());\n\n        //configure programmatic security\n        ServletRegistration.Dynamic rego = sce.getServletContext().addServlet(\"RegoTest\", RegTest.class.getName());\n        rego.addMapping(\"/rego/*\");\n        HttpConstraintElement constraintElement = new HttpConstraintElement(ServletSecurity.EmptyRoleSemantic.PERMIT, \n            ServletSecurity.TransportGuarantee.NONE, new String[]{\"admin\"});\n        ServletSecurityElement securityElement = new ServletSecurityElement(constraintElement, null);\n        Set<String> unchanged = rego.setServletSecurity(securityElement);\n        //// System.err.println(\"Security constraints registered: \"+unchanged.isEmpty());\n\n        //Test that a security constraint from web.xml can't be overridden programmatically\n        ServletRegistration.Dynamic rego2 = sce.getServletContext().addServlet(\"RegoTest2\", RegTest.class.getName());\n        rego2.addMapping(\"/rego2/*\");\n        securityElement = new ServletSecurityElement(constraintElement, null);\n        unchanged = rego2.setServletSecurity(securityElement);\n        //// System.err.println(\"Overridding web.xml constraints not possible:\" +!unchanged.isEmpty());\n\n        /* For servlet 3.0 */\n        FilterRegistration.Dynamic registration = sce.getServletContext().addFilter(\"TestFilter\",TestFilter.class.getName());\n        if (registration != null) //otherwise defined in web.xml\n        {\n            registration.setInitParameter(\"remote\", \"false\");\n            registration.setAsyncSupported(true);\n            registration.addMappingForUrlPatterns(\n                                                  EnumSet.of(DispatcherType.ERROR,DispatcherType.ASYNC,DispatcherType.FORWARD,DispatcherType.INCLUDE,DispatcherType.REQUEST),\n                                                  true, \n                                                  new String[]{\"/*\"});\n        }\n    }","id":78119,"modified_method":"@Override\n    public void contextInitialized(ServletContextEvent sce)\n    {\t\n        // System.err.println(\"contextInitialized \"+sce);\n        _called.put(\"contextInitialized\",new Throwable());\n\n        //configure programmatic security\n        ServletRegistration.Dynamic rego = sce.getServletContext().addServlet(\"RegoTest\", RegTest.class.getName());\n        rego.addMapping(\"/rego/*\");\n        HttpConstraintElement constraintElement = new HttpConstraintElement(ServletSecurity.EmptyRoleSemantic.PERMIT, \n            ServletSecurity.TransportGuarantee.NONE, new String[]{\"admin\"});\n        ServletSecurityElement securityElement = new ServletSecurityElement(constraintElement, null);\n        Set<String> unchanged = rego.setServletSecurity(securityElement);\n        //// System.err.println(\"Security constraints registered: \"+unchanged.isEmpty());\n\n        //Test that a security constraint from web.xml can't be overridden programmatically\n        ServletRegistration.Dynamic rego2 = sce.getServletContext().addServlet(\"RegoTest2\", RegTest.class.getName());\n        rego2.addMapping(\"/rego2/*\");\n        securityElement = new ServletSecurityElement(constraintElement, null);\n        unchanged = rego2.setServletSecurity(securityElement);\n        //// System.err.println(\"Overridding web.xml constraints not possible:\" +!unchanged.isEmpty());\n\n        /* For servlet 3.0 */\n        FilterRegistration registration = sce.getServletContext().addFilter(\"TestFilter\",TestFilter.class.getName());\n        if (registration != null) //otherwise defined in web.xml\n        {\n            ((FilterRegistration.Dynamic)registration).setAsyncSupported(true);\n        }\n        else\n        {\n            registration=sce.getServletContext().getFilterRegistration(\"TestFilter\");\n        }\n        registration.setInitParameter(\"remote\", \"false\");\n        registration.addMappingForUrlPatterns(\n                EnumSet.of(DispatcherType.ERROR,DispatcherType.ASYNC,DispatcherType.FORWARD,DispatcherType.INCLUDE,DispatcherType.REQUEST),\n                true, \n                new String[]{\"/*\"});\n    }","commit_id":"7dec90fafb8c219ca4a2a98b3b97afe470eec397","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static void main(String[] args) throws Exception\n    {\n        ((StdErrLog)Log.getLog()).setSource(false);\n\n        String jetty_root = \"../../..\";\n\n        // Setup Threadpool\n        QueuedThreadPool threadPool = new QueuedThreadPool();\n        threadPool.setMaxThreads(100);\n\n        // Setup server\n        Server server = new Server(threadPool);\n        server.manage(threadPool);\n\n        // Setup JMX\n        MBeanContainer mbContainer=new MBeanContainer(ManagementFactory.getPlatformMBeanServer());\n        server.addBean(mbContainer);\n        server.addBean(Log.getLog());\n        \n\n        // Common HTTP configuration\n        HttpConfiguration config = new HttpConfiguration();\n        config.setSecurePort(8443);\n        config.addCustomizer(new ForwardedRequestCustomizer());\n        config.addCustomizer(new SecureRequestCustomizer());\n        config.setSendDateHeader(true);\n        config.setSendServerVersion(true);\n        \n        \n        // Http Connector\n        HttpConnectionFactory http = new HttpConnectionFactory(config);\n        ServerConnector httpConnector = new ServerConnector(server,http);\n        httpConnector.setPort(8080);\n        httpConnector.setIdleTimeout(30000);\n        server.addConnector(httpConnector);\n\n        \n        // SSL configurations\n        SslContextFactory sslContextFactory = new SslContextFactory();\n        sslContextFactory.setKeyStorePath(jetty_root + \"/jetty-server/src/main/config/etc/keystore\");\n        sslContextFactory.setKeyStorePassword(\"OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4\");\n        sslContextFactory.setKeyManagerPassword(\"OBF:1u2u1wml1z7s1z7a1wnl1u2g\");\n        sslContextFactory.setTrustStorePath(jetty_root + \"/jetty-server/src/main/config/etc/keystore\");\n        sslContextFactory.setTrustStorePassword(\"OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4\");\n        sslContextFactory.setExcludeCipherSuites(\n                \"SSL_RSA_WITH_DES_CBC_SHA\",\n                \"SSL_DHE_RSA_WITH_DES_CBC_SHA\",\n                \"SSL_DHE_DSS_WITH_DES_CBC_SHA\",\n                \"SSL_RSA_EXPORT_WITH_RC4_40_MD5\",\n                \"SSL_RSA_EXPORT_WITH_DES40_CBC_SHA\",\n                \"SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\",\n                \"SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\");\n        \n        \n        // Spdy Connector\n        SPDYServerConnectionFactory.checkNPNAvailable();\n        PushStrategy push = new ReferrerPushStrategy();\n        HTTPSPDYServerConnectionFactory spdy2 = new HTTPSPDYServerConnectionFactory(2,config,push);\n        spdy2.setInputBufferSize(8192);\n        spdy2.setInitialWindowSize(32768);\n        HTTPSPDYServerConnectionFactory spdy3 = new HTTPSPDYServerConnectionFactory(3,config,push);\n        spdy2.setInputBufferSize(8192);\n        NPNServerConnectionFactory npn = new NPNServerConnectionFactory(spdy3.getProtocol(),spdy2.getProtocol(),http.getProtocol());\n        npn.setDefaultProtocol(http.getProtocol());\n        npn.setInputBufferSize(1024); \n        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory,npn.getProtocol()); \n        ServerConnector spdyConnector = new ServerConnector(server,ssl,npn,spdy3,spdy2,http);\n        spdyConnector.setPort(8443);\n        spdyConnector.setIdleTimeout(15000);\n        server.addConnector(spdyConnector);\n        \n        \n        \n        // Handlers\n        HandlerCollection handlers = new HandlerCollection();\n        ContextHandlerCollection contexts = new ContextHandlerCollection();\n        RequestLogHandler requestLogHandler = new RequestLogHandler();\n        handlers.setHandlers(new Handler[]\n        { contexts, new DefaultHandler(), requestLogHandler });\n\n        // Add restart handler to test the ability to save sessions and restart\n        RestartHandler restart = new RestartHandler();\n        restart.setHandler(handlers);\n\n        server.setHandler(restart);\n\n\n        // Setup context\n        HashLoginService login = new HashLoginService();\n        login.setName(\"Test Realm\");\n        login.setConfig(jetty_root + \"/tests/test-webapps/test-jetty-webapp/src/main/config/demo-base/etc/realm.properties\");\n        server.addBean(login);\n\n        File log=File.createTempFile(\"jetty-yyyy_mm_dd\", \"log\");\n        NCSARequestLog requestLog = new NCSARequestLog(log.toString());\n        requestLog.setExtended(false);\n        requestLogHandler.setRequestLog(requestLog);\n\n        server.setStopAtShutdown(true);\n\n        WebAppContext webapp = new WebAppContext();\n        webapp.setParentLoaderPriority(true);\n        webapp.setResourceBase(\"./src/main/webapp\");\n        webapp.setAttribute(\"testAttribute\",\"testValue\");\n        File sessiondir=File.createTempFile(\"sessions\",null);\n        if (sessiondir.exists())\n            sessiondir.delete();\n        sessiondir.mkdir();\n        sessiondir.deleteOnExit();\n        ((HashSessionManager)webapp.getSessionHandler().getSessionManager()).setStoreDirectory(sessiondir);\n        ((HashSessionManager)webapp.getSessionHandler().getSessionManager()).setSavePeriod(10);\n\n        contexts.addHandler(webapp);\n\n        ContextHandler srcroot = new ContextHandler();\n        srcroot.setResourceBase(\".\");\n        srcroot.setHandler(new ResourceHandler());\n        srcroot.setContextPath(\"/src\");\n        contexts.addHandler(srcroot);\n\n        server.start();\n        server.join();\n    }","id":78120,"modified_method":"public static void main(String[] args) throws Exception\n    {\n        ((StdErrLog)Log.getLog()).setSource(false);\n\n        String jetty_root = \"../../..\";\n\n        // Setup Threadpool\n        QueuedThreadPool threadPool = new QueuedThreadPool();\n        threadPool.setMaxThreads(100);\n\n        // Setup server\n        Server server = new Server(threadPool);\n        server.manage(threadPool);\n\n        // Setup JMX\n        MBeanContainer mbContainer=new MBeanContainer(ManagementFactory.getPlatformMBeanServer());\n        server.addBean(mbContainer);\n        server.addBean(Log.getLog());\n        \n\n        // Common HTTP configuration\n        HttpConfiguration config = new HttpConfiguration();\n        config.setSecurePort(8443);\n        config.addCustomizer(new ForwardedRequestCustomizer());\n        config.addCustomizer(new SecureRequestCustomizer());\n        config.setSendDateHeader(true);\n        config.setSendServerVersion(true);\n        \n        \n        // Http Connector\n        HttpConnectionFactory http = new HttpConnectionFactory(config);\n        ServerConnector httpConnector = new ServerConnector(server,http);\n        httpConnector.setPort(8080);\n        httpConnector.setIdleTimeout(30000);\n        server.addConnector(httpConnector);\n\n        /*\n        // SSL configurations\n        SslContextFactory sslContextFactory = new SslContextFactory();\n        sslContextFactory.setKeyStorePath(jetty_root + \"/jetty-server/src/main/config/etc/keystore\");\n        sslContextFactory.setKeyStorePassword(\"OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4\");\n        sslContextFactory.setKeyManagerPassword(\"OBF:1u2u1wml1z7s1z7a1wnl1u2g\");\n        sslContextFactory.setTrustStorePath(jetty_root + \"/jetty-server/src/main/config/etc/keystore\");\n        sslContextFactory.setTrustStorePassword(\"OBF:1vny1zlo1x8e1vnw1vn61x8g1zlu1vn4\");\n        sslContextFactory.setExcludeCipherSuites(\n                \"SSL_RSA_WITH_DES_CBC_SHA\",\n                \"SSL_DHE_RSA_WITH_DES_CBC_SHA\",\n                \"SSL_DHE_DSS_WITH_DES_CBC_SHA\",\n                \"SSL_RSA_EXPORT_WITH_RC4_40_MD5\",\n                \"SSL_RSA_EXPORT_WITH_DES40_CBC_SHA\",\n                \"SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA\",\n                \"SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\");\n        \n        \n        // Spdy Connector\n        SPDYServerConnectionFactory.checkNPNAvailable();\n        PushStrategy push = new ReferrerPushStrategy();\n        HTTPSPDYServerConnectionFactory spdy2 = new HTTPSPDYServerConnectionFactory(2,config,push);\n        spdy2.setInputBufferSize(8192);\n        spdy2.setInitialWindowSize(32768);\n        HTTPSPDYServerConnectionFactory spdy3 = new HTTPSPDYServerConnectionFactory(3,config,push);\n        spdy2.setInputBufferSize(8192);\n        NPNServerConnectionFactory npn = new NPNServerConnectionFactory(spdy3.getProtocol(),spdy2.getProtocol(),http.getProtocol());\n        npn.setDefaultProtocol(http.getProtocol());\n        npn.setInputBufferSize(1024); \n        SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory,npn.getProtocol()); \n        ServerConnector spdyConnector = new ServerConnector(server,ssl,npn,spdy3,spdy2,http);\n        spdyConnector.setPort(8443);\n        spdyConnector.setIdleTimeout(15000);\n        server.addConnector(spdyConnector);\n        \n        */\n        \n        // Handlers\n        HandlerCollection handlers = new HandlerCollection();\n        ContextHandlerCollection contexts = new ContextHandlerCollection();\n        RequestLogHandler requestLogHandler = new RequestLogHandler();\n        handlers.setHandlers(new Handler[]\n        { contexts, new DefaultHandler(), requestLogHandler });\n\n        // Add restart handler to test the ability to save sessions and restart\n        RestartHandler restart = new RestartHandler();\n        restart.setHandler(handlers);\n\n        server.setHandler(restart);\n\n\n        // Setup context\n        HashLoginService login = new HashLoginService();\n        login.setName(\"Test Realm\");\n        login.setConfig(jetty_root + \"/tests/test-webapps/test-jetty-webapp/src/main/config/demo-base/etc/realm.properties\");\n        server.addBean(login);\n\n        File log=File.createTempFile(\"jetty-yyyy_mm_dd\", \"log\");\n        NCSARequestLog requestLog = new NCSARequestLog(log.toString());\n        requestLog.setExtended(false);\n        requestLogHandler.setRequestLog(requestLog);\n\n        server.setStopAtShutdown(true);\n\n        WebAppContext webapp = new WebAppContext();\n        webapp.setParentLoaderPriority(true);\n        webapp.setResourceBase(\"./src/main/webapp\");\n        webapp.setAttribute(\"testAttribute\",\"testValue\");\n        File sessiondir=File.createTempFile(\"sessions\",null);\n        if (sessiondir.exists())\n            sessiondir.delete();\n        sessiondir.mkdir();\n        sessiondir.deleteOnExit();\n        ((HashSessionManager)webapp.getSessionHandler().getSessionManager()).setStoreDirectory(sessiondir);\n        ((HashSessionManager)webapp.getSessionHandler().getSessionManager()).setSavePeriod(10);\n\n        contexts.addHandler(webapp);\n\n        ContextHandler srcroot = new ContextHandler();\n        srcroot.setResourceBase(\".\");\n        srcroot.setHandler(new ResourceHandler());\n        srcroot.setContextPath(\"/src\");\n        contexts.addHandler(srcroot);\n\n        server.start();\n        server.join();\n    }","commit_id":"7dec90fafb8c219ca4a2a98b3b97afe470eec397","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected static void setupLayoutSetPrototype(long companyId)\n\t\tthrows Exception {\n\n\t\tLayoutSetPrototype layoutSetPrototype = addLayoutSetPrototype(\n\t\t\tcompanyId, \"Default Social Office Site\");\n\n\t\tExpandoValueLocalServiceUtil.addValue(\n\t\t\tLayoutSetPrototype.class.getName(),\n\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME, \"socialOfficeDefault\",\n\t\t\tlayoutSetPrototype.getLayoutSetPrototypeId(), true);\n\n\t\tGroup group = layoutSetPrototype.getGroup();\n\n\t\tLayoutLocalServiceUtil.deleteLayouts(group.getGroupId(), true);\n\n\t\tLayoutSetLocalServiceUtil.updateLookAndFeel(\n\t\t\tgroup.getGroupId(), \"so_WAR_sotheme\", \"01\", \"\", false);\n\n\t\t// Home\n\n\t\tLayout layout = addLayout(\n\t\t\tgroup, \"Home\", \"/home\",\n\t\t\tPortletPropsValues.SITE_PROTOTYPE_LAYOUT_TEMPLATE);\n\n\t\taddPortlets(group, layout, \"/home\");\n\n\t\tconfigureRSS(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Calendar\n\n\t\tlayout = addLayout(group, \"Calendar\", \"/calendar\", \"1_column\");\n\n\t\taddPortlets(group, layout, \"/calendar\");\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Documents\n\n\t\tlayout = addLayout(group, \"Documents\", \"/documents\", \"2_columns_iii\");\n\n\t\taddPortlets(group, layout, \"/documents\");\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Forums\n\n\t\tlayout = addLayout(group, \"Forums\", \"/forums\", \"2_columns_iii\");\n\n\t\taddPortlets(group, layout, \"/forums\");\n\n\t\tconfigureAssetPublisher(layout);\n\t\tconfigureMessageBoards(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Blog\n\n\t\tlayout = addLayout(group, \"Blog\", \"/blog\", \"2_columns_iii\");\n\n\t\taddPortlets(group, layout, \"/blog\");\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Wiki\n\n\t\tlayout = addLayout(group, \"Wiki\", \"/wiki\", \"2_columns_iii\");\n\n\t\taddPortlets(group, layout, \"/wiki\");\n\n\t\tconfigureAssetPublisher(layout);\n\n\t\tupdatePermissions(layout, true);\n\n\t\t// Members\n\n\t\tlayout = addLayout(group, \"Members\", \"/members\", \"1_column\");\n\n\t\taddPortlets(group, layout, \"/members\");\n\n\t\tremovePortletBorder(layout, \"2_WAR_soportlet\");\n\n\t\tupdatePermissions(layout, true);\n\t}","id":78121,"modified_method":"protected static void setupLayoutSetPrototype(long companyId)\n\t\tthrows Exception {\n\n\t\tLayoutSetPrototype layoutSetPrototype = addLayoutSetPrototype(\n\t\t\tcompanyId, \"Default Social Office Site\");\n\n\t\tExpandoValueLocalServiceUtil.addValue(\n\t\t\tLayoutSetPrototype.class.getName(),\n\t\t\tExpandoTableConstants.DEFAULT_TABLE_NAME, \"socialOfficeDefault\",\n\t\t\tlayoutSetPrototype.getLayoutSetPrototypeId(), true);\n\n\t\tGroup group = layoutSetPrototype.getGroup();\n\n\t\tLayoutLocalServiceUtil.deleteLayouts(group.getGroupId(), true);\n\n\t\tLayoutSetLocalServiceUtil.updateLookAndFeel(\n\t\t\tgroup.getGroupId(), \"so_WAR_sotheme\", \"01\", \"\", false);\n\n\t\t// Home\n\n\t\tLayout layout = LayoutUtil.addLayout(\n\t\t\tgroup, true, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Home\",\n\t\t\tPortletPropsValues.SITE_PROTOTYPE_LAYOUT_TEMPLATE);\n\n\t\tLayoutUtil.addPortlets(\n\t\t\tgroup, layout, \"/home\", PortletPropsKeys.SITE_PROTOTYPE_PORTLETS);\n\n\t\tLayoutUtil.configureRSS(layout);\n\n\t\tLayoutUtil.updatePermissions(layout, true);\n\n\t\t// Calendar\n\n\t\tlayout = LayoutUtil.addLayout(\n\t\t\tgroup, true, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Calendar\",\n\t\t\t\"1_column\");\n\n\t\tLayoutUtil.addPortlets(\n\t\t\tgroup, layout, \"/calendar\",\n\t\t\tPortletPropsKeys.SITE_PROTOTYPE_PORTLETS);\n\n\t\tLayoutUtil.updatePermissions(layout, true);\n\n\t\t// Documents\n\n\t\tlayout = LayoutUtil.addLayout(\n\t\t\tgroup, true, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Documents\",\n\t\t\t\"2_columns_iii\");\n\n\t\tLayoutUtil.addPortlets(\n\t\t\tgroup, layout, \"/documents\",\n\t\t\tPortletPropsKeys.SITE_PROTOTYPE_PORTLETS);\n\n\t\tLayoutUtil.configureAssetPublisher(layout);\n\n\t\tLayoutUtil.updatePermissions(layout, true);\n\n\t\t// Forums\n\n\t\tlayout = LayoutUtil.addLayout(\n\t\t\tgroup, true, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Forums\",\n\t\t\t\"2_columns_iii\");\n\n\t\tLayoutUtil.addPortlets(\n\t\t\tgroup, layout, \"/forums\", PortletPropsKeys.SITE_PROTOTYPE_PORTLETS);\n\n\t\tLayoutUtil.configureAssetPublisher(layout);\n\t\tLayoutUtil.configureMessageBoards(layout);\n\n\t\tLayoutUtil.updatePermissions(layout, true);\n\n\t\t// Blog\n\n\t\tlayout = LayoutUtil.addLayout(\n\t\t\tgroup, true, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Blog\",\n\t\t\t\"2_columns_iii\");\n\n\t\tLayoutUtil.addPortlets(\n\t\t\tgroup, layout, \"/blog\", PortletPropsKeys.SITE_PROTOTYPE_PORTLETS);\n\n\t\tLayoutUtil.configureAssetPublisher(layout);\n\n\t\tLayoutUtil.updatePermissions(layout, true);\n\n\t\t// Wiki\n\n\t\tlayout = LayoutUtil.addLayout(\n\t\t\tgroup, true, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Wiki\",\n\t\t\t\"2_columns_iii\");\n\n\t\tLayoutUtil.addPortlets(\n\t\t\tgroup, layout, \"/wiki\", PortletPropsKeys.SITE_PROTOTYPE_PORTLETS);\n\n\t\tLayoutUtil.configureAssetPublisher(layout);\n\n\t\tLayoutUtil.updatePermissions(layout, true);\n\n\t\t// Members\n\n\t\tlayout = LayoutUtil.addLayout(\n\t\t\tgroup, true, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Members\",\n\t\t\t\"1_column\");\n\n\t\tLayoutUtil.addPortlets(\n\t\t\tgroup, layout, \"/members\",\n\t\t\tPortletPropsKeys.SITE_PROTOTYPE_PORTLETS);\n\n\t\tLayoutUtil.removePortletBorder(layout, \"2_WAR_soportlet\");\n\n\t\tLayoutUtil.updatePermissions(layout, true);\n\t}","commit_id":"79fb3e31ab10d8c9c55a579f567952049f717056","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addApplications(Group group, long parentLayoutId)\n\t\tthrows Exception {\n\n\t\tfor (String portletId : PortletPropsValues.USER_APPLICATIONS) {\n\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tgroup.getCompanyId(), portletId);\n\n\t\t\tif ((portlet == null) || portlet.isUndeployedPortlet()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLayout layout = addLayout(\n\t\t\t\tgroup, true, parentLayoutId, portlet.getDisplayName(),\n\t\t\t\t\"2_columns_ii\");\n\n\t\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tString[] commonPortletIds = PortletProps.getArray(\n\t\t\t\tPortletPropsKeys.USER_LAYOUT_PORTLETS + \"column-1\",\n\t\t\t\tnew Filter(\"/home\"));\n\n\t\t\tString portletIds = StringPool.BLANK;\n\n\t\t\tfor (String commonPortletId : commonPortletIds) {\n\t\t\t\tportletIds = StringUtil.add(portletIds, commonPortletId);\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setPortletIds(\"column-1\", portletIds);\n\t\t\tlayoutTypePortlet.setPortletIds(\"column-2\", portletId);\n\n\t\t\tLayoutLocalServiceUtil.updateLayout(\n\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\tlayout.getLayoutId(), layout.getTypeSettings());\n\n\t\t\taddResources(layout, portletId);\n\n\t\t\tfor (String commonPortletId : commonPortletIds) {\n\t\t\t\taddResources(layout, commonPortletId);\n\n\t\t\t\tif (commonPortletId.startsWith(\"71_INSTANCE_\")) {\n\t\t\t\t\tremovePortletBorder(layout, commonPortletId);\n\t\t\t\t\tconfigureNavigation(layout, commonPortletId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tupdatePermissions(layout, false);\n\t\t}\n\t}","id":78122,"modified_method":"protected void addApplications(Group group, long parentLayoutId)\n\t\tthrows Exception {\n\n\t\tfor (String portletId : PortletPropsValues.USER_APPLICATIONS) {\n\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tgroup.getCompanyId(), portletId);\n\n\t\t\tif ((portlet == null) || portlet.isUndeployedPortlet()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLayout layout = LayoutUtil.addLayout(\n\t\t\t\tgroup, true, parentLayoutId, portlet.getDisplayName(),\n\t\t\t\tPortletPropsValues.USER_NEW_LAYOUT_TEMPLATE);\n\n\t\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\tString[] commonPortletIds = PortletProps.getArray(\n\t\t\t\tPortletPropsKeys.USER_LAYOUT_PORTLETS + \"column-1\",\n\t\t\t\tnew Filter(\"/home\"));\n\n\t\t\tString portletIds = StringPool.BLANK;\n\n\t\t\tfor (String commonPortletId : commonPortletIds) {\n\t\t\t\tportletIds = StringUtil.add(portletIds, commonPortletId);\n\t\t\t}\n\n\t\t\tlayoutTypePortlet.setPortletIds(\"column-1\", portletIds);\n\t\t\tlayoutTypePortlet.setPortletIds(\"column-2\", portletId);\n\n\t\t\tLayoutLocalServiceUtil.updateLayout(\n\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\tlayout.getLayoutId(), layout.getTypeSettings());\n\n\t\t\tLayoutUtil.addResources(layout, portletId);\n\n\t\t\tfor (String commonPortletId : commonPortletIds) {\n\t\t\t\tLayoutUtil.addResources(layout, commonPortletId);\n\n\t\t\t\tif (commonPortletId.startsWith(\"71_INSTANCE_\")) {\n\t\t\t\t\tLayoutUtil.removePortletBorder(layout, commonPortletId);\n\t\t\t\t\tLayoutUtil.configureNavigation(layout, commonPortletId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLayoutUtil.updatePermissions(layout, false);\n\t\t}\n\t}","commit_id":"79fb3e31ab10d8c9c55a579f567952049f717056","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addPrivateUserLayouts(Group group) throws Exception {\n\t\tLayoutSetLocalServiceUtil.updateLookAndFeel(\n\t\t\tgroup.getGroupId(), true, \"so_WAR_sotheme\", \"01\", \"\", false);\n\n\t\tLayout layout = addLayout(\n\t\t\tgroup, true, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Home\",\n\t\t\t\"2_columns_ii\");\n\n\t\taddPortlets(group, layout, \"/home\");\n\n\t\tupdatePermissions(layout, false);\n\n\t\taddApplications(group, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\t}","id":78123,"modified_method":"protected void addPrivateUserLayouts(Group group) throws Exception {\n\t\tLayoutSetLocalServiceUtil.updateLookAndFeel(\n\t\t\tgroup.getGroupId(), true, \"so_WAR_sotheme\", \"01\", StringPool.BLANK,\n\t\t\tfalse);\n\n\t\tLayout layout = LayoutUtil.addLayout(\n\t\t\tgroup, true, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Home\",\n\t\t\tPortletPropsValues.USER_NEW_LAYOUT_TEMPLATE);\n\n\t\tLayoutUtil.addPortlets(\n\t\t\tgroup, layout, \"/home\", PortletPropsKeys.USER_LAYOUT_PORTLETS);\n\n\t\tLayoutUtil.updatePermissions(layout, false);\n\n\t\taddApplications(group, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID);\n\t}","commit_id":"79fb3e31ab10d8c9c55a579f567952049f717056","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void addPublicUserLayouts(Group group) throws Exception {\n\t\tLayoutSetLocalServiceUtil.updateLookAndFeel(\n\t\t\tgroup.getGroupId(), false, \"so_WAR_sotheme\", \"01\", \"\", false);\n\n\t\tLayout layout = addLayout(\n\t\t\tgroup, false, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Profile\",\n\t\t\t\"2_columns_ii\");\n\n\t\taddPortlets(group, layout, \"/profile\");\n\n\t\tupdatePermissions(layout, true);\n\t}","id":78124,"modified_method":"protected void addPublicUserLayouts(Group group) throws Exception {\n\t\tLayoutSetLocalServiceUtil.updateLookAndFeel(\n\t\t\tgroup.getGroupId(), false, \"so_WAR_sotheme\", \"01\", StringPool.BLANK,\n\t\t\tfalse);\n\n\t\tLayout layout = LayoutUtil.addLayout(\n\t\t\tgroup, false, LayoutConstants.DEFAULT_PARENT_LAYOUT_ID, \"Profile\",\n\t\t\tPortletPropsValues.USER_NEW_LAYOUT_TEMPLATE);\n\n\t\tLayoutUtil.addPortlets(\n\t\t\tgroup, layout, \"/profile\", PortletPropsKeys.USER_LAYOUT_PORTLETS);\n\n\t\tLayoutUtil.updatePermissions(layout, true);\n\t}","commit_id":"79fb3e31ab10d8c9c55a579f567952049f717056","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public String genHelp(Request R) {\n    final String name = R.getClass().getSimpleName();\n    final FieldDoc docs[] = R.toDocField();\n    final StringBuilder sb = new StringBuilder();\n    bodyHead(sb);\n    title(sb,name);\n    paragraph(sb,\"\");\n\n    section(sb,\"Supported HTTP methods and descriptions\");\n    String gs = R.toDocGET();\n    if( gs != null ) {\n      paragraph(sb,\"GET\");\n      paragraph(sb,gs);\n    }\n\n    section(sb,\"URL\");\n    paraTail(escape(paraHead(sb),\"http://<h2oHost>:<h2oApiPort>/\"+name+\".json\"));\n\n    // Escape out for not-yet-converted auto-doc Requests\n    if( docs == null ) return bodyTail(sb).toString();\n\n    section(sb,\"Input parameters\");\n    listHead(sb);\n    for( FieldDoc doc : docs )\n      if( doc.isArg() ) {\n        listBullet(sb,\n                   bold(doc._name)+\", \"+doc.argHelp(R),\n                   doc._help+doc.version(),0);\n        String[] errors = doc.errors(R);\n        if( errors != null || doc.required(R) ) {\n          paragraph(sb,\"\");\n          paragraph(sb,bold(\"Possible JSON error field returns:\"));\n          listHead(sb);\n          if( errors != null )\n            for( String err : errors )\n              listBullet(sb,doc.argErr()+err,\"\",1);\n          if( doc.required(R) )\n            listBullet(sb,doc.argErr()+\"Argument '\"+doc._name+\"' is required, but not specified\",\"\",1);\n          listTail(sb);\n        }\n      }\n    listTail(sb);\n\n    section(sb,\"Output JSON elements\");\n    listHead(sb);\n    for( FieldDoc doc : docs )\n      if( doc.isJSON() )\n        listBullet(sb,\n                   bold(doc._name)+\", a \"+doc._clazz.getSimpleName(),\n                   doc._help+doc.version(),0);\n    listTail(sb);\n\n    section(sb,\"HTTP response codes\");\n    paragraph(sb,\"200 OK\");\n    paragraph(sb,\"Success and error responses are identical.\");\n\n    section(sb,\"Success Example\");\n    String s[] = R.DocExampleSucc();\n    paraHead(sb);\n    url(sb,name,s);\n    paraTail(sb);\n    paragraph(sb,serve(name,s));\n\n    section(sb,\"Error Example\");\n    String f[] = R.DocExampleFail();\n    paraHead(sb);\n    url(sb,name,f);\n    paraTail(sb);\n    paragraph(sb,serve(name,f));\n\n    bodyTail(sb);\n    return sb.toString();\n  }","id":78125,"modified_method":"public String genHelp(Request R) {\n    final String name = R.getClass().getSimpleName();\n    final FieldDoc docs[] = R.toDocField();\n    final StringBuilder sb = new StringBuilder();\n    bodyHead(sb);\n    title(sb,name);\n    paragraph(sb,\"\");\n\n    section(sb,\"Supported HTTP methods and descriptions\");\n    String gs = R.toDocGET();\n    if( gs != null ) {\n      paragraph(sb,\"GET\");\n      paragraph(sb,gs);\n    }\n\n    section(sb,\"URL\");\n    paraTail(escape(paraHead(sb),\"http://<h2oHost>:<h2oApiPort>/\"+name+\".json\"));\n\n    // Escape out for not-yet-converted auto-doc Requests\n    if( docs == null ) return bodyTail(sb).toString();\n\n    section(sb,\"Input parameters\");\n    listHead(sb);\n    for( FieldDoc doc : docs )\n      if( doc.isArg() ) {\n        listBullet(sb,\n                   bold(doc._name)+\", \"+doc.argHelp(R),\n                   doc._help+doc.version(),0);\n        String[] errors = doc.errors(R);\n        if( errors != null || doc.required(R) ) {\n          paragraph(sb,\"\");\n          paragraph(sb,bold(\"Possible JSON error field returns:\"));\n          listHead(sb);\n          if( errors != null )\n            for( String err : errors )\n              listBullet(sb,doc.argErr()+err,\"\",1);\n          if( doc.required(R) )\n            listBullet(sb,doc.argErr()+\"Argument '\"+doc._name+\"' is required, but not specified\",\"\",1);\n          listTail(sb);\n        }\n      }\n    listTail(sb);\n\n    section(sb,\"Output JSON elements\");\n    listHead(sb);\n    for( FieldDoc doc : docs )\n      if( doc.isJSON() )\n        listBullet(sb,\n                   bold(doc._name)+\", a \"+doc._clazz.getSimpleName(),\n                   doc._help+doc.version(),0);\n    listTail(sb);\n\n    section(sb,\"HTTP response codes\");\n    paragraph(sb,\"200 OK\");\n    paragraph(sb,\"Success and error responses are identical.\");\n\n    String s[] = R.DocExampleSucc();\n    if( s != null ) {\n      section(sb,\"Success Example\");\n      paraHead(sb);\n      url(sb,name,s);\n      paraTail(sb);\n      paragraph(sb,serve(name,s));\n    }\n\n    section(sb,\"Error Example\");\n    String f[] = R.DocExampleFail();\n    paraHead(sb);\n    url(sb,name,f);\n    paraTail(sb);\n    paragraph(sb,serve(name,f));\n\n    bodyTail(sb);\n    return sb.toString();\n  }","commit_id":"401e228910788c6e94f686914b5202de7d29d970","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n         * Create the documentation to provide an developer access with a <code>SVN<\/code> SCM.\n         * For example, generate the following command line:\n         * <p>svn checkout https://svn.apache.org/repos/asf/maven/components/trunk maven<\/p>\n         * <p>svn commit --username your-username -m \"A message\"<\/p>\n         *\n         * @param svnRepo\n         * @see <a href=\"http://svnbook.red-bean.com/\">http://svnbook.red-bean.com/<\/a>\n         */\n        private void developerAccessSVN( SvnScmProviderRepository svnRepo )\n        {\n            paragraph( i18n.getString( \"project-info-report\", locale, \"report.scm.devaccess.svn.intro1\" ) );\n\n            StringBuffer sb = new StringBuffer();\n\n            sb.append( \"$ svn checkout \" ).append( svnRepo.getUrl() ).append( \" \" ).append( checkoutDirectoryName );\n\n            verbatimText( sb.toString() );\n\n            paragraph( i18n.getString( \"project-info-report\", locale, \"report.scm.devaccess.svn.intro2\" ) );\n\n            sb = new StringBuffer();\n            sb.append( \"$ svn commit --username your-username -m \\\"A message\\\"\" );\n\n            verbatimText( sb.toString() );\n        }","id":78126,"modified_method":"/**\n         * Create the documentation to provide an developer access with a <code>SVN<\/code> SCM.\n         * For example, generate the following command line:\n         * <p>svn checkout https://svn.apache.org/repos/asf/maven/components/trunk maven<\/p>\n         * <p>svn commit --username your-username -m \"A message\"<\/p>\n         *\n         * @param svnRepo\n         * @see <a href=\"http://svnbook.red-bean.com/\">http://svnbook.red-bean.com/<\/a>\n         */\n        private void developerAccessSVN( SvnScmProviderRepository svnRepo )\n        {\n            if ( svnRepo.getUrl() != null )\n            {\n                if ( svnRepo.getUrl().startsWith( \"https://\" ) )\n                {\n                    paragraph( i18n.getString( \"project-info-report\", locale, \"report.scm.devaccess.svn.intro1.https\" ) );\n                }\n                else if ( svnRepo.getUrl().startsWith( \"svn://\" ) )\n                {\n                    paragraph( i18n.getString( \"project-info-report\", locale, \"report.scm.devaccess.svn.intro1.svn\" ) );\n                }\n                else if ( svnRepo.getUrl().startsWith( \"svn+ssh://\" ) )\n                {\n                    paragraph( i18n.getString( \"project-info-report\", locale, \"report.scm.devaccess.svn.intro1.svnssh\" ) );\n                }\n                else\n                {\n                    paragraph( i18n.getString( \"project-info-report\", locale, \"report.scm.devaccess.svn.intro1.other\" ) );\n                }\n            }\n\n            StringBuffer sb = new StringBuffer();\n\n            sb.append( \"$ svn checkout \" ).append( svnRepo.getUrl() ).append( \" \" ).append( checkoutDirectoryName );\n\n            verbatimText( sb.toString() );\n\n            paragraph( i18n.getString( \"project-info-report\", locale, \"report.scm.devaccess.svn.intro2\" ) );\n\n            sb = new StringBuffer();\n            sb.append( \"$ svn commit --username your-username -m \\\"A message\\\"\" );\n\n            verbatimText( sb.toString() );\n        }","commit_id":"071e6f86c015682aa3999577d38ae36d85e54181","url":"https://github.com/apache/maven-plugins"},{"original_method":"void runFraction(float fraction) {\n    long seed0 = 0xDECAF;\n    int num_runs = 0;\n    for (int repeat = 0; repeat < 5; ++repeat) {\n      // Testing different things\n      // Note: Microsoft reference implementation is only for Tanh + MSE, rectifier and MCE are implemented by 0xdata (trivial).\n      // Note: Initial weight distributions are copied, but what is tested is the stability behavior.\n\n      DeepLearning.Activation[] activations = {DeepLearning.Activation.Tanh, DeepLearning.Activation.Rectifier};\n      DeepLearning.Loss[] losses = {DeepLearning.Loss.MeanSquare, DeepLearning.Loss.CrossEntropy};\n      DeepLearning.InitialWeightDistribution[] dists = {\n              DeepLearning.InitialWeightDistribution.Normal,\n              DeepLearning.InitialWeightDistribution.Uniform,\n              DeepLearning.InitialWeightDistribution.UniformAdaptive\n      };\n      final long seed = seed0 + repeat;\n      Random rng = new Random(seed);\n\n      double[] initial_weight_scales = {1e-4 + rng.nextDouble()};\n      double[] holdout_ratios = {0.1 + rng.nextDouble() * 0.8};\n      double[] momenta = {rng.nextDouble() * 0.99};\n      int[] hiddens = {1, 2 + rng.nextInt(50)};\n      int[] epochs = {1, 2 + rng.nextInt(50)};\n      double[] rates = {0.01, 1e-5 + rng.nextDouble() * .1};\n\n      for (DeepLearning.Activation activation : activations) {\n        for (DeepLearning.Loss loss : losses) {\n          for (DeepLearning.InitialWeightDistribution dist : dists) {\n            for (double scale : initial_weight_scales) {\n              for (double holdout_ratio : holdout_ratios) {\n                for (double momentum : momenta) {\n                  for (int hidden : hiddens) {\n                    for (int epoch : epochs) {\n                      for (double rate : rates) {\n                        for (boolean sparse : new boolean[]{true,false}) {\n                          for (boolean col_major : new boolean[]{false}) {\n                            if (col_major && !sparse) continue;\n                            num_runs++;\n                            if (fraction < rng.nextFloat()) continue;\n                            Log.info(\"\");\n                            Log.info(\"STARTING.\");\n                            Log.info(\"Running with \" + activation.name() + \" activation function and \" + loss.name() + \" loss function.\");\n                            Log.info(\"Initialization with \" + dist.name() + \" distribution and \" + scale + \" scale, holdout ratio \" + holdout_ratio);\n                            Log.info(\"Using \" + hidden + \" hidden layers and momentum: \" + momentum);\n                            Log.info(\"Using seed \" + seed);\n\n                            Key file = NFSFileVec.make(find_test_file(PATH));\n                            Frame frame = ParseDataset2.parse(Key.make(\"iris_nn2\"), new Key[]{file});\n\n                            Frame fr = null;\n                            DeepLearning p;\n                            Random rand;\n\n                            int trial = 0;\n                            FrameTask.DataInfo dinfo;\n                            do {\n                              Log.info(\"Trial #\" + ++trial);\n                              if (_train != null) _train.delete();\n                              if (_test != null) _test.delete();\n                              if (fr != null) fr.delete();\n\n                              rand = Utils.getDeterRNG(seed);\n\n                              double[][] rows = new double[(int) frame.numRows()][frame.numCols()];\n                              String[] names = new String[frame.numCols()];\n                              for (int c = 0; c < frame.numCols(); c++) {\n                                names[c] = \"ColumnName\" + c;\n                                for (int r = 0; r < frame.numRows(); r++)\n                                  rows[r][c] = frame.vecs()[c].at(r);\n                              }\n\n                              for (int i = rows.length - 1; i >= 0; i--) {\n                                int shuffle = rand.nextInt(i + 1);\n                                double[] row = rows[shuffle];\n                                rows[shuffle] = rows[i];\n                                rows[i] = row;\n                              }\n\n                              int limit = (int) (frame.numRows() * holdout_ratio);\n                              _train = frame(names, Utils.subarray(rows, 0, limit));\n                              _test = frame(names, Utils.subarray(rows, limit, (int) frame.numRows() - limit));\n\n                              p = new DeepLearning();\n                              p.source = _train;\n                              p.response = _train.lastVec();\n                              p.ignored_cols = null;\n                              p.ignore_const_cols = true;\n                              fr = FrameTask.DataInfo.prepareFrame(p.source, p.response, p.ignored_cols, true, p.ignore_const_cols);\n                              dinfo = new FrameTask.DataInfo(fr, 1, false, true);\n                            }\n                            // must have all output classes in training data (since that's what the reference implementation has hardcoded)\n                            while (dinfo._adaptedFrame.lastVec().domain().length < 3);\n\n                            // use the same seed for the reference implementation\n                            DeepLearningMLPReference ref = new DeepLearningMLPReference();\n                            ref.init(activation, Utils.getDeterRNG(seed), holdout_ratio, hidden);\n\n                            p.seed = seed;\n                            p.hidden = new int[]{hidden};\n                            p.adaptive_rate = false;\n                            p.rho = 0;\n                            p.epsilon = 0;\n                            p.rate = rate / (1 - momentum); //adapt to (1-m) correction that's done inside (only for constant momentum!)\n                            p.activation = activation;\n                            p.max_w2 = Float.POSITIVE_INFINITY;\n                            p.epochs = epoch;\n                            p.input_dropout_ratio = 0;\n                            p.rate_annealing = 0; //do not change - not implemented in reference\n                            p.l1 = 0;\n                            p.loss = loss;\n                            p.l2 = 0;\n                            p.momentum_stable = momentum; //reference only supports constant momentum\n                            p.momentum_start = p.momentum_stable; //do not change - not implemented in reference\n                            p.momentum_ramp = 0; //do not change - not implemented in reference\n                            p.initial_weight_distribution = dist;\n                            p.initial_weight_scale = scale;\n                            p.classification = true;\n                            p.diagnostics = true;\n                            p.validation = null;\n                            p.quiet_mode = true;\n                            p.fast_mode = false; //to be the same as reference\n//                      p.fast_mode = true; //to be the same as old NeuralNet code\n                            p.nesterov_accelerated_gradient = false; //to be the same as reference\n//                        p.nesterov_accelerated_gradient = true; //to be the same as old NeuralNet code\n                            p.train_samples_per_iteration = 0; //sync once per period\n                            p.ignore_const_cols = false;\n                            p.shuffle_training_data = false;\n                            p.classification_stop = -1; //don't stop early -> need to compare against reference, which doesn't stop either\n                            p.force_load_balance = false; //keep just 1 chunk for reproducibility\n                            p.replicate_training_data = false;\n                            p.single_node_mode = true;\n                            p.sparse = sparse;\n                            p.col_major = col_major;\n                            DeepLearningModel mymodel = p.initModel(); //randomize weights, but don't start training yet\n\n                            Neurons[] neurons = DeepLearningTask.makeNeuronsForTraining(mymodel.model_info());\n\n                            // use the same random weights for the reference implementation\n                            Neurons l = neurons[1];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                                ref._nn.ihWeights[i][o] = l._w.get(o, i);\n                              }\n                              ref._nn.hBiases[o] = l._b.get(o);\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                            }\n                            l = neurons[2];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                                ref._nn.hoWeights[i][o] = l._w.get(o, i);\n                              }\n                              ref._nn.oBiases[o] = l._b.get(o);\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                            }\n\n                            // Train the Reference\n                            ref.train((int) p.epochs, rate, p.momentum_stable, loss);\n\n                            // Train H2O\n                            mymodel = p.trainModel(mymodel);\n\n                            /**\n                             * Tolerances (should ideally be super tight -> expect the same double/float precision math inside both algos)\n                             */\n                            final double abseps = 1e-4;\n                            final double releps = 1e-4;\n\n                            /**\n                             * Compare weights and biases in hidden layer\n                             */\n                            neurons = DeepLearningTask.makeNeuronsForTesting(mymodel.model_info()); //link the weights to the neurons, for easy access\n                            l = neurons[1];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n                                double a = ref._nn.ihWeights[i][o];\n                                double b = l._w.get(o, i);\n                                compareVal(a, b, abseps, releps);\n//                          System.out.println(\"weight[\" + o + \"]=\" + b);\n                              }\n                              double ba = ref._nn.hBiases[o];\n                              double bb = l._b.get(o);\n                              compareVal(ba, bb, abseps, releps);\n                            }\n                            Log.info(\"Weights and biases for hidden layer: PASS\");\n\n                            /**\n                             * Compare weights and biases for output layer\n                             */\n                            l = neurons[2];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n                                double a = ref._nn.hoWeights[i][o];\n                                double b = l._w.get(o, i);\n                                compareVal(a, b, abseps, releps);\n                              }\n                              double ba = ref._nn.oBiases[o];\n                              double bb = l._b.get(o);\n                              compareVal(ba, bb, abseps, releps);\n                            }\n                            Log.info(\"Weights and biases for output layer: PASS\");\n\n                            /**\n                             * Compare predictions\n                             * Note: Reference and H2O each do their internal data normalization,\n                             * so we must use their \"own\" test data, which is assumed to be created correctly.\n                             */\n                            // H2O predictions\n                            Frame fpreds = mymodel.score(_test); //[0] is label, [1]...[4] are the probabilities\n\n                            for (int i = 0; i < _test.numRows(); ++i) {\n                              // Reference predictions\n                              double[] xValues = new double[neurons[0]._a.size()];\n                              System.arraycopy(ref._testData[i], 0, xValues, 0, xValues.length);\n                              double[] ref_preds = ref._nn.ComputeOutputs(xValues);\n\n                              // find the label\n                              // do the same as H2O here (compare float values and break ties based on row number)\n                              float[] preds = new float[ref_preds.length + 1];\n                              for (int j = 0; j < ref_preds.length; ++j) preds[j + 1] = (float) ref_preds[j];\n                              preds[0] = getPrediction(preds, i);\n\n                              // compare predicted label\n                              Assert.assertTrue(preds[0] == (int) fpreds.vecs()[0].at(i));\n//                          // compare predicted probabilities\n//                          for (int j=0; j<ref_preds.length; ++j) {\n//                            compareVal((float)(ref_preds[j]), fpreds.vecs()[1+j].at(i), abseps, releps);\n//                          }\n                            }\n                            fpreds.delete();\n                            Log.info(\"Predicted values: PASS\");\n\n                            /**\n                             * Compare (self-reported) scoring\n                             */\n                            final double trainErr = ref._nn.Accuracy(ref._trainData);\n                            final double testErr = ref._nn.Accuracy(ref._testData);\n                            final Frame trainPredict = mymodel.score(_train, false);\n                            final double myTrainErr = mymodel.calcError(_train, _train.lastVec(), trainPredict, trainPredict, \"Final training error:\",\n                                    true, p.max_confusion_matrix_size, new water.api.ConfusionMatrix(), null, null);\n                            final Frame testPredict = mymodel.score(_test, false);\n                            final double myTestErr = mymodel.calcError(_test, _test.lastVec(), testPredict, testPredict, \"Final testing error:\",\n                                    true, p.max_confusion_matrix_size, new water.api.ConfusionMatrix(), null, null);\n                            Log.info(\"H2O  training error : \" + myTrainErr * 100 + \"%, test error: \" + myTestErr * 100 + \"%\");\n                            Log.info(\"REF  training error : \" + trainErr * 100 + \"%, test error: \" + testErr * 100 + \"%\");\n                            compareVal(trainErr, myTrainErr, abseps, releps);\n                            compareVal(testErr, myTestErr, abseps, releps);\n                            Log.info(\"Scoring: PASS\");\n\n                            // cleanup\n                            mymodel.delete();\n                            _train.delete();\n                            _test.delete();\n                            frame.delete();\n                            fr.delete();\n                            p.delete();\n                            trainPredict.delete();\n                            testPredict.delete();\n                            Log.info(\"Parameters combination \" + num_runs + \": PASS\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }","id":78127,"modified_method":"void runFraction(float fraction) {\n    long seed0 = 0xDECAF;\n    int num_runs = 0;\n    for (int repeat = 0; repeat < 5; ++repeat) {\n      // Testing different things\n      // Note: Microsoft reference implementation is only for Tanh + MSE, rectifier and MCE are implemented by 0xdata (trivial).\n      // Note: Initial weight distributions are copied, but what is tested is the stability behavior.\n\n      DeepLearning.Activation[] activations = {DeepLearning.Activation.Tanh, DeepLearning.Activation.Rectifier};\n      DeepLearning.Loss[] losses = {DeepLearning.Loss.MeanSquare, DeepLearning.Loss.CrossEntropy};\n      DeepLearning.InitialWeightDistribution[] dists = {\n              DeepLearning.InitialWeightDistribution.Normal,\n              DeepLearning.InitialWeightDistribution.Uniform,\n              DeepLearning.InitialWeightDistribution.UniformAdaptive\n      };\n      final long seed = seed0 + repeat;\n      Random rng = new Random(seed);\n\n      double[] initial_weight_scales = {1e-4 + rng.nextDouble()};\n      double[] holdout_ratios = {0.1 + rng.nextDouble() * 0.8};\n      double[] momenta = {rng.nextDouble() * 0.99};\n      int[] hiddens = {1, 2 + rng.nextInt(50)};\n      int[] epochs = {1, 2 + rng.nextInt(50)};\n      double[] rates = {0.01, 1e-5 + rng.nextDouble() * .1};\n\n      for (DeepLearning.Activation activation : activations) {\n        for (DeepLearning.Loss loss : losses) {\n          for (DeepLearning.InitialWeightDistribution dist : dists) {\n            for (double scale : initial_weight_scales) {\n              for (double holdout_ratio : holdout_ratios) {\n                for (double momentum : momenta) {\n                  for (int hidden : hiddens) {\n                    for (int epoch : epochs) {\n                      for (double rate : rates) {\n                        for (boolean sparse : new boolean[]{true,false}) {\n                          for (boolean col_major : new boolean[]{false}) {\n                            if (col_major && !sparse) continue;\n                            num_runs++;\n                            if (fraction < rng.nextFloat()) continue;\n                            Log.info(\"\");\n                            Log.info(\"STARTING.\");\n                            Log.info(\"Running with \" + activation.name() + \" activation function and \" + loss.name() + \" loss function.\");\n                            Log.info(\"Initialization with \" + dist.name() + \" distribution and \" + scale + \" scale, holdout ratio \" + holdout_ratio);\n                            Log.info(\"Using \" + hidden + \" hidden layers and momentum: \" + momentum);\n                            Log.info(\"Using seed \" + seed);\n\n                            Key file = NFSFileVec.make(find_test_file(PATH));\n                            Frame frame = ParseDataset2.parse(Key.make(\"iris_nn2\"), new Key[]{file});\n\n                            Frame fr = null;\n                            DeepLearning p;\n                            Random rand;\n\n                            int trial = 0;\n                            FrameTask.DataInfo dinfo;\n                            do {\n                              Log.info(\"Trial #\" + ++trial);\n                              if (_train != null) _train.delete();\n                              if (_test != null) _test.delete();\n                              if (fr != null) fr.delete();\n\n                              rand = Utils.getDeterRNG(seed);\n\n                              double[][] rows = new double[(int) frame.numRows()][frame.numCols()];\n                              String[] names = new String[frame.numCols()];\n                              for (int c = 0; c < frame.numCols(); c++) {\n                                names[c] = \"ColumnName\" + c;\n                                for (int r = 0; r < frame.numRows(); r++)\n                                  rows[r][c] = frame.vecs()[c].at(r);\n                              }\n\n                              for (int i = rows.length - 1; i >= 0; i--) {\n                                int shuffle = rand.nextInt(i + 1);\n                                double[] row = rows[shuffle];\n                                rows[shuffle] = rows[i];\n                                rows[i] = row;\n                              }\n\n                              int limit = (int) (frame.numRows() * holdout_ratio);\n                              _train = frame(names, Utils.subarray(rows, 0, limit));\n                              _test = frame(names, Utils.subarray(rows, limit, (int) frame.numRows() - limit));\n\n                              p = new DeepLearning();\n                              p.source = _train;\n                              p.response = _train.lastVec();\n                              p.ignored_cols = null;\n                              p.ignore_const_cols = true;\n                              fr = FrameTask.DataInfo.prepareFrame(p.source, p.response, p.ignored_cols, true, p.ignore_const_cols);\n                              dinfo = new FrameTask.DataInfo(fr, 1, false, true);\n                            }\n                            // must have all output classes in training data (since that's what the reference implementation has hardcoded)\n                            while (dinfo._adaptedFrame.lastVec().domain().length < 3);\n\n                            // use the same seed for the reference implementation\n                            DeepLearningMLPReference ref = new DeepLearningMLPReference();\n                            ref.init(activation, Utils.getDeterRNG(seed), holdout_ratio, hidden);\n\n                            p.best_model_key = Key.make(\"best_DLIris.hex\");\n                            p.seed = seed;\n                            p.hidden = new int[]{hidden};\n                            p.adaptive_rate = false;\n                            p.rho = 0;\n                            p.epsilon = 0;\n                            p.rate = rate / (1 - momentum); //adapt to (1-m) correction that's done inside (only for constant momentum!)\n                            p.activation = activation;\n                            p.max_w2 = Float.POSITIVE_INFINITY;\n                            p.epochs = epoch;\n                            p.input_dropout_ratio = 0;\n                            p.rate_annealing = 0; //do not change - not implemented in reference\n                            p.l1 = 0;\n                            p.loss = loss;\n                            p.l2 = 0;\n                            p.momentum_stable = momentum; //reference only supports constant momentum\n                            p.momentum_start = p.momentum_stable; //do not change - not implemented in reference\n                            p.momentum_ramp = 0; //do not change - not implemented in reference\n                            p.initial_weight_distribution = dist;\n                            p.initial_weight_scale = scale;\n                            p.classification = true;\n                            p.diagnostics = true;\n                            p.validation = null;\n                            p.quiet_mode = true;\n                            p.fast_mode = false; //to be the same as reference\n//                      p.fast_mode = true; //to be the same as old NeuralNet code\n                            p.nesterov_accelerated_gradient = false; //to be the same as reference\n//                        p.nesterov_accelerated_gradient = true; //to be the same as old NeuralNet code\n                            p.train_samples_per_iteration = 0; //sync once per period\n                            p.ignore_const_cols = false;\n                            p.shuffle_training_data = false;\n                            p.classification_stop = -1; //don't stop early -> need to compare against reference, which doesn't stop either\n                            p.force_load_balance = false; //keep just 1 chunk for reproducibility\n                            p.replicate_training_data = false;\n                            p.single_node_mode = true;\n                            p.sparse = sparse;\n                            p.col_major = col_major;\n                            DeepLearningModel mymodel = p.initModel(); //randomize weights, but don't start training yet\n\n                            Neurons[] neurons = DeepLearningTask.makeNeuronsForTraining(mymodel.model_info());\n\n                            // use the same random weights for the reference implementation\n                            Neurons l = neurons[1];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                                ref._nn.ihWeights[i][o] = l._w.get(o, i);\n                              }\n                              ref._nn.hBiases[o] = l._b.get(o);\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                            }\n                            l = neurons[2];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n//                          System.out.println(\"initial weight[\" + o + \"]=\" + l._w[o * l._previous._a.length + i]);\n                                ref._nn.hoWeights[i][o] = l._w.get(o, i);\n                              }\n                              ref._nn.oBiases[o] = l._b.get(o);\n//                        System.out.println(\"initial bias[\" + o + \"]=\" + l._b[o]);\n                            }\n\n                            // Train the Reference\n                            ref.train((int) p.epochs, rate, p.momentum_stable, loss);\n\n                            // Train H2O\n                            mymodel = p.trainModel(mymodel);\n\n                            /**\n                             * Tolerances (should ideally be super tight -> expect the same double/float precision math inside both algos)\n                             */\n                            final double abseps = 1e-4;\n                            final double releps = 1e-4;\n\n                            /**\n                             * Compare weights and biases in hidden layer\n                             */\n                            neurons = DeepLearningTask.makeNeuronsForTesting(mymodel.model_info()); //link the weights to the neurons, for easy access\n                            l = neurons[1];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n                                double a = ref._nn.ihWeights[i][o];\n                                double b = l._w.get(o, i);\n                                compareVal(a, b, abseps, releps);\n//                          System.out.println(\"weight[\" + o + \"]=\" + b);\n                              }\n                              double ba = ref._nn.hBiases[o];\n                              double bb = l._b.get(o);\n                              compareVal(ba, bb, abseps, releps);\n                            }\n                            Log.info(\"Weights and biases for hidden layer: PASS\");\n\n                            /**\n                             * Compare weights and biases for output layer\n                             */\n                            l = neurons[2];\n                            for (int o = 0; o < l._a.size(); o++) {\n                              for (int i = 0; i < l._previous._a.size(); i++) {\n                                double a = ref._nn.hoWeights[i][o];\n                                double b = l._w.get(o, i);\n                                compareVal(a, b, abseps, releps);\n                              }\n                              double ba = ref._nn.oBiases[o];\n                              double bb = l._b.get(o);\n                              compareVal(ba, bb, abseps, releps);\n                            }\n                            Log.info(\"Weights and biases for output layer: PASS\");\n\n                            /**\n                             * Compare predictions\n                             * Note: Reference and H2O each do their internal data normalization,\n                             * so we must use their \"own\" test data, which is assumed to be created correctly.\n                             */\n                            // H2O predictions\n                            Frame fpreds = mymodel.score(_test); //[0] is label, [1]...[4] are the probabilities\n\n                            for (int i = 0; i < _test.numRows(); ++i) {\n                              // Reference predictions\n                              double[] xValues = new double[neurons[0]._a.size()];\n                              System.arraycopy(ref._testData[i], 0, xValues, 0, xValues.length);\n                              double[] ref_preds = ref._nn.ComputeOutputs(xValues);\n\n                              // find the label\n                              // do the same as H2O here (compare float values and break ties based on row number)\n                              float[] preds = new float[ref_preds.length + 1];\n                              for (int j = 0; j < ref_preds.length; ++j) preds[j + 1] = (float) ref_preds[j];\n                              preds[0] = getPrediction(preds, i);\n\n                              // compare predicted label\n                              Assert.assertTrue(preds[0] == (int) fpreds.vecs()[0].at(i));\n//                          // compare predicted probabilities\n//                          for (int j=0; j<ref_preds.length; ++j) {\n//                            compareVal((float)(ref_preds[j]), fpreds.vecs()[1+j].at(i), abseps, releps);\n//                          }\n                            }\n                            fpreds.delete();\n                            Log.info(\"Predicted values: PASS\");\n\n                            /**\n                             * Compare (self-reported) scoring\n                             */\n                            final double trainErr = ref._nn.Accuracy(ref._trainData);\n                            final double testErr = ref._nn.Accuracy(ref._testData);\n                            final Frame trainPredict = mymodel.score(_train, false);\n                            final double myTrainErr = mymodel.calcError(_train, _train.lastVec(), trainPredict, trainPredict, \"Final training error:\",\n                                    true, p.max_confusion_matrix_size, new water.api.ConfusionMatrix(), null, null);\n                            final Frame testPredict = mymodel.score(_test, false);\n                            final double myTestErr = mymodel.calcError(_test, _test.lastVec(), testPredict, testPredict, \"Final testing error:\",\n                                    true, p.max_confusion_matrix_size, new water.api.ConfusionMatrix(), null, null);\n                            Log.info(\"H2O  training error : \" + myTrainErr * 100 + \"%, test error: \" + myTestErr * 100 + \"%\");\n                            Log.info(\"REF  training error : \" + trainErr * 100 + \"%, test error: \" + testErr * 100 + \"%\");\n                            compareVal(trainErr, myTrainErr, abseps, releps);\n                            compareVal(testErr, myTestErr, abseps, releps);\n                            Log.info(\"Scoring: PASS\");\n\n                            // cleanup\n                            if (p.best_model_key != null) UKV.remove(p.best_model_key);\n                            mymodel.delete();\n                            _train.delete();\n                            _test.delete();\n                            frame.delete();\n                            fr.delete();\n                            p.delete();\n                            trainPredict.delete();\n                            testPredict.delete();\n                            Log.info(\"Parameters combination \" + num_runs + \": PASS\");\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"6a77a929b7ad5fe0360a77c5632c56dae2985509","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   *\n   * @param train training data from which the model is built (for epoch counting only)\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param job_key key of the owning job\n   * @return true if model building is ongoing\n   */\n  boolean doScoring(Frame train, Frame ftrain, Frame ftest, Key job_key, Job.ValidatedJob.Response2CMAdaptor vadaptor) {\n    try {\n      final long now = System.currentTimeMillis();\n      epoch_counter = (float)model_info().get_processed_total()/train.numRows();\n      run_time += now-_timeLastScoreEnter;\n      _timeLastScoreEnter = now;\n      boolean keep_running = (epoch_counter < get_params().epochs);\n      final long sinceLastScore = now -_timeLastScoreStart;\n      final long sinceLastPrint = now -_timeLastPrintStart;\n      final long samples = model_info().get_processed_total();\n      if (!keep_running || sinceLastPrint > get_params().score_interval*1000) {\n        _timeLastPrintStart = now;\n        Log.info(\"Training time: \" + PrettyPrint.msecs(run_time, true)\n                + \". Processed \" + String.format(\"%,d\", samples) + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n                + \" Speed: \" + String.format(\"%.3f\", 1000.*samples/run_time) + \" samples/sec.\");\n      }\n      // this is potentially slow - only do every so often\n      if( !keep_running ||\n              (sinceLastScore > get_params().score_interval*1000 //don't score too often\n                      &&(double)(_timeLastScoreEnd-_timeLastScoreStart)/sinceLastScore < get_params().score_duty_cycle) ) { //duty cycle\n        final boolean printme = !get_params().quiet_mode;\n        if (printme) Log.info(\"Scoring the model.\");\n        _timeLastScoreStart = now;\n        // compute errors\n        Errors err = new Errors();\n        err.classification = isClassifier();\n        assert(err.classification == get_params().classification);\n        err.training_time_ms = run_time;\n        err.epoch_counter = epoch_counter;\n        err.validation = ftest != null;\n        err.training_samples = model_info().get_processed_total();\n        err.score_training_samples = ftrain.numRows();\n        err.train_confusion_matrix = new ConfusionMatrix();\n        final int hit_k = Math.min(nclasses(), get_params().max_hit_ratio_k);\n        if (err.classification && nclasses()==2) err.trainAUC = new AUC();\n        if (err.classification && nclasses() > 2 && hit_k > 0) {\n          err.train_hitratio = new HitRatio();\n          err.train_hitratio.set_max_k(hit_k);\n        }\n        if (get_params().diagnostics) model_info().computeStats();\n        final String m = model_info().toString();\n        if (m.length() > 0) Log.info(m);\n        final Frame trainPredict = score(ftrain, false);\n        final double trainErr = calcError(ftrain, ftrain.lastVec(), trainPredict, trainPredict, \"training\",\n                printme, get_params().max_confusion_matrix_size, err.train_confusion_matrix, err.trainAUC, err.train_hitratio);\n        if (isClassifier()) err.train_err = trainErr;\n        else err.train_mse = trainErr;\n\n        trainPredict.delete();\n\n        if (err.validation) {\n          assert ftest != null;\n          err.score_validation_samples = ftest.numRows();\n          err.valid_confusion_matrix = new ConfusionMatrix();\n          if (err.classification && nclasses()==2) err.validAUC = new AUC();\n          if (err.classification && nclasses() > 2 && hit_k > 0) {\n            err.valid_hitratio = new HitRatio();\n            err.valid_hitratio.set_max_k(hit_k);\n          }\n          final boolean adaptCM = (isClassifier() && vadaptor.needsAdaptation2CM());\n          final String adaptRespName = vadaptor.adaptedValidationResponse(responseName());\n          Vec adaptCMresp = null;\n          if (adaptCM) {\n            Vec[] v = ftest.vecs();\n            assert(ftest.find(adaptRespName) == v.length-1); //make sure to have (adapted) response in the test set\n            adaptCMresp = ftest.remove(v.length-1); //model would remove any extra columns anyway (need to keep it here for later)\n          }\n\n          final Frame validPredict = score(ftest, adaptCM);\n          final Frame hitratio_validPredict = new Frame(validPredict);\n          // Adapt output response domain, in case validation domain is different from training domain\n          // Note: doesn't change predictions, just the *possible* label domain\n          if (adaptCM) {\n            assert(adaptCMresp != null);\n            assert(ftest.find(adaptRespName) == -1);\n            ftest.add(adaptRespName, adaptCMresp);\n            final Vec CMadapted = vadaptor.adaptModelResponse2CM(validPredict.vecs()[0]);\n            validPredict.replace(0, CMadapted); //replace label\n            validPredict.add(\"to_be_deleted\", CMadapted); //keep the Vec around to be deleted later (no leak)\n          }\n          final double validErr = calcError(ftest, ftest.lastVec(), validPredict, hitratio_validPredict, \"validation\",\n                  printme, get_params().max_confusion_matrix_size, err.valid_confusion_matrix, err.validAUC, err.valid_hitratio);\n          if (isClassifier()) err.valid_err = validErr;\n          else err.valid_mse = validErr;\n          validPredict.delete();\n        }\n\n        if (get_params().variable_importances) {\n          if (!get_params().quiet_mode) Log.info(\"Computing variable importances.\");\n          final float [] vi = model_info().computeVariableImportances();\n          err.variable_importances = new VarImp(vi, Arrays.copyOfRange(model_info().data_info().coefNames(), 0, vi.length));\n        }\n\n        // only keep confusion matrices for the last step if there are fewer than specified number of output classes\n        if (err.train_confusion_matrix.cm != null\n                && err.train_confusion_matrix.cm.length-1 >= get_params().max_confusion_matrix_size) {\n          err.train_confusion_matrix = null;\n          err.valid_confusion_matrix = null;\n        }\n\n        _timeLastScoreEnd = System.currentTimeMillis();\n        err.scoring_time = System.currentTimeMillis() - now;\n        // enlarge the error array by one, push latest score back\n        if (errors == null) {\n          errors = new Errors[]{err};\n        } else {\n          Errors[] err2 = new Errors[errors.length+1];\n          System.arraycopy(errors, 0, err2, 0, errors.length);\n          err2[err2.length-1] = err;\n          errors = err2;\n        }\n        // always keep a copy of the best model so far (based on the following criterion)\n        if (error() < _bestError) {\n          if (_improvedCounter == 0) _bestModelKey = Key.make(\"DeepLearning\" + Key.rand());\n          _bestError = error();\n          _improvedCounter++;\n          if (!get_params().quiet_mode) Log.info(\"Saving best model so far under key \" + _bestModelKey.toString());\n          DeepLearningModel bestModel = new DeepLearningModel(this, _bestModelKey, jobKey, model_info().data_info());\n          bestModel.delete_and_lock(null);\n          bestModel.unlock(null);\n          assert(UKV.get(_bestModelKey) != null);\n          assert(bestModel.compareTo(this) <= 0);\n          assert(((DeepLearningModel)UKV.get(_bestModelKey)).error() == _bestError);\n        }\n//        else {\n//          // keep output JSON small\n//          if (errors.length > 1) {\n//            if (last_scored().trainAUC != null) last_scored().trainAUC.clear();\n//            if (last_scored().validAUC != null) last_scored().validAUC.clear();\n//            last_scored().variable_importances = null;\n//          }\n//        }\n\n        // print the freshly scored model to ASCII\n        for (String s : toString().split(\"\\n\")) Log.info(s);\n        if (printme) Log.info(\"Time taken for scoring and diagnostics: \" + PrettyPrint.msecs(err.scoring_time, true));\n      }\n      if (model_info().unstable()) {\n        Log.err(\"Canceling job since the model is unstable (exponential growth observed).\");\n        Log.err(\"Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\");\n        keep_running = false;\n      } else if ( (isClassifier() && last_scored().train_err <= get_params().classification_stop)\n              || (!isClassifier() && last_scored().train_mse <= get_params().regression_stop) ) {\n        Log.info(\"Achieved requested predictive accuracy on the training data. Model building completed.\");\n        keep_running = false;\n      }\n      update(job_key);\n\n//    System.out.println(this);\n      return keep_running;\n    }\n    catch (Exception ex) {\n      return false;\n    }\n  }","id":78128,"modified_method":"/**\n   *\n   * @param train training data from which the model is built (for epoch counting only)\n   * @param ftrain potentially downsampled training data for scoring\n   * @param ftest  potentially downsampled validation data for scoring\n   * @param job_key key of the owning job\n   * @return true if model building is ongoing\n   */\n  boolean doScoring(Frame train, Frame ftrain, Frame ftest, Key job_key, Job.ValidatedJob.Response2CMAdaptor vadaptor) {\n    try {\n      final long now = System.currentTimeMillis();\n      epoch_counter = (float)model_info().get_processed_total()/train.numRows();\n      run_time += now-_timeLastScoreEnter;\n      _timeLastScoreEnter = now;\n      boolean keep_running = (epoch_counter < get_params().epochs);\n      final long sinceLastScore = now -_timeLastScoreStart;\n      final long sinceLastPrint = now -_timeLastPrintStart;\n      final long samples = model_info().get_processed_total();\n      if (!keep_running || sinceLastPrint > get_params().score_interval*1000) {\n        _timeLastPrintStart = now;\n        Log.info(\"Training time: \" + PrettyPrint.msecs(run_time, true)\n                + \". Processed \" + String.format(\"%,d\", samples) + \" samples\" + \" (\" + String.format(\"%.3f\", epoch_counter) + \" epochs).\"\n                + \" Speed: \" + String.format(\"%.3f\", 1000.*samples/run_time) + \" samples/sec.\");\n      }\n      // this is potentially slow - only do every so often\n      if( !keep_running ||\n              (sinceLastScore > get_params().score_interval*1000 //don't score too often\n                      &&(double)(_timeLastScoreEnd-_timeLastScoreStart)/sinceLastScore < get_params().score_duty_cycle) ) { //duty cycle\n        final boolean printme = !get_params().quiet_mode;\n        if (printme) Log.info(\"Scoring the model.\");\n        _timeLastScoreStart = now;\n        // compute errors\n        Errors err = new Errors();\n        err.classification = isClassifier();\n        assert(err.classification == get_params().classification);\n        err.training_time_ms = run_time;\n        err.epoch_counter = epoch_counter;\n        err.validation = ftest != null;\n        err.training_samples = model_info().get_processed_total();\n        err.score_training_samples = ftrain.numRows();\n        err.train_confusion_matrix = new ConfusionMatrix();\n        final int hit_k = Math.min(nclasses(), get_params().max_hit_ratio_k);\n        if (err.classification && nclasses()==2) err.trainAUC = new AUC();\n        if (err.classification && nclasses() > 2 && hit_k > 0) {\n          err.train_hitratio = new HitRatio();\n          err.train_hitratio.set_max_k(hit_k);\n        }\n        if (get_params().diagnostics) model_info().computeStats();\n        final String m = model_info().toString();\n        if (m.length() > 0) Log.info(m);\n        final Frame trainPredict = score(ftrain, false);\n        final double trainErr = calcError(ftrain, ftrain.lastVec(), trainPredict, trainPredict, \"training\",\n                printme, get_params().max_confusion_matrix_size, err.train_confusion_matrix, err.trainAUC, err.train_hitratio);\n        if (isClassifier()) err.train_err = trainErr;\n        else err.train_mse = trainErr;\n\n        trainPredict.delete();\n\n        if (err.validation) {\n          assert ftest != null;\n          err.score_validation_samples = ftest.numRows();\n          err.valid_confusion_matrix = new ConfusionMatrix();\n          if (err.classification && nclasses()==2) err.validAUC = new AUC();\n          if (err.classification && nclasses() > 2 && hit_k > 0) {\n            err.valid_hitratio = new HitRatio();\n            err.valid_hitratio.set_max_k(hit_k);\n          }\n          final boolean adaptCM = (isClassifier() && vadaptor.needsAdaptation2CM());\n          final String adaptRespName = vadaptor.adaptedValidationResponse(responseName());\n          Vec adaptCMresp = null;\n          if (adaptCM) {\n            Vec[] v = ftest.vecs();\n            assert(ftest.find(adaptRespName) == v.length-1); //make sure to have (adapted) response in the test set\n            adaptCMresp = ftest.remove(v.length-1); //model would remove any extra columns anyway (need to keep it here for later)\n          }\n\n          final Frame validPredict = score(ftest, adaptCM);\n          final Frame hitratio_validPredict = new Frame(validPredict);\n          // Adapt output response domain, in case validation domain is different from training domain\n          // Note: doesn't change predictions, just the *possible* label domain\n          if (adaptCM) {\n            assert(adaptCMresp != null);\n            assert(ftest.find(adaptRespName) == -1);\n            ftest.add(adaptRespName, adaptCMresp);\n            final Vec CMadapted = vadaptor.adaptModelResponse2CM(validPredict.vecs()[0]);\n            validPredict.replace(0, CMadapted); //replace label\n            validPredict.add(\"to_be_deleted\", CMadapted); //keep the Vec around to be deleted later (no leak)\n          }\n          final double validErr = calcError(ftest, ftest.lastVec(), validPredict, hitratio_validPredict, \"validation\",\n                  printme, get_params().max_confusion_matrix_size, err.valid_confusion_matrix, err.validAUC, err.valid_hitratio);\n          if (isClassifier()) err.valid_err = validErr;\n          else err.valid_mse = validErr;\n          validPredict.delete();\n        }\n\n        if (get_params().variable_importances) {\n          if (!get_params().quiet_mode) Log.info(\"Computing variable importances.\");\n          final float [] vi = model_info().computeVariableImportances();\n          err.variable_importances = new VarImp(vi, Arrays.copyOfRange(model_info().data_info().coefNames(), 0, vi.length));\n        }\n\n        // only keep confusion matrices for the last step if there are fewer than specified number of output classes\n        if (err.train_confusion_matrix.cm != null\n                && err.train_confusion_matrix.cm.length-1 >= get_params().max_confusion_matrix_size) {\n          err.train_confusion_matrix = null;\n          err.valid_confusion_matrix = null;\n        }\n\n        _timeLastScoreEnd = System.currentTimeMillis();\n        err.scoring_time = System.currentTimeMillis() - now;\n        // enlarge the error array by one, push latest score back\n        if (errors == null) {\n          errors = new Errors[]{err};\n        } else {\n          Errors[] err2 = new Errors[errors.length+1];\n          System.arraycopy(errors, 0, err2, 0, errors.length);\n          err2[err2.length-1] = err;\n          errors = err2;\n        }\n        // always keep a copy of the best model so far (based on the following criterion)\n        if (error() < _bestError && get_params().best_model_key != null) {\n          final Key bestModelKey = get_params().best_model_key;\n          _bestError = error();\n          if (!get_params().quiet_mode) Log.info(\"Saving best model so far under key \" + bestModelKey.toString());\n          final Key job = null;\n          final DeepLearningModel cp = this;\n          Key dest_before = this._key;\n          DeepLearningModel bestModel = new DeepLearningModel(cp, bestModelKey, job, model_info().data_info());\n          Key dest_after = this._key;\n          assert(Arrays.equals(dest_before._kb, dest_after._kb));\n          bestModel.delete_and_lock(job);\n          bestModel.unlock(job);\n          assert(UKV.get(bestModelKey) != null);\n          assert(bestModel.compareTo(this) <= 0);\n          assert(((DeepLearningModel)UKV.get(bestModelKey)).error() == _bestError);\n        }\n//        else {\n//          // keep output JSON small\n//          if (errors.length > 1) {\n//            if (last_scored().trainAUC != null) last_scored().trainAUC.clear();\n//            if (last_scored().validAUC != null) last_scored().validAUC.clear();\n//            last_scored().variable_importances = null;\n//          }\n//        }\n\n        // print the freshly scored model to ASCII\n        for (String s : toString().split(\"\\n\")) Log.info(s);\n        if (printme) Log.info(\"Time taken for scoring and diagnostics: \" + PrettyPrint.msecs(err.scoring_time, true));\n      }\n      if (model_info().unstable()) {\n        Log.err(\"Canceling job since the model is unstable (exponential growth observed).\");\n        Log.err(\"Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\");\n        keep_running = false;\n      } else if ( (isClassifier() && last_scored().train_err <= get_params().classification_stop)\n              || (!isClassifier() && last_scored().train_mse <= get_params().regression_stop) ) {\n        Log.info(\"Achieved requested predictive accuracy on the training data. Model building completed.\");\n        keep_running = false;\n      }\n      update(job_key);\n\n//    System.out.println(this);\n      return keep_running;\n    }\n    catch (Exception ex) {\n      return false;\n    }\n  }","commit_id":"6a77a929b7ad5fe0360a77c5632c56dae2985509","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public boolean generateHTML(String title, StringBuilder sb) {\n    if (_key == null) {\n      DocGen.HTML.title(sb, \"No model yet\");\n      return true;\n    }\n\n    final String mse_format = \"%g\";\n//    final String cross_entropy_format = \"%2.6f\";\n\n    // stats for training and validation\n    final Errors error = last_scored();\n\n    DocGen.HTML.title(sb, title);\n\n    job().toHTML(sb);\n    final Key val_key = get_params().validation != null ? get_params().validation._key : null;\n    sb.append(\"<div class='alert'>Actions: \"\n            + (UKV.get(jobKey) != null && Job.isRunning(jobKey) ? \"<i class=\\\"icon-stop\\\"><\/i>\" + Cancel.link(jobKey, \"Stop training\") + \", \" : \"\")\n            + Inspect2.link(\"Inspect training data (\" + _dataKey + \")\", _dataKey) + \", \"\n            + (val_key != null ? (Inspect2.link(\"Inspect validation data (\" + val_key + \")\", val_key) + \", \") : \"\")\n            + water.api.Predict.link(_key, \"Score on dataset\") + \", \"\n            + DeepLearning.link(_dataKey, \"Compute new model\", null, responseName(), val_key)\n            + (_bestModelKey != null && UKV.get(_bestModelKey) != null && _bestModelKey != _key ? \", \" + DeepLearningModelView.link(\"Go to best model\", _bestModelKey) : \"\")\n            + (UKV.get(jobKey) != null && Job.isEnded(jobKey) ? \", <i class=\\\"icon-play\\\"><\/i>\" + DeepLearning.link(_dataKey, \"Continue training this model\", _key, responseName(), val_key) : \"\")\n            + \"<\/div>\");\n\n    DocGen.HTML.paragraph(sb, \"Model Key: \" + _key);\n    DocGen.HTML.paragraph(sb, \"Job Key: \" + jobKey);\n    DocGen.HTML.paragraph(sb, \"Model type: \" + (get_params().classification ? \" Classification\" : \" Regression\") + \", predicting: \" + responseName());\n    DocGen.HTML.paragraph(sb, \"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_info().size()));\n\n    if (model_info.unstable()) {\n      final String msg = \"Job was aborted due to observed numerical instability (exponential growth).\"\n              + \" Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\";\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n      DocGen.HTML.section(sb, msg);\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n    }\n\n    DocGen.HTML.title(sb, \"Progress\");\n    // update epoch counter every time the website is displayed\n    epoch_counter = training_rows > 0 ? (float)model_info().get_processed_total()/training_rows : 0;\n    final double progress = get_params().progress();\n\n    if (get_params() != null && get_params().diagnostics) {\n      DocGen.HTML.section(sb, \"Status of Neuron Layers\");\n      sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n      sb.append(\"<tr>\");\n      sb.append(\"<th>\").append(\"#\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Units\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Type\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Dropout\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L1\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L2\").append(\"<\/th>\");\n      if (get_params().adaptive_rate) {\n        sb.append(\"<th>\").append(\"Rate (Mean, RMS)\").append(\"<\/th>\");\n      } else {\n        sb.append(\"<th>\").append(\"Rate\").append(\"<\/th>\");\n        sb.append(\"<th>\").append(\"Momentum\").append(\"<\/th>\");\n      }\n      sb.append(\"<th>\").append(\"Weight (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Bias (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<\/tr>\");\n      Neurons[] neurons = DeepLearningTask.makeNeuronsForTesting(model_info()); //link the weights to the neurons, for easy access\n      for (int i=0; i<neurons.length; ++i) {\n        sb.append(\"<tr>\");\n        sb.append(\"<td>\").append(\"<b>\").append(i+1).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(\"<b>\").append(neurons[i].units).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].getClass().getSimpleName()).append(\"<\/td>\");\n\n        if (i == 0) {\n          sb.append(\"<td>\");\n          sb.append(formatPct(neurons[i].params.input_dropout_ratio));\n          sb.append(\"<\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          if (!get_params().adaptive_rate) sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<\/tr>\");\n          continue;\n        }\n        else if (i < neurons.length-1) {\n          sb.append(\"<td>\");\n          sb.append(formatPct(neurons[i].params.hidden_dropout_ratios[i-1]));\n          sb.append(\"<\/td>\");\n        } else {\n          sb.append(\"<td><\/td>\");\n        }\n\n        final String format = \"%g\";\n        sb.append(\"<td>\").append(neurons[i].params.l1).append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].params.l2).append(\"<\/td>\");\n        if (get_params().adaptive_rate) {\n          sb.append(\"<td>(\").append(String.format(format, model_info.mean_rate[i])).\n                  append(\", \").append(String.format(format, model_info.rms_rate[i])).append(\")<\/td>\");\n        } else {\n          sb.append(\"<td>\").append(String.format(\"%.5g\", neurons[i].rate(error.training_samples))).append(\"<\/td>\");\n          sb.append(\"<td>\").append(String.format(\"%.5f\", neurons[i].momentum(error.training_samples))).append(\"<\/td>\");\n        }\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_weight[i])).\n                append(\", \").append(String.format(format, model_info.rms_weight[i])).append(\")<\/td>\");\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_bias[i])).\n                append(\", \").append(String.format(format, model_info.rms_bias[i])).append(\")<\/td>\");\n        sb.append(\"<\/tr>\");\n      }\n      sb.append(\"<\/table>\");\n    }\n\n    if (isClassifier()) {\n      DocGen.HTML.section(sb, \"Classification error on training data: \" + formatPct(error.train_err));\n//      DocGen.HTML.section(sb, \"Training cross entropy: \" + String.format(cross_entropy_format, error.train_mce));\n      if(error.validation) {\n        DocGen.HTML.section(sb, \"Classification error on validation data: \" + formatPct(error.valid_err));\n//        DocGen.HTML.section(sb, \"Validation mean cross entropy: \" + String.format(cross_entropy_format, error.valid_mce));\n      }\n    } else {\n      DocGen.HTML.section(sb, \"MSE on training data: \" + String.format(mse_format, error.train_mse));\n      if(error.validation) {\n        DocGen.HTML.section(sb, \"MSE on validation data: \" + String.format(mse_format, error.valid_mse));\n      }\n    }\n    DocGen.HTML.paragraph(sb, \"Training samples: \" + String.format(\"%,d\", model_info().get_processed_total()));\n    DocGen.HTML.paragraph(sb, \"Epochs: \" + String.format(\"%.3f\", epoch_counter) + \" / \" + String.format(\"%.3f\", get_params().epochs));\n    int cores = 0; for (H2ONode n : H2O.CLOUD._memary) cores += n._heartbeat._num_cpus;\n    DocGen.HTML.paragraph(sb, \"Number of compute nodes: \" + (model_info.get_params().single_node_mode ? (\"1 (\" + H2O.NUMCPUS + \" threads)\") : (H2O.CLOUD.size() + \" (\" + cores + \" threads)\")));\n    DocGen.HTML.paragraph(sb, \"Training samples per iteration: \" + String.format(\"%,d\", get_params().actual_train_samples_per_iteration));\n    final boolean isEnded = UKV.get(get_params().self()) != null && Job.isEnded(get_params().self());\n    final long time_so_far = isEnded ? run_time : run_time + System.currentTimeMillis() - _timeLastScoreEnter;\n    if (time_so_far > 0) {\n      DocGen.HTML.paragraph(sb, \"Training speed: \" + String.format(\"%,d\", model_info().get_processed_total() * 1000 / time_so_far) + \" samples/s\");\n    }\n    DocGen.HTML.paragraph(sb, \"Training time: \" + PrettyPrint.msecs(time_so_far, true));\n    if (progress > 0 && !isEnded)\n      DocGen.HTML.paragraph(sb, \"Estimated time left: \" +PrettyPrint.msecs((long)(time_so_far*(1-progress)/progress), true));\n\n    long score_train = error.score_training_samples;\n    long score_valid = error.score_validation_samples;\n    final boolean fulltrain = score_train==0 || score_train == training_rows;\n    final boolean fullvalid = score_valid==0 || score_valid == get_params().validation.numRows();\n\n    final String toolarge = \" Confusion matrix not shown here - too large: number of classes (\" + model_info.units[model_info.units.length-1]\n            + \") is greater than the specified limit of \" + get_params().max_confusion_matrix_size + \".\";\n    boolean smallenough = model_info.units[model_info.units.length-1] <= get_params().max_confusion_matrix_size;\n\n    if (isClassifier()) {\n      // print AUC\n      if (error.validAUC != null) {\n        error.validAUC.toHTML(sb);\n      }\n      else if (error.trainAUC != null) {\n        error.trainAUC.toHTML(sb);\n      }\n      else {\n        if (error.validation) {\n          RString v_rs = new RString(\"<a href='Inspect2.html?src_key=%$key'>%key<\/a>\");\n          v_rs.replace(\"key\", get_params().validation._key);\n          String cmTitle = \"<div class=\\\"alert\\\">Scoring results reported on validation data \" + v_rs.toString() + (fullvalid ? \"\" : \" (\" + score_valid + \" samples)\") + \":<\/div>\";\n          sb.append(\"<h5>\" + cmTitle);\n          if (error.valid_confusion_matrix != null && smallenough) {\n            sb.append(\"<\/h5>\");\n            error.valid_confusion_matrix.toHTML(sb);\n          } else if (smallenough) sb.append(\" Confusion matrix not yet computed.<\/h5>\");\n          else sb.append(toolarge + \"<\/h5>\");\n        } else {\n          RString t_rs = new RString(\"<a href='Inspect2.html?src_key=%$key'>%key<\/a>\");\n          t_rs.replace(\"key\", get_params().source._key);\n          String cmTitle = \"<div class=\\\"alert\\\">Scoring results reported on training data \" + t_rs.toString() + (fulltrain ? \"\" : \" (\" + score_train + \" samples)\") + \":<\/div>\";\n          sb.append(\"<h5>\" + cmTitle);\n          if (error.train_confusion_matrix != null && smallenough) {\n            sb.append(\"<\/h5>\");\n            error.train_confusion_matrix.toHTML(sb);\n          } else if (smallenough) sb.append(\" Confusion matrix not yet computed.<\/h5>\");\n          else sb.append(toolarge + \"<\/h5>\");\n        }\n      }\n    }\n\n    // Hit ratio\n    if (error.valid_hitratio != null) {\n      error.valid_hitratio.toHTML(sb);\n    } else if (error.train_hitratio != null) {\n      error.train_hitratio.toHTML(sb);\n    }\n\n    // Variable importance\n    if (error.variable_importances != null) {\n      error.variable_importances.toHTML(sb);\n    }\n\n    DocGen.HTML.title(sb, \"Scoring history\");\n    if (errors.length > 1) {\n      DocGen.HTML.paragraph(sb, \"Time taken for last scoring and diagnostics: \" + PrettyPrint.msecs(errors[errors.length-1].scoring_time, true));\n      // training\n      {\n        final long pts = fulltrain ? training_rows : score_train;\n        String training = \"Number of training data samples for scoring: \" + (fulltrain ? \"all \" : \"\") + pts;\n        if (pts < 1000 && training_rows >= 1000) training += \" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)\";\n        if (pts > 100000 && errors[errors.length-1].scoring_time > 10000) training += \" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)\";\n        DocGen.HTML.paragraph(sb, training);\n      }\n      // validation\n      if (error.validation) {\n        final long ptsv = fullvalid ? get_params().validation.numRows() : score_valid;\n        String validation = \"Number of validation data samples for scoring: \" + (fullvalid ? \"all \" : \"\") + ptsv;\n        if (ptsv < 1000 && get_params().validation.numRows() >= 1000) validation += \" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)\";\n        if (ptsv > 100000 && errors[errors.length-1].scoring_time > 10000) validation += \" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)\";\n        DocGen.HTML.paragraph(sb, validation);\n      }\n\n      if (isClassifier() && nclasses() != 2 /*binary classifier has its own conflicting D3 object (AUC)*/) {\n        // Plot training error\n        float[] err = new float[errors.length];\n        float[] samples = new float[errors.length];\n        for (int i=0; i<err.length; ++i) {\n          err[i] = (float)errors[i].train_err;\n          samples[i] = errors[i].training_samples;\n        }\n        new D3Plot(samples, err, \"training samples\", \"classification error\",\n                \"classification error on training data\").generate(sb);\n\n        // Plot validation error\n        if (get_params().validation != null) {\n          for (int i=0; i<err.length; ++i) {\n            err[i] = (float)errors[i].valid_err;\n          }\n          new D3Plot(samples, err, \"training samples\", \"classification error\",\n                  \"classification error on validation set\").generate(sb);\n        }\n      }\n      // regression\n      else if (!isClassifier()) {\n        // Plot training MSE\n        float[] err = new float[errors.length-1];\n        float[] samples = new float[errors.length-1];\n        for (int i=0; i<err.length; ++i) {\n          err[i] = (float)errors[i+1].train_mse;\n          samples[i] = errors[i+1].training_samples;\n        }\n        new D3Plot(samples, err, \"training samples\", \"MSE\",\n                \"regression error on training data\").generate(sb);\n\n        // Plot validation MSE\n        if (get_params().validation != null) {\n          for (int i=0; i<err.length; ++i) {\n            err[i] = (float)errors[i+1].valid_mse;\n          }\n          new D3Plot(samples, err, \"training samples\", \"MSE\",\n                  \"regression error on validation data\").generate(sb);\n        }\n      }\n    }\n\n//    String training = \"Number of training set samples for scoring: \" + error.score_training;\n    if (error.validation) {\n//      String validation = \"Number of validation set samples for scoring: \" + error.score_validation;\n    }\n    sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n    sb.append(\"<tr>\");\n    sb.append(\"<th>Training Time<\/th>\");\n    sb.append(\"<th>Training Epochs<\/th>\");\n    sb.append(\"<th>Training Samples<\/th>\");\n    if (isClassifier()) {\n//      sb.append(\"<th>Training MCE<\/th>\");\n      sb.append(\"<th>Training Error<\/th>\");\n      if (nclasses()==2) sb.append(\"<th>Training AUC<\/th>\");\n    } else {\n      sb.append(\"<th>Training MSE<\/th>\");\n    }\n    if (error.validation) {\n      if (isClassifier()) {\n//      sb.append(\"<th>Validation MCE<\/th>\");\n        sb.append(\"<th>Validation Error<\/th>\");\n        if (nclasses()==2) sb.append(\"<th>Validation AUC<\/th>\");\n      } else {\n        sb.append(\"<th>Validation MSE<\/th>\");\n      }\n    }\n    sb.append(\"<\/tr>\");\n    for( int i = errors.length - 1; i >= 0; i-- ) {\n      final Errors e = errors[i];\n      sb.append(\"<tr>\");\n      sb.append(\"<td>\" + PrettyPrint.msecs(e.training_time_ms, true) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(\"%g\", e.epoch_counter) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(\"%,d\", e.training_samples) + \"<\/td>\");\n      if (isClassifier()) {\n//        sb.append(\"<td>\" + String.format(cross_entropy_format, e.train_mce) + \"<\/td>\");\n        sb.append(\"<td>\" + formatPct(e.train_err) + \"<\/td>\");\n        if (nclasses()==2) {\n          if (e.trainAUC != null) sb.append(\"<td>\" + formatPct(e.trainAUC.AUC()) + \"<\/td>\");\n          else sb.append(\"<td>\" + \"N/A\" + \"<\/td>\");\n        }\n      } else {\n        sb.append(\"<td>\" + String.format(mse_format, e.train_mse) + \"<\/td>\");\n      }\n      if(e.validation) {\n        if (isClassifier()) {\n//          sb.append(\"<td>\" + String.format(cross_entropy_format, e.valid_mce) + \"<\/td>\");\n          sb.append(\"<td>\" + formatPct(e.valid_err) + \"<\/td>\");\n          if (nclasses()==2) {\n            if (e.validAUC != null) sb.append(\"<td>\" + formatPct(e.validAUC.AUC()) + \"<\/td>\");\n            else sb.append(\"<td>\" + \"N/A\" + \"<\/td>\");\n          }\n        } else {\n          sb.append(\"<td>\" + String.format(mse_format, e.valid_mse) + \"<\/td>\");\n        }\n      }\n      sb.append(\"<\/tr>\");\n    }\n    sb.append(\"<\/table>\");\n    return true;\n  }","id":78129,"modified_method":"public boolean generateHTML(String title, StringBuilder sb) {\n    if (_key == null) {\n      DocGen.HTML.title(sb, \"No model yet\");\n      return true;\n    }\n\n    final String mse_format = \"%g\";\n//    final String cross_entropy_format = \"%2.6f\";\n\n    // stats for training and validation\n    final Errors error = last_scored();\n\n    DocGen.HTML.title(sb, title);\n\n    final Key val_key = get_params().validation != null ? get_params().validation._key : null;\n    final Key bestModelKey = get_params().best_model_key;\n    sb.append(\"<div class='alert'>Actions: \"\n            + (jobKey != null && UKV.get(jobKey) != null && Job.isRunning(jobKey) ? \"<i class=\\\"icon-stop\\\"><\/i>\" + Cancel.link(jobKey, \"Stop training\") + \", \" : \"\")\n            + Inspect2.link(\"Inspect training data (\" + _dataKey + \")\", _dataKey) + \", \"\n            + (val_key != null ? (Inspect2.link(\"Inspect validation data (\" + val_key + \")\", val_key) + \", \") : \"\")\n            + water.api.Predict.link(_key, \"Score on dataset\") + \", \"\n            + DeepLearning.link(_dataKey, \"Compute new model\", null, responseName(), val_key)\n            + (bestModelKey != null && UKV.get(bestModelKey) != null && bestModelKey != _key ? \", \" + DeepLearningModelView.link(\"Go to best model\", bestModelKey) : \"\")\n            + (jobKey == null || (UKV.get(jobKey) != null && Job.isEnded(jobKey)) ? \", <i class=\\\"icon-play\\\"><\/i>\" + DeepLearning.link(_dataKey, \"Continue training this model\", _key, responseName(), val_key) : \"\")\n            + \"<\/div>\");\n\n    DocGen.HTML.paragraph(sb, \"Model Key: \" + _key);\n    if (jobKey != null) DocGen.HTML.paragraph(sb, \"Job Key: \" + jobKey);\n    DocGen.HTML.paragraph(sb, \"Model type: \" + (get_params().classification ? \" Classification\" : \" Regression\") + \", predicting: \" + responseName());\n    DocGen.HTML.paragraph(sb, \"Number of model parameters (weights/biases): \" + String.format(\"%,d\", model_info().size()));\n\n    if (model_info.unstable()) {\n      final String msg = \"Job was aborted due to observed numerical instability (exponential growth).\"\n              + \" Try a bounded activation function or regularization with L1, L2 or max_w2 and/or use a smaller learning rate or faster annealing.\";\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n      DocGen.HTML.section(sb, msg);\n      DocGen.HTML.section(sb, \"=======================================================================================\");\n    }\n\n    DocGen.HTML.title(sb, \"Progress\");\n    // update epoch counter every time the website is displayed\n    epoch_counter = training_rows > 0 ? (float)model_info().get_processed_total()/training_rows : 0;\n    final double progress = get_params().progress();\n\n    if (get_params() != null && get_params().diagnostics) {\n      DocGen.HTML.section(sb, \"Status of Neuron Layers\");\n      sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n      sb.append(\"<tr>\");\n      sb.append(\"<th>\").append(\"#\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Units\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Type\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Dropout\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L1\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"L2\").append(\"<\/th>\");\n      if (get_params().adaptive_rate) {\n        sb.append(\"<th>\").append(\"Rate (Mean, RMS)\").append(\"<\/th>\");\n      } else {\n        sb.append(\"<th>\").append(\"Rate\").append(\"<\/th>\");\n        sb.append(\"<th>\").append(\"Momentum\").append(\"<\/th>\");\n      }\n      sb.append(\"<th>\").append(\"Weight (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<th>\").append(\"Bias (Mean, RMS)\").append(\"<\/th>\");\n      sb.append(\"<\/tr>\");\n      Neurons[] neurons = DeepLearningTask.makeNeuronsForTesting(model_info()); //link the weights to the neurons, for easy access\n      for (int i=0; i<neurons.length; ++i) {\n        sb.append(\"<tr>\");\n        sb.append(\"<td>\").append(\"<b>\").append(i+1).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(\"<b>\").append(neurons[i].units).append(\"<\/b>\").append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].getClass().getSimpleName()).append(\"<\/td>\");\n\n        if (i == 0) {\n          sb.append(\"<td>\");\n          sb.append(formatPct(neurons[i].params.input_dropout_ratio));\n          sb.append(\"<\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          if (!get_params().adaptive_rate) sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<td><\/td>\");\n          sb.append(\"<\/tr>\");\n          continue;\n        }\n        else if (i < neurons.length-1) {\n          sb.append(\"<td>\");\n          sb.append(formatPct(neurons[i].params.hidden_dropout_ratios[i-1]));\n          sb.append(\"<\/td>\");\n        } else {\n          sb.append(\"<td><\/td>\");\n        }\n\n        final String format = \"%g\";\n        sb.append(\"<td>\").append(neurons[i].params.l1).append(\"<\/td>\");\n        sb.append(\"<td>\").append(neurons[i].params.l2).append(\"<\/td>\");\n        if (get_params().adaptive_rate) {\n          sb.append(\"<td>(\").append(String.format(format, model_info.mean_rate[i])).\n                  append(\", \").append(String.format(format, model_info.rms_rate[i])).append(\")<\/td>\");\n        } else {\n          sb.append(\"<td>\").append(String.format(\"%.5g\", neurons[i].rate(error.training_samples))).append(\"<\/td>\");\n          sb.append(\"<td>\").append(String.format(\"%.5f\", neurons[i].momentum(error.training_samples))).append(\"<\/td>\");\n        }\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_weight[i])).\n                append(\", \").append(String.format(format, model_info.rms_weight[i])).append(\")<\/td>\");\n        sb.append(\"<td>(\").append(String.format(format, model_info.mean_bias[i])).\n                append(\", \").append(String.format(format, model_info.rms_bias[i])).append(\")<\/td>\");\n        sb.append(\"<\/tr>\");\n      }\n      sb.append(\"<\/table>\");\n    }\n\n    if (isClassifier()) {\n      DocGen.HTML.section(sb, \"Classification error on training data: \" + formatPct(error.train_err));\n//      DocGen.HTML.section(sb, \"Training cross entropy: \" + String.format(cross_entropy_format, error.train_mce));\n      if(error.validation) {\n        DocGen.HTML.section(sb, \"Classification error on validation data: \" + formatPct(error.valid_err));\n//        DocGen.HTML.section(sb, \"Validation mean cross entropy: \" + String.format(cross_entropy_format, error.valid_mce));\n      }\n    } else {\n      DocGen.HTML.section(sb, \"MSE on training data: \" + String.format(mse_format, error.train_mse));\n      if(error.validation) {\n        DocGen.HTML.section(sb, \"MSE on validation data: \" + String.format(mse_format, error.valid_mse));\n      }\n    }\n    DocGen.HTML.paragraph(sb, \"Training samples: \" + String.format(\"%,d\", model_info().get_processed_total()));\n    DocGen.HTML.paragraph(sb, \"Epochs: \" + String.format(\"%.3f\", epoch_counter) + \" / \" + String.format(\"%.3f\", get_params().epochs));\n    int cores = 0; for (H2ONode n : H2O.CLOUD._memary) cores += n._heartbeat._num_cpus;\n    DocGen.HTML.paragraph(sb, \"Number of compute nodes: \" + (model_info.get_params().single_node_mode ? (\"1 (\" + H2O.NUMCPUS + \" threads)\") : (H2O.CLOUD.size() + \" (\" + cores + \" threads)\")));\n    DocGen.HTML.paragraph(sb, \"Training samples per iteration: \" + String.format(\"%,d\", get_params().actual_train_samples_per_iteration));\n    final boolean isEnded = get_params().self() == null || (UKV.get(get_params().self()) != null && Job.isEnded(get_params().self()));\n    final long time_so_far = isEnded ? run_time : run_time + System.currentTimeMillis() - _timeLastScoreEnter;\n    if (time_so_far > 0) {\n      DocGen.HTML.paragraph(sb, \"Training speed: \" + String.format(\"%,d\", model_info().get_processed_total() * 1000 / time_so_far) + \" samples/s\");\n    }\n    DocGen.HTML.paragraph(sb, \"Training time: \" + PrettyPrint.msecs(time_so_far, true));\n    if (progress > 0 && !isEnded)\n      DocGen.HTML.paragraph(sb, \"Estimated time left: \" +PrettyPrint.msecs((long)(time_so_far*(1-progress)/progress), true));\n\n    long score_train = error.score_training_samples;\n    long score_valid = error.score_validation_samples;\n    final boolean fulltrain = score_train==0 || score_train == training_rows;\n    final boolean fullvalid = score_valid==0 || score_valid == get_params().validation.numRows();\n\n    final String toolarge = \" Confusion matrix not shown here - too large: number of classes (\" + model_info.units[model_info.units.length-1]\n            + \") is greater than the specified limit of \" + get_params().max_confusion_matrix_size + \".\";\n    boolean smallenough = model_info.units[model_info.units.length-1] <= get_params().max_confusion_matrix_size;\n\n    if (isClassifier()) {\n      // print AUC\n      if (error.validAUC != null) {\n        error.validAUC.toHTML(sb);\n      }\n      else if (error.trainAUC != null) {\n        error.trainAUC.toHTML(sb);\n      }\n      else {\n        if (error.validation) {\n          RString v_rs = new RString(\"<a href='Inspect2.html?src_key=%$key'>%key<\/a>\");\n          v_rs.replace(\"key\", get_params().validation._key);\n          String cmTitle = \"<div class=\\\"alert\\\">Scoring results reported on validation data \" + v_rs.toString() + (fullvalid ? \"\" : \" (\" + score_valid + \" samples)\") + \":<\/div>\";\n          sb.append(\"<h5>\" + cmTitle);\n          if (error.valid_confusion_matrix != null && smallenough) {\n            sb.append(\"<\/h5>\");\n            error.valid_confusion_matrix.toHTML(sb);\n          } else if (smallenough) sb.append(\" Confusion matrix not yet computed.<\/h5>\");\n          else sb.append(toolarge + \"<\/h5>\");\n        } else {\n          RString t_rs = new RString(\"<a href='Inspect2.html?src_key=%$key'>%key<\/a>\");\n          t_rs.replace(\"key\", get_params().source._key);\n          String cmTitle = \"<div class=\\\"alert\\\">Scoring results reported on training data \" + t_rs.toString() + (fulltrain ? \"\" : \" (\" + score_train + \" samples)\") + \":<\/div>\";\n          sb.append(\"<h5>\" + cmTitle);\n          if (error.train_confusion_matrix != null && smallenough) {\n            sb.append(\"<\/h5>\");\n            error.train_confusion_matrix.toHTML(sb);\n          } else if (smallenough) sb.append(\" Confusion matrix not yet computed.<\/h5>\");\n          else sb.append(toolarge + \"<\/h5>\");\n        }\n      }\n    }\n\n    // Hit ratio\n    if (error.valid_hitratio != null) {\n      error.valid_hitratio.toHTML(sb);\n    } else if (error.train_hitratio != null) {\n      error.train_hitratio.toHTML(sb);\n    }\n\n    // Variable importance\n    if (error.variable_importances != null) {\n      error.variable_importances.toHTML(sb);\n    }\n\n    DocGen.HTML.title(sb, \"Scoring history\");\n    if (errors.length > 1) {\n      DocGen.HTML.paragraph(sb, \"Time taken for last scoring and diagnostics: \" + PrettyPrint.msecs(errors[errors.length-1].scoring_time, true));\n      // training\n      {\n        final long pts = fulltrain ? training_rows : score_train;\n        String training = \"Number of training data samples for scoring: \" + (fulltrain ? \"all \" : \"\") + pts;\n        if (pts < 1000 && training_rows >= 1000) training += \" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)\";\n        if (pts > 100000 && errors[errors.length-1].scoring_time > 10000) training += \" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)\";\n        DocGen.HTML.paragraph(sb, training);\n      }\n      // validation\n      if (error.validation) {\n        final long ptsv = fullvalid ? get_params().validation.numRows() : score_valid;\n        String validation = \"Number of validation data samples for scoring: \" + (fullvalid ? \"all \" : \"\") + ptsv;\n        if (ptsv < 1000 && get_params().validation.numRows() >= 1000) validation += \" (low, scoring might be inaccurate -> consider increasing this number in the expert mode)\";\n        if (ptsv > 100000 && errors[errors.length-1].scoring_time > 10000) validation += \" (large, scoring can be slow -> consider reducing this number in the expert mode or scoring manually)\";\n        DocGen.HTML.paragraph(sb, validation);\n      }\n\n      if (isClassifier() && nclasses() != 2 /*binary classifier has its own conflicting D3 object (AUC)*/) {\n        // Plot training error\n        float[] err = new float[errors.length];\n        float[] samples = new float[errors.length];\n        for (int i=0; i<err.length; ++i) {\n          err[i] = (float)errors[i].train_err;\n          samples[i] = errors[i].training_samples;\n        }\n        new D3Plot(samples, err, \"training samples\", \"classification error\",\n                \"classification error on training data\").generate(sb);\n\n        // Plot validation error\n        if (get_params().validation != null) {\n          for (int i=0; i<err.length; ++i) {\n            err[i] = (float)errors[i].valid_err;\n          }\n          new D3Plot(samples, err, \"training samples\", \"classification error\",\n                  \"classification error on validation set\").generate(sb);\n        }\n      }\n      // regression\n      else if (!isClassifier()) {\n        // Plot training MSE\n        float[] err = new float[errors.length-1];\n        float[] samples = new float[errors.length-1];\n        for (int i=0; i<err.length; ++i) {\n          err[i] = (float)errors[i+1].train_mse;\n          samples[i] = errors[i+1].training_samples;\n        }\n        new D3Plot(samples, err, \"training samples\", \"MSE\",\n                \"regression error on training data\").generate(sb);\n\n        // Plot validation MSE\n        if (get_params().validation != null) {\n          for (int i=0; i<err.length; ++i) {\n            err[i] = (float)errors[i+1].valid_mse;\n          }\n          new D3Plot(samples, err, \"training samples\", \"MSE\",\n                  \"regression error on validation data\").generate(sb);\n        }\n      }\n    }\n\n//    String training = \"Number of training set samples for scoring: \" + error.score_training;\n    if (error.validation) {\n//      String validation = \"Number of validation set samples for scoring: \" + error.score_validation;\n    }\n    sb.append(\"<table class='table table-striped table-bordered table-condensed'>\");\n    sb.append(\"<tr>\");\n    sb.append(\"<th>Training Time<\/th>\");\n    sb.append(\"<th>Training Epochs<\/th>\");\n    sb.append(\"<th>Training Samples<\/th>\");\n    if (isClassifier()) {\n//      sb.append(\"<th>Training MCE<\/th>\");\n      sb.append(\"<th>Training Error<\/th>\");\n      if (nclasses()==2) sb.append(\"<th>Training AUC<\/th>\");\n    } else {\n      sb.append(\"<th>Training MSE<\/th>\");\n    }\n    if (error.validation) {\n      if (isClassifier()) {\n//      sb.append(\"<th>Validation MCE<\/th>\");\n        sb.append(\"<th>Validation Error<\/th>\");\n        if (nclasses()==2) sb.append(\"<th>Validation AUC<\/th>\");\n      } else {\n        sb.append(\"<th>Validation MSE<\/th>\");\n      }\n    }\n    sb.append(\"<\/tr>\");\n    for( int i = errors.length - 1; i >= 0; i-- ) {\n      final Errors e = errors[i];\n      sb.append(\"<tr>\");\n      sb.append(\"<td>\" + PrettyPrint.msecs(e.training_time_ms, true) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(\"%g\", e.epoch_counter) + \"<\/td>\");\n      sb.append(\"<td>\" + String.format(\"%,d\", e.training_samples) + \"<\/td>\");\n      if (isClassifier()) {\n//        sb.append(\"<td>\" + String.format(cross_entropy_format, e.train_mce) + \"<\/td>\");\n        sb.append(\"<td>\" + formatPct(e.train_err) + \"<\/td>\");\n        if (nclasses()==2) {\n          if (e.trainAUC != null) sb.append(\"<td>\" + formatPct(e.trainAUC.AUC()) + \"<\/td>\");\n          else sb.append(\"<td>\" + \"N/A\" + \"<\/td>\");\n        }\n      } else {\n        sb.append(\"<td>\" + String.format(mse_format, e.train_mse) + \"<\/td>\");\n      }\n      if(e.validation) {\n        if (isClassifier()) {\n//          sb.append(\"<td>\" + String.format(cross_entropy_format, e.valid_mce) + \"<\/td>\");\n          sb.append(\"<td>\" + formatPct(e.valid_err) + \"<\/td>\");\n          if (nclasses()==2) {\n            if (e.validAUC != null) sb.append(\"<td>\" + formatPct(e.validAUC.AUC()) + \"<\/td>\");\n            else sb.append(\"<td>\" + \"N/A\" + \"<\/td>\");\n          }\n        } else {\n          sb.append(\"<td>\" + String.format(mse_format, e.valid_mse) + \"<\/td>\");\n        }\n      }\n      sb.append(\"<\/tr>\");\n    }\n    sb.append(\"<\/table>\");\n    return true;\n  }","commit_id":"6a77a929b7ad5fe0360a77c5632c56dae2985509","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public DeepLearningModel(final Key selfKey, final Key jobKey, final Key dataKey, final DataInfo dinfo, final DeepLearning params, final float[] priorDist) {\n    super(selfKey, dataKey, dinfo._adaptedFrame, priorDist);\n    this.jobKey = jobKey;\n    run_time = 0;\n    start_time = System.currentTimeMillis();\n    _timeLastScoreEnter = start_time;\n    model_info = new DeepLearningModelInfo(params, dinfo);\n    errors = new Errors[1];\n    errors[0] = new Errors();\n    errors[0].validation = (params.validation != null);\n  }","id":78130,"modified_method":"public DeepLearningModel(final Key destKey, final Key jobKey, final Key dataKey, final DataInfo dinfo, final DeepLearning params, final float[] priorDist) {\n    super(destKey, dataKey, dinfo._adaptedFrame, priorDist);\n    this.jobKey = jobKey;\n    run_time = 0;\n    start_time = System.currentTimeMillis();\n    _timeLastScoreEnter = start_time;\n    model_info = new DeepLearningModelInfo(params, dinfo);\n    errors = new Errors[1];\n    errors[0] = new Errors();\n    errors[0].validation = (params.validation != null);\n    assert(Arrays.equals(_key._kb, destKey._kb));\n  }","commit_id":"6a77a929b7ad5fe0360a77c5632c56dae2985509","url":"https://github.com/h2oai/h2o-2"},{"original_method":"/**\n   * Constructor to restart from a checkpointed model\n   * @param cp Checkpoint to restart from\n   * @param destKey New destination key for the model\n   * @param jobKey New job key (job which updates the model)\n   */\n  public DeepLearningModel(final DeepLearningModel cp, final Key destKey, final Key jobKey, final DataInfo dataInfo) {\n    super(destKey, cp._dataKey, dataInfo._adaptedFrame.names(), dataInfo._adaptedFrame.domains(), cp._priorClassDist);\n    this.jobKey = jobKey;\n    model_info = (DeepLearningModelInfo)cp.model_info.clone(); //this clones the parameters too\n    model_info.data_info = dataInfo; //replace previous data_info with updated version that's passed in (contains enum for classification)\n    assert(cp.get_params().classification == get_params().classification);\n    get_params().checkpoint = cp._key;\n    get_params().destination_key = destKey;\n    get_params().job_key = jobKey;\n    start_time = cp.start_time;\n    run_time = cp.run_time;\n    errors = cp.errors.clone();\n    training_rows = cp.training_rows; //copy the value to display the right number on the model page before training has started\n    get_params().start_time = System.currentTimeMillis(); //for displaying the model progress\n    _bestModelKey = cp._bestModelKey;\n    _bestError = cp._bestError;\n    _timeLastScoreEnter = System.currentTimeMillis();\n    _timeLastScoreStart = 0;\n    _timeLastScoreEnd = 0;\n    _timeLastPrintStart = 0;\n    model_info().get_params().state = Job.JobState.RUNNING;\n  }","id":78131,"modified_method":"/**\n   * Constructor to restart from a checkpointed model\n   * @param cp Checkpoint to restart from\n   * @param destKey New destination key for the model\n   * @param jobKey New job key (job which updates the model)\n   */\n  public DeepLearningModel(final DeepLearningModel cp, final Key destKey, final Key jobKey, final DataInfo dataInfo) {\n    super(destKey, cp._dataKey, dataInfo._adaptedFrame.names(), dataInfo._adaptedFrame.domains(), cp._priorClassDist);\n    this.jobKey = jobKey;\n    model_info = (DeepLearningModelInfo)cp.model_info.clone(); //this clones the parameters too\n    model_info.data_info = dataInfo; //replace previous data_info with updated version that's passed in (contains enum for classification)\n    if (jobKey != null) get_params().checkpoint = cp._key;\n    get_params().destination_key = destKey;\n    get_params().job_key = jobKey != null ? jobKey : cp.jobKey;\n    start_time = cp.start_time;\n    run_time = cp.run_time;\n    errors = cp.errors.clone();\n    training_rows = cp.training_rows; //copy the value to display the right number on the model page before training has started\n    get_params().start_time = System.currentTimeMillis(); //for displaying the model progress\n    _bestError = cp._bestError;\n    _timeLastScoreEnter = System.currentTimeMillis();\n    _timeLastScoreStart = 0;\n    _timeLastScoreEnd = 0;\n    _timeLastPrintStart = 0;\n    model_info().get_params().state = Job.JobState.RUNNING;\n    assert(Arrays.equals(_key._kb, destKey._kb));\n  }","commit_id":"6a77a929b7ad5fe0360a77c5632c56dae2985509","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void runFraction(float fraction) {\n    long seed = 0xDECAF;\n    Random rng = new Random(seed);\n    String[] datasets = new String[2];\n    int[][] responses = new int[datasets.length][];\n    datasets[0] = \"smalldata/./logreg/prostate.csv\"; responses[0] = new int[]{1,2,8};\n    datasets[1] = \"smalldata/iris/iris.csv\";  responses[1] = new int[]{4};\n\n    int count = 0;\n    for (int i =0;i<datasets.length;++i) {\n      String dataset = datasets[i];\n      Key file = NFSFileVec.make(find_test_file(dataset));\n      Frame frame = ParseDataset2.parse(Key.make(), new Key[]{file});\n      Key vfile = NFSFileVec.make(find_test_file(dataset));\n      Frame vframe = ParseDataset2.parse(Key.make(), new Key[]{vfile});\n\n      for (boolean replicate : new boolean[]{\n              true,\n              false,\n      }) {\n        for (boolean load_balance : new boolean[]{\n                true,\n                false,\n        }) {\n          for (boolean shuffle : new boolean[]{\n                  true,\n                  false,\n          }) {\n            for (boolean balance_classes : new boolean[]{\n                    true,\n                    false,\n            }) {\n              for (int resp : responses[i]) {\n                for (DeepLearning.ClassSamplingMethod csm : new DeepLearning.ClassSamplingMethod[] {\n                        DeepLearning.ClassSamplingMethod.Stratified,\n                        DeepLearning.ClassSamplingMethod.Uniform\n                }) {\n                  for (int scoretraining : new int[]{\n                          200,\n                          0,\n                  }) {\n                    for (int scorevalidation : new int[]{\n                            200,\n                            0,\n                    }) {\n                      for (int vf : new int[]{\n                              0,  //no validation\n                              1,  //same as source\n                              -1, //different validation frame\n                      }) {\n                        count++;\n                        if (fraction < rng.nextFloat()) continue;\n                        Log.info(\"**************************)\");\n                        Log.info(\"Starting test #\" + count);\n                        Log.info(\"**************************)\");\n                        Frame valid = null; //no validation\n                        if (vf == 1) valid = frame; //use the same frame for validation\n                        else if (vf == -1) valid = vframe; //different validation frame (here: from the same file)\n\n                        Key dest = Key.make();\n\n                        // build the model, with all kinds of shuffling/rebalancing/sampling\n                        {\n                          Log.info(\"Using seed: \" + seed);\n                          DeepLearning p = new DeepLearning();\n                          p.epochs = 1.0 + rng.nextDouble();\n                          p.source = frame;\n                          p.hidden = new int[]{1+rng.nextInt(4), 1+rng.nextInt(6)};\n                          p.response = frame.vecs()[resp];\n                          if (i == 0 && resp == 2) p.classification = false;\n                          p.destination_key = dest;\n                          p.seed = seed;\n                          p.validation = valid;\n                          p.train_samples_per_iteration = 0;\n                          p.force_load_balance = load_balance;\n                          p.replicate_training_data = replicate;\n                          p.shuffle_training_data = shuffle;\n                          p.score_training_samples = scoretraining;\n                          p.score_validation_samples = scorevalidation;\n                          p.balance_classes = balance_classes;\n                          p.quiet_mode = true;\n                          p.score_validation_sampling = csm;\n//                      p.execImpl();\n\n                          // Train the model via checkpointing\n                          DeepLearningModel mymodel = p.initModel();\n                          p.trainModel(mymodel);\n                          p.trainModel(mymodel, p.epochs); //incremental training\n                          p.delete();\n                        }\n\n                        // score and check result (on full data)\n                        final DeepLearningModel mymodel = UKV.get(dest); //this actually *requires* frame to also still be in UKV (because of DataInfo...)\n                        // test HTML\n                        {\n                          StringBuilder sb = new StringBuilder();\n                          mymodel.generateHTML(\"test\", sb);\n                        }\n                        if (valid == null ) valid = frame;\n                        if (mymodel.isClassifier()) {\n                          Frame pred = mymodel.score(valid);\n                          StringBuilder sb = new StringBuilder();\n\n                          AUC auc = new AUC();\n                          double threshold = 0;\n                          double error = 0;\n                          // binary\n                          if (mymodel.nclasses()==2) {\n                            auc.actual = valid;\n                            auc.vactual = valid.vecs()[resp];\n                            auc.predict = pred;\n                            auc.vpredict = pred.vecs()[2];\n                            auc.threshold_criterion = AUC.ThresholdCriterion.maximum_F1;\n                            auc.invoke();\n                            auc.toASCII(sb);\n                            threshold = auc.threshold();\n                            error = auc.err();\n                            Log.info(sb);\n\n                            // check that auc.cm() is the right CM\n                            Assert.assertEquals(new ConfusionMatrix(auc.cm()).err(), error, 1e-15);\n\n                            // check that calcError() is consistent as well (for CM=null, AUC!=null)\n                            Assert.assertEquals(mymodel.calcError(valid, valid.lastVec(), pred, pred, \"training\", false, 0, null, auc, null), error, 1e-15);\n                          }\n\n                          // Compute CM\n                          double CMerrorOrig;\n                          {\n                            sb = new StringBuilder();\n                            water.api.ConfusionMatrix CM = new water.api.ConfusionMatrix();\n                            CM.actual = valid;\n                            CM.vactual = valid.vecs()[resp];\n                            CM.predict = pred;\n                            CM.vpredict = pred.vecs()[0];\n                            CM.invoke();\n                            sb.append(\"\\n\");\n                            CM.toASCII(sb);\n                            Log.info(sb);\n                            CMerrorOrig = new ConfusionMatrix(CM.cm).err();\n                          }\n\n                          // confirm that orig CM was made with threshold 0.5\n                          // put pred2 into UKV, and allow access\n                          Frame pred2 = new Frame(Key.make(\"pred2\"), pred.names(), pred.vecs());\n                          pred2.delete_and_lock(null);\n                          pred2.unlock(null);\n\n                          if (mymodel.nclasses()==2) {\n                            // make labels with 0.5 threshold for binary classifier\n                            Env ev = Exec2.exec(\"pred2[,1]=pred2[,3]>=\" + 0.5);\n                            pred2 = ev.popAry();\n                            ev.subRef(pred2, \"pred2\");\n                            ev.remove_and_unlock();\n\n                            water.api.ConfusionMatrix CM = new water.api.ConfusionMatrix();\n                            CM.actual = valid;\n                            CM.vactual = valid.vecs()[1];\n                            CM.predict = pred2;\n                            CM.vpredict = pred2.vecs()[0];\n                            CM.invoke();\n                            sb = new StringBuilder();\n                            sb.append(\"\\n\");\n                            CM.toASCII(sb);\n                            Log.info(sb);\n                            double threshErr = new ConfusionMatrix(CM.cm).err();\n                            Assert.assertEquals(threshErr, CMerrorOrig, 1e-15);\n\n                            // make labels with AUC-given threshold for best F1\n                            ev = Exec2.exec(\"pred2[,1]=pred2[,3]>=\" + threshold);\n                            pred2 = ev.popAry();\n                            ev.subRef(pred2, \"pred2\");\n                            ev.remove_and_unlock();\n\n                            CM = new water.api.ConfusionMatrix();\n                            CM.actual = valid;\n                            CM.vactual = valid.vecs()[1];\n                            CM.predict = pred2;\n                            CM.vpredict = pred2.vecs()[0];\n                            CM.invoke();\n                            sb = new StringBuilder();\n                            sb.append(\"\\n\");\n                            CM.toASCII(sb);\n                            Log.info(sb);\n                            double threshErr2 = new ConfusionMatrix(CM.cm).err();\n                            Assert.assertEquals(threshErr2, error, 1e-15);\n                          }\n                          pred2.delete();\n                          pred.delete();\n                        } //classifier\n                        mymodel.delete();\n                        UKV.remove(dest);\n                        Log.info(\"Parameters combination \" + count + \": PASS\");\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      frame.delete();\n      vframe.delete();\n    }\n  }","id":78132,"modified_method":"public void runFraction(float fraction) {\n    long seed = 0xDECAF;\n    Random rng = new Random(seed);\n    String[] datasets = new String[2];\n    int[][] responses = new int[datasets.length][];\n    datasets[0] = \"smalldata/./logreg/prostate.csv\"; responses[0] = new int[]{1,2,8};\n    datasets[1] = \"smalldata/iris/iris.csv\";  responses[1] = new int[]{4};\n\n    int count = 0;\n    for (int i =0;i<datasets.length;++i) {\n      String dataset = datasets[i];\n      Key file = NFSFileVec.make(find_test_file(dataset));\n      Frame frame = ParseDataset2.parse(Key.make(), new Key[]{file});\n      Key vfile = NFSFileVec.make(find_test_file(dataset));\n      Frame vframe = ParseDataset2.parse(Key.make(), new Key[]{vfile});\n\n      for (boolean replicate : new boolean[]{\n              true,\n              false,\n      }) {\n        for (boolean load_balance : new boolean[]{\n                true,\n                false,\n        }) {\n          for (boolean shuffle : new boolean[]{\n                  true,\n                  false,\n          }) {\n            for (boolean balance_classes : new boolean[]{\n                    true,\n                    false,\n            }) {\n              for (int resp : responses[i]) {\n                for (DeepLearning.ClassSamplingMethod csm : new DeepLearning.ClassSamplingMethod[] {\n                        DeepLearning.ClassSamplingMethod.Stratified,\n                        DeepLearning.ClassSamplingMethod.Uniform\n                }) {\n                  for (int scoretraining : new int[]{\n                          200,\n                          0,\n                  }) {\n                    for (int scorevalidation : new int[]{\n                            200,\n                            0,\n                    }) {\n                      for (int vf : new int[]{\n                              0,  //no validation\n                              1,  //same as source\n                              -1, //different validation frame\n                      }) {\n                        for (Key best_model_key : new Key[]{null, Key.make()}) {\n                          count++;\n                          if (fraction < rng.nextFloat()) continue;\n                          Log.info(\"**************************)\");\n                          Log.info(\"Starting test #\" + count);\n                          Log.info(\"**************************)\");\n                          Frame valid = null; //no validation\n                          if (vf == 1) valid = frame; //use the same frame for validation\n                          else if (vf == -1) valid = vframe; //different validation frame (here: from the same file)\n\n                          Key dest = Key.make();\n\n                          // build the model, with all kinds of shuffling/rebalancing/sampling\n                          {\n                            Log.info(\"Using seed: \" + seed);\n                            DeepLearning p = new DeepLearning();\n                            p.best_model_key = best_model_key;\n                            p.epochs = 1.0 + rng.nextDouble();\n                            p.source = frame;\n                            p.hidden = new int[]{1+rng.nextInt(4), 1+rng.nextInt(6)};\n                            p.response = frame.vecs()[resp];\n                            if (i == 0 && resp == 2) p.classification = false;\n                            p.destination_key = dest;\n                            p.seed = seed;\n                            p.validation = valid;\n                            p.train_samples_per_iteration = 0;\n                            p.force_load_balance = load_balance;\n                            p.replicate_training_data = replicate;\n                            p.shuffle_training_data = shuffle;\n                            p.score_training_samples = scoretraining;\n                            p.score_validation_samples = scorevalidation;\n                            p.balance_classes = balance_classes;\n                            p.quiet_mode = true;\n                            p.score_validation_sampling = csm;\n//                      p.execImpl();\n\n                            // Train the model via checkpointing\n                            DeepLearningModel mymodel = p.initModel();\n                            p.trainModel(mymodel);\n                            p.trainModel(mymodel, p.epochs); //incremental training\n                            p.delete();\n                          }\n\n                          // score and check result (on full data)\n                          final DeepLearningModel mymodel = UKV.get(dest); //this actually *requires* frame to also still be in UKV (because of DataInfo...)\n                          // test HTML\n                          {\n                            StringBuilder sb = new StringBuilder();\n                            mymodel.generateHTML(\"test\", sb);\n                          }\n                          if (valid == null ) valid = frame;\n                          if (mymodel.isClassifier()) {\n                            Frame pred = mymodel.score(valid);\n                            StringBuilder sb = new StringBuilder();\n\n                            AUC auc = new AUC();\n                            double threshold = 0;\n                            double error = 0;\n                            // binary\n                            if (mymodel.nclasses()==2) {\n                              auc.actual = valid;\n                              auc.vactual = valid.vecs()[resp];\n                              auc.predict = pred;\n                              auc.vpredict = pred.vecs()[2];\n                              auc.threshold_criterion = AUC.ThresholdCriterion.maximum_F1;\n                              auc.invoke();\n                              auc.toASCII(sb);\n                              threshold = auc.threshold();\n                              error = auc.err();\n                              Log.info(sb);\n\n                              // check that auc.cm() is the right CM\n                              Assert.assertEquals(new ConfusionMatrix(auc.cm()).err(), error, 1e-15);\n\n                              // check that calcError() is consistent as well (for CM=null, AUC!=null)\n                              Assert.assertEquals(mymodel.calcError(valid, valid.lastVec(), pred, pred, \"training\", false, 0, null, auc, null), error, 1e-15);\n                            }\n\n                            // Compute CM\n                            double CMerrorOrig;\n                            {\n                              sb = new StringBuilder();\n                              water.api.ConfusionMatrix CM = new water.api.ConfusionMatrix();\n                              CM.actual = valid;\n                              CM.vactual = valid.vecs()[resp];\n                              CM.predict = pred;\n                              CM.vpredict = pred.vecs()[0];\n                              CM.invoke();\n                              sb.append(\"\\n\");\n                              CM.toASCII(sb);\n                              Log.info(sb);\n                              CMerrorOrig = new ConfusionMatrix(CM.cm).err();\n                            }\n\n                            // confirm that orig CM was made with threshold 0.5\n                            // put pred2 into UKV, and allow access\n                            Frame pred2 = new Frame(Key.make(\"pred2\"), pred.names(), pred.vecs());\n                            pred2.delete_and_lock(null);\n                            pred2.unlock(null);\n\n                            if (mymodel.nclasses()==2) {\n                              // make labels with 0.5 threshold for binary classifier\n                              Env ev = Exec2.exec(\"pred2[,1]=pred2[,3]>=\" + 0.5);\n                              pred2 = ev.popAry();\n                              ev.subRef(pred2, \"pred2\");\n                              ev.remove_and_unlock();\n\n                              water.api.ConfusionMatrix CM = new water.api.ConfusionMatrix();\n                              CM.actual = valid;\n                              CM.vactual = valid.vecs()[1];\n                              CM.predict = pred2;\n                              CM.vpredict = pred2.vecs()[0];\n                              CM.invoke();\n                              sb = new StringBuilder();\n                              sb.append(\"\\n\");\n                              CM.toASCII(sb);\n                              Log.info(sb);\n                              double threshErr = new ConfusionMatrix(CM.cm).err();\n                              Assert.assertEquals(threshErr, CMerrorOrig, 1e-15);\n\n                              // make labels with AUC-given threshold for best F1\n                              ev = Exec2.exec(\"pred2[,1]=pred2[,3]>=\" + threshold);\n                              pred2 = ev.popAry();\n                              ev.subRef(pred2, \"pred2\");\n                              ev.remove_and_unlock();\n\n                              CM = new water.api.ConfusionMatrix();\n                              CM.actual = valid;\n                              CM.vactual = valid.vecs()[1];\n                              CM.predict = pred2;\n                              CM.vpredict = pred2.vecs()[0];\n                              CM.invoke();\n                              sb = new StringBuilder();\n                              sb.append(\"\\n\");\n                              CM.toASCII(sb);\n                              Log.info(sb);\n                              double threshErr2 = new ConfusionMatrix(CM.cm).err();\n                              Assert.assertEquals(threshErr2, error, 1e-15);\n                            }\n                            pred2.delete();\n                            pred.delete();\n                          } //classifier\n                          if (best_model_key != null) UKV.remove(best_model_key);\n                          mymodel.delete();\n                          UKV.remove(dest);\n                          Log.info(\"Parameters combination \" + count + \": PASS\");\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      frame.delete();\n      vframe.delete();\n    }\n  }","commit_id":"6a77a929b7ad5fe0360a77c5632c56dae2985509","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\r\n\tpublic void publishKey(ContentName keyName,\r\n\t\t\tPublisherPublicKeyDigest keyToPublish) throws InvalidKeyException, ConfigurationException {\r\n\t\tPublicKey key = getPublicKey(keyToPublish);\r\n\t\tif (null == key) {\r\n\t\t\tthrow new InvalidKeyException(\"Cannot retrieive key \" + keyToPublish);\r\n\t\t}\r\n\t\tkeyRepository().publishKey(keyName, key, getDefaultKeyID(), getDefaultSigningKey());\r\n\t}","id":78133,"modified_method":"@Override\r\n\tpublic void publishKey(ContentName keyName,\r\n\t\t\tPublisherPublicKeyDigest keyToPublish) throws InvalidKeyException, ConfigurationException {\r\n\t\tPublicKey key = null;\r\n\t\tif (null == keyToPublish) {\r\n\t\t\tkey = getDefaultPublicKey();\r\n\t\t} else {\r\n\t\t\tkey = getPublicKey(keyToPublish);\r\n\t\t\tif (null == key) {\r\n\t\t\t\tthrow new InvalidKeyException(\"Cannot retrieive key \" + keyToPublish);\r\n\t\t\t}\r\n\t\t}\r\n\t\tkeyRepository().publishKey(keyName, key, getDefaultKeyID(), getDefaultSigningKey());\r\n\t}","commit_id":"2ae99dd01d06f59ec7579767075c7fed34e75b96","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Retrieve the public key from CCN given a key digest and a key locator\n\t * the function blocks and waits for the public key until a certain timeout\n\t * @param desiredKeyID the digest of the desired public key.\n\t * @param locator locator for the key\n\t * @param timeout timeout value\n\t * @throws IOException \n\t */\n\tpublic PublicKey getPublicKey(PublisherPublicKeyDigest desiredKeyID, KeyLocator locator, long timeout) throws IOException {\n\t\n\t\t// Look for it in our cache first.\n\t\tPublicKey publicKey = getPublicKey(desiredKeyID);\n\t\tif (null != publicKey) {\n\t\t\treturn publicKey;\n\t\t}\n\t\t\n\t\tContentObject keyObject = null;\n\t\tif (locator.type() != KeyLocator.KeyLocatorType.NAME) {\n\t\t\tLog.info(\"This is silly: asking the repository to retrieve for me a key I already have...\");\n\t\t\tif (locator.type() == KeyLocator.KeyLocatorType.KEY) {\n\t\t\t\tPublicKey key = locator.key();\n\t\t\t\tremember(key);\n\t\t\t\treturn key;\n\t\t\t} else if (locator.type() == KeyLocator.KeyLocatorType.CERTIFICATE) {\n\t\t\t\tCertificate certificate = locator.certificate();\n\t\t\t\tPublicKey key = certificate.getPublicKey();\n\t\t\t\tremember(certificate);\n\t\t\t\treturn key;\n\t\t\t}\n\t\t} else {\n\t\t\t// DKS TODO -- better key retrieval\n\t\t\t// take code from #BasicKeyManager.getKey, to validate more complex publisher constraints\n\t\t\tInterest keyInterest = new Interest(locator.name().name());\n\t\t\tif (null != locator.name().publisher()) {\n\t\t\t\tkeyInterest.publisherID(locator.name().publisher());\n\t\t\t}\t\t\t\n\t\t\t//  it would be really good to know how many additional name components to expect...\n\t\t\ttry {\n\t\t\t\tLog.info(\"Trying network retrieval of key: \" + keyInterest.name());\n\t\t\t\tkeyObject = _networkManager.get(keyInterest, timeout);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.warning(\"IOException attempting to retrieve key: \" + keyInterest.name() + \": \" + e.getMessage());\n\t\t\t\tLog.warningStackTrace(e);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\tLog.warning(\"Interrupted attempting to retrieve key: \" + keyInterest.name() + \": \" + e.getMessage());\n\t\t\t}\n\t\t\tif (null != keyObject) {\n\t\t\t\tif (keyObject.signedInfo().getType().equals(ContentType.KEY)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tLog.info(\"Retrieved public key using name: \" + locator.name().name());\n\t\t\t\t\t\tPublicKey theKey = CryptoUtil.getPublicKey(keyObject.content());\n\t\t\t\t\t\tremember(theKey, keyObject);\n\t\t\t\t\t\treturn theKey;\n\t\t\t\t\t} catch (CertificateEncodingException e) {\n\t\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t} catch (InvalidKeySpecException e) {\n\t\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLog.warning(\"Retrieved an object when looking for key \" + locator.name().name() + \" at \" + keyObject.name() + \", but type is \" + keyObject.signedInfo().getTypeName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":78134,"modified_method":"/**\n\t * Retrieve the public key from CCN given a key digest and a key locator\n\t * the function blocks and waits for the public key until a certain timeout\n\t * @param desiredKeyID the digest of the desired public key.\n\t * @param locator locator for the key\n\t * @param timeout timeout value\n\t * @throws IOException \n\t */\n\tpublic PublicKey getPublicKey(PublisherPublicKeyDigest desiredKeyID, KeyLocator locator, long timeout) throws IOException {\n\n\t\t// How many pieces of bad content do we wade through?\n\t\tfinal int ITERATION_LIMIT = 5;\n\t\t\n\t\t// Look for it in our cache first.\n\t\tPublicKey publicKey = getPublicKey(desiredKeyID);\n\t\tif (null != publicKey) {\n\t\t\treturn publicKey;\n\t\t}\n\n\t\tif (locator.type() != KeyLocator.KeyLocatorType.NAME) {\n\t\t\tLog.info(\"This is silly: asking the repository to retrieve for me a key I already have...\");\n\t\t\tif (locator.type() == KeyLocator.KeyLocatorType.KEY) {\n\t\t\t\tPublicKey key = locator.key();\n\t\t\t\tremember(key);\n\t\t\t\treturn key;\n\t\t\t} else if (locator.type() == KeyLocator.KeyLocatorType.CERTIFICATE) {\n\t\t\t\tCertificate certificate = locator.certificate();\n\t\t\t\tPublicKey key = certificate.getPublicKey();\n\t\t\t\tremember(certificate);\n\t\t\t\treturn key;\n\t\t\t}\n\t\t} else {\n\t\t\t// DKS TODO -- better key retrieval\n\t\t\t// take code from #BasicKeyManager.getKey, to validate more complex publisher constraints\n\t\t\tInterest keyInterest = new Interest(locator.name().name());\n\t\t\tif (null != locator.name().publisher()) {\n\t\t\t\tkeyInterest.publisherID(locator.name().publisher());\n\t\t\t}\t\n\n\t\t\tContentObject retrievedContent = null;\n\t\t\tint iterationCount = 0;\n\t\t\t\n\t\t\twhile ((null == publicKey) && (iterationCount < ITERATION_LIMIT)) {\n\t\t\t\t//  it would be really good to know how many additional name components to expect...\n\t\t\t\ttry {\n\t\t\t\t\tLog.info(\"Trying network retrieval of key: \" + keyInterest.name());\n\t\t\t\t\t// use more aggressive high-level get\n\t\t\t\t\tretrievedContent = _networkManager.get(keyInterest, timeout);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tLog.warning(\"IOException attempting to retrieve key: \" + keyInterest.name() + \": \" + e.getMessage());\n\t\t\t\t\tLog.warningStackTrace(e);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tLog.warning(\"Interrupted attempting to retrieve key: \" + keyInterest.name() + \": \" + e.getMessage());\n\t\t\t\t}\n\t\t\t\tif (null == retrievedContent) {\n\t\t\t\t\tLog.fine(\"No data returned when we attempted to retrieve key using interest {0}, timeout \" + timeout, keyInterest);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (retrievedContent.signedInfo().getType().equals(ContentType.KEY)) {\n\t\t\t\t\tPublicKey theKey = null;\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttheKey = CryptoUtil.getPublicKey(retrievedContent.content());\n\t\t\t\t\t} catch (CertificateEncodingException e) {\n\t\t\t\t\t\t// TODO go around again to avoid garbage data\n\t\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t} catch (InvalidKeySpecException e) {\n\t\t\t\t\t\t// TODO go around again to avoid garbage data\n\t\t\t\t\t\tLog.warning(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t\tthrow new IOException(\"Unexpected exception \" + e.getClass().getName() + \": \" + e.getMessage() + \", should not have to decode public key, should have it in cache.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (null != theKey) {\n\t\t\t\t\t\tif ((null != desiredKeyID) && (!new PublisherPublicKeyDigest(theKey).equals(desiredKeyID))) {\n\t\t\t\t\t\t\tLog.fine(\"Got key at expected name {0}, but it wasn't the right key, wanted {0}, got {1}\", \n\t\t\t\t\t\t\t\t\tdesiredKeyID, new PublisherPublicKeyDigest(theKey));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// either we don't have a preferred key ID, or we matched\n\t\t\t\t\t\t\tLog.info(\"Retrieved public key using name: \" + locator.name().name());\n\t\t\t\t\t\t\t// TODO make a key object instead of just retrieving\n\t\t\t\t\t\t\t// content, use it to decode\n\t\t\t\t\t\t\tremember(theKey, retrievedContent);\n\t\t\t\t\t\t\treturn theKey;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLog.severe(\"Decoded key at name {0} without error, but result was null!\", retrievedContent.name());\n\t\t\t\t\t\tthrow new IOException(\"Decoded key at name \" + retrievedContent.name() + \" without error, but result was null!\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLog.warning(\"Retrieved an object when looking for key \" + locator.name().name() + \" at \" + retrievedContent.name() + \", but type is \" + retrievedContent.signedInfo().getTypeName());\n\t\t\t\t}\n\t\t\t\t// TODO -- not sure this is exactly right, but a start...\n\t\t\t\tExclude currentExclude = keyInterest.exclude();\n\t\t\t\tcurrentExclude.add(new byte [][]{retrievedContent.digest()});\n\t\t\t\tkeyInterest.exclude(currentExclude);\n\t\t\t\titerationCount++;\n\t\t\t}\n\t\t}\n\t\tLog.info(\"Could not retrieve key {0} with locator {1}!\", desiredKeyID, locator);\n\t\treturn null;\n\t}","commit_id":"11575909f80023a6edb8fd4db7619e3a3a55fc44","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n     * Returns the public key for the specified alias, or null if the alias or private key is not found.\n     */    \n    // TODO Move this to a crypto utility class\n    private Key getPublicKey(KeyStore keystore, String alias, String password) throws Exception {\n        Key key = keystore.getKey(alias, password.toCharArray());\n        if (key instanceof PublicKey) {\n            return key;\n        } else {\n            java.security.cert.Certificate cert = keystore.getCertificate(alias);\n            // Get public key\n            PublicKey publicKey = cert.getPublicKey();\n            return publicKey;\n        }\n    }","id":78135,"modified_method":"/**\n     * Returns the public key for the specified alias, or null if the alias or private key is not found.\n     */    \n    // TODO Move this to a crypto utility class\n    private Key getPublicKey(KeyStore keystore, String alias, String password) throws Exception {\n        java.security.cert.Certificate cert = keystore.getCertificate(alias);\n        if (cert != null) {\n            // Get public key\n            return cert.getPublicKey();\n        }\n        return keystore.getKey(alias, password.toCharArray());\n    }","commit_id":"6bd3ad92090ab24dfb7856456c742b0823539f80","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {\n        Document encodedDocument = exchange.getContext().getTypeConverter().convertTo(Document.class, exchange, stream);        \n        \n        if (null != keyCipherAlgorithm \n            && (keyCipherAlgorithm.equals(XMLCipher.RSA_v1dot5) || keyCipherAlgorithm.equals(XMLCipher.RSA_OAEP)\n                || keyCipherAlgorithm.equals(XMLCipher.RSA_OAEP_11))) {\n            return decodeWithAsymmetricKey(exchange, encodedDocument);\n        } else {\n            return decodeWithSymmetricKey(exchange, encodedDocument);\n        }\n    }","id":78136,"modified_method":"@Override\n    public Object unmarshal(Exchange exchange, InputStream stream) throws Exception {\n        Document encodedDocument = exchange.getContext().getTypeConverter().convertTo(Document.class, exchange, stream);        \n        \n        if (null != keyCipherAlgorithm \n            && (keyCipherAlgorithm.equals(XMLCipher.RSA_v1dot5) || keyCipherAlgorithm.equals(XMLCipher.RSA_OAEP)\n                || keyCipherAlgorithm.equals(XMLCipher.RSA_OAEP_11))) {\n            return decodeWithAsymmetricKey(exchange, encodedDocument);\n        } else {\n            LOG.debug(\"No (known) asymmetric keyCipherAlgorithm specified. Attempting to \"\n                      + \"decrypt using a symmetric key\"); \n            return decodeWithSymmetricKey(exchange, encodedDocument);\n        }\n    }","commit_id":"6bd3ad92090ab24dfb7856456c742b0823539f80","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Configure the public key for the asymmetric key wrap algorithm, create the key cipher, and delegate\n     * to common encryption method.\n     * \n     * The method first checks the exchange for a declared key alias, and will fall back to the\n     * statically-defined instance variable if no value is found in the exchange. This allows different\n     * aliases / keys to be used for multiple-recipient messaging integration patterns such as CBR\n     * or recipient list.\n     */\n    private void encryptAsymmetric(Exchange exchange, Document document, OutputStream stream) throws Exception {       \n        String exchangeRecipientAlias = getRecipientKeyAlias(exchange);\n        \n        if (null == exchangeRecipientAlias) {\n            throw new IllegalStateException(\"The  recipient's key alias must be defined for asymmetric key encryption.\");\n        }\n        \n        if (trustStore == null && null != this.keyOrTrustStoreParameters) {\n            trustStore = keyOrTrustStoreParameters.createKeyStore();\n            trustStorePassword = keyOrTrustStoreParameters.getPassword();\n        }\n\n        if (null == trustStore) {\n            throw new IllegalStateException(\"A trust store must be defined for asymmetric key encryption.\");\n        }\n        \n        Key keyEncryptionKey = getPublicKey(this.trustStore, exchangeRecipientAlias, this.trustStorePassword);\n        \n        if (null == keyEncryptionKey) {\n            throw new IllegalStateException(\"No key for the alias [ \" + exchangeRecipientAlias \n                + \" ] exists in \" + \"the configured trust store.\");\n        }\n        \n        Key dataEncryptionKey = generateDataEncryptionKey();\n        \n        XMLCipher keyCipher;\n        if (null != this.getKeyCipherAlgorithm()) {\n            keyCipher = XMLCipher.getInstance(this.getKeyCipherAlgorithm(), null, digestAlgorithm);\n        } else {\n            keyCipher = XMLCipher.getInstance(XMLCipher.RSA_OAEP, null, digestAlgorithm);\n        }\n        keyCipher.init(XMLCipher.WRAP_MODE, keyEncryptionKey);\n        encrypt(exchange, document, stream, dataEncryptionKey, keyCipher);\n    }","id":78137,"modified_method":"/**\n     * Configure the public key for the asymmetric key wrap algorithm, create the key cipher, and delegate\n     * to common encryption method.\n     * \n     * The method first checks the exchange for a declared key alias, and will fall back to the\n     * statically-defined instance variable if no value is found in the exchange. This allows different\n     * aliases / keys to be used for multiple-recipient messaging integration patterns such as CBR\n     * or recipient list.\n     */\n    private void encryptAsymmetric(Exchange exchange, Document document, OutputStream stream) throws Exception {       \n        String exchangeRecipientAlias = getRecipientKeyAlias(exchange);\n        \n        if (null == exchangeRecipientAlias) {\n            throw new IllegalStateException(\"The  recipient's key alias must be defined for asymmetric key encryption.\");\n        }\n        \n        if (trustStore == null && null != this.keyOrTrustStoreParameters) {\n            trustStore = keyOrTrustStoreParameters.createKeyStore();\n            trustStorePassword = keyOrTrustStoreParameters.getPassword();\n        }\n\n        if (null == trustStore) {\n            throw new IllegalStateException(\"A trust store must be defined for asymmetric key encryption.\");\n        }\n        \n        String password = \n            this.keyPassword != null ? this.keyPassword : this.trustStorePassword;\n        Key keyEncryptionKey = getPublicKey(this.trustStore, exchangeRecipientAlias, password);\n        \n        if (null == keyEncryptionKey) {\n            throw new IllegalStateException(\"No key for the alias [ \" + exchangeRecipientAlias \n                + \" ] exists in \" + \"the configured trust store.\");\n        }\n        \n        Key dataEncryptionKey = generateDataEncryptionKey();\n        \n        XMLCipher keyCipher;\n        if (null != this.getKeyCipherAlgorithm()) {\n            keyCipher = XMLCipher.getInstance(this.getKeyCipherAlgorithm(), null, digestAlgorithm);\n        } else {\n            keyCipher = XMLCipher.getInstance(XMLCipher.RSA_OAEP, null, digestAlgorithm);\n        }\n        keyCipher.init(XMLCipher.WRAP_MODE, keyEncryptionKey);\n        encrypt(exchange, document, stream, dataEncryptionKey, keyCipher);\n    }","commit_id":"6bd3ad92090ab24dfb7856456c742b0823539f80","url":"https://github.com/apache/camel"},{"original_method":"protected void validateToken(Message message, SamlAssertionWrapper assertion) {\n        try {\n            RequestData data = new RequestData();\n            if (assertion.isSigned()) {\n                WSSConfig cfg = WSSConfig.getNewInstance(); \n                data.setWssConfig(cfg);\n                data.setCallbackHandler(SecurityUtils.getCallbackHandler(message, this.getClass()));\n                try {\n                    data.setSigVerCrypto(new CryptoLoader().getCrypto(message,\n                                                SecurityConstants.SIGNATURE_CRYPTO,\n                                                SecurityConstants.SIGNATURE_PROPERTIES));\n                } catch (IOException ex) {\n                    throwFault(\"Crypto can not be loaded\", ex);\n                }\n                data.setEnableRevocation(MessageUtils.isTrue(\n                    message.getContextualProperty(WSHandlerConstants.ENABLE_REVOCATION)));\n                Signature sig = assertion.getSignature();\n                WSDocInfo docInfo = new WSDocInfo(sig.getDOM().getOwnerDocument());\n                KeyInfo keyInfo = sig.getKeyInfo();\n                \n                SAMLKeyInfo samlKeyInfo = \n                    SAMLUtil.getCredentialFromKeyInfo(\n                        keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(data, docInfo), \n                        data.getSigVerCrypto()\n                    );\n                \n                assertion.verifySignature(samlKeyInfo);\n                assertion.parseHOKSubject(\n                    new WSSSAMLKeyInfoProcessor(data, null), data.getSigVerCrypto(), \n                    data.getCallbackHandler()\n                );\n            } else if (getTLSCertificates(message) == null) {\n                throwFault(\"Assertion must be signed\", null);\n            }\n            if (samlValidator != null) {\n                Credential credential = new Credential();\n                credential.setSamlAssertion(assertion);\n                samlValidator.validate(credential, data);\n            }\n                \n            \n            checkSubjectConfirmationData(message, assertion);\n            setSecurityContext(message, assertion);\n            \n        } catch (Exception ex) {\n            throwFault(\"Assertion can not be validated\", ex);\n        }\n    }","id":78138,"modified_method":"protected void validateToken(Message message, SamlAssertionWrapper assertion) {\n        try {\n            RequestData data = new RequestData();\n            if (assertion.isSigned()) {\n                WSSConfig cfg = WSSConfig.getNewInstance(); \n                data.setWssConfig(cfg);\n                data.setCallbackHandler(SecurityUtils.getCallbackHandler(message, this.getClass()));\n                try {\n                    data.setSigVerCrypto(new CryptoLoader().getCrypto(message,\n                                                SecurityConstants.SIGNATURE_CRYPTO,\n                                                SecurityConstants.SIGNATURE_PROPERTIES));\n                } catch (IOException ex) {\n                    throwFault(\"Crypto can not be loaded\", ex);\n                }\n                data.setEnableRevocation(MessageUtils.isTrue(\n                    message.getContextualProperty(WSHandlerConstants.ENABLE_REVOCATION)));\n                Signature sig = assertion.getSignature();\n                WSDocInfo docInfo = new WSDocInfo(sig.getDOM().getOwnerDocument());\n                \n                SAMLKeyInfo samlKeyInfo = null;\n                \n                KeyInfo keyInfo = sig.getKeyInfo();\n                if (keyInfo != null) {\n                    samlKeyInfo = SAMLUtil.getCredentialFromKeyInfo(\n                        keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(data, docInfo), \n                        data.getSigVerCrypto()\n                    );\n                } else if (!keyInfoMustBeAvailable) {\n                    samlKeyInfo = createKeyInfoFromDefaultAlias(data.getSigVerCrypto());\n                }\n                \n                assertion.verifySignature(samlKeyInfo);\n                assertion.parseHOKSubject(\n                    new WSSSAMLKeyInfoProcessor(data, null), data.getSigVerCrypto(), \n                    data.getCallbackHandler()\n                );\n            } else if (getTLSCertificates(message) == null) {\n                throwFault(\"Assertion must be signed\", null);\n            }\n            if (samlValidator != null) {\n                Credential credential = new Credential();\n                credential.setSamlAssertion(assertion);\n                samlValidator.validate(credential, data);\n            }\n                \n            \n            checkSubjectConfirmationData(message, assertion);\n            setSecurityContext(message, assertion);\n            \n        } catch (Exception ex) {\n            throwFault(\"Assertion can not be validated\", ex);\n        }\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"protected void checkSignature(Message message) {\n        \n        Document doc = getDocument(message);\n        if (doc == null) {\n            return;\n        }\n\n        Element root = doc.getDocumentElement();\n        Element signatureElement = getSignatureElement(root);\n        if (signatureElement == null) {\n            throwFault(\"XML Signature is not available\", null);\n        }\n        \n        String cryptoKey = null; \n        String propKey = null;\n        if (SecurityUtils.isSignedAndEncryptedTwoWay(message)) {\n            cryptoKey = SecurityConstants.ENCRYPT_CRYPTO;\n            propKey = SecurityConstants.ENCRYPT_PROPERTIES;\n        } else {\n            cryptoKey = SecurityConstants.SIGNATURE_CRYPTO;\n            propKey = SecurityConstants.SIGNATURE_PROPERTIES;    \n        }\n        \n        Crypto crypto = null;\n        try {\n            CryptoLoader loader = new CryptoLoader();\n            crypto = loader.getCrypto(message, cryptoKey, propKey);\n        } catch (Exception ex) {\n            throwFault(\"Crypto can not be loaded\", ex);\n        }\n        boolean valid = false;\n        Reference ref = null;\n        try {\n            XMLSignature signature = new XMLSignature(signatureElement, \"\", true);\n            \n            if (sigProps != null) {\n                SignedInfo sInfo = signature.getSignedInfo();\n                if (sigProps.getSignatureAlgo() != null\n                    && !sigProps.getSignatureAlgo().equals(sInfo.getSignatureMethodURI())) {\n                    throwFault(\"Signature Algorithm is not supported\", null);\n                }\n                if (sigProps.getSignatureC14Method() != null\n                    && !sigProps.getSignatureC14Method().equals(sInfo.getCanonicalizationMethodURI())) {\n                    throwFault(\"Signature Algorithm is not supported\", null);\n                }\n            }\n            \n            ref = getReference(signature);\n            Element signedElement = validateReference(root, ref);\n            if (signedElement.hasAttributeNS(null, \"ID\")) {\n                signedElement.setIdAttributeNS(null, \"ID\", true);\n            }\n            \n            // See also WSS4J SAMLUtil.getCredentialFromKeyInfo \n            KeyInfo keyInfo = signature.getKeyInfo();\n            \n            X509Certificate cert = keyInfo.getX509Certificate();\n            if (cert != null) {\n                valid = signature.checkSignatureValue(cert);\n            } else {\n                PublicKey pk = keyInfo.getPublicKey();\n                if (pk != null) {\n                    valid = signature.checkSignatureValue(pk);\n                }\n            }\n            \n            // validate trust \n            new TrustValidator().validateTrust(crypto, cert, keyInfo.getPublicKey());\n            \n            if (valid && persistSignature) {\n                message.setContent(XMLSignature.class, signature);\n                message.setContent(Element.class, signedElement);\n            }\n        } catch (Exception ex) {\n            throwFault(\"Signature validation failed\", ex);\n        }\n        if (!valid) {\n            throwFault(\"Signature validation failed\", null);\n        }\n        if (removeSignature) {\n            if (!isEnveloping(root)) {\n                Element signedEl = getSignedElement(root, ref);\n                signedEl.removeAttribute(\"ID\");\n                root.removeChild(signatureElement);\n            } else {\n                Element actualBody = getActualBody(root);\n                Document newDoc = DOMUtils.createDocument();\n                newDoc.adoptNode(actualBody);\n                root = actualBody;\n            }\n        }\n        message.setContent(XMLStreamReader.class, \n                           new W3CDOMStreamReader(root));\n        message.setContent(InputStream.class, null);\n        \n    }","id":78139,"modified_method":"protected void checkSignature(Message message) {\n        \n        Document doc = getDocument(message);\n        if (doc == null) {\n            return;\n        }\n\n        Element root = doc.getDocumentElement();\n        Element signatureElement = getSignatureElement(root);\n        if (signatureElement == null) {\n            throwFault(\"XML Signature is not available\", null);\n        }\n        \n        String cryptoKey = null; \n        String propKey = null;\n        if (SecurityUtils.isSignedAndEncryptedTwoWay(message)) {\n            cryptoKey = SecurityConstants.ENCRYPT_CRYPTO;\n            propKey = SecurityConstants.ENCRYPT_PROPERTIES;\n        } else {\n            cryptoKey = SecurityConstants.SIGNATURE_CRYPTO;\n            propKey = SecurityConstants.SIGNATURE_PROPERTIES;    \n        }\n        \n        Crypto crypto = null;\n        try {\n            CryptoLoader loader = new CryptoLoader();\n            crypto = loader.getCrypto(message, cryptoKey, propKey);\n        } catch (Exception ex) {\n            throwFault(\"Crypto can not be loaded\", ex);\n        }\n        boolean valid = false;\n        Reference ref = null;\n        try {\n            XMLSignature signature = new XMLSignature(signatureElement, \"\", true);\n            \n            if (sigProps != null) {\n                SignedInfo sInfo = signature.getSignedInfo();\n                if (sigProps.getSignatureAlgo() != null\n                    && !sigProps.getSignatureAlgo().equals(sInfo.getSignatureMethodURI())) {\n                    throwFault(\"Signature Algorithm is not supported\", null);\n                }\n                if (sigProps.getSignatureC14Method() != null\n                    && !sigProps.getSignatureC14Method().equals(sInfo.getCanonicalizationMethodURI())) {\n                    throwFault(\"Signature Algorithm is not supported\", null);\n                }\n            }\n            \n            ref = getReference(signature);\n            Element signedElement = validateReference(root, ref);\n            if (signedElement.hasAttributeNS(null, \"ID\")) {\n                signedElement.setIdAttributeNS(null, \"ID\", true);\n            }\n            \n            X509Certificate cert = null;\n            PublicKey publicKey = null;\n            \n            \n            // See also WSS4J SAMLUtil.getCredentialFromKeyInfo \n            KeyInfo keyInfo = signature.getKeyInfo();\n            \n            if (keyInfo != null) {\n                cert = keyInfo.getX509Certificate();\n                if (cert != null) {\n                    valid = signature.checkSignatureValue(cert);\n                } else {\n                    publicKey = keyInfo.getPublicKey();\n                    if (publicKey != null) {\n                        valid = signature.checkSignatureValue(publicKey);\n                    }\n                } \n            } else if (!keyInfoMustBeAvailable) {\n                String user = getUserName(crypto, message);\n                cert = SecurityUtils.getCertificates(crypto, user)[0];\n                publicKey = cert.getPublicKey();\n                valid = signature.checkSignatureValue(cert);\n            }\n            \n            // validate trust \n            new TrustValidator().validateTrust(crypto, cert, publicKey);\n            if (valid && persistSignature) {\n                message.setContent(XMLSignature.class, signature);\n                message.setContent(Element.class, signedElement);\n            }\n        } catch (Exception ex) {\n            throwFault(\"Signature validation failed\", ex);\n        }\n        if (!valid) {\n            throwFault(\"Signature validation failed\", null);\n        }\n        if (removeSignature) {\n            if (!isEnveloping(root)) {\n                Element signedEl = getSignedElement(root, ref);\n                signedEl.removeAttribute(\"ID\");\n                root.removeChild(signatureElement);\n            } else {\n                Element actualBody = getActualBody(root);\n                Document newDoc = DOMUtils.createDocument();\n                newDoc.adoptNode(actualBody);\n                root = actualBody;\n            }\n        }\n        message.setContent(XMLStreamReader.class, \n                           new W3CDOMStreamReader(root));\n        message.setContent(InputStream.class, null);\n        \n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPostBookWithEnvelopingSigFromResponse() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlsig/bookstore/books\";\n        doTestSignature(address, true, true);\n    }","id":78140,"modified_method":"@Test\n    public void testPostBookWithEnvelopingSigFromResponse() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlsig/bookstore/books\";\n        doTestSignature(address, true, true, true);\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPostBookWithEnvelopedSig() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlsig/bookstore/books\";\n        doTestSignature(address, false, false);\n    }","id":78141,"modified_method":"@Test\n    public void testPostBookWithEnvelopedSig() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlsig/bookstore/books\";\n        doTestSignature(address, false, false, true);\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testPostBookWithEnvelopingSig() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlsig/bookstore/books\";\n        doTestSignature(address, true, false);\n    }","id":78142,"modified_method":"@Test\n    public void testPostBookWithEnvelopingSig() throws Exception {\n        String address = \"https://localhost:\" + PORT + \"/xmlsig/bookstore/books\";\n        doTestSignature(address, true, false, true);\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"private void doTestSignature(String address, boolean enveloping, boolean fromResponse) {\n        JAXRSClientFactoryBean bean = new JAXRSClientFactoryBean();\n        bean.setAddress(address);\n        \n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = JAXRSXmlSecTest.class.getResource(\"client.xml\");\n        Bus springBus = bf.createBus(busFile.toString());\n        bean.setBus(springBus);\n\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.signature.username\", \"alice\");\n        properties.put(\"ws-security.signature.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/alice.properties\");\n        bean.setProperties(properties);\n        XmlSigOutInterceptor sigInterceptor = new XmlSigOutInterceptor();\n        if (enveloping) {\n            sigInterceptor.setStyle(XmlSigOutInterceptor.ENVELOPING_SIG);\n        }\n        bean.getOutInterceptors().add(sigInterceptor);\n        bean.getInInterceptors().add(new XmlSigInInterceptor());\n        \n        WebClient wc = bean.createWebClient();\n        try {\n            Book book;\n            if (!fromResponse) {\n                book = wc.post(new Book(\"CXF\", 126L), Book.class);\n            } else {\n                book = wc.post(new Book(\"CXF\", 126L)).readEntity(Book.class);\n            }\n            assertEquals(126L, book.getId());\n        } catch (WebApplicationException ex) {\n            fail(ex.getMessage());\n        } catch (ProcessingException ex) {\n            if (ex.getCause() != null && ex.getCause().getMessage() != null) {\n                fail(ex.getCause().getMessage());\n            } else {\n                fail(ex.getMessage());\n            }\n        }\n    }","id":78143,"modified_method":"private void doTestSignature(String address, \n                                 boolean enveloping, \n                                 boolean fromResponse,\n                                 boolean useKeyInfo) {\n        JAXRSClientFactoryBean bean = new JAXRSClientFactoryBean();\n        bean.setAddress(address);\n        \n        SpringBusFactory bf = new SpringBusFactory();\n        URL busFile = JAXRSXmlSecTest.class.getResource(\"client.xml\");\n        Bus springBus = bf.createBus(busFile.toString());\n        bean.setBus(springBus);\n\n        Map<String, Object> properties = new HashMap<String, Object>();\n        properties.put(\"ws-security.callback-handler\", \n                       \"org.apache.cxf.systest.jaxrs.security.saml.KeystorePasswordCallback\");\n        properties.put(\"ws-security.signature.username\", \"alice\");\n        properties.put(\"ws-security.signature.properties\", \n                       \"org/apache/cxf/systest/jaxrs/security/alice.properties\");\n        bean.setProperties(properties);\n        XmlSigOutInterceptor sigOutInterceptor = new XmlSigOutInterceptor();\n        if (enveloping) {\n            sigOutInterceptor.setStyle(XmlSigOutInterceptor.ENVELOPING_SIG);\n        }\n        sigOutInterceptor.setKeyInfoMustBeAvailable(useKeyInfo);\n        bean.getOutInterceptors().add(sigOutInterceptor);\n        XmlSigInInterceptor sigInInterceptor = new XmlSigInInterceptor();\n        sigInInterceptor.setKeyInfoMustBeAvailable(useKeyInfo);\n        bean.getInInterceptors().add(sigInInterceptor);\n        \n        WebClient wc = bean.createWebClient();\n        WebClient.getConfig(wc).getHttpConduit().getClient().setReceiveTimeout(10000000L);\n        try {\n            Book book;\n            if (!fromResponse) {\n                book = wc.post(new Book(\"CXF\", 126L), Book.class);\n            } else {\n                book = wc.post(new Book(\"CXF\", 126L)).readEntity(Book.class);\n            }\n            assertEquals(126L, book.getId());\n        } catch (WebApplicationException ex) {\n            fail(ex.getMessage());\n        } catch (ProcessingException ex) {\n            if (ex.getCause() != null && ex.getCause().getMessage() != null) {\n                fail(ex.getCause().getMessage());\n            } else {\n                fail(ex.getMessage());\n            }\n        }\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Validate the received SAML Response as per the protocol\n     */\n    protected void validateSamlResponseProtocol(\n        org.opensaml.saml2.core.Response samlResponse\n    ) {\n        try {\n            SAMLProtocolResponseValidator protocolValidator = new SAMLProtocolResponseValidator();\n            protocolValidator.validateSamlResponse(samlResponse, getSignatureCrypto(), getCallbackHandler());\n        } catch (WSSecurityException ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            reportError(\"INVALID_SAML_RESPONSE\");\n            throw new BadRequestException();\n        }\n    }","id":78144,"modified_method":"/**\n     * Validate the received SAML Response as per the protocol\n     */\n    protected void validateSamlResponseProtocol(\n        org.opensaml.saml2.core.Response samlResponse\n    ) {\n        try {\n            SAMLProtocolResponseValidator protocolValidator = new SAMLProtocolResponseValidator();\n            protocolValidator.setKeyInfoMustBeAvailable(keyInfoMustBeAvailable);\n            protocolValidator.validateSamlResponse(samlResponse, getSignatureCrypto(), getCallbackHandler());\n        } catch (WSSecurityException ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            reportError(\"INVALID_SAML_RESPONSE\");\n            throw new BadRequestException();\n        }\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Validate an internal Assertion\n     */\n    private void validateAssertion(\n        SamlAssertionWrapper assertion,\n        Crypto sigCrypto,\n        CallbackHandler callbackHandler,\n        Document doc\n    ) throws WSSecurityException {\n        Credential credential = new Credential();\n        credential.setSamlAssertion(assertion);\n        \n        RequestData requestData = new RequestData();\n        requestData.setSigVerCrypto(sigCrypto);\n        WSSConfig wssConfig = WSSConfig.getNewInstance();\n        requestData.setWssConfig(wssConfig);\n        requestData.setCallbackHandler(callbackHandler);\n        \n        if (assertion.isSigned()) {\n            if (assertion.getSaml1() != null) {\n                assertion.getSaml1().getDOM().setIdAttributeNS(null, \"AssertionID\", true);\n            } else {\n                assertion.getSaml2().getDOM().setIdAttributeNS(null, \"ID\", true);\n            }\n            \n            // Verify the signature\n            try {\n                Signature sig = assertion.getSignature();\n                WSDocInfo docInfo = new WSDocInfo(sig.getDOM().getOwnerDocument());\n                KeyInfo keyInfo = sig.getKeyInfo();\n                \n                SAMLKeyInfo samlKeyInfo = \n                    SAMLUtil.getCredentialFromKeyInfo(\n                        keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(requestData, docInfo), sigCrypto\n                    );\n                assertion.verifySignature(samlKeyInfo);\n                \n                assertion.parseHOKSubject(\n                    new WSSSAMLKeyInfoProcessor(requestData, new WSDocInfo(doc)),\n                    requestData.getSigVerCrypto(), \n                    requestData.getCallbackHandler()\n                );\n            } catch (WSSecurityException e) {\n                LOG.log(Level.FINE, \"Assertion failed signature validation\", e);\n                throw e;\n            }\n        }\n        \n        // Validate the Assertion & verify trust in the signature\n        try {\n            assertionValidator.validate(credential, requestData);\n        } catch (WSSecurityException ex) {\n            LOG.log(Level.FINE, \"Assertion validation failed: \" + ex.getMessage(), ex);\n            throw ex;\n        }\n    }","id":78145,"modified_method":"/**\n     * Validate an internal Assertion\n     */\n    private void validateAssertion(\n        SamlAssertionWrapper assertion,\n        Crypto sigCrypto,\n        CallbackHandler callbackHandler,\n        Document doc\n    ) throws WSSecurityException {\n        Credential credential = new Credential();\n        credential.setSamlAssertion(assertion);\n        \n        RequestData requestData = new RequestData();\n        requestData.setSigVerCrypto(sigCrypto);\n        WSSConfig wssConfig = WSSConfig.getNewInstance();\n        requestData.setWssConfig(wssConfig);\n        requestData.setCallbackHandler(callbackHandler);\n        \n        if (assertion.isSigned()) {\n            if (assertion.getSaml1() != null) {\n                assertion.getSaml1().getDOM().setIdAttributeNS(null, \"AssertionID\", true);\n            } else {\n                assertion.getSaml2().getDOM().setIdAttributeNS(null, \"ID\", true);\n            }\n            \n            // Verify the signature\n            try {\n                Signature sig = assertion.getSignature();\n                WSDocInfo docInfo = new WSDocInfo(sig.getDOM().getOwnerDocument());\n                \n                SAMLKeyInfo samlKeyInfo = null;\n                \n                KeyInfo keyInfo = sig.getKeyInfo();\n                if (keyInfo != null) {\n                    samlKeyInfo = SAMLUtil.getCredentialFromKeyInfo(\n                        keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(requestData, docInfo), sigCrypto\n                    );\n                } else if (!keyInfoMustBeAvailable) {\n                    samlKeyInfo = createKeyInfoFromDefaultAlias(sigCrypto);\n                }\n\n                if (samlKeyInfo == null) {\n                    LOG.fine(\"No KeyInfo supplied in the SAMLResponse assertion signature\");\n                    throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n                }\n                \n                assertion.verifySignature(samlKeyInfo);\n                \n                assertion.parseHOKSubject(\n                    new WSSSAMLKeyInfoProcessor(requestData, new WSDocInfo(doc)),\n                    requestData.getSigVerCrypto(), \n                    requestData.getCallbackHandler()\n                );\n            } catch (WSSecurityException e) {\n                LOG.log(Level.FINE, \"Assertion failed signature validation\", e);\n                throw e;\n            }\n        }\n        \n        // Validate the Assertion & verify trust in the signature\n        try {\n            assertionValidator.validate(credential, requestData);\n        } catch (WSSecurityException ex) {\n            LOG.log(Level.FINE, \"Assertion validation failed: \" + ex.getMessage(), ex);\n            throw ex;\n        }\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Validate the response signature\n     */\n    private void validateResponseSignature(\n        Signature signature, \n        Document doc,\n        Crypto sigCrypto,\n        CallbackHandler callbackHandler\n    ) throws WSSecurityException {\n        RequestData requestData = new RequestData();\n        requestData.setSigVerCrypto(sigCrypto);\n        WSSConfig wssConfig = WSSConfig.getNewInstance();\n        requestData.setWssConfig(wssConfig);\n        requestData.setCallbackHandler(callbackHandler);\n        \n        KeyInfo keyInfo = signature.getKeyInfo();\n        SAMLKeyInfo samlKeyInfo = null;\n        try {\n            samlKeyInfo = \n                SAMLUtil.getCredentialFromKeyInfo(\n                    keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(requestData, new WSDocInfo(doc)), sigCrypto\n                );\n        } catch (WSSecurityException ex) {\n            LOG.log(Level.FINE, \"Error in getting KeyInfo from SAML Response: \" + ex.getMessage(), ex);\n            throw ex;\n        }\n        if (samlKeyInfo == null) {\n            LOG.fine(\"No KeyInfo supplied in the SAMLResponse signature\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Validate Signature against profiles\n        validateSignatureAgainstProfiles(signature, samlKeyInfo);\n\n        // Now verify trust on the signature\n        Credential trustCredential = new Credential();\n        trustCredential.setPublicKey(samlKeyInfo.getPublicKey());\n        trustCredential.setCertificates(samlKeyInfo.getCerts());\n\n        try {\n            signatureValidator.validate(trustCredential, requestData);\n        } catch (WSSecurityException e) {\n            LOG.log(Level.FINE, \"Error in validating signature on SAML Response: \" + e.getMessage(), e);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n    }","id":78146,"modified_method":"/**\n     * Validate the response signature\n     */\n    private void validateResponseSignature(\n        Signature signature, \n        Document doc,\n        Crypto sigCrypto,\n        CallbackHandler callbackHandler\n    ) throws WSSecurityException {\n        RequestData requestData = new RequestData();\n        requestData.setSigVerCrypto(sigCrypto);\n        WSSConfig wssConfig = WSSConfig.getNewInstance();\n        requestData.setWssConfig(wssConfig);\n        requestData.setCallbackHandler(callbackHandler);\n        \n        SAMLKeyInfo samlKeyInfo = null;\n        \n        KeyInfo keyInfo = signature.getKeyInfo();\n        if (keyInfo != null) {\n            try {\n                samlKeyInfo = \n                    SAMLUtil.getCredentialFromKeyInfo(\n                        keyInfo.getDOM(), new WSSSAMLKeyInfoProcessor(requestData, new WSDocInfo(doc)), sigCrypto\n                    );\n            } catch (WSSecurityException ex) {\n                LOG.log(Level.FINE, \"Error in getting KeyInfo from SAML Response: \" + ex.getMessage(), ex);\n                throw ex;\n            }\n        } else if (!keyInfoMustBeAvailable) {\n            samlKeyInfo = createKeyInfoFromDefaultAlias(sigCrypto);\n        }\n        if (samlKeyInfo == null) {\n            LOG.fine(\"No KeyInfo supplied in the SAMLResponse signature\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        // Validate Signature against profiles\n        validateSignatureAgainstProfiles(signature, samlKeyInfo);\n\n        // Now verify trust on the signature\n        Credential trustCredential = new Credential();\n        trustCredential.setPublicKey(samlKeyInfo.getPublicKey());\n        trustCredential.setCertificates(samlKeyInfo.getCerts());\n\n        try {\n            signatureValidator.validate(trustCredential, requestData);\n        } catch (WSSecurityException e) {\n            LOG.log(Level.FINE, \"Error in validating signature on SAML Response: \" + e.getMessage(), e);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"@org.junit.Test\n    public void testSignedResponse() throws Exception {\n        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n        docBuilderFactory.setNamespaceAware(true);\n        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n        Document doc = docBuilder.newDocument();\n        \n        Status status = \n            SAML2PResponseComponentBuilder.createStatus(\n                SAMLProtocolResponseValidator.SAML2_STATUSCODE_SUCCESS, null\n            );\n        Response response = \n            SAML2PResponseComponentBuilder.createSAMLResponse(\n                \"http://cxf.apache.org/saml\", \"http://cxf.apache.org/issuer\", status\n            );\n        \n        // Create an AuthenticationAssertion\n        SAML2CallbackHandler callbackHandler = new SAML2CallbackHandler();\n        callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);\n        callbackHandler.setIssuer(\"http://cxf.apache.org/issuer\");\n        callbackHandler.setConfirmationMethod(SAML2Constants.CONF_BEARER);\n        \n        SAMLCallback samlCallback = new SAMLCallback();\n        SAMLUtil.doSAMLCallback(callbackHandler, samlCallback);\n        SamlAssertionWrapper assertion = new SamlAssertionWrapper(samlCallback);\n        \n        Crypto issuerCrypto = new Merlin();\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        ClassLoader loader = Loader.getClassLoader(SAMLResponseValidatorTest.class);\n        InputStream input = Merlin.loadInputStream(loader, \"alice.jks\");\n        keyStore.load(input, \"password\".toCharArray());\n        ((Merlin)issuerCrypto).setKeyStore(keyStore);\n        \n        response.getAssertions().add(assertion.getSaml2());\n        signResponse(response, \"alice\", \"password\", issuerCrypto);\n        \n        Element policyElement = OpenSAMLUtil.toDom(response, doc);\n        doc.appendChild(policyElement);\n        assertNotNull(policyElement);\n        \n        Response marshalledResponse = (Response)OpenSAMLUtil.fromDom(policyElement);\n        \n        // Validate the Response\n        SAMLProtocolResponseValidator validator = new SAMLProtocolResponseValidator();\n        try {\n            validator.validateSamlResponse(marshalledResponse, null, new KeystorePasswordCallback());\n            fail(\"Expected failure on no Signature Crypto\");\n        } catch (WSSecurityException ex) {\n            // expected\n        }\n        \n        // Validate the Response\n        validator.validateSamlResponse(\n            marshalledResponse, issuerCrypto, new KeystorePasswordCallback()\n        );\n    }","id":78147,"modified_method":"@org.junit.Test\n    public void testSignedResponse() throws Exception {\n        DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n        docBuilderFactory.setNamespaceAware(true);\n        DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n        Document doc = docBuilder.newDocument();\n        \n        Status status = \n            SAML2PResponseComponentBuilder.createStatus(\n                SAMLProtocolResponseValidator.SAML2_STATUSCODE_SUCCESS, null\n            );\n        Response response = \n            SAML2PResponseComponentBuilder.createSAMLResponse(\n                \"http://cxf.apache.org/saml\", \"http://cxf.apache.org/issuer\", status\n            );\n        \n        // Create an AuthenticationAssertion\n        SAML2CallbackHandler callbackHandler = new SAML2CallbackHandler();\n        callbackHandler.setStatement(SAML2CallbackHandler.Statement.AUTHN);\n        callbackHandler.setIssuer(\"http://cxf.apache.org/issuer\");\n        callbackHandler.setConfirmationMethod(SAML2Constants.CONF_BEARER);\n        \n        SAMLCallback samlCallback = new SAMLCallback();\n        SAMLUtil.doSAMLCallback(callbackHandler, samlCallback);\n        SamlAssertionWrapper assertion = new SamlAssertionWrapper(samlCallback);\n        \n        Crypto issuerCrypto = new Merlin();\n        KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());\n        ClassLoader loader = Loader.getClassLoader(SAMLResponseValidatorTest.class);\n        InputStream input = Merlin.loadInputStream(loader, \"alice.jks\");\n        keyStore.load(input, \"password\".toCharArray());\n        ((Merlin)issuerCrypto).setKeyStore(keyStore);\n        \n        response.getAssertions().add(assertion.getSaml2());\n        signResponse(response, \"alice\", \"password\", issuerCrypto, true);\n        \n        Element policyElement = OpenSAMLUtil.toDom(response, doc);\n        doc.appendChild(policyElement);\n        assertNotNull(policyElement);\n        \n        Response marshalledResponse = (Response)OpenSAMLUtil.fromDom(policyElement);\n        \n        // Validate the Response\n        SAMLProtocolResponseValidator validator = new SAMLProtocolResponseValidator();\n        try {\n            validator.validateSamlResponse(marshalledResponse, null, new KeystorePasswordCallback());\n            fail(\"Expected failure on no Signature Crypto\");\n        } catch (WSSecurityException ex) {\n            // expected\n        }\n        \n        // Validate the Response\n        validator.validateSamlResponse(\n            marshalledResponse, issuerCrypto, new KeystorePasswordCallback()\n        );\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Sign a SAML Response\n     * @throws Exception \n     */\n    private void signResponse(\n        Response response,\n        String issuerKeyName,\n        String issuerKeyPassword,\n        Crypto issuerCrypto\n    ) throws Exception {\n        //\n        // Create the signature\n        //\n        Signature signature = OpenSAMLUtil.buildSignature();\n        signature.setCanonicalizationAlgorithm(SignatureConstants.ALGO_ID_C14N_EXCL_OMIT_COMMENTS);\n        \n        // prepare to sign the SAML token\n        CryptoType cryptoType = new CryptoType(CryptoType.TYPE.ALIAS);\n        cryptoType.setAlias(issuerKeyName);\n        X509Certificate[] issuerCerts = issuerCrypto.getX509Certificates(cryptoType);\n        if (issuerCerts == null) {\n            throw new Exception(\n                    \"No issuer certs were found to sign the SAML Assertion using issuer name: \"\n                            + issuerKeyName);\n        }\n\n        String sigAlgo = SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA1;\n        String pubKeyAlgo = issuerCerts[0].getPublicKey().getAlgorithm();\n\n        if (pubKeyAlgo.equalsIgnoreCase(\"DSA\")) {\n            sigAlgo = SignatureConstants.ALGO_ID_SIGNATURE_DSA;\n        }\n        \n        PrivateKey privateKey = issuerCrypto.getPrivateKey(issuerKeyName, issuerKeyPassword);\n\n        signature.setSignatureAlgorithm(sigAlgo);\n\n        BasicX509Credential signingCredential = new BasicX509Credential();\n        signingCredential.setEntityCertificate(issuerCerts[0]);\n        signingCredential.setPrivateKey(privateKey);\n\n        signature.setSigningCredential(signingCredential);\n\n        X509KeyInfoGeneratorFactory kiFactory = new X509KeyInfoGeneratorFactory();\n        kiFactory.setEmitEntityCertificate(true);\n        \n        try {\n            KeyInfo keyInfo = kiFactory.newInstance().generate(signingCredential);\n            signature.setKeyInfo(keyInfo);\n        } catch (org.opensaml.xml.security.SecurityException ex) {\n            throw new Exception(\n                    \"Error generating KeyInfo from signing credential\", ex);\n        }\n\n        // add the signature to the assertion\n        SignableSAMLObject signableObject = (SignableSAMLObject) response;\n        signableObject.setSignature(signature);\n        signableObject.releaseDOM();\n        signableObject.releaseChildrenDOM(true);\n    }","id":78148,"modified_method":"/**\n     * Sign a SAML Response\n     * @throws Exception \n     */\n    private void signResponse(\n        Response response,\n        String issuerKeyName,\n        String issuerKeyPassword,\n        Crypto issuerCrypto,\n        boolean useKeyInfo\n    ) throws Exception {\n        //\n        // Create the signature\n        //\n        Signature signature = OpenSAMLUtil.buildSignature();\n        signature.setCanonicalizationAlgorithm(SignatureConstants.ALGO_ID_C14N_EXCL_OMIT_COMMENTS);\n        \n        // prepare to sign the SAML token\n        CryptoType cryptoType = new CryptoType(CryptoType.TYPE.ALIAS);\n        cryptoType.setAlias(issuerKeyName);\n        X509Certificate[] issuerCerts = issuerCrypto.getX509Certificates(cryptoType);\n        if (issuerCerts == null) {\n            throw new Exception(\n                    \"No issuer certs were found to sign the SAML Assertion using issuer name: \"\n                            + issuerKeyName);\n        }\n\n        String sigAlgo = SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA1;\n        String pubKeyAlgo = issuerCerts[0].getPublicKey().getAlgorithm();\n\n        if (pubKeyAlgo.equalsIgnoreCase(\"DSA\")) {\n            sigAlgo = SignatureConstants.ALGO_ID_SIGNATURE_DSA;\n        }\n        \n        PrivateKey privateKey = issuerCrypto.getPrivateKey(issuerKeyName, issuerKeyPassword);\n\n        signature.setSignatureAlgorithm(sigAlgo);\n\n        BasicX509Credential signingCredential = new BasicX509Credential();\n        signingCredential.setEntityCertificate(issuerCerts[0]);\n        signingCredential.setPrivateKey(privateKey);\n\n        signature.setSigningCredential(signingCredential);\n\n        if (useKeyInfo) {\n            X509KeyInfoGeneratorFactory kiFactory = new X509KeyInfoGeneratorFactory();\n            kiFactory.setEmitEntityCertificate(true);\n            \n            try {\n                KeyInfo keyInfo = kiFactory.newInstance().generate(signingCredential);\n                signature.setKeyInfo(keyInfo);\n            } catch (org.opensaml.xml.security.SecurityException ex) {\n                throw new Exception(\n                        \"Error generating KeyInfo from signing credential\", ex);\n            }\n        }\n\n        // add the signature to the assertion\n        SignableSAMLObject signableObject = (SignableSAMLObject) response;\n        signableObject.setSignature(signature);\n        signableObject.releaseDOM();\n        signableObject.releaseChildrenDOM(true);\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"private Document createSignature(Message message, Document doc) \n        throws Exception {\n        \n        String userNameKey = SecurityConstants.SIGNATURE_USERNAME;\n        \n        CryptoLoader loader = new CryptoLoader();\n        Crypto crypto = loader.getCrypto(message, \n                                         SecurityConstants.SIGNATURE_CRYPTO,\n                                         SecurityConstants.SIGNATURE_PROPERTIES);\n        String user = SecurityUtils.getUserName(message, crypto, userNameKey);\n         \n        if (StringUtils.isEmpty(user) || SecurityUtils.USE_REQUEST_SIGNATURE_CERT.equals(user)) {\n            throw new Exception(\"User name is not available\");\n        }\n\n        String password = \n            SecurityUtils.getPassword(message, user, WSPasswordCallback.SIGNATURE, this.getClass());\n    \n        X509Certificate[] issuerCerts = SecurityUtils.getCertificates(crypto, user);\n        \n        String sigAlgo = sigProps.getSignatureAlgo() == null \n            ? SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA1 : sigProps.getSignatureAlgo();\n        \n        String pubKeyAlgo = issuerCerts[0].getPublicKey().getAlgorithm();\n        if (pubKeyAlgo.equalsIgnoreCase(\"DSA\")) {\n            sigAlgo = XMLSignature.ALGO_ID_SIGNATURE_DSA;\n        }\n        PrivateKey privateKey = null;\n        try {\n            privateKey = crypto.getPrivateKey(user, password);\n        } catch (Exception ex) {\n            String errorMessage = \"Private key can not be loaded, user:\" + user;\n            LOG.severe(errorMessage);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, ex);\n        }\n        \n        String id = UUID.randomUUID().toString();\n        String referenceId = \"#\" + id;\n        \n        String digestAlgo = sigProps.getSignatureDigestAlgo() == null \n            ? Constants.ALGO_ID_DIGEST_SHA1 : sigProps.getSignatureDigestAlgo();\n        \n        XMLSignature sig = null;\n        if (ENVELOPING_SIG.equals(sigStyle)) {\n            sig = prepareEnvelopingSignature(doc, id, referenceId, sigAlgo, digestAlgo);\n        } else if (DETACHED_SIG.equals(sigStyle)) {\n            sig = prepareDetachedSignature(doc, id, referenceId, sigAlgo, digestAlgo);\n        } else {\n            sig = prepareEnvelopedSignature(doc, id, referenceId, sigAlgo, digestAlgo);\n        }\n        \n        \n        sig.addKeyInfo(issuerCerts[0]);\n        sig.addKeyInfo(issuerCerts[0].getPublicKey());\n        sig.sign(privateKey);\n        return sig.getElement().getOwnerDocument();\n    }","id":78149,"modified_method":"private Document createSignature(Message message, Document doc) \n        throws Exception {\n        \n        String userNameKey = SecurityConstants.SIGNATURE_USERNAME;\n        \n        CryptoLoader loader = new CryptoLoader();\n        Crypto crypto = loader.getCrypto(message, \n                                         SecurityConstants.SIGNATURE_CRYPTO,\n                                         SecurityConstants.SIGNATURE_PROPERTIES);\n        String user = SecurityUtils.getUserName(message, crypto, userNameKey);\n         \n        if (StringUtils.isEmpty(user) || SecurityUtils.USE_REQUEST_SIGNATURE_CERT.equals(user)) {\n            throw new Exception(\"User name is not available\");\n        }\n\n        String password = \n            SecurityUtils.getPassword(message, user, WSPasswordCallback.SIGNATURE, this.getClass());\n    \n        X509Certificate[] issuerCerts = SecurityUtils.getCertificates(crypto, user);\n        \n        String sigAlgo = sigProps.getSignatureAlgo() == null \n            ? SignatureConstants.ALGO_ID_SIGNATURE_RSA_SHA1 : sigProps.getSignatureAlgo();\n        \n        String pubKeyAlgo = issuerCerts[0].getPublicKey().getAlgorithm();\n        if (pubKeyAlgo.equalsIgnoreCase(\"DSA\")) {\n            sigAlgo = XMLSignature.ALGO_ID_SIGNATURE_DSA;\n        }\n        PrivateKey privateKey = null;\n        try {\n            privateKey = crypto.getPrivateKey(user, password);\n        } catch (Exception ex) {\n            String errorMessage = \"Private key can not be loaded, user:\" + user;\n            LOG.severe(errorMessage);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, ex);\n        }\n        \n        String id = UUID.randomUUID().toString();\n        String referenceId = \"#\" + id;\n        \n        String digestAlgo = sigProps.getSignatureDigestAlgo() == null \n            ? Constants.ALGO_ID_DIGEST_SHA1 : sigProps.getSignatureDigestAlgo();\n        \n        XMLSignature sig = null;\n        if (ENVELOPING_SIG.equals(sigStyle)) {\n            sig = prepareEnvelopingSignature(doc, id, referenceId, sigAlgo, digestAlgo);\n        } else if (DETACHED_SIG.equals(sigStyle)) {\n            sig = prepareDetachedSignature(doc, id, referenceId, sigAlgo, digestAlgo);\n        } else {\n            sig = prepareEnvelopedSignature(doc, id, referenceId, sigAlgo, digestAlgo);\n        }\n        \n        if (this.keyInfoMustBeAvailable) {\n            sig.addKeyInfo(issuerCerts[0]);\n            sig.addKeyInfo(issuerCerts[0].getPublicKey());\n        }\n        sig.sign(privateKey);\n        return sig.getElement().getOwnerDocument();\n    }","commit_id":"b2cc4b22eb064e6a0b242646cb50772f8edc55d2","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public void filter(ContainerRequestContext context) throws IOException {\n        if (HttpMethod.GET.equals(context.getMethod())) {\n            return;\n        }\n        JwsCompactConsumer p = new JwsCompactConsumer(IOUtils.readStringFromStream(context.getEntityStream()));\n        JwsSignatureVerifier theSigVerifier = getInitializedSigVerifier(p.getJwsHeaders());\n        if (!p.verifySignatureWith(theSigVerifier)) {\n            context.abortWith(JAXRSUtils.toResponse(400));\n            return;\n        }\n        JoseUtils.validateRequestContextProperty(p.getJwsHeaders());\n        byte[] bytes = p.getDecodedJwsPayloadBytes();\n        context.setEntityStream(new ByteArrayInputStream(bytes));\n        context.getHeaders().putSingle(\"Content-Length\", Integer.toString(bytes.length));\n        \n        String ct = JoseUtils.checkContentType(p.getJwsHeaders().getContentType(), getDefaultMediaType());\n        if (ct != null) {\n            context.getHeaders().putSingle(\"Content-Type\", ct);\n        }\n    }","id":78150,"modified_method":"@Override\n    public void filter(ContainerRequestContext context) throws IOException {\n        if (HttpMethod.GET.equals(context.getMethod())) {\n            return;\n        }\n        JwsCompactConsumer p = new JwsCompactConsumer(IOUtils.readStringFromStream(context.getEntityStream()));\n        JwsSignatureVerifier theSigVerifier = getInitializedSigVerifier(p.getJwsHeaders());\n        if (!p.verifySignatureWith(theSigVerifier)) {\n            context.abortWith(JAXRSUtils.toResponse(400));\n            return;\n        }\n        JoseUtils.validateRequestContextProperty(p.getJwsHeaders());\n        byte[] bytes = p.getDecodedJwsPayloadBytes();\n        context.setEntityStream(new ByteArrayInputStream(bytes));\n        context.getHeaders().putSingle(\"Content-Length\", Integer.toString(bytes.length));\n        \n        String ct = JoseUtils.checkContentType(p.getJwsHeaders().getContentType(), getDefaultMediaType());\n        if (ct != null) {\n            context.getHeaders().putSingle(\"Content-Type\", ct);\n        }\n        \n        SecurityContext securityContext = configureSecurityContext(theSigVerifier);\n        if (securityContext != null) {\n            JAXRSUtils.getCurrentMessage().put(SecurityContext.class, securityContext);\n        }\n    }","commit_id":"f2b0bc8137ca5bed09fc25a20f1a2896cb15c838","url":"https://github.com/apache/cxf"},{"original_method":"public static JwsSignatureVerifier getPublicKeySignatureVerifier(X509Certificate cert, SignatureAlgorithm algo) {\n        return getPublicKeySignatureVerifier(cert.getPublicKey(), algo);\n    }","id":78151,"modified_method":"public static JwsSignatureVerifier getPublicKeySignatureVerifier(X509Certificate cert, SignatureAlgorithm algo) {\n        if (algo == null) {\n            LOG.warning(\"No signature algorithm was defined\");\n            throw new JwsException(JwsException.Error.ALGORITHM_NOT_SET);\n        }\n        \n        if (cert != null) {\n            if (cert.getPublicKey() instanceof RSAPublicKey) {\n                return new PublicKeyJwsSignatureVerifier(cert, algo);\n            } else if (cert.getPublicKey() instanceof ECPublicKey) {\n                return new EcDsaJwsSignatureVerifier(cert, algo);\n            }\n        }\n        \n        return null;\n    }","commit_id":"f2b0bc8137ca5bed09fc25a20f1a2896cb15c838","url":"https://github.com/apache/cxf"},{"original_method":"public static JwsSignatureVerifier loadSignatureVerifier(Message m, \n                                                              Properties props,\n                                                              JwsHeaders inHeaders, \n                                                              boolean ignoreNullVerifier) {\n        JwsSignatureVerifier theVerifier = null;\n        String inHeaderKid = null;\n        if (inHeaders != null) {\n            inHeaderKid = inHeaders.getKeyId();\n            //TODO: optionally validate inHeaders.getAlgorithm against a property in props\n            if (inHeaders.getHeader(JoseConstants.HEADER_JSON_WEB_KEY) != null) {\n                JsonWebKey publicJwk = inHeaders.getJsonWebKey();\n                if (inHeaderKid != null && !inHeaderKid.equals(publicJwk.getKeyId())\n                    || !MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {\n                    throw new JwsException(JwsException.Error.INVALID_KEY);\n                }\n                return getSignatureVerifier(publicJwk, \n                                            inHeaders.getSignatureAlgorithm());\n            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_CHAIN) != null) {\n                List<X509Certificate> chain = KeyManagementUtils.toX509CertificateChain(inHeaders.getX509Chain());\n                KeyManagementUtils.validateCertificateChain(props, chain);\n                return getPublicKeySignatureVerifier(chain.get(0).getPublicKey(), \n                                                     inHeaders.getSignatureAlgorithm());\n            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT) != null) {\n                X509Certificate foundCert = \n                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509Thumbprint(), \n                                                                    MessageDigestUtils.ALGO_SHA_1,\n                                                                    m, props);\n                if (foundCert != null) {\n                    return getPublicKeySignatureVerifier(foundCert.getPublicKey(), \n                                                         inHeaders.getSignatureAlgorithm());\n                }\n            }\n        }\n        \n        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.VERIFY, inHeaderKid);\n            if (jwk != null) {\n                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, \n                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()), \n                                                             getDefaultKeyAlgorithm(jwk));\n                theVerifier = getSignatureVerifier(jwk, signatureAlgo);\n            }\n            \n        } else {\n            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);\n            if (signatureAlgo == SignatureAlgorithm.NONE \n                && SignatureAlgorithm.NONE.getJwaName().equals(inHeaders.getAlgorithm())) {\n                theVerifier = new NoneJwsSignatureVerifier();\n            } else {\n                theVerifier = getPublicKeySignatureVerifier(\n                              KeyManagementUtils.loadPublicKey(m, props), \n                              signatureAlgo);\n            }\n        }\n        if (theVerifier == null && !ignoreNullVerifier) {\n            LOG.warning(\"Verifier is not available\");\n            throw new JwsException(JwsException.Error.NO_VERIFIER);\n        }\n        return theVerifier;\n    }","id":78152,"modified_method":"public static JwsSignatureVerifier loadSignatureVerifier(Message m, \n                                                              Properties props,\n                                                              JwsHeaders inHeaders, \n                                                              boolean ignoreNullVerifier) {\n        JwsSignatureVerifier theVerifier = null;\n        String inHeaderKid = null;\n        if (inHeaders != null) {\n            inHeaderKid = inHeaders.getKeyId();\n            //TODO: optionally validate inHeaders.getAlgorithm against a property in props\n            if (inHeaders.getHeader(JoseConstants.HEADER_JSON_WEB_KEY) != null) {\n                JsonWebKey publicJwk = inHeaders.getJsonWebKey();\n                if (inHeaderKid != null && !inHeaderKid.equals(publicJwk.getKeyId())\n                    || !MessageUtils.getContextualBoolean(m, JoseConstants.RSSEC_ACCEPT_PUBLIC_KEY, false)) {\n                    throw new JwsException(JwsException.Error.INVALID_KEY);\n                }\n                return getSignatureVerifier(publicJwk, \n                                            inHeaders.getSignatureAlgorithm());\n            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_CHAIN) != null) {\n                List<X509Certificate> chain = KeyManagementUtils.toX509CertificateChain(inHeaders.getX509Chain());\n                KeyManagementUtils.validateCertificateChain(props, chain);\n                return getPublicKeySignatureVerifier(chain.get(0), \n                                                     inHeaders.getSignatureAlgorithm());\n            } else if (inHeaders.getHeader(JoseConstants.HEADER_X509_THUMBPRINT) != null) {\n                X509Certificate foundCert = \n                    KeyManagementUtils.getCertificateFromThumbprint(inHeaders.getX509Thumbprint(), \n                                                                    MessageDigestUtils.ALGO_SHA_1,\n                                                                    m, props);\n                if (foundCert != null) {\n                    return getPublicKeySignatureVerifier(foundCert, \n                                                         inHeaders.getSignatureAlgorithm());\n                }\n            }\n        }\n        \n        if (JoseConstants.HEADER_JSON_WEB_KEY.equals(props.get(JoseConstants.RSSEC_KEY_STORE_TYPE))) {\n            JsonWebKey jwk = JwkUtils.loadJsonWebKey(m, props, KeyOperation.VERIFY, inHeaderKid);\n            if (jwk != null) {\n                SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, \n                                                             SignatureAlgorithm.getAlgorithm(jwk.getAlgorithm()), \n                                                             getDefaultKeyAlgorithm(jwk));\n                theVerifier = getSignatureVerifier(jwk, signatureAlgo);\n            }\n            \n        } else {\n            SignatureAlgorithm signatureAlgo = getSignatureAlgorithm(m, props, null, null);\n            if (signatureAlgo == SignatureAlgorithm.NONE \n                && SignatureAlgorithm.NONE.getJwaName().equals(inHeaders.getAlgorithm())) {\n                theVerifier = new NoneJwsSignatureVerifier();\n            } else {\n                X509Certificate[] certs = KeyManagementUtils.loadX509CertificateOrChain(m, props);\n                if (certs != null && certs.length > 0) {\n                    theVerifier = getPublicKeySignatureVerifier(certs[0], signatureAlgo);\n                }\n            }\n        }\n        if (theVerifier == null && !ignoreNullVerifier) {\n            LOG.warning(\"Verifier is not available\");\n            throw new JwsException(JwsException.Error.NO_VERIFIER);\n        }\n        return theVerifier;\n    }","commit_id":"f2b0bc8137ca5bed09fc25a20f1a2896cb15c838","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public boolean implies(ProtectionDomain domain, Permission permission) {\n        PermissionCollection pc;\n\n        if (!_initialized)\n        {\n            synchronized (_initialized)\n            {\n                // make sure we haven't been initialized since obtaining lock\n                if (!_initialized)\n                {\n                    refresh();\n                }\n            }\n        }\n\n        synchronized (_cache) {\n            pc = _cache.get(domain);\n        }\n\n        if (pc != null) {\n            return pc.implies(permission);\n        } \n        \n        pc = getPermissions(domain);\n        if (pc == null) {\n            return false;\n        }\n\n        synchronized (_cache) {\n            // cache it \n            _cache.put(domain, pc);\n        }\n        \n        return pc.implies(permission);\n    }","id":78153,"modified_method":"@Override\n    public boolean implies(ProtectionDomain domain, Permission permission)\n    {\n        PermissionCollection pc = getPermissions(domain);\n        \n        return (pc == null ? false : pc.implies(permission));\n    }","commit_id":"bbbf5d7503c22286e02a9e65c7d0d12d870f0215","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public PermissionCollection getPermissions(ProtectionDomain domain)\n    {\n\n        if (!_initialized)\n        {\n            synchronized (_initialized)\n            {\n                // make sure we haven't been initialized since obtaining lock\n                if (!_initialized)\n                {\n                    refresh();\n                }\n            }\n        }\n\n        if (_cache.containsKey(domain))\n        {\n            return _cache.get(domain);\n        }\n\n        synchronized (_cache)\n        {\n            // check if it was added in since we obtained lock\n            if (_cache.containsKey(domain))\n            {\n                return _cache.get(domain);\n            }\n\n            PermissionCollection perms = new Permissions();\n\n            for (Iterator<PolicyBlock> i = _grants.iterator(); i.hasNext();)\n            {\n                PolicyBlock policyBlock = i.next();\n                ProtectionDomain grantPD = policyBlock.toProtectionDomain();\n\n                if (__DEBUG)\n                {\n                    System.out.println(\"----START----\");\n                    System.out.println(\"PDCS: \" + policyBlock.getCodeSource());\n                    System.out.println(\"CS: \" + domain.getCodeSource());\n                }\n\n                // 1) if protection domain codesource is null, it is the global permissions (grant {})\n                // 2) if protection domain codesource implies target codesource and there are no prinicpals\n                // 2) if protection domain codesource implies target codesource and principals align\n                if (grantPD.getCodeSource() == null || grantPD.getCodeSource().implies(domain.getCodeSource()) && grantPD.getPrincipals() == null || grantPD.getCodeSource().implies(domain.getCodeSource())\n                        && validate(grantPD.getPrincipals(),domain.getPrincipals()))\n                {\n\n                    for (Enumeration<Permission> e = policyBlock.getPermissions().elements(); e.hasMoreElements();)\n                    {\n                        Permission perm = e.nextElement();\n                        if (__DEBUG)\n                        {\n                            System.out.println(\"D: \" + perm);\n                        }\n                        perms.add(perm);\n                    }\n                }\n                if (__DEBUG)\n                {\n                    System.out.println(\"----STOP----\");\n                }\n            }\n\n            _cache.put(domain,perms);\n\n            return perms;\n        }\n    }","id":78154,"modified_method":"@Override\n    public PermissionCollection getPermissions(ProtectionDomain domain)\n    {\n\n        synchronized (_initialized)\n        {\n            if (!_initialized)\n            {\n                refresh();\n            }\n        }\n\n        synchronized (_cache)\n        {\n            if (_cache.containsKey(domain))\n            {\n                return copyOf(_cache.get(domain));\n            }\n\n            PermissionCollection perms = new Permissions();\n\n            for (Iterator<PolicyBlock> i = _grants.iterator(); i.hasNext();)\n            {\n                PolicyBlock policyBlock = i.next();\n                ProtectionDomain grantPD = policyBlock.toProtectionDomain();\n\n                if (__DEBUG)\n                {\n                    System.out.println(\"----START----\");\n                    System.out.println(\"PDCS: \" + policyBlock.getCodeSource());\n                    System.out.println(\"CS: \" + domain.getCodeSource());\n                }\n\n                // 1) if protection domain codesource is null, it is the global permissions (grant {})\n                // 2) if protection domain codesource implies target codesource and there are no prinicpals\n                // 2) if protection domain codesource implies target codesource and principals align\n                if (grantPD.getCodeSource() == null || grantPD.getCodeSource().implies(domain.getCodeSource()) && grantPD.getPrincipals() == null || grantPD.getCodeSource().implies(domain.getCodeSource())\n                        && validate(grantPD.getPrincipals(),domain.getPrincipals()))\n                {\n\n                    for (Enumeration<Permission> e = policyBlock.getPermissions().elements(); e.hasMoreElements();)\n                    {\n                        Permission perm = e.nextElement();\n                        if (__DEBUG)\n                        {\n                            System.out.println(\"D: \" + perm);\n                        }\n                        perms.add(perm);\n                    }\n                }\n                if (__DEBUG)\n                {\n                    System.out.println(\"----STOP----\");\n                }\n            }\n\n            _cache.put(domain,perms);\n\n            return copyOf(perms);\n        }\n    }","commit_id":"bbbf5d7503c22286e02a9e65c7d0d12d870f0215","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public PermissionCollection getPermissions(CodeSource codesource)\n    {\n        if (!_initialized)\n        {\n            synchronized (_initialized)\n            {\n                // make sure we haven't been initialized since obtaining lock\n                if (!_initialized)\n                {\n                    refresh();\n                }\n            }\n        }\n\n        if (_cache.containsKey(codesource))\n        {\n            return _cache.get(codesource);\n        }\n\n        synchronized (_cache)\n        {\n            // check if it was added in since we obtained lock\n            if (_cache.containsKey(codesource))\n            {\n                return _cache.get(codesource);\n            }\n\n            PermissionCollection perms = new Permissions();\n\n            for (Iterator<PolicyBlock> i = _grants.iterator(); i.hasNext();)\n            {\n                PolicyBlock policyBlock = i.next();\n                ProtectionDomain grantPD = policyBlock.toProtectionDomain();\n\n                if (grantPD.getCodeSource() == null || grantPD.getCodeSource().implies(codesource))\n                {\n                    if (__DEBUG)\n                    {\n                        System.out.println(\"----START----\");\n                        System.out.println(\"PDCS: \" + grantPD.getCodeSource());\n                        System.out.println(\"CS: \" + codesource);\n                    }\n\n                    for (Enumeration<Permission> e = policyBlock.getPermissions().elements(); e.hasMoreElements();)\n                    {\n                        Permission perm = e.nextElement();\n                        if (__DEBUG)\n                        {\n                            System.out.println(\"D: \" + perm);\n                        }\n                        perms.add(perm);\n                    }\n\n                    if (__DEBUG)\n                    {\n                        System.out.println(\"----STOP----\");\n                    }\n                }\n            }\n\n            _cache.put(codesource,perms);\n\n            return perms;\n        }\n    }","id":78155,"modified_method":"@Override\n    public PermissionCollection getPermissions(CodeSource codesource)\n    {\n        synchronized (_initialized)\n        {\n            if (!_initialized)\n            {\n                refresh();\n            }\n        }\n\n        synchronized (_cache)\n        {\n            if (_cache.containsKey(codesource))\n            {\n                return copyOf(_cache.get(codesource));\n            }\n\n            PermissionCollection perms = new Permissions();\n\n            for (Iterator<PolicyBlock> i = _grants.iterator(); i.hasNext();)\n            {\n                PolicyBlock policyBlock = i.next();\n                ProtectionDomain grantPD = policyBlock.toProtectionDomain();\n\n                if (grantPD.getCodeSource() == null || grantPD.getCodeSource().implies(codesource))\n                {\n                    if (__DEBUG)\n                    {\n                        System.out.println(\"----START----\");\n                        System.out.println(\"PDCS: \" + grantPD.getCodeSource());\n                        System.out.println(\"CS: \" + codesource);\n                    }\n\n                    for (Enumeration<Permission> e = policyBlock.getPermissions().elements(); e.hasMoreElements();)\n                    {\n                        Permission perm = e.nextElement();\n                        if (__DEBUG)\n                        {\n                            System.out.println(\"D: \" + perm);\n                        }\n                        perms.add(perm);\n                    }\n\n                    if (__DEBUG)\n                    {\n                        System.out.println(\"----STOP----\");\n                    }\n                }\n            }\n\n            _cache.put(codesource,perms);\n\n            return copyOf(perms);\n        }\n    }","commit_id":"bbbf5d7503c22286e02a9e65c7d0d12d870f0215","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private boolean _checkWithPACLPolicyPolicy(\n\t\tProtectionDomain protectionDomain, Permission permission,\n\t\tPermissionCollection permissionCollection) {\n\n\t\tif (!(permissionCollection instanceof PortalPermissionCollection)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tPortalPermissionCollection portalPermissionCollection =\n\t\t\t(PortalPermissionCollection)permissionCollection;\n\n\t\tPolicy policy = portalPermissionCollection.getPolicy();\n\n\t\tClassLoader classLoader = portalPermissionCollection.getClassLoader();\n\n\t\tif ((policy != null) &&\n\t\t\t(classLoader == protectionDomain.getClassLoader())) {\n\n\t\t\treturn policy.implies(protectionDomain, permission);\n\t\t}\n\n\t\treturn false;\n\t}","id":78156,"modified_method":"private boolean _checkWithPACLPolicyPolicy(\n\t\tProtectionDomain protectionDomain, Permission permission,\n\t\tPermissionCollection permissionCollection) {\n\n\t\tPortalPermissionCollection portalPermissionCollection =\n\t\t\t(PortalPermissionCollection)permissionCollection;\n\n\t\tPolicy policy = portalPermissionCollection.getPolicy();\n\n\t\tClassLoader classLoader = portalPermissionCollection.getClassLoader();\n\n\t\tif ((policy != null) &&\n\t\t\t(classLoader == protectionDomain.getClassLoader())) {\n\n\t\t\treturn policy.implies(protectionDomain, permission);\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"b8bc32c0e9725a69647c3a70d17b8d3af2040e4c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean implies(\n\t\tProtectionDomain protectionDomain, Permission permission) {\n\n\t\tif (_started.get().booleanValue()) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttry {\n\t\t\t_started.set(true);\n\n\t\t\tif (!(permission instanceof PACLUtil.Permission) &&\n\t\t\t\t((protectionDomain.getClassLoader() == null) ||\n\t\t\t\t !_paclPolicy.isCheckablePermission(permission))) {\n\n\t\t\t\treturn _checkWithParentPolicy(protectionDomain, permission);\n\t\t\t}\n\n\t\t\tObject key = _getKey(protectionDomain);\n\n\t\t\tPermissionCollection permissionCollection = getPermissions(\n\t\t\t\tprotectionDomain);\n\n\t\t\tif (permissionCollection != null) {\n\t\t\t\tif (permissionCollection.implies(permission)) {\n\t\t\t\t\treturn _checkWithParentPolicy(protectionDomain, permission);\n\t\t\t\t}\n\t\t\t\telse if (_checkWithPACLPolicyPolicy(\n\t\t\t\t\t\t\tprotectionDomain,\n\t\t\t\t\t\t\tpermission, permissionCollection)) {\n\n\t\t\t\t\treturn _checkWithParentPolicy(protectionDomain, permission);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tpermissionCollection = getPermissions(protectionDomain);\n\n\t\t\t_permissionCollections.putIfAbsent(key, permissionCollection);\n\n\t\t\tif (permissionCollection.implies(permission)) {\n\t\t\t\treturn _checkWithParentPolicy(protectionDomain, permission);\n\t\t\t}\n\t\t\telse if (_checkWithPACLPolicyPolicy(\n\t\t\t\t\t\tprotectionDomain, permission, permissionCollection)) {\n\n\t\t\t\treturn _checkWithParentPolicy(protectionDomain, permission);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t\tfinally {\n\t\t\t_started.set(false);\n\t\t}\n\t}","id":78157,"modified_method":"@Override\n\tpublic boolean implies(\n\t\tProtectionDomain protectionDomain, Permission permission) {\n\n\t\tif (_started.get().booleanValue()) {\n\t\t\treturn true;\n\t\t}\n\n\t\ttry {\n\t\t\t_started.set(true);\n\n\t\t\tPermissionCollection permissionCollection = null;\n\n\t\t\tif (!(permission instanceof PACLUtil.Permission) &&\n\t\t\t\t!_paclPolicy.isCheckablePermission(permission)) {\n\n\t\t\t\treturn _checkWithParentPolicy(protectionDomain, permission);\n\t\t\t}\n\n\t\t\tif (permissionCollection instanceof\n\t\t\t\t\tPortalPermissionCollection) {\n\n\t\t\t\tif (permissionCollection.implies(permission) ||\n\t\t\t\t\t_checkWithPACLPolicyPolicy(\n\t\t\t\t\t\tprotectionDomain, permission, permissionCollection)) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tthrow new AccessControlException(\n\t\t\t\t\t\"access denied \" + permission, permission);\n\t\t\t}\n\n\t\t\treturn _checkWithParentPolicy(protectionDomain, permission);\n\t\t}\n\t\tfinally {\n\t\t\t_started.set(false);\n\t\t}\n\t}","commit_id":"b8bc32c0e9725a69647c3a70d17b8d3af2040e4c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean implies(Permission permission) {\n\t\tif (Reflection.getCallerClass(1) == ProtectionDomain.class) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!_paclPolicy.isActive()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (permission instanceof PACLUtil.Permission) {\n\t\t\tthrow new PACLUtil.Exception(_paclPolicy);\n\t\t}\n\n\t\tif (_permissionCollection.implies(permission) ||\n\t\t\t_paclPolicy.implies(permission)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":78158,"modified_method":"@Override\n\tpublic boolean implies(Permission permission) {\n\t\tif (!_paclPolicy.isActive()) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (permission instanceof PACLUtil.Permission) {\n\t\t\tthrow new PACLUtil.Exception(_paclPolicy);\n\t\t}\n\n\t\tif (_paclPolicy.implies(permission)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"50b8ef9f7d5ef9bb873ef9583506e968a02b5f5b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public PortalPermissionCollection(\n\t\tPACLPolicy paclPolicy, PermissionCollection permissionCollection) {\n\n\t\t_paclPolicy = paclPolicy;\n\t\t_permissionCollection = permissionCollection;\n\t}","id":78159,"modified_method":"public PortalPermissionCollection(PACLPolicy paclPolicy) {\n\t\t_paclPolicy = paclPolicy;\n\t}","commit_id":"50b8ef9f7d5ef9bb873ef9583506e968a02b5f5b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic PermissionCollection getPermissions(\n\t\tProtectionDomain protectionDomain) {\n\n\t\tif (protectionDomain == null) {\n\t\t\treturn new Permissions();\n\t\t}\n\n\t\tObject key = _getKey(protectionDomain);\n\n\t\tPermissionCollection permissionCollection = _getPermissionCollection(\n\t\t\tkey);\n\n\t\tif (permissionCollection != null) {\n\t\t\treturn permissionCollection;\n\t\t}\n\n\t\tpermissionCollection = getPermissions(protectionDomain.getCodeSource());\n\n\t\tif (permissionCollection == null) {\n\t\t\tpermissionCollection = new Permissions();\n\t\t}\n\n\t\tif (_policy != null) {\n\t\t\t_addExtraPermissions(\n\t\t\t\tpermissionCollection, _policy.getPermissions(protectionDomain));\n\t\t}\n\n\t\t_addExtraPermissions(\n\t\t\tpermissionCollection, protectionDomain.getPermissions());\n\n\t\tPACLPolicy paclPolicy = PACLPolicyManager.getPACLPolicy(\n\t\t\tprotectionDomain.getClassLoader());\n\n\t\tif (paclPolicy != null) {\n\t\t\treturn new PortalPermissionCollection(\n\t\t\t\tpaclPolicy, permissionCollection);\n\t\t}\n\n\t\tpermissionCollection.add(_allPermission);\n\n\t\treturn permissionCollection;\n\t}","id":78160,"modified_method":"@Override\n\tpublic PermissionCollection getPermissions(\n\t\tProtectionDomain protectionDomain) {\n\n\t\tif (protectionDomain == null) {\n\t\t\treturn new Permissions();\n\t\t}\n\n\t\tObject key = _getKey(protectionDomain);\n\n\t\tPermissionCollection permissionCollection = _getPermissionCollection(\n\t\t\tkey);\n\n\t\tif (permissionCollection != null) {\n\t\t\treturn permissionCollection;\n\t\t}\n\n\t\tpermissionCollection = getPermissions(protectionDomain.getCodeSource());\n\n\t\tif (permissionCollection == null) {\n\t\t\tpermissionCollection = new Permissions();\n\t\t}\n\n\t\tif (_policy != null) {\n\t\t\t_addExtraPermissions(\n\t\t\t\tpermissionCollection, _policy.getPermissions(protectionDomain));\n\t\t}\n\n\t\t_addExtraPermissions(\n\t\t\tpermissionCollection, protectionDomain.getPermissions());\n\n\t\tPACLPolicy paclPolicy = PACLPolicyManager.getPACLPolicy(\n\t\t\tprotectionDomain.getClassLoader());\n\n\t\tif (paclPolicy != null) {\n\t\t\treturn new PortalPermissionCollection(paclPolicy);\n\t\t}\n\n\t\tpermissionCollection.add(_allPermission);\n\n\t\treturn permissionCollection;\n\t}","commit_id":"50b8ef9f7d5ef9bb873ef9583506e968a02b5f5b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public Iterable<Resource> getResources(Resource.Type type, Request request, Predicate predicate)\n      throws UnsupportedPropertyException,\n             SystemException,\n             NoSuchParentResourceException,\n             NoSuchResourceException {\n    PageResponse response = getResources(type, request, predicate, null);\n    return response.getIterable();\n  }","id":78161,"modified_method":"public Iterable<Resource> getResources(Resource.Type type, Request request, Predicate predicate)\n      throws UnsupportedPropertyException,\n             SystemException,\n             NoSuchParentResourceException,\n             NoSuchResourceException {\n    return getResources(type, request, predicate, null).getIterable();\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Populate the given resources from the associated property providers.  This\n   * method may filter the resources based on the predicate and return a subset\n   * of the given resources.\n   *\n   * @param type       the resource type\n   * @param resources  the resources to be populated\n   * @param request    the request\n   * @param predicate  the predicate\n   *\n   * @return the set of resources that were successfully populated\n   *\n   * @throws SystemException if unable to populate the resources\n   */\n  private Set<Resource> populateResources(Resource.Type type,\n                                          Set<Resource> resources,\n                                          Request request,\n                                          Predicate predicate) throws SystemException {\n    Set<Resource> keepers = resources;\n\n    for (PropertyProvider propertyProvider : propertyProviders.get(type)) {\n      if (providesRequestProperties(propertyProvider, request, predicate)) {\n        keepers = propertyProvider.populateResources(keepers, request, predicate);\n      }\n    }\n    return keepers;\n  }","id":78162,"modified_method":"/**\n   * Populate the given resources from the associated property providers.  This\n   * method may filter the resources based on the predicate and return a subset\n   * of the given resources.\n   *\n   * @param type       the resource type\n   * @param resources  the resources to be populated\n   * @param request    the request\n   * @param predicate  the predicate\n   *\n   * @return the set of resources that were successfully populated\n   *\n   * @throws SystemException if unable to populate the resources\n   */\n  @Override\n  public Set<Resource> populateResources(Resource.Type type,\n                                         Set<Resource> resources,\n                                         Request request,\n                                         Predicate predicate) throws SystemException {\n    Set<Resource> keepers = resources;\n\n    for (PropertyProvider propertyProvider : propertyProviders.get(type)) {\n      if (providesRequestProperties(propertyProvider, request, predicate)) {\n        keepers = propertyProvider.populateResources(keepers, request, predicate);\n      }\n    }\n    return keepers;\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public PageResponse getResources(Resource.Type type, Request request, Predicate predicate, PageRequest pageRequest)\n      throws UnsupportedPropertyException,\n             SystemException,\n             NoSuchResourceException,\n             NoSuchParentResourceException {\n    ResourceProvider provider = ensureResourceProvider(type);\n    ensurePropertyProviders(type);\n    Set<Resource> resources;\n\n    ResourcePredicateEvaluator evaluator = provider instanceof ResourcePredicateEvaluator ?\n      (ResourcePredicateEvaluator) provider : DEFAULT_RESOURCE_PREDICATE_EVALUATOR;\n\n    if (provider == null) {\n      resources = Collections.emptySet();\n    } else {\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Using resource provider \"\n            + provider.getClass().getName()\n            + \" for request type \" + type.toString());\n      }\n      checkProperties(type, request, predicate);\n\n      Set<Resource> providerResources = provider.getResources(request, predicate);\n      providerResources               = populateResources(type, providerResources, request, predicate);\n\n      Comparator<Resource> resourceComparator = pageRequest == null || pageRequest.getComparator() == null ?\n          comparator : pageRequest.getComparator();\n\n      TreeSet<Resource> sortedResources = new TreeSet<Resource>(resourceComparator);\n      sortedResources.addAll(providerResources);\n\n      if (pageRequest != null) {\n        switch (pageRequest.getStartingPoint()) {\n          case Beginning:\n            return getPageFromOffset(pageRequest.getPageSize(), 0,\n              sortedResources, predicate, evaluator);\n          case End:\n            return getPageToOffset(pageRequest.getPageSize(), -1,\n              sortedResources, predicate, evaluator);\n          case OffsetStart:\n            return getPageFromOffset(pageRequest.getPageSize(),\n              pageRequest.getOffset(), sortedResources, predicate, evaluator);\n          case OffsetEnd:\n            return getPageToOffset(pageRequest.getPageSize(),\n              pageRequest.getOffset(), sortedResources, predicate, evaluator);\n          // TODO : need to support the following cases for pagination\n//          case PredicateStart:\n//          case PredicateEnd:\n        }\n      }\n      resources = sortedResources;\n    }\n\n    return new PageResponseImpl(new ResourceIterable(resources, predicate, evaluator),\n      0, null, null);\n  }","id":78163,"modified_method":"public PageResponse getResources(Resource.Type type, Request request, Predicate predicate, PageRequest pageRequest)\n      throws UnsupportedPropertyException,\n             SystemException,\n             NoSuchResourceException,\n             NoSuchParentResourceException {\n\n    Set<Resource> providerResources = getRawResources(type, request, predicate);\n    populateResources(type, providerResources, request, predicate);\n    return getResources(type, providerResources, predicate, pageRequest);\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesWithPredicate() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c2\", \"p4\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(\"c1/p2\").equals(1).toPredicate();\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, predicate);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(2, cnt);\n  }","id":78164,"modified_method":"@Test\n  public void testGetResourcesWithPredicate() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c2\", \"p4\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(\"c1/p2\").equals(1).toPredicate();\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, predicate);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(2, cnt);\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesPageToEnd() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the last two\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.End, 2, 0, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:3\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:4\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.End, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:4\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","id":78165,"modified_method":"@Test\n  public void testGetResourcesPageToEnd() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the last two\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.End, 2, 0, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:3\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:4\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.End, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:4\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesPageToOffset() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the middle two (1 - 2)\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetEnd, 2, 2, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(1, pageResponse.getOffset());\n    Assert.assertEquals(\"host:1\", pageResponse.getPreviousResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three (0 - 2)\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetEnd, 3, 2, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(0, pageResponse.getOffset());\n    Assert.assertNull(pageResponse.getPreviousResource());\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","id":78166,"modified_method":"@Test\n  public void testGetResourcesPageToOffset() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the middle two (1 - 2)\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetEnd, 2, 2, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(1, pageResponse.getOffset());\n    Assert.assertEquals(\"host:1\", pageResponse.getPreviousResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three (0 - 2)\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetEnd, 3, 2, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(0, pageResponse.getOffset());\n    Assert.assertNull(pageResponse.getPreviousResource());\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesWithUnsupportedPropertyPredicate() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c2\", \"p4\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(UNSUPPORTED_PROPERTY).equals(1).toPredicate();\n\n    try {\n      controller.getResources(Resource.Type.Host, request, predicate);\n      Assert.fail(\"Expected an UnsupportedPropertyException for the unsupported properties.\");\n    } catch (UnsupportedPropertyException e) {\n      // Expected\n    }\n  }","id":78167,"modified_method":"@Test\n  public void testGetResourcesWithUnsupportedPropertyPredicate() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c2\", \"p4\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(UNSUPPORTED_PROPERTY).equals(1).toPredicate();\n\n    try {\n      controller.getResources(Resource.Type.Host, request, predicate);\n      Assert.fail(\"Expected an UnsupportedPropertyException for the unsupported properties.\");\n    } catch (UnsupportedPropertyException e) {\n      // Expected\n    }\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesCheckOrder() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    String lastHostName = null;\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n\n      String hostName = (String) resource.getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\"));\n\n      if (lastHostName != null) {\n        Assert.assertTrue(hostName.compareTo(lastHostName) > 0);\n      }\n      lastHostName = hostName;\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","id":78168,"modified_method":"@Test\n  public void testGetResourcesCheckOrder() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    String lastHostName = null;\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n\n      String hostName = (String) resource.getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\"));\n\n      if (lastHostName != null) {\n        Assert.assertTrue(hostName.compareTo(lastHostName) > 0);\n      }\n      lastHostName = hostName;\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesPageFromOffset() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the middle two (1 - 2)\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetStart, 2, 1, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(1, pageResponse.getOffset());\n    Assert.assertEquals(\"host:1\", pageResponse.getPreviousResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three (0 - 2)\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetStart, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(0, pageResponse.getOffset());\n    Assert.assertNull(pageResponse.getPreviousResource());\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","id":78169,"modified_method":"@Test\n  public void testGetResourcesPageFromOffset() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the middle two (1 - 2)\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetStart, 2, 1, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(1, pageResponse.getOffset());\n    Assert.assertEquals(\"host:1\", pageResponse.getPreviousResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three (0 - 2)\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetStart, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(0, pageResponse.getOffset());\n    Assert.assertNull(pageResponse.getPreviousResource());\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesWithUnsupportedPropertyRequest() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(UNSUPPORTED_PROPERTY);\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(\"c1/p2\").equals(1).toPredicate();\n\n    try {\n      controller.getResources(Resource.Type.Host, request, predicate);\n      Assert.fail(\"Expected an UnsupportedPropertyException for the unsupported properties.\");\n    } catch (UnsupportedPropertyException e) {\n      // Expected\n    }\n  }","id":78170,"modified_method":"@Test\n  public void testGetResourcesWithUnsupportedPropertyRequest() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(UNSUPPORTED_PROPERTY);\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(\"c1/p2\").equals(1).toPredicate();\n\n    try {\n      controller.getResources(Resource.Type.Host, request, predicate);\n      Assert.fail(\"Expected an UnsupportedPropertyException for the unsupported properties.\");\n    } catch (UnsupportedPropertyException e) {\n      // Expected\n    }\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesEmptyRequest() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","id":78171,"modified_method":"@Test\n  public void testGetResourcesEmptyRequest() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesPageFromStart() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the first two\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.Beginning, 2, 0, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the first three\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.Beginning, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","id":78172,"modified_method":"@Test\n  public void testGetResourcesPageFromStart() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the first two\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.Beginning, 2, 0, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the first three\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.Beginning, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResources() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","id":78173,"modified_method":"@Test\n  public void testGetResources() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Result execute()\n      throws UnsupportedPropertyException, SystemException, NoSuchResourceException, NoSuchParentResourceException {\n\n    Result result = createResult();\n    Resource.Type resourceType = m_resource.getResourceDefinition().getType();\n    if (m_resource.getIds().get(resourceType) == null) {\n      addCollectionProperties(resourceType);\n      result.getResultTree().setProperty(\"isCollection\", \"true\");\n    }\n\n    if (m_setQueryProperties.isEmpty() && m_mapSubResources.isEmpty()) {\n      //Add sub resource properties for default case where no fields are specified.\n      m_mapSubResources.putAll(m_resource.getSubResources());\n    }\n\n    if (LOG.isDebugEnabled()) {\n      //todo: include predicate info.  Need to implement toString for all predicates.\n      LOG.debug(\"Executing resource query: \" + m_resource.getIds());\n    }\n\n    Predicate predicate = createPredicate(m_resource);\n    Iterable<Resource> iterResource;\n\n    if (m_pageRequest == null) {\n      iterResource = getClusterController().getResources(\n          resourceType, createRequest(), predicate);\n    } else {\n      PageResponse pageResponse = getClusterController().getResources(\n          resourceType, createRequest(), predicate, m_pageRequest);\n      iterResource = pageResponse.getIterable();\n    }\n\n    TreeNode<Resource> tree = result.getResultTree();\n    int count = 1;\n    for (Resource resource : iterResource) {\n      // add a child node for the resource and provide a unique name.  The name is never used.\n      //todo: provide a more meaningful node name\n      TreeNode<Resource> node = tree.addChild(resource, resource.getType() + \":\" + count++);\n      for (Map.Entry<String, ResourceInstance> entry : m_mapSubResources.entrySet()) {\n        String subResCategory = entry.getKey();\n        ResourceInstance r = entry.getValue();\n\n        setParentIdsOnSubResource(resource, r);\n\n        TreeNode<Resource> childResult = r.getQuery().execute().getResultTree();\n        childResult.setName(subResCategory);\n        childResult.setProperty(\"isCollection\", \"false\");\n        node.addChild(childResult);\n      }\n    }\n    return result;\n  }","id":78174,"modified_method":"@Override\n  public Result execute() throws NoSuchParentResourceException, UnsupportedPropertyException, NoSuchResourceException, SystemException {\n\n    Map<Resource,Collection<Resource>> resourceTree =\n        new HashMap<Resource, Collection<Resource>>();\n    Map<Resource,String> resourceNames = new HashMap<Resource, String>();\n\n    Map<QueryImpl, Resource> nextLevel = new HashMap<QueryImpl, Resource>();\n    nextLevel.put(this, null);\n\n    while (!nextLevel.isEmpty()) {\n      Map<QueryImpl, Resource> current = nextLevel;\n      Map<Resource.Type, Set<Resource>> resourceMap = new HashMap<Resource.Type, Set<Resource>>();\n      Map<Resource.Type, Predicate> predicateMap = new HashMap<Resource.Type, Predicate>();\n\n      Map<Resource.Type, Request> requestMap = new HashMap<Resource.Type, Request>();\n\n      //All resource instances in tree have same set of property ids, only resource type is valuable\n      //Request and predicate are formed using data described above\n      for (QueryImpl query : current.keySet()) {\n\n        Resource.Type type = query.getResourceType();\n        if (!resourceMap.containsKey(type)) {\n          resourceMap.put(type, new HashSet<Resource>());\n          predicateMap.put(type, query.getPredicate());\n          requestMap.put(type, query.createRequest());\n        }\n\n        resourceMap.get(type).addAll(query.getProviderResources());\n\n      }\n\n      getClusterController().populateResources(resourceMap, requestMap, predicateMap);\n\n      //fill next level\n      nextLevel = new HashMap<QueryImpl, Resource>();\n\n      for (Map.Entry<QueryImpl, Resource> entry : current.entrySet()) {\n        QueryImpl query = entry.getKey();\n        Resource parent = entry.getValue();\n\n        Map<QueryImpl, Resource> subQueries = query.getSubQueries();\n\n        Collection<Resource> validResources = new ArrayList<Resource>();\n\n        for (Resource resource : query.getResourceIterable()) {\n          validResources.add(resource);\n        }\n\n        resourceTree.put(parent, validResources);\n\n        resourceNames.put(parent, query.getResultName());\n\n        nextLevel.putAll(subQueries);\n      }\n\n    }\n\n    //create Result\n    Result result = createResult();\n    populateResult(result, resourceTree, resourceNames, null, null);\n    return result;\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Predicate getPredicate() {\n    //todo: create predicate once\n    return createPredicate(m_resource);\n  }","id":78175,"modified_method":"@Override\n  public Predicate getPredicate() {\n    if (m_predicate == null) {\n      m_predicate = createPredicate(m_resource);\n    }\n    return m_predicate;\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"private Request createRequest() {\n    Set<String> setProperties = new HashSet<String>();\n\n    Map<String, TemporalInfo> mapTemporalInfo    = new HashMap<String, TemporalInfo>();\n    TemporalInfo              globalTemporalInfo = m_mapCategoryTemporalInfo.get(null);\n\n    for (String group : m_setQueryProperties) {\n      TemporalInfo temporalInfo = m_mapCategoryTemporalInfo.get(group);\n      if (temporalInfo != null) {\n        mapTemporalInfo.put(group, temporalInfo);\n      } else if (globalTemporalInfo != null) {\n        mapTemporalInfo.put(group, globalTemporalInfo);\n      }\n      setProperties.add(group);\n    }\n\n    return PropertyHelper.getReadRequest(allProperties ? Collections.<String>emptySet() : setProperties, mapTemporalInfo);\n  }","id":78176,"modified_method":"public Request createRequest() {\n    Set<String> setProperties = new HashSet<String>();\n\n    Map<String, TemporalInfo> mapTemporalInfo    = new HashMap<String, TemporalInfo>();\n    TemporalInfo              globalTemporalInfo = m_mapCategoryTemporalInfo.get(null);\n\n    for (String group : m_setQueryProperties) {\n      TemporalInfo temporalInfo = m_mapCategoryTemporalInfo.get(group);\n      if (temporalInfo != null) {\n        mapTemporalInfo.put(group, temporalInfo);\n      } else if (globalTemporalInfo != null) {\n        mapTemporalInfo.put(group, globalTemporalInfo);\n      }\n      setProperties.add(group);\n    }\n\n    return PropertyHelper.getReadRequest(allProperties ? Collections.<String>emptySet() : setProperties, mapTemporalInfo);\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecute__collection_nonNullInternalPredicate_nonNullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    String servicePropertyId = \"serviceId\";\n    String clusterPropertyId = \"clusterId\";\n\n    Set<String> setPropertyIds = new HashSet<String>();\n    setPropertyIds.add(clusterPropertyId);\n    setPropertyIds.add(servicePropertyId);\n    setPropertyIds.add(componentPropertyId);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    List<Resource> listResources = Collections.singletonList(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, null);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate internalPredicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").toPredicate();\n\n    pb = new PredicateBuilder();\n    Predicate userPredicate = pb.property(\"foo\").equals(\"bar\").toPredicate();\n    // combine internal predicate and user predicate\n    //todo: for now, need to cast to BasePredicate\n    Predicate predicate = new AndPredicate(internalPredicate, userPredicate);\n\n    // expectations\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).atLeastOnce();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\").anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\").anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(setPropertyIds)),\n        eq(predicate))).andReturn(listResources);\n\n    expect(componentResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.setUserPredicate(userPredicate);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertSame(componentResource, componentNode.getObject());\n    assertEquals(0, componentNode.getChildren().size());\n  }","id":78177,"modified_method":"@Test\n  public void testExecute__collection_nonNullInternalPredicate_nonNullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    String servicePropertyId = \"serviceId\";\n    String clusterPropertyId = \"clusterId\";\n\n    Set<String> setPropertyIds = new HashSet<String>();\n    setPropertyIds.add(clusterPropertyId);\n    setPropertyIds.add(servicePropertyId);\n    setPropertyIds.add(componentPropertyId);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    Set<Resource> resourceSet = Collections.singleton(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, null);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate internalPredicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").toPredicate();\n\n    pb = new PredicateBuilder();\n    Predicate userPredicate = pb.property(\"foo\").equals(\"bar\").toPredicate();\n    // combine internal predicate and user predicate\n    //todo: for now, need to cast to BasePredicate\n    Predicate predicate = new AndPredicate(internalPredicate, userPredicate);\n\n    // expectations\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).atLeastOnce();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\").anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\").anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n//    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(setPropertyIds)),\n//        eq(predicate))).andReturn(resourceSet);\n\n    expect(m_controller.getRawResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(setPropertyIds)),\n        eq(predicate))).andReturn(resourceSet);\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(resourceSet), eq(predicate))).andReturn(\n        resourceSet);\n\n    expect(componentResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.setUserPredicate(userPredicate);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertSame(componentResource, componentNode.getObject());\n    assertEquals(0, componentNode.getChildren().size());\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecute__Component_instance_noSpecifiedProps() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    ResourceInstance hostResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition hostResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    Query hostComponentQuery = createStrictMock(Query.class);\n    Result hostComponentQueryResult = createNiceMock(Result.class);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    TreeNode<Resource> hostComponentResultNode = new TreeNodeImpl<Resource>(null, null, null);\n    List<Resource> listResources = Collections.singletonList(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, \"componentName\");\n\n    Map<String, ResourceInstance> mapChildren = new HashMap<String, ResourceInstance>();\n    mapChildren.put(\"host_components\", hostResourceInstance);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate predicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").and().\n        property(\"componentId\").equals(\"componentName\").toPredicate();\n\n    // expectations\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n    expect(componentResourceInstance.getSubResources()).andReturn(mapChildren).anyTimes();\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n    expect(componentResource.getPropertyValue(componentPropertyId)).andReturn(\"keyVal\");\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\");\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\");\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).atLeastOnce();\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.<String>emptySet())),\n        eq(predicate))).andReturn(listResources);\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n    Map<Resource.Type, String> mapResourceIdsSet = new HashMap<Resource.Type, String>(mapResourceIds);\n    mapResourceIdsSet.put(Resource.Type.Component, \"keyVal\");\n    hostResourceInstance.setIds(mapResourceIdsSet);\n    expect(hostResourceInstance.getResourceDefinition()).andReturn(hostResourceDefinition).anyTimes();\n    expect(hostResourceInstance.getQuery()).andReturn(hostComponentQuery).anyTimes();\n\n    expect(hostResourceDefinition.getType()).andReturn(Resource.Type.Host);\n    expect(hostComponentQuery.execute()).andReturn(hostComponentQueryResult);\n    expect(hostComponentQueryResult.getResultTree()).andReturn(hostComponentResultNode);\n\n    replay(m_controller, result, componentResourceInstance, componentResourceDefinition, hostResourceInstance, componentSchema, componentResource,\n        hostComponentQuery, hostComponentQueryResult);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, hostResourceInstance, componentSchema, componentResource,\n        hostComponentQuery, hostComponentQueryResult);\n\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertEquals(\"Component:1\", componentNode.getName());\n    assertEquals(componentResource, componentNode.getObject());\n    assertEquals(1, componentNode.getChildren().size());\n    assertSame(hostComponentResultNode, componentNode.getChild(\"host_components\"));\n    assertEquals(\"false\", hostComponentResultNode.getProperty(\"isCollection\"));\n  }","id":78178,"modified_method":"@Test\n  public void testExecute__Component_instance_noSpecifiedProps() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    ResourceInstance hostResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition hostResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    QueryImpl hostComponentQuery = createStrictMock(QueryImpl.class);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    Set<Resource> listResources = Collections.singleton(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, \"componentName\");\n\n    Map<String, ResourceInstance> mapChildren = new HashMap<String, ResourceInstance>();\n    mapChildren.put(\"host_components\", hostResourceInstance);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate predicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").and().\n        property(\"componentId\").equals(\"componentName\").toPredicate();\n\n    // expectations\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n    expect(componentResourceInstance.getSubResources()).andReturn(mapChildren).anyTimes();\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n\n    expect(hostResourceInstance.createCopy()).andReturn(hostResourceInstance).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n    expect(componentResource.getPropertyValue(componentPropertyId)).andReturn(\"keyVal\");\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\");\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\");\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).atLeastOnce();\n\n    expect(m_controller.getRawResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.<String>emptySet())),\n        eq(predicate))).andReturn(listResources);\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(listResources), eq(predicate))).andReturn(\n        listResources);\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n    Map<Resource.Type, String> mapResourceIdsSet = new HashMap<Resource.Type, String>(mapResourceIds);\n    mapResourceIdsSet.put(Resource.Type.Component, \"keyVal\");\n    hostResourceInstance.setIds(mapResourceIdsSet);\n    expect(hostResourceInstance.getResourceDefinition()).andReturn(hostResourceDefinition).anyTimes();\n    expect(hostResourceInstance.getQuery()).andReturn(hostComponentQuery).anyTimes();\n\n    expect(hostResourceDefinition.getType()).andReturn(Resource.Type.Host);\n\n//    expect(hostComponentQuery.getResourceInstance()).andReturn(hostResourceInstance);\n    expect(hostComponentQuery.getResourceType()).andReturn(Resource.Type.Host);\n    expect(hostComponentQuery.getPredicate()).andReturn(predicate);\n    expect(hostComponentQuery.createRequest()).andReturn(PropertyHelper.getReadRequest(Collections.<String>emptySet()));\n    expect(hostComponentQuery.getProviderResources()).andReturn(Collections.<Resource>emptySet());\n    expect(hostComponentQuery.getSubQueries()).andReturn(Collections.<QueryImpl, Resource>emptyMap());\n    expect(hostComponentQuery.getResourceIterable()).andReturn(Collections.<Resource>emptySet());\n    expect(hostComponentQuery.getResultName()).andReturn(\"host_components\");\n\n\n    replay(m_controller, result, componentResourceInstance, componentResourceDefinition, hostResourceInstance, componentSchema, componentResource,\n        hostComponentQuery);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, hostResourceInstance, componentSchema, componentResource,\n        hostComponentQuery);\n\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertEquals(\"Component:1\", componentNode.getName());\n    assertEquals(componentResource, componentNode.getObject());\n    assertEquals(1, componentNode.getChildren().size());\n    assertEquals(\"false\", componentNode.getChild(\"host_components\").getProperty(\"isCollection\"));\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecute__collection_nullInternalPredicate_nullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance clusterResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition clusterResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema clusterSchema = createNiceMock(Schema.class);\n    Resource clusterResource = createNiceMock(Resource.class);\n    String clusterPropertyId = \"clusterId\";\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    List<Resource> listResources = Collections.singletonList(clusterResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n\n    // expectations\n    expect(clusterResource.getType()).andReturn(Resource.Type.Cluster).anyTimes();\n\n    expect(clusterResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(clusterResourceInstance.getResourceDefinition()).andReturn(clusterResourceDefinition).anyTimes();\n\n    expect(clusterResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(clusterSchema).atLeastOnce();\n\n    expect(clusterSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(clusterPropertyId).atLeastOnce();\n\n    expect(result.getResultTree()).andReturn(tree).atLeastOnce();\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.singleton(clusterPropertyId))),\n        (Predicate) isNull())).andReturn(listResources);\n\n\n    expect(clusterResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource);\n\n    QueryImpl query = new TestQuery(clusterResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> clusterNode = tree.getChild(\"Cluster:1\");\n    assertSame(clusterResource, clusterNode.getObject());\n    assertEquals(0, clusterNode.getChildren().size());\n\n  }","id":78179,"modified_method":"@Test\n  public void testExecute__collection_nullInternalPredicate_nullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance clusterResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition clusterResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema clusterSchema = createNiceMock(Schema.class);\n    Resource clusterResource = createNiceMock(Resource.class);\n    String clusterPropertyId = \"clusterId\";\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    Set<Resource> resourceSet = Collections.singleton(clusterResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n\n    // expectations\n    expect(clusterResource.getType()).andReturn(Resource.Type.Cluster).anyTimes();\n\n    expect(clusterResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(clusterResourceInstance.getResourceDefinition()).andReturn(clusterResourceDefinition).anyTimes();\n\n    expect(clusterResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(clusterSchema).atLeastOnce();\n\n    expect(clusterSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(clusterPropertyId).atLeastOnce();\n\n    expect(result.getResultTree()).andReturn(tree).atLeastOnce();\n\n    expect(m_controller.getRawResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.singleton(clusterPropertyId))),\n        isNull(Predicate.class))).andReturn(resourceSet);\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(resourceSet), isNull(Predicate.class))).andReturn(\n        resourceSet);\n\n\n    expect(clusterResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource);\n\n    QueryImpl query = new TestQuery(clusterResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> clusterNode = tree.getChild(\"Cluster:1\");\n    assertSame(clusterResource, clusterNode.getObject());\n    assertEquals(0, clusterNode.getChildren().size());\n\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecute__Component_collection_noSpecifiedProps() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    String servicePropertyId = \"serviceId\";\n    String clusterPropertyId = \"clusterId\";\n\n    Set<String> setPropertyIds = new HashSet<String>();\n    setPropertyIds.add(clusterPropertyId);\n    setPropertyIds.add(servicePropertyId);\n    setPropertyIds.add(componentPropertyId);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    List<Resource> listResources = Collections.singletonList(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, null);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate predicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").toPredicate();\n\n    // expectations\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\").anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\").anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(setPropertyIds)),\n        eq(predicate))).andReturn(listResources);\n\n    expect(componentResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result,componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertSame(componentResource, componentNode.getObject());\n    assertEquals(0, componentNode.getChildren().size());\n  }","id":78180,"modified_method":"@Test\n  public void testExecute__Component_collection_noSpecifiedProps() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    String servicePropertyId = \"serviceId\";\n    String clusterPropertyId = \"clusterId\";\n\n    Set<String> setPropertyIds = new HashSet<String>();\n    setPropertyIds.add(clusterPropertyId);\n    setPropertyIds.add(servicePropertyId);\n    setPropertyIds.add(componentPropertyId);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    Set<Resource> resourceSet = Collections.singleton(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, null);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate predicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").toPredicate();\n\n    // expectations\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\").anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\").anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n\n    expect(m_controller.getRawResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(setPropertyIds)),\n        eq(predicate))).andReturn(resourceSet);\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(resourceSet), eq(predicate))).andReturn(\n        resourceSet);\n\n    expect(componentResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result,componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertSame(componentResource, componentNode.getObject());\n    assertEquals(0, componentNode.getChildren().size());\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecute__collection_nullInternalPredicate_nonNullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance clusterResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition clusterResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema clusterSchema = createNiceMock(Schema.class);\n    Resource clusterResource = createNiceMock(Resource.class);\n    String clusterPropertyId = \"clusterId\";\n    Predicate userPredicate = createNiceMock(Predicate.class);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    List<Resource> listResources = Collections.singletonList(clusterResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n\n    // expectations\n    expect(clusterResource.getType()).andReturn(Resource.Type.Cluster).anyTimes();\n\n    expect(clusterResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(clusterResourceInstance.getResourceDefinition()).andReturn(clusterResourceDefinition).anyTimes();\n\n    expect(clusterResourceDefinition.getType()).andReturn(Resource.Type.Component).atLeastOnce();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(clusterSchema).anyTimes();\n    expect(clusterSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(clusterPropertyId).anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.singleton(clusterPropertyId))),\n        eq(userPredicate))).andReturn(listResources);\n\n    expect(clusterResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result,clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource, userPredicate);\n\n    QueryImpl query = new TestQuery(clusterResourceInstance, result);\n    query.setUserPredicate(userPredicate);\n    query.execute();\n\n    verify(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource, userPredicate);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> clusterNode = tree.getChild(\"Cluster:1\");\n    assertSame(clusterResource, clusterNode.getObject());\n    assertEquals(0, clusterNode.getChildren().size());\n  }","id":78181,"modified_method":"@Test\n  public void testExecute__collection_nullInternalPredicate_nonNullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance clusterResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition clusterResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema clusterSchema = createNiceMock(Schema.class);\n    Resource clusterResource = createNiceMock(Resource.class);\n    String clusterPropertyId = \"clusterId\";\n    Predicate userPredicate = createNiceMock(Predicate.class);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    Set<Resource> resourceSet = Collections.singleton(clusterResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n\n    // expectations\n    expect(clusterResource.getType()).andReturn(Resource.Type.Cluster).anyTimes();\n\n    expect(clusterResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(clusterResourceInstance.getResourceDefinition()).andReturn(clusterResourceDefinition).anyTimes();\n\n    expect(clusterResourceDefinition.getType()).andReturn(Resource.Type.Component).atLeastOnce();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(clusterSchema).anyTimes();\n    expect(clusterSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(clusterPropertyId).anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n//    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.singleton(clusterPropertyId))),\n//        eq(userPredicate))).andReturn(resourceSet);\n\n    expect(m_controller.getRawResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.singleton(clusterPropertyId))),\n        eq(userPredicate))).andReturn(resourceSet);\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(resourceSet), eq(userPredicate))).andReturn(\n        resourceSet);\n\n    expect(clusterResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result,clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource, userPredicate);\n\n    QueryImpl query = new TestQuery(clusterResourceInstance, result);\n    query.setUserPredicate(userPredicate);\n    query.execute();\n\n    verify(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource, userPredicate);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> clusterNode = tree.getChild(\"Cluster:1\");\n    assertSame(clusterResource, clusterNode.getObject());\n    assertEquals(0, clusterNode.getChildren().size());\n  }","commit_id":"20702c6bf5dc99206980967b30335ab0061b1770","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public PageResponse getResources(Resource.Type type, Request request, Predicate predicate, PageRequest pageRequest)\n      throws UnsupportedPropertyException,\n             SystemException,\n             NoSuchResourceException,\n             NoSuchParentResourceException {\n    ResourceProvider provider = ensureResourceProvider(type);\n    ensurePropertyProviders(type);\n    Set<Resource> resources;\n\n    ResourcePredicateEvaluator evaluator = provider instanceof ResourcePredicateEvaluator ?\n      (ResourcePredicateEvaluator) provider : DEFAULT_RESOURCE_PREDICATE_EVALUATOR;\n\n    if (provider == null) {\n      resources = Collections.emptySet();\n    } else {\n\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Using resource provider \"\n            + provider.getClass().getName()\n            + \" for request type \" + type.toString());\n      }\n      checkProperties(type, request, predicate);\n\n      Set<Resource> providerResources = provider.getResources(request, predicate);\n      providerResources               = populateResources(type, providerResources, request, predicate);\n\n      Comparator<Resource> resourceComparator = pageRequest == null || pageRequest.getComparator() == null ?\n          comparator : pageRequest.getComparator();\n\n      TreeSet<Resource> sortedResources = new TreeSet<Resource>(resourceComparator);\n      sortedResources.addAll(providerResources);\n\n      if (pageRequest != null) {\n        switch (pageRequest.getStartingPoint()) {\n          case Beginning:\n            return getPageFromOffset(pageRequest.getPageSize(), 0,\n              sortedResources, predicate, evaluator);\n          case End:\n            return getPageToOffset(pageRequest.getPageSize(), -1,\n              sortedResources, predicate, evaluator);\n          case OffsetStart:\n            return getPageFromOffset(pageRequest.getPageSize(),\n              pageRequest.getOffset(), sortedResources, predicate, evaluator);\n          case OffsetEnd:\n            return getPageToOffset(pageRequest.getPageSize(),\n              pageRequest.getOffset(), sortedResources, predicate, evaluator);\n          // TODO : need to support the following cases for pagination\n//          case PredicateStart:\n//          case PredicateEnd:\n        }\n      }\n      resources = sortedResources;\n    }\n\n    return new PageResponseImpl(new ResourceIterable(resources, predicate, evaluator),\n      0, null, null);\n  }","id":78182,"modified_method":"public PageResponse getResources(Resource.Type type, Request request, Predicate predicate, PageRequest pageRequest)\n      throws UnsupportedPropertyException,\n             SystemException,\n             NoSuchResourceException,\n             NoSuchParentResourceException {\n\n    Set<Resource> providerResources = getRawResources(type, request, predicate);\n    populateResources(type, providerResources, request, predicate);\n    return getResources(type, providerResources, predicate, pageRequest);\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Iterable<Resource> getResources(Resource.Type type, Request request, Predicate predicate)\n      throws UnsupportedPropertyException,\n             SystemException,\n             NoSuchParentResourceException,\n             NoSuchResourceException {\n    PageResponse response = getResources(type, request, predicate, null);\n    return response.getIterable();\n  }","id":78183,"modified_method":"public Iterable<Resource> getResources(Resource.Type type, Request request, Predicate predicate)\n      throws UnsupportedPropertyException,\n             SystemException,\n             NoSuchParentResourceException,\n             NoSuchResourceException {\n    return getResources(type, request, predicate, null).getIterable();\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Populate the given resources from the associated property providers.  This\n   * method may filter the resources based on the predicate and return a subset\n   * of the given resources.\n   *\n   * @param type       the resource type\n   * @param resources  the resources to be populated\n   * @param request    the request\n   * @param predicate  the predicate\n   *\n   * @return the set of resources that were successfully populated\n   *\n   * @throws SystemException if unable to populate the resources\n   */\n  private Set<Resource> populateResources(Resource.Type type,\n                                          Set<Resource> resources,\n                                          Request request,\n                                          Predicate predicate) throws SystemException {\n    Set<Resource> keepers = resources;\n\n    for (PropertyProvider propertyProvider : propertyProviders.get(type)) {\n      if (providesRequestProperties(propertyProvider, request, predicate)) {\n        keepers = propertyProvider.populateResources(keepers, request, predicate);\n      }\n    }\n    return keepers;\n  }","id":78184,"modified_method":"/**\n   * Populate the given resources from the associated property providers.  This\n   * method may filter the resources based on the predicate and return a subset\n   * of the given resources.\n   *\n   * @param type       the resource type\n   * @param resources  the resources to be populated\n   * @param request    the request\n   * @param predicate  the predicate\n   *\n   * @return the set of resources that were successfully populated\n   *\n   * @throws SystemException if unable to populate the resources\n   */\n  @Override\n  public Set<Resource> populateResources(Resource.Type type,\n                                         Set<Resource> resources,\n                                         Request request,\n                                         Predicate predicate) throws SystemException {\n    Set<Resource> keepers = resources;\n\n    for (PropertyProvider propertyProvider : propertyProviders.get(type)) {\n      if (providesRequestProperties(propertyProvider, request, predicate)) {\n        keepers = propertyProvider.populateResources(keepers, request, predicate);\n      }\n    }\n    return keepers;\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesWithUnsupportedPropertyRequest() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(UNSUPPORTED_PROPERTY);\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(\"c1/p2\").equals(1).toPredicate();\n\n    try {\n      controller.getResources(Resource.Type.Host, request, predicate);\n      Assert.fail(\"Expected an UnsupportedPropertyException for the unsupported properties.\");\n    } catch (UnsupportedPropertyException e) {\n      // Expected\n    }\n  }","id":78185,"modified_method":"@Test\n  public void testGetResourcesWithUnsupportedPropertyRequest() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(UNSUPPORTED_PROPERTY);\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(\"c1/p2\").equals(1).toPredicate();\n\n    try {\n      controller.getResources(Resource.Type.Host, request, predicate);\n      Assert.fail(\"Expected an UnsupportedPropertyException for the unsupported properties.\");\n    } catch (UnsupportedPropertyException e) {\n      // Expected\n    }\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesCheckOrder() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    String lastHostName = null;\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n\n      String hostName = (String) resource.getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\"));\n\n      if (lastHostName != null) {\n        Assert.assertTrue(hostName.compareTo(lastHostName) > 0);\n      }\n      lastHostName = hostName;\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","id":78186,"modified_method":"@Test\n  public void testGetResourcesCheckOrder() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    String lastHostName = null;\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n\n      String hostName = (String) resource.getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\"));\n\n      if (lastHostName != null) {\n        Assert.assertTrue(hostName.compareTo(lastHostName) > 0);\n      }\n      lastHostName = hostName;\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesEmptyRequest() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","id":78187,"modified_method":"@Test\n  public void testGetResourcesEmptyRequest() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesPageToOffset() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the middle two (1 - 2)\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetEnd, 2, 2, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(1, pageResponse.getOffset());\n    Assert.assertEquals(\"host:1\", pageResponse.getPreviousResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three (0 - 2)\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetEnd, 3, 2, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(0, pageResponse.getOffset());\n    Assert.assertNull(pageResponse.getPreviousResource());\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","id":78188,"modified_method":"@Test\n  public void testGetResourcesPageToOffset() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the middle two (1 - 2)\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetEnd, 2, 2, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(1, pageResponse.getOffset());\n    Assert.assertEquals(\"host:1\", pageResponse.getPreviousResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three (0 - 2)\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetEnd, 3, 2, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(0, pageResponse.getOffset());\n    Assert.assertNull(pageResponse.getPreviousResource());\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesPageFromStart() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the first two\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.Beginning, 2, 0, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the first three\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.Beginning, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","id":78189,"modified_method":"@Test\n  public void testGetResourcesPageFromStart() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the first two\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.Beginning, 2, 0, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the first three\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.Beginning, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResources() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","id":78190,"modified_method":"@Test\n  public void testGetResources() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, null);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(4, cnt);\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesWithPredicate() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c2\", \"p4\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(\"c1/p2\").equals(1).toPredicate();\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, predicate);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(2, cnt);\n  }","id":78191,"modified_method":"@Test\n  public void testGetResourcesWithPredicate() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c2\", \"p4\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(\"c1/p2\").equals(1).toPredicate();\n\n    Iterable<Resource> iterable = controller.getResources(Resource.Type.Host, request, predicate);\n\n    int cnt = 0;\n    for (Resource resource : iterable) {\n      Assert.assertEquals(Resource.Type.Host, resource.getType());\n      ++cnt;\n    }\n    Assert.assertEquals(2, cnt);\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesPageToEnd() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the last two\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.End, 2, 0, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:3\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:4\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.End, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:4\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","id":78192,"modified_method":"@Test\n  public void testGetResourcesPageToEnd() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the last two\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.End, 2, 0, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:3\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:4\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.End, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:4\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesPageFromOffset() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the middle two (1 - 2)\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetStart, 2, 1, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(1, pageResponse.getOffset());\n    Assert.assertEquals(\"host:1\", pageResponse.getPreviousResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three (0 - 2)\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetStart, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(0, pageResponse.getOffset());\n    Assert.assertNull(pageResponse.getPreviousResource());\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","id":78193,"modified_method":"@Test\n  public void testGetResourcesPageFromOffset() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    // get the middle two (1 - 2)\n    PageRequest pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetStart, 2, 1, null, null);\n    PageResponse pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(1, pageResponse.getOffset());\n    Assert.assertEquals(\"host:1\", pageResponse.getPreviousResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    Iterable<Resource> iterable = pageResponse.getIterable();\n    List<Resource> list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(2, list.size());\n    Assert.assertEquals(\"host:2\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n\n    // get the last three (0 - 2)\n    pageRequest = new PageRequestImpl(PageRequest.StartingPoint.OffsetStart, 3, 0, null, null);\n    pageResponse = controller.getResources(Resource.Type.Host, request, null, pageRequest);\n\n    Assert.assertEquals(0, pageResponse.getOffset());\n    Assert.assertNull(pageResponse.getPreviousResource());\n    Assert.assertEquals(\"host:4\", pageResponse.getNextResource().getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n\n    iterable = pageResponse.getIterable();\n    list = new LinkedList<Resource>();\n\n    for (Resource resource : iterable) {\n      list.add(resource);\n    }\n    Assert.assertEquals(3, list.size());\n    Assert.assertEquals(\"host:1\", (String) list.get(0).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(0).getType());\n    Assert.assertEquals(\"host:2\", (String) list.get(1).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(1).getType());\n    Assert.assertEquals(\"host:3\", (String) list.get(2).getPropertyValue(PropertyHelper.getPropertyId(\"Hosts\", \"host_name\")));\n    Assert.assertEquals(Resource.Type.Host, list.get(2).getType());\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testGetResourcesWithUnsupportedPropertyPredicate() throws Exception{\n    ClusterController controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c2\", \"p4\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(UNSUPPORTED_PROPERTY).equals(1).toPredicate();\n\n    try {\n      controller.getResources(Resource.Type.Host, request, predicate);\n      Assert.fail(\"Expected an UnsupportedPropertyException for the unsupported properties.\");\n    } catch (UnsupportedPropertyException e) {\n      // Expected\n    }\n  }","id":78194,"modified_method":"@Test\n  public void testGetResourcesWithUnsupportedPropertyPredicate() throws Exception{\n    ClusterControllerImpl controller = new ClusterControllerImpl(new TestProviderModule());\n\n    Set<String> propertyIds = new HashSet<String>();\n\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p1\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p2\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c1\", \"p3\"));\n    propertyIds.add(PropertyHelper.getPropertyId(\"c2\", \"p4\"));\n\n    Request request = PropertyHelper.getReadRequest(propertyIds);\n\n    Predicate predicate = new PredicateBuilder().property(UNSUPPORTED_PROPERTY).equals(1).toPredicate();\n\n    try {\n      controller.getResources(Resource.Type.Host, request, predicate);\n      Assert.fail(\"Expected an UnsupportedPropertyException for the unsupported properties.\");\n    } catch (UnsupportedPropertyException e) {\n      // Expected\n    }\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Result execute()\n      throws UnsupportedPropertyException, SystemException, NoSuchResourceException, NoSuchParentResourceException {\n\n    Result result = createResult();\n    Resource.Type resourceType = m_resource.getResourceDefinition().getType();\n    if (m_resource.getIds().get(resourceType) == null) {\n      addCollectionProperties(resourceType);\n      result.getResultTree().setProperty(\"isCollection\", \"true\");\n    }\n\n    if (m_setQueryProperties.isEmpty() && m_mapSubResources.isEmpty()) {\n      //Add sub resource properties for default case where no fields are specified.\n      m_mapSubResources.putAll(m_resource.getSubResources());\n    }\n\n    if (LOG.isDebugEnabled()) {\n      //todo: include predicate info.  Need to implement toString for all predicates.\n      LOG.debug(\"Executing resource query: \" + m_resource.getIds());\n    }\n\n    Predicate predicate = createPredicate(m_resource);\n    Iterable<Resource> iterResource;\n\n    if (m_pageRequest == null) {\n      iterResource = getClusterController().getResources(\n          resourceType, createRequest(), predicate);\n    } else {\n      PageResponse pageResponse = getClusterController().getResources(\n          resourceType, createRequest(), predicate, m_pageRequest);\n      iterResource = pageResponse.getIterable();\n    }\n\n    TreeNode<Resource> tree = result.getResultTree();\n    int count = 1;\n    for (Resource resource : iterResource) {\n      // add a child node for the resource and provide a unique name.  The name is never used.\n      //todo: provide a more meaningful node name\n      TreeNode<Resource> node = tree.addChild(resource, resource.getType() + \":\" + count++);\n      for (Map.Entry<String, ResourceInstance> entry : m_mapSubResources.entrySet()) {\n        String subResCategory = entry.getKey();\n        ResourceInstance r = entry.getValue();\n\n        setParentIdsOnSubResource(resource, r);\n\n        TreeNode<Resource> childResult = r.getQuery().execute().getResultTree();\n        childResult.setName(subResCategory);\n        childResult.setProperty(\"isCollection\", \"false\");\n        node.addChild(childResult);\n      }\n    }\n    return result;\n  }","id":78195,"modified_method":"@Override\n  public Result execute() throws NoSuchParentResourceException, UnsupportedPropertyException, NoSuchResourceException, SystemException {\n\n    Map<Resource,Collection<Resource>> resourceTree =\n        new HashMap<Resource, Collection<Resource>>();\n    Map<Resource,String> resourceNames = new HashMap<Resource, String>();\n\n    Map<QueryImpl, Resource> nextLevel = new HashMap<QueryImpl, Resource>();\n    nextLevel.put(this, null);\n\n    while (!nextLevel.isEmpty()) {\n      Map<QueryImpl, Resource> current = nextLevel;\n      Map<Resource.Type, Set<Resource>> resourceMap = new HashMap<Resource.Type, Set<Resource>>();\n      Map<Resource.Type, Predicate> predicateMap = new HashMap<Resource.Type, Predicate>();\n\n      Map<Resource.Type, Request> requestMap = new HashMap<Resource.Type, Request>();\n\n      //All resource instances in tree have same set of property ids, only resource type is valuable\n      //Request and predicate are formed using data described above\n      for (QueryImpl query : current.keySet()) {\n\n        Resource.Type type = query.getResourceType();\n        if (!resourceMap.containsKey(type)) {\n          resourceMap.put(type, new HashSet<Resource>());\n          predicateMap.put(type, query.getPredicate());\n          requestMap.put(type, query.createRequest());\n        }\n\n        resourceMap.get(type).addAll(query.getProviderResources());\n\n      }\n\n      getClusterController().populateResources(resourceMap, requestMap, predicateMap);\n\n      //fill next level\n      nextLevel = new HashMap<QueryImpl, Resource>();\n\n      for (Map.Entry<QueryImpl, Resource> entry : current.entrySet()) {\n        QueryImpl query = entry.getKey();\n        Resource parent = entry.getValue();\n\n        Map<QueryImpl, Resource> subQueries = query.getSubQueries();\n\n        Collection<Resource> validResources = new ArrayList<Resource>();\n\n        for (Resource resource : query.getResourceIterable()) {\n          validResources.add(resource);\n        }\n\n        resourceTree.put(parent, validResources);\n\n        resourceNames.put(parent, query.getResultName());\n\n        nextLevel.putAll(subQueries);\n      }\n\n    }\n\n    //create Result\n    Result result = createResult();\n    populateResult(result, resourceTree, resourceNames, null, null);\n    return result;\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Predicate getPredicate() {\n    //todo: create predicate once\n    return createPredicate(m_resource);\n  }","id":78196,"modified_method":"@Override\n  public Predicate getPredicate() {\n    if (m_predicate == null) {\n      m_predicate = createPredicate(m_resource);\n    }\n    return m_predicate;\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"private Request createRequest() {\n    Set<String> setProperties = new HashSet<String>();\n\n    Map<String, TemporalInfo> mapTemporalInfo    = new HashMap<String, TemporalInfo>();\n    TemporalInfo              globalTemporalInfo = m_mapCategoryTemporalInfo.get(null);\n\n    for (String group : m_setQueryProperties) {\n      TemporalInfo temporalInfo = m_mapCategoryTemporalInfo.get(group);\n      if (temporalInfo != null) {\n        mapTemporalInfo.put(group, temporalInfo);\n      } else if (globalTemporalInfo != null) {\n        mapTemporalInfo.put(group, globalTemporalInfo);\n      }\n      setProperties.add(group);\n    }\n\n    return PropertyHelper.getReadRequest(allProperties ? Collections.<String>emptySet() : setProperties, mapTemporalInfo);\n  }","id":78197,"modified_method":"public Request createRequest() {\n    Set<String> setProperties = new HashSet<String>();\n\n    Map<String, TemporalInfo> mapTemporalInfo    = new HashMap<String, TemporalInfo>();\n    TemporalInfo              globalTemporalInfo = m_mapCategoryTemporalInfo.get(null);\n\n    for (String group : m_setQueryProperties) {\n      TemporalInfo temporalInfo = m_mapCategoryTemporalInfo.get(group);\n      if (temporalInfo != null) {\n        mapTemporalInfo.put(group, temporalInfo);\n      } else if (globalTemporalInfo != null) {\n        mapTemporalInfo.put(group, globalTemporalInfo);\n      }\n      setProperties.add(group);\n    }\n\n    return PropertyHelper.getReadRequest(allProperties ? Collections.<String>emptySet() : setProperties, mapTemporalInfo);\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecute__Component_instance_noSpecifiedProps() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    ResourceInstance hostResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition hostResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    Query hostComponentQuery = createStrictMock(Query.class);\n    Result hostComponentQueryResult = createNiceMock(Result.class);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    TreeNode<Resource> hostComponentResultNode = new TreeNodeImpl<Resource>(null, null, null);\n    List<Resource> listResources = Collections.singletonList(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, \"componentName\");\n\n    Map<String, ResourceInstance> mapChildren = new HashMap<String, ResourceInstance>();\n    mapChildren.put(\"host_components\", hostResourceInstance);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate predicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").and().\n        property(\"componentId\").equals(\"componentName\").toPredicate();\n\n    // expectations\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n    expect(componentResourceInstance.getSubResources()).andReturn(mapChildren).anyTimes();\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n    expect(componentResource.getPropertyValue(componentPropertyId)).andReturn(\"keyVal\");\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\");\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\");\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).atLeastOnce();\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.<String>emptySet())),\n        eq(predicate))).andReturn(listResources);\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n    Map<Resource.Type, String> mapResourceIdsSet = new HashMap<Resource.Type, String>(mapResourceIds);\n    mapResourceIdsSet.put(Resource.Type.Component, \"keyVal\");\n    hostResourceInstance.setIds(mapResourceIdsSet);\n    expect(hostResourceInstance.getResourceDefinition()).andReturn(hostResourceDefinition).anyTimes();\n    expect(hostResourceInstance.getQuery()).andReturn(hostComponentQuery).anyTimes();\n\n    expect(hostResourceDefinition.getType()).andReturn(Resource.Type.Host);\n    expect(hostComponentQuery.execute()).andReturn(hostComponentQueryResult);\n    expect(hostComponentQueryResult.getResultTree()).andReturn(hostComponentResultNode);\n\n    replay(m_controller, result, componentResourceInstance, componentResourceDefinition, hostResourceInstance, componentSchema, componentResource,\n        hostComponentQuery, hostComponentQueryResult);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, hostResourceInstance, componentSchema, componentResource,\n        hostComponentQuery, hostComponentQueryResult);\n\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertEquals(\"Component:1\", componentNode.getName());\n    assertEquals(componentResource, componentNode.getObject());\n    assertEquals(1, componentNode.getChildren().size());\n    assertSame(hostComponentResultNode, componentNode.getChild(\"host_components\"));\n    assertEquals(\"false\", hostComponentResultNode.getProperty(\"isCollection\"));\n  }","id":78198,"modified_method":"@Test\n  public void testExecute__Component_instance_noSpecifiedProps() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    ResourceInstance hostResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition hostResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    QueryImpl hostComponentQuery = createStrictMock(QueryImpl.class);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    Set<Resource> listResources = Collections.singleton(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, \"componentName\");\n\n    Map<String, ResourceInstance> mapChildren = new HashMap<String, ResourceInstance>();\n    mapChildren.put(\"host_components\", hostResourceInstance);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate predicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").and().\n        property(\"componentId\").equals(\"componentName\").toPredicate();\n\n    // expectations\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n    expect(componentResourceInstance.getSubResources()).andReturn(mapChildren).anyTimes();\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n\n    expect(hostResourceInstance.createCopy()).andReturn(hostResourceInstance).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n    expect(componentResource.getPropertyValue(componentPropertyId)).andReturn(\"keyVal\");\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\");\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\");\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).atLeastOnce();\n\n    expect(m_controller.getRawResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.<String>emptySet())),\n        eq(predicate))).andReturn(listResources);\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(listResources), eq(predicate))).andReturn(\n        listResources);\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n    Map<Resource.Type, String> mapResourceIdsSet = new HashMap<Resource.Type, String>(mapResourceIds);\n    mapResourceIdsSet.put(Resource.Type.Component, \"keyVal\");\n    hostResourceInstance.setIds(mapResourceIdsSet);\n    expect(hostResourceInstance.getResourceDefinition()).andReturn(hostResourceDefinition).anyTimes();\n    expect(hostResourceInstance.getQuery()).andReturn(hostComponentQuery).anyTimes();\n\n    expect(hostResourceDefinition.getType()).andReturn(Resource.Type.Host);\n\n//    expect(hostComponentQuery.getResourceInstance()).andReturn(hostResourceInstance);\n    expect(hostComponentQuery.getResourceType()).andReturn(Resource.Type.Host);\n    expect(hostComponentQuery.getPredicate()).andReturn(predicate);\n    expect(hostComponentQuery.createRequest()).andReturn(PropertyHelper.getReadRequest(Collections.<String>emptySet()));\n    expect(hostComponentQuery.getProviderResources()).andReturn(Collections.<Resource>emptySet());\n    expect(hostComponentQuery.getSubQueries()).andReturn(Collections.<QueryImpl, Resource>emptyMap());\n    expect(hostComponentQuery.getResourceIterable()).andReturn(Collections.<Resource>emptySet());\n    expect(hostComponentQuery.getResultName()).andReturn(\"host_components\");\n\n\n    replay(m_controller, result, componentResourceInstance, componentResourceDefinition, hostResourceInstance, componentSchema, componentResource,\n        hostComponentQuery);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, hostResourceInstance, componentSchema, componentResource,\n        hostComponentQuery);\n\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertEquals(\"Component:1\", componentNode.getName());\n    assertEquals(componentResource, componentNode.getObject());\n    assertEquals(1, componentNode.getChildren().size());\n    assertEquals(\"false\", componentNode.getChild(\"host_components\").getProperty(\"isCollection\"));\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecute__collection_nullInternalPredicate_nullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance clusterResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition clusterResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema clusterSchema = createNiceMock(Schema.class);\n    Resource clusterResource = createNiceMock(Resource.class);\n    String clusterPropertyId = \"clusterId\";\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    List<Resource> listResources = Collections.singletonList(clusterResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n\n    // expectations\n    expect(clusterResource.getType()).andReturn(Resource.Type.Cluster).anyTimes();\n\n    expect(clusterResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(clusterResourceInstance.getResourceDefinition()).andReturn(clusterResourceDefinition).anyTimes();\n\n    expect(clusterResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(clusterSchema).atLeastOnce();\n\n    expect(clusterSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(clusterPropertyId).atLeastOnce();\n\n    expect(result.getResultTree()).andReturn(tree).atLeastOnce();\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.singleton(clusterPropertyId))),\n        (Predicate) isNull())).andReturn(listResources);\n\n\n    expect(clusterResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource);\n\n    QueryImpl query = new TestQuery(clusterResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> clusterNode = tree.getChild(\"Cluster:1\");\n    assertSame(clusterResource, clusterNode.getObject());\n    assertEquals(0, clusterNode.getChildren().size());\n\n  }","id":78199,"modified_method":"@Test\n  public void testExecute__collection_nullInternalPredicate_nullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance clusterResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition clusterResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema clusterSchema = createNiceMock(Schema.class);\n    Resource clusterResource = createNiceMock(Resource.class);\n    String clusterPropertyId = \"clusterId\";\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    Set<Resource> resourceSet = Collections.singleton(clusterResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n\n    // expectations\n    expect(clusterResource.getType()).andReturn(Resource.Type.Cluster).anyTimes();\n\n    expect(clusterResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(clusterResourceInstance.getResourceDefinition()).andReturn(clusterResourceDefinition).anyTimes();\n\n    expect(clusterResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(clusterSchema).atLeastOnce();\n\n    expect(clusterSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(clusterPropertyId).atLeastOnce();\n\n    expect(result.getResultTree()).andReturn(tree).atLeastOnce();\n\n    expect(m_controller.getRawResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.singleton(clusterPropertyId))),\n        isNull(Predicate.class))).andReturn(resourceSet);\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(resourceSet), isNull(Predicate.class))).andReturn(\n        resourceSet);\n\n\n    expect(clusterResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource);\n\n    QueryImpl query = new TestQuery(clusterResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> clusterNode = tree.getChild(\"Cluster:1\");\n    assertSame(clusterResource, clusterNode.getObject());\n    assertEquals(0, clusterNode.getChildren().size());\n\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecute__collection_nonNullInternalPredicate_nonNullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    String servicePropertyId = \"serviceId\";\n    String clusterPropertyId = \"clusterId\";\n\n    Set<String> setPropertyIds = new HashSet<String>();\n    setPropertyIds.add(clusterPropertyId);\n    setPropertyIds.add(servicePropertyId);\n    setPropertyIds.add(componentPropertyId);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    List<Resource> listResources = Collections.singletonList(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, null);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate internalPredicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").toPredicate();\n\n    pb = new PredicateBuilder();\n    Predicate userPredicate = pb.property(\"foo\").equals(\"bar\").toPredicate();\n    // combine internal predicate and user predicate\n    //todo: for now, need to cast to BasePredicate\n    Predicate predicate = new AndPredicate(internalPredicate, userPredicate);\n\n    // expectations\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).atLeastOnce();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\").anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\").anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(setPropertyIds)),\n        eq(predicate))).andReturn(listResources);\n\n    expect(componentResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.setUserPredicate(userPredicate);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertSame(componentResource, componentNode.getObject());\n    assertEquals(0, componentNode.getChildren().size());\n  }","id":78200,"modified_method":"@Test\n  public void testExecute__collection_nonNullInternalPredicate_nonNullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    String servicePropertyId = \"serviceId\";\n    String clusterPropertyId = \"clusterId\";\n\n    Set<String> setPropertyIds = new HashSet<String>();\n    setPropertyIds.add(clusterPropertyId);\n    setPropertyIds.add(servicePropertyId);\n    setPropertyIds.add(componentPropertyId);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    Set<Resource> resourceSet = Collections.singleton(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, null);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate internalPredicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").toPredicate();\n\n    pb = new PredicateBuilder();\n    Predicate userPredicate = pb.property(\"foo\").equals(\"bar\").toPredicate();\n    // combine internal predicate and user predicate\n    //todo: for now, need to cast to BasePredicate\n    Predicate predicate = new AndPredicate(internalPredicate, userPredicate);\n\n    // expectations\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).atLeastOnce();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\").anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\").anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n//    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(setPropertyIds)),\n//        eq(predicate))).andReturn(resourceSet);\n\n    expect(m_controller.getRawResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(setPropertyIds)),\n        eq(predicate))).andReturn(resourceSet);\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(resourceSet), eq(predicate))).andReturn(\n        resourceSet);\n\n    expect(componentResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.setUserPredicate(userPredicate);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertSame(componentResource, componentNode.getObject());\n    assertEquals(0, componentNode.getChildren().size());\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecute__Component_collection_noSpecifiedProps() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    String servicePropertyId = \"serviceId\";\n    String clusterPropertyId = \"clusterId\";\n\n    Set<String> setPropertyIds = new HashSet<String>();\n    setPropertyIds.add(clusterPropertyId);\n    setPropertyIds.add(servicePropertyId);\n    setPropertyIds.add(componentPropertyId);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    List<Resource> listResources = Collections.singletonList(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, null);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate predicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").toPredicate();\n\n    // expectations\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\").anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\").anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(setPropertyIds)),\n        eq(predicate))).andReturn(listResources);\n\n    expect(componentResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result,componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertSame(componentResource, componentNode.getObject());\n    assertEquals(0, componentNode.getChildren().size());\n  }","id":78201,"modified_method":"@Test\n  public void testExecute__Component_collection_noSpecifiedProps() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance componentResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition componentResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema componentSchema = createNiceMock(Schema.class);\n    Resource componentResource = createNiceMock(Resource.class);\n    String componentPropertyId = \"componentId\";\n    String servicePropertyId = \"serviceId\";\n    String clusterPropertyId = \"clusterId\";\n\n    Set<String> setPropertyIds = new HashSet<String>();\n    setPropertyIds.add(clusterPropertyId);\n    setPropertyIds.add(servicePropertyId);\n    setPropertyIds.add(componentPropertyId);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    Set<Resource> resourceSet = Collections.singleton(componentResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n    mapResourceIds.put(Resource.Type.Cluster, \"clusterName\");\n    mapResourceIds.put(Resource.Type.Service, \"serviceName\");\n    mapResourceIds.put(Resource.Type.Component, null);\n\n    PredicateBuilder pb = new PredicateBuilder();\n    Predicate predicate = pb.property(\"clusterId\").equals(\"clusterName\").and().\n        property(\"serviceId\").equals(\"serviceName\").toPredicate();\n\n    // expectations\n    expect(componentResource.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(componentResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(componentResourceInstance.getResourceDefinition()).andReturn(componentResourceDefinition).anyTimes();\n\n    expect(componentResourceDefinition.getType()).andReturn(Resource.Type.Component).anyTimes();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(componentSchema).anyTimes();\n\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(componentPropertyId).anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Cluster)).andReturn(\"clusterId\").anyTimes();\n    expect(componentSchema.getKeyPropertyId(Resource.Type.Service)).andReturn(\"serviceId\").anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n\n    expect(m_controller.getRawResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(setPropertyIds)),\n        eq(predicate))).andReturn(resourceSet);\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(resourceSet), eq(predicate))).andReturn(\n        resourceSet);\n\n    expect(componentResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result,componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    QueryImpl query = new TestQuery(componentResourceInstance, result);\n    query.execute();\n\n    verify(m_controller, result, componentResourceInstance, componentResourceDefinition, componentSchema, componentResource);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> componentNode = tree.getChild(\"Component:1\");\n    assertSame(componentResource, componentNode.getObject());\n    assertEquals(0, componentNode.getChildren().size());\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testExecute__collection_nullInternalPredicate_nonNullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance clusterResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition clusterResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema clusterSchema = createNiceMock(Schema.class);\n    Resource clusterResource = createNiceMock(Resource.class);\n    String clusterPropertyId = \"clusterId\";\n    Predicate userPredicate = createNiceMock(Predicate.class);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    List<Resource> listResources = Collections.singletonList(clusterResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n\n    // expectations\n    expect(clusterResource.getType()).andReturn(Resource.Type.Cluster).anyTimes();\n\n    expect(clusterResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(clusterResourceInstance.getResourceDefinition()).andReturn(clusterResourceDefinition).anyTimes();\n\n    expect(clusterResourceDefinition.getType()).andReturn(Resource.Type.Component).atLeastOnce();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(clusterSchema).anyTimes();\n    expect(clusterSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(clusterPropertyId).anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.singleton(clusterPropertyId))),\n        eq(userPredicate))).andReturn(listResources);\n\n    expect(clusterResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result,clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource, userPredicate);\n\n    QueryImpl query = new TestQuery(clusterResourceInstance, result);\n    query.setUserPredicate(userPredicate);\n    query.execute();\n\n    verify(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource, userPredicate);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> clusterNode = tree.getChild(\"Cluster:1\");\n    assertSame(clusterResource, clusterNode.getObject());\n    assertEquals(0, clusterNode.getChildren().size());\n  }","id":78202,"modified_method":"@Test\n  public void testExecute__collection_nullInternalPredicate_nonNullUserPredicate() throws Exception {\n    Result result = createNiceMock(Result.class);\n    ResourceInstance clusterResourceInstance = createNiceMock(ResourceInstance.class);\n    ResourceDefinition clusterResourceDefinition = createNiceMock(ResourceDefinition.class);\n    Schema clusterSchema = createNiceMock(Schema.class);\n    Resource clusterResource = createNiceMock(Resource.class);\n    String clusterPropertyId = \"clusterId\";\n    Predicate userPredicate = createNiceMock(Predicate.class);\n\n    TreeNode<Resource> tree = new TreeNodeImpl<Resource>(null, null, null);\n    Set<Resource> resourceSet = Collections.singleton(clusterResource);\n\n    Map<Resource.Type, String> mapResourceIds = new HashMap<Resource.Type, String>();\n\n    // expectations\n    expect(clusterResource.getType()).andReturn(Resource.Type.Cluster).anyTimes();\n\n    expect(clusterResourceInstance.getIds()).andReturn(mapResourceIds).anyTimes();\n    expect(clusterResourceInstance.getResourceDefinition()).andReturn(clusterResourceDefinition).anyTimes();\n\n    expect(clusterResourceDefinition.getType()).andReturn(Resource.Type.Component).atLeastOnce();\n\n    expect(m_controller.getSchema(Resource.Type.Component)).andReturn(clusterSchema).anyTimes();\n    expect(clusterSchema.getKeyPropertyId(Resource.Type.Component)).andReturn(clusterPropertyId).anyTimes();\n\n    expect(result.getResultTree()).andReturn(tree).anyTimes();\n\n//    expect(m_controller.getResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.singleton(clusterPropertyId))),\n//        eq(userPredicate))).andReturn(resourceSet);\n\n    expect(m_controller.getRawResources(eq(Resource.Type.Component), eq(PropertyHelper.getReadRequest(Collections.singleton(clusterPropertyId))),\n        eq(userPredicate))).andReturn(resourceSet);\n\n    expect(m_controller.getResources(eq(Resource.Type.Component), eq(resourceSet), eq(userPredicate))).andReturn(\n        resourceSet);\n\n    expect(clusterResourceInstance.getSubResources()).andReturn(Collections.<String, ResourceInstance>emptyMap()).anyTimes();\n\n    replay(m_controller, result,clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource, userPredicate);\n\n    QueryImpl query = new TestQuery(clusterResourceInstance, result);\n    query.setUserPredicate(userPredicate);\n    query.execute();\n\n    verify(m_controller, result, clusterResourceInstance, clusterResourceDefinition, clusterSchema, clusterResource, userPredicate);\n\n    assertEquals(\"true\", tree.getProperty(\"isCollection\"));\n    assertEquals(1, tree.getChildren().size());\n    TreeNode<Resource> clusterNode = tree.getChild(\"Cluster:1\");\n    assertSame(clusterResource, clusterNode.getObject());\n    assertEquals(0, clusterNode.getChildren().size());\n  }","commit_id":"3b78da641f0d863d552afb7ff3c5224c3b2577e7","url":"https://github.com/apache/ambari"},{"original_method":"/**\n     * Populate the associated resources by making the rrd request.\n     *\n     * @return a collection of populated resources\n     *\n     * @throws SystemException if unable to populate the resources\n     */\n    public Collection<Resource> populateResources() throws SystemException {\n\n      //Get full url with parameters\n      String specWithParams = getSpec(clusterName, clusterSet, hostSet, metrics.keySet(), temporalInfo);\n      \n      //URL\n      String spec = null;\n      //Parameters\n      String params = null;\n      \n      String[] tokens = specWithParams.split(\"\\\\?\", 2);\n\n      try {\n        spec = tokens[0];\n        params = tokens[1];\n      } catch (ArrayIndexOutOfBoundsException e) {\n        LOG.info(e.toString());\n      }\n      \n\n      BufferedReader reader = null;\n      try {\n        \n        //Check if host is live\n        if (!hostProvider.isGangliaCollectorHostLive(clusterName)) {\n          LOG.info(\"Ganglia host is not live\");\n          return Collections.emptySet();\n        }\n\n        //Check if Ganglia server component is live\n        if (!hostProvider.isGangliaCollectorComponentLive(clusterName)) {\n          LOG.info(\"Ganglia server component is not live\");\n          return Collections.emptySet();\n        }\n\n        reader = new BufferedReader(new InputStreamReader(\n            getStreamProvider().readFrom(spec, \"POST\", params)));\n\n        String feedStart = reader.readLine();\n        if (feedStart == null || feedStart.isEmpty()) {\n          LOG.info(\"Empty feed while getting ganglia metrics for spec => \"+\n            spec);\n          return Collections.emptySet();\n        }\n        int startTime = convertToNumber(feedStart).intValue();\n\n        String dsName = reader.readLine();\n        if (dsName == null || dsName.isEmpty()) {\n          LOG.info(\"Feed without body while reading ganglia metrics for spec \" +\n            \"=> \" + spec);\n          return Collections.emptySet();\n        }\n\n        while(!\"[~EOF]\".equals(dsName)) {\n          GangliaMetric metric = new GangliaMetric();\n          List<GangliaMetric.TemporalMetric> listTemporalMetrics =\n              new ArrayList<GangliaMetric.TemporalMetric>();\n\n          metric.setDs_name(dsName);\n          metric.setCluster_name(reader.readLine());\n          metric.setHost_name(reader.readLine());\n          metric.setMetric_name(reader.readLine());\n\n          String timeStr = reader.readLine();\n          String stepStr = reader.readLine();\n          if (timeStr == null || timeStr.isEmpty() || stepStr == null\n              || stepStr.isEmpty()) {\n            LOG.info(\"Unexpected end of stream reached while getting ganglia \" +\n                \"metrics for spec => \" + spec);\n            return Collections.emptySet();\n          }\n          int time = convertToNumber(timeStr).intValue();\n          int step = convertToNumber(stepStr).intValue();\n\n          String val     = reader.readLine();\n          String lastVal = null;\n\n          while(val!=null && !\"[~EOM]\".equals(val)) {\n            if (val.startsWith(\"[~r]\")) {\n              Integer repeat = Integer.valueOf(val.substring(4)) - 1;\n              for (int i = 0; i < repeat; ++i) {\n                if (! \"[~n]\".equals(lastVal)) {\n                  GangliaMetric.TemporalMetric tm = new GangliaMetric.TemporalMetric(lastVal, time);\n                  if (tm.isValid()) listTemporalMetrics.add(tm);\n                }\n                time += step;\n              }\n            } else {\n              if (! \"[~n]\".equals(val)) {\n                GangliaMetric.TemporalMetric tm = new GangliaMetric.TemporalMetric(val, time);\n                if (tm.isValid()) listTemporalMetrics.add(tm);\n              }\n              time += step;\n            }\n            lastVal = val;\n            val = reader.readLine();\n          }\n\n          metric.setDatapointsFromList(listTemporalMetrics);\n\n          ResourceKey key = new ResourceKey(metric.getHost_name(), metric.getCluster_name());\n          Set<Resource> resourceSet = resources.get(key);\n          if (resourceSet != null) {\n            for (Resource resource : resourceSet) {\n              populateResource(resource, metric);\n            }\n          }\n\n          dsName = reader.readLine();\n          if (dsName == null || dsName.isEmpty()) {\n            LOG.info(\"Unexpected end of stream reached while getting ganglia \" +\n              \"metrics for spec => \" + spec);\n            return Collections.emptySet();\n          }\n        }\n        String feedEnd = reader.readLine();\n        if (feedEnd == null || feedEnd.isEmpty()) {\n          LOG.info(\"Error reading end of feed while getting ganglia metrics \" +\n            \"for spec => \" + spec);\n        } else {\n\n          int endTime = convertToNumber(feedEnd).intValue();\n          int totalTime = endTime - startTime;\n          if (LOG.isInfoEnabled() && totalTime > POPULATION_TIME_UPPER_LIMIT) {\n            LOG.info(\"Ganglia resource population time: \" + totalTime);\n          }\n        }\n      } catch (IOException e) {\n        if (LOG.isErrorEnabled()) {\n          LOG.error(\"Caught exception getting Ganglia metrics : spec=\" + spec, e);\n        }\n      } finally {\n        if (reader != null) {\n          try {\n            reader.close();\n          } catch (IOException e) {\n            if (LOG.isWarnEnabled()) {\n              LOG.warn(\"Unable to close http input steam : spec=\" + spec, e);\n            }\n          }\n        }\n      }\n      //todo: filter out resources and return keepers\n      return Collections.emptySet();\n    }","id":78203,"modified_method":"/**\n     * Populate the associated resources by making the rrd request.\n     *\n     * @return a collection of populated resources\n     *\n     * @throws org.apache.ambari.server.controller.spi.SystemException if unable to populate the resources\n     */\n    public Collection<Resource> populateResources() throws SystemException {\n\n      //Get full url with parameters\n      String specWithParams = getSpec(clusterName, clusterSet, hostSet, metrics.keySet(), temporalInfo);\n      \n      //URL\n      String spec = null;\n      //Parameters\n      String params = null;\n      \n      String[] tokens = questionMarkPattern.split(specWithParams, 2);\n\n      try {\n        spec = tokens[0];\n        params = tokens[1];\n      } catch (ArrayIndexOutOfBoundsException e) {\n        LOG.info(e.toString());\n      }\n      \n\n      BufferedReader reader = null;\n      try {\n        \n        //Check if host is live\n        if (!hostProvider.isGangliaCollectorHostLive(clusterName)) {\n          LOG.info(\"Ganglia host is not live\");\n          return Collections.emptySet();\n        }\n\n        //Check if Ganglia server component is live\n        if (!hostProvider.isGangliaCollectorComponentLive(clusterName)) {\n          LOG.info(\"Ganglia server component is not live\");\n          return Collections.emptySet();\n        }\n\n        reader = new BufferedReader(new InputStreamReader(\n            getStreamProvider().readFrom(spec, \"POST\", params)));\n\n        String feedStart = reader.readLine();\n        if (feedStart == null || feedStart.isEmpty()) {\n          LOG.info(\"Empty feed while getting ganglia metrics for spec => \"+\n            spec);\n          return Collections.emptySet();\n        }\n        int startTime = convertToNumber(feedStart).intValue();\n\n        String dsName = reader.readLine();\n        if (dsName == null || dsName.isEmpty()) {\n          LOG.info(\"Feed without body while reading ganglia metrics for spec \" +\n            \"=> \" + spec);\n          return Collections.emptySet();\n        }\n\n        while(!\"[~EOF]\".equals(dsName)) {\n          GangliaMetric metric = new GangliaMetric();\n          List<GangliaMetric.TemporalMetric> listTemporalMetrics =\n              new ArrayList<GangliaMetric.TemporalMetric>();\n\n          metric.setDs_name(dsName);\n          metric.setCluster_name(reader.readLine());\n          metric.setHost_name(reader.readLine());\n          metric.setMetric_name(reader.readLine());\n\n          String timeStr = reader.readLine();\n          String stepStr = reader.readLine();\n          if (timeStr == null || timeStr.isEmpty() || stepStr == null\n              || stepStr.isEmpty()) {\n            LOG.info(\"Unexpected end of stream reached while getting ganglia \" +\n                \"metrics for spec => \" + spec);\n            return Collections.emptySet();\n          }\n          int time = convertToNumber(timeStr).intValue();\n          int step = convertToNumber(stepStr).intValue();\n\n          String val     = reader.readLine();\n          String lastVal = null;\n\n          while(val!=null && !\"[~EOM]\".equals(val)) {\n            if (val.startsWith(\"[~r]\")) {\n              Integer repeat = Integer.valueOf(val.substring(4)) - 1;\n              for (int i = 0; i < repeat; ++i) {\n                if (! \"[~n]\".equals(lastVal)) {\n                  GangliaMetric.TemporalMetric tm = new GangliaMetric.TemporalMetric(lastVal, time);\n                  if (tm.isValid()) listTemporalMetrics.add(tm);\n                }\n                time += step;\n              }\n            } else {\n              if (! \"[~n]\".equals(val)) {\n                GangliaMetric.TemporalMetric tm = new GangliaMetric.TemporalMetric(val, time);\n                if (tm.isValid()) listTemporalMetrics.add(tm);\n              }\n              time += step;\n            }\n            lastVal = val;\n            val = reader.readLine();\n          }\n\n          metric.setDatapointsFromList(listTemporalMetrics);\n\n          ResourceKey key = new ResourceKey(metric.getHost_name(), metric.getCluster_name());\n          Set<Resource> resourceSet = resources.get(key);\n          if (resourceSet != null) {\n            for (Resource resource : resourceSet) {\n              populateResource(resource, metric);\n            }\n          }\n\n          dsName = reader.readLine();\n          if (dsName == null || dsName.isEmpty()) {\n            LOG.info(\"Unexpected end of stream reached while getting ganglia \" +\n              \"metrics for spec => \" + spec);\n            return Collections.emptySet();\n          }\n        }\n        String feedEnd = reader.readLine();\n        if (feedEnd == null || feedEnd.isEmpty()) {\n          LOG.info(\"Error reading end of feed while getting ganglia metrics \" +\n            \"for spec => \" + spec);\n        } else {\n\n          int endTime = convertToNumber(feedEnd).intValue();\n          int totalTime = endTime - startTime;\n          if (LOG.isInfoEnabled() && totalTime > POPULATION_TIME_UPPER_LIMIT) {\n            LOG.info(\"Ganglia resource population time: \" + totalTime);\n          }\n        }\n      } catch (IOException e) {\n        if (LOG.isErrorEnabled()) {\n          LOG.error(\"Caught exception getting Ganglia metrics : spec=\" + spec, e);\n        }\n      } finally {\n        if (reader != null) {\n          try {\n            reader.close();\n          } catch (IOException e) {\n            if (LOG.isWarnEnabled()) {\n              LOG.warn(\"Unable to close http input steam : spec=\" + spec, e);\n            }\n          }\n        }\n      }\n      //todo: filter out resources and return keepers\n      return Collections.emptySet();\n    }","commit_id":"e74fc95b838c0a9e024a32cab9495c1dc6c90e4e","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Get the spec to locate the Ganglia stream from the given\n   * request info.\n   *\n   * @param clusterName   the cluster name\n   * @param clusterSet    the set of ganglia cluster names\n   * @param hostSet       the set of host names\n   * @param metricSet     the set of metric names\n   * @param temporalInfo  the temporal information\n   *\n   * @return the spec, like http://example.com/path?param1=val1&paramn=valn\n   *\n   * @throws SystemException if unable to get the Ganglia Collector host name\n   */\n  private String getSpec(String clusterName,\n                         Set<String> clusterSet,\n                         Set<String> hostSet,\n                         Set<String> metricSet,\n                         TemporalInfo temporalInfo) throws SystemException {\n    \n    String clusters = getSetString(clusterSet, -1);\n    String hosts = getSetString(hostSet, -1);\n    String metrics = getSetString(metricSet, -1);\n    \n    URIBuilder uriBuilder = new URIBuilder();\n\n    if (configuration.isGangliaSSL()) {\n      uriBuilder.setScheme(\"https\");\n    } else {\n      uriBuilder.setScheme(\"http\");\n    }\n\n    uriBuilder.setHost(hostProvider.getGangliaCollectorHostName(clusterName));\n\n    uriBuilder.setPath(\"/cgi-bin/rrd.py\");\n    \n    uriBuilder.setParameter(\"c\", clusters);\n\n    if (hosts.length() > 0) {\n      uriBuilder.setParameter(\"h\", hosts);\n    }\n\n    if (metrics.length() > 0) {\n      uriBuilder.setParameter(\"m\", metrics);\n    } else {\n      // get all metrics\n      uriBuilder.setParameter(\"m\", \".*\");\n    }\n\n    if (temporalInfo != null) {\n      long startTime = temporalInfo.getStartTime();\n      if (startTime != -1) {\n        uriBuilder.setParameter(\"s\", String.valueOf(startTime));\n      }\n\n      long endTime = temporalInfo.getEndTime();\n      if (endTime != -1) {\n        uriBuilder.setParameter(\"e\", String.valueOf(endTime));\n      }\n\n      long step = temporalInfo.getStep();\n      if (step != -1) {\n        uriBuilder.setParameter(\"r\", String.valueOf(step));\n      }\n    } else {\n      uriBuilder.setParameter(\"e\", \"now\");\n      uriBuilder.setParameter(\"pt\", \"true\");\n    }\n\n    return uriBuilder.toString();\n  }","id":78204,"modified_method":"/**\n   * Get the spec to locate the Ganglia stream from the given\n   * request info.\n   *\n   * @param clusterName   the cluster name\n   * @param clusterSet    the set of ganglia cluster names\n   * @param hostSet       the set of host names\n   * @param metricSet     the set of metric names\n   * @param temporalInfo  the temporal information\n   *\n   * @return the spec, like http://example.com/path?param1=val1&paramn=valn\n   *\n   * @throws org.apache.ambari.server.controller.spi.SystemException if unable to get the Ganglia Collector host name\n   */\n  private String getSpec(String clusterName,\n                         Set<String> clusterSet,\n                         Set<String> hostSet,\n                         Set<String> metricSet,\n                         TemporalInfo temporalInfo) throws SystemException {\n    \n    String clusters = getSetString(clusterSet, -1);\n    String hosts = getSetString(hostSet, -1);\n    String metrics = getSetString(metricSet, -1);\n    \n    URIBuilder uriBuilder = new URIBuilder();\n\n    if (configuration.isGangliaSSL()) {\n      uriBuilder.setScheme(\"https\");\n    } else {\n      uriBuilder.setScheme(\"http\");\n    }\n\n    uriBuilder.setHost(hostProvider.getGangliaCollectorHostName(clusterName));\n\n    uriBuilder.setPath(\"/cgi-bin/rrd.py\");\n    \n    uriBuilder.setParameter(\"c\", clusters);\n\n    if (hosts.length() > 0) {\n      uriBuilder.setParameter(\"h\", hosts);\n    }\n\n    if (metrics.length() > 0) {\n      uriBuilder.setParameter(\"m\", metrics);\n    } else {\n      // get all metrics\n      uriBuilder.setParameter(\"m\", \".*\");\n    }\n\n    if (temporalInfo != null) {\n      long startTime = temporalInfo.getStartTime();\n      if (startTime != -1) {\n        uriBuilder.setParameter(\"s\", String.valueOf(startTime));\n      }\n\n      long endTime = temporalInfo.getEndTime();\n      if (endTime != -1) {\n        uriBuilder.setParameter(\"e\", String.valueOf(endTime));\n      }\n\n      long step = temporalInfo.getStep();\n      if (step != -1) {\n        uriBuilder.setParameter(\"r\", String.valueOf(step));\n      }\n    } else {\n      uriBuilder.setParameter(\"e\", \"now\");\n      uriBuilder.setParameter(\"pt\", \"true\");\n    }\n\n    return uriBuilder.toString();\n  }","commit_id":"e74fc95b838c0a9e024a32cab9495c1dc6c90e4e","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Get a comma delimited string from the given set of strings or\n   * an empty string if the size of the given set is greater than\n   * the given limit.\n   *\n   * @param set    the set of strings\n   * @param limit  the upper size limit for the list\n   *\n   * @return a comma delimited string of strings\n   */\n  private static String getSetString(Set<String> set, int limit) {\n    StringBuilder sb = new StringBuilder();\n\n    if (limit == -1 || set.size() <= limit) {\n      for (String cluster : set) {\n        if (sb.length() > 0) {\n          sb.append(\",\");\n        }\n        sb.append(cluster);\n      }\n    }\n    return sb.toString();\n  }","id":78205,"modified_method":"/**\n   * Get a comma delimited string from the given set of strings or\n   * an empty string if the size of the given set is greater than\n   * the given limit.\n   *\n   * @param set    the set of strings\n   * @param limit  the upper size limit for the list\n   *\n   * @return a comma delimited string of strings\n   */\n  private static String getSetString(Set<String> set, int limit) {\n    StringBuilder sb = new StringBuilder();\n\n    if (limit == -1 || set.size() <= limit) {\n      for (String cluster : set) {\n        if (sb.length() > 0) {\n          sb.append(',');\n        }\n        sb.append(cluster);\n      }\n    }\n    return sb.toString();\n  }","commit_id":"e74fc95b838c0a9e024a32cab9495c1dc6c90e4e","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Set<Resource> populateResources(Set<Resource> resources, Request request, Predicate predicate)\n      throws SystemException {\n\n    Set<String> ids = getRequestPropertyIds(request, predicate);\n    if (ids.isEmpty()) {\n      return resources;\n    }\n\n    Set<Resource> keepers = new HashSet<Resource>();\n\n    Map<String, Map<TemporalInfo, RRDRequest>> requestMap = getRRDRequests(resources, request, ids);\n\n    // For each cluster...\n    for (Map.Entry<String, Map<TemporalInfo, RRDRequest>> clusterEntry : requestMap.entrySet()) {\n      // For each request ...\n      for (RRDRequest rrdRequest : clusterEntry.getValue().values() ) {\n        //todo: property provider can reduce set of resources\n        keepers.addAll(rrdRequest.populateResources());\n      }\n    }\n    //todo: ignoring keepers returned by the provider\n    return resources;\n  }","id":78206,"modified_method":"@Override\n  public Set<Resource> populateResources(Set<Resource> resources, Request request, Predicate predicate)\n      throws SystemException {\n\n    Set<String> ids = getRequestPropertyIds(request, predicate);\n    if (ids.isEmpty()) {\n      return resources;\n    }\n\n    Map<String, Map<TemporalInfo, RRDRequest>> requestMap = getRRDRequests(resources, request, ids);\n\n    // For each cluster...\n    for (Map.Entry<String, Map<TemporalInfo, RRDRequest>> clusterEntry : requestMap.entrySet()) {\n      // For each request ...\n      for (RRDRequest rrdRequest : clusterEntry.getValue().values() ) {\n        //todo: property provider can reduce set of resources\n        rrdRequest.populateResources();\n      }\n    }\n    return resources;\n  }","commit_id":"e74fc95b838c0a9e024a32cab9495c1dc6c90e4e","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Populate a resource by obtaining the requested JMX properties.\n   *\n   * @param resource  the resource to be populated\n   * @param request   the request\n   * @param predicate the predicate\n   *\n   * @return the populated resource; null if the resource should NOT be part of the result set for the given predicate\n   */\n  private Resource populateResource(Resource resource, Request request, Predicate predicate)\n      throws SystemException {\n\n    Set<String> ids = getRequestPropertyIds(request, predicate);\n    Set<String> temporalIds = new HashSet<String>();\n\n    for (String id : ids) {\n      if (request.getTemporalInfo(id) != null) {\n        temporalIds.add(id);\n      }\n    }\n    ids.removeAll(temporalIds);\n\n    if (ids.isEmpty()) {\n      // no properties requested\n      return resource;\n    }\n\n    // Don't attempt to get the JMX properties if the resource is in an unhealthy state\n    if (statePropertyId != null) {\n      String state = (String) resource.getPropertyValue(statePropertyId);\n      if (state != null && !healthyStates.contains(state)) {\n        return resource;\n      }\n    }\n\n    String componentName = (String) resource.getPropertyValue(componentNamePropertyId);\n\n    if (getComponentMetrics().get(componentName) == null) {\n      // If there are no metrics defined for the given component then there is nothing to do.\n      return resource;\n    }\n\n    String clusterName = (String) resource.getPropertyValue(clusterNamePropertyId);\n\n    String port = getPort(clusterName, componentName);\n    if (port == null) {\n      LOG.warn(\"Unable to get JMX metrics.  No port value for \" + componentName);\n      return resource;\n    }\n\n    String hostName = getHost(resource, clusterName, componentName);\n    if (hostName == null) {\n      LOG.warn(\"Unable to get JMX metrics.  No host name for \" + componentName);\n      return resource;\n    }\n    \n    String protocol = getJMXProtocol(clusterName, componentName);\n    try {\n      InputStream in = streamProvider.readFrom(getSpec(protocol, hostName, port, componentName));\n\n      try {\n\n        if (null == componentName || !componentName.equals(STORM_REST_API)) {\n          getHadoopMetricValue(in, ids, resource, request);\n        } else {\n          getStormMetricValue(in, ids, resource, request);\n        }\n\n      } finally {\n        in.close();\n      }\n    } catch (IOException e) {\n      logException(e);\n    }\n    return resource;\n  }","id":78207,"modified_method":"/**\n   * Populate a resource by obtaining the requested JMX properties.\n   *\n   * @param resource  the resource to be populated\n   * @param request   the request\n   * @param predicate the predicate\n   *\n   * @return the populated resource; null if the resource should NOT be part of the result set for the given predicate\n   */\n  private Resource populateResource(Resource resource, Request request, Predicate predicate)\n      throws SystemException {\n\n    Set<String> ids = getRequestPropertyIds(request, predicate);\n    Set<String> temporalIds = new HashSet<String>();\n\n    for (String id : ids) {\n      if (request.getTemporalInfo(id) != null) {\n        temporalIds.add(id);\n      }\n    }\n    ids.removeAll(temporalIds);\n\n    if (ids.isEmpty()) {\n      // no properties requested\n      return resource;\n    }\n\n    // Don't attempt to get the JMX properties if the resource is in an unhealthy state\n    if (statePropertyId != null) {\n      String state = (String) resource.getPropertyValue(statePropertyId);\n      if (state != null && !healthyStates.contains(state)) {\n        return resource;\n      }\n    }\n\n    String componentName = (String) resource.getPropertyValue(componentNamePropertyId);\n\n    if (getComponentMetrics().get(componentName) == null) {\n      // If there are no metrics defined for the given component then there is nothing to do.\n      return resource;\n    }\n\n    String clusterName = (String) resource.getPropertyValue(clusterNamePropertyId);\n\n    String port = getPort(clusterName, componentName);\n    if (port == null) {\n      LOG.warn(\"Unable to get JMX metrics.  No port value for \" + componentName);\n      return resource;\n    }\n\n    String hostName = getHost(resource, clusterName, componentName);\n    if (hostName == null) {\n      LOG.warn(\"Unable to get JMX metrics.  No host name for \" + componentName);\n      return resource;\n    }\n    \n    String protocol = getJMXProtocol(clusterName, componentName);\n    try {\n      InputStream in = streamProvider.readFrom(getSpec(protocol, hostName, port, componentName));\n\n      try {\n\n        if (null == componentName || !componentName.equals(STORM_REST_API)) {\n          getHadoopMetricValue(in, ids, resource, request);\n        } else {\n          getStormMetricValue(in, ids, resource);\n        }\n\n      } finally {\n        in.close();\n      }\n    } catch (IOException e) {\n      logException(e);\n    }\n    return resource;\n  }","commit_id":"e74fc95b838c0a9e024a32cab9495c1dc6c90e4e","url":"https://github.com/apache/ambari"},{"original_method":"private String getJMXProtocol(String clusterName, String componentName) {\n    String protocol = jmxHostProvider.getJMXProtocol(clusterName, componentName);\n    return protocol;\n  }","id":78208,"modified_method":"private String getJMXProtocol(String clusterName, String componentName) {\n    return jmxHostProvider.getJMXProtocol(clusterName, componentName);\n  }","commit_id":"e74fc95b838c0a9e024a32cab9495c1dc6c90e4e","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * TODO: Refactor\n   * Storm-specific metrics fetching\n   */\n  private void getStormMetricValue(InputStream in, Set<String> ids,\n                                   Resource resource, Request request) throws IOException {\n    HashMap<String, Object> metricHolder = stormObjectReader.readValue(in);\n    for (String category : ids) {\n      Map<String, PropertyInfo> defProps = getComponentMetrics().get(STORM_REST_API);\n      for (String depProp : defProps.keySet()) {\n        if (depProp.startsWith(category)) {\n          PropertyInfo propInfo = defProps.get(depProp);\n          String propName = propInfo.getPropertyId();\n          Object propertyValue = metricHolder.get(propName);\n          String absId = PropertyHelper.getPropertyId(category, propName);\n          // TODO: Maybe cast to int\n          resource.setProperty(absId, propertyValue);\n        }\n      }\n    }\n  }","id":78209,"modified_method":"/**\n   * TODO: Refactor\n   * Storm-specific metrics fetching\n   */\n  private void getStormMetricValue(InputStream in, Set<String> ids,\n                                   Resource resource) throws IOException {\n    HashMap<String, Object> metricHolder = stormObjectReader.readValue(in);\n    for (String category : ids) {\n      Map<String, PropertyInfo> defProps = getComponentMetrics().get(STORM_REST_API);\n      for (Map.Entry<String, PropertyInfo> depEntry : defProps.entrySet()) {\n        if (depEntry.getKey().startsWith(category)) {\n          PropertyInfo propInfo = depEntry.getValue();\n          String propName = propInfo.getPropertyId();\n          Object propertyValue = metricHolder.get(propName);\n          String absId = PropertyHelper.getPropertyId(category, propName);\n          // TODO: Maybe cast to int\n          resource.setProperty(absId, propertyValue);\n        }\n      }\n    }\n  }","commit_id":"e74fc95b838c0a9e024a32cab9495c1dc6c90e4e","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Rethrow the given exception as a System exception and log the message.\n   *\n   * @param throwable  the caught exception\n   *\n   * @throws SystemException always around the given exception\n   */\n  private static void rethrowSystemException(Throwable throwable) throws SystemException {\n    String msg = logException(throwable);\n\n    if (throwable instanceof SystemException) {\n      throw (SystemException) throwable;\n    }\n    throw new SystemException (msg, throwable);\n  }","id":78210,"modified_method":"/**\n   * Rethrow the given exception as a System exception and log the message.\n   *\n   * @param throwable  the caught exception\n   *\n   * @throws org.apache.ambari.server.controller.spi.SystemException always around the given exception\n   */\n  private static void rethrowSystemException(Throwable throwable) throws SystemException {\n    String msg = logException(throwable);\n\n    if (throwable instanceof SystemException) {\n      throw (SystemException) throwable;\n    }\n    throw new SystemException (msg, throwable);\n  }","commit_id":"e74fc95b838c0a9e024a32cab9495c1dc6c90e4e","url":"https://github.com/apache/ambari"},{"original_method":"private void setResourceValue(Resource resource, Map<String, Map<String, Object>> categories, String propertyId,\n                                String category, String property, List<String> keyList) {\n    Map<String, Object> properties = categories.get(category);\n    if (property.contains(DOT_REPLACEMENT_CHAR)) {\n      property = property.replaceAll(DOT_REPLACEMENT_CHAR, \".\");\n    }\n    if (properties != null && properties.containsKey(property)) {\n      Object value = properties.get(property);\n      if (keyList.size() > 0 && value instanceof Map) {\n        Map<?, ?> map = (Map<?, ?>) value;\n        for (String key : keyList) {\n          value = map.get(key);\n          if (value instanceof Map) {\n            map = (Map<?, ?>) value;\n          }\n          else {\n            break;\n          }\n        }\n      }\n      resource.setProperty(propertyId, value);\n    }\n  }","id":78211,"modified_method":"private void setResourceValue(Resource resource, Map<String, Map<String, Object>> categories, String propertyId,\n                                String category, String property, List<String> keyList) {\n    Map<String, Object> properties = categories.get(category);\n    if (property.contains(DOT_REPLACEMENT_CHAR)) {\n      property = dotReplacementCharPattern.matcher(property).replaceAll(\".\");\n    }\n    if (properties != null && properties.containsKey(property)) {\n      Object value = properties.get(property);\n      if (keyList.size() > 0 && value instanceof Map) {\n        Map<?, ?> map = (Map<?, ?>) value;\n        for (String key : keyList) {\n          value = map.get(key);\n          if (value instanceof Map) {\n            map = (Map<?, ?>) value;\n          }\n          else {\n            break;\n          }\n        }\n      }\n      resource.setProperty(propertyId, value);\n    }\n  }","commit_id":"e74fc95b838c0a9e024a32cab9495c1dc6c90e4e","url":"https://github.com/apache/ambari"},{"original_method":"@Inject\n  public static void init(Injector injector) {\n    clusters = injector.getInstance(Clusters.class);\n    Configuration config = injector.getInstance(Configuration.class);\n    \n    String ignores = config.getProperty(Configuration.NAGIOS_IGNORE_FOR_SERVICES_KEY);\n    if (null != ignores) {\n      for (String str : ignores.split(\",\"))\n        IGNORABLE_FOR_SERVICES.add(str);\n    }\n\n    ignores = config.getProperty(Configuration.NAGIOS_IGNORE_FOR_HOSTS_KEY);\n    if (null != ignores) {\n      for (String str : ignores.split(\",\"))\n        IGNORABLE_FOR_HOSTS.add(str);\n    }\n    \n  }","id":78212,"modified_method":"@Inject\n  public static void init(Injector injector) {\n    clusters = injector.getInstance(Clusters.class);\n    Configuration config = injector.getInstance(Configuration.class);\n    \n    String ignores = config.getProperty(Configuration.NAGIOS_IGNORE_FOR_SERVICES_KEY);\n    if (null != ignores) {\n      Collections.addAll(IGNORABLE_FOR_SERVICES, COMMA_PATTERN.split(ignores));\n    }\n\n    ignores = config.getProperty(Configuration.NAGIOS_IGNORE_FOR_HOSTS_KEY);\n    if (null != ignores) {\n      Collections.addAll(IGNORABLE_FOR_HOSTS, COMMA_PATTERN.split(ignores));\n    }\n    \n  }","commit_id":"e74fc95b838c0a9e024a32cab9495c1dc6c90e4e","url":"https://github.com/apache/ambari"},{"original_method":"public ClientFileInfo getClientFileInfo(int id) throws FileDoesNotExistException {\n    LOG.info(\"getClientFileInfo(\" + id + \")\");\n    synchronized (mRoot) {\n      Inode inode = mInodes.get(id);\n      if (inode == null) {\n        throw new FileDoesNotExistException(\"FileId \" + id + \" does not exist.\");\n      }\n      ClientFileInfo ret = new ClientFileInfo();\n      ret.id = inode.getId();\n      ret.name = inode.getName();\n      ret.path = getPath(inode);\n      ret.checkpointPath = \"\";\n      ret.sizeBytes = 0;\n      ret.creationTimeMs = inode.getCreationTimeMs();\n      ret.inMemory = false;\n      ret.ready = true;\n      if (inode.isFile()) {\n        ret.sizeBytes = ((InodeFile) inode).getLength();\n        ret.inMemory = ((InodeFile) inode).isInMemory();\n        ret.ready = ((InodeFile) inode).isReady();\n      }\n      ret.folder = inode.isDirectory();\n      ret.needPin = false;\n      ret.needCache = false;\n\n      if (inode.isFile()) {\n        InodeFile tInode = (InodeFile) inode;\n        ret.checkpointPath = tInode.getCheckpointPath();\n        ret.needPin = tInode.isPin();\n        ret.needCache = tInode.isCache();\n      }\n\n      LOG.info(\"getClientFileInfo(\" + id + \"): \"  + ret);\n      return ret;\n    }\n  }","id":78213,"modified_method":"public ClientFileInfo getClientFileInfo(int id) throws FileDoesNotExistException {\n    synchronized (mRoot) {\n      Inode inode = mInodes.get(id);\n      if (inode == null) {\n        throw new FileDoesNotExistException(\"FileId \" + id + \" does not exist.\");\n      }\n      ClientFileInfo ret = new ClientFileInfo();\n      ret.id = inode.getId();\n      ret.name = inode.getName();\n      ret.path = getPath(inode);\n      ret.checkpointPath = \"\";\n      ret.sizeBytes = 0;\n      ret.creationTimeMs = inode.getCreationTimeMs();\n      ret.inMemory = false;\n      ret.ready = true;\n      if (inode.isFile()) {\n        ret.sizeBytes = ((InodeFile) inode).getLength();\n        ret.inMemory = ((InodeFile) inode).isInMemory();\n        ret.ready = ((InodeFile) inode).isReady();\n      }\n      ret.folder = inode.isDirectory();\n      ret.needPin = false;\n      ret.needCache = false;\n\n      if (inode.isFile()) {\n        InodeFile tInode = (InodeFile) inode;\n        ret.checkpointPath = tInode.getCheckpointPath();\n        ret.needPin = tInode.isPin();\n        ret.needCache = tInode.isCache();\n      }\n\n      LOG.debug(\"getClientFileInfo(\" + id + \"): \"  + ret);\n      return ret;\n    }\n  }","commit_id":"307eaf9d643a8d39b274477189de3ec08b1e95ff","url":"https://github.com/amplab/tachyon"},{"original_method":"public int createRawTable(String path, int columns, List<Byte> metadata)\n      throws FileAlreadyExistException, InvalidPathException, TableColumnException {\n    String parameters = CommonUtils.parametersToString(path, columns);\n    LOG.info(\"user_createRawTable\" + parameters);\n\n    if (columns <= 0 || columns >= Config.MAX_COLUMNS) {\n      throw new TableColumnException(\"Column \" + columns + \" should between 0 to \" + \n          Config.MAX_COLUMNS);\n    }\n\n    int id = createFile(true, path, true, columns, metadata);\n\n    for (int k = 0; k < columns; k ++) {\n      createFile(path + Config.SEPARATOR + COL + k, true);\n    }\n\n    return id;\n  }","id":78214,"modified_method":"public int createRawTable(String path, int columns, List<Byte> metadata)\n      throws FileAlreadyExistException, InvalidPathException, TableColumnException {\n    LOG.info(\"createRawTable\" + CommonUtils.parametersToString(path, columns));\n\n    if (columns <= 0 || columns >= Config.MAX_COLUMNS) {\n      throw new TableColumnException(\"Column \" + columns + \" should between 0 to \" + \n          Config.MAX_COLUMNS);\n    }\n\n    int id = createFile(true, path, true, columns, metadata);\n\n    for (int k = 0; k < columns; k ++) {\n      createFile(path + Config.SEPARATOR + COL + k, true);\n    }\n\n    return id;\n  }","commit_id":"307eaf9d643a8d39b274477189de3ec08b1e95ff","url":"https://github.com/amplab/tachyon"},{"original_method":"public void cachedFile(long workerId, long workerUsedBytes, int fileId,\n      long fileSizeBytes) throws FileDoesNotExistException, SuspectedFileSizeException {\n    String parameters = CommonUtils.parametersToString(workerId, workerUsedBytes, fileId, \n        fileSizeBytes);\n    LOG.info(\"cachedFile\" + parameters);\n\n    WorkerInfo tWorkerInfo = null;\n    synchronized (mWorkers) {\n      tWorkerInfo = mWorkers.get(workerId);\n\n      if (tWorkerInfo == null) {\n        LOG.error(\"No worker: \" + workerId);\n        return;\n      }\n    }\n\n    tWorkerInfo.updateFile(true, fileId);\n    tWorkerInfo.updateUsedBytes(workerUsedBytes);\n    tWorkerInfo.updateLastUpdatedTimeMs();\n\n    synchronized (mRoot) {\n      Inode inode = mInodes.get(fileId);\n\n      if (inode == null) {\n        throw new FileDoesNotExistException(\"File \" + fileId + \" does not exist.\");\n      }\n      if (inode.isDirectory()) {\n        throw new FileDoesNotExistException(\"File \" + fileId + \" is a folder.\");\n      }\n\n      InodeFile tFile = (InodeFile) inode;\n      boolean needLog = false;\n\n      if (tFile.isReady()) {\n        if (tFile.getLength() != fileSizeBytes) {\n          throw new SuspectedFileSizeException(fileId + \". Original Size: \" +\n              tFile.getLength() + \". New Size: \" + fileSizeBytes);\n        }\n      } else {\n        tFile.setLength(fileSizeBytes);\n        needLog = true;\n      }\n      if (needLog) {\n        mMasterLogWriter.appendAndFlush(tFile);\n      }\n      InetSocketAddress address = tWorkerInfo.ADDRESS;\n      tFile.addLocation(workerId, new NetAddress(address.getHostName(), address.getPort()));\n    }\n  }","id":78215,"modified_method":"public void cachedFile(long workerId, long workerUsedBytes, int fileId,\n      long fileSizeBytes) throws FileDoesNotExistException, SuspectedFileSizeException {\n    LOG.info(\"cachedFile\" + CommonUtils.parametersToString(workerId, workerUsedBytes, fileId, \n        fileSizeBytes));\n\n    WorkerInfo tWorkerInfo = null;\n    synchronized (mWorkers) {\n      tWorkerInfo = mWorkers.get(workerId);\n\n      if (tWorkerInfo == null) {\n        LOG.error(\"No worker: \" + workerId);\n        return;\n      }\n    }\n\n    tWorkerInfo.updateFile(true, fileId);\n    tWorkerInfo.updateUsedBytes(workerUsedBytes);\n    tWorkerInfo.updateLastUpdatedTimeMs();\n\n    synchronized (mRoot) {\n      Inode inode = mInodes.get(fileId);\n\n      if (inode == null) {\n        throw new FileDoesNotExistException(\"File \" + fileId + \" does not exist.\");\n      }\n      if (inode.isDirectory()) {\n        throw new FileDoesNotExistException(\"File \" + fileId + \" is a folder.\");\n      }\n\n      InodeFile tFile = (InodeFile) inode;\n      boolean needLog = false;\n\n      if (tFile.isReady()) {\n        if (tFile.getLength() != fileSizeBytes) {\n          throw new SuspectedFileSizeException(fileId + \". Original Size: \" +\n              tFile.getLength() + \". New Size: \" + fileSizeBytes);\n        }\n      } else {\n        tFile.setLength(fileSizeBytes);\n        needLog = true;\n      }\n      if (needLog) {\n        mMasterLogWriter.appendAndFlush(tFile);\n      }\n      InetSocketAddress address = tWorkerInfo.ADDRESS;\n      tFile.addLocation(workerId, new NetAddress(address.getHostName(), address.getPort()));\n    }\n  }","commit_id":"307eaf9d643a8d39b274477189de3ec08b1e95ff","url":"https://github.com/amplab/tachyon"},{"original_method":"public void addCheckpoint(long workerId, int fileId, long fileSizeBytes,\n      String checkpointPath) throws FileDoesNotExistException, SuspectedFileSizeException {\n    String parameters = CommonUtils.parametersToString(workerId, fileId, fileSizeBytes,\n        checkpointPath);\n    LOG.info(\"addCheckpoint\" + parameters);\n\n    WorkerInfo tWorkerInfo = null;\n    synchronized (mWorkers) {\n      tWorkerInfo = mWorkers.get(workerId);\n\n      if (tWorkerInfo == null) {\n        LOG.error(\"No worker: \" + workerId);\n        return;\n      }\n    }\n\n    tWorkerInfo.updateLastUpdatedTimeMs();\n\n    synchronized (mRoot) {\n      Inode inode = mInodes.get(fileId);\n\n      if (inode == null) {\n        throw new FileDoesNotExistException(\"File \" + fileId + \" does not exist.\");\n      }\n      if (inode.isDirectory()) {\n        throw new FileDoesNotExistException(\"File \" + fileId + \" is a folder.\");\n      }\n\n      InodeFile tFile = (InodeFile) inode;\n      boolean needLog = false;\n\n      if (tFile.isReady()) {\n        if (tFile.getLength() != fileSizeBytes) {\n          throw new SuspectedFileSizeException(fileId + \". Original Size: \" +\n              tFile.getLength() + \". New Size: \" + fileSizeBytes);\n        }\n      } else {\n        tFile.setLength(fileSizeBytes);\n        needLog = true;\n      }\n      if (!tFile.hasCheckpointed()) {\n        tFile.setCheckpointPath(checkpointPath);\n        needLog = true;\n      }\n      if (needLog) {\n        mMasterLogWriter.appendAndFlush(tFile);\n      }\n    }\n  }","id":78216,"modified_method":"public void addCheckpoint(long workerId, int fileId, long fileSizeBytes,\n      String checkpointPath) throws FileDoesNotExistException, SuspectedFileSizeException {\n    LOG.info(\"addCheckpoint\" + CommonUtils.parametersToString(workerId, fileId, fileSizeBytes,\n        checkpointPath));\n\n    WorkerInfo tWorkerInfo = null;\n    synchronized (mWorkers) {\n      tWorkerInfo = mWorkers.get(workerId);\n\n      if (tWorkerInfo == null) {\n        LOG.error(\"No worker: \" + workerId);\n        return;\n      }\n    }\n\n    tWorkerInfo.updateLastUpdatedTimeMs();\n\n    synchronized (mRoot) {\n      Inode inode = mInodes.get(fileId);\n\n      if (inode == null) {\n        throw new FileDoesNotExistException(\"File \" + fileId + \" does not exist.\");\n      }\n      if (inode.isDirectory()) {\n        throw new FileDoesNotExistException(\"File \" + fileId + \" is a folder.\");\n      }\n\n      InodeFile tFile = (InodeFile) inode;\n      boolean needLog = false;\n\n      if (tFile.isReady()) {\n        if (tFile.getLength() != fileSizeBytes) {\n          throw new SuspectedFileSizeException(fileId + \". Original Size: \" +\n              tFile.getLength() + \". New Size: \" + fileSizeBytes);\n        }\n      } else {\n        tFile.setLength(fileSizeBytes);\n        needLog = true;\n      }\n      if (!tFile.hasCheckpointed()) {\n        tFile.setCheckpointPath(checkpointPath);\n        needLog = true;\n      }\n      if (needLog) {\n        mMasterLogWriter.appendAndFlush(tFile);\n      }\n    }\n  }","commit_id":"307eaf9d643a8d39b274477189de3ec08b1e95ff","url":"https://github.com/amplab/tachyon"},{"original_method":"public int getFileId(String filePath) throws InvalidPathException {\n    LOG.info(\"getFileId(\" + filePath + \")\");\n    Inode inode = getInode(filePath);\n    int ret = -1;\n    if (inode != null) {\n      ret = inode.getId();\n    }\n    LOG.info(\"getFileId(\" + filePath + \"): \" + ret);\n    return ret;\n  }","id":78217,"modified_method":"public int getFileId(String filePath) throws InvalidPathException {\n    LOG.debug(\"getFileId(\" + filePath + \")\");\n    Inode inode = getInode(filePath);\n    int ret = -1;\n    if (inode != null) {\n      ret = inode.getId();\n    }\n    LOG.debug(\"getFileId(\" + filePath + \"): \" + ret);\n    return ret;\n  }","commit_id":"307eaf9d643a8d39b274477189de3ec08b1e95ff","url":"https://github.com/amplab/tachyon"},{"original_method":"public int createFile(boolean recursive, String path, boolean directory, int columns,\n      List<Byte> metadata) throws FileAlreadyExistException, InvalidPathException {\n    String parameters = CommonUtils.parametersToString(path);\n    LOG.info(\"createFile\" + parameters);\n\n    String[] pathNames = getPathNames(path);\n\n    synchronized (mRoot) {\n      Inode inode = getInode(pathNames);\n      if (inode != null) {\n        Log.info(\"FileAlreadyExistException: File \" + path + \" already exist.\");\n        throw new FileAlreadyExistException(\"File \" + path + \" already exist.\");\n      }\n\n      String name = pathNames[pathNames.length - 1];\n      String folderPath = null;\n      if (path.length() - name.length() == 1) {\n        folderPath = path.substring(0, path.length() - name.length()); \n      } else {\n        folderPath = path.substring(0, path.length() - name.length() - 1);\n      }\n      inode = getInode(folderPath);\n      if (inode == null) {\n        int succeed = 0;\n        if (recursive) {\n          succeed = createFile(true, folderPath, true, -1, null);\n        }\n        if (!recursive || succeed <= 0) {\n          Log.info(\"InvalidPathException: File \" + path + \" creation failed. Folder \"\n              + folderPath + \" does not exist.\");\n          throw new InvalidPathException(\"InvalidPathException: File \" + path + \" creation \" +\n              \"failed. Folder \" + folderPath + \" does not exist.\");\n        } else {\n          inode = mInodes.get(succeed);\n        }\n      } else if (inode.isFile()) {\n        Log.info(\"InvalidPathException: File \" + path + \" creation failed. \"\n            + folderPath + \" is a file.\");\n        throw new InvalidPathException(\"File \" + path + \" creation failed. \"\n            + folderPath + \" is a file\");\n      }\n\n      Inode ret = null;\n\n      if (directory) {\n        if (columns != -1) {\n          ret = new InodeRawTable(name, mInodeCounter.incrementAndGet(), inode.getId(),\n              columns, metadata);\n        } else {\n          ret = new InodeFolder(name, mInodeCounter.incrementAndGet(), inode.getId());\n        }\n      } else {\n        ret = new InodeFile(name, mInodeCounter.incrementAndGet(), inode.getId());\n        String curPath = getPath(ret);\n        if (mPinList.inList(curPath)) {\n          synchronized (mIdPinList) {\n            mIdPinList.add(ret.getId());\n            ((InodeFile) ret).setPin(true);\n          }\n        }\n        if (mWhiteList.inList(curPath)) {\n          ((InodeFile) ret).setCache(true);\n        }\n      }\n\n      mInodes.put(ret.getId(), ret);\n      ((InodeFolder) inode).addChild(ret.getId());\n\n      // TODO this two appends should be atomic;\n      mMasterLogWriter.appendAndFlush(inode);\n      mMasterLogWriter.appendAndFlush(ret);\n\n      LOG.info(\"createFile: File Created: \" + ret + \" parent: \" + inode);\n      return ret.getId();\n    }\n  }","id":78218,"modified_method":"public int createFile(boolean recursive, String path, boolean directory, int columns,\n      List<Byte> metadata) throws FileAlreadyExistException, InvalidPathException {\n    LOG.debug(\"createFile\" + CommonUtils.parametersToString(path));\n\n    String[] pathNames = getPathNames(path);\n\n    synchronized (mRoot) {\n      Inode inode = getInode(pathNames);\n      if (inode != null) {\n        Log.info(\"FileAlreadyExistException: File \" + path + \" already exist.\");\n        throw new FileAlreadyExistException(\"File \" + path + \" already exist.\");\n      }\n\n      String name = pathNames[pathNames.length - 1];\n      String folderPath = null;\n      if (path.length() - name.length() == 1) {\n        folderPath = path.substring(0, path.length() - name.length()); \n      } else {\n        folderPath = path.substring(0, path.length() - name.length() - 1);\n      }\n      inode = getInode(folderPath);\n      if (inode == null) {\n        int succeed = 0;\n        if (recursive) {\n          succeed = createFile(true, folderPath, true, -1, null);\n        }\n        if (!recursive || succeed <= 0) {\n          Log.info(\"InvalidPathException: File \" + path + \" creation failed. Folder \"\n              + folderPath + \" does not exist.\");\n          throw new InvalidPathException(\"InvalidPathException: File \" + path + \" creation \" +\n              \"failed. Folder \" + folderPath + \" does not exist.\");\n        } else {\n          inode = mInodes.get(succeed);\n        }\n      } else if (inode.isFile()) {\n        Log.info(\"InvalidPathException: File \" + path + \" creation failed. \"\n            + folderPath + \" is a file.\");\n        throw new InvalidPathException(\"File \" + path + \" creation failed. \"\n            + folderPath + \" is a file\");\n      }\n\n      Inode ret = null;\n\n      if (directory) {\n        if (columns != -1) {\n          ret = new InodeRawTable(name, mInodeCounter.incrementAndGet(), inode.getId(),\n              columns, metadata);\n        } else {\n          ret = new InodeFolder(name, mInodeCounter.incrementAndGet(), inode.getId());\n        }\n      } else {\n        ret = new InodeFile(name, mInodeCounter.incrementAndGet(), inode.getId());\n        String curPath = getPath(ret);\n        if (mPinList.inList(curPath)) {\n          synchronized (mIdPinList) {\n            mIdPinList.add(ret.getId());\n            ((InodeFile) ret).setPin(true);\n          }\n        }\n        if (mWhiteList.inList(curPath)) {\n          ((InodeFile) ret).setCache(true);\n        }\n      }\n\n      mInodes.put(ret.getId(), ret);\n      ((InodeFolder) inode).addChild(ret.getId());\n\n      // TODO this two appends should be atomic;\n      mMasterLogWriter.appendAndFlush(inode);\n      mMasterLogWriter.appendAndFlush(ret);\n\n      LOG.debug(\"createFile: File Created: \" + ret + \" parent: \" + inode);\n      return ret.getId();\n    }\n  }","commit_id":"307eaf9d643a8d39b274477189de3ec08b1e95ff","url":"https://github.com/amplab/tachyon"},{"original_method":"public List<NetAddress> getFileLocations(int fileId) throws FileDoesNotExistException {\n    LOG.info(\"getFileLocations: \" + fileId);\n    synchronized (mRoot) {\n      Inode inode = mInodes.get(fileId);\n      if (inode == null || inode.isDirectory()) {\n        throw new FileDoesNotExistException(\"FileId \" + fileId + \" does not exist.\");\n      }\n      LOG.info(\"getFileLocations: \" + fileId + \" good return\");\n      return ((InodeFile) inode).getLocations();\n    }\n  }","id":78219,"modified_method":"public List<NetAddress> getFileLocations(int fileId) throws FileDoesNotExistException {\n    synchronized (mRoot) {\n      Inode inode = mInodes.get(fileId);\n      if (inode == null || inode.isDirectory()) {\n        throw new FileDoesNotExistException(\"FileId \" + fileId + \" does not exist.\");\n      }\n      LOG.debug(\"getFileLocations: \" + fileId + ((InodeFile) inode).getLocations());\n      return ((InodeFile) inode).getLocations();\n    }\n  }","commit_id":"307eaf9d643a8d39b274477189de3ec08b1e95ff","url":"https://github.com/amplab/tachyon"},{"original_method":"@Handler\n   void onActivateConsole()\n   {\n      view_.bringToFront();\n      view_.focus();\n   }","id":78220,"modified_method":"@Handler\n   void onActivateConsole()\n   {\n      WindowEx.get().focus();\n      view_.bringToFront();\n      view_.focus();\n   }","commit_id":"41dbd9c7e48f714ab6b31e9a23dcdbe52a9ea4b2","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected SecondaryToolbar createSecondaryToolbar()\n   {\n      SecondaryToolbar toolbar = new SecondaryToolbar() ;\n      title_ = new Label() ;\n      title_.setStylePrimaryName(\"rstudio-StrongLabel\") ;\n      title_.setWordWrap(false);\n      title_.getElement().getStyle().setCursor(Style.Cursor.DEFAULT);\n      title_.getElement().getStyle().setOverflow(Overflow.HIDDEN);\n      toolbar.addLeftWidget(title_) ;\n      final Image image = new Image(ThemeResources.INSTANCE.mediumDropDownArrow());\n      image.getElement().getStyle().setMarginLeft(2, Unit.PX);\n      image.getElement().getStyle().setMarginRight(8, Unit.PX);\n      image.getElement().getStyle().setMarginBottom(2, Unit.PX);\n      toolbar.addLeftWidget(image);\n\n      final ClickHandler clickHandler = new ClickHandler()\n      {\n         public void onClick(ClickEvent event)\n         {\n            final PopupPanel pp = history_.getMenu();\n            pp.showRelativeTo(title_);\n            pp.getElement().getStyle().setPaddingTop(3, Style.Unit.PX);\n         }\n      };\n      title_.addClickHandler(clickHandler);\n      image.addClickHandler(clickHandler);\n      \n      if (BrowseCap.INSTANCE.hasWindowFind())\n      {\n         final FindTextBox findTextBox = new FindTextBox(\"Find in Topic\");\n         findTextBox.setOverrideWidth(90);\n         toolbar.addLeftWidget(findTextBox);\n         final SmallButton findButton = new SmallButton(\"Find\");\n         findButton.setVisible(false);\n         findButton.addClickHandler(new ClickHandler() {\n   \n            @Override\n            public void onClick(ClickEvent event)\n            {\n               // prevent two enter keys in rapid succession from \n               // maximizing or minimizing the help tab\n               event.stopPropagation();\n               event.preventDefault();\n               \n               // do the find\n               findInTopic(findTextBox.getValue().trim(), findTextBox);\n            }\n            \n         });\n         toolbar.addLeftWidget(findButton);      \n         \n         \n         findTextBox.addKeyDownHandler(new KeyDownHandler() {\n            @Override\n            public void onKeyDown(KeyDownEvent event)\n            {\n               // enter key triggers a find\n               if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER)\n               {\n                  event.preventDefault();\n                  event.stopPropagation();\n                  findButton.click();\n                  findTextBox.focus();\n               }\n               else if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE)\n               {\n                  findTextBox.setValue(\"\");\n                  findButton.setVisible(false);\n               }\n               else\n               {\n                  // other keys trigger visibility chagne of find button\n                  Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n                     @Override\n                     public void execute()\n                     {\n                        findButton.setVisible(\n                                   findTextBox.getValue().trim().length() > 0);\n                        \n                     }    \n                  });\n               }       \n            }\n            \n         });\n      }\n\n      return toolbar ;\n   }","id":78221,"modified_method":"@Override\n   protected SecondaryToolbar createSecondaryToolbar()\n   {\n      SecondaryToolbar toolbar = new SecondaryToolbar() ;\n      title_ = new Label() ;\n      title_.setStylePrimaryName(\"rstudio-StrongLabel\") ;\n      title_.setWordWrap(false);\n      title_.getElement().getStyle().setCursor(Style.Cursor.DEFAULT);\n      title_.getElement().getStyle().setOverflow(Overflow.HIDDEN);\n      toolbar.addLeftWidget(title_) ;\n      final Image image = new Image(ThemeResources.INSTANCE.mediumDropDownArrow());\n      image.getElement().getStyle().setMarginLeft(2, Unit.PX);\n      image.getElement().getStyle().setMarginRight(8, Unit.PX);\n      image.getElement().getStyle().setMarginBottom(2, Unit.PX);\n      toolbar.addLeftWidget(image);\n\n      final ClickHandler clickHandler = new ClickHandler()\n      {\n         public void onClick(ClickEvent event)\n         {\n            final PopupPanel pp = history_.getMenu();\n            pp.showRelativeTo(title_);\n            pp.getElement().getStyle().setPaddingTop(3, Style.Unit.PX);\n         }\n      };\n      title_.addClickHandler(clickHandler);\n      image.addClickHandler(clickHandler);\n      \n      if (isFindSupported())\n      {\n         final SmallButton btnNext = new SmallButton(\"&gt;\", true);\n         btnNext.setTitle(\"Find next (Enter)\");\n         btnNext.setVisible(false);\n         btnNext.addClickHandler(new ClickHandler() {\n            @Override\n            public void onClick(ClickEvent event)\n            {\n               findNext();\n            }  \n         });\n         \n         final SmallButton btnPrev = new SmallButton(\"&lt;\", true);\n         btnPrev.setTitle(\"Find previous\");\n         btnPrev.setVisible(false);\n         btnPrev.addClickHandler(new ClickHandler() {\n            @Override\n            public void onClick(ClickEvent event)\n            {\n               findPrev();\n            }  \n         });\n         \n         \n         findTextBox_ = new FindTextBox(\"Find in Topic\");\n         findTextBox_.setOverrideWidth(90);\n         toolbar.addLeftWidget(findTextBox_);\n         findTextBox_.addKeyUpHandler(new KeyUpHandler() { \n            \n            @Override\n            public void onKeyUp(KeyUpEvent event)\n            {     \n               WindowEx contentWindow = getContentWindow();\n               if (contentWindow != null)\n               {\n                  // escape or tab means exit find mode and put focus \n                  // into the main content window\n                  if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE ||\n                      event.getNativeKeyCode() == KeyCodes.KEY_TAB)\n                  {\n                     event.preventDefault();\n                     event.stopPropagation();\n                     if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE)\n                        clearTerm();\n                     contentWindow.focus();\n                  }\n                  else\n                  {\n                     // prevent two enter keys in rapid succession from \n                     // minimizing or maximizing the help pane\n                     if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER)\n                     {\n                        event.preventDefault();\n                        event.stopPropagation();\n                     }\n                      \n                     // check for term\n                     String term = findTextBox_.getValue().trim();\n                     \n                     // if there is a term then search for it\n                     if (term.length() > 0)\n                     { \n                        // make buttons visible\n                        setButtonVisibility(true);\n                        \n                        // perform the find (check for incremental)\n                        if (isIncrementalFindSupported())\n                        {\n                           boolean incremental = \n                            !event.isAnyModifierKeyDown() &&\n                            (event.getNativeKeyCode() != KeyCodes.KEY_ENTER);   \n                           \n                           performFind(term, true, incremental);\n                        }\n                        else\n                        {\n                           if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER)\n                              performFind(term, true, false);\n                        }\n                     }\n                     \n                     // no term means clear term and remove selection\n                     else\n                     {\n                        if (isIncrementalFindSupported())\n                        {\n                           clearTerm();\n                           contentWindow.removeSelection();\n                        }\n                     }\n                  }\n               }\n            }\n            \n            private void clearTerm()\n            {\n               findTextBox_.setValue(\"\");\n               setButtonVisibility(false);\n            }\n            \n            private void setButtonVisibility(final boolean visible)\n            {\n               Scheduler.get().scheduleDeferred(new ScheduledCommand() {\n                  @Override\n                  public void execute()\n                  {\n                     btnNext.setVisible(visible);\n                     btnPrev.setVisible(visible);\n                  }\n               });\n            }\n         });\n       \n         findTextBox_.addKeyDownHandler(new KeyDownHandler() {\n\n            @Override\n            public void onKeyDown(KeyDownEvent event)\n            { \n               // we handle these directly so prevent the browser\n               // from handling them\n               if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE ||\n                   event.getNativeKeyCode() == KeyCodes.KEY_TAB ||\n                   event.getNativeKeyCode() == KeyCodes.KEY_ENTER)\n               {\n                  event.preventDefault();\n                  event.stopPropagation();\n               }\n            }\n            \n         });\n         \n         if (isIncrementalFindSupported())\n         {\n            btnPrev.getElement().getStyle().setMarginRight(3, Unit.PX);\n            toolbar.addLeftWidget(btnPrev);\n            toolbar.addLeftWidget(btnNext);\n         }\n       \n      }\n\n      return toolbar ;\n   }","commit_id":"41dbd9c7e48f714ab6b31e9a23dcdbe52a9ea4b2","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected void onLoad()\n   {\n      super.onLoad() ;\n\n      if (!initialized_)\n      {\n         initialized_ = true;\n\n         initHelpNavigateCallback() ;\n\n         Scheduler.get().scheduleDeferred(new ScheduledCommand()\n         {\n            public void execute()\n            {\n               manageTitleLabelMaxSize();\n            }\n         });\n      }\n   }","id":78222,"modified_method":"@Override\n   protected void onLoad()\n   {\n      super.onLoad() ;\n\n      if (!initialized_)\n      {\n         initialized_ = true;\n\n         initHelpCallbacks() ;\n\n         Scheduler.get().scheduleDeferred(new ScheduledCommand()\n         {\n            public void execute()\n            {\n               manageTitleLabelMaxSize();\n            }\n         });\n      }\n   }","commit_id":"41dbd9c7e48f714ab6b31e9a23dcdbe52a9ea4b2","url":"https://github.com/rstudio/rstudio"},{"original_method":"public final native void initHelpNavigateCallback() /*-{\n      function addEventHandler(subject, eventName, handler) {\n         if (subject.addEventListener) {\n            subject.addEventListener(eventName, handler, false);\n         }\n         else {\n            subject.attachEvent(eventName, handler);\n         }\n      }\n\n      var thiz = this ;\n      $wnd.helpNavigated = function(document, win) {\n         thiz.@org.rstudio.studio.client.workbench.views.help.HelpPane::helpNavigated(Lcom/google/gwt/dom/client/Document;)(document);\n         addEventHandler(win, \"unload\", function () {\n            thiz.@org.rstudio.studio.client.workbench.views.help.HelpPane::unload()();\n         });\n      } ;\n      $wnd.helpNavigate = function(url) {\n         thiz.@org.rstudio.studio.client.workbench.views.help.HelpPane::showHelp(Ljava/lang/String;)(url);\n      } ;\n   }-*/;","id":78223,"modified_method":"public final native void initHelpCallbacks() /*-{\n      function addEventHandler(subject, eventName, handler) {\n         if (subject.addEventListener) {\n            subject.addEventListener(eventName, handler, false);\n         }\n         else {\n            subject.attachEvent(eventName, handler);\n         }\n      }\n\n      var thiz = this ;\n      $wnd.helpNavigated = function(document, win) {\n         thiz.@org.rstudio.studio.client.workbench.views.help.HelpPane::helpNavigated(Lcom/google/gwt/dom/client/Document;)(document);\n         addEventHandler(win, \"unload\", function () {\n            thiz.@org.rstudio.studio.client.workbench.views.help.HelpPane::unload()();\n         });\n      } ;\n      $wnd.helpNavigate = function(url) {\n         thiz.@org.rstudio.studio.client.workbench.views.help.HelpPane::showHelp(Ljava/lang/String;)(url);\n      } ;\n      \n      $wnd.helpKeydown = function(e) {\n         thiz.@org.rstudio.studio.client.workbench.views.help.HelpPane::handleKeyDown(Lcom/google/gwt/dom/client/NativeEvent;)(e);\n      } ;\n   }-*/;","commit_id":"41dbd9c7e48f714ab6b31e9a23dcdbe52a9ea4b2","url":"https://github.com/rstudio/rstudio"},{"original_method":"protected NativeKeyDownEvent(NativeEvent event)\n   {\n      event_ = event;\n   }","id":78224,"modified_method":"public NativeKeyDownEvent(NativeEvent event)\n   {\n      event_ = event;\n   }","commit_id":"41dbd9c7e48f714ab6b31e9a23dcdbe52a9ea4b2","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void activateTab(Tab tab)\n   {\n      tabToPanel_.get(tab).selectTab(tabToIndex_.get(tab));\n   }","id":78225,"modified_method":"public void activateTab(Tab tab)\n   {\n      WindowEx.get().focus();\n      tabToPanel_.get(tab).selectTab(tabToIndex_.get(tab));\n   }","commit_id":"41dbd9c7e48f714ab6b31e9a23dcdbe52a9ea4b2","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void selectTab(int tabIndex)\n   {\n      if (tabPanel_.getSelectedIndex() == tabIndex)\n         return;\n\n      // deal with migrating from n+1 to n tabs, and with -1 values\n      int safeIndex = Math.min(Math.max(0, tabIndex), tabs_.size() - 1);\n      \n      tabPanel_.selectTab(safeIndex);\n   }","id":78226,"modified_method":"public void selectTab(int tabIndex)\n   {\n      if (tabPanel_.getSelectedIndex() == tabIndex)\n      {\n         // if it's already selected then we still want to fire the\n         // onBeforeSelected and onSelected methods (so that actions \n         // like auto-focus are always taken)\n         int selected = getSelectedIndex();\n         if (selected != -1)\n         {\n            WorkbenchTab tab = tabs_.get(selected);\n            tab.onBeforeSelected();\n            tab.onSelected();\n         }\n        \n         return;\n      }\n      \n      // deal with migrating from n+1 to n tabs, and with -1 values\n      int safeIndex = Math.min(Math.max(0, tabIndex), tabs_.size() - 1);\n      \n      tabPanel_.selectTab(safeIndex);\n   }","commit_id":"41dbd9c7e48f714ab6b31e9a23dcdbe52a9ea4b2","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public Files(Display view, \n                EventBus eventBus,\n                FilesServerOperations server,\n                RemoteFileSystemContext fileSystemContext,\n                GlobalDisplay globalDisplay,\n                Session session,\n                Commands commands,\n                Provider<FilesCopy> pFilesCopy,\n                Provider<FilesUpload> pFilesUpload,\n                FileTypeRegistry fileTypeRegistry,\n                ConsoleDispatcher consoleDispatcher,\n                WorkbenchContext workbenchContext)\n   {\n      super(view);\n      view_ = view ;\n      view_.setObserver(new DisplayObserver());\n      fileTypeRegistry_ = fileTypeRegistry;\n      consoleDispatcher_ = consoleDispatcher;\n      workbenchContext_ = workbenchContext;\n      \n      eventBus_ = eventBus;\n      server_ = server;\n      fileSystemContext_ = fileSystemContext;\n      globalDisplay_ = globalDisplay ;\n      session_ = session;\n      pFilesCopy_ = pFilesCopy;\n      pFilesUpload_ = pFilesUpload;\n\n      ((Binder)GWT.create(Binder.class)).bind(commands, this);\n\n      \n      eventBus_.addHandler(FileChangeEvent.TYPE, this);\n\n      initSession();\n   }","id":78227,"modified_method":"@Inject\n   public Files(Display view, \n                EventBus eventBus,\n                FilesServerOperations server,\n                RemoteFileSystemContext fileSystemContext,\n                GlobalDisplay globalDisplay,\n                Session session,\n                Commands commands,\n                Provider<FilesCopy> pFilesCopy,\n                Provider<FilesUpload> pFilesUpload,\n                Provider<FileExport> pFileExport,\n                FileTypeRegistry fileTypeRegistry,\n                ConsoleDispatcher consoleDispatcher,\n                WorkbenchContext workbenchContext)\n   {\n      super(view);\n      view_ = view ;\n      view_.setObserver(new DisplayObserver());\n      fileTypeRegistry_ = fileTypeRegistry;\n      consoleDispatcher_ = consoleDispatcher;\n      workbenchContext_ = workbenchContext;\n      \n      eventBus_ = eventBus;\n      server_ = server;\n      fileSystemContext_ = fileSystemContext;\n      globalDisplay_ = globalDisplay ;\n      session_ = session;\n      pFilesCopy_ = pFilesCopy;\n      pFilesUpload_ = pFilesUpload;\n      pFileExport_ = pFileExport;\n\n      ((Binder)GWT.create(Binder.class)).bind(commands, this);\n\n      \n      eventBus_.addHandler(FileChangeEvent.TYPE, this);\n\n      initSession();\n   }","commit_id":"b28e8a4b81040ec147c4e8fb11569a7c78a0680d","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Handler\n   void onExportFiles()\n   {\n      // get currently selected files\n      final ArrayList<FileSystemItem> selectedFiles = view_.getSelectedFiles();\n      \n      // validation: some selection exists\n      if  (selectedFiles.size() == 0)\n         return ;\n         \n      // case: single file which is not a folder \n      if ((selectedFiles.size()) == 1 && !selectedFiles.get(0).isDirectory())\n      {\n         final FileSystemItem file = selectedFiles.get(0);\n         \n         view_.showFileExport(file.getStem(),\n                              file.getExtension(),\n                              new ProgressOperationWithInput<String>(){\n            public void execute(String name, ProgressIndicator progress)\n            {\n               // execute the download (open in a new window)\n               globalDisplay_.openWindow(server_.getFileExportUrl(name, file));\n               \n            }\n         });\n      }\n      \n      // case: folder or multiple files\n      else\n      {\n         // determine the default zip file name based on the selection\n         String defaultArchiveName;\n         if (selectedFiles.size() == 1)\n            defaultArchiveName = selectedFiles.get(0).getStem();\n         else\n            defaultArchiveName = \"rstudio-export\";\n         \n         // prompt user\n         final String ZIP = \".zip\";\n         view_.showFileExport(defaultArchiveName,\n                              ZIP,\n                              new ProgressOperationWithInput<String>(){\n            \n            public void execute(String archiveName, ProgressIndicator progress)\n            {\n               // force zip extension in case the user deleted it\n               if (!archiveName.endsWith(ZIP))\n                  archiveName += ZIP;\n               \n               // build list of filenames for current selection\n               ArrayList<String> filenames = new ArrayList<String>();\n               for (FileSystemItem file : selectedFiles)\n                  filenames.add(file.getName());\n               \n               // execute the download (open in a new window)\n               globalDisplay_.openWindow(server_.getFileExportUrl(archiveName, \n                                                                  currentPath_, \n                                                                  filenames));\n            }\n         });\n      }\n   }","id":78228,"modified_method":"@Handler\n   void onExportFiles()\n   {     \n      pFileExport_.get().export(\"Export Files\",\n                                \"selected file(s)\",\n                                currentPath_, \n                                view_.getSelectedFiles());\n   }","commit_id":"b28e8a4b81040ec147c4e8fb11569a7c78a0680d","url":"https://github.com/rstudio/rstudio"},{"original_method":"private Toolbar createToolbar(Commands commands)\n   {\n      Toolbar toolbar = new Toolbar();\n      \n      toolbar.addLeftWidget(new ToolbarLabel(\"Preview: \"));\n      fileLabel_ = new ToolbarLabel();\n      fileLabel_.addStyleName(ThemeStyles.INSTANCE.subtitle());\n      fileLabel_.getElement().getStyle().setMarginRight(7, Unit.PX);\n      toolbar.addLeftWidget(fileLabel_);\n      \n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands.openHtmlExternal().createToolbarButton());\n      \n      saveHtmlPreviewAsSeparator_ = toolbar.addLeftSeparator();\n      saveHtmlPreviewAs_ = commands.saveHtmlPreviewAs().createToolbarButton();\n      toolbar.addLeftWidget(saveHtmlPreviewAs_);\n      \n      \n      findTextBox_ = new FindTextBox(\"Find\");\n      findTextBox_.setIconVisible(true);\n      findTextBox_.setOverrideWidth(120);\n      findTextBox_.getElement().getStyle().setMarginRight(6, Unit.PX);\n      toolbar.addRightWidget(findTextBox_);\n      \n      findTextBox_.addKeyDownHandler(new KeyDownHandler() {\n         @Override\n         public void onKeyDown(KeyDownEvent event)\n         {\n            // enter key triggers a find\n            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER)\n            {\n               event.preventDefault();\n               event.stopPropagation();\n               findInTopic(findTextBox_.getValue().trim(), findTextBox_);\n               findTextBox_.focus();\n            }\n            else if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE)\n            {\n               findTextBox_.setValue(\"\");\n            }       \n         }\n         \n         private void findInTopic(String term, CanFocus findInputSource)\n         {\n            // get content window\n            WindowEx contentWindow = previewFrame_.getWindow();\n            if (contentWindow == null)\n               return;\n                \n            if (!contentWindow.find(term, false, false, true, false))\n            {\n               RStudioGinjector.INSTANCE.getGlobalDisplay().showMessage(\n                     MessageDialog.INFO,\n                     \"Find in Page\", \n                     \"No occurences found\",\n                     findInputSource);\n            }     \n         }\n         \n      });\n      \n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(\n                     commands.refreshHtmlPreview().createToolbarButton());\n      \n      \n      return toolbar;\n   }","id":78229,"modified_method":"private Toolbar createToolbar(Commands commands)\n   {\n      Toolbar toolbar = new Toolbar();\n      \n      toolbar.addLeftWidget(new ToolbarLabel(\"Preview: \"));\n      fileLabel_ = new ToolbarLabel();\n      fileLabel_.addStyleName(ThemeStyles.INSTANCE.subtitle());\n      fileLabel_.getElement().getStyle().setMarginRight(7, Unit.PX);\n      toolbar.addLeftWidget(fileLabel_);\n      \n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands.openHtmlExternal().createToolbarButton());\n      \n      saveHtmlPreviewAsSeparator_ = toolbar.addLeftSeparator();\n      if (Desktop.isDesktop())\n      { \n         saveHtmlPreviewAs_ = commands.saveHtmlPreviewAs().createToolbarButton();\n         toolbar.addLeftWidget(saveHtmlPreviewAs_);\n      }\n      else\n      {\n         ToolbarPopupMenu menu = new ToolbarPopupMenu();\n         menu.addItem(commands.saveHtmlPreviewAsLocalFile().createMenuItem(false));\n         menu.addItem(commands.saveHtmlPreviewAs().createMenuItem(false));\n         \n         saveHtmlPreviewAs_ = toolbar.addLeftWidget(new ToolbarButton(\n               \"Save As\", \n               commands.saveSourceDoc().getImageResource(),\n               menu));\n         \n         \n      }\n      \n      \n      findTextBox_ = new FindTextBox(\"Find\");\n      findTextBox_.setIconVisible(true);\n      findTextBox_.setOverrideWidth(120);\n      findTextBox_.getElement().getStyle().setMarginRight(6, Unit.PX);\n      toolbar.addRightWidget(findTextBox_);\n      \n      findTextBox_.addKeyDownHandler(new KeyDownHandler() {\n         @Override\n         public void onKeyDown(KeyDownEvent event)\n         {\n            // enter key triggers a find\n            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER)\n            {\n               event.preventDefault();\n               event.stopPropagation();\n               findInTopic(findTextBox_.getValue().trim(), findTextBox_);\n               findTextBox_.focus();\n            }\n            else if (event.getNativeKeyCode() == KeyCodes.KEY_ESCAPE)\n            {\n               findTextBox_.setValue(\"\");\n            }       \n         }\n         \n         private void findInTopic(String term, CanFocus findInputSource)\n         {\n            // get content window\n            WindowEx contentWindow = previewFrame_.getWindow();\n            if (contentWindow == null)\n               return;\n                \n            if (!contentWindow.find(term, false, false, true, false))\n            {\n               RStudioGinjector.INSTANCE.getGlobalDisplay().showMessage(\n                     MessageDialog.INFO,\n                     \"Find in Page\", \n                     \"No occurences found\",\n                     findInputSource);\n            }     \n         }\n         \n      });\n      \n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(\n                     commands.refreshHtmlPreview().createToolbarButton());\n      \n      \n      return toolbar;\n   }","commit_id":"b28e8a4b81040ec147c4e8fb11569a7c78a0680d","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public HTMLPreviewPresenter(Display view,\n                               Binder binder,\n                               final Commands commands,\n                               GlobalDisplay globalDisplay,\n                               EventBus eventBus,\n                               Satellite satellite,\n                               Session session,\n                               FileDialogs fileDialogs,\n                               RemoteFileSystemContext fileSystemContext,\n                               HTMLPreviewServerOperations server)\n   {\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      server_ = server;\n      session_ = session;\n      fileDialogs_ = fileDialogs;\n      fileSystemContext_ = fileSystemContext;\n      \n      binder.bind(commands, this);\n         \n      // map Ctrl-R to our internal refresh handler\n      Event.addNativePreviewHandler(new NativePreviewHandler() {\n         @Override\n         public void onPreviewNativeEvent(NativePreviewEvent event)\n         {\n            if (event.getTypeInt() == Event.ONKEYDOWN)\n            {\n               NativeEvent ne = event.getNativeEvent();\n               int mod = KeyboardShortcut.getModifierValue(ne);\n               if ((mod == KeyboardShortcut.META || \n                   (mod == KeyboardShortcut.CTRL && !BrowseCap.hasMetaKey()))\n                   && ne.getKeyCode() == 'R')\n               {\n                  ne.preventDefault();\n                  ne.stopPropagation();\n                  commands.refreshHtmlPreview().execute();\n               }\n            }\n         }\n      });\n      \n      satellite.addCloseHandler(new CloseHandler<Satellite>() {\n         @Override\n         public void onClose(CloseEvent<Satellite> event)\n         {\n            if (previewRunning_)\n               terminateRunningPreview();\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewStartedEvent.TYPE, \n                          new HTMLPreviewStartedEvent.Handler()\n      {\n         @Override\n         public void onHTMLPreviewStarted(HTMLPreviewStartedEvent event)\n         {\n            previewRunning_ = true;\n            view_.showProgress(\"Knitting...\");\n            view_.addProgressClickHandler(new ClickHandler() {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  if (previewRunning_)\n                     terminateRunningPreview();\n                  else\n                     view_.closeProgress();\n               }\n               \n            });\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewOutputEvent.TYPE, \n                          new HTMLPreviewOutputEvent.Handler()\n      {\n         @Override\n         public void onHTMLPreviewOutput(HTMLPreviewOutputEvent event)\n         {\n            view_.showProgressOutput(event.getOutput());\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewCompletedEvent.TYPE, \n                          new HTMLPreviewCompletedEvent.Handler()\n      { \n         @Override\n         public void onHTMLPreviewCompleted(HTMLPreviewCompletedEvent event)\n         {\n            previewRunning_ = false;\n            \n            HTMLPreviewResult result = event.getResult();\n            if (result.getSucceeded())\n            {\n               lastSuccessfulPreview_ = result;\n               view_.closeProgress();\n               view_.showPreview(\n                  server_.getApplicationURL(result.getPreviewURL()),\n                  result.getHtmlFile(),\n                  result.getEnableSaveAs(),\n                  result.getEnableScripts());\n            }\n            else\n            {\n               view_.setProgressCaption(\"Preview failed\");\n               view_.stopProgress();\n            }\n         }\n      });\n      \n      new StringStateValue(\n            MODULE_HTML_PREVIEW,\n            KEY_SAVEAS_DIR,\n            ClientState.PERSISTENT,\n            session_.getSessionInfo().getClientState())\n      {\n         @Override\n         protected void onInit(String value)\n         {\n            savePreviewDir_ = value;\n         }\n\n         @Override\n         protected String getValue()\n         {\n            return savePreviewDir_;\n         }\n      };\n   }","id":78230,"modified_method":"@Inject\n   public HTMLPreviewPresenter(Display view,\n                               Binder binder,\n                               final Commands commands,\n                               GlobalDisplay globalDisplay,\n                               EventBus eventBus,\n                               Satellite satellite,\n                               Session session,\n                               FileDialogs fileDialogs,\n                               RemoteFileSystemContext fileSystemContext,\n                               HTMLPreviewServerOperations server,\n                               Provider<FileExport> pFileExport)\n   {\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      server_ = server;\n      session_ = session;\n      fileDialogs_ = fileDialogs;\n      fileSystemContext_ = fileSystemContext;\n      pFileExport_ = pFileExport;\n      \n      binder.bind(commands, this);\n         \n      // map Ctrl-R to our internal refresh handler\n      Event.addNativePreviewHandler(new NativePreviewHandler() {\n         @Override\n         public void onPreviewNativeEvent(NativePreviewEvent event)\n         {\n            if (event.getTypeInt() == Event.ONKEYDOWN)\n            {\n               NativeEvent ne = event.getNativeEvent();\n               int mod = KeyboardShortcut.getModifierValue(ne);\n               if ((mod == KeyboardShortcut.META || \n                   (mod == KeyboardShortcut.CTRL && !BrowseCap.hasMetaKey()))\n                   && ne.getKeyCode() == 'R')\n               {\n                  ne.preventDefault();\n                  ne.stopPropagation();\n                  commands.refreshHtmlPreview().execute();\n               }\n            }\n         }\n      });\n      \n      satellite.addCloseHandler(new CloseHandler<Satellite>() {\n         @Override\n         public void onClose(CloseEvent<Satellite> event)\n         {\n            if (previewRunning_)\n               terminateRunningPreview();\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewStartedEvent.TYPE, \n                          new HTMLPreviewStartedEvent.Handler()\n      {\n         @Override\n         public void onHTMLPreviewStarted(HTMLPreviewStartedEvent event)\n         {\n            previewRunning_ = true;\n            view_.showProgress(\"Knitting...\");\n            view_.addProgressClickHandler(new ClickHandler() {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  if (previewRunning_)\n                     terminateRunningPreview();\n                  else\n                     view_.closeProgress();\n               }\n               \n            });\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewOutputEvent.TYPE, \n                          new HTMLPreviewOutputEvent.Handler()\n      {\n         @Override\n         public void onHTMLPreviewOutput(HTMLPreviewOutputEvent event)\n         {\n            view_.showProgressOutput(event.getOutput());\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewCompletedEvent.TYPE, \n                          new HTMLPreviewCompletedEvent.Handler()\n      { \n         @Override\n         public void onHTMLPreviewCompleted(HTMLPreviewCompletedEvent event)\n         {\n            previewRunning_ = false;\n            \n            HTMLPreviewResult result = event.getResult();\n            if (result.getSucceeded())\n            {\n               lastSuccessfulPreview_ = result;\n               view_.closeProgress();\n               view_.showPreview(\n                  server_.getApplicationURL(result.getPreviewURL()),\n                  result.getHtmlFile(),\n                  result.getEnableSaveAs(),\n                  result.getEnableScripts());\n            }\n            else\n            {\n               view_.setProgressCaption(\"Preview failed\");\n               view_.stopProgress();\n            }\n         }\n      });\n      \n      new StringStateValue(\n            MODULE_HTML_PREVIEW,\n            KEY_SAVEAS_DIR,\n            ClientState.PERSISTENT,\n            session_.getSessionInfo().getClientState())\n      {\n         @Override\n         protected void onInit(String value)\n         {\n            savePreviewDir_ = value;\n         }\n\n         @Override\n         protected String getValue()\n         {\n            return savePreviewDir_;\n         }\n      };\n   }","commit_id":"b28e8a4b81040ec147c4e8fb11569a7c78a0680d","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n      \n      // always include build all\n      toolbar.addLeftWidget(commands_.buildAll().createToolbarButton());\n      \n      // makefiles get extra build menu entries\n      String type = session_.getSessionInfo().getBuildToolsType();\n      if (type.equals(SessionInfo.BUILD_TOOLS_MAKEFILE))\n      {\n         ToolbarPopupMenu buildMenu = new ToolbarPopupMenu();\n         buildMenu.addItem(commands_.buildAll().createMenuItem(false));\n         buildMenu.addItem(commands_.rebuildAll().createMenuItem(false));\n         buildMenu.addSeparator();\n         buildMenu.addItem(commands_.cleanAll().createMenuItem(false));\n         ToolbarButton buildMenuButton = new ToolbarButton(buildMenu, true);\n         toolbar.addLeftWidget(buildMenuButton);\n      }\n      \n      toolbar.addLeftSeparator();\n      \n      // packages get checkPackage\n      if (type.equals(SessionInfo.BUILD_TOOLS_PACKAGE))\n      {\n         toolbar.addLeftWidget(commands_.checkPackage().createToolbarButton());\n         toolbar.addLeftSeparator();\n      }\n      \n      // always include configuration\n      toolbar.addLeftWidget(\n               commands_.buildToolsProjectSetup().createToolbarButton());\n      \n      // stop button (initially hidden)\n      ImageResource stopImage = commands_.interruptR().getImageResource();\n      stopButton_ = new ToolbarButton(stopImage, null);\n      stopButton_.setVisible(false);\n      toolbar.addRightWidget(stopButton_);\n      \n      return toolbar;\n   }","id":78231,"modified_method":"@Override\n   protected Toolbar createMainToolbar()\n   {\n      Toolbar toolbar = new Toolbar();\n      \n      // always include build all\n      toolbar.addLeftWidget(commands_.buildAll().createToolbarButton());\n      \n      // makefiles get extra build menu entries\n      String type = session_.getSessionInfo().getBuildToolsType();\n      if (type.equals(SessionInfo.BUILD_TOOLS_MAKEFILE))\n      {\n         ToolbarPopupMenu buildMenu = new ToolbarPopupMenu();\n         buildMenu.addItem(commands_.buildAll().createMenuItem(false));\n         buildMenu.addItem(commands_.rebuildAll().createMenuItem(false));\n         buildMenu.addSeparator();\n         buildMenu.addItem(commands_.cleanAll().createMenuItem(false));\n         ToolbarButton buildMenuButton = new ToolbarButton(buildMenu, true);\n         toolbar.addLeftWidget(buildMenuButton);\n      }\n      \n      // packages get additional commands \n      else if (type.equals(SessionInfo.BUILD_TOOLS_PACKAGE))\n      {\n         ToolbarPopupMenu buildMenu = new ToolbarPopupMenu();\n         buildMenu.addItem(commands_.buildSourcePackage().createMenuItem(false));\n         buildMenu.addItem(commands_.buildBinaryPackage().createMenuItem(false));\n         ToolbarButton buildMenuButton = new ToolbarButton(buildMenu, true);\n         toolbar.addLeftWidget(buildMenuButton);\n         toolbar.addLeftSeparator();\n         toolbar.addLeftWidget(commands_.checkPackage().createToolbarButton());\n      }\n      \n      toolbar.addLeftSeparator();\n      \n      // always include configuration\n      toolbar.addLeftWidget(\n               commands_.buildToolsProjectSetup().createToolbarButton());\n      \n      // stop button (initially hidden)\n      ImageResource stopImage = commands_.interruptR().getImageResource();\n      stopButton_ = new ToolbarButton(stopImage, null);\n      stopButton_.setVisible(false);\n      toolbar.addRightWidget(stopButton_);\n      \n      return toolbar;\n   }","commit_id":"5a8b8fc85c55117e4f51623b5dde86e788edaab5","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public BuildTab(final Shim shim, \n                   final Session session, \n                   Binder binder, \n                   final Commands commands,\n                   EventBus eventBus)\n   {\n      super(\"Build\", shim);\n      session_ = session;\n      binder.bind(commands, shim);\n      \n      eventBus.addHandler(SessionInitEvent.TYPE, new SessionInitHandler() {\n         public void onSessionInit(SessionInitEvent sie)\n         {\n            SessionInfo sessionInfo = session.getSessionInfo();\n\n            // adapt or remove package commands if this isn't a package\n            String type = sessionInfo.getBuildToolsType();\n            if (!type.equals(SessionInfo.BUILD_TOOLS_PACKAGE))\n            {\n               commands.checkPackage().remove();\n               commands.buildAll().setImageResource(\n                                 BuildPaneResources.INSTANCE.iconBuild());\n               commands.buildAll().setMenuLabel(\"_Build All\");\n               commands.buildAll().setDesc(\"Build all\");\n               \n            }\n            \n            // remove makefile commands if this isn't a makefile\n            if (!type.equals(SessionInfo.BUILD_TOOLS_MAKEFILE))\n            {\n               commands.rebuildAll().remove();\n               commands.cleanAll().remove();\n            }\n            \n            // remove all other commands if there are no build tools\n            if (type.equals(SessionInfo.BUILD_TOOLS_NONE))\n            {\n               commands.buildAll().remove();\n               commands.rebuildAll().remove();\n               commands.cleanAll().remove();\n               commands.activateBuild().remove();\n            }\n            \n            // initialize from build state or restart context\n            BuildState buildState = sessionInfo.getBuildState();\n            BuildRestartContext context = sessionInfo.getBuildRestartContext();\n            \n            if (buildState != null)\n               shim.initialize(buildState);\n            else if (context != null)\n               shim.initializeAfterRestart(context);\n               \n          }\n      });\n   }","id":78232,"modified_method":"@Inject\n   public BuildTab(final Shim shim, \n                   final Session session, \n                   Binder binder, \n                   final Commands commands,\n                   EventBus eventBus)\n   {\n      super(\"Build\", shim);\n      session_ = session;\n      binder.bind(commands, shim);\n      \n      eventBus.addHandler(SessionInitEvent.TYPE, new SessionInitHandler() {\n         public void onSessionInit(SessionInitEvent sie)\n         {\n            SessionInfo sessionInfo = session.getSessionInfo();\n\n            // adapt or remove package commands if this isn't a package\n            String type = sessionInfo.getBuildToolsType();\n            if (!type.equals(SessionInfo.BUILD_TOOLS_PACKAGE))\n            {\n               commands.buildSourcePackage().remove();\n               commands.buildBinaryPackage().remove();\n               commands.checkPackage().remove();\n               commands.buildAll().setImageResource(\n                                 BuildPaneResources.INSTANCE.iconBuild());\n               commands.buildAll().setMenuLabel(\"_Build All\");\n               commands.buildAll().setDesc(\"Build all\");\n               \n            }\n            \n            // remove makefile commands if this isn't a makefile\n            if (!type.equals(SessionInfo.BUILD_TOOLS_MAKEFILE))\n            {\n               commands.rebuildAll().remove();\n               commands.cleanAll().remove();\n            }\n            \n            // remove all other commands if there are no build tools\n            if (type.equals(SessionInfo.BUILD_TOOLS_NONE))\n            {\n               commands.buildAll().remove();\n               commands.rebuildAll().remove();\n               commands.cleanAll().remove();\n               commands.activateBuild().remove();\n            }\n            \n            // initialize from build state or restart context\n            BuildState buildState = sessionInfo.getBuildState();\n            BuildRestartContext context = sessionInfo.getBuildRestartContext();\n            \n            if (buildState != null)\n               shim.initialize(buildState);\n            else if (context != null)\n               shim.initializeAfterRestart(context);\n               \n          }\n      });\n   }","commit_id":"5a8b8fc85c55117e4f51623b5dde86e788edaab5","url":"https://github.com/rstudio/rstudio"},{"original_method":"public static void shortenReference(GrCodeReferenceElement ref) {\n    if (ref.getQualifier() != null &&\n        (PsiTreeUtil.getParentOfType(ref, GrDocMemberReference.class) != null ||\n         PsiTreeUtil.getParentOfType(ref, GrDocComment.class) == null) &&\n         PsiTreeUtil.getParentOfType(ref, GrImportStatement.class) == null &&\n         PsiTreeUtil.getParentOfType(ref, GroovyCodeFragment.class) == null) {\n      final PsiElement resolved = ref.resolve();\n      if (resolved instanceof PsiClass && mayShorten(ref)) {\n        ref.setQualifier(null);\n        try {\n          ref.bindToElement(resolved);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n    }\n  }","id":78233,"modified_method":"public static void shortenReference(GrCodeReferenceElement ref) {\n    if (ref.getQualifier() != null &&\n        (PsiTreeUtil.getParentOfType(ref, GrDocMemberReference.class) != null ||\n         PsiTreeUtil.getParentOfType(ref, GrDocComment.class) == null) &&\n         PsiTreeUtil.getParentOfType(ref, GrImportStatement.class) == null &&\n         PsiTreeUtil.getParentOfType(ref, GroovyCodeFragment.class) == null) {\n      final PsiElement resolved = ref.resolve();\n      if (resolved instanceof PsiClass && mayShorten(ref)) {\n        if (ref.getUserData(SHORTENING) != null) {\n          LOG.error(\"Endless shortening. Ref=\" + ref.getText() + \"; parent=\" + ref.getParent());\n          return;\n        }\n\n        ref.setQualifier(null);\n        ref.putUserData(SHORTENING, Boolean.TRUE);\n        try {\n          ref.bindToElement(resolved);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n        finally {\n          ref.putUserData(SHORTENING, null);\n        }\n      }\n    }\n  }","commit_id":"a5a1d4b3b1e7b0e20efe61c09e8a7b6f09347fe1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Object parseObject(Source source)\n    {\n        if (source.next() != '{')\n            throw new IllegalStateException();\n        Map<String, Object> map = newMap();\n\n        char next = seekTo(\"\\\"}\",source);\n\n        while (source.hasNext())\n        {\n            if (next == '}')\n            {\n                source.next();\n                break;\n            }\n\n            String name = parseString(source);\n            seekTo(':',source);\n            source.next();\n\n            Object value = contextFor(name).parse(source);\n            map.put(name,value);\n\n            seekTo(\",}\",source);\n            next = source.next();\n            if (next == '}')\n                break;\n            else\n                next = seekTo(\"\\\"}\",source);\n        }\n\n        String xclassname = (String)map.get(\"x-class\");\n        if (xclassname != null)\n        {\n        \tConvertor c = getConvertorFor(xclassname);\n        \tif (c != null)\n        \t\treturn c.fromJSON(map);\n        \tLOG.warn(\"no Convertor for xclassname '%s'\", xclassname);\n        }\n\n        String classname = (String)map.get(\"class\");\n        if (classname != null)\n        {\n            try\n            {\n                Class c = Loader.loadClass(JSON.class,classname);\n                return convertTo(c,map);\n            }\n            catch (ClassNotFoundException e)\n            {\n                LOG.warn(\"no Class for classname '%s'\", classname);\n            }\n        }\n        \n        return map;\n    }","id":78234,"modified_method":"protected Object parseObject(Source source)\n    {\n        if (source.next() != '{')\n            throw new IllegalStateException();\n        Map<String, Object> map = newMap();\n\n        char next = seekTo(\"\\\"}\",source);\n\n        while (source.hasNext())\n        {\n            if (next == '}')\n            {\n                source.next();\n                break;\n            }\n\n            String name = parseString(source);\n            seekTo(':',source);\n            source.next();\n\n            Object value = contextFor(name).parse(source);\n            map.put(name,value);\n\n            seekTo(\",}\",source);\n            next = source.next();\n            if (next == '}')\n                break;\n            else\n                next = seekTo(\"\\\"}\",source);\n        }\n\n        String xclassname = (String)map.get(\"x-class\");\n        if (xclassname != null)\n        {\n            Convertor c = getConvertorFor(xclassname);\n            if (c != null)\n                return c.fromJSON(map);\n            LOG.warn(\"No Convertor for x-class '{}'\", xclassname);\n        }\n\n        String classname = (String)map.get(\"class\");\n        if (classname != null)\n        {\n            try\n            {\n                Class c = Loader.loadClass(JSON.class,classname);\n                return convertTo(c,map);\n            }\n            catch (ClassNotFoundException e)\n            {\n                LOG.warn(\"No Class for '{}'\", classname);\n            }\n        }\n\n        return map;\n    }","commit_id":"a0519a96938a1b9aba4076101c8b36a2fb3cb50d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Append object as JSON to string buffer.\n     *\n     * @param buffer\n     *            the buffer to append to\n     * @param object\n     *            the object to append\n     */\n    public void append(Appendable buffer, Object object)\n    {\n        try\n        {\n            if (object == null)\n                buffer.append(\"null\");\n            else if (object instanceof Convertible)\n                appendJSON(buffer,(Convertible)object);\n            else if (object instanceof Generator)\n                appendJSON(buffer,(Generator)object);\n            else if (object instanceof Map)\n                appendMap(buffer,(Map)object);\n            else if (object instanceof Collection)\n                appendArray(buffer,(Collection)object);\n            else if (object.getClass().isArray())\n                appendArray(buffer,object);\n            else if (object instanceof Number)\n                appendNumber(buffer,(Number)object);\n            else if (object instanceof Boolean)\n                appendBoolean(buffer,(Boolean)object);\n            else if (object instanceof Character)\n                appendString(buffer,object.toString());\n            else if (object instanceof String)\n                appendString(buffer,(String)object);\n            else\n            {\n                Convertor convertor = getConvertor(object.getClass());\n                if (convertor != null)\n                    appendJSON(buffer,convertor,object);\n                else\n                    appendString(buffer,object.toString());\n            }\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","id":78235,"modified_method":"/**\n     * Append object as JSON to string buffer.\n     *\n     * @param buffer\n     *            the buffer to append to\n     * @param object\n     *            the object to append\n     */\n    public void append(Appendable buffer, Object object)\n    {\n        try\n        {\n            if (object == null)\n            {\n                buffer.append(\"null\");\n            }\n            // Most likely first\n            else if (object instanceof Map)\n            {\n                appendMap(buffer,(Map)object);\n            }\n            else if (object instanceof String)\n            {\n                appendString(buffer,(String)object);\n            }\n            else if (object instanceof Number)\n            {\n                appendNumber(buffer,(Number)object);\n            }\n            else if (object instanceof Boolean)\n            {\n                appendBoolean(buffer,(Boolean)object);\n            }\n            else if (object.getClass().isArray())\n            {\n                appendArray(buffer,object);\n            }\n            else if (object instanceof Character)\n            {\n                appendString(buffer,object.toString());\n            }\n            else if (object instanceof Convertible)\n            {\n                appendJSON(buffer,(Convertible)object);\n            }\n            else if (object instanceof Generator)\n            {\n                appendJSON(buffer,(Generator)object);\n            }\n            else\n            {\n                // Check Convertor before Collection to support JSONCollectionConvertor\n                Convertor convertor = getConvertor(object.getClass());\n                if (convertor != null)\n                {\n                    appendJSON(buffer,convertor,object);\n                }\n                else if (object instanceof Collection)\n                {\n                    appendArray(buffer,(Collection)object);\n                }\n                else\n                {\n                    appendString(buffer,object.toString());\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"a0519a96938a1b9aba4076101c8b36a2fb3cb50d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Lookup a convertor for a class.\n     * <p>\n     * If no match is found for the class, then the interfaces for the class are\n     * tried. If still no match is found, then the super class and it's\n     * interfaces are tried recursively.\n     *\n     * @param forClass\n     *            The class\n     * @return a {@link JSON.Convertor} or null if none were found.\n     */\n    protected Convertor getConvertor(Class forClass)\n    {\n        Class cls = forClass;\n        Convertor convertor = _convertors.get(cls.getName());\n        if (convertor == null && this != DEFAULT)\n            convertor = DEFAULT.getConvertor(cls);\n\n        while (convertor == null && cls != null && cls != Object.class)\n        {\n            Class[] ifs = cls.getInterfaces();\n            int i = 0;\n            while (convertor == null && ifs != null && i < ifs.length)\n                convertor = _convertors.get(ifs[i++].getName());\n            if (convertor == null)\n            {\n                cls = cls.getSuperclass();\n                convertor = _convertors.get(cls.getName());\n            }\n        }\n        return convertor;\n    }","id":78236,"modified_method":"/**\n     * Lookup a convertor for a class.\n     * <p>\n     * If no match is found for the class, then the interfaces for the class are\n     * tried. If still no match is found, then the super class and it's\n     * interfaces are tried recursively.\n     *\n     * @param forClass\n     *            The class\n     * @return a {@link JSON.Convertor} or null if none were found.\n     */\n    protected Convertor getConvertor(Class forClass)\n    {\n        Class cls = forClass;\n        Convertor convertor = _convertors.get(cls.getName());\n        if (convertor == null && this != DEFAULT)\n            convertor = DEFAULT.getConvertor(cls);\n\n        while (convertor == null && cls != Object.class)\n        {\n            Class[] ifs = cls.getInterfaces();\n            int i = 0;\n            while (convertor == null && ifs != null && i < ifs.length)\n                convertor = _convertors.get(ifs[i++].getName());\n            if (convertor == null)\n            {\n                cls = cls.getSuperclass();\n                convertor = _convertors.get(cls.getName());\n            }\n        }\n        return convertor;\n    }","commit_id":"a0519a96938a1b9aba4076101c8b36a2fb3cb50d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Lookup a convertor for a named class.\n     *\n     * @param name\n     *            name of the class\n     * @return a {@link JSON.Convertor} or null if none were found.\n     */\n    public Convertor getConvertorFor(String name)\n    {\n        String clsName = name;\n        Convertor convertor = _convertors.get(clsName);\n        if (convertor == null && this != DEFAULT)\n            convertor = DEFAULT.getConvertorFor(clsName);\n        return convertor;\n    }","id":78237,"modified_method":"/**\n     * Lookup a convertor for a named class.\n     *\n     * @param name\n     *            name of the class\n     * @return a {@link JSON.Convertor} or null if none were found.\n     */\n    public Convertor getConvertorFor(String name)\n    {\n        Convertor convertor = _convertors.get(name);\n        if (convertor == null && this != DEFAULT)\n            convertor = DEFAULT.getConvertorFor(name);\n        return convertor;\n    }","commit_id":"a0519a96938a1b9aba4076101c8b36a2fb3cb50d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void add(String name, double value)\n        {\n            try\n            {\n                if (c == 0)\n                    throw new IllegalStateException();\n                _buffer.append(c);\n                QuotedStringTokenizer.quote(_buffer,name);\n                _buffer.append(':');\n                appendNumber(_buffer,new Double(value));\n                c = ',';\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n        }","id":78238,"modified_method":"public void add(String name, double value)\n        {\n            try\n            {\n                if (c == 0)\n                    throw new IllegalStateException();\n                _buffer.append(c);\n                QuotedStringTokenizer.quote(_buffer,name);\n                _buffer.append(':');\n                appendNumber(_buffer, value);\n                c = ',';\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n        }","commit_id":"a0519a96938a1b9aba4076101c8b36a2fb3cb50d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void appendBoolean(Appendable buffer, Boolean b)\n    {\n        try\n        {\n            if (b == null)\n            {\n                appendNull(buffer);\n                return;\n            }\n            buffer.append(b.booleanValue()?\"true\":\"false\");\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","id":78239,"modified_method":"public void appendBoolean(Appendable buffer, Boolean b)\n    {\n        try\n        {\n            if (b == null)\n            {\n                appendNull(buffer);\n                return;\n            }\n            buffer.append(b?\"true\":\"false\");\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"a0519a96938a1b9aba4076101c8b36a2fb3cb50d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected String parseString(Source source)\n    {\n        if (source.next() != '\"')\n            throw new IllegalStateException();\n\n        boolean escape = false;\n\n        StringBuilder b = null;\n        final char[] scratch = source.scratchBuffer();\n\n        if (scratch != null)\n        {\n            int i = 0;\n            while (source.hasNext())\n            {\n                if (i >= scratch.length)\n                {\n                    // we have filled the scratch buffer, so we must\n                    // use the StringBuffer for a large string\n                    b = new StringBuilder(scratch.length * 2);\n                    b.append(scratch,0,i);\n                    break;\n                }\n\n                char c = source.next();\n\n                if (escape)\n                {\n                    escape = false;\n                    switch (c)\n                    {\n                        case '\"':\n                            scratch[i++] = '\"';\n                            break;\n                        case '\\\\':\n                            scratch[i++] = '\\\\';\n                            break;\n                        case '/':\n                            scratch[i++] = '/';\n                            break;\n                        case 'b':\n                            scratch[i++] = '\\b';\n                            break;\n                        case 'f':\n                            scratch[i++] = '\\f';\n                            break;\n                        case 'n':\n                            scratch[i++] = '\\n';\n                            break;\n                        case 'r':\n                            scratch[i++] = '\\r';\n                            break;\n                        case 't':\n                            scratch[i++] = '\\t';\n                            break;\n                        case 'u':\n                            char uc = (char)((TypeUtil.convertHexDigit((byte)source.next()) << 12) + (TypeUtil.convertHexDigit((byte)source.next()) << 8)\n                                    + (TypeUtil.convertHexDigit((byte)source.next()) << 4) + (TypeUtil.convertHexDigit((byte)source.next())));\n                            scratch[i++] = uc;\n                            break;\n                        default:\n                            scratch[i++] = c;\n                    }\n                }\n                else if (c == '\\\\')\n                {\n                    escape = true;\n                    continue;\n                }\n                else if (c == '\\\"')\n                {\n                    // Return string that fits within scratch buffer\n                    return toString(scratch,0,i);\n                }\n                else\n                    scratch[i++] = c;\n            }\n\n            // Missing end quote, but return string anyway ?\n            if (b == null)\n                return toString(scratch,0,i);\n        }\n        else\n            b = new StringBuilder(getStringBufferSize());\n\n        // parse large string into string buffer\n        final StringBuilder builder=b;\n        while (source.hasNext())\n        {\n            char c = source.next();\n\n            if (escape)\n            {\n                escape = false;\n                switch (c)\n                {\n                    case '\"':\n                        builder.append('\"');\n                        break;\n                    case '\\\\':\n                        builder.append('\\\\');\n                        break;\n                    case '/':\n                        builder.append('/');\n                        break;\n                    case 'b':\n                        builder.append('\\b');\n                        break;\n                    case 'f':\n                        builder.append('\\f');\n                        break;\n                    case 'n':\n                        builder.append('\\n');\n                        break;\n                    case 'r':\n                        builder.append('\\r');\n                        break;\n                    case 't':\n                        builder.append('\\t');\n                        break;\n                    case 'u':\n                        char uc = (char)((TypeUtil.convertHexDigit((byte)source.next()) << 12) + (TypeUtil.convertHexDigit((byte)source.next()) << 8)\n                                + (TypeUtil.convertHexDigit((byte)source.next()) << 4) + (TypeUtil.convertHexDigit((byte)source.next())));\n                        builder.append(uc);\n                        break;\n                    default:\n                        builder.append(c);\n                }\n            }\n            else if (c == '\\\\')\n            {\n                escape = true;\n                continue;\n            }\n            else if (c == '\\\"')\n                break;\n            else\n                builder.append(c);\n        }\n        return builder.toString();\n    }","id":78240,"modified_method":"protected String parseString(Source source)\n    {\n        if (source.next() != '\"')\n            throw new IllegalStateException();\n\n        boolean escape = false;\n\n        StringBuilder b = null;\n        final char[] scratch = source.scratchBuffer();\n\n        if (scratch != null)\n        {\n            int i = 0;\n            while (source.hasNext())\n            {\n                if (i >= scratch.length)\n                {\n                    // we have filled the scratch buffer, so we must\n                    // use the StringBuffer for a large string\n                    b = new StringBuilder(scratch.length * 2);\n                    b.append(scratch,0,i);\n                    break;\n                }\n\n                char c = source.next();\n\n                if (escape)\n                {\n                    escape = false;\n                    switch (c)\n                    {\n                        case '\"':\n                            scratch[i++] = '\"';\n                            break;\n                        case '\\\\':\n                            scratch[i++] = '\\\\';\n                            break;\n                        case '/':\n                            scratch[i++] = '/';\n                            break;\n                        case 'b':\n                            scratch[i++] = '\\b';\n                            break;\n                        case 'f':\n                            scratch[i++] = '\\f';\n                            break;\n                        case 'n':\n                            scratch[i++] = '\\n';\n                            break;\n                        case 'r':\n                            scratch[i++] = '\\r';\n                            break;\n                        case 't':\n                            scratch[i++] = '\\t';\n                            break;\n                        case 'u':\n                            char uc = (char)((TypeUtil.convertHexDigit((byte)source.next()) << 12) + (TypeUtil.convertHexDigit((byte)source.next()) << 8)\n                                    + (TypeUtil.convertHexDigit((byte)source.next()) << 4) + (TypeUtil.convertHexDigit((byte)source.next())));\n                            scratch[i++] = uc;\n                            break;\n                        default:\n                            scratch[i++] = c;\n                    }\n                }\n                else if (c == '\\\\')\n                {\n                    escape = true;\n                }\n                else if (c == '\\\"')\n                {\n                    // Return string that fits within scratch buffer\n                    return toString(scratch,0,i);\n                }\n                else\n                {\n                    scratch[i++] = c;\n                }\n            }\n\n            // Missing end quote, but return string anyway ?\n            if (b == null)\n                return toString(scratch,0,i);\n        }\n        else\n            b = new StringBuilder(getStringBufferSize());\n\n        // parse large string into string buffer\n        final StringBuilder builder=b;\n        while (source.hasNext())\n        {\n            char c = source.next();\n\n            if (escape)\n            {\n                escape = false;\n                switch (c)\n                {\n                    case '\"':\n                        builder.append('\"');\n                        break;\n                    case '\\\\':\n                        builder.append('\\\\');\n                        break;\n                    case '/':\n                        builder.append('/');\n                        break;\n                    case 'b':\n                        builder.append('\\b');\n                        break;\n                    case 'f':\n                        builder.append('\\f');\n                        break;\n                    case 'n':\n                        builder.append('\\n');\n                        break;\n                    case 'r':\n                        builder.append('\\r');\n                        break;\n                    case 't':\n                        builder.append('\\t');\n                        break;\n                    case 'u':\n                        char uc = (char)((TypeUtil.convertHexDigit((byte)source.next()) << 12) + (TypeUtil.convertHexDigit((byte)source.next()) << 8)\n                                + (TypeUtil.convertHexDigit((byte)source.next()) << 4) + (TypeUtil.convertHexDigit((byte)source.next())));\n                        builder.append(uc);\n                        break;\n                    default:\n                        builder.append(c);\n                }\n            }\n            else if (c == '\\\\')\n            {\n                escape = true;\n            }\n            else if (c == '\\\"')\n            {\n                break;\n            }\n            else\n            {\n                builder.append(c);\n            }\n        }\n        return builder.toString();\n    }","commit_id":"a0519a96938a1b9aba4076101c8b36a2fb3cb50d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Object fromJSON(Map map)\n    {\n        if (!_fromJSON)\n            throw new UnsupportedOperationException();\n        try\n        {\n            Class c=Loader.loadClass(getClass(),(String)map.get(\"class\"));\n            return _valueOf.invoke(null,new Object[]{c,map.get(\"value\")});\n        }\n        catch(Exception e)\n        {\n            LOG.warn(e);  \n        }\n        return null;\n    }","id":78241,"modified_method":"public Object fromJSON(Map map)\n    {\n        if (!_fromJSON)\n            throw new UnsupportedOperationException();\n        try\n        {\n            Class c=Loader.loadClass(getClass(),(String)map.get(\"class\"));\n            return _valueOf.invoke(null,c,map.get(\"value\"));\n        }\n        catch(Exception e)\n        {\n            LOG.warn(e);\n        }\n        return null;\n    }","commit_id":"a0519a96938a1b9aba4076101c8b36a2fb3cb50d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String deckTitle,\n\t\t\tString description, String content, int displayDateMonth,\n\t\t\tint displayDateDay, int displayDateYear, int displayDateHour,\n\t\t\tint displayDateMinute, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks, boolean smallImage,\n\t\t\tString smallImageURL, String smallImageFileName,\n\t\t\tInputStream smallImageInputStream, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, user.getTimeZone(),\n\t\t\tEntryDisplayDateException.class);\n\n\t\tbyte[] smallImageBytes = null;\n\n\t\ttry {\n\t\t\tif ((smallImageInputStream != null) && smallImage) {\n\t\t\t\tsmallImageBytes = FileUtil.getBytes(smallImageInputStream);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, content, smallImage, smallImageURL, smallImageFileName,\n\t\t\tsmallImageBytes);\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setTitle(title);\n\t\tentry.setDeckTitle(deckTitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setSmallImage(smallImage);\n\n\t\tif (entry.getSmallImageId() == 0) {\n\t\t\tentry.setSmallImageId(counterLocalService.increment());\n\t\t}\n\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Small image\n\n\t\tsaveImages(smallImage, entry.getSmallImageId(), smallImageBytes);\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\treturn entry;\n\t}","id":78242,"modified_method":"@Override\n\tpublic BlogsEntry updateEntry(\n\t\t\tlong userId, long entryId, String title, String deckTitle,\n\t\t\tString description, String content, int displayDateMonth,\n\t\t\tint displayDateDay, int displayDateYear, int displayDateHour,\n\t\t\tint displayDateMinute, boolean allowPingbacks,\n\t\t\tboolean allowTrackbacks, String[] trackbacks, boolean smallImage,\n\t\t\tString smallImageURL, String smallImageFileName,\n\t\t\tInputStream smallImageInputStream, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, user.getTimeZone(),\n\t\t\tEntryDisplayDateException.class);\n\n\t\tbyte[] smallImageBytes = null;\n\n\t\ttry {\n\t\t\tif ((smallImageInputStream != null) && smallImage) {\n\t\t\t\tsmallImageBytes = FileUtil.getBytes(smallImageInputStream);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tvalidate(\n\t\t\ttitle, content, smallImage, smallImageURL, smallImageFileName,\n\t\t\tsmallImageBytes);\n\n\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tString oldUrlTitle = entry.getUrlTitle();\n\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tentry.setTitle(title);\n\t\tentry.setDeckTitle(deckTitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, oldUrlTitle, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setSmallImage(smallImage);\n\n\t\tif (entry.getSmallImageId() == 0) {\n\t\t\tentry.setSmallImageId(counterLocalService.increment());\n\t\t}\n\n\t\tentry.setSmallImageURL(smallImageURL);\n\n\t\tif (entry.isPending() || entry.isDraft()) {\n\t\t}\n\t\telse {\n\t\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t}\n\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getGroupPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Small image\n\n\t\tsaveImages(smallImage, entry.getSmallImageId(), smallImageBytes);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Workflow\n\n\t\tboolean pingOldTrackbacks = false;\n\n\t\tif (!oldUrlTitle.equals(entry.getUrlTitle())) {\n\t\t\tpingOldTrackbacks = true;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"pingOldTrackbacks\", String.valueOf(pingOldTrackbacks));\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tstartWorkflowInstance(userId, entry, serviceContext);\n\n\t\treturn entry;\n\t}","commit_id":"11e93068fb60f706f2827010349a46f784be8d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected BlogsEntry startWorkflowInstance(\n\t\t\tlong userId, BlogsEntry entry, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tMap<String, Serializable> workflowContext =\n\t\t\tnew HashMap<String, Serializable>();\n\n\t\tworkflowContext.put(\n\t\t\tWorkflowConstants.CONTEXT_URL, getEntryURL(entry, serviceContext));\n\n\t\tString userPortraitURL = StringPool.BLANK;\n\t\tString userURL = StringPool.BLANK;\n\n\t\tif (serviceContext.getThemeDisplay() != null) {\n\t\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\t\tuserPortraitURL = user.getPortraitURL(\n\t\t\t\tserviceContext.getThemeDisplay());\n\t\t\tuserURL = user.getDisplayURL(serviceContext.getThemeDisplay());\n\t\t}\n\n\t\tworkflowContext.put(\n\t\t\tWorkflowConstants.CONTEXT_USER_PORTRAIT_URL, userPortraitURL);\n\t\tworkflowContext.put(WorkflowConstants.CONTEXT_USER_URL, userURL);\n\n\t\tBlogsEntry updatedEntry =\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tentry.getCompanyId(), entry.getGroupId(), userId,\n\t\t\t\tBlogsEntry.class.getName(), entry.getEntryId(), entry,\n\t\t\t\tserviceContext, workflowContext);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, updatedEntry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\treturn updatedEntry;\n\t}","id":78243,"modified_method":"protected void startWorkflowInstance(\n\t\t\tlong userId, BlogsEntry entry, ServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\tMap<String, Serializable> workflowContext =\n\t\t\tnew HashMap<String, Serializable>();\n\n\t\tworkflowContext.put(\n\t\t\tWorkflowConstants.CONTEXT_URL, getEntryURL(entry, serviceContext));\n\n\t\tString userPortraitURL = StringPool.BLANK;\n\t\tString userURL = StringPool.BLANK;\n\n\t\tif (serviceContext.getThemeDisplay() != null) {\n\t\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\t\tuserPortraitURL = user.getPortraitURL(\n\t\t\t\tserviceContext.getThemeDisplay());\n\t\t\tuserURL = user.getDisplayURL(serviceContext.getThemeDisplay());\n\t\t}\n\n\t\tworkflowContext.put(\n\t\t\tWorkflowConstants.CONTEXT_USER_PORTRAIT_URL, userPortraitURL);\n\t\tworkflowContext.put(WorkflowConstants.CONTEXT_USER_URL, userURL);\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tentry.getCompanyId(), entry.getGroupId(), userId,\n\t\t\tBlogsEntry.class.getName(), entry.getEntryId(), entry,\n\t\t\tserviceContext, workflowContext);\n\t}","commit_id":"11e93068fb60f706f2827010349a46f784be8d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic BlogsEntry addEntry(\n\t\t\tlong userId, String title, String deckTitle, String description,\n\t\t\tString content, int displayDateMonth, int displayDateDay,\n\t\t\tint displayDateYear, int displayDateHour, int displayDateMinute,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, boolean smallImage, String smallImageURL,\n\t\t\tString smallImageFileName, InputStream smallImageInputStream,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, user.getTimeZone(),\n\t\t\tEntryDisplayDateException.class);\n\n\t\tbyte[] smallImageBytes = null;\n\n\t\ttry {\n\t\t\tif ((smallImageInputStream != null) && smallImage) {\n\t\t\t\tsmallImageBytes = FileUtil.getBytes(smallImageInputStream);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\ttitle, content, smallImage, smallImageURL, smallImageFileName,\n\t\t\tsmallImageBytes);\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tBlogsEntry entry = blogsEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tentry.setTitle(title);\n\t\tentry.setDeckTitle(deckTitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, null, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageId(counterLocalService.increment());\n\t\tentry.setSmallImageURL(smallImageURL);\n\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tentry.setStatusByUserId(userId);\n\t\tentry.setStatusDate(serviceContext.getModifiedDate(now));\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Small image\n\n\t\tsaveImages(smallImage, entry.getSmallImageId(), smallImageBytes);\n\n\t\t// Message boards\n\n\t\tif (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, entry.getUserName(), groupId,\n\t\t\t\tBlogsEntry.class.getName(), entryId,\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\t// Workflow\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tentry = startWorkflowInstance(userId, entry, serviceContext);\n\n\t\treturn entry;\n\t}","id":78244,"modified_method":"@Override\n\tpublic BlogsEntry addEntry(\n\t\t\tlong userId, String title, String deckTitle, String description,\n\t\t\tString content, int displayDateMonth, int displayDateDay,\n\t\t\tint displayDateYear, int displayDateHour, int displayDateMinute,\n\t\t\tboolean allowPingbacks, boolean allowTrackbacks,\n\t\t\tString[] trackbacks, boolean smallImage, String smallImageURL,\n\t\t\tString smallImageFileName, InputStream smallImageInputStream,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Entry\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\n\t\tDate displayDate = PortalUtil.getDate(\n\t\t\tdisplayDateMonth, displayDateDay, displayDateYear, displayDateHour,\n\t\t\tdisplayDateMinute, user.getTimeZone(),\n\t\t\tEntryDisplayDateException.class);\n\n\t\tbyte[] smallImageBytes = null;\n\n\t\ttry {\n\t\t\tif ((smallImageInputStream != null) && smallImage) {\n\t\t\t\tsmallImageBytes = FileUtil.getBytes(smallImageInputStream);\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(\n\t\t\ttitle, content, smallImage, smallImageURL, smallImageFileName,\n\t\t\tsmallImageBytes);\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tBlogsEntry entry = blogsEntryPersistence.create(entryId);\n\n\t\tentry.setUuid(serviceContext.getUuid());\n\t\tentry.setGroupId(groupId);\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setCreateDate(serviceContext.getCreateDate(now));\n\t\tentry.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tentry.setTitle(title);\n\t\tentry.setDeckTitle(deckTitle);\n\t\tentry.setUrlTitle(\n\t\t\tgetUniqueUrlTitle(entryId, title, null, serviceContext));\n\t\tentry.setDescription(description);\n\t\tentry.setContent(content);\n\t\tentry.setDisplayDate(displayDate);\n\t\tentry.setAllowPingbacks(allowPingbacks);\n\t\tentry.setAllowTrackbacks(allowTrackbacks);\n\t\tentry.setSmallImage(smallImage);\n\t\tentry.setSmallImageId(counterLocalService.increment());\n\t\tentry.setSmallImageURL(smallImageURL);\n\t\tentry.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tentry.setStatusByUserId(userId);\n\t\tentry.setStatusDate(serviceContext.getModifiedDate(now));\n\t\tentry.setExpandoBridgeAttributes(serviceContext);\n\n\t\tblogsEntryPersistence.update(entry);\n\n\t\t// Resources\n\n\t\tif (serviceContext.isAddGroupPermissions() ||\n\t\t\tserviceContext.isAddGuestPermissions()) {\n\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.isAddGroupPermissions(),\n\t\t\t\tserviceContext.isAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddEntryResources(\n\t\t\t\tentry, serviceContext.getGroupPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Small image\n\n\t\tsaveImages(smallImage, entry.getSmallImageId(), smallImageBytes);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, entry, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames(),\n\t\t\tserviceContext.getAssetLinkEntryIds());\n\n\t\t// Message boards\n\n\t\tif (PropsValues.BLOGS_ENTRY_COMMENTS_ENABLED) {\n\t\t\tmbMessageLocalService.addDiscussionMessage(\n\t\t\t\tuserId, entry.getUserName(), groupId,\n\t\t\t\tBlogsEntry.class.getName(), entryId,\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH);\n\t\t}\n\n\t\t// Workflow\n\n\t\tif (ArrayUtil.isNotEmpty(trackbacks)) {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", trackbacks);\n\t\t}\n\t\telse {\n\t\t\tserviceContext.setAttribute(\"trackbacks\", null);\n\t\t}\n\n\t\tstartWorkflowInstance(userId, entry, serviceContext);\n\n\t\treturn entry;\n\t}","commit_id":"11e93068fb60f706f2827010349a46f784be8d36","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateStatus(\n\t\t\tlong userId, long messageId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = getMessage(messageId);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(status);\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tMBCategory category = null;\n\n\t\tif (thread.getCategoryId() > 0) {\n\n\t\t\tcategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\t\t}\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != status)) {\n\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tif ((oldStatus != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t(status == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\tcategory.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\n\t\t\t}\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Asset\n\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(), true);\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.reindex(message);\n\n\t\t\t\t// Social\n\n\t\t\t\tif (!message.isAnonymous() && !user.isDefaultUser()) {\n\n\t\t\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\t\t\tlong receiverUserId = 0;\n\n\t\t\t\t\tMBMessage parentMessage =\n\t\t\t\t\t\tmbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\tif (parentMessage != null) {\n\t\t\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t\t\t}\n\n\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\t\t\tmessage.getMessageId(), activityType, StringPool.BLANK,\n\t\t\t\t\t\treceiverUserId);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tnotifySubscribers(message, serviceContext);\n\n\t\t\t// Ping\n\n\t\t\tpingPingback(message, serviceContext);\n\t\t}\n\t\telse if ((oldStatus == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t (status != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Asset\n\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(), false);\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.delete(message);\n\t\t\t}\n\n\t\t}\n\n\t\tif (status != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId,\n\t\t\t\tserviceContext.getModifiedDate(now));\n\t\t}\n\n\t\treturn message;\n\t}","id":78245,"modified_method":"public MBMessage updateStatus(\n\t\t\tlong userId, long messageId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = getMessage(messageId);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(status);\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tMBCategory category = null;\n\n\t\tif (thread.getCategoryId() > 0) {\n\n\t\t\tcategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\t\t}\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != status)) {\n\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tif ((oldStatus != WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t(status == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\tcategory.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\n\t\t\t}\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Asset\n\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(), true);\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.reindex(message);\n\n\t\t\t\t// Social\n\n\t\t\t\tif (!message.isAnonymous() && !user.isDefaultUser()) {\n\n\t\t\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\t\t\tlong receiverUserId = 0;\n\n\t\t\t\t\tMBMessage parentMessage =\n\t\t\t\t\t\tmbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\tif (parentMessage != null) {\n\t\t\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t\t\t}\n\n\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\t\t\tmessage.getMessageId(), activityType, StringPool.BLANK,\n\t\t\t\t\t\treceiverUserId);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tnotifySubscribers(message, serviceContext);\n\n\t\t\t// Ping\n\n\t\t\tpingPingback(message, serviceContext);\n\n\t\t\t// Discussion\n\n\t\t\tif (message.isDiscussion()) {\n\t\t\t\tupdateDiscussionMessageStatus(\n\t\t\t\t\tuserId, messageId, status, serviceContext);\n\t\t\t}\n\t\t}\n\t\telse if ((oldStatus == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t (status != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Asset\n\n\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(), false);\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.delete(message);\n\t\t\t}\n\n\t\t}\n\n\t\tif (status != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId,\n\t\t\t\tserviceContext.getModifiedDate(now));\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"f9b47b4e4b037ea83da2d2ae6a73c0dee4efbe8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessageDisplay getMessageDisplay(\n\t\t\tMBMessage message, int status, String threadView)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tmessage.getCategoryId());\n\n\t\tMBMessage parentMessage = null;\n\n\t\tif (message.isReply()) {\n\t\t\tparentMessage = mbMessagePersistence.findByPrimaryKey(\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(message.getStatus() == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\tmbThreadLocalService.updateThread(\n\t\t\t\tthread.getThreadId(), thread.getViewCount() + 1);\n\t\t}\n\n\t\tMBThread previousThread = null;\n\t\tMBThread nextThread = null;\n\n\t\tif (message.getStatus() == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tThreadLastPostDateComparator comparator =\n\t\t\t\tnew ThreadLastPostDateComparator(false);\n\n\t\t\tMBThread[] prevAndNextThreads =\n\t\t\t\tmbThreadPersistence.findByG_C_PrevAndNext(\n\t\t\t\t\tmessage.getThreadId(), message.getGroupId(),\n\t\t\t\t\tmessage.getCategoryId(), comparator);\n\n\t\t\tpreviousThread = prevAndNextThreads[0];\n\t\t\tnextThread = prevAndNextThreads[2];\n\t\t}\n\n\t\treturn new MBMessageDisplayImpl(\n\t\t\tmessage, parentMessage, category, thread,\n\t\t\tpreviousThread, nextThread, status, threadView);\n\t}","id":78246,"modified_method":"public MBMessageDisplay getMessageDisplay(\n\t\t\tMBMessage message, int status, String threadView)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBCategory category = null;\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbCategoryPersistence.findByPrimaryKey(message.getCategoryId());\n\t\t}\n\n\t\tMBMessage parentMessage = null;\n\n\t\tif (message.isReply()) {\n\t\t\tparentMessage = mbMessagePersistence.findByPrimaryKey(\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif (!message.isDiscussion() &&\n\t\t\t(message.getStatus() == WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\tmbThreadLocalService.updateThread(\n\t\t\t\tthread.getThreadId(), thread.getViewCount() + 1);\n\t\t}\n\n\t\tMBThread previousThread = null;\n\t\tMBThread nextThread = null;\n\n\t\tif (message.getStatus() == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tThreadLastPostDateComparator comparator =\n\t\t\t\tnew ThreadLastPostDateComparator(false);\n\n\t\t\tMBThread[] prevAndNextThreads =\n\t\t\t\tmbThreadPersistence.findByG_C_PrevAndNext(\n\t\t\t\t\tmessage.getThreadId(), message.getGroupId(),\n\t\t\t\t\tmessage.getCategoryId(), comparator);\n\n\t\t\tpreviousThread = prevAndNextThreads[0];\n\t\t\tnextThread = prevAndNextThreads[2];\n\t\t}\n\n\t\treturn new MBMessageDisplayImpl(\n\t\t\tmessage, parentMessage, category, thread,\n\t\t\tpreviousThread, nextThread, status, threadView);\n\t}","commit_id":"f9b47b4e4b037ea83da2d2ae6a73c0dee4efbe8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, String userName, long groupId,\n\t\t\tlong categoryId, long threadId, long parentMessageId,\n\t\t\tString subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files, boolean anonymous,\n\t\t\tdouble priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setGroupId(groupId);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(serviceContext.getCreateDate(now));\n\t\tmessage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tmessage.setAllowPingbacks(allowPingbacks);\n\t\tmessage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tmessage.setStatusByUserId(user.getUserId());\n\t\tmessage.setStatusByUserName(userName);\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(groupId);\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t\tthread.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(userName);\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong dlGroupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, dlGroupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddCommunityPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getCommunityPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), message,\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\treturn message;\n\t}","id":78247,"modified_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, String userName, long groupId,\n\t\t\tlong categoryId, long threadId, long parentMessageId,\n\t\t\tString subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files, boolean anonymous,\n\t\t\tdouble priority, boolean allowPingbacks,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setGroupId(groupId);\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(serviceContext.getCreateDate(now));\n\t\tmessage.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tmessage.setAllowPingbacks(allowPingbacks);\n\t\tmessage.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tmessage.setStatusByUserId(user.getUserId());\n\t\tmessage.setStatusByUserName(userName);\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(groupId);\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\t\t\tthread.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t\tthread.setStatusByUserId(user.getUserId());\n\t\t\tthread.setStatusByUserName(userName);\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tif ((priority != MBThreadConstants.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong dlGroupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, dlGroupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddCommunityPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getCommunityPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Workflow\n\n\t\tif (serviceContext.getWorkflowAction() ==\n\t\t\t\tWorkflowConstants.ACTION_PUBLISH) {\n\n\t\t\tString className = MBMessage.class.getName();\n\n\t\t\tif (message.isDiscussion()) {\n\t\t\t\tclassName = MBDiscussion.class.getName();\n\t\t\t}\n\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), groupId, userId,\n\t\t\t\tclassName, message.getMessageId(), message,\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\treturn message;\n\t}","commit_id":"f9b47b4e4b037ea83da2d2ae6a73c0dee4efbe8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage addDiscussionMessage(\n\t\t\tlong userId, String userName, String className, long classPK,\n\t\t\tlong threadId, long parentMessageId, String subject,\n\t\t\tString body, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tif (Validator.isNull(subject)) {\n\t\t\tsubject = \"N/A\";\n\t\t}\n\n\t\tList<ObjectValuePair<String, byte[]>> files =\n\t\t\tnew ArrayList<ObjectValuePair<String, byte[]>>();\n\t\tboolean anonymous = false;\n\t\tdouble priority = 0.0;\n\t\tboolean allowPingbacks = false;\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tlong categoryId = MBCategoryConstants.DISCUSSIONS_CATEGORY_ID;\n\n\t\tMBMessage message = addMessage(\n\t\t\tuserId, userName, groupId, categoryId, threadId, parentMessageId,\n\t\t\tsubject, body, files, anonymous, priority, allowPingbacks,\n\t\t\tserviceContext);\n\n\t\tmessage.setClassNameId(classNameId);\n\t\tmessage.setClassPK(classPK);\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Social\n\n\t\tif (!message.isRoot()) {\n\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\tuserId, className, classPK, ActionKeys.ADD_DISCUSSION);\n\t\t}\n\n\t\tif (className.equals(BlogsEntry.class.getName()) &&\n\t\t\tparentMessageId != MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\t// Social\n\n\t\t\tBlogsEntry entry = blogsEntryPersistence.findByPrimaryKey(classPK);\n\n\t\t\tJSONObject extraData = JSONFactoryUtil.createJSONObject();\n\n\t\t\textraData.put(\"messageId\", message.getMessageId());\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, entry.getGroupId(), BlogsEntry.class.getName(),\n\t\t\t\tclassPK, BlogsActivityKeys.ADD_COMMENT, extraData.toString(),\n\t\t\t\tentry.getUserId());\n\n\t\t\t// Email\n\n\t\t\ttry {\n\t\t\t\tsendBlogsCommentsEmail(userId, entry, message, serviceContext);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\t// Discussion\n\n\t\tif (parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\t\t\tMBDiscussion discussion = mbDiscussionPersistence.fetchByC_C(\n\t\t\t\tclassNameId, classPK);\n\n\t\t\tif (discussion == null) {\n\t\t\t\tdiscussion = mbDiscussionLocalService.addDiscussion(\n\t\t\t\t\tclassNameId, classPK, message.getThreadId());\n\t\t\t}\n\t\t}\n\n\t\treturn message;\n\t}","id":78248,"modified_method":"public MBMessage addDiscussionMessage(\n\t\t\tlong userId, String userName, String className, long classPK,\n\t\t\tlong threadId, long parentMessageId, String subject,\n\t\t\tString body, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Message\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tif (Validator.isNull(subject)) {\n\t\t\tsubject = \"N/A\";\n\t\t}\n\n\t\tList<ObjectValuePair<String, byte[]>> files =\n\t\t\tnew ArrayList<ObjectValuePair<String, byte[]>>();\n\t\tboolean anonymous = false;\n\t\tdouble priority = 0.0;\n\t\tboolean allowPingbacks = false;\n\n\t\tserviceContext.setAddCommunityPermissions(true);\n\t\tserviceContext.setAddGuestPermissions(true);\n\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tlong categoryId = MBCategoryConstants.DISCUSSIONS_CATEGORY_ID;\n\n\t\tMBMessage message = addMessage(\n\t\t\tuserId, userName, groupId, categoryId, threadId, parentMessageId,\n\t\t\tsubject, body, files, anonymous, priority, allowPingbacks,\n\t\t\tserviceContext);\n\n\t\tmessage.setClassNameId(classNameId);\n\t\tmessage.setClassPK(classPK);\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\tserviceContext.setAttribute(\"className\", className);\n\t\tserviceContext.setAttribute(\"classPK\", String.valueOf(classPK));\n\n\t\t// Discussion\n\n\t\tif (parentMessageId == MBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\t\t\tMBDiscussion discussion = mbDiscussionPersistence.fetchByC_C(\n\t\t\t\tclassNameId, classPK);\n\n\t\t\tif (discussion == null) {\n\t\t\t\tdiscussion = mbDiscussionLocalService.addDiscussion(\n\t\t\t\t\tclassNameId, classPK, message.getThreadId());\n\t\t\t}\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"f9b47b4e4b037ea83da2d2ae6a73c0dee4efbe8f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic LayoutRevision updateLayoutRevision(\n\t\t\tlong userId, long layoutRevisionId, long layoutBranchId,\n\t\t\tString name, String title, String description, String keywords,\n\t\t\tString robots, String typeSettings, boolean iconImage,\n\t\t\tlong iconImageId, String themeId, String colorSchemeId,\n\t\t\tString wapThemeId, String wapColorSchemeId, String css,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Layout revision\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tLayoutRevision oldLayoutRevision =\n\t\t\tlayoutRevisionPersistence.findByPrimaryKey(layoutRevisionId);\n\t\tDate now = new Date();\n\n\t\tLayoutRevision layoutRevision = null;\n\n\t\tint workflowAction = serviceContext.getWorkflowAction();\n\n\t\tboolean revisionInProgress = ParamUtil.getBoolean(\n\t\t\tserviceContext, \"revisionInProgress\");\n\n\t\tif (!MergeLayoutPrototypesThreadLocal.isInProgress() &&\n\t\t\t(workflowAction != WorkflowConstants.ACTION_PUBLISH) &&\n\t\t\t(_layoutRevisionId.get() <= 0) && !revisionInProgress) {\n\n\t\t\tlong newLayoutRevisionId = counterLocalService.increment();\n\n\t\t\tlayoutRevision = layoutRevisionPersistence.create(\n\t\t\t\tnewLayoutRevisionId);\n\n\t\t\tlayoutRevision.setGroupId(oldLayoutRevision.getGroupId());\n\t\t\tlayoutRevision.setCompanyId(oldLayoutRevision.getCompanyId());\n\t\t\tlayoutRevision.setUserId(user.getUserId());\n\t\t\tlayoutRevision.setUserName(user.getFullName());\n\t\t\tlayoutRevision.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\tlayoutRevision.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t\tlayoutRevision.setLayoutSetBranchId(\n\t\t\t\toldLayoutRevision.getLayoutSetBranchId());\n\t\t\tlayoutRevision.setParentLayoutRevisionId(\n\t\t\t\toldLayoutRevision.getLayoutRevisionId());\n\t\t\tlayoutRevision.setHead(false);\n\t\t\tlayoutRevision.setLayoutBranchId(layoutBranchId);\n\t\t\tlayoutRevision.setPlid(oldLayoutRevision.getPlid());\n\t\t\tlayoutRevision.setPrivateLayout(\n\t\t\t\toldLayoutRevision.isPrivateLayout());\n\t\t\tlayoutRevision.setName(name);\n\t\t\tlayoutRevision.setTitle(title);\n\t\t\tlayoutRevision.setDescription(description);\n\t\t\tlayoutRevision.setKeywords(keywords);\n\t\t\tlayoutRevision.setRobots(robots);\n\t\t\tlayoutRevision.setTypeSettings(typeSettings);\n\t\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\t\tlayoutRevision.setThemeId(themeId);\n\t\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\t\tlayoutRevision.setCss(css);\n\t\t\tlayoutRevision.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t\tlayoutRevision.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\n\t\t\t// Portlet preferences\n\n\t\t\tcopyPortletPreferences(\n\t\t\t\tlayoutRevision, layoutRevision.getParentLayoutRevisionId(),\n\t\t\t\tserviceContext);\n\n\t\t\tStagingUtil.setRecentLayoutBranchId(\n\t\t\t\tuser, layoutRevision.getLayoutSetBranchId(),\n\t\t\t\tlayoutRevision.getPlid(), layoutRevision.getLayoutBranchId());\n\n\t\t\tStagingUtil.setRecentLayoutRevisionId(\n\t\t\t\tuser, layoutRevision.getLayoutSetBranchId(),\n\t\t\t\tlayoutRevision.getPlid(), layoutRevision.getLayoutRevisionId());\n\t\t}\n\t\telse {\n\t\t\tif (_layoutRevisionId.get() > 0) {\n\t\t\t\tlayoutRevision = layoutRevisionPersistence.findByPrimaryKey(\n\t\t\t\t\t_layoutRevisionId.get());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayoutRevision = oldLayoutRevision;\n\t\t\t}\n\n\t\t\tlayoutRevision.setName(name);\n\t\t\tlayoutRevision.setTitle(title);\n\t\t\tlayoutRevision.setDescription(description);\n\t\t\tlayoutRevision.setKeywords(keywords);\n\t\t\tlayoutRevision.setRobots(robots);\n\t\t\tlayoutRevision.setTypeSettings(typeSettings);\n\t\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\t\tlayoutRevision.setThemeId(themeId);\n\t\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\t\tlayoutRevision.setCss(css);\n\n\t\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\t\t}\n\n\t\tboolean major = ParamUtil.getBoolean(serviceContext, \"major\");\n\n\t\tif (major) {\n\t\t\tupdateMajor(layoutRevision);\n\t\t}\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tlayoutRevision.getCompanyId(), layoutRevision.getGroupId(), userId,\n\t\t\tLayoutRevision.class.getName(),\n\t\t\tlayoutRevision.getLayoutRevisionId(), layoutRevision,\n\t\t\tserviceContext);\n\n\t\treturn layoutRevision;\n\t}","id":78249,"modified_method":"@Override\n\tpublic LayoutRevision updateLayoutRevision(\n\t\t\tlong userId, long layoutRevisionId, long layoutBranchId,\n\t\t\tString name, String title, String description, String keywords,\n\t\t\tString robots, String typeSettings, boolean iconImage,\n\t\t\tlong iconImageId, String themeId, String colorSchemeId,\n\t\t\tString wapThemeId, String wapColorSchemeId, String css,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Layout revision\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tLayoutRevision oldLayoutRevision =\n\t\t\tlayoutRevisionPersistence.findByPrimaryKey(layoutRevisionId);\n\t\tDate now = new Date();\n\n\t\tLayoutRevision layoutRevision = null;\n\n\t\tint workflowAction = serviceContext.getWorkflowAction();\n\n\t\tboolean revisionInProgress = ParamUtil.getBoolean(\n\t\t\tserviceContext, \"revisionInProgress\");\n\n\t\tif (!MergeLayoutPrototypesThreadLocal.isInProgress() &&\n\t\t\t(workflowAction != WorkflowConstants.ACTION_PUBLISH) &&\n\t\t\t(_layoutRevisionId.get() <= 0) && !revisionInProgress) {\n\n\t\t\tlong newLayoutRevisionId = counterLocalService.increment();\n\n\t\t\tlayoutRevision = layoutRevisionPersistence.create(\n\t\t\t\tnewLayoutRevisionId);\n\n\t\t\tlayoutRevision.setGroupId(oldLayoutRevision.getGroupId());\n\t\t\tlayoutRevision.setCompanyId(oldLayoutRevision.getCompanyId());\n\t\t\tlayoutRevision.setUserId(user.getUserId());\n\t\t\tlayoutRevision.setUserName(user.getFullName());\n\t\t\tlayoutRevision.setCreateDate(serviceContext.getCreateDate(now));\n\t\t\tlayoutRevision.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\t\tlayoutRevision.setLayoutSetBranchId(\n\t\t\t\toldLayoutRevision.getLayoutSetBranchId());\n\t\t\tlayoutRevision.setParentLayoutRevisionId(\n\t\t\t\toldLayoutRevision.getLayoutRevisionId());\n\t\t\tlayoutRevision.setHead(false);\n\t\t\tlayoutRevision.setLayoutBranchId(layoutBranchId);\n\t\t\tlayoutRevision.setPlid(oldLayoutRevision.getPlid());\n\t\t\tlayoutRevision.setPrivateLayout(\n\t\t\t\toldLayoutRevision.isPrivateLayout());\n\t\t\tlayoutRevision.setName(name);\n\t\t\tlayoutRevision.setTitle(title);\n\t\t\tlayoutRevision.setDescription(description);\n\t\t\tlayoutRevision.setKeywords(keywords);\n\t\t\tlayoutRevision.setRobots(robots);\n\t\t\tlayoutRevision.setTypeSettings(typeSettings);\n\t\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\t\tlayoutRevision.setThemeId(themeId);\n\t\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\t\tlayoutRevision.setCss(css);\n\t\t\tlayoutRevision.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\t\tlayoutRevision.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\n\t\t\t// Portlet preferences\n\n\t\t\tcopyPortletPreferences(\n\t\t\t\tlayoutRevision, layoutRevision.getParentLayoutRevisionId(),\n\t\t\t\tserviceContext);\n\n\t\t\tStagingUtil.setRecentLayoutBranchId(\n\t\t\t\tuser, layoutRevision.getLayoutSetBranchId(),\n\t\t\t\tlayoutRevision.getPlid(), layoutRevision.getLayoutBranchId());\n\n\t\t\tStagingUtil.setRecentLayoutRevisionId(\n\t\t\t\tuser, layoutRevision.getLayoutSetBranchId(),\n\t\t\t\tlayoutRevision.getPlid(), layoutRevision.getLayoutRevisionId());\n\t\t}\n\t\telse {\n\t\t\tif (_layoutRevisionId.get() > 0) {\n\t\t\t\tlayoutRevision = layoutRevisionPersistence.findByPrimaryKey(\n\t\t\t\t\t_layoutRevisionId.get());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayoutRevision = oldLayoutRevision;\n\t\t\t}\n\n\t\t\tlayoutRevision.setName(name);\n\t\t\tlayoutRevision.setTitle(title);\n\t\t\tlayoutRevision.setDescription(description);\n\t\t\tlayoutRevision.setKeywords(keywords);\n\t\t\tlayoutRevision.setRobots(robots);\n\t\t\tlayoutRevision.setTypeSettings(typeSettings);\n\t\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\t\tlayoutRevision.setThemeId(themeId);\n\t\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\t\tlayoutRevision.setCss(css);\n\n\t\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\t\t}\n\n\t\tboolean major = ParamUtil.getBoolean(serviceContext, \"major\");\n\n\t\tif (major || !isWorkflowEnabled(layoutRevision.getPlid())) {\n\t\t\tupdateMajor(layoutRevision);\n\t\t}\n\n\t\t// Workflow\n\n\t\tif (isWorkflowEnabled(layoutRevision.getPlid())) {\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tlayoutRevision.getCompanyId(), layoutRevision.getGroupId(),\n\t\t\t\tuserId, LayoutRevision.class.getName(),\n\t\t\t\tlayoutRevision.getLayoutRevisionId(), layoutRevision,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tupdateStatus(\n\t\t\t\tuserId, layoutRevision.getLayoutRevisionId(),\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, serviceContext);\n\t\t}\n\n\t\treturn layoutRevision;\n\t}","commit_id":"f9fb0e3671f12857f34c6e55895b6afd347e3070","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic LayoutRevision updateStatus(\n\t\t\tlong userId, long layoutRevisionId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tLayoutRevision layoutRevision =\n\t\t\tlayoutRevisionPersistence.findByPrimaryKey(layoutRevisionId);\n\n\t\tlayoutRevision.setStatus(status);\n\t\tlayoutRevision.setStatusByUserId(user.getUserId());\n\t\tlayoutRevision.setStatusByUserName(user.getFullName());\n\t\tlayoutRevision.setStatusDate(new Date());\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tlayoutRevision.setHead(true);\n\t\t}\n\t\telse {\n\t\t\tlayoutRevision.setHead(false);\n\t\t}\n\n\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tList<LayoutRevision> layoutRevisions =\n\t\t\t\tlayoutRevisionPersistence.findByL_P(\n\t\t\t\t\tlayoutRevision.getLayoutSetBranchId(),\n\t\t\t\t\tlayoutRevision.getPlid());\n\n\t\t\tfor (LayoutRevision curLayoutRevision : layoutRevisions) {\n\t\t\t\tif (curLayoutRevision.getLayoutRevisionId() !=\n\t\t\t\t\t\tlayoutRevision.getLayoutRevisionId()) {\n\n\t\t\t\t\tcurLayoutRevision.setHead(false);\n\n\t\t\t\t\tlayoutRevisionPersistence.update(curLayoutRevision);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tList<LayoutRevision> layoutRevisions =\n\t\t\t\tlayoutRevisionPersistence.findByL_P_S(\n\t\t\t\t\tlayoutRevision.getLayoutSetBranchId(),\n\t\t\t\t\tlayoutRevision.getPlid(),\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tfor (LayoutRevision curLayoutRevision : layoutRevisions) {\n\t\t\t\tif (curLayoutRevision.getLayoutRevisionId() !=\n\t\t\t\t\t\tlayoutRevision.getLayoutRevisionId()) {\n\n\t\t\t\t\tcurLayoutRevision.setHead(true);\n\n\t\t\t\t\tlayoutRevisionPersistence.update(curLayoutRevision);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn layoutRevision;\n\t}","id":78250,"modified_method":"@Override\n\tpublic LayoutRevision updateStatus(\n\t\t\tlong userId, long layoutRevisionId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tLayoutRevision layoutRevision =\n\t\t\tlayoutRevisionPersistence.findByPrimaryKey(layoutRevisionId);\n\n\t\tlayoutRevision.setStatus(status);\n\t\tlayoutRevision.setStatusByUserId(user.getUserId());\n\t\tlayoutRevision.setStatusByUserName(user.getFullName());\n\t\tlayoutRevision.setStatusDate(new Date());\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tlayoutRevision.setHead(true);\n\t\t}\n\t\telse {\n\t\t\tlayoutRevision.setHead(false);\n\t\t\tlayoutRevision.setMajor(false);\n\t\t}\n\n\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tList<LayoutRevision> layoutRevisions =\n\t\t\t\tlayoutRevisionPersistence.findByL_P(\n\t\t\t\t\tlayoutRevision.getLayoutSetBranchId(),\n\t\t\t\t\tlayoutRevision.getPlid());\n\n\t\t\tfor (LayoutRevision curLayoutRevision : layoutRevisions) {\n\t\t\t\tif (curLayoutRevision.getLayoutRevisionId() !=\n\t\t\t\t\t\tlayoutRevision.getLayoutRevisionId()) {\n\n\t\t\t\t\tcurLayoutRevision.setHead(false);\n\n\t\t\t\t\tlayoutRevisionPersistence.update(curLayoutRevision);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tList<LayoutRevision> layoutRevisions =\n\t\t\t\tlayoutRevisionPersistence.findByL_P_S(\n\t\t\t\t\tlayoutRevision.getLayoutSetBranchId(),\n\t\t\t\t\tlayoutRevision.getPlid(),\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\t\tfor (LayoutRevision curLayoutRevision : layoutRevisions) {\n\t\t\t\tif (curLayoutRevision.getLayoutRevisionId() !=\n\t\t\t\t\t\tlayoutRevision.getLayoutRevisionId()) {\n\n\t\t\t\t\tcurLayoutRevision.setHead(true);\n\n\t\t\t\t\tlayoutRevisionPersistence.update(curLayoutRevision);\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn layoutRevision;\n\t}","commit_id":"f9fb0e3671f12857f34c6e55895b6afd347e3070","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic LayoutRevision addLayoutRevision(\n\t\t\tlong userId, long layoutSetBranchId, long layoutBranchId,\n\t\t\tlong parentLayoutRevisionId, boolean head, long plid,\n\t\t\tlong portletPreferencesPlid, boolean privateLayout, String name,\n\t\t\tString title, String description, String keywords, String robots,\n\t\t\tString typeSettings, boolean iconImage, long iconImageId,\n\t\t\tString themeId, String colorSchemeId, String wapThemeId,\n\t\t\tString wapColorSchemeId, String css, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Layout revision\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tLayoutSetBranch layoutSetBranch =\n\t\t\tlayoutSetBranchPersistence.findByPrimaryKey(layoutSetBranchId);\n\t\tparentLayoutRevisionId = getParentLayoutRevisionId(\n\t\t\tlayoutSetBranchId, parentLayoutRevisionId, plid);\n\t\tDate now = new Date();\n\n\t\tlong layoutRevisionId = counterLocalService.increment();\n\n\t\tLayoutRevision layoutRevision = layoutRevisionPersistence.create(\n\t\t\tlayoutRevisionId);\n\n\t\tlayoutRevision.setGroupId(layoutSetBranch.getGroupId());\n\t\tlayoutRevision.setCompanyId(user.getCompanyId());\n\t\tlayoutRevision.setUserId(user.getUserId());\n\t\tlayoutRevision.setUserName(user.getFullName());\n\t\tlayoutRevision.setCreateDate(serviceContext.getCreateDate(now));\n\t\tlayoutRevision.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tlayoutRevision.setLayoutSetBranchId(layoutSetBranchId);\n\t\tlayoutRevision.setLayoutBranchId(layoutBranchId);\n\t\tlayoutRevision.setParentLayoutRevisionId(parentLayoutRevisionId);\n\t\tlayoutRevision.setHead(head);\n\t\tlayoutRevision.setPlid(plid);\n\t\tlayoutRevision.setPrivateLayout(privateLayout);\n\t\tlayoutRevision.setName(name);\n\t\tlayoutRevision.setTitle(title);\n\t\tlayoutRevision.setDescription(description);\n\t\tlayoutRevision.setKeywords(keywords);\n\t\tlayoutRevision.setRobots(robots);\n\t\tlayoutRevision.setTypeSettings(typeSettings);\n\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\tlayoutRevision.setThemeId(themeId);\n\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\tlayoutRevision.setCss(css);\n\t\tlayoutRevision.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tlayoutRevision.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\n\t\t// Portlet preferences\n\n\t\tif (portletPreferencesPlid == LayoutConstants.DEFAULT_PLID) {\n\t\t\tportletPreferencesPlid = plid;\n\t\t}\n\n\t\tcopyPortletPreferences(\n\t\t\tlayoutRevision, portletPreferencesPlid, serviceContext);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), layoutRevision.getGroupId(), user.getUserId(),\n\t\t\tLayoutRevision.class.getName(),\n\t\t\tlayoutRevision.getLayoutRevisionId(), layoutRevision,\n\t\t\tserviceContext);\n\n\t\tStagingUtil.setRecentLayoutRevisionId(\n\t\t\tuser, layoutSetBranchId, plid,\n\t\t\tlayoutRevision.getLayoutRevisionId());\n\n\t\treturn layoutRevision;\n\t}","id":78251,"modified_method":"@Override\n\tpublic LayoutRevision addLayoutRevision(\n\t\t\tlong userId, long layoutSetBranchId, long layoutBranchId,\n\t\t\tlong parentLayoutRevisionId, boolean head, long plid,\n\t\t\tlong portletPreferencesPlid, boolean privateLayout, String name,\n\t\t\tString title, String description, String keywords, String robots,\n\t\t\tString typeSettings, boolean iconImage, long iconImageId,\n\t\t\tString themeId, String colorSchemeId, String wapThemeId,\n\t\t\tString wapColorSchemeId, String css, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Layout revision\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tLayoutSetBranch layoutSetBranch =\n\t\t\tlayoutSetBranchPersistence.findByPrimaryKey(layoutSetBranchId);\n\t\tparentLayoutRevisionId = getParentLayoutRevisionId(\n\t\t\tlayoutSetBranchId, parentLayoutRevisionId, plid);\n\t\tDate now = new Date();\n\n\t\tlong layoutRevisionId = counterLocalService.increment();\n\n\t\tLayoutRevision layoutRevision = layoutRevisionPersistence.create(\n\t\t\tlayoutRevisionId);\n\n\t\tlayoutRevision.setGroupId(layoutSetBranch.getGroupId());\n\t\tlayoutRevision.setCompanyId(user.getCompanyId());\n\t\tlayoutRevision.setUserId(user.getUserId());\n\t\tlayoutRevision.setUserName(user.getFullName());\n\t\tlayoutRevision.setCreateDate(serviceContext.getCreateDate(now));\n\t\tlayoutRevision.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tlayoutRevision.setLayoutSetBranchId(layoutSetBranchId);\n\t\tlayoutRevision.setLayoutBranchId(layoutBranchId);\n\t\tlayoutRevision.setParentLayoutRevisionId(parentLayoutRevisionId);\n\t\tlayoutRevision.setHead(head);\n\t\tlayoutRevision.setPlid(plid);\n\t\tlayoutRevision.setPrivateLayout(privateLayout);\n\t\tlayoutRevision.setName(name);\n\t\tlayoutRevision.setTitle(title);\n\t\tlayoutRevision.setDescription(description);\n\t\tlayoutRevision.setKeywords(keywords);\n\t\tlayoutRevision.setRobots(robots);\n\t\tlayoutRevision.setTypeSettings(typeSettings);\n\t\tlayoutRevision.setIconImageId(iconImageId);\n\t\tlayoutRevision.setThemeId(themeId);\n\t\tlayoutRevision.setColorSchemeId(colorSchemeId);\n\t\tlayoutRevision.setWapThemeId(wapThemeId);\n\t\tlayoutRevision.setWapColorSchemeId(wapColorSchemeId);\n\t\tlayoutRevision.setCss(css);\n\t\tlayoutRevision.setStatus(WorkflowConstants.STATUS_DRAFT);\n\t\tlayoutRevision.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tlayoutRevisionPersistence.update(layoutRevision);\n\n\t\t_layoutRevisionId.set(layoutRevision.getLayoutRevisionId());\n\n\t\t// Portlet preferences\n\n\t\tif (portletPreferencesPlid == LayoutConstants.DEFAULT_PLID) {\n\t\t\tportletPreferencesPlid = plid;\n\t\t}\n\n\t\tcopyPortletPreferences(\n\t\t\tlayoutRevision, portletPreferencesPlid, serviceContext);\n\n\t\t// Workflow\n\n\t\tif (isWorkflowEnabled(plid)) {\n\t\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\t\tuser.getCompanyId(), layoutRevision.getGroupId(),\n\t\t\t\tuser.getUserId(), LayoutRevision.class.getName(),\n\t\t\t\tlayoutRevision.getLayoutRevisionId(), layoutRevision,\n\t\t\t\tserviceContext);\n\t\t}\n\t\telse {\n\t\t\tupdateStatus(\n\t\t\t\tuserId, layoutRevisionId, WorkflowConstants.STATUS_APPROVED,\n\t\t\t\tserviceContext);\n\n\t\t\tupdateMajor(layoutRevision);\n\t\t}\n\n\t\tStagingUtil.setRecentLayoutRevisionId(\n\t\t\tuser, layoutSetBranchId, plid,\n\t\t\tlayoutRevision.getLayoutRevisionId());\n\n\t\treturn layoutRevision;\n\t}","commit_id":"f9fb0e3671f12857f34c6e55895b6afd347e3070","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void checkIndexedPropertiesOnCreation(final ODocument iRecord) {\r\n\t\tfinal OClass cls = iRecord.getSchemaClass();\r\n\t\tif (cls == null)\r\n\t\t\treturn;\r\n\r\n\t\tfinal Collection<OIndex<?>> indexes = cls.getIndexes();\r\n\t\tfor (final OIndex<?> index : indexes) {\r\n\t\t\tfinal Object key = index.getDefinition().getDocumentValueToIndex(iRecord);\r\n\t\t\tif (key instanceof Collection) {\r\n\t\t\t\tfor (final Object keyItem : (Collection<?>) key)\r\n\t\t\t\t\tindex.checkEntry(iRecord, keyItem);\r\n\t\t\t} else\r\n\t\t\t\tindex.checkEntry(iRecord, key);\r\n\t\t}\r\n\r\n\t}","id":78252,"modified_method":"private void checkIndexedPropertiesOnCreation(final ODocument iRecord) {\r\n\t\tfinal OClass cls = iRecord.getSchemaClass();\r\n\t\tif (cls == null)\r\n\t\t\treturn;\r\n\r\n\t\tfinal Collection<OIndex<?>> indexes = cls.getIndexes();\r\n\t\tfor (final OIndex<?> index : indexes) {\r\n\t\t\tfinal Object key = index.getDefinition().getDocumentValueToIndex(iRecord);\r\n\t\t\tif (key instanceof Collection) {\r\n\t\t\t\tfor (final Object keyItem : (Collection<?>) key) {\r\n\t\t\t\t\tif(keyItem != null)\r\n\t\t\t\t\t\tindex.checkEntry(iRecord, keyItem);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif(key != null)\r\n\t\t\t\t\tindex.checkEntry(iRecord, key);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}","commit_id":"3fa81c5cee1fb79616325368a81d80e722b6dc76","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void checkIndexedPropertiesOnUpdate(final ODocument iRecord) {\r\n    final OClass cls = iRecord.getSchemaClass();\r\n    if (cls == null)\r\n      return;\r\n\r\n    final Set<String> dirtyFields = new HashSet<String>(Arrays.asList(iRecord.getDirtyFields()));\r\n    if(dirtyFields.isEmpty())\r\n      return;\r\n    \r\n    final Collection<OIndex<?>> indexes = cls.getIndexes();\r\n    for (final OIndex<?> index : indexes) {\r\n      final OIndexDefinition indexDefinition = index.getDefinition();\r\n      final List<String> indexFields = indexDefinition.getFields();\r\n      for(final String indexField : indexFields) {\r\n        if(dirtyFields.contains(indexField))  {\r\n          final Object key = index.getDefinition().getDocumentValueToIndex(iRecord);\r\n          if (key instanceof Collection) {\r\n            for (final Object keyItem : (Collection<?>) key)\r\n              index.checkEntry(iRecord, keyItem);\r\n          } else\r\n            index.checkEntry(iRecord, key);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }","id":78253,"modified_method":"private void checkIndexedPropertiesOnUpdate(final ODocument iRecord) {\r\n    final OClass cls = iRecord.getSchemaClass();\r\n    if (cls == null)\r\n      return;\r\n\r\n    final Set<String> dirtyFields = new HashSet<String>(Arrays.asList(iRecord.getDirtyFields()));\r\n    if(dirtyFields.isEmpty())\r\n      return;\r\n    \r\n    final Collection<OIndex<?>> indexes = cls.getIndexes();\r\n    for (final OIndex<?> index : indexes) {\r\n      final OIndexDefinition indexDefinition = index.getDefinition();\r\n      final List<String> indexFields = indexDefinition.getFields();\r\n      for(final String indexField : indexFields) {\r\n        if(dirtyFields.contains(indexField))  {\r\n          final Object key = index.getDefinition().getDocumentValueToIndex(iRecord);\r\n          if (key instanceof Collection) {\r\n            for (final Object keyItem : (Collection<?>) key) {\r\n\t\t\t\t\t\t\tif(keyItem != null)\r\n\t\t\t\t\t\t\t\tindex.checkEntry(iRecord, keyItem);\r\n\t\t\t\t\t\t}\r\n          } else {\r\n\t\t\t\t\t\tif(key != null)\r\n\t\t\t\t\t\t\tindex.checkEntry(iRecord, key);\r\n\t\t\t\t\t}\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }","commit_id":"3fa81c5cee1fb79616325368a81d80e722b6dc76","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * @see org.sakaiproject.api.app.messageforums.MembershipManager#getAllCourseUsers()\n   */\n  public List getAllCourseUsers()\n  {       \n    Map userMap = new HashMap();    \n    String realmId = getContextSiteId();    \n     \n    AuthzGroup realm = null;\n    try{\n      realm = authzGroupService.getAuthzGroup(realmId);      \n    } catch (GroupNotDefinedException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n                \n    /** handle users */\n    Set users = realm.getMembers();\n    for (Iterator userIterator = users.iterator(); userIterator.hasNext();){\n      Member member = (Member) userIterator.next();      \n      String userId = member.getUserId();\n      Role userRole = member.getRole();            \n      \n      User user = null;\n      try{\n        user = userDirectoryService.getUser(userId);\n      } catch (UserNotDefinedException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}            \n      \n      MembershipItem memberItem = MembershipItem.getInstance();\n      memberItem.setType(MembershipItem.TYPE_USER);\n      memberItem.setName(user.getSortName());\n      memberItem.setUser(user);\n      memberItem.setRole(userRole);             \n                         \n      if(!(userId).equals(\"admin\"))\n      {                                               \n        userMap.put(memberItem.getId(), memberItem);                \n      }                                \n    }\n    \n    return convertMemberMapToList(userMap);\n  }","id":78254,"modified_method":"/**\n   * @see org.sakaiproject.api.app.messageforums.MembershipManager#getAllCourseUsers()\n   */\n  public List getAllCourseUsers()\n  {       \n    Map userMap = new HashMap();    \n    String realmId = getContextSiteId();    \n     \n    AuthzGroup realm = null;\n    try{\n      realm = authzGroupService.getAuthzGroup(realmId);      \n    } catch (GroupNotDefinedException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n                \n    /** handle users */\n    Set users = realm.getMembers();\n    for (Iterator userIterator = users.iterator(); userIterator.hasNext();){\n      Member member = (Member) userIterator.next();      \n      String userId = member.getUserId();\n      Role userRole = member.getRole();            \n      \n      User user = null;\n      try{\n        user = userDirectoryService.getUser(userId);\n      } catch (UserNotDefinedException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}            \n      \n      if(user != null)\n      {\n      \tMembershipItem memberItem = MembershipItem.getInstance();\n      \tmemberItem.setType(MembershipItem.TYPE_USER);\n      \tmemberItem.setName(user.getSortName());\n      \tmemberItem.setUser(user);\n      \tmemberItem.setRole(userRole);             \n\n      \tif(!(userId).equals(\"admin\"))\n      \t{                                               \n      \t\tuserMap.put(memberItem.getId(), memberItem);                \n      \t}\n      }\n    }\n    \n    return convertMemberMapToList(userMap);\n  }","commit_id":"286cf60bc2d9335b29da2d6b30fe2d2a75f88b18","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * @see org.sakaiproject.api.app.messageforums.MembershipManager#getAllCourseMembers(boolean, boolean, boolean)\n   */\n  public Map getAllCourseMembers(boolean filterFerpa, boolean includeRoles, boolean includeAllParticipantsMember)\n  {   \n    Map returnMap = new HashMap();    \n    String realmId = getContextSiteId();\n    Site currentSite = null;\n        \n    /** add all participants */\n    if (includeAllParticipantsMember){\n      MembershipItem memberAll = MembershipItem.getInstance();\n      memberAll.setType(MembershipItem.TYPE_ALL_PARTICIPANTS);\n      memberAll.setName(MembershipItem.ALL_PARTICIPANTS_DESC);\n      returnMap.put(memberAll.getId(), memberAll);\n    }\n \n    AuthzGroup realm = null;\n    try{\n      realm = authzGroupService.getAuthzGroup(realmId);\n      currentSite = siteService.getSite(toolManager.getCurrentPlacement().getContext());      \n    }\n    catch (IdUnusedException e){\n      LOG.debug(e.getMessage(), e);\n      return returnMap;\n    } catch (GroupNotDefinedException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n        \n    /** handle groups */\n    Collection groups = currentSite.getGroups();    \n    for (Iterator groupIterator = groups.iterator(); groupIterator.hasNext();){\n      Group currentGroup = (Group) groupIterator.next();      \n      MembershipItem member = MembershipItem.getInstance();\n      member.setType(MembershipItem.TYPE_GROUP);\n      member.setName(currentGroup.getTitle() + \" Group\");\n      member.setGroup(currentGroup);\n      returnMap.put(member.getId(), member);\n    }\n    \n    /** handle roles */\n    if (includeRoles && realm != null){\n      Set roles = realm.getRoles();\n      for (Iterator roleIterator = roles.iterator(); roleIterator.hasNext();){\n        Role role = (Role) roleIterator.next();\n        MembershipItem member = MembershipItem.getInstance();\n        member.setType(MembershipItem.TYPE_ROLE);\n        String roleId = role.getId();\n        if (roleId != null && roleId.length() > 0){\n          roleId = roleId.substring(0,1).toUpperCase() + roleId.substring(1); \n        }\n        member.setName(roleId + \" Role\");\n        member.setRole(role);\n        returnMap.put(member.getId(), member);\n      }\n    }\n    \n    /** handle users */\n    Set users = realm.getMembers();\n    for (Iterator userIterator = users.iterator(); userIterator.hasNext();){\n      Member member = (Member) userIterator.next();\n      String userId = member.getUserId();\n      Role userRole = member.getRole();            \n      \n      User user = null;\n      try{\n        user = userDirectoryService.getUser(userId);\n      } catch (UserNotDefinedException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}            \n      \n      MembershipItem memberItem = MembershipItem.getInstance();\n      memberItem.setType(MembershipItem.TYPE_USER);\n      memberItem.setName(user.getSortName());\n      memberItem.setUser(user);\n      memberItem.setRole(userRole);             \n                         \n      if(!(userId).equals(\"admin\"))\n      {                                       \n        if (filterFerpa){                       \n          List personList = sakaiPersonManager.findSakaiPersonByUid(userId);\n          boolean ferpa_flag = false;\n          for (Iterator iter = personList.iterator(); iter.hasNext();)\n          {\n            SakaiPerson element = (SakaiPerson) iter.next();            \n            if (Boolean.TRUE.equals(element.getFerpaEnabled())){\n              ferpa_flag = true;\n            }            \n          }                                          \n         if (!ferpa_flag || securityService.unlock(memberItem.getUser(), \n                                                   SiteService.SECURE_UPDATE_SITE,\n                                                   getContextSiteId())\n                         || securityService.unlock(userDirectoryService.getCurrentUser(),\n                                                   SiteService.SECURE_UPDATE_SITE,\n                                                   getContextSiteId())\n          ){\n           returnMap.put(memberItem.getId(), memberItem);\n          }\n        }\n        else{\n          returnMap.put(memberItem.getId(), memberItem);\n        }\n      }                                \n    }\n    \n    return returnMap;\n  }","id":78255,"modified_method":"/**\n   * @see org.sakaiproject.api.app.messageforums.MembershipManager#getAllCourseMembers(boolean, boolean, boolean)\n   */\n  public Map getAllCourseMembers(boolean filterFerpa, boolean includeRoles, boolean includeAllParticipantsMember)\n  {   \n    Map returnMap = new HashMap();    \n    String realmId = getContextSiteId();\n    Site currentSite = null;\n        \n    /** add all participants */\n    if (includeAllParticipantsMember){\n      MembershipItem memberAll = MembershipItem.getInstance();\n      memberAll.setType(MembershipItem.TYPE_ALL_PARTICIPANTS);\n      memberAll.setName(MembershipItem.ALL_PARTICIPANTS_DESC);\n      returnMap.put(memberAll.getId(), memberAll);\n    }\n \n    AuthzGroup realm = null;\n    try{\n      realm = authzGroupService.getAuthzGroup(realmId);\n      currentSite = siteService.getSite(toolManager.getCurrentPlacement().getContext());      \n    }\n    catch (IdUnusedException e){\n      LOG.debug(e.getMessage(), e);\n      return returnMap;\n    } catch (GroupNotDefinedException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n        \n    /** handle groups */\n    Collection groups = currentSite.getGroups();    \n    for (Iterator groupIterator = groups.iterator(); groupIterator.hasNext();){\n      Group currentGroup = (Group) groupIterator.next();      \n      MembershipItem member = MembershipItem.getInstance();\n      member.setType(MembershipItem.TYPE_GROUP);\n      member.setName(currentGroup.getTitle() + \" Group\");\n      member.setGroup(currentGroup);\n      returnMap.put(member.getId(), member);\n    }\n    \n    /** handle roles */\n    if (includeRoles && realm != null){\n      Set roles = realm.getRoles();\n      for (Iterator roleIterator = roles.iterator(); roleIterator.hasNext();){\n        Role role = (Role) roleIterator.next();\n        MembershipItem member = MembershipItem.getInstance();\n        member.setType(MembershipItem.TYPE_ROLE);\n        String roleId = role.getId();\n        if (roleId != null && roleId.length() > 0){\n          roleId = roleId.substring(0,1).toUpperCase() + roleId.substring(1); \n        }\n        member.setName(roleId + \" Role\");\n        member.setRole(role);\n        returnMap.put(member.getId(), member);\n      }\n    }\n    \n    /** handle users */\n    Set users = realm.getMembers();\n    for (Iterator userIterator = users.iterator(); userIterator.hasNext();){\n      Member member = (Member) userIterator.next();\n      String userId = member.getUserId();\n      Role userRole = member.getRole();            \n      \n      User user = null;\n      try{\n        user = userDirectoryService.getUser(userId);\n      } catch (UserNotDefinedException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}            \n      \n      if(user != null)\n      {\n      \tMembershipItem memberItem = MembershipItem.getInstance();\n      \tmemberItem.setType(MembershipItem.TYPE_USER);\n      \tmemberItem.setName(user.getSortName());\n      \tmemberItem.setUser(user);\n      \tmemberItem.setRole(userRole);             \n\n      \tif(!(userId).equals(\"admin\"))\n      \t{                                       \n      \t\tif (filterFerpa){                       \n      \t\t\tList personList = sakaiPersonManager.findSakaiPersonByUid(userId);\n      \t\t\tboolean ferpa_flag = false;\n      \t\t\tfor (Iterator iter = personList.iterator(); iter.hasNext();)\n      \t\t\t{\n      \t\t\t\tSakaiPerson element = (SakaiPerson) iter.next();            \n      \t\t\t\tif (Boolean.TRUE.equals(element.getFerpaEnabled())){\n      \t\t\t\t\tferpa_flag = true;\n      \t\t\t\t}            \n      \t\t\t}                                          \n      \t\t\tif (!ferpa_flag || securityService.unlock(memberItem.getUser(), \n      \t\t\t\t\tSiteService.SECURE_UPDATE_SITE,\n      \t\t\t\t\tgetContextSiteId())\n      \t\t\t\t\t|| securityService.unlock(userDirectoryService.getCurrentUser(),\n      \t\t\t\t\t\t\tSiteService.SECURE_UPDATE_SITE,\n      \t\t\t\t\t\t\tgetContextSiteId())\n      \t\t\t){\n      \t\t\t\treturnMap.put(memberItem.getId(), memberItem);\n      \t\t\t}\n      \t\t}\n      \t\telse{\n      \t\t\treturnMap.put(memberItem.getId(), memberItem);\n      \t\t}\n      \t}                                \n      }\n    }\n    \n    return returnMap;\n  }","commit_id":"286cf60bc2d9335b29da2d6b30fe2d2a75f88b18","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void generateProject(@NotNull final Project project, @NotNull final VirtualFile baseDir) {\n    StudyTaskManager.getInstance(project).setUser(myUser);\n    final Course course = getCourse(project);\n    if (course == null) {\n      LOG.warn(\"Course is null\");\n      Messages.showWarningDialog(\"Some problems occurred while creating the course\", \"Error in Course Creation\");\n      return;\n    }\n    final File courseDirectory = StudyUtils.getCourseDirectory(project, course);\n    StudyTaskManager.getInstance(project).setCourse(course);\n    ApplicationManager.getApplication().runWriteAction(() -> {\n      StudyGenerator.createCourse(course, baseDir, courseDirectory, project);\n      course.setCourseDirectory(courseDirectory.getAbsolutePath());\n      VirtualFileManager.getInstance().refreshWithoutFileWatcher(true);\n      StudyProjectComponent.getInstance(project).registerStudyToolWindow(course);\n      openFirstTask(course, project);\n    });\n  }","id":78256,"modified_method":"public void generateProject(@NotNull final Project project, @NotNull final VirtualFile baseDir) {\n    if (myUser != null) {\n      StudyTaskManager.getInstance(project).setUser(myUser);\n    }\n    final Course course = getCourse(project);\n    if (course == null) {\n      LOG.warn(\"Course is null\");\n      Messages.showWarningDialog(\"Some problems occurred while creating the course\", \"Error in Course Creation\");\n      return;\n    }\n    final File courseDirectory = StudyUtils.getCourseDirectory(project, course);\n    StudyTaskManager.getInstance(project).setCourse(course);\n    ApplicationManager.getApplication().runWriteAction(() -> {\n      StudyGenerator.createCourse(course, baseDir, courseDirectory, project);\n      course.setCourseDirectory(courseDirectory.getAbsolutePath());\n      VirtualFileManager.getInstance().refreshWithoutFileWatcher(true);\n      StudyProjectComponent.getInstance(project).registerStudyToolWindow(course);\n      openFirstTask(course, project);\n    });\n  }","commit_id":"5c70a6701bd5990c7d7520a73122ceecf3cfaec1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tpublic void handleReturnValue(Object returnValue, MethodParameter returnType, Message<?> inputMessage)\n\t\t\tthrows Exception {\n\n\t\tif (returnValue == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tSimpMessageHeaderAccessor inputHeaders = SimpMessageHeaderAccessor.wrap(inputMessage);\n\n\t\tString sessionId = inputHeaders.getSessionId();\n\t\tMessagePostProcessor postProcessor = new SessionHeaderPostProcessor(sessionId);\n\n\t\tSendToUser sendToUser = returnType.getMethodAnnotation(SendToUser.class);\n\t\tif (sendToUser != null) {\n\t\t\tif (inputHeaders.getUser() == null) {\n\t\t\t\tthrow new MissingSessionUserException(inputMessage);\n\t\t\t}\n\t\t\tString user = inputHeaders.getUser().getName();\n\t\t\tfor (String destination : getDestinations(sendToUser, inputHeaders.getDestination())) {\n\t\t\t\tthis.messagingTemplate.convertAndSendToUser(user, destination, returnValue, postProcessor);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tSendTo sendTo = returnType.getMethodAnnotation(SendTo.class);\n\t\tif (sendTo != null) {\n\t\t\tfor (String destination : getDestinations(sendTo, inputHeaders.getDestination())) {\n\t\t\t\tthis.messagingTemplate.convertAndSend(destination, returnValue, postProcessor);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis.messagingTemplate.convertAndSend(inputHeaders.getDestination(), returnValue, postProcessor);\n\t}","id":78257,"modified_method":"@Override\n\tpublic void handleReturnValue(Object returnValue, MethodParameter returnType, Message<?> inputMessage)\n\t\t\tthrows Exception {\n\n\t\tif (returnValue == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tSimpMessageHeaderAccessor inputHeaders = SimpMessageHeaderAccessor.wrap(inputMessage);\n\n\t\tString sessionId = inputHeaders.getSessionId();\n\t\tMessagePostProcessor postProcessor = new SessionHeaderPostProcessor(sessionId);\n\n\t\tSendToUser sendToUser = returnType.getMethodAnnotation(SendToUser.class);\n\t\tif (sendToUser != null) {\n\t\t\tif (inputHeaders.getUser() == null) {\n\t\t\t\tthrow new MissingSessionUserException(inputMessage);\n\t\t\t}\n\t\t\tString user = inputHeaders.getUser().getName();\n\t\t\tString[] destinations = getTargetDestinations(sendToUser, inputHeaders, this.defaultUserDestinationPrefix);\n\t\t\tfor (String destination : destinations) {\n\t\t\t\tthis.messagingTemplate.convertAndSendToUser(user, destination, returnValue, postProcessor);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tSendTo sendTo = returnType.getMethodAnnotation(SendTo.class);\n\t\t\tString[] destinations = getTargetDestinations(sendTo, inputHeaders, this.defaultDestinationPrefix);\n\t\t\tfor (String destination : getTargetDestinations(sendTo, inputHeaders, this.defaultDestinationPrefix)) {\n\t\t\t\tthis.messagingTemplate.convertAndSend(destination, returnValue, postProcessor);\n\t\t\t}\n\t\t}\n\t}","commit_id":"72dec7d0fed80cf74139157690641096de23f41a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private String[] getDestinations(Annotation annot, String inputDestination) {\n\t\tString[] destinations = (String[]) AnnotationUtils.getValue(annot);\n\t\treturn ObjectUtils.isEmpty(destinations) ? new String[] { inputDestination } : destinations;\n\t}","id":78258,"modified_method":"protected String[] getTargetDestinations(Annotation annot, SimpMessageHeaderAccessor inputHeaders,\n\t\t\tString defaultPrefix) {\n\n\t\tif (annot != null) {\n\t\t\tString[] value = (String[]) AnnotationUtils.getValue(annot);\n\t\t\tif (!ObjectUtils.isEmpty(value)) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\treturn new String[] { defaultPrefix + inputHeaders.getDestination() };\n\t}","commit_id":"72dec7d0fed80cf74139157690641096de23f41a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void supportsReturnType() throws Exception {\n\t\tassertTrue(this.handler.supportsReturnType(this.sendToReturnType));\n\t\tassertTrue(this.handler.supportsReturnType(this.sendToUserReturnType));\n\t\tassertFalse(this.handler.supportsReturnType(this.missingSendToReturnType));\n\t\tassertTrue(this.handlerAnnotationNotRequired.supportsReturnType(this.missingSendToReturnType));\n\t}","id":78259,"modified_method":"@Test\n\tpublic void supportsReturnType() throws Exception {\n\t\tassertTrue(this.handler.supportsReturnType(this.sendToReturnType));\n\t\tassertTrue(this.handler.supportsReturnType(this.sendToUserReturnType));\n\t\tassertFalse(this.handler.supportsReturnType(this.noAnnotationsReturnType));\n\t\tassertTrue(this.handlerAnnotationNotRequired.supportsReturnType(this.noAnnotationsReturnType));\n\t}","commit_id":"72dec7d0fed80cf74139157690641096de23f41a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t@Before\n\tpublic void setup() throws Exception {\n\n\t\tMockitoAnnotations.initMocks(this);\n\n\t\tMessage message = MessageBuilder.withPayload(payloadContent).build();\n\t\twhen(this.messageConverter.toMessage(payloadContent, null)).thenReturn(message);\n\n\t\tSimpMessagingTemplate messagingTemplate = new SimpMessagingTemplate(this.messageChannel);\n\t\tmessagingTemplate.setMessageConverter(this.messageConverter);\n\n\t\tthis.handler = new SendToMethodReturnValueHandler(messagingTemplate, true);\n\t\tthis.handlerAnnotationNotRequired = new SendToMethodReturnValueHandler(messagingTemplate, false);\n\n\t\tMethod method = this.getClass().getDeclaredMethod(\"handleAndSendTo\");\n\t\tthis.sendToReturnType = new MethodParameter(method, -1);\n\n\t\tmethod = this.getClass().getDeclaredMethod(\"handleAndSendToUser\");\n\t\tthis.sendToUserReturnType = new MethodParameter(method, -1);\n\n\t\tmethod = this.getClass().getDeclaredMethod(\"handleWithMissingSendTo\");\n\t\tthis.missingSendToReturnType = new MethodParameter(method, -1);\n\t}","id":78260,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t@Before\n\tpublic void setup() throws Exception {\n\n\t\tMockitoAnnotations.initMocks(this);\n\n\t\tMessage message = MessageBuilder.withPayload(payloadContent).build();\n\t\twhen(this.messageConverter.toMessage(payloadContent, null)).thenReturn(message);\n\n\t\tSimpMessagingTemplate messagingTemplate = new SimpMessagingTemplate(this.messageChannel);\n\t\tmessagingTemplate.setMessageConverter(this.messageConverter);\n\n\t\tthis.handler = new SendToMethodReturnValueHandler(messagingTemplate, true);\n\t\tthis.handlerAnnotationNotRequired = new SendToMethodReturnValueHandler(messagingTemplate, false);\n\n\t\tMethod method = this.getClass().getDeclaredMethod(\"handleNoAnnotations\");\n\t\tthis.noAnnotationsReturnType = new MethodParameter(method, -1);\n\n\t\tmethod = this.getClass().getDeclaredMethod(\"handleAndSendToDefaultDestination\");\n\t\tthis.sendToDefaultDestReturnType = new MethodParameter(method, -1);\n\n\t\tmethod = this.getClass().getDeclaredMethod(\"handleAndSendTo\");\n\t\tthis.sendToReturnType = new MethodParameter(method, -1);\n\n\t\tmethod = this.getClass().getDeclaredMethod(\"handleAndSendToUser\");\n\t\tthis.sendToUserReturnType = new MethodParameter(method, -1);\n\n\t\tmethod = this.getClass().getDeclaredMethod(\"handleAndSendToUserDefaultDestination\");\n\t\tthis.sendToUserDefaultDestReturnType = new MethodParameter(method, -1);\n\t}","commit_id":"72dec7d0fed80cf74139157690641096de23f41a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void sendToMethod() throws Exception {\n\n\t\twhen(this.messageChannel.send(any(Message.class))).thenReturn(true);\n\n\t\tString sessionId = \"sess1\";\n\t\tMessage<?> inputMessage = createInputMessage(sessionId, \"sub1\", \"/dest\", null);\n\n\t\tthis.handler.handleReturnValue(payloadContent, this.sendToReturnType, inputMessage);\n\n\t\tverify(this.messageChannel, times(2)).send(this.messageCaptor.capture());\n\n\t\tMessage<?> message = this.messageCaptor.getAllValues().get(0);\n\t\tSimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.wrap(message);\n\n\t\tassertEquals(sessionId, headers.getSessionId());\n\t\tassertNull(headers.getSubscriptionId());\n\t\tassertEquals(\"/dest1\", headers.getDestination());\n\n\t\tmessage = this.messageCaptor.getAllValues().get(1);\n\t\theaders = SimpMessageHeaderAccessor.wrap(message);\n\n\t\tassertEquals(sessionId, headers.getSessionId());\n\t\tassertNull(headers.getSubscriptionId());\n\t\tassertEquals(\"/dest2\", headers.getDestination());\n\t}","id":78261,"modified_method":"@Test\n\tpublic void sendToMethod() throws Exception {\n\n\t\twhen(this.messageChannel.send(any(Message.class))).thenReturn(true);\n\n\t\tString sessionId = \"sess1\";\n\t\tMessage<?> inputMessage = createInputMessage(sessionId, \"sub1\", null, null);\n\t\tthis.handler.handleReturnValue(payloadContent, this.sendToReturnType, inputMessage);\n\n\t\tverify(this.messageChannel, times(2)).send(this.messageCaptor.capture());\n\n\t\tMessage<?> message = this.messageCaptor.getAllValues().get(0);\n\t\tSimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.wrap(message);\n\t\tassertEquals(sessionId, headers.getSessionId());\n\t\tassertNull(headers.getSubscriptionId());\n\t\tassertEquals(\"/dest1\", headers.getDestination());\n\n\t\tmessage = this.messageCaptor.getAllValues().get(1);\n\t\theaders = SimpMessageHeaderAccessor.wrap(message);\n\t\tassertEquals(sessionId, headers.getSessionId());\n\t\tassertNull(headers.getSubscriptionId());\n\t\tassertEquals(\"/dest2\", headers.getDestination());\n\t}","commit_id":"72dec7d0fed80cf74139157690641096de23f41a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private Message<?> createInputMessage(String sessId, String subsId, String dest, Principal principal) {\n\t\tSimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.create();\n\t\theaders.setSessionId(sessId);\n\t\theaders.setSubscriptionId(subsId);\n\t\theaders.setDestination(dest);\n\t\theaders.setUser(principal);\n\t\treturn MessageBuilder.withPayload(new byte[0]).copyHeaders(headers.toMap()).build();\n\t}","id":78262,"modified_method":"private Message<?> createInputMessage(String sessId, String subsId, String destination, Principal principal) {\n\t\tSimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.create();\n\t\theaders.setSessionId(sessId);\n\t\theaders.setSubscriptionId(subsId);\n\t\tif (destination != null) {\n\t\t\theaders.setDestination(destination);\n\t\t}\n\t\tif (principal != null) {\n\t\t\theaders.setUser(principal);\n\t\t}\n\t\treturn MessageBuilder.withPayload(new byte[0]).copyHeaders(headers.toMap()).build();\n\t}","commit_id":"72dec7d0fed80cf74139157690641096de23f41a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void sendToUserMethod() throws Exception {\n\n\t\twhen(this.messageChannel.send(any(Message.class))).thenReturn(true);\n\n\t\tString sessionId = \"sess1\";\n\t\tTestUser user = new TestUser();\n\t\tMessage<?> inputMessage = createInputMessage(sessionId, \"sub1\", \"/dest\", user);\n\n\t\tthis.handler.handleReturnValue(payloadContent, this.sendToUserReturnType, inputMessage);\n\n\t\tverify(this.messageChannel, times(2)).send(this.messageCaptor.capture());\n\n\t\tMessage<?> message = this.messageCaptor.getAllValues().get(0);\n\t\tSimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.wrap(message);\n\n\t\tassertEquals(sessionId, headers.getSessionId());\n\t\tassertNull(headers.getSubscriptionId());\n\t\tassertEquals(\"/user/\" + user.getName() + \"/dest1\", headers.getDestination());\n\n\t\tmessage = this.messageCaptor.getAllValues().get(1);\n\t\theaders = SimpMessageHeaderAccessor.wrap(message);\n\n\t\tassertEquals(sessionId, headers.getSessionId());\n\t\tassertNull(headers.getSubscriptionId());\n\t\tassertEquals(\"/user/\" + user.getName() + \"/dest2\", headers.getDestination());\n\t}","id":78263,"modified_method":"@Test\n\tpublic void sendToUserMethod() throws Exception {\n\n\t\twhen(this.messageChannel.send(any(Message.class))).thenReturn(true);\n\n\t\tString sessionId = \"sess1\";\n\t\tTestUser user = new TestUser();\n\t\tMessage<?> inputMessage = createInputMessage(sessionId, \"sub1\", null, user);\n\t\tthis.handler.handleReturnValue(payloadContent, this.sendToUserReturnType, inputMessage);\n\n\t\tverify(this.messageChannel, times(2)).send(this.messageCaptor.capture());\n\n\t\tMessage<?> message = this.messageCaptor.getAllValues().get(0);\n\t\tSimpMessageHeaderAccessor headers = SimpMessageHeaderAccessor.wrap(message);\n\t\tassertEquals(sessionId, headers.getSessionId());\n\t\tassertNull(headers.getSubscriptionId());\n\t\tassertEquals(\"/user/\" + user.getName() + \"/dest1\", headers.getDestination());\n\n\t\tmessage = this.messageCaptor.getAllValues().get(1);\n\t\theaders = SimpMessageHeaderAccessor.wrap(message);\n\t\tassertEquals(sessionId, headers.getSessionId());\n\t\tassertNull(headers.getSubscriptionId());\n\t\tassertEquals(\"/user/\" + user.getName() + \"/dest2\", headers.getDestination());\n\t}","commit_id":"72dec7d0fed80cf74139157690641096de23f41a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void sendMessageToControllerAndReceiveReplyViaTopic() throws Exception {\n\n\t\tTextMessage message1 = create(StompCommand.SUBSCRIBE).headers(\n\t\t\t\t\"id:subs1\", \"destination:/topic/increment\").build();\n\n\t\tTextMessage message2 = create(StompCommand.SEND).headers(\n\t\t\t\t\"destination:/app/topic/increment\").body(\"5\").build();\n\n\t\tTestClientWebSocketHandler clientHandler = new TestClientWebSocketHandler(1, message1, message2);\n\t\tWebSocketSession session = doHandshake(clientHandler, \"/ws\").get();\n\n\t\ttry {\n\t\t\tassertTrue(clientHandler.latch.await(2, TimeUnit.SECONDS));\n\t\t}\n\t\tfinally {\n\t\t\tsession.close();\n\t\t}\n\t}","id":78264,"modified_method":"@Test\n\tpublic void sendMessageToControllerAndReceiveReplyViaTopic() throws Exception {\n\n\t\tTextMessage message1 = create(StompCommand.SUBSCRIBE).headers(\n\t\t\t\t\"id:subs1\", \"destination:/topic/increment\").build();\n\n\t\tTextMessage message2 = create(StompCommand.SEND).headers(\n\t\t\t\t\"destination:/app/increment\").body(\"5\").build();\n\n\t\tTestClientWebSocketHandler clientHandler = new TestClientWebSocketHandler(1, message1, message2);\n\t\tWebSocketSession session = doHandshake(clientHandler, \"/ws\").get();\n\n\t\ttry {\n\t\t\tassertTrue(clientHandler.latch.await(2, TimeUnit.SECONDS));\n\t\t}\n\t\tfinally {\n\t\t\tsession.close();\n\t\t}\n\t}","commit_id":"72dec7d0fed80cf74139157690641096de23f41a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public DB2Dialect() {\n\t\tsuper();\n\t\tregisterKeyword(\"optimize\");\n\t\tregisterKeyword(\"for\");\n\t}","id":78265,"modified_method":"public DB2Dialect() {\n\t\tsuper();\n\n\t\tregisterKeyword(\"for\");\n\t\tregisterKeyword(\"optimize\");\n\t}","commit_id":"35495c5100a13434d17cefc6d7c91c0fdaff5281","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void addQueryForLimitedRows(\n\t\tStringBundler sb, String sql, int limit) {\n\n\t\tsb.append(sql);\n\n\t\tString sqlFragment = StringUtil.replace(\n\t\t\t_SQL_FETCH_FIRST_LIMITED_ROWS_ONLY, \"[$LIMIT$]\",\n\t\t\tString.valueOf(limit));\n\n\t\tsb.append(StringPool.SPACE);\n\t\tsb.append(sqlFragment);\n\t}","id":78266,"modified_method":"protected void addQueryForLimitedRows(\n\t\tStringBundler sb, String sql, int limit) {\n\n\t\tsb.append(sql);\n\t\tsb.append(StringPool.SPACE);\n\t\tsb.append(\n\t\t\tStringUtil.replace(\n\t\t\t\t_SQL_FETCH_FIRST_LIMITED_ROWS_ONLY, \"[$LIMIT$]\",\n\t\t\t\tString.valueOf(limit)));\n\t}","commit_id":"35495c5100a13434d17cefc6d7c91c0fdaff5281","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void addOptimizeForLimitedRows(StringBundler sb, int limit) {\n\t\tString sqlFragment = StringUtil.replace(\n\t\t\t_SQL_OPTIMIZE_FOR_LIMITED_ROWS, \"[$LIMIT$]\", String.valueOf(limit));\n\n\t\tsb.append(StringPool.SPACE);\n\t\tsb.append(sqlFragment);\n\t}","id":78267,"modified_method":"protected void addOptimizeForLimitedRows(StringBundler sb, int limit) {\n\t\tsb.append(StringPool.SPACE);\n\t\tsb.append(\n\t\t\tStringUtil.replace(\n\t\t\t\t_SQL_OPTIMIZE_FOR_LIMITED_ROWS, \"[$LIMIT$]\",\n\t\t\t\tString.valueOf(limit)));\n\t}","commit_id":"35495c5100a13434d17cefc6d7c91c0fdaff5281","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String getLimitString(String sql, int offset, int limit) {\n\n\t\tboolean hasOffset = false;\n\n\t\tif ((offset > 0) || forceLimitUsage()) {\n\t\t\thasOffset = true;\n\t\t}\n\n\t\tStringBundler sb = null;\n\n\t\tif (hasOffset) {\n\t\t\tsb = new StringBundler(11);\n\t\t}\n\t\telse {\n\t\t\tsb = new StringBundler(5);\n\t\t}\n\n\t\t// If offset is not specified ROW_NUMBER() OVER () can be omitted\n\t\t// and implicit sort will not be taken place this way.\n\n\t\tif (!hasOffset) {\n\t\t\taddQueryForLimitedRows(sb, sql, limit);\n\t\t\taddOptimizeForLimitedRows(sb, limit);\n\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t// Outer query\n\n\t\tsb.append(\"SELECT outerQuery.* FROM (\");\n\t\tsb.append(\"SELECT ROW_NUMBER() OVER() AS rownumber_, \");\n\n\t\t// Inner query\n\n\t\tsb.append(\"innerQuery.* FROM (\");\n\t\taddQueryForLimitedRows(sb, sql, limit);\n\t\tsb.append(\") AS innerQuery\");\n\n\t\t// Offset\n\n\t\tsb.append(\") AS outerQuery WHERE rownumber_ > \");\n\t\tsb.append(offset);\n\n\t\taddOptimizeForLimitedRows(sb, limit);\n\n\t\treturn sb.toString();\n\t}","id":78268,"modified_method":"@Override\n\tpublic String getLimitString(String sql, int offset, int limit) {\n\t\tboolean hasOffset = false;\n\n\t\tif ((offset > 0) || forceLimitUsage()) {\n\t\t\thasOffset = true;\n\t\t}\n\n\t\tStringBundler sb = null;\n\n\t\tif (hasOffset) {\n\t\t\tsb = new StringBundler(11);\n\t\t}\n\t\telse {\n\t\t\tsb = new StringBundler(5);\n\t\t}\n\n\t\tif (!hasOffset) {\n\t\t\taddQueryForLimitedRows(sb, sql, limit);\n\t\t\taddOptimizeForLimitedRows(sb, limit);\n\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\t// Outer query\n\n\t\tsb.append(\"SELECT outerQuery.* FROM (\");\n\t\tsb.append(\"SELECT ROW_NUMBER() OVER() AS rowNumber_, \");\n\n\t\t// Inner query\n\n\t\tsb.append(\"innerQuery.* FROM (\");\n\n\t\taddQueryForLimitedRows(sb, sql, limit);\n\n\t\tsb.append(\") AS innerQuery\");\n\n\t\t// Offset\n\n\t\tsb.append(\") AS outerQuery WHERE rowNumber_ > \");\n\t\tsb.append(offset);\n\n\t\taddOptimizeForLimitedRows(sb, limit);\n\n\t\treturn sb.toString();\n\t}","commit_id":"35495c5100a13434d17cefc6d7c91c0fdaff5281","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tAssume.assumeTrue(DB.TYPE_DB2.equals(DBFactoryUtil.getDB().getType()));\n\t}","id":78269,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tDB db = DBFactoryUtil.getDB();\n\t\t\n\t\tString dbType = db.getType();\n\n\t\tAssume.assumeTrue(dbType.equals(DB.TYPE_DB2));\n\t}","commit_id":"35495c5100a13434d17cefc6d7c91c0fdaff5281","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testPagingWithoutOffset() {\n\t\tdoPaging(_MOCK_SQL, 0, 20);\n\t}","id":78270,"modified_method":"@Test\n\tpublic void testPagingWithoutOffset() {\n\t\ttestPaging(_SQL, 0, 20);\n\t}","commit_id":"35495c5100a13434d17cefc6d7c91c0fdaff5281","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testPagingWithOffset() {\n\t\tdoPaging(_MOCK_SQL, 10, 20);\n\t}","id":78271,"modified_method":"@Test\n\tpublic void testPagingWithOffset() {\n\t\ttestPaging(_SQL, 10, 20);\n\t}","commit_id":"35495c5100a13434d17cefc6d7c91c0fdaff5281","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doPaging(String sql, int offset, int limit) {\n\n\t\tSession session = null;\n\n\t\tList<?> result = null;\n\n\t\ttry {\n\t\t\tsession = _liferaySessionFactory.openSession();\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tresult = QueryUtil.list(\n\t\t\t\tq, _liferaySessionFactory.getDialect(), offset, offset + limit);\n\t\t}\n\t\tfinally {\n\t\t\t_liferaySessionFactory.closeSession(session);\n\t\t}\n\n\t\tAssert.assertNotNull(result);\n\t\tAssert.assertEquals(limit, result.size());\n\t}","id":78272,"modified_method":"protected void testPaging(String sql, int offset, int limit) {\n\t\tSessionFactory sessionFactory =\n\t\t\t(SessionFactory)PortalBeanLocatorUtil.locate(\n\t\t\t\t\"liferaySessionFactory\");\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = sessionFactory.openSession();\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tList<?> result = QueryUtil.list(\n\t\t\t\tq, sessionFactory.getDialect(), offset, offset + limit);\n\n\t\t\tAssert.assertNotNull(result);\n\t\t\tAssert.assertEquals(limit, result.size());\n\t\t}\n\t\tfinally {\n\t\t\tsessionFactory.closeSession(session);\n\t\t}\n\t}","commit_id":"35495c5100a13434d17cefc6d7c91c0fdaff5281","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Activate\n\tprotected void activate(final BundleContext bundleContext)\n\t\tthrows InvalidSyntaxException {\n\n\t\t_logger = new Logger(bundleContext);\n\n\t\t_serviceTrackerMap = ServiceTrackerMapFactory.multiValueMap(\n\t\t\tbundleContext, UpgradeStep.class,\n\t\t\t\t\"(&(\" + UpgradeStepConstants.APPLICATION_NAME +\n\t\t\t\t\t\"=*)(|(database=\" +\n\t\t\t\t\t\tUpgradeStepConstants.ALL_DATABASES +\n\t\t\t\t\t\t\t\")(database=\" + DBFactoryUtil.getDB().getType() +\n\t\t\t\t\t\t\t\t\")))\",\n\t\t\tnew PropertyServiceReferenceMapper<String, UpgradeStep>(\n\t\t\t\tUpgradeStepConstants.APPLICATION_NAME),\n\t\t\tnew UpgradeServiceTrackerCustomizer(bundleContext),\n\t\t\tCollections.reverseOrder(\n\t\t\t\tnew PropertyServiceReferenceComparator<UpgradeStep>(\n\t\t\t\t\t\"upgrade.from\")));\n\n\t\t_serviceTrackerMap.open();\n\t}","id":78273,"modified_method":"@Activate\n\tprotected void activate(final BundleContext bundleContext)\n\t\tthrows InvalidSyntaxException {\n\n\t\t_logger = new Logger(bundleContext);\n\n\t\tDB db = DBFactoryUtil.getDB();\n\n\t\t_serviceTrackerMap = ServiceTrackerMapFactory.multiValueMap(\n\t\t\tbundleContext, UpgradeStep.class,\n\t\t\t\"(&(upgrade.bundle.symbolic.name=*)(|(upgrade.db.type=any)\" +\n\t\t\t\t\"(upgrade.db.type=\" + db.getType() + \")))\",\n\t\t\tnew PropertyServiceReferenceMapper<String, UpgradeStep>(\n\t\t\t\t\"upgrade.bundle.symbolic.name\"),\n\t\t\tnew UpgradeServiceTrackerCustomizer(bundleContext),\n\t\t\tCollections.reverseOrder(\n\t\t\t\tnew PropertyServiceReferenceComparator<UpgradeStep>(\n\t\t\t\t\t\"upgrade.from.version\")));\n\n\t\t_serviceTrackerMap.open();\n\t}","commit_id":"a35bf4a7eb90a3e0a280bd342a9c0b864d451b6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic UpgradeInfo addingService(\n\t\t\tServiceReference<UpgradeStep> serviceReference) {\n\n\t\t\tString fromVersionString = (String)serviceReference.getProperty(\n\t\t\t\t\"upgrade.from.version\");\n\t\t\tString toVersionString = (String)serviceReference.getProperty(\n\t\t\t\t\"upgrade.to.version\");\n\n\t\t\tUpgradeStep upgradeStep = _bundleContext.getService(\n\t\t\t\tserviceReference);\n\n\t\t\tif (upgradeStep == null) {\n\t\t\t\t_logger.log(\n\t\t\t\t\tLogger.LOG_WARNING,\n\t\t\t\t\t\"Not tracking service \" + serviceReference +\n\t\t\t\t\t\t\" because it does not implement UpgradeStep\");\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn new UpgradeInfo(\n\t\t\t\tfromVersionString, toVersionString, upgradeStep);\n\t\t}","id":78274,"modified_method":"@Override\n\t\tpublic UpgradeInfo addingService(\n\t\t\tServiceReference<UpgradeStep> serviceReference) {\n\n\t\t\tString fromVersionString = (String)serviceReference.getProperty(\n\t\t\t\t\"upgrade.from.version\");\n\t\t\tString toVersionString = (String)serviceReference.getProperty(\n\t\t\t\t\"upgrade.to.version\");\n\n\t\t\tUpgradeStep upgradeStep = _bundleContext.getService(\n\t\t\t\tserviceReference);\n\n\t\t\tif (upgradeStep == null) {\n\t\t\t\t_logger.log(\n\t\t\t\t\tLogger.LOG_WARNING,\n\t\t\t\t\t\"Not tracking service reference \" + serviceReference +\n\t\t\t\t\t\t\" because it does not implement UpgradeStep\");\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn new UpgradeInfo(\n\t\t\t\tfromVersionString, toVersionString, upgradeStep);\n\t\t}","commit_id":"a35bf4a7eb90a3e0a280bd342a9c0b864d451b6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Scheduler initializeScheduler(\n\t\t\tString propertiesPrefix, boolean useQuartzCluster)\n\t\tthrows Exception {\n\n\t\tStdSchedulerFactory schedulerFactory = new StdSchedulerFactory();\n\n\t\tProperties properties = PropsUtil.getProperties(propertiesPrefix, true);\n\n\t\tif (useQuartzCluster && PropsValues.CLUSTER_LINK_ENABLED) {\n\t\t\tString dbType = DBFactoryUtil.getDB().getType();\n\n\t\t\tif (dbType.equals(DB.TYPE_HYPERSONIC)) {\n\t\t\t\t_log.error(\"Unable to cluster scheduler on HSQL\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tproperties.put(\n\t\t\t\t\t\"org.quartz.jobStore.isClustered\", Boolean.TRUE.toString());\n\t\t\t}\n\t\t}\n\n\t\tschedulerFactory.initialize(properties);\n\n\t\treturn schedulerFactory.getScheduler();\n\t}","id":78275,"modified_method":"protected Scheduler initializeScheduler(\n\t\t\tString propertiesPrefix, boolean useQuartzCluster)\n\t\tthrows Exception {\n\n\t\tStdSchedulerFactory schedulerFactory = new StdSchedulerFactory();\n\n\t\tProperties properties = PropsUtil.getProperties(propertiesPrefix, true);\n\n\t\tif (useQuartzCluster && PropsValues.CLUSTER_LINK_ENABLED) {\n\t\t\tDB db = DBFactoryUtil.getDB();\n\n\t\t\tString dbType = db.getType();\n\n\t\t\tif (dbType.equals(DB.TYPE_HYPERSONIC)) {\n\t\t\t\t_log.error(\"Unable to cluster scheduler on Hypersonic\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tproperties.put(\n\t\t\t\t\t\"org.quartz.jobStore.isClustered\", Boolean.TRUE.toString());\n\t\t\t}\n\t\t}\n\n\t\tschedulerFactory.initialize(properties);\n\n\t\treturn schedulerFactory.getScheduler();\n\t}","commit_id":"eba6c213dc0d8113e3c95067e7e884dce0abbcad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean evaluateCondition(final EvaluationContextImpl context, LocatableEvent event) throws EvaluateException {\n    final DebugProcessImpl debugProcess = context.getDebugProcess();\n    if (isCountFilterEnabled()) {\n      debugProcess.getVirtualMachineProxy().suspend();\n      debugProcess.getRequestsManager().deleteRequest(this);\n      ((Breakpoint)this).createRequest(debugProcess);\n      debugProcess.getVirtualMachineProxy().resume();\n    }\n    if (isInstanceFiltersEnabled()) {\n      Value value = context.getThisObject();\n      if (value != null) {  // non-static\n        ObjectReference reference = (ObjectReference)value;\n        if (!hasObjectID(reference.uniqueID())) {\n          return false;\n        }\n      }\n    }\n\n    if (isClassFiltersEnabled()) {\n      String typeName = calculateEventClass(context, event);\n      if (!typeMatchesClassFilters(typeName)) return false;\n    }\n\n    if (!isConditionEnabled() || getCondition().getText().isEmpty()) {\n      return true;\n    }\n\n    StackFrameProxyImpl frame = context.getFrameProxy();\n    if (frame != null) {\n      Location location = frame.location();\n      if (location != null) {\n        ThreeState result = debugProcess.getPositionManager().evaluateCondition(context, frame, location, getCondition().getText());\n        if (result != ThreeState.UNSURE) {\n          return result == ThreeState.YES;\n        }\n      }\n    }\n\n    try {\n      ExpressionEvaluator evaluator = DebuggerInvocationUtil.commitAndRunReadAction(context.getProject(), new EvaluatingComputable<ExpressionEvaluator>() {\n        @Override\n        public ExpressionEvaluator compute() throws EvaluateException {\n          final SourcePosition contextSourcePosition = ContextUtil.getSourcePosition(context);\n          // IMPORTANT: calculate context psi element basing on the location where the exception\n          // has been hit, not on the location where it was set. (For line breakpoints these locations are the same, however,\n          // for method, exception and field breakpoints these locations differ)\n          PsiElement contextPsiElement = ContextUtil.getContextElement(contextSourcePosition);\n          if (contextPsiElement == null) {\n            contextPsiElement = getEvaluationElement(); // as a last resort\n          }\n          return EvaluatorBuilderImpl.build(getCondition(), contextPsiElement, contextSourcePosition);\n        }\n      });\n      final Value value = evaluator.evaluate(context);\n      if (!(value instanceof BooleanValue)) {\n        throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.boolean.expected\"));\n      }\n      if (!((BooleanValue)value).booleanValue()) {\n        return false;\n      }\n    }\n    catch (EvaluateException ex) {\n      if (ex.getCause() instanceof VMDisconnectedException) {\n        return false;\n      }\n      throw EvaluateExceptionUtil.createEvaluateException(\n        DebuggerBundle.message(\"error.failed.evaluating.breakpoint.condition\", getCondition(), ex.getMessage())\n      );\n    }\n    return true;\n  }","id":78276,"modified_method":"public boolean evaluateCondition(final EvaluationContextImpl context, LocatableEvent event) throws EvaluateException {\n    final DebugProcessImpl debugProcess = context.getDebugProcess();\n    if (isCountFilterEnabled()) {\n      debugProcess.getVirtualMachineProxy().suspend();\n      debugProcess.getRequestsManager().deleteRequest(this);\n      ((Breakpoint)this).createRequest(debugProcess);\n      debugProcess.getVirtualMachineProxy().resume();\n    }\n    if (isInstanceFiltersEnabled()) {\n      Value value = context.getThisObject();\n      if (value != null) {  // non-static\n        ObjectReference reference = (ObjectReference)value;\n        if (!hasObjectID(reference.uniqueID())) {\n          return false;\n        }\n      }\n    }\n\n    if (isClassFiltersEnabled()) {\n      String typeName = calculateEventClass(context, event);\n      if (!typeMatchesClassFilters(typeName)) return false;\n    }\n\n    if (!isConditionEnabled() || getCondition().getText().isEmpty()) {\n      return true;\n    }\n\n    StackFrameProxyImpl frame = context.getFrameProxy();\n    if (frame != null) {\n      Location location = frame.location();\n      if (location != null) {\n        ThreeState result = debugProcess.getPositionManager().evaluateCondition(context, frame, location, getCondition().getText());\n        if (result != ThreeState.UNSURE) {\n          return result == ThreeState.YES;\n        }\n      }\n    }\n\n    try {\n      ExpressionEvaluator evaluator = DebuggerInvocationUtil.commitAndRunReadAction(context.getProject(), new EvaluatingComputable<ExpressionEvaluator>() {\n        @Override\n        public ExpressionEvaluator compute() throws EvaluateException {\n          final SourcePosition contextSourcePosition = ContextUtil.getSourcePosition(context);\n          // IMPORTANT: calculate context psi element basing on the location where the exception\n          // has been hit, not on the location where it was set. (For line breakpoints these locations are the same, however,\n          // for method, exception and field breakpoints these locations differ)\n          PsiElement contextPsiElement = ContextUtil.getContextElement(contextSourcePosition);\n          if (contextPsiElement == null) {\n            contextPsiElement = getEvaluationElement(); // as a last resort\n          }\n          return EvaluatorBuilderImpl.build(getCondition(), contextPsiElement, contextSourcePosition);\n        }\n      });\n      Object value = UnBoxingEvaluator.unbox(evaluator.evaluate(context), context);\n      if (!(value instanceof BooleanValue)) {\n        throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.boolean.expected\"));\n      }\n      if (!((BooleanValue)value).booleanValue()) {\n        return false;\n      }\n    }\n    catch (EvaluateException ex) {\n      if (ex.getCause() instanceof VMDisconnectedException) {\n        return false;\n      }\n      throw EvaluateExceptionUtil.createEvaluateException(\n        DebuggerBundle.message(\"error.failed.evaluating.breakpoint.condition\", getCondition(), ex.getMessage())\n      );\n    }\n    return true;\n  }","commit_id":"ce28e2bcb6d2a6ac0112aa24b4b19c3a44953fc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    Value condition = (Value)myConditionEvaluator.evaluate(context);\n    if (condition == null || !(condition instanceof BooleanValue)) {\n      throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.boolean.condition.expected\"));\n    }\n    return ((BooleanValue)condition).booleanValue()? myThenEvaluator.evaluate(context) : myElseEvaluator.evaluate(context);\n  }","id":78277,"modified_method":"@Override\n  public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    Object condition = UnBoxingEvaluator.unbox(myConditionEvaluator.evaluate(context), context);\n    if (!(condition instanceof BooleanValue)) {\n      throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.boolean.condition.expected\"));\n    }\n    return ((BooleanValue)condition).booleanValue()? myThenEvaluator.evaluate(context) : myElseEvaluator.evaluate(context);\n  }","commit_id":"ce28e2bcb6d2a6ac0112aa24b4b19c3a44953fc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    Object value = context.getDebugProcess().getVirtualMachineProxy().mirrorOf();\n    while (true) {\n      if (body(context)) break;\n\n      value = myConditionEvaluator.evaluate(context);\n      if (!(value instanceof BooleanValue)) {\n        throw EvaluateExceptionUtil.BOOLEAN_EXPECTED;\n      }\n      else {\n        if (!((BooleanValue)value).booleanValue()) {\n          break;\n        }\n      }\n    }\n\n    return value;\n  }","id":78278,"modified_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    Object value = context.getDebugProcess().getVirtualMachineProxy().mirrorOf();\n    while (true) {\n      if (body(context)) break;\n\n      value = UnBoxingEvaluator.unbox(myConditionEvaluator.evaluate(context), context);\n      if (!(value instanceof BooleanValue)) {\n        throw EvaluateExceptionUtil.BOOLEAN_EXPECTED;\n      }\n      else {\n        if (!((BooleanValue)value).booleanValue()) {\n          break;\n        }\n      }\n    }\n\n    return value;\n  }","commit_id":"ce28e2bcb6d2a6ac0112aa24b4b19c3a44953fc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    Object value = context.getDebugProcess().getVirtualMachineProxy().mirrorOf();\n    value = evaluateInitialization(context, value);\n\n    while (true) {\n      // condition\n      Object codition = evaluateCondition(context);\n      if (codition instanceof Boolean) {\n        if (!(Boolean)codition) break;\n      }\n      else if (codition instanceof BooleanValue) {\n        if (!((BooleanValue)codition).booleanValue()) break;\n      }\n      else {\n        throw EvaluateExceptionUtil.BOOLEAN_EXPECTED;\n      }\n\n      // body\n      if (body(context)) break;\n\n      // update\n      value = evaluateUpdate(context, value);\n    }\n\n    return value;\n  }","id":78279,"modified_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    Object value = context.getDebugProcess().getVirtualMachineProxy().mirrorOf();\n    value = evaluateInitialization(context, value);\n\n    while (true) {\n      // condition\n      Object codition = UnBoxingEvaluator.unbox(evaluateCondition(context), context);\n      if (codition instanceof Boolean) {\n        if (!(Boolean)codition) break;\n      }\n      else if (codition instanceof BooleanValue) {\n        if (!((BooleanValue)codition).booleanValue()) break;\n      }\n      else {\n        throw EvaluateExceptionUtil.BOOLEAN_EXPECTED;\n      }\n\n      // body\n      if (body(context)) break;\n\n      // update\n      value = evaluateUpdate(context, value);\n    }\n\n    return value;\n  }","commit_id":"ce28e2bcb6d2a6ac0112aa24b4b19c3a44953fc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    Object value = myConditionEvaluator.evaluate(context);\n    if(!(value instanceof BooleanValue)) {\n      throw EvaluateExceptionUtil.BOOLEAN_EXPECTED;\n    } else {\n      if(((BooleanValue)value).booleanValue()) {\n        value = myThenEvaluator.evaluate(context);\n        myModifier = myThenEvaluator.getModifier();\n      }\n      else {\n        if(myElseEvaluator != null) {\n          value = myElseEvaluator.evaluate(context);\n          myModifier = myElseEvaluator.getModifier();\n        } else {\n          value = context.getDebugProcess().getVirtualMachineProxy().mirrorOf();\n          myModifier = null;\n        }\n      }\n    }\n    return value;\n  }","id":78280,"modified_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    Object value = UnBoxingEvaluator.unbox(myConditionEvaluator.evaluate(context), context);\n    if(!(value instanceof BooleanValue)) {\n      throw EvaluateExceptionUtil.BOOLEAN_EXPECTED;\n    } else {\n      if(((BooleanValue)value).booleanValue()) {\n        value = myThenEvaluator.evaluate(context);\n        myModifier = myThenEvaluator.getModifier();\n      }\n      else {\n        if(myElseEvaluator != null) {\n          value = myElseEvaluator.evaluate(context);\n          myModifier = myElseEvaluator.getModifier();\n        } else {\n          value = context.getDebugProcess().getVirtualMachineProxy().mirrorOf();\n          myModifier = null;\n        }\n      }\n    }\n    return value;\n  }","commit_id":"ce28e2bcb6d2a6ac0112aa24b4b19c3a44953fc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    final Value result = (Value)myOperand.evaluate(context);\n    if (result == null) {\n      throw new EvaluateException(\"java.lang.NullPointerException: cannot unbox null value\");\n    }\n    if (result instanceof ObjectReference) {\n      final String valueTypeName = result.type().name();\n      final Couple<String> pair = TYPES_TO_CONVERSION_METHOD_MAP.get(valueTypeName);\n      if (pair != null) {\n        return convertToPrimitive(context, (ObjectReference)result, pair.getFirst(), pair.getSecond());\n      }\n    }\n    return result;\n  }","id":78281,"modified_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    return unbox(myOperand.evaluate(context), context);\n  }","commit_id":"ce28e2bcb6d2a6ac0112aa24b4b19c3a44953fc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    Object value;\n    while (true) {\n      value = myConditionEvaluator.evaluate(context);\n      if (!(value instanceof BooleanValue)) {\n        throw EvaluateExceptionUtil.BOOLEAN_EXPECTED;\n      }\n      else {\n        if (!((BooleanValue)value).booleanValue()) {\n          break;\n        }\n      }\n\n      if (body(context)) break;\n    }\n\n    return value;\n  }","id":78282,"modified_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    Object value;\n    while (true) {\n      value = UnBoxingEvaluator.unbox(myConditionEvaluator.evaluate(context), context);\n      if (!(value instanceof BooleanValue)) {\n        throw EvaluateExceptionUtil.BOOLEAN_EXPECTED;\n      }\n      else {\n        if (!((BooleanValue)value).booleanValue()) {\n          break;\n        }\n      }\n\n      if (body(context)) break;\n    }\n\n    return value;\n  }","commit_id":"ce28e2bcb6d2a6ac0112aa24b4b19c3a44953fc0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void configureFlow() {\n      setName(\"WhoFlow\");\n      setDescription(\"A flow that collects names\");\n      addFlowlet(\"saver\", new NameSaver());\n      connectStream(\"who\", \"saver\");\n    }","id":78283,"modified_method":"@Override\n    protected void configure() {\n      setName(\"WhoFlow\");\n      setDescription(\"A flow that collects names\");\n      addFlowlet(\"saver\", new NameSaver());\n      connectStream(\"who\", \"saver\");\n    }","commit_id":"16bf563c106f6e90cb5720c5ad16fda811cd5ca0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws TimeoutException, InterruptedException, IOException {\n    // Deploy the HelloWorld application\n    ApplicationManager appManager = deployApplication(HelloWorld.class);\n\n    // Start WhoFlow\n    FlowManager flowManager = appManager.getFlowManager(\"WhoFlow\").start();\n\n    // Send stream events to the \"who\" Stream\n    StreamManager streamManager = getStreamManager(\"who\");\n    streamManager.send(\"1\");\n    streamManager.send(\"2\");\n    streamManager.send(\"3\");\n    streamManager.send(\"4\");\n    streamManager.send(\"5\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = RuntimeStats.getFlowletMetrics(\"HelloWorld\", \"WhoFlow\", \"saver\");\n      metrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n    }\n\n    // Start Greeting service and use it\n    ServiceManager serviceManager = appManager.getServiceManager(HelloWorld.Greeting.SERVICE_NAME);\n    serviceManager.start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    URL url = new URL(serviceManager.getServiceURL(), \"greet\");\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    String response;\n    try {\n      response = new String(ByteStreams.toByteArray(connection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      connection.disconnect();\n    }\n    Assert.assertEquals(\"Hello 5!\", response);\n\n    appManager.stopAll();\n  }","id":78284,"modified_method":"@Test\n  public void test() throws Exception {\n    // Deploy the HelloWorld application\n    ApplicationManager appManager = deployApplication(HelloWorld.class);\n\n    // Start WhoFlow\n    FlowManager flowManager = appManager.getFlowManager(\"WhoFlow\").start();\n    Assert.assertTrue(flowManager.isRunning());\n\n    // Send stream events to the \"who\" Stream\n    StreamManager streamManager = getStreamManager(\"who\");\n    streamManager.send(\"1\");\n    streamManager.send(\"2\");\n    streamManager.send(\"3\");\n    streamManager.send(\"4\");\n    streamManager.send(\"5\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = flowManager.getFlowletMetrics(\"saver\");\n      metrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // Start Greeting service and use it\n    ServiceManager serviceManager = appManager.getServiceManager(HelloWorld.Greeting.SERVICE_NAME).start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    URL url = new URL(serviceManager.getServiceURL(), \"greet\");\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    String response;\n    try {\n      response = new String(ByteStreams.toByteArray(connection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      connection.disconnect();\n    }\n    Assert.assertEquals(\"Hello 5!\", response);\n  }","commit_id":"16bf563c106f6e90cb5720c5ad16fda811cd5ca0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void test() throws Exception {\n    // Deploy the HelloWorld application\n    ApplicationManager appManager = deployApplication(HelloWorld.class);\n\n    // Start WhoFlow\n    FlowManager flowManager = appManager.getFlowManager(\"WhoFlow\").start();\n    Assert.assertTrue(flowManager.isRunning());\n\n    // Send stream events to the \"who\" Stream\n    StreamManager streamManager = getStreamManager(\"who\");\n    streamManager.send(\"1\");\n    streamManager.send(\"2\");\n    streamManager.send(\"3\");\n    streamManager.send(\"4\");\n    streamManager.send(\"5\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = flowManager.getFlowletMetrics(\"saver\");\n      metrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // Start Greeting service and use it\n    ServiceManager serviceManager = appManager.getServiceManager(HelloWorld.Greeting.SERVICE_NAME).start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    URL url = new URL(serviceManager.getServiceURL(15, TimeUnit.SECONDS), \"greet\");\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    String response;\n    try {\n      response = new String(ByteStreams.toByteArray(connection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      connection.disconnect();\n    }\n    Assert.assertEquals(\"Hello 5!\", response);\n  }","id":78285,"modified_method":"@Test\n  public void test() throws Exception {\n    // Deploy the HelloWorld application\n    ApplicationManager appManager = deployApplication(HelloWorld.class);\n\n    // Start WhoFlow\n    FlowManager flowManager = appManager.getFlowManager(\"WhoFlow\").start();\n    Assert.assertTrue(flowManager.isRunning());\n\n    // Send stream events to the \"who\" Stream\n    StreamManager streamManager = getStreamManager(\"who\");\n    streamManager.send(\"1\");\n    streamManager.send(\"2\");\n    streamManager.send(\"3\");\n    streamManager.send(\"4\");\n    streamManager.send(\"5\");\n\n    try {\n      // Wait for the last Flowlet processing 5 events, or at most 5 seconds\n      RuntimeMetrics metrics = flowManager.getFlowletMetrics(\"saver\");\n      metrics.waitForProcessed(5, 5, TimeUnit.SECONDS);\n    } finally {\n      flowManager.stop();\n      Assert.assertFalse(flowManager.isRunning());\n    }\n\n    // Start Greeting service and use it\n    ServiceManager serviceManager = appManager.getServiceManager(HelloWorld.Greeting.SERVICE_NAME).start();\n\n    // Wait service startup\n    serviceManager.waitForStatus(true);\n\n    URL url = new URL(serviceManager.getServiceURL(), \"greet\");\n    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n    Assert.assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());\n    String response;\n    try {\n      response = new String(ByteStreams.toByteArray(connection.getInputStream()), Charsets.UTF_8);\n    } finally {\n      connection.disconnect();\n    }\n    Assert.assertEquals(\"Hello 5!\", response);\n  }","commit_id":"16bf563c106f6e90cb5720c5ad16fda811cd5ca0","url":"https://github.com/caskdata/cdap"},{"original_method":"public boolean processAction(\n\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows PortletException {\n\n\t\tUploadPortletRequest uploadRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\n\t\tactionResponse.setRenderParameter(\"jspPage\", ParamUtil.getString(\n\t\t\tuploadRequest, \"jspPage\"));\n\n\t\tString definitionName =\n\t\t\tParamUtil.getString(uploadRequest, \"definitionName\");\n\t\tif (Validator.isNull(definitionName)) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, DefinitionNameException.class.getName());\n\t\t}\n\n\t\tString format = ParamUtil.getString(uploadRequest, \"format\");\n\t\tReportFormat reportFormat = null;\n\t\ttry {\n\t\t\treportFormat = ReportFormat.parse(format);\n\t\t}\n\t\tcatch (IllegalArgumentException e) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, DefinitionFormatException.class.getName());\n\t\t}\n\n\t\tString fileName = uploadRequest.getFileName(\"msgFile\");\n\t\tFile file = uploadRequest.getFile(\"msgFile\");\n\t\tif (Validator.isNull(fileName) || file.length() <= 0) {\n\t\t\tfileName = StringPool.BLANK;\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, DefinitionFileException.class.getName());\n\t\t}\n\n\t\ttry {\n\t\t\tString description =\n\t\t\t\tParamUtil.getString(uploadRequest, \"description\");\n\t\t\tString datasourceName =\n\t\t\t\tParamUtil.getString(uploadRequest, \"dataSourceName\");\n\t\t\tString reportParameters =\n\t\t\t\tParamUtil.getString(uploadRequest, \"reportParameters\");\n\n\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t(ThemeDisplay) uploadRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\t\t\tReportDefinition definition = null;\n\t\t\tif (SessionErrors.isEmpty(actionRequest)) {\n\t\t\t\tdefinition =\n\t\t\t\t\tReportDefinitionLocalServiceUtil.addReportDefinition(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(),\n\t\t\t\t\t\tthemeDisplay.getScopeGroupId(),\n\t\t\t\t\t\tthemeDisplay.getUserId(), definitionName, description,\n\t\t\t\t\t\tdatasourceName, reportFormat, fileName, file,\n\t\t\t\t\t\treportParameters);\n\t\t\t\tactionRequest.setAttribute(\"fileName\", fileName);\n\t\t\t\tSessionMessages.add(actionRequest, \"request_processed\");\n\t\t\t}else{\n\t\t\t\tdefinition = new ReportDefinitionImpl();\n\t\t\t\tdefinition.setDefinitionName(definitionName);\n\t\t\t\tdefinition.setDescription(description);\n\t\t\t\tdefinition.setDataSourceName(datasourceName);\n\t\t\t\tdefinition.setReportFormat(format.toString());\n\t\t\t\tdefinition.setReportParameters(reportParameters);\n\t\t\t}\n\n\t\t\tuploadRequest.setAttribute(\"definition\", definition);\n\t\t}\n\t\tcatch (PortalException e) {\n\t\t\t_log.error(e);\n\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t}\n\t\tcatch (SystemException e) {\n\t\t\t_log.error(e);\n\t\t\tthrow new PortletException(\"Unable to create new definition \", e);\n\t\t}\n\t\treturn false;\n\t}","id":78286,"modified_method":"public boolean processAction(\n\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows PortletException {\n\n\t\tUploadPortletRequest uploadRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\t\tString definitionName =\n\t\t\tParamUtil.getString(uploadRequest, \"definitionName\");\n\t\tString format = ParamUtil.getString(uploadRequest, \"format\");\n\t\tString fileName = uploadRequest.getFileName(\"msgFile\");\n\t\tFile file = uploadRequest.getFile(\"msgFile\");\n\t\tString description = ParamUtil.getString(uploadRequest, \"description\");\n\t\tString datasourceName =\n\t\t\tParamUtil.getString(uploadRequest, \"dataSourceName\");\n\t\tString reportParameters =\n\t\t\tParamUtil.getString(uploadRequest, \"reportParameters\");\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay) uploadRequest.getAttribute(WebKeys.THEME_DISPLAY);\n\t\tReportDefinition definition = null;\n\t\ttry {\n\t\t\tdefinition =\n\t\t\t\tReportDefinitionLocalServiceUtil.addReportDefinition(\n\t\t\t\t\tthemeDisplay.getCompanyId(),\n\t\t\t\t\tthemeDisplay.getScopeGroupId(), themeDisplay.getUserId(),\n\t\t\t\t\tdefinitionName, description, datasourceName, format,\n\t\t\t\t\tfileName, file, reportParameters);\n\t\t\tuploadRequest.setAttribute(\"fileName\", fileName);\n\t\t\tSessionMessages.add(uploadRequest, \"request_processed\");\n\t\t}\n\t\tcatch (PortalException e) {\n\t\t\tdefinition = new ReportDefinitionImpl();\n\t\t\tdefinition.setNew(true);\n\t\t\tdefinition.setDefinitionName(definitionName);\n\t\t\tdefinition.setDescription(description);\n\t\t\tdefinition.setDataSourceName(datasourceName);\n\t\t\tdefinition.setReportFormat(format);\n\t\t\tdefinition.setReportParameters(reportParameters);\n\n\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t}\n\t\tcatch (SystemException e) {\n\t\t\t_log.error(e);\n\t\t\tthrow new PortletException(\"Unable to create new definition \", e);\n\t\t}\n\t\tuploadRequest.setAttribute(\"definition\", definition);\n\t\tactionResponse.setRenderParameter(\"jspPage\", ParamUtil.getString(\n\t\t\tuploadRequest, \"jspPage\"));\n\t\treturn false;\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public String getAttachmentsDir() {\n\t\tif (_attachmentDirs == null) {\n\t\t\t_attachmentDirs = \"report_templates/\" + getDefinitionId();\n\t\t}\n\n\t\treturn _attachmentDirs;\n\t}","id":78287,"modified_method":"public String getAttachmentsDir() {\n\n\t\tif (_attachmentDirs == null) {\n\t\t\t_attachmentDirs = REPORT_TEMPLATES_DIRS + getDefinitionId();\n\t\t}\n\t\treturn _attachmentDirs;\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public com.liferay.bi.report.model.ReportDefinition updateReportDefinition(\n\t\tlong definitionId, java.lang.String definitionName,\n\t\tjava.lang.String description, java.lang.String datasourceName,\n\t\tcom.liferay.portal.kernel.bi.reporting.ReportFormat format,\n\t\tjava.lang.String reportParameters, java.lang.String fileName,\n\t\tjava.io.File file)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\tObject paramObj0 = new LongWrapper(definitionId);\n\n\t\tObject paramObj1 = ClpSerializer.translateInput(definitionName);\n\n\t\tif (definitionName == null) {\n\t\t\tparamObj1 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj2 = ClpSerializer.translateInput(description);\n\n\t\tif (description == null) {\n\t\t\tparamObj2 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj3 = ClpSerializer.translateInput(datasourceName);\n\n\t\tif (datasourceName == null) {\n\t\t\tparamObj3 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj4 = ClpSerializer.translateInput(format);\n\n\t\tif (format == null) {\n\t\t\tparamObj4 = new NullWrapper(\n\t\t\t\t\t\"com.liferay.portal.kernel.bi.reporting.ReportFormat\");\n\t\t}\n\n\t\tObject paramObj5 = ClpSerializer.translateInput(reportParameters);\n\n\t\tif (reportParameters == null) {\n\t\t\tparamObj5 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj6 = ClpSerializer.translateInput(fileName);\n\n\t\tif (fileName == null) {\n\t\t\tparamObj6 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj7 = ClpSerializer.translateInput(file);\n\n\t\tif (file == null) {\n\t\t\tparamObj7 = new NullWrapper(\"java.io.File\");\n\t\t}\n\n\t\tObject returnObj = null;\n\n\t\ttry {\n\t\t\treturnObj = _classLoaderProxy.invoke(\"updateReportDefinition\",\n\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\tparamObj0, paramObj1, paramObj2, paramObj3, paramObj4,\n\t\t\t\t\t\tparamObj5, paramObj6, paramObj7\n\t\t\t\t\t});\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (t instanceof com.liferay.portal.PortalException) {\n\t\t\t\tthrow (com.liferay.portal.PortalException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof com.liferay.portal.SystemException) {\n\t\t\t\tthrow (com.liferay.portal.SystemException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\tthrow (RuntimeException)t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new RuntimeException(t.getClass().getName() +\n\t\t\t\t\t\" is not a valid exception\");\n\t\t\t}\n\t\t}\n\n\t\treturn (com.liferay.bi.report.model.ReportDefinition)ClpSerializer.translateOutput(returnObj);\n\t}","id":78288,"modified_method":"public com.liferay.bi.report.model.ReportDefinition updateReportDefinition(\n\t\tlong definitionId, java.lang.String definitionName,\n\t\tjava.lang.String description, java.lang.String datasourceName,\n\t\tjava.lang.String format, java.lang.String reportParameters,\n\t\tjava.lang.String fileName, java.io.File file)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\tObject paramObj0 = new LongWrapper(definitionId);\n\n\t\tObject paramObj1 = ClpSerializer.translateInput(definitionName);\n\n\t\tif (definitionName == null) {\n\t\t\tparamObj1 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj2 = ClpSerializer.translateInput(description);\n\n\t\tif (description == null) {\n\t\t\tparamObj2 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj3 = ClpSerializer.translateInput(datasourceName);\n\n\t\tif (datasourceName == null) {\n\t\t\tparamObj3 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj4 = ClpSerializer.translateInput(format);\n\n\t\tif (format == null) {\n\t\t\tparamObj4 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj5 = ClpSerializer.translateInput(reportParameters);\n\n\t\tif (reportParameters == null) {\n\t\t\tparamObj5 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj6 = ClpSerializer.translateInput(fileName);\n\n\t\tif (fileName == null) {\n\t\t\tparamObj6 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj7 = ClpSerializer.translateInput(file);\n\n\t\tif (file == null) {\n\t\t\tparamObj7 = new NullWrapper(\"java.io.File\");\n\t\t}\n\n\t\tObject returnObj = null;\n\n\t\ttry {\n\t\t\treturnObj = _classLoaderProxy.invoke(\"updateReportDefinition\",\n\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\tparamObj0, paramObj1, paramObj2, paramObj3, paramObj4,\n\t\t\t\t\t\tparamObj5, paramObj6, paramObj7\n\t\t\t\t\t});\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (t instanceof com.liferay.portal.PortalException) {\n\t\t\t\tthrow (com.liferay.portal.PortalException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof com.liferay.portal.SystemException) {\n\t\t\t\tthrow (com.liferay.portal.SystemException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\tthrow (RuntimeException)t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new RuntimeException(t.getClass().getName() +\n\t\t\t\t\t\" is not a valid exception\");\n\t\t\t}\n\t\t}\n\n\t\treturn (com.liferay.bi.report.model.ReportDefinition)ClpSerializer.translateOutput(returnObj);\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public com.liferay.bi.report.model.ReportDefinition updateReportDefinition(\n\t\tlong definitionId, java.lang.String definitionName,\n\t\tjava.lang.String description, java.lang.String datasourceName,\n\t\tcom.liferay.portal.kernel.bi.reporting.ReportFormat format,\n\t\tjava.lang.String reportParameters)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\tObject paramObj0 = new LongWrapper(definitionId);\n\n\t\tObject paramObj1 = ClpSerializer.translateInput(definitionName);\n\n\t\tif (definitionName == null) {\n\t\t\tparamObj1 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj2 = ClpSerializer.translateInput(description);\n\n\t\tif (description == null) {\n\t\t\tparamObj2 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj3 = ClpSerializer.translateInput(datasourceName);\n\n\t\tif (datasourceName == null) {\n\t\t\tparamObj3 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj4 = ClpSerializer.translateInput(format);\n\n\t\tif (format == null) {\n\t\t\tparamObj4 = new NullWrapper(\n\t\t\t\t\t\"com.liferay.portal.kernel.bi.reporting.ReportFormat\");\n\t\t}\n\n\t\tObject paramObj5 = ClpSerializer.translateInput(reportParameters);\n\n\t\tif (reportParameters == null) {\n\t\t\tparamObj5 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject returnObj = null;\n\n\t\ttry {\n\t\t\treturnObj = _classLoaderProxy.invoke(\"updateReportDefinition\",\n\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\tparamObj0, paramObj1, paramObj2, paramObj3, paramObj4,\n\t\t\t\t\t\tparamObj5\n\t\t\t\t\t});\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (t instanceof com.liferay.portal.PortalException) {\n\t\t\t\tthrow (com.liferay.portal.PortalException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof com.liferay.portal.SystemException) {\n\t\t\t\tthrow (com.liferay.portal.SystemException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\tthrow (RuntimeException)t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new RuntimeException(t.getClass().getName() +\n\t\t\t\t\t\" is not a valid exception\");\n\t\t\t}\n\t\t}\n\n\t\treturn (com.liferay.bi.report.model.ReportDefinition)ClpSerializer.translateOutput(returnObj);\n\t}","id":78289,"modified_method":"public com.liferay.bi.report.model.ReportDefinition updateReportDefinition(\n\t\tlong definitionId, java.lang.String definitionName,\n\t\tjava.lang.String description, java.lang.String datasourceName,\n\t\tjava.lang.String format, java.lang.String reportParameters)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\tObject paramObj0 = new LongWrapper(definitionId);\n\n\t\tObject paramObj1 = ClpSerializer.translateInput(definitionName);\n\n\t\tif (definitionName == null) {\n\t\t\tparamObj1 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj2 = ClpSerializer.translateInput(description);\n\n\t\tif (description == null) {\n\t\t\tparamObj2 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj3 = ClpSerializer.translateInput(datasourceName);\n\n\t\tif (datasourceName == null) {\n\t\t\tparamObj3 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj4 = ClpSerializer.translateInput(format);\n\n\t\tif (format == null) {\n\t\t\tparamObj4 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj5 = ClpSerializer.translateInput(reportParameters);\n\n\t\tif (reportParameters == null) {\n\t\t\tparamObj5 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject returnObj = null;\n\n\t\ttry {\n\t\t\treturnObj = _classLoaderProxy.invoke(\"updateReportDefinition\",\n\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\tparamObj0, paramObj1, paramObj2, paramObj3, paramObj4,\n\t\t\t\t\t\tparamObj5\n\t\t\t\t\t});\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (t instanceof com.liferay.portal.PortalException) {\n\t\t\t\tthrow (com.liferay.portal.PortalException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof com.liferay.portal.SystemException) {\n\t\t\t\tthrow (com.liferay.portal.SystemException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\tthrow (RuntimeException)t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new RuntimeException(t.getClass().getName() +\n\t\t\t\t\t\" is not a valid exception\");\n\t\t\t}\n\t\t}\n\n\t\treturn (com.liferay.bi.report.model.ReportDefinition)ClpSerializer.translateOutput(returnObj);\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public com.liferay.bi.report.model.ReportDefinition addReportDefinition(\n\t\tlong companyId, long groupId, long userId,\n\t\tjava.lang.String definitionName, java.lang.String description,\n\t\tjava.lang.String datasourceName,\n\t\tcom.liferay.portal.kernel.bi.reporting.ReportFormat format,\n\t\tjava.lang.String fileName, java.io.File file,\n\t\tjava.lang.String reportParameters)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\tObject paramObj0 = new LongWrapper(companyId);\n\n\t\tObject paramObj1 = new LongWrapper(groupId);\n\n\t\tObject paramObj2 = new LongWrapper(userId);\n\n\t\tObject paramObj3 = ClpSerializer.translateInput(definitionName);\n\n\t\tif (definitionName == null) {\n\t\t\tparamObj3 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj4 = ClpSerializer.translateInput(description);\n\n\t\tif (description == null) {\n\t\t\tparamObj4 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj5 = ClpSerializer.translateInput(datasourceName);\n\n\t\tif (datasourceName == null) {\n\t\t\tparamObj5 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj6 = ClpSerializer.translateInput(format);\n\n\t\tif (format == null) {\n\t\t\tparamObj6 = new NullWrapper(\n\t\t\t\t\t\"com.liferay.portal.kernel.bi.reporting.ReportFormat\");\n\t\t}\n\n\t\tObject paramObj7 = ClpSerializer.translateInput(fileName);\n\n\t\tif (fileName == null) {\n\t\t\tparamObj7 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj8 = ClpSerializer.translateInput(file);\n\n\t\tif (file == null) {\n\t\t\tparamObj8 = new NullWrapper(\"java.io.File\");\n\t\t}\n\n\t\tObject paramObj9 = ClpSerializer.translateInput(reportParameters);\n\n\t\tif (reportParameters == null) {\n\t\t\tparamObj9 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject returnObj = null;\n\n\t\ttry {\n\t\t\treturnObj = _classLoaderProxy.invoke(\"addReportDefinition\",\n\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\tparamObj0, paramObj1, paramObj2, paramObj3, paramObj4,\n\t\t\t\t\t\tparamObj5, paramObj6, paramObj7, paramObj8, paramObj9\n\t\t\t\t\t});\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (t instanceof com.liferay.portal.PortalException) {\n\t\t\t\tthrow (com.liferay.portal.PortalException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof com.liferay.portal.SystemException) {\n\t\t\t\tthrow (com.liferay.portal.SystemException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\tthrow (RuntimeException)t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new RuntimeException(t.getClass().getName() +\n\t\t\t\t\t\" is not a valid exception\");\n\t\t\t}\n\t\t}\n\n\t\treturn (com.liferay.bi.report.model.ReportDefinition)ClpSerializer.translateOutput(returnObj);\n\t}","id":78290,"modified_method":"public com.liferay.bi.report.model.ReportDefinition addReportDefinition(\n\t\tlong companyId, long groupId, long userId,\n\t\tjava.lang.String definitionName, java.lang.String description,\n\t\tjava.lang.String datasourceName, java.lang.String format,\n\t\tjava.lang.String fileName, java.io.File file,\n\t\tjava.lang.String reportParameters)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\tObject paramObj0 = new LongWrapper(companyId);\n\n\t\tObject paramObj1 = new LongWrapper(groupId);\n\n\t\tObject paramObj2 = new LongWrapper(userId);\n\n\t\tObject paramObj3 = ClpSerializer.translateInput(definitionName);\n\n\t\tif (definitionName == null) {\n\t\t\tparamObj3 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj4 = ClpSerializer.translateInput(description);\n\n\t\tif (description == null) {\n\t\t\tparamObj4 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj5 = ClpSerializer.translateInput(datasourceName);\n\n\t\tif (datasourceName == null) {\n\t\t\tparamObj5 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj6 = ClpSerializer.translateInput(format);\n\n\t\tif (format == null) {\n\t\t\tparamObj6 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj7 = ClpSerializer.translateInput(fileName);\n\n\t\tif (fileName == null) {\n\t\t\tparamObj7 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject paramObj8 = ClpSerializer.translateInput(file);\n\n\t\tif (file == null) {\n\t\t\tparamObj8 = new NullWrapper(\"java.io.File\");\n\t\t}\n\n\t\tObject paramObj9 = ClpSerializer.translateInput(reportParameters);\n\n\t\tif (reportParameters == null) {\n\t\t\tparamObj9 = new NullWrapper(\"java.lang.String\");\n\t\t}\n\n\t\tObject returnObj = null;\n\n\t\ttry {\n\t\t\treturnObj = _classLoaderProxy.invoke(\"addReportDefinition\",\n\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\tparamObj0, paramObj1, paramObj2, paramObj3, paramObj4,\n\t\t\t\t\t\tparamObj5, paramObj6, paramObj7, paramObj8, paramObj9\n\t\t\t\t\t});\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tif (t instanceof com.liferay.portal.PortalException) {\n\t\t\t\tthrow (com.liferay.portal.PortalException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof com.liferay.portal.SystemException) {\n\t\t\t\tthrow (com.liferay.portal.SystemException)t;\n\t\t\t}\n\n\t\t\tif (t instanceof RuntimeException) {\n\t\t\t\tthrow (RuntimeException)t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new RuntimeException(t.getClass().getName() +\n\t\t\t\t\t\" is not a valid exception\");\n\t\t\t}\n\t\t}\n\n\t\treturn (com.liferay.bi.report.model.ReportDefinition)ClpSerializer.translateOutput(returnObj);\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public ReportDefinition addReportDefinition(\n\t\tlong companyId, long groupId, long userId, String definitionName,\n\t\tString description, String datasourceName, ReportFormat format,\n\t\tString fileName, File file, String reportParameters)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong definitionId = CounterLocalServiceUtil.increment();\n\t\tReportDefinition definition =\n\t\t\treportDefinitionPersistence.create(definitionId);\n\t\tdefinition.setCompanyId(companyId);\n\t\tdefinition.setGroupId(groupId);\n\t\tdefinition.setUserId(userId);\n\t\tdefinition.setDefinitionName(definitionName);\n\t\tdefinition.setDescription(description);\n\t\tdefinition.setDataSourceName(datasourceName);\n\t\tdefinition.setReportFormat(format.toString());\n\t\tdefinition.setReportParameters(reportParameters);\n\n\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\tlong repositoryId = 0;\n\t\tlong fileEntryId = 0;\n\t\tString properties = StringPool.BLANK;\n\t\tDate modifiedDate = new Date();\n\t\tString[] tagsCategories = new String[0];\n\t\tString[] tagsEntries = new String[0];\n\n\t\tDLServiceUtil.addDirectory(\n\t\t\tcompanyId, repositoryId, definition.getAttachmentsDir());\n\n\t\tDLServiceUtil.addFile(\n\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\tdefinition.getAttachmentsDir() + StringPool.SLASH + fileName,\n\t\t\tfileEntryId, properties, modifiedDate, tagsCategories, tagsEntries,\n\t\t\tfile);\n\n\t\treturn addReportDefinition(definition);\n\t}","id":78291,"modified_method":"public ReportDefinition addReportDefinition(\n\t\tlong companyId, long groupId, long userId, String definitionName,\n\t\tString description, String datasourceName, String format,\n\t\tString fileName, File file, String reportParameters)\n\t\tthrows PortalException, SystemException {\n\n\t\tlong definitionId = CounterLocalServiceUtil.increment();\n\t\tReportDefinition definition =\n\t\t\treportDefinitionPersistence.create(definitionId);\n\t\tdefinition.setCompanyId(companyId);\n\t\tdefinition.setGroupId(groupId);\n\t\tdefinition.setUserId(userId);\n\t\tdefinition.setDefinitionName(definitionName);\n\t\tdefinition.setDescription(description);\n\t\tdefinition.setDataSourceName(datasourceName);\n\t\tdefinition.setReportFormat(format);\n\t\tdefinition.setReportParameters(reportParameters);\n\n\t\tvalidate(definition);\n\n\t\tif (Validator.isNull(fileName)) {\n\t\t\tthrow new DefinitionFileException();\n\t\t}\n\n\t\ttry {\n\t\t\tDLServiceUtil.addDirectory(\n\t\t\t\tcompanyId, repositoryId, definition.getAttachmentsDir());\n\t\t}\n\t\tcatch (DuplicateDirectoryException dde) {\n\t\t}\n\t\ttry {\n\t\t\tDLServiceUtil.addFile(\n\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\tdefinition.getAttachmentsDir() + StringPool.SLASH + fileName,\n\t\t\t\tfileEntryId, properties, modifiedDate, tagsCategories,\n\t\t\t\ttagsEntries, file);\n\t\t}\n\t\tcatch (PortalException e) {\n\t\t\tDLServiceUtil.deleteDirectory(\n\t\t\t\tcompanyId, portletId, repositoryId,\n\t\t\t\tdefinition.getAttachmentsDir());\n\t\t\tthrow new DefinitionFileException();\n\t\t}\n\n\t\treturn addReportDefinition(definition);\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public ReportDefinition updateReportDefinition(\n\t\tlong definitionId, String definitionName, String description,\n\t\tString datasourceName, ReportFormat format, String reportParameters)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn updateReportDefinition(\n\t\t\tdefinitionId, definitionName, description, datasourceName, format,\n\t\t\treportParameters, null, null);\n\t}","id":78292,"modified_method":"public ReportDefinition updateReportDefinition(\n\t\tlong definitionId, String definitionName, String description,\n\t\tString datasourceName, String format, String reportParameters)\n\t\tthrows PortalException, SystemException {\n\n\t\tReportDefinition definition = getReportDefinition(definitionId);\n\t\tdefinition.setDefinitionName(definitionName);\n\t\tdefinition.setDescription(description);\n\t\tdefinition.setDataSourceName(datasourceName);\n\t\tdefinition.setReportFormat(format);\n\t\tdefinition.setReportParameters(reportParameters);\n\n\t\tvalidate(definition);\n\n\t\treturn updateReportDefinition(definition);\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public ReportDefinition updateReportDefinition(\n\t\tlong definitionId, String definitionName, String description,\n\t\tString datasourceName, ReportFormat format, String reportParameters,\n\t\tString fileName, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tReportDefinition definition = getReportDefinition(definitionId);\n\t\tdefinition.setDefinitionName(definitionName);\n\t\tdefinition.setDescription(description);\n\t\tdefinition.setDataSourceName(datasourceName);\n\t\tdefinition.setReportFormat(format.toString());\n\t\tdefinition.setReportParameters(reportParameters);\n\n\t\tif (Validator.isNotNull(fileName)) {\n\t\t\tString[] existingAttachments =\n\t\t\t\tDLServiceUtil.getFileNames(\n\t\t\t\t\tdefinition.getCompanyId(), CompanyConstants.SYSTEM,\n\t\t\t\t\tdefinition.getAttachmentsDir());\n\t\t\tfor (String attachment : existingAttachments) {\n\t\t\t\tDLServiceUtil.deleteFile(\n\t\t\t\t\tdefinition.getCompanyId(), CompanyConstants.SYSTEM_STRING,\n\t\t\t\t\tCompanyConstants.SYSTEM, attachment);\n\t\t\t}\n\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = 0;\n\t\t\tlong fileEntryId = 0;\n\t\t\tString properties = StringPool.BLANK;\n\t\t\tDate modifiedDate = new Date();\n\t\t\tString[] tagsCategories = new String[0];\n\t\t\tString[] tagsEntries = new String[0];\n\n\t\t\tDLServiceUtil.addFile(\n\t\t\t\tdefinition.getCompanyId(), portletId, definition.getGroupId(),\n\t\t\t\trepositoryId, definition.getAttachmentsDir() +\n\t\t\t\t\tStringPool.SLASH + fileName, fileEntryId, properties,\n\t\t\t\tmodifiedDate, tagsCategories, tagsEntries, file);\n\t\t}\n\n\t\treturn updateReportDefinition(definition);\n\t}","id":78293,"modified_method":"public ReportDefinition updateReportDefinition(\n\t\tlong definitionId, String definitionName, String description,\n\t\tString datasourceName, String format, String reportParameters,\n\t\tString fileName, File file)\n\t\tthrows PortalException, SystemException {\n\n\t\tReportDefinition definition = getReportDefinition(definitionId);\n\t\tdefinition.setDefinitionName(definitionName);\n\t\tdefinition.setDescription(description);\n\t\tdefinition.setDataSourceName(datasourceName);\n\t\tdefinition.setReportFormat(format);\n\t\tdefinition.setReportParameters(reportParameters);\n\n\t\tvalidate(definition);\n\n\t\tif (Validator.isNull(fileName)) {\n\t\t\tthrow new DefinitionFileException();\n\t\t}\n\n\t\tfileName = definition.getAttachmentsDir() + StringPool.SLASH + fileName;\n\n\t\ttry {\n\t\t\tDLServiceUtil.addFile(\n\t\t\t\tdefinition.getCompanyId(), portletId, definition.getGroupId(),\n\t\t\t\trepositoryId, fileName, fileEntryId, properties, modifiedDate,\n\t\t\t\ttagsCategories, tagsEntries, file);\n\t\t}\n\t\tcatch (DuplicateFileException e) {\n\t\t}\n\t\tcatch (PortalException e) {\n\t\t\tthrow new DefinitionFileException();\n\t\t}\n\n\t\tString[] existingFiles = definition.getAttachmentsFiles();\n\t\tfor (String existingFile : existingFiles) {\n\t\t\tif (fileName != existingFile) {\n\t\t\t\tDLServiceUtil.deleteFile(\n\t\t\t\t\tdefinition.getCompanyId(), portletId, repositoryId,\n\t\t\t\t\texistingFile);\n\t\t\t}\n\t\t}\n\n\t\treturn updateReportDefinition(definition);\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static com.liferay.bi.report.model.ReportDefinition addReportDefinition(\n\t\tlong companyId, long groupId, long userId,\n\t\tjava.lang.String definitionName, java.lang.String description,\n\t\tjava.lang.String datasourceName,\n\t\tcom.liferay.portal.kernel.bi.reporting.ReportFormat format,\n\t\tjava.lang.String fileName, java.io.File file,\n\t\tjava.lang.String reportParameters)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\treturn getService()\n\t\t\t\t   .addReportDefinition(companyId, groupId, userId,\n\t\t\tdefinitionName, description, datasourceName, format, fileName,\n\t\t\tfile, reportParameters);\n\t}","id":78294,"modified_method":"public static com.liferay.bi.report.model.ReportDefinition addReportDefinition(\n\t\tlong companyId, long groupId, long userId,\n\t\tjava.lang.String definitionName, java.lang.String description,\n\t\tjava.lang.String datasourceName, java.lang.String format,\n\t\tjava.lang.String fileName, java.io.File file,\n\t\tjava.lang.String reportParameters)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\treturn getService()\n\t\t\t\t   .addReportDefinition(companyId, groupId, userId,\n\t\t\tdefinitionName, description, datasourceName, format, fileName,\n\t\t\tfile, reportParameters);\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static com.liferay.bi.report.model.ReportDefinition updateReportDefinition(\n\t\tlong definitionId, java.lang.String definitionName,\n\t\tjava.lang.String description, java.lang.String datasourceName,\n\t\tcom.liferay.portal.kernel.bi.reporting.ReportFormat format,\n\t\tjava.lang.String reportParameters, java.lang.String fileName,\n\t\tjava.io.File file)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\treturn getService()\n\t\t\t\t   .updateReportDefinition(definitionId, definitionName,\n\t\t\tdescription, datasourceName, format, reportParameters, fileName,\n\t\t\tfile);\n\t}","id":78295,"modified_method":"public static com.liferay.bi.report.model.ReportDefinition updateReportDefinition(\n\t\tlong definitionId, java.lang.String definitionName,\n\t\tjava.lang.String description, java.lang.String datasourceName,\n\t\tjava.lang.String format, java.lang.String reportParameters,\n\t\tjava.lang.String fileName, java.io.File file)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\treturn getService()\n\t\t\t\t   .updateReportDefinition(definitionId, definitionName,\n\t\t\tdescription, datasourceName, format, reportParameters, fileName,\n\t\t\tfile);\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static com.liferay.bi.report.model.ReportDefinition updateReportDefinition(\n\t\tlong definitionId, java.lang.String definitionName,\n\t\tjava.lang.String description, java.lang.String datasourceName,\n\t\tcom.liferay.portal.kernel.bi.reporting.ReportFormat format,\n\t\tjava.lang.String reportParameters)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\treturn getService()\n\t\t\t\t   .updateReportDefinition(definitionId, definitionName,\n\t\t\tdescription, datasourceName, format, reportParameters);\n\t}","id":78296,"modified_method":"public static com.liferay.bi.report.model.ReportDefinition updateReportDefinition(\n\t\tlong definitionId, java.lang.String definitionName,\n\t\tjava.lang.String description, java.lang.String datasourceName,\n\t\tjava.lang.String format, java.lang.String reportParameters)\n\t\tthrows com.liferay.portal.PortalException,\n\t\t\tcom.liferay.portal.SystemException {\n\t\treturn getService()\n\t\t\t\t   .updateReportDefinition(definitionId, definitionName,\n\t\t\tdescription, datasourceName, format, reportParameters);\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private String performUpdate(\n\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows PortalException, SystemException {\n\n\t\tString jspPage = ParamUtil.getString(actionRequest, \"jspPage\");\n\n\t\tlong definitionId = ParamUtil.getLong(actionRequest, \"definitionId\");\n\t\tif (definitionId <= 0) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, NoSuchDefinitionException.class.getName());\n\t\t}\n\t\tString definitionName =\n\t\t\tParamUtil.getString(actionRequest, \"definitionName\");\n\t\tif (Validator.isNull(definitionName)) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, DefinitionNameException.class.getName());\n\t\t}\n\n\t\tString format = ParamUtil.getString(actionRequest, \"format\");\n\t\tReportFormat reportFormat = null;\n\t\ttry {\n\t\t\treportFormat = ReportFormat.parse(format);\n\t\t}\n\t\tcatch (IllegalArgumentException e) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, DefinitionFormatException.class.getName());\n\t\t}\n\n\t\tString description = ParamUtil.getString(actionRequest, \"description\");\n\t\tString datasourceName =\n\t\t\tParamUtil.getString(actionRequest, \"dataSourceName\");\n\t\tString reportParameters =\n\t\t\tParamUtil.getString(actionRequest, \"reportParameters\");\n\n\t\tReportDefinition definition = null;\n\t\tif (SessionErrors.isEmpty(actionRequest)) {\n\t\t\tdefinition =\n\t\t\t\tReportDefinitionLocalServiceUtil.updateReportDefinition(\n\t\t\t\t\tdefinitionId, definitionName, description, datasourceName,\n\t\t\t\t\treportFormat, reportParameters);\n\t\t\tSessionMessages.add(actionRequest, \"request_processed\");\n\t\t}\n\t\telse {\n\t\t\tdefinition = new ReportDefinitionImpl();\n\t\t\tdefinition.setDefinitionId(definitionId);\n\t\t\tdefinition.setDefinitionName(definitionName);\n\t\t\tdefinition.setDescription(description);\n\t\t\tdefinition.setDataSourceName(datasourceName);\n\t\t\tdefinition.setReportFormat(format.toString());\n\t\t\tdefinition.setReportParameters(reportParameters);\n\t\t}\n\n\t\tactionRequest.setAttribute(\"fileName\", ParamUtil.getString(\n\t\t\tactionRequest, \"fileName\"));\n\t\tactionRequest.setAttribute(\"definition\", definition);\n\t\treturn jspPage;\n\t}","id":78297,"modified_method":"private String performUpdate(\n\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows PortalException, SystemException {\n\n\t\tString jspPage = ParamUtil.getString(actionRequest, \"jspPage\");\n\n\t\tlong definitionId = ParamUtil.getLong(actionRequest, \"definitionId\");\n\t\tString definitionName =\n\t\t\tParamUtil.getString(actionRequest, \"definitionName\");\n\t\tString format = ParamUtil.getString(actionRequest, \"format\");\n\t\tString description = ParamUtil.getString(actionRequest, \"description\");\n\t\tString datasourceName =\n\t\t\tParamUtil.getString(actionRequest, \"dataSourceName\");\n\t\tString reportParameters =\n\t\t\tParamUtil.getString(actionRequest, \"reportParameters\");\n\n\t\tReportDefinition definition = null;\n\t\ttry {\n\t\t\tdefinition =\n\t\t\t\tReportDefinitionLocalServiceUtil.updateReportDefinition(\n\t\t\t\t\tdefinitionId, definitionName, description, datasourceName,\n\t\t\t\t\tformat, reportParameters);\n\t\t\t\n\t\t\tSessionMessages.add(actionRequest, \"request_processed\");\n\t\t}\n\t\tcatch (PortalException e) {\n\t\t\tdefinition = new ReportDefinitionImpl();\n\t\t\tdefinition.setDefinitionId(definitionId);\n\t\t\tdefinition.setDefinitionName(definitionName);\n\t\t\tdefinition.setDescription(description);\n\t\t\tdefinition.setDataSourceName(datasourceName);\n\t\t\tdefinition.setReportFormat(format.toString());\n\t\t\tdefinition.setReportParameters(reportParameters);\n\t\t\t\n\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\t\t}\n\n\t\tactionRequest.setAttribute(\"fileName\", ParamUtil.getString(\n\t\t\tactionRequest, \"fileName\"));\n\t\tactionRequest.setAttribute(\"definition\", definition);\n\t\treturn jspPage;\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private String performUpdateWithFileUpdated(\n\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows PortalException, SystemException {\n\n\t\tUploadPortletRequest uploadRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\t\tString jspPage = ParamUtil.getString(uploadRequest, \"jspPage\");\n\n\t\tlong definitionId = ParamUtil.getLong(uploadRequest, \"definitionId\");\n\t\tif (definitionId <= 0) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, NoSuchDefinitionException.class.getName());\n\t\t}\n\n\t\tString definitionName =\n\t\t\tParamUtil.getString(uploadRequest, \"definitionName\");\n\t\tif (Validator.isNull(definitionName)) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, DefinitionNameException.class.getName());\n\t\t}\n\n\t\tString format = ParamUtil.getString(uploadRequest, \"format\");\n\t\tReportFormat reportFormat = null;\n\t\ttry {\n\t\t\treportFormat = ReportFormat.parse(format);\n\t\t}\n\t\tcatch (IllegalArgumentException e) {\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, DefinitionFormatException.class.getName());\n\t\t}\n\n\t\tString fileName = uploadRequest.getFileName(\"msgFile\");\n\t\tFile file = uploadRequest.getFile(\"msgFile\");\n\t\tif (Validator.isNull(fileName) || file.length() <= 0) {\n\t\t\tfileName = StringPool.BLANK;\n\t\t\tSessionErrors.add(\n\t\t\t\tactionRequest, DefinitionFileException.class.getName());\n\t\t}\n\n\t\tString description = ParamUtil.getString(uploadRequest, \"description\");\n\t\tString datasourceName =\n\t\t\tParamUtil.getString(uploadRequest, \"dataSourceName\");\n\n\t\tString reportParameters =\n\t\t\tParamUtil.getString(uploadRequest, \"reportParameters\");\n\n\t\tReportDefinition definition = null;\n\t\tif (SessionErrors.isEmpty(actionRequest)) {\n\t\t\tdefinition =\n\t\t\t\tReportDefinitionLocalServiceUtil.updateReportDefinition(\n\t\t\t\t\tdefinitionId, definitionName, description, datasourceName,\n\t\t\t\t\treportFormat, reportParameters, fileName, file);\n\t\t\tSessionMessages.add(actionRequest, \"request_processed\");\n\t\t}\n\t\telse {\n\t\t\tdefinition = new ReportDefinitionImpl();\n\t\t\tdefinition.setDefinitionId(definitionId);\n\t\t\tdefinition.setDefinitionName(definitionName);\n\t\t\tdefinition.setDescription(description);\n\t\t\tdefinition.setDataSourceName(datasourceName);\n\t\t\tdefinition.setReportFormat(format.toString());\n\t\t\tdefinition.setReportParameters(reportParameters);\n\t\t}\n\n\t\tuploadRequest.setAttribute(\"fileName\", fileName);\n\t\tuploadRequest.setAttribute(\"definition\", definition);\n\t\treturn jspPage;\n\n\t}","id":78298,"modified_method":"private String performUpdateWithFileUpdated(\n\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows PortalException, SystemException {\n\t\t\n\t\tUploadPortletRequest uploadRequest =\n\t\t\tPortalUtil.getUploadPortletRequest(actionRequest);\n\t\tString jspPage = ParamUtil.getString(uploadRequest, \"jspPage\");\n\n\t\tlong definitionId = ParamUtil.getLong(uploadRequest, \"definitionId\");\n\t\tString definitionName =\n\t\t\tParamUtil.getString(uploadRequest, \"definitionName\");\n\t\tString format = ParamUtil.getString(uploadRequest, \"format\");\n\t\tString fileName = uploadRequest.getFileName(\"msgFile\");\n\t\tFile file = uploadRequest.getFile(\"msgFile\");\n\t\tString description = ParamUtil.getString(uploadRequest, \"description\");\n\t\tString datasourceName =\n\t\t\tParamUtil.getString(uploadRequest, \"dataSourceName\");\n\t\tString reportParameters =\n\t\t\tParamUtil.getString(uploadRequest, \"reportParameters\");\n\n\t\tReportDefinition definition = null;\n\t\ttry {\n\t\t\tdefinition =\n\t\t\t\tReportDefinitionLocalServiceUtil.updateReportDefinition(\n\t\t\t\t\tdefinitionId, definitionName, description, datasourceName,\n\t\t\t\t\tformat, reportParameters, fileName, file);\n\t\t\tSessionMessages.add(actionRequest, \"request_processed\");\n\t\t}\n\t\tcatch (PortalException e) {\n\t\t\tdefinition = new ReportDefinitionImpl();\n\t\t\tdefinition.setDefinitionId(definitionId);\n\t\t\tdefinition.setDefinitionName(definitionName);\n\t\t\tdefinition.setDescription(description);\n\t\t\tdefinition.setDataSourceName(datasourceName);\n\t\t\tdefinition.setReportFormat(format.toString());\n\t\t\tdefinition.setReportParameters(reportParameters);\n\t\t\t\n\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\t\t\t\n\t\t}\n\n\t\tuploadRequest.setAttribute(\"fileName\", fileName);\n\t\tuploadRequest.setAttribute(\"definition\", definition);\n\t\treturn jspPage;\n\n\t}","commit_id":"36b5d73ce27978c6804b31c0b59816502635f16e","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static Map<ThreadLocal<?>, Object> getShortLivedThreadLocals() {\r\n\t\treturn _shortLivedThreadLocals.get();\r\n\t}","id":78299,"modified_method":"public static Map<CentralizedThreadLocal<?>, Object>\n\t\tgetShortLivedThreadLocals() {\n\n\t\treturn _toMap(_shortLivedThreadLocals.get());\n\t}","commit_id":"0f6205bdb3eceb997ee2015c8f943770d6d16691","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\r\n\tpublic void remove() {\r\n\t\tMap<ThreadLocal<?>, Object> threadLocals = _getThreadLocals();\r\n\r\n\t\tthreadLocals.remove(this);\r\n\t}","id":78300,"modified_method":"@Override\r\n\tpublic void remove() {\r\n\t\tThreadLocalMap threadLocals = _getThreadLocals();\n\r\n\t\tthreadLocals.removeEntry(this);\n\t}","commit_id":"0f6205bdb3eceb997ee2015c8f943770d6d16691","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Map<ThreadLocal<?>, Object> getLongLivedThreadLocals() {\r\n\t\treturn _longLivedThreadLocals.get();\r\n\t}","id":78301,"modified_method":"public static Map<CentralizedThreadLocal<?>, Object>\n\t\tgetLongLivedThreadLocals() {\n\n\t\treturn _toMap(_longLivedThreadLocals.get());\n\t}","commit_id":"0f6205bdb3eceb997ee2015c8f943770d6d16691","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\r\n\tpublic void set(T value) {\r\n\t\tMap<ThreadLocal<?>, Object> threadLocals = _getThreadLocals();\r\n\r\n\t\tif (value == null) {\r\n\t\t\tthreadLocals.put(this, _nullHolder);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthreadLocals.put(this, value);\r\n\t\t}\r\n\t}","id":78302,"modified_method":"@Override\r\n\tpublic void set(T value) {\r\n\t\tThreadLocalMap threadLocals = _getThreadLocals();\n\r\n\t\tthreadLocals.putEntry(this, value);\n\t}","commit_id":"0f6205bdb3eceb997ee2015c8f943770d6d16691","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\r\n\t\tprotected Map<ThreadLocal<?>, Object> initialValue() {\r\n\t\t\treturn new HashMap<ThreadLocal<?>, Object>();\r\n\t\t}","id":78303,"modified_method":"@Override\r\n\t\tprotected ThreadLocalMap initialValue() {\n\t\t\treturn new ThreadLocalMap();\n\t\t}","commit_id":"0f6205bdb3eceb997ee2015c8f943770d6d16691","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\r\n\tpublic T get() {\r\n\t\tMap<ThreadLocal<?>, Object> threadLocals = _getThreadLocals();\r\n\r\n\t\tT value = (T)threadLocals.get(this);\r\n\r\n\t\tif (value == _nullHolder) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tif (value == null) {\r\n\t\t\tvalue = initialValue();\r\n\r\n\t\t\tif (value == null) {\r\n\t\t\t\tthreadLocals.put(this, _nullHolder);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthreadLocals.put(this, value);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t}","id":78304,"modified_method":"@Override\r\n\tpublic T get() {\r\n\t\tThreadLocalMap threadLocals = _getThreadLocals();\n\r\n\t\tEntry entry = threadLocals.getEntry(this);\n\r\n\t\tif (entry == null) {\n\t\t\tT value = initialValue();\n\r\n\t\t\tthreadLocals.putEntry(this, value);\n\r\n\t\t\treturn value;\n\t\t}\r\n\t\telse {\n\t\t\treturn (T)entry._value;\n\t\t}\n\t}","commit_id":"0f6205bdb3eceb997ee2015c8f943770d6d16691","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void setThreadLocals(\r\n\t\tMap<ThreadLocal<?>, Object> longLivedThreadLocals,\r\n\t\tMap<ThreadLocal<?>, Object> shortLivedThreadLocals) {\r\n\r\n\t\t_longLivedThreadLocals.set(longLivedThreadLocals);\r\n\t\t_shortLivedThreadLocals.set(shortLivedThreadLocals);\r\n\t}","id":78305,"modified_method":"public static void setThreadLocals(\r\n\t\tMap<CentralizedThreadLocal<?>, Object> longLivedThreadLocals,\n\t\tMap<CentralizedThreadLocal<?>, Object> shortLivedThreadLocals) {\n\n\t\tThreadLocalMap threadLocals = _longLivedThreadLocals.get();\n\n\t\tfor (Map.Entry<CentralizedThreadLocal<?>, Object> entry :\n\t\t\tlongLivedThreadLocals.entrySet()) {\n\n\t\t\tthreadLocals.putEntry(entry.getKey(), entry.getValue());\n\t\t}\n\n\t\tthreadLocals = _shortLivedThreadLocals.get();\n\n\t\tfor (Map.Entry<CentralizedThreadLocal<?>, Object> entry :\n\t\t\tshortLivedThreadLocals.entrySet()) {\n\n\t\t\tthreadLocals.putEntry(entry.getKey(), entry.getValue());\n\t\t}\n\t}","commit_id":"0f6205bdb3eceb997ee2015c8f943770d6d16691","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Places a key/value pair into one or several nodes in the cluster.\n     * @param key The key, needs to be serializable\n     * @param val The value, needs to be serializable\n     * @param repl_count Number of replicas. The total number of times a data item should be present in a cluster.\n     * Needs to be &gt; 0\n     * <ul>\n     * <li>-1: create key/val in all the nodes in the cluster\n     * <li>0: create key/val only in one node in the cluster, picked by computing the consistent hash of KEY\n     * <li>K &gt; 0: create key/val in those nodes in the cluster which match the consistent hashes created for KEY\n     * <\/ul>\n     * @param timeout Expiration time for key/value.\n     * <ul>\n     * <li>-1: don't cache at all in the L1 cache\n     * <li>0: cache forever, until removed or evicted because we need space for newer elements\n     * <li>&gt; 0: number of milliseconds to keep an idle element in the cache. An element is idle when not accessed.\n     * <\/ul>\n     */\n    @ManagedOperation\n    public void put(K key, V val, short repl_count, long timeout) {\n        sendPut(null, key, val, repl_count, timeout, false);\n        if(l1_cache != null && timeout >= 0)\n            l1_cache.put(key, val, timeout);\n    }","id":78306,"modified_method":"/**\n     * Places a key/value pair into one or several nodes in the cluster.\n     * @param key The key, needs to be serializable\n     * @param val The value, needs to be serializable\n     * @param repl_count Number of replicas. The total number of times a data item should be present in a cluster.\n     * Needs to be &gt; 0\n     * <ul>\n     * <li>-1: create key/val in all the nodes in the cluster\n     * <li>0: create key/val only in one node in the cluster, picked by computing the consistent hash of KEY\n     * <li>K &gt; 0: create key/val in those nodes in the cluster which match the consistent hashes created for KEY\n     * <\/ul>\n     * @param timeout Expiration time for key/value.\n     * <ul>\n     * <li>-1: don't cache at all in the L1 cache\n     * <li>0: cache forever, until removed or evicted because we need space for newer elements\n     * <li>&gt; 0: number of milliseconds to keep an idle element in the cache. An element is idle when not accessed.\n     * <\/ul>\n     */\n    @ManagedOperation\n    public void put(K key, V val, short repl_count, long timeout) {\n        sendPut(key, val, repl_count, timeout, false);\n        if(l1_cache != null && timeout >= 0)\n            l1_cache.put(key, val, timeout);\n    }","commit_id":"a1461fdee09cc406642e0e91fd82cbdb753abd34","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n            return \"val=\" + val + \", replication_count=\" + replication_count;\n        }","id":78307,"modified_method":"public String toString() {\n            return val + \" (replication_count=\" + replication_count + \")\";\n        }","commit_id":"a1461fdee09cc406642e0e91fd82cbdb753abd34","url":"https://github.com/belaban/JGroups"},{"original_method":"public V _remove(K key) {\n        if(log.isTraceEnabled())\n            log.trace(\"_remove(\" + key + \")\");\n        Value<V> retval=l2_cache.remove(key);\n        return retval != null? retval.getVal() : null;\n    }","id":78308,"modified_method":"public V _remove(K key) {\n        if(log.isTraceEnabled())\n            log.trace(\"_remove(\" + key + \")\");\n        Value<V> retval=l2_cache.remove(key);\n        if(l1_cache != null)\n            l1_cache.remove(key);\n        return retval != null? retval.getVal() : null;\n    }","commit_id":"a1461fdee09cc406642e0e91fd82cbdb753abd34","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendPut(Address dest, K key, V val, short repl_count, long caching_time, boolean synchronous) {\n        try {\n            int mode=synchronous? GroupRequest.GET_ALL : GroupRequest.GET_NONE;\n            disp.callRemoteMethod(dest, new MethodCall(PUT, new Object[]{key, val, repl_count, caching_time}), mode, call_timeout);\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"put() failed\", t);\n        }\n    }","id":78309,"modified_method":"private void sendPut(K key, V val, short repl_count, long caching_time, boolean synchronous) {\n        try {\n            int mode=synchronous? GroupRequest.GET_ALL : GroupRequest.GET_NONE;\n            disp.callRemoteMethods(null, new MethodCall(PUT, new Object[]{key, val, repl_count, caching_time}), mode, call_timeout);\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"put() failed\", t);\n        }\n    }","commit_id":"a1461fdee09cc406642e0e91fd82cbdb753abd34","url":"https://github.com/belaban/JGroups"},{"original_method":"public V _put(K key, V val, short repl_count, long timeout) {\n\n        // check if we need to host the data\n        boolean accept=repl_count == -1;\n\n        if(!accept) {\n            if(view != null && repl_count >= view.size()) {\n                accept=true;\n            }\n            else {\n                List<Address> selected_hosts=hash_function != null? hash_function.hash(key, repl_count) : null;\n                if(selected_hosts != null) {\n                    for(Address addr: selected_hosts) {\n                        if(addr.equals(local_addr)) {\n                            accept=true;\n                            break;\n                        }\n                    }\n                }\n                if(!accept)\n                    return null;\n            }\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"_put(\" + key + \", \" + val + \", \" + repl_count + \", \" + timeout + \")\");\n\n        if(timeout > 0)\n            timeout=System.currentTimeMillis() + timeout;\n        Value<V> value=new Value<V>(val, repl_count);\n        Value<V> retval=l2_cache.put(key, value, timeout);\n        return retval != null? retval.getVal() : null;\n    }","id":78310,"modified_method":"public V _put(K key, V val, short repl_count, long timeout) {\n\n        // check if we need to host the data\n        boolean accept=repl_count == -1;\n\n        if(!accept) {\n            if(view != null && repl_count >= view.size()) {\n                accept=true;\n            }\n            else {\n                List<Address> selected_hosts=hash_function != null? hash_function.hash(key, repl_count) : null;\n                if(selected_hosts != null) {\n                    for(Address addr: selected_hosts) {\n                        if(addr.equals(local_addr)) {\n                            accept=true;\n                            break;\n                        }\n                    }\n                }\n                if(!accept)\n                    return null;\n            }\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"_put(\" + key + \", \" + val + \", \" + repl_count + \", \" + timeout + \")\");\n\n        if(timeout > 0)\n            timeout=System.currentTimeMillis() + timeout;\n        Value<V> value=new Value<V>(val, repl_count);\n        Value<V> retval=l2_cache.put(key, value, timeout);\n\n        if(l1_cache != null)\n            l1_cache.remove(key);\n\n        return retval != null? retval.getVal() : null;\n    }","commit_id":"a1461fdee09cc406642e0e91fd82cbdb753abd34","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the value associated with key\n     * @param key The key, has to be serializable\n     * @return The value associated with key, or null\n     */\n    @ManagedOperation\n    public V get(K key) {\n\n        // 1. Try the L1 cache first\n        if(l1_cache != null) {\n            V val=l1_cache.get(key);\n            if(val != null) {\n                if(log.isTraceEnabled())\n                    log.trace(\"returned value \" + val + \" for \" + key + \" from L1 cache\");\n                return val;\n            }\n        }\n\n        // 2. Try the local cache\n        Value<V> tmp=l2_cache.get(key);\n        if(tmp != null)\n            return tmp.getVal();\n\n        // 3. Execute a cluster wide GET\n        try {\n            RspList rsps=disp.callRemoteMethods(null,\n                                                new MethodCall(GET, new Object[]{key}),\n                                                GroupRequest.GET_ALL,\n                                                call_timeout);\n            for(Rsp rsp: rsps.values()) {\n                Cache.Value<Value<V>> val=(Cache.Value<Value<V>>)rsp.getValue();\n                if(val != null) {\n                    tmp=val.getValue();\n                    if(tmp != null) {\n                        V real_value=tmp.getVal();\n                        if(real_value != null && l1_cache != null && val.getExpirationTime() >= 0)\n                            l1_cache.put(key, real_value, val.getExpirationTime());\n                        return real_value;\n                    }\n                }\n            }\n            return null;\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"get() failed\", t);\n            return null;\n        }\n    }","id":78311,"modified_method":"/**\n     * Returns the value associated with key\n     * @param key The key, has to be serializable\n     * @return The value associated with key, or null\n     */\n    @ManagedOperation\n    public V get(K key) {\n\n        // 1. Try the L1 cache first\n        if(l1_cache != null) {\n            V val=l1_cache.get(key);\n            if(val != null) {\n                if(log.isTraceEnabled())\n                    log.trace(\"returned value \" + val + \" for \" + key + \" from L1 cache\");\n                return val;\n            }\n        }\n\n        // 2. Try the local cache\n        Cache.Value<Value<V>> val=l2_cache.getEntry(key);\n        Value<V> tmp;\n        if(val != null) {\n            tmp=val.getValue();\n            if(tmp !=null) {\n                V real_value=tmp.getVal();\n                if(real_value != null && l1_cache != null && val.getExpirationTime() >= 0)\n                    l1_cache.put(key, real_value, val.getExpirationTime());\n                return tmp.getVal();\n            }\n        }\n\n        // 3. Execute a cluster wide GET\n        try {\n            RspList rsps=disp.callRemoteMethods(null,\n                                                new MethodCall(GET, new Object[]{key}),\n                                                GroupRequest.GET_ALL,\n                                                call_timeout);\n            for(Rsp rsp: rsps.values()) {\n                Object obj=rsp.getValue();\n                if(obj == null || obj instanceof Throwable)\n                    continue;\n                val=(Cache.Value<Value<V>>)rsp.getValue();\n                if(val != null) {\n                    tmp=val.getValue();\n                    if(tmp != null) {\n                        V real_value=tmp.getVal();\n                        if(real_value != null && l1_cache != null && val.getExpirationTime() >= 0)\n                            l1_cache.put(key, real_value, val.getExpirationTime());\n                        return real_value;\n                    }\n                }\n            }\n            return null;\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"get() failed\", t);\n            return null;\n        }\n    }","commit_id":"a1461fdee09cc406642e0e91fd82cbdb753abd34","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes key in all nodes in the cluster, both from their local hashmaps and L1 caches\n     * @param key The key, needs to be serializable\n     */\n    @ManagedOperation\n    public void remove(K key) {\n        try {\n            disp.callRemoteMethod(null, new MethodCall(REMOVE, new Object[]{key}),\n                                  GroupRequest.GET_NONE, call_timeout);\n            if(l1_cache != null)\n                l1_cache.remove(key);\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"remove() failed\", t);\n        }\n    }","id":78312,"modified_method":"/**\n     * Removes key in all nodes in the cluster, both from their local hashmaps and L1 caches\n     * @param key The key, needs to be serializable\n     */\n    @ManagedOperation\n    public void remove(K key) {\n        try {\n            disp.callRemoteMethods(null, new MethodCall(REMOVE, new Object[]{key}),\n                                   GroupRequest.GET_NONE, call_timeout);\n            if(l1_cache != null)\n                l1_cache.remove(key);\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"remove() failed\", t);\n        }\n    }","commit_id":"a1461fdee09cc406642e0e91fd82cbdb753abd34","url":"https://github.com/belaban/JGroups"},{"original_method":"private void start(String props, InetAddress bind_addr, int port, int min_threads, int max_threads,\n                       long rpc_timeout, long caching_time, boolean migrate_data, boolean use_l1_cache,\n                       int l1_max_entries, long l1_reaping_interval,\n                       int l2_max_entries, long l2_reaping_interval) throws Exception {\n        MBeanServer server=ManagementFactory.getPlatformMBeanServer();\n\n        cache=new ReplCache(props, \"replcache-cluster\");\n        cache.setCallTimeout(rpc_timeout);\n        cache.setCachingTime(caching_time);\n        cache.setMigrateData(migrate_data);\n        JmxConfigurator.register(cache, server, BASENAME + \":name=cache\");\n        JmxConfigurator.register(cache.getL2Cache(), server, BASENAME + \":name=l2-cache\");\n\n        if(use_l1_cache) {\n            Cache<String,String> l1_cache=new Cache<String,String>();\n            cache.setL1Cache(l1_cache);\n            if(l1_reaping_interval > 0)\n                l1_cache.enableReaping(l1_reaping_interval);\n            if(l1_max_entries > 0)\n                l1_cache.setMaxNumberOfEntries(l1_max_entries);\n            JmxConfigurator.register(cache.getL1Cache(), server, BASENAME + \":name=l1-cache\");\n        }\n\n        if(l2_max_entries > 0 || l2_reaping_interval > 0) {\n            Cache<String, ReplCache.Value<String>> l2_cache=cache.getL2Cache();\n            if(l2_max_entries > 0)\n                l2_cache.setMaxNumberOfEntries(l2_max_entries);\n            if(l2_reaping_interval > 0)\n                l2_cache.enableReaping(l2_reaping_interval);\n        }\n\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                cache.stop();\n            }\n        });\n\n        cache.start();\n    }","id":78313,"modified_method":"private void start(String props, InetAddress bind_addr, int port, int min_threads, int max_threads,\n                       long rpc_timeout, long caching_time, boolean migrate_data, boolean use_l1_cache,\n                       int l1_max_entries, long l1_reaping_interval,\n                       int l2_max_entries, long l2_reaping_interval) throws Exception {\n        MBeanServer server=ManagementFactory.getPlatformMBeanServer();\n\n        cache=new ReplCache(props, \"replcache-cluster\");\n        cache.setCallTimeout(rpc_timeout);\n        cache.setCachingTime(caching_time);\n        cache.setMigrateData(migrate_data);\n        JmxConfigurator.register(cache, server, BASENAME + \":name=cache\");\n        JmxConfigurator.register(cache.getL2Cache(), server, BASENAME + \":name=l2-cache\");\n\n        if(use_l1_cache) {\n            Cache<String,String> l1_cache=new Cache<String,String>();\n            cache.setL1Cache(l1_cache);\n            if(l1_reaping_interval > 0)\n                l1_cache.enableReaping(l1_reaping_interval);\n            if(l1_max_entries > 0)\n                l1_cache.setMaxNumberOfEntries(l1_max_entries);\n            JmxConfigurator.register(cache.getL1Cache(), server, BASENAME + \":name=l1-cache\");\n        }\n\n        if(l2_max_entries > 0 || l2_reaping_interval > 0) {\n            Cache<String, ReplCache.Value<String>> l2_cache=cache.getL2Cache();\n            if(l2_max_entries > 0)\n                l2_cache.setMaxNumberOfEntries(l2_max_entries);\n            if(l2_reaping_interval > 0)\n                l2_cache.enableReaping(l2_reaping_interval);\n        }\n\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                cache.stop();\n            }\n        });\n\n        cache.start();\n\n        mainLoop();\n    }","commit_id":"a1461fdee09cc406642e0e91fd82cbdb753abd34","url":"https://github.com/belaban/JGroups"},{"original_method":"private void sendPut(Address dest, K key, V val, short repl_count, long caching_time, boolean synchronous) {\n        try {\n            int mode=synchronous? GroupRequest.GET_ALL : GroupRequest.GET_NONE;\n            disp.callRemoteMethod(dest, new MethodCall(PUT, new Object[]{key, val, repl_count, caching_time}), mode, call_timeout);\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"put() failed\", t);\n        }\n    }","id":78314,"modified_method":"private void sendPut(K key, V val, short repl_count, long caching_time, boolean synchronous) {\n        try {\n            int mode=synchronous? GroupRequest.GET_ALL : GroupRequest.GET_NONE;\n            disp.callRemoteMethods(null, new MethodCall(PUT, new Object[]{key, val, repl_count, caching_time}), mode, call_timeout);\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"put() failed\", t);\n        }\n    }","commit_id":"0501a94467dec9c65ec5df7f7439c4a906129fcd","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Places a key/value pair into one or several nodes in the cluster.\n     * @param key The key, needs to be serializable\n     * @param val The value, needs to be serializable\n     * @param repl_count Number of replicas. The total number of times a data item should be present in a cluster.\n     * Needs to be &gt; 0\n     * <ul>\n     * <li>-1: create key/val in all the nodes in the cluster\n     * <li>0: create key/val only in one node in the cluster, picked by computing the consistent hash of KEY\n     * <li>K &gt; 0: create key/val in those nodes in the cluster which match the consistent hashes created for KEY\n     * <\/ul>\n     * @param timeout Expiration time for key/value.\n     * <ul>\n     * <li>-1: don't cache at all in the L1 cache\n     * <li>0: cache forever, until removed or evicted because we need space for newer elements\n     * <li>&gt; 0: number of milliseconds to keep an idle element in the cache. An element is idle when not accessed.\n     * <\/ul>\n     */\n    @ManagedOperation\n    public void put(K key, V val, short repl_count, long timeout) {\n        sendPut(null, key, val, repl_count, timeout, false);\n        if(l1_cache != null && timeout >= 0)\n            l1_cache.put(key, val, timeout);\n    }","id":78315,"modified_method":"/**\n     * Places a key/value pair into one or several nodes in the cluster.\n     * @param key The key, needs to be serializable\n     * @param val The value, needs to be serializable\n     * @param repl_count Number of replicas. The total number of times a data item should be present in a cluster.\n     * Needs to be &gt; 0\n     * <ul>\n     * <li>-1: create key/val in all the nodes in the cluster\n     * <li>0: create key/val only in one node in the cluster, picked by computing the consistent hash of KEY\n     * <li>K &gt; 0: create key/val in those nodes in the cluster which match the consistent hashes created for KEY\n     * <\/ul>\n     * @param timeout Expiration time for key/value.\n     * <ul>\n     * <li>-1: don't cache at all in the L1 cache\n     * <li>0: cache forever, until removed or evicted because we need space for newer elements\n     * <li>&gt; 0: number of milliseconds to keep an idle element in the cache. An element is idle when not accessed.\n     * <\/ul>\n     */\n    @ManagedOperation\n    public void put(K key, V val, short repl_count, long timeout) {\n        sendPut(key, val, repl_count, timeout, false);\n        if(l1_cache != null && timeout >= 0)\n            l1_cache.put(key, val, timeout);\n    }","commit_id":"0501a94467dec9c65ec5df7f7439c4a906129fcd","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the value associated with key\n     * @param key The key, has to be serializable\n     * @return The value associated with key, or null\n     */\n    @ManagedOperation\n    public V get(K key) {\n\n        // 1. Try the L1 cache first\n        if(l1_cache != null) {\n            V val=l1_cache.get(key);\n            if(val != null) {\n                if(log.isTraceEnabled())\n                    log.trace(\"returned value \" + val + \" for \" + key + \" from L1 cache\");\n                return val;\n            }\n        }\n\n        // 2. Try the local cache\n        Value<V> tmp=l2_cache.get(key);\n        if(tmp != null)\n            return tmp.getVal();\n\n        // 3. Execute a cluster wide GET\n        try {\n            RspList rsps=disp.callRemoteMethods(null,\n                                                new MethodCall(GET, new Object[]{key}),\n                                                GroupRequest.GET_ALL,\n                                                call_timeout);\n            for(Rsp rsp: rsps.values()) {\n                Cache.Value<Value<V>> val=(Cache.Value<Value<V>>)rsp.getValue();\n                if(val != null) {\n                    tmp=val.getValue();\n                    if(tmp != null) {\n                        V real_value=tmp.getVal();\n                        if(real_value != null && l1_cache != null && val.getExpirationTime() >= 0)\n                            l1_cache.put(key, real_value, val.getExpirationTime());\n                        return real_value;\n                    }\n                }\n            }\n            return null;\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"get() failed\", t);\n            return null;\n        }\n    }","id":78316,"modified_method":"/**\n     * Returns the value associated with key\n     * @param key The key, has to be serializable\n     * @return The value associated with key, or null\n     */\n    @ManagedOperation\n    public V get(K key) {\n\n        // 1. Try the L1 cache first\n        if(l1_cache != null) {\n            V val=l1_cache.get(key);\n            if(val != null) {\n                if(log.isTraceEnabled())\n                    log.trace(\"returned value \" + val + \" for \" + key + \" from L1 cache\");\n                return val;\n            }\n        }\n\n        // 2. Try the local cache\n        Cache.Value<Value<V>> val=l2_cache.getEntry(key);\n        Value<V> tmp;\n        if(val != null) {\n            tmp=val.getValue();\n            if(tmp !=null) {\n                V real_value=tmp.getVal();\n                if(real_value != null && l1_cache != null && val.getExpirationTime() >= 0)\n                    l1_cache.put(key, real_value, val.getExpirationTime());\n                return tmp.getVal();\n            }\n        }\n\n        // 3. Execute a cluster wide GET\n        try {\n            RspList rsps=disp.callRemoteMethods(null,\n                                                new MethodCall(GET, new Object[]{key}),\n                                                GroupRequest.GET_ALL,\n                                                call_timeout);\n            for(Rsp rsp: rsps.values()) {\n                Object obj=rsp.getValue();\n                if(obj == null || obj instanceof Throwable)\n                    continue;\n                val=(Cache.Value<Value<V>>)rsp.getValue();\n                if(val != null) {\n                    tmp=val.getValue();\n                    if(tmp != null) {\n                        V real_value=tmp.getVal();\n                        if(real_value != null && l1_cache != null && val.getExpirationTime() >= 0)\n                            l1_cache.put(key, real_value, val.getExpirationTime());\n                        return real_value;\n                    }\n                }\n            }\n            return null;\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"get() failed\", t);\n            return null;\n        }\n    }","commit_id":"0501a94467dec9c65ec5df7f7439c4a906129fcd","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n            return \"val=\" + val + \", replication_count=\" + replication_count;\n        }","id":78317,"modified_method":"public String toString() {\n            return val + \" (replication_count=\" + replication_count + \")\";\n        }","commit_id":"0501a94467dec9c65ec5df7f7439c4a906129fcd","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Removes key in all nodes in the cluster, both from their local hashmaps and L1 caches\n     * @param key The key, needs to be serializable\n     */\n    @ManagedOperation\n    public void remove(K key) {\n        try {\n            disp.callRemoteMethod(null, new MethodCall(REMOVE, new Object[]{key}),\n                                  GroupRequest.GET_NONE, call_timeout);\n            if(l1_cache != null)\n                l1_cache.remove(key);\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"remove() failed\", t);\n        }\n    }","id":78318,"modified_method":"/**\n     * Removes key in all nodes in the cluster, both from their local hashmaps and L1 caches\n     * @param key The key, needs to be serializable\n     */\n    @ManagedOperation\n    public void remove(K key) {\n        try {\n            disp.callRemoteMethods(null, new MethodCall(REMOVE, new Object[]{key}),\n                                   GroupRequest.GET_NONE, call_timeout);\n            if(l1_cache != null)\n                l1_cache.remove(key);\n        }\n        catch(Throwable t) {\n            if(log.isWarnEnabled())\n                log.warn(\"remove() failed\", t);\n        }\n    }","commit_id":"0501a94467dec9c65ec5df7f7439c4a906129fcd","url":"https://github.com/belaban/JGroups"},{"original_method":"public V _put(K key, V val, short repl_count, long timeout) {\n\n        // check if we need to host the data\n        boolean accept=repl_count == -1;\n\n        if(!accept) {\n            if(view != null && repl_count >= view.size()) {\n                accept=true;\n            }\n            else {\n                List<Address> selected_hosts=hash_function != null? hash_function.hash(key, repl_count) : null;\n                if(selected_hosts != null) {\n                    for(Address addr: selected_hosts) {\n                        if(addr.equals(local_addr)) {\n                            accept=true;\n                            break;\n                        }\n                    }\n                }\n                if(!accept)\n                    return null;\n            }\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"_put(\" + key + \", \" + val + \", \" + repl_count + \", \" + timeout + \")\");\n\n        if(timeout > 0)\n            timeout=System.currentTimeMillis() + timeout;\n        Value<V> value=new Value<V>(val, repl_count);\n        Value<V> retval=l2_cache.put(key, value, timeout);\n        return retval != null? retval.getVal() : null;\n    }","id":78319,"modified_method":"public V _put(K key, V val, short repl_count, long timeout) {\n\n        // check if we need to host the data\n        boolean accept=repl_count == -1;\n\n        if(!accept) {\n            if(view != null && repl_count >= view.size()) {\n                accept=true;\n            }\n            else {\n                List<Address> selected_hosts=hash_function != null? hash_function.hash(key, repl_count) : null;\n                if(selected_hosts != null) {\n                    for(Address addr: selected_hosts) {\n                        if(addr.equals(local_addr)) {\n                            accept=true;\n                            break;\n                        }\n                    }\n                }\n                if(!accept)\n                    return null;\n            }\n        }\n\n        if(log.isTraceEnabled())\n            log.trace(\"_put(\" + key + \", \" + val + \", \" + repl_count + \", \" + timeout + \")\");\n\n        if(timeout > 0)\n            timeout=System.currentTimeMillis() + timeout;\n        Value<V> value=new Value<V>(val, repl_count);\n        Value<V> retval=l2_cache.put(key, value, timeout);\n\n        if(l1_cache != null)\n            l1_cache.remove(key);\n\n        return retval != null? retval.getVal() : null;\n    }","commit_id":"0501a94467dec9c65ec5df7f7439c4a906129fcd","url":"https://github.com/belaban/JGroups"},{"original_method":"public V _remove(K key) {\n        if(log.isTraceEnabled())\n            log.trace(\"_remove(\" + key + \")\");\n        Value<V> retval=l2_cache.remove(key);\n        return retval != null? retval.getVal() : null;\n    }","id":78320,"modified_method":"public V _remove(K key) {\n        if(log.isTraceEnabled())\n            log.trace(\"_remove(\" + key + \")\");\n        Value<V> retval=l2_cache.remove(key);\n        if(l1_cache != null)\n            l1_cache.remove(key);\n        return retval != null? retval.getVal() : null;\n    }","commit_id":"0501a94467dec9c65ec5df7f7439c4a906129fcd","url":"https://github.com/belaban/JGroups"},{"original_method":"private void start(String props, InetAddress bind_addr, int port, int min_threads, int max_threads,\n                       long rpc_timeout, long caching_time, boolean migrate_data, boolean use_l1_cache,\n                       int l1_max_entries, long l1_reaping_interval,\n                       int l2_max_entries, long l2_reaping_interval) throws Exception {\n        MBeanServer server=ManagementFactory.getPlatformMBeanServer();\n\n        cache=new ReplCache(props, \"replcache-cluster\");\n        cache.setCallTimeout(rpc_timeout);\n        cache.setCachingTime(caching_time);\n        cache.setMigrateData(migrate_data);\n        JmxConfigurator.register(cache, server, BASENAME + \":name=cache\");\n        JmxConfigurator.register(cache.getL2Cache(), server, BASENAME + \":name=l2-cache\");\n\n        if(use_l1_cache) {\n            Cache<String,String> l1_cache=new Cache<String,String>();\n            cache.setL1Cache(l1_cache);\n            if(l1_reaping_interval > 0)\n                l1_cache.enableReaping(l1_reaping_interval);\n            if(l1_max_entries > 0)\n                l1_cache.setMaxNumberOfEntries(l1_max_entries);\n            JmxConfigurator.register(cache.getL1Cache(), server, BASENAME + \":name=l1-cache\");\n        }\n\n        if(l2_max_entries > 0 || l2_reaping_interval > 0) {\n            Cache<String, ReplCache.Value<String>> l2_cache=cache.getL2Cache();\n            if(l2_max_entries > 0)\n                l2_cache.setMaxNumberOfEntries(l2_max_entries);\n            if(l2_reaping_interval > 0)\n                l2_cache.enableReaping(l2_reaping_interval);\n        }\n\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                cache.stop();\n            }\n        });\n\n        cache.start();\n    }","id":78321,"modified_method":"private void start(String props, InetAddress bind_addr, int port, int min_threads, int max_threads,\n                       long rpc_timeout, long caching_time, boolean migrate_data, boolean use_l1_cache,\n                       int l1_max_entries, long l1_reaping_interval,\n                       int l2_max_entries, long l2_reaping_interval) throws Exception {\n        MBeanServer server=ManagementFactory.getPlatformMBeanServer();\n\n        cache=new ReplCache(props, \"replcache-cluster\");\n        cache.setCallTimeout(rpc_timeout);\n        cache.setCachingTime(caching_time);\n        cache.setMigrateData(migrate_data);\n        JmxConfigurator.register(cache, server, BASENAME + \":name=cache\");\n        JmxConfigurator.register(cache.getL2Cache(), server, BASENAME + \":name=l2-cache\");\n\n        if(use_l1_cache) {\n            Cache<String,String> l1_cache=new Cache<String,String>();\n            cache.setL1Cache(l1_cache);\n            if(l1_reaping_interval > 0)\n                l1_cache.enableReaping(l1_reaping_interval);\n            if(l1_max_entries > 0)\n                l1_cache.setMaxNumberOfEntries(l1_max_entries);\n            JmxConfigurator.register(cache.getL1Cache(), server, BASENAME + \":name=l1-cache\");\n        }\n\n        if(l2_max_entries > 0 || l2_reaping_interval > 0) {\n            Cache<String, ReplCache.Value<String>> l2_cache=cache.getL2Cache();\n            if(l2_max_entries > 0)\n                l2_cache.setMaxNumberOfEntries(l2_max_entries);\n            if(l2_reaping_interval > 0)\n                l2_cache.enableReaping(l2_reaping_interval);\n        }\n\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            public void run() {\n                cache.stop();\n            }\n        });\n\n        cache.start();\n\n        mainLoop();\n    }","commit_id":"0501a94467dec9c65ec5df7f7439c4a906129fcd","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * This method looks for existing tags in the current selection and sets the corresponding boolean in the boolean array existing[]\n     */\n    private void findExistingTags() {\n        TableModel tm = propertyTable.getModel();\n        for (int i=0; i<tm.getRowCount(); i++) {\n            String key = (String)tm.getValueAt(i, 1);\n            existing[i] = false;\n            for (OsmPrimitive osm : sel) {\n                if (osm.keySet().contains(key)) {\n                    existing[i] = true;\n                    break;\n                }\n            }\n        }\n        propertyTable.repaint();\n    }","id":78322,"modified_method":"/**\n     * This method looks for existing tags in the current selection and sets the corresponding boolean in the boolean array existing[]\n     */\n    private void findExistingTags() {\n        TableModel tm = propertyTable.getModel();\n        for (int i=0; i<tm.getRowCount(); i++) {\n            String key = (String)tm.getValueAt(i, 1);\n            count[i] = 0;\n            for (OsmPrimitive osm : sel) {\n                if (osm.keySet().contains(key)) {\n                    count[i]++;\n                    break;\n                }\n            }\n        }\n        propertyTable.repaint();\n    }","commit_id":"baadd926bb72ae7944b48b047214e68313a3a827","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * If you click the \"Add tags\" button build a ChangePropertyCommand for every key that has a checked checkbox to apply the key value pair to all selected osm objects.\n     * You get a entry for every key in the command queue.\n     */\n    @Override\n    protected void buttonAction(int buttonIndex, ActionEvent evt) {\n        if (buttonIndex == 0) {\n            TableModel tm = propertyTable.getModel();\n            for (int i=0; i<tm.getRowCount(); i++) {\n                if ((Boolean)tm.getValueAt(i, 0)) {\n                    Main.main.undoRedo.add(new ChangePropertyCommand(sel, (String)tm.getValueAt(i, 1), (String)tm.getValueAt(i, 2)));\n                }\n            }\n        }\n        setVisible(false);\n    }","id":78323,"modified_method":"/**\n     * If you click the \"Add tags\" button build a ChangePropertyCommand for every key that has a checked checkbox to apply the key value pair to all selected osm objects.\n     * You get a entry for every key in the command queue.\n     */\n    @Override\n    protected void buttonAction(int buttonIndex, ActionEvent evt) {\n        if (buttonIndex != 2) {\n            TableModel tm = propertyTable.getModel();\n            for (int i=0; i<tm.getRowCount(); i++) {\n                if (buttonIndex==1 || (Boolean)tm.getValueAt(i, 0)) {\n                    String key =(String)tm.getValueAt(i, 1);\n                    Object value = tm.getValueAt(i, 2);\n                    Main.main.undoRedo.add(new ChangePropertyCommand(sel,\n                            key, value instanceof String ? (String) value : \"\"));\n                }\n            }\n        }\n        setVisible(false);\n    }","commit_id":"baadd926bb72ae7944b48b047214e68313a3a827","url":"https://github.com/openstreetmap/josm"},{"original_method":"public AddTagsDialog(String[][] tags) {\n        super(Main.parent, tr(\"Add tags to selected objects\"), new String[] { tr(\"Add tags\"), tr(\"Cancel\")},\n                false,\n                true);\n\n        DataSet.addSelectionListener(this);\n\n\n        DefaultTableModel tm = new DefaultTableModel(new String[] {tr(\"Assume\"), tr(\"Key\"), tr(\"Value\")}, tags.length) {\n            @Override\n            public Class getColumnClass(int c) {\n                return getValueAt(0, c).getClass();\n            }\n\n        };\n\n        sel = Main.main.getCurrentDataSet().getSelected();\n        existing = new boolean[tags.length];\n\n        for (int i = 0; i<tags.length; i++) {\n            existing[i] = false;\n            String key = tags[i][0];\n            Boolean b = Boolean.TRUE;\n            for (OsmPrimitive osm : sel) {\n                if (osm.keySet().contains(key)) {\n                    b = Boolean.FALSE;\n                    existing[i]=true;\n                    break;\n                }\n            }\n            tm.setValueAt(b, i, 0);\n            tm.setValueAt(tags[i][0], i, 1);\n            tm.setValueAt(tags[i][1], i, 2);\n        }\n\n        propertyTable = new JTable(tm) {\n\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {\n                Component c = super.prepareRenderer(renderer, row, column);\n                if (existing[row]) {\n                    c.setFont(c.getFont().deriveFont(Font.ITALIC));\n                    c.setForeground(new Color(100, 100, 100));\n                } else {\n                    c.setFont(c.getFont().deriveFont(Font.PLAIN));\n                    c.setForeground(new Color(0, 0, 0));\n                }\n                return c;\n            }\n        };\n\n        // a checkbox has a size of 15 px\n        propertyTable.getColumnModel().getColumn(0).setMaxWidth(15);\n        // get edit results if the table looses the focus, for example if a user clicks \"add tags\"\n        propertyTable.putClientProperty(\"terminateEditOnFocusLost\", Boolean.TRUE);\n\n        // set the content of this AddTagsDialog consisting of the tableHeader and the table itself.\n        JPanel tablePanel = new JPanel();\n        tablePanel.setLayout(new GridBagLayout());\n        tablePanel.add(propertyTable.getTableHeader(), GBC.eol().fill(GBC.HORIZONTAL));\n        tablePanel.add(propertyTable, GBC.eol().fill(GBC.BOTH));\n        setContent(tablePanel);\n\n        // set the default Dimensions and show the dialog\n        setPreferredSize(new Dimension(400,tablePanel.getPreferredSize().height+100));\n        showDialog();\n    }","id":78324,"modified_method":"public AddTagsDialog(String[][] tags) {\n        super(Main.parent, tr(\"Add tags to selected objects\"), new String[] { tr(\"Add selected tags\"), tr(\"Add all tags\"),  tr(\"Cancel\")},\n                false,\n                true);\n        setToolTipTexts(new String[]{tr(\"Add checked tags to selected objects\"), tr(\"Shift+Enter: Add all tags to selected objects\"), \"\"});\n     \n        DataSet.addSelectionListener(this);\n\n\n        DefaultTableModel tm = new DefaultTableModel(new String[] {tr(\"Assume\"), tr(\"Key\"), tr(\"Value\")}, tags.length) {\n            @Override\n            public Class getColumnClass(int c) {\n                return getValueAt(0, c).getClass();\n            }\n\n        };\n\n        sel = Main.main.getCurrentDataSet().getSelected();\n        count = new int[tags.length];\n        \n        for (int i = 0; i<tags.length; i++) {\n            count[i] = 0;\n            String key = tags[i][0];\n            Boolean b = Boolean.TRUE;\n            for (OsmPrimitive osm : sel) {\n                if (osm.keySet().contains(key)) {\n                    b = Boolean.FALSE;\n                    count[i]++;\n                    break;\n                }\n            }\n            tm.setValueAt(b, i, 0);\n            tm.setValueAt(tags[i][0], i, 1);\n            tm.setValueAt(tags[i][1].isEmpty() ? new DeleteTagMarker(count[i]) : tags[i][1], i, 2);\n        }\n\n        propertyTable = new JTable(tm) {\n\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {\n                Component c = super.prepareRenderer(renderer, row, column);\n                if (count[row]>0) {\n                    c.setFont(c.getFont().deriveFont(Font.ITALIC));\n                    c.setForeground(new Color(100, 100, 100));\n                } else {\n                    c.setFont(c.getFont().deriveFont(Font.PLAIN));\n                    c.setForeground(new Color(0, 0, 0));\n                }\n                return c;\n            }\n        };\n        \n        // a checkbox has a size of 15 px\n        propertyTable.getColumnModel().getColumn(0).setMaxWidth(15);\n        // get edit results if the table looses the focus, for example if a user clicks \"add tags\"\n        propertyTable.putClientProperty(\"terminateEditOnFocusLost\", Boolean.TRUE);\n        propertyTable.getInputMap().put(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, KeyEvent.SHIFT_MASK), \"shiftenter\");\n        propertyTable.getActionMap().put(\"shiftenter\", new AbstractAction() {\n            @Override  public void actionPerformed(ActionEvent e) { \n                buttonAction(1, e); // add all tags on Shift-Enter\n            }\n        });\n\n        // set the content of this AddTagsDialog consisting of the tableHeader and the table itself.\n        JPanel tablePanel = new JPanel();\n        tablePanel.setLayout(new GridBagLayout());\n        tablePanel.add(propertyTable.getTableHeader(), GBC.eol().fill(GBC.HORIZONTAL));\n        tablePanel.add(propertyTable, GBC.eol().fill(GBC.BOTH));\n        setContent(tablePanel);\n        setDefaultButton(2);\n        // set the default Dimensions and show the dialog\n        setPreferredSize(new Dimension(400,tablePanel.getPreferredSize().height+100));\n        showDialog();\n    }","commit_id":"baadd926bb72ae7944b48b047214e68313a3a827","url":"https://github.com/openstreetmap/josm"},{"original_method":"static void addTags(final Map<String, String> args) {\n        if (args.containsKey(\"addtags\")) {\n            Main.worker.execute(new Runnable() {\n\n                public void run() {\n                    String[] tags = null;\n                    try {\n                        tags = URLDecoder.decode(args.get(\"addtags\"), \"UTF-8\").split(\"\\\\|\");\n                    } catch (UnsupportedEncodingException e) {\n                        throw new RuntimeException();\n                    }\n                    Set<String> tagSet = new HashSet<String>();\n                    for (String tag : tags) {\n                        if (!tag.trim().isEmpty() && tag.contains(\"=\")) {\n                            tagSet.add(tag.trim());\n                        }\n                    }\n                    if (!tagSet.isEmpty()) {\n                        String[][] keyValue = new String[tagSet.size()][2];\n                        int i = 0;\n                        for (String tag : tagSet) {\n                            keyValue[i++] = tag.split(\"=\");\n                        }\n    \n                        new AddTagsDialog(keyValue);\n                    }\n                }\n            });\n        }\n    }","id":78325,"modified_method":"static void addTags(final Map<String, String> args) {\n        if (args.containsKey(\"addtags\")) {\n            Main.worker.execute(new Runnable() {\n\n                public void run() {\n                    String[] tags = null;\n                    try {\n                        tags = URLDecoder.decode(args.get(\"addtags\"), \"UTF-8\").split(\"\\\\|\");\n                    } catch (UnsupportedEncodingException e) {\n                        throw new RuntimeException();\n                    }\n                    Set<String> tagSet = new HashSet<String>();\n                    for (String tag : tags) {\n                        if (!tag.trim().isEmpty() && tag.contains(\"=\")) {\n                            tagSet.add(tag.trim());\n                        }\n                    }\n                    if (!tagSet.isEmpty()) {\n                        String[][] keyValue = new String[tagSet.size()][2];\n                        int i = 0;\n                        for (String tag : tagSet) {\n                            // support a  =   b===c as \"a\"=\"b===c\"\n                            String [] pair = tag.split(\"\\\\s*=\\\\s*\",2); \n                            keyValue[i][0] = pair[0];\n                            keyValue[i][1] = pair.length<2 ? \"\": pair[1];\n                            i++;\n                        }\n    \n                        new AddTagsDialog(keyValue);\n                    }\n                }\n            });\n        }\n    }","commit_id":"baadd926bb72ae7944b48b047214e68313a3a827","url":"https://github.com/openstreetmap/josm"},{"original_method":"public boolean dropAssociation(Transferable transfer, int row, int column) {\n\t\tboolean\t\t\tresult = false;\n\n/* \t\tDataFlavor[]\tflavors = transfer.getTransferDataFlavors();\n\t\tint\t\t\t\tflavorCount = flavors.length,\n\t\t\t\t\t\tindex;\n\t\tfor (index = 0; index < flavorCount; index++) {\n\t\t\tSystem.out.println(\"!!!!!!!!!! flavor \" + index + \" is \" + flavors[index].getHumanPresentableName());\n\t\t} */\n\n\t\tif (column == 1 || column == 3) {\n                    try {\n                        LWComponent dragNode = tufts.vue.MapDropTarget.extractData(transfer,\n                                                                                   LWComponent.DataFlavor,\n                                                                                   LWComponent.class);\n                        tufts.vue.ds.Field field = dragNode.getClientData(tufts.vue.ds.Field.class);\n\n                        //associationsTable.setValueAt(field.getSchema().getName() + \".\" + field.getName(), row, column);\n                        associationsTable.setValueAt(field, row, column);\n\n                        tufts.vue.ds.Schema.addAssociation(field,\n                                                           (Field) associationsTable.getValueAt(row, column == 1 ? 3 : 1));\n                        \n                        result = true;\n                    } catch (Exception ex) {\n                        Log.error(\"exception processing drop \" + transfer + \" at \" + row + \",\" + column, ex);\n                    }\n\t\t}\n// \t\tif (column == 1 || column == 3) {\n// \t\t\ttry {\n// \t\t\t\tString\tdata = (String)transfer.getTransferData(DataFlavor.stringFlavor);\n\n// \t\t\t\tassociationsTable.setValueAt(data.substring(data.indexOf('\\'') + 1, data.lastIndexOf('\\'')), row, column);\n\n// \t\t\t\tresult = true;\n// \t\t\t} catch (Exception ex) {\n// \t\t\t\tLog.error(ex);\n// \t\t\t}\n// \t\t}\n\n\t\treturn result;\n\t}","id":78326,"modified_method":"public boolean dropAssociation(Transferable transfer, int row, int column) {\n\t\tboolean\t\t\tresult = false;\n\n/* \t\tDataFlavor[]\tflavors = transfer.getTransferDataFlavors();\n\t\tint\t\t\t\tflavorCount = flavors.length,\n\t\t\t\t\t\tindex;\n\t\tfor (index = 0; index < flavorCount; index++) {\n\t\t\tSystem.out.println(\"!!!!!!!!!! flavor \" + index + \" is \" + flavors[index].getHumanPresentableName());\n\t\t} */\n\n\t\tif (column == 1 || column == 3) {\n                    try {\n                        LWComponent dragNode = tufts.vue.MapDropTarget.extractData(transfer,\n                                                                                   LWComponent.DataFlavor,\n                                                                                   LWComponent.class);\n                        Field field = dragNode.getClientData(tufts.vue.ds.Field.class);\n\n                        associationsTable.setValueAt(field, row, column);\n\n                        Object otherField = associationsTable.getValueAt(row, column == 1 ? 3 : 1);\n\n                        if (otherField instanceof Field)\n                            tufts.vue.ds.Schema.addAssociation(field, (Field) otherField);\n                        \n                        result = true;\n                    } catch (Exception ex) {\n                        Log.error(\"exception processing drop \" + transfer + \" at \" + row + \",\" + column, ex);\n                    }\n\t\t}\n// \t\tif (column == 1 || column == 3) {\n// \t\t\ttry {\n// \t\t\t\tString\tdata = (String)transfer.getTransferData(DataFlavor.stringFlavor);\n\n// \t\t\t\tassociationsTable.setValueAt(data.substring(data.indexOf('\\'') + 1, data.lastIndexOf('\\'')), row, column);\n\n// \t\t\t\tresult = true;\n// \t\t\t} catch (Exception ex) {\n// \t\t\t\tLog.error(ex);\n// \t\t\t}\n// \t\t}\n\n\t\treturn result;\n\t}","commit_id":"a53051fda68538cc6da2ee27ebf2f840617973e0","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Adds to a Solr document the fields that are specific to the XWiki document that contains the entity to be\n     * indexed. These fields required to identify the owning document and to also reflect some properties of the owning\n     * document towards the indexed entity (like locale and hidden flag).\n     * \n     * @param documentReference reference to document.\n     * @param solrDocument the Solr document to which to add the fields.\n     * @return false if the document does not exist, true otherwise\n     * @throws Exception if problems occur.\n     */\n    protected boolean setDocumentFields(DocumentReference documentReference, SolrInputDocument solrDocument)\n        throws Exception\n    {\n        XWikiDocument document = getDocument(documentReference);\n        if (document.isNew()) {\n            return false;\n        }\n\n        solrDocument.setField(FieldUtils.HIDDEN, document.isHidden());\n\n        solrDocument.setField(FieldUtils.WIKI, documentReference.getWikiReference().getName());\n        solrDocument.setField(FieldUtils.SPACE,\n            this.localSerializer.serialize(documentReference.getLastSpaceReference()));\n        solrDocument.setField(FieldUtils.NAME, documentReference.getName());\n\n        // Set the fields that are used to query / filter the document hierarchy.\n        setHierarchyFields(solrDocument, documentReference.getParent());\n\n        Locale locale = getLocale(documentReference);\n        solrDocument.setField(FieldUtils.LOCALE, locale.toString());\n        solrDocument.setField(FieldUtils.LANGUAGE, locale.getLanguage());\n\n        return true;\n    }","id":78327,"modified_method":"/**\n     * Adds to a Solr document the fields that are specific to the XWiki document that contains the entity to be\n     * indexed. These fields required to identify the owning document and to also reflect some properties of the owning\n     * document towards the indexed entity (like locale and hidden flag).\n     * \n     * @param documentReference reference to document.\n     * @param solrDocument the Solr document to which to add the fields.\n     * @return false if the document does not exist, true otherwise\n     * @throws Exception if problems occur.\n     */\n    protected boolean setDocumentFields(DocumentReference documentReference, SolrInputDocument solrDocument)\n        throws Exception\n    {\n        XWikiDocument document = getDocument(documentReference);\n        if (document.isNew()) {\n            return false;\n        }\n\n        solrDocument.setField(FieldUtils.HIDDEN, document.isHidden());\n\n        solrDocument.setField(FieldUtils.WIKI, documentReference.getWikiReference().getName());\n        solrDocument.setField(FieldUtils.NAME, documentReference.getName());\n\n        // Set the fields that are used to query / filter the document hierarchy.\n        setHierarchyFields(solrDocument, documentReference.getParent());\n\n        Locale locale = getLocale(documentReference);\n        solrDocument.setField(FieldUtils.LOCALE, locale.toString());\n        solrDocument.setField(FieldUtils.LANGUAGE, locale.getLanguage());\n\n        return true;\n    }","commit_id":"28e786ebba5304431a77bc30a6e47fc1048aa86f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void setHierarchyFields(SolrInputDocument solrDocument, EntityReference path)\n    {\n        List<EntityReference> ancestors = path.getReversedReferenceChain();\n        // Skip the wiki reference because we want to index the local space references.\n        for (int i = 1; i < ancestors.size(); i++) {\n            String localAncestorReference = this.localSerializer.serialize(ancestors.get(i));\n            // We prefix the local ancestor reference with the depth in order to use 'facet.prefix'. We also add a\n            // trailing slash in order to distinguish between space names with the same prefix (e.g. 0/Gallery/ and\n            // 0/GalleryCode/).\n            solrDocument.addField(FieldUtils.SPACE_FACET, (i - 1) + \"/\" + localAncestorReference + \".\");\n            solrDocument.addField(FieldUtils.SPACE_PREFIX, localAncestorReference);\n        }\n    }","id":78328,"modified_method":"private void setHierarchyFields(SolrInputDocument solrDocument, EntityReference path)\n    {\n        solrDocument.setField(FieldUtils.SPACE_EXACT, this.localSerializer.serialize(path));\n        List<EntityReference> ancestors = path.getReversedReferenceChain();\n        // Skip the wiki reference because we want to index the local space references.\n        for (int i = 1; i < ancestors.size(); i++) {\n            solrDocument.addField(FieldUtils.SPACE, ancestors.get(i).getName());\n            String localAncestorReference = this.localSerializer.serialize(ancestors.get(i));\n            solrDocument.addField(FieldUtils.SPACE_PREFIX, localAncestorReference);\n            // We prefix the local ancestor reference with the depth in order to use 'facet.prefix'. We also add a\n            // trailing slash in order to distinguish between space names with the same prefix (e.g. 0/Gallery/ and\n            // 0/GalleryCode/).\n            solrDocument.addField(FieldUtils.SPACE_FACET, (i - 1) + \"/\" + localAncestorReference + \".\");\n        }\n    }","commit_id":"28e786ebba5304431a77bc30a6e47fc1048aa86f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void getSimpleDocument() throws Exception\n    {\n        //\n        // Mock\n        //\n\n        // ID\n        String id = \"wiki:Space.Name_\" + Locale.ROOT.toString();\n        SolrReferenceResolver documentSolrReferenceResolver =\n            this.mocker.getInstance(SolrReferenceResolver.class, \"document\");\n        when(documentSolrReferenceResolver.getId(documentReference)).thenReturn(id);\n\n        // Full Name\n        String fullName = \"Space.Name\";\n        EntityReferenceSerializer<String> localEntityReferenceSerializer =\n            this.mocker.registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        when(localEntityReferenceSerializer.serialize(this.documentReference)).thenReturn(fullName);\n\n        String localSpaceReference = \"Path.To.Page\";\n        when(localEntityReferenceSerializer.serialize(this.documentReference.getLastSpaceReference())).thenReturn(\n            localSpaceReference);\n\n        // Hierarchy\n        when(localEntityReferenceSerializer.serialize(this.documentReference.getParent().getParent())).thenReturn(\n            \"Path.To\");\n        when(localEntityReferenceSerializer.serialize(this.documentReference.getParent().getParent().getParent()))\n            .thenReturn(\"Path\");\n\n        // Creator.\n        DocumentReference creatorReference = new DocumentReference(\"wiki\", \"Space\", \"Creator\");\n        when(this.document.getCreatorReference()).thenReturn(creatorReference);\n\n        String creatorStringReference = \"wiki:Space.Creator\";\n        EntityReferenceSerializer<String> entityReferenceSerializer =\n            this.mocker.registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"default\");\n        when(entityReferenceSerializer.serialize(creatorReference)).thenReturn(creatorStringReference);\n\n        String creatorDisplayName = \"Crea Tor\";\n        when(this.xcontext.getWiki().getPlainUserName(creatorReference, this.xcontext)).thenReturn(creatorDisplayName);\n\n        // Author.\n        DocumentReference authorReference = new DocumentReference(\"wiki\", \"Space\", \"Author\");\n        when(this.document.getAuthorReference()).thenReturn(authorReference);\n\n        String authorStringReference = \"wiki:Space.Author\";\n        when(entityReferenceSerializer.serialize(authorReference)).thenReturn(authorStringReference);\n\n        String authorDisplayName = \"Au Thor\";\n        when(this.xcontext.getWiki().getPlainUserName(authorReference, this.xcontext)).thenReturn(authorDisplayName);\n\n        // Creation Date\n        Date creationDate = new Date();\n        when(this.document.getCreationDate()).thenReturn(creationDate);\n\n        // Date\n        Date date = new Date();\n        when(this.document.getContentUpdateDate()).thenReturn(date);\n\n        // Version\n        String version = \"1.1\";\n        when(this.document.getVersion()).thenReturn(version);\n\n        // Version summary\n        String comment = \"1.1 comment\";\n        when(this.document.getComment()).thenReturn(comment);\n\n        // XObjects.\n        when(this.document.getXObjects()).thenReturn(Collections.<DocumentReference, List<BaseObject>> emptyMap());\n\n        // Title\n        String title = \"title\";\n        when(this.document.getRenderedTitle(any(Syntax.class), eq(this.xcontext))).thenReturn(title);\n\n        // Rendered Content\n        final String renderedContent = \"rendered content\";\n        BlockRenderer plainRenderer = this.mocker.registerMockComponent(BlockRenderer.class, \"plain/1.0\");\n        doAnswer(new Answer<Object>()\n        {\n            @Override\n            public Object answer(InvocationOnMock invocation)\n            {\n                Object[] args = invocation.getArguments();\n\n                WikiPrinter printer = (WikiPrinter) args[1];\n                printer.print(renderedContent);\n\n                return null;\n            }\n        }).when(plainRenderer).render(any(Block.class), any(WikiPrinter.class));\n\n        // Raw Content\n        String rawContent = \"raw content\";\n        when(this.document.getContent()).thenReturn(rawContent);\n\n        //\n        // Call\n        //\n        SolrInputDocument solrDocument = this.mocker.getComponentUnderTest().getSolrDocument(this.documentReference);\n\n        //\n        // Assert and verify\n        //\n        assertEquals(id, solrDocument.getFieldValue(FieldUtils.ID));\n\n        assertEquals(this.documentReference.getWikiReference().getName(), solrDocument.getFieldValue(FieldUtils.WIKI));\n        assertEquals(localSpaceReference, solrDocument.getFieldValue(FieldUtils.SPACE));\n        assertEquals(this.documentReference.getName(), solrDocument.getFieldValue(FieldUtils.NAME));\n\n        assertEquals(Arrays.asList(\"0/Path.\", \"1/Path.To.\", \"2/Path.To.Page.\"),\n            solrDocument.getFieldValues(FieldUtils.SPACE_FACET));\n        assertEquals(Arrays.asList(\"Path\", \"Path.To\", \"Path.To.Page\"),\n            solrDocument.getFieldValues(FieldUtils.SPACE_PREFIX));\n\n        assertEquals(Locale.US.toString(), solrDocument.getFieldValue(FieldUtils.LOCALE));\n        assertEquals(Locale.US.getLanguage(), solrDocument.getFieldValue(FieldUtils.LANGUAGE));\n        Collection< ? > actualLocales = solrDocument.getFieldValues(FieldUtils.LOCALES);\n        // The order of the locales in the returned collection is nondeterministic.\n        assertTrue(actualLocales.size() == 2 && actualLocales.contains(\"\")\n            && actualLocales.contains(Locale.US.toString()));\n        assertEquals(this.document.isHidden(), solrDocument.getFieldValue(FieldUtils.HIDDEN));\n        assertEquals(EntityType.DOCUMENT.name(), solrDocument.getFieldValue(FieldUtils.TYPE));\n\n        assertEquals(fullName, solrDocument.getFieldValue(FieldUtils.FULLNAME));\n\n        assertEquals(title, solrDocument.getFieldValue(FieldUtils.getFieldName(FieldUtils.TITLE, Locale.US)));\n        assertEquals(rawContent,\n            solrDocument.getFieldValue(FieldUtils.getFieldName(FieldUtils.DOCUMENT_RAW_CONTENT, Locale.US)));\n        assertEquals(renderedContent,\n            solrDocument.getFieldValue(FieldUtils.getFieldName(FieldUtils.DOCUMENT_RENDERED_CONTENT, Locale.US)));\n\n        assertEquals(version, solrDocument.getFieldValue(FieldUtils.VERSION));\n        assertEquals(comment, solrDocument.getFieldValue(FieldUtils.COMMENT));\n\n        assertEquals(authorStringReference, solrDocument.getFieldValue(FieldUtils.AUTHOR));\n        assertEquals(authorDisplayName, solrDocument.getFieldValue(FieldUtils.AUTHOR_DISPLAY));\n        assertEquals(creatorStringReference, solrDocument.getFieldValue(FieldUtils.CREATOR));\n        assertEquals(creatorDisplayName, solrDocument.getFieldValue(FieldUtils.CREATOR_DISPLAY));\n\n        assertEquals(creationDate, solrDocument.getFieldValue(FieldUtils.CREATIONDATE));\n        assertEquals(date, solrDocument.get(FieldUtils.DATE).getValue());\n    }","id":78329,"modified_method":"@Test\n    public void getSimpleDocument() throws Exception\n    {\n        //\n        // Mock\n        //\n\n        // ID\n        String id = \"wiki:Space.Name_\" + Locale.ROOT.toString();\n        SolrReferenceResolver documentSolrReferenceResolver =\n            this.mocker.getInstance(SolrReferenceResolver.class, \"document\");\n        when(documentSolrReferenceResolver.getId(documentReference)).thenReturn(id);\n\n        // Full Name\n        String fullName = \"Space.Name\";\n        EntityReferenceSerializer<String> localEntityReferenceSerializer =\n            this.mocker.registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"local\");\n        when(localEntityReferenceSerializer.serialize(this.documentReference)).thenReturn(fullName);\n\n        // Hierarchy\n        when(localEntityReferenceSerializer.serialize(this.documentReference.getParent())).thenReturn(\"Path.To.Page\");\n        when(localEntityReferenceSerializer.serialize(this.documentReference.getParent().getParent())).thenReturn(\n            \"Path.To\");\n        when(localEntityReferenceSerializer.serialize(this.documentReference.getParent().getParent().getParent()))\n            .thenReturn(\"Path\");\n\n        // Creator.\n        DocumentReference creatorReference = new DocumentReference(\"wiki\", \"Space\", \"Creator\");\n        when(this.document.getCreatorReference()).thenReturn(creatorReference);\n\n        String creatorStringReference = \"wiki:Space.Creator\";\n        EntityReferenceSerializer<String> entityReferenceSerializer =\n            this.mocker.registerMockComponent(EntityReferenceSerializer.TYPE_STRING, \"default\");\n        when(entityReferenceSerializer.serialize(creatorReference)).thenReturn(creatorStringReference);\n\n        String creatorDisplayName = \"Crea Tor\";\n        when(this.xcontext.getWiki().getPlainUserName(creatorReference, this.xcontext)).thenReturn(creatorDisplayName);\n\n        // Author.\n        DocumentReference authorReference = new DocumentReference(\"wiki\", \"Space\", \"Author\");\n        when(this.document.getAuthorReference()).thenReturn(authorReference);\n\n        String authorStringReference = \"wiki:Space.Author\";\n        when(entityReferenceSerializer.serialize(authorReference)).thenReturn(authorStringReference);\n\n        String authorDisplayName = \"Au Thor\";\n        when(this.xcontext.getWiki().getPlainUserName(authorReference, this.xcontext)).thenReturn(authorDisplayName);\n\n        // Creation Date\n        Date creationDate = new Date();\n        when(this.document.getCreationDate()).thenReturn(creationDate);\n\n        // Date\n        Date date = new Date();\n        when(this.document.getContentUpdateDate()).thenReturn(date);\n\n        // Version\n        String version = \"1.1\";\n        when(this.document.getVersion()).thenReturn(version);\n\n        // Version summary\n        String comment = \"1.1 comment\";\n        when(this.document.getComment()).thenReturn(comment);\n\n        // XObjects.\n        when(this.document.getXObjects()).thenReturn(Collections.<DocumentReference, List<BaseObject>> emptyMap());\n\n        // Title\n        String title = \"title\";\n        when(this.document.getRenderedTitle(any(Syntax.class), eq(this.xcontext))).thenReturn(title);\n\n        // Rendered Content\n        final String renderedContent = \"rendered content\";\n        BlockRenderer plainRenderer = this.mocker.registerMockComponent(BlockRenderer.class, \"plain/1.0\");\n        doAnswer(new Answer<Object>()\n        {\n            @Override\n            public Object answer(InvocationOnMock invocation)\n            {\n                Object[] args = invocation.getArguments();\n\n                WikiPrinter printer = (WikiPrinter) args[1];\n                printer.print(renderedContent);\n\n                return null;\n            }\n        }).when(plainRenderer).render(any(Block.class), any(WikiPrinter.class));\n\n        // Raw Content\n        String rawContent = \"raw content\";\n        when(this.document.getContent()).thenReturn(rawContent);\n\n        //\n        // Call\n        //\n        SolrInputDocument solrDocument = this.mocker.getComponentUnderTest().getSolrDocument(this.documentReference);\n\n        //\n        // Assert and verify\n        //\n        assertEquals(id, solrDocument.getFieldValue(FieldUtils.ID));\n\n        assertEquals(this.documentReference.getWikiReference().getName(), solrDocument.getFieldValue(FieldUtils.WIKI));\n        assertEquals(Arrays.asList(\"Path\", \"To\", \"Page\"), solrDocument.getFieldValues(FieldUtils.SPACE));\n        assertEquals(this.documentReference.getName(), solrDocument.getFieldValue(FieldUtils.NAME));\n\n        assertEquals(Arrays.asList(\"0/Path.\", \"1/Path.To.\", \"2/Path.To.Page.\"),\n            solrDocument.getFieldValues(FieldUtils.SPACE_FACET));\n        assertEquals(Arrays.asList(\"Path\", \"Path.To\", \"Path.To.Page\"),\n            solrDocument.getFieldValues(FieldUtils.SPACE_PREFIX));\n\n        assertEquals(Locale.US.toString(), solrDocument.getFieldValue(FieldUtils.LOCALE));\n        assertEquals(Locale.US.getLanguage(), solrDocument.getFieldValue(FieldUtils.LANGUAGE));\n        Collection< ? > actualLocales = solrDocument.getFieldValues(FieldUtils.LOCALES);\n        // The order of the locales in the returned collection is nondeterministic.\n        assertTrue(actualLocales.size() == 2 && actualLocales.contains(\"\")\n            && actualLocales.contains(Locale.US.toString()));\n        assertEquals(this.document.isHidden(), solrDocument.getFieldValue(FieldUtils.HIDDEN));\n        assertEquals(EntityType.DOCUMENT.name(), solrDocument.getFieldValue(FieldUtils.TYPE));\n\n        assertEquals(fullName, solrDocument.getFieldValue(FieldUtils.FULLNAME));\n\n        assertEquals(title, solrDocument.getFieldValue(FieldUtils.getFieldName(FieldUtils.TITLE, Locale.US)));\n        assertEquals(rawContent,\n            solrDocument.getFieldValue(FieldUtils.getFieldName(FieldUtils.DOCUMENT_RAW_CONTENT, Locale.US)));\n        assertEquals(renderedContent,\n            solrDocument.getFieldValue(FieldUtils.getFieldName(FieldUtils.DOCUMENT_RENDERED_CONTENT, Locale.US)));\n\n        assertEquals(version, solrDocument.getFieldValue(FieldUtils.VERSION));\n        assertEquals(comment, solrDocument.getFieldValue(FieldUtils.COMMENT));\n\n        assertEquals(authorStringReference, solrDocument.getFieldValue(FieldUtils.AUTHOR));\n        assertEquals(authorDisplayName, solrDocument.getFieldValue(FieldUtils.AUTHOR_DISPLAY));\n        assertEquals(creatorStringReference, solrDocument.getFieldValue(FieldUtils.CREATOR));\n        assertEquals(creatorDisplayName, solrDocument.getFieldValue(FieldUtils.CREATOR_DISPLAY));\n\n        assertEquals(creationDate, solrDocument.getFieldValue(FieldUtils.CREATIONDATE));\n        assertEquals(date, solrDocument.get(FieldUtils.DATE).getValue());\n    }","commit_id":"28e786ebba5304431a77bc30a6e47fc1048aa86f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private EntityReference getSpaceReference(SolrDocument solrDocument, EntityReference parent, Object... parameters)\n    {\n        String localSpaceReference = (String) solrDocument.get(FieldUtils.SPACE);\n        if (!StringUtils.isEmpty(localSpaceReference)) {\n            return this.explicitStringEntityReferenceResolver.resolve(localSpaceReference, EntityType.SPACE, parent);\n        } else {\n            return resolveMissingReference(EntityType.SPACE, parent, parameters);\n        }\n    }","id":78330,"modified_method":"private EntityReference getSpaceReference(SolrDocument solrDocument, EntityReference parent, Object... parameters)\n    {\n        Collection<Object> spaceNames = solrDocument.getFieldValues(FieldUtils.SPACE);\n        if (spaceNames != null && !spaceNames.isEmpty()) {\n            EntityReference spaceReference = parent;\n            for (Object spaceName : spaceNames) {\n                spaceReference = new EntityReference(String.valueOf(spaceName), EntityType.SPACE, spaceReference);\n            }\n            return spaceReference;\n        } else {\n            return resolveMissingReference(EntityType.SPACE, parent, parameters);\n        }\n    }","commit_id":"28e786ebba5304431a77bc30a6e47fc1048aa86f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Before\n    public void configure() throws Exception\n    {\n        solrDocument = new SolrDocument();\n        solrDocument.setField(FieldUtils.WIKI, \"chess\");\n        solrDocument.setField(FieldUtils.SPACE, \"Path.To.Success\");\n        solrDocument.setField(FieldUtils.NAME, \"WebHome\");\n        solrDocument.setField(FieldUtils.DOCUMENT_LOCALE, \"fr\");\n        // The file name field can have multiple values.\n        solrDocument.addField(FieldUtils.FILENAME, \"image.png\");\n        solrDocument.addField(FieldUtils.FILENAME, \"presentation.odp\");\n        // The class name field can have multiple values too.\n        solrDocument.addField(FieldUtils.CLASS, \"App.Code.PlayerClass\");\n        solrDocument.addField(FieldUtils.CLASS, \"App.Code.TrainerClass\");\n        solrDocument.setField(FieldUtils.NUMBER, 13);\n        solrDocument.setField(FieldUtils.PROPERTY_NAME, \"age\");\n\n        EntityReferenceResolver<String> explicitStringEntityReferenceResolver =\n            this.mocker.getInstance(EntityReferenceResolver.TYPE_STRING, \"explicit\");\n        WikiReference wikiReference = new WikiReference(\"chess\");\n        SpaceReference spaceReference =\n            new SpaceReference(\"Success\", new SpaceReference(\"To\", new SpaceReference(\"Path\", wikiReference)));\n        when(explicitStringEntityReferenceResolver.resolve(\"Path.To.Success\", EntityType.SPACE, wikiReference))\n            .thenReturn(spaceReference);\n\n        EntityReferenceResolver<EntityReference> explicitReferenceEntityReferenceResolver =\n            this.mocker.getInstance(EntityReferenceResolver.TYPE_REFERENCE, \"explicit\");\n        doAnswer(new Answer<EntityReference>()\n        {\n            @Override\n            public EntityReference answer(InvocationOnMock invocation) throws Throwable\n            {\n                EntityReference reference = invocation.getArgumentAt(0, EntityReference.class);\n                EntityType type = invocation.getArgumentAt(1, EntityType.class);\n                return reference.extractReference(type);\n            }\n        }).when(explicitReferenceEntityReferenceResolver).resolve(any(EntityReference.class), any(EntityType.class));\n    }","id":78331,"modified_method":"@Before\n    public void configure() throws Exception\n    {\n        solrDocument = new SolrDocument();\n        solrDocument.setField(FieldUtils.WIKI, \"chess\");\n        solrDocument.setField(FieldUtils.SPACE, Arrays.asList(\"Path\", \"To\", \"Success\"));\n        solrDocument.setField(FieldUtils.NAME, \"WebHome\");\n        solrDocument.setField(FieldUtils.DOCUMENT_LOCALE, \"fr\");\n        // The file name field can have multiple values.\n        solrDocument.addField(FieldUtils.FILENAME, \"image.png\");\n        solrDocument.addField(FieldUtils.FILENAME, \"presentation.odp\");\n        // The class name field can have multiple values too.\n        solrDocument.addField(FieldUtils.CLASS, \"App.Code.PlayerClass\");\n        solrDocument.addField(FieldUtils.CLASS, \"App.Code.TrainerClass\");\n        solrDocument.setField(FieldUtils.NUMBER, 13);\n        solrDocument.setField(FieldUtils.PROPERTY_NAME, \"age\");\n\n        EntityReferenceResolver<EntityReference> explicitReferenceEntityReferenceResolver =\n            this.mocker.getInstance(EntityReferenceResolver.TYPE_REFERENCE, \"explicit\");\n        doAnswer(new Answer<EntityReference>()\n        {\n            @Override\n            public EntityReference answer(InvocationOnMock invocation) throws Throwable\n            {\n                EntityReference reference = invocation.getArgumentAt(0, EntityReference.class);\n                EntityType type = invocation.getArgumentAt(1, EntityType.class);\n                return reference.extractReference(type);\n            }\n        }).when(explicitReferenceEntityReferenceResolver).resolve(any(EntityReference.class), any(EntityType.class));\n    }","commit_id":"28e786ebba5304431a77bc30a6e47fc1048aa86f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public static void login(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tString login, String password, boolean rememberMe, String authType)\n\t\tthrows Exception {\n\n\t\tCookieKeys.validateSupportCookie(request);\n\n\t\tHttpSession session = request.getSession();\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong userId = getAuthenticatedUserId(\n\t\t\trequest, login, password, authType);\n\n\t\tif (!PropsValues.AUTH_SIMULTANEOUS_LOGINS) {\n\t\t\tMap<String, UserTracker> sessionUsers = LiveUsers.getSessionUsers(\n\t\t\t\tcompany.getCompanyId());\n\n\t\t\tList<UserTracker> userTrackers = new ArrayList<UserTracker>(\n\t\t\t\tsessionUsers.values());\n\n\t\t\tfor (UserTracker userTracker : userTrackers) {\n\t\t\t\tif (userId == userTracker.getUserId()) {\n\t\t\t\t\tHttpSession userTrackerSession =  PortalSessionContext.get(\n\t\t\t\t\t\tuserTracker.getSessionId());\n\n\t\t\t\t\tuserTrackerSession.invalidate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PropsValues.SESSION_ENABLE_PHISHING_PROTECTION) {\n\n\t\t\t// Invalidate the previous session to prevent phishing\n\n\t\t\tString[] protectedAttributeNames =\n\t\t\t\tPropsValues.SESSION_PHISHING_PROTECTED_ATTRIBUTES;\n\n\t\t\tMap<String, Object> protectedAttributes =\n\t\t\t\tnew HashMap<String, Object>();\n\n\t\t\tfor (String protectedAttributeName : protectedAttributeNames) {\n\t\t\t\tObject protectedAttributeValue = session.getAttribute(\n\t\t\t\t\tprotectedAttributeName);\n\n\t\t\t\tif (protectedAttributeValue == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprotectedAttributes.put(\n\t\t\t\t\tprotectedAttributeName, protectedAttributeValue);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tsession.invalidate();\n\t\t\t}\n\t\t\tcatch (IllegalStateException ise) {\n\n\t\t\t\t// This only happens in Geronimo\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(ise.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession = request.getSession(true);\n\n\t\t\tfor (String protectedAttributeName : protectedAttributeNames) {\n\t\t\t\tObject protectedAttributeValue = protectedAttributes.get(\n\t\t\t\t\tprotectedAttributeName);\n\n\t\t\t\tif (protectedAttributeValue == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsession.setAttribute(\n\t\t\t\t\tprotectedAttributeName, protectedAttributeValue);\n\t\t\t}\n\t\t}\n\n\t\t// Set cookies\n\n\t\tString domain = CookieKeys.getDomain(request);\n\n\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\tString userIdString = String.valueOf(userId);\n\n\t\tsession.setAttribute(\"j_username\", userIdString);\n\t\tsession.setAttribute(\"j_password\", user.getPassword());\n\t\tsession.setAttribute(\"j_remoteuser\", userIdString);\n\n\t\tif (PropsValues.SESSION_STORE_PASSWORD) {\n\t\t\tsession.setAttribute(WebKeys.USER_PASSWORD, password);\n\t\t}\n\n\t\tCookie companyIdCookie = new Cookie(\n\t\t\tCookieKeys.COMPANY_ID, String.valueOf(company.getCompanyId()));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tcompanyIdCookie.setDomain(domain);\n\t\t}\n\n\t\tcompanyIdCookie.setPath(StringPool.SLASH);\n\n\t\tCookie idCookie = new Cookie(\n\t\t\tCookieKeys.ID, UserLocalServiceUtil.encryptUserId(userIdString));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tidCookie.setDomain(domain);\n\t\t}\n\n\t\tidCookie.setPath(StringPool.SLASH);\n\n\t\tCookie passwordCookie = new Cookie(\n\t\t\tCookieKeys.PASSWORD,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), password));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tpasswordCookie.setDomain(domain);\n\t\t}\n\n\t\tpasswordCookie.setPath(StringPool.SLASH);\n\n\t\tCookie rememberMeCookie = new Cookie(\n\t\t\tCookieKeys.REMEMBER_ME, Boolean.TRUE.toString());\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\trememberMeCookie.setDomain(domain);\n\t\t}\n\n\t\trememberMeCookie.setPath(StringPool.SLASH);\n\n\t\tint loginMaxAge = PropsValues.COMPANY_SECURITY_AUTO_LOGIN_MAX_AGE;\n\n\t\tif (PropsValues.SESSION_DISABLED) {\n\t\t\trememberMe = true;\n\t\t}\n\n\t\tif (rememberMe) {\n\t\t\tcompanyIdCookie.setMaxAge(loginMaxAge);\n\t\t\tidCookie.setMaxAge(loginMaxAge);\n\t\t\tpasswordCookie.setMaxAge(loginMaxAge);\n\t\t\trememberMeCookie.setMaxAge(loginMaxAge);\n\t\t}\n\t\telse {\n\n\t\t\t// This was explicitly changed from 0 to -1 so that the cookie lasts\n\t\t\t// as long as the browser. This allows an external servlet wrapped\n\t\t\t// in AutoLoginFilter to work throughout the client connection. The\n\t\t\t// cookies ARE removed on an actual logout, so there is no security\n\t\t\t// issue. See LEP-4678 and LEP-5177.\n\n\t\t\tcompanyIdCookie.setMaxAge(-1);\n\t\t\tidCookie.setMaxAge(-1);\n\t\t\tpasswordCookie.setMaxAge(-1);\n\t\t\trememberMeCookie.setMaxAge(0);\n\t\t}\n\n\t\tCookie loginCookie = new Cookie(CookieKeys.LOGIN, login);\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tloginCookie.setDomain(domain);\n\t\t}\n\n\t\tloginCookie.setMaxAge(loginMaxAge);\n\t\tloginCookie.setPath(StringPool.SLASH);\n\n\t\tCookie screenNameCookie = new Cookie(\n\t\t\tCookieKeys.SCREEN_NAME,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), user.getScreenName()));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tscreenNameCookie.setDomain(domain);\n\t\t}\n\n\t\tscreenNameCookie.setMaxAge(loginMaxAge);\n\t\tscreenNameCookie.setPath(StringPool.SLASH);\n\n\t\tboolean secure = request.isSecure();\n\n\t\tif (secure) {\n\t\t\tBoolean httpsInitial = (Boolean)session.getAttribute(\n\t\t\t\tWebKeys.HTTPS_INITIAL);\n\n\t\t\tif ((httpsInitial == null) || !httpsInitial.booleanValue()) {\n\t\t\t\tsecure = false;\n\t\t\t}\n\t\t}\n\n\t\tCookieKeys.addCookie(request, response, companyIdCookie, secure);\n\t\tCookieKeys.addCookie(request, response, idCookie, secure);\n\t\tCookieKeys.addCookie(request, response, passwordCookie, secure);\n\t\tCookieKeys.addCookie(request, response, rememberMeCookie, secure);\n\t\tCookieKeys.addCookie(request, response, loginCookie, secure);\n\t\tCookieKeys.addCookie(request, response, screenNameCookie, secure);\n\t}","id":78332,"modified_method":"public static void login(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tString login, String password, boolean rememberMe, String authType)\n\t\tthrows Exception {\n\n\t\tCookieKeys.validateSupportCookie(request);\n\n\t\tHttpSession session = request.getSession();\n\n\t\tCompany company = PortalUtil.getCompany(request);\n\n\t\tlong userId = getAuthenticatedUserId(\n\t\t\trequest, login, password, authType);\n\n\t\tif (!PropsValues.AUTH_SIMULTANEOUS_LOGINS) {\n\t\t\tMap<String, UserTracker> sessionUsers = LiveUsers.getSessionUsers(\n\t\t\t\tcompany.getCompanyId());\n\n\t\t\tList<UserTracker> userTrackers = new ArrayList<UserTracker>(\n\t\t\t\tsessionUsers.values());\n\n\t\t\tfor (UserTracker userTracker : userTrackers) {\n\t\t\t\tif (userId == userTracker.getUserId()) {\n\t\t\t\t\tHttpSession userTrackerSession =  PortalSessionContext.get(\n\t\t\t\t\t\tuserTracker.getSessionId());\n\n\t\t\t\t\tif (userTrackerSession != null) {\n\t\t\t\t\t\tuserTrackerSession.invalidate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PropsValues.SESSION_ENABLE_PHISHING_PROTECTION) {\n\n\t\t\t// Invalidate the previous session to prevent phishing\n\n\t\t\tString[] protectedAttributeNames =\n\t\t\t\tPropsValues.SESSION_PHISHING_PROTECTED_ATTRIBUTES;\n\n\t\t\tMap<String, Object> protectedAttributes =\n\t\t\t\tnew HashMap<String, Object>();\n\n\t\t\tfor (String protectedAttributeName : protectedAttributeNames) {\n\t\t\t\tObject protectedAttributeValue = session.getAttribute(\n\t\t\t\t\tprotectedAttributeName);\n\n\t\t\t\tif (protectedAttributeValue == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprotectedAttributes.put(\n\t\t\t\t\tprotectedAttributeName, protectedAttributeValue);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tsession.invalidate();\n\t\t\t}\n\t\t\tcatch (IllegalStateException ise) {\n\n\t\t\t\t// This only happens in Geronimo\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(ise.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsession = request.getSession(true);\n\n\t\t\tfor (String protectedAttributeName : protectedAttributeNames) {\n\t\t\t\tObject protectedAttributeValue = protectedAttributes.get(\n\t\t\t\t\tprotectedAttributeName);\n\n\t\t\t\tif (protectedAttributeValue == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsession.setAttribute(\n\t\t\t\t\tprotectedAttributeName, protectedAttributeValue);\n\t\t\t}\n\t\t}\n\n\t\t// Set cookies\n\n\t\tString domain = CookieKeys.getDomain(request);\n\n\t\tUser user = UserLocalServiceUtil.getUserById(userId);\n\n\t\tString userIdString = String.valueOf(userId);\n\n\t\tsession.setAttribute(\"j_username\", userIdString);\n\t\tsession.setAttribute(\"j_password\", user.getPassword());\n\t\tsession.setAttribute(\"j_remoteuser\", userIdString);\n\n\t\tif (PropsValues.SESSION_STORE_PASSWORD) {\n\t\t\tsession.setAttribute(WebKeys.USER_PASSWORD, password);\n\t\t}\n\n\t\tCookie companyIdCookie = new Cookie(\n\t\t\tCookieKeys.COMPANY_ID, String.valueOf(company.getCompanyId()));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tcompanyIdCookie.setDomain(domain);\n\t\t}\n\n\t\tcompanyIdCookie.setPath(StringPool.SLASH);\n\n\t\tCookie idCookie = new Cookie(\n\t\t\tCookieKeys.ID, UserLocalServiceUtil.encryptUserId(userIdString));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tidCookie.setDomain(domain);\n\t\t}\n\n\t\tidCookie.setPath(StringPool.SLASH);\n\n\t\tCookie passwordCookie = new Cookie(\n\t\t\tCookieKeys.PASSWORD,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), password));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tpasswordCookie.setDomain(domain);\n\t\t}\n\n\t\tpasswordCookie.setPath(StringPool.SLASH);\n\n\t\tCookie rememberMeCookie = new Cookie(\n\t\t\tCookieKeys.REMEMBER_ME, Boolean.TRUE.toString());\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\trememberMeCookie.setDomain(domain);\n\t\t}\n\n\t\trememberMeCookie.setPath(StringPool.SLASH);\n\n\t\tint loginMaxAge = PropsValues.COMPANY_SECURITY_AUTO_LOGIN_MAX_AGE;\n\n\t\tif (PropsValues.SESSION_DISABLED) {\n\t\t\trememberMe = true;\n\t\t}\n\n\t\tif (rememberMe) {\n\t\t\tcompanyIdCookie.setMaxAge(loginMaxAge);\n\t\t\tidCookie.setMaxAge(loginMaxAge);\n\t\t\tpasswordCookie.setMaxAge(loginMaxAge);\n\t\t\trememberMeCookie.setMaxAge(loginMaxAge);\n\t\t}\n\t\telse {\n\n\t\t\t// This was explicitly changed from 0 to -1 so that the cookie lasts\n\t\t\t// as long as the browser. This allows an external servlet wrapped\n\t\t\t// in AutoLoginFilter to work throughout the client connection. The\n\t\t\t// cookies ARE removed on an actual logout, so there is no security\n\t\t\t// issue. See LEP-4678 and LEP-5177.\n\n\t\t\tcompanyIdCookie.setMaxAge(-1);\n\t\t\tidCookie.setMaxAge(-1);\n\t\t\tpasswordCookie.setMaxAge(-1);\n\t\t\trememberMeCookie.setMaxAge(0);\n\t\t}\n\n\t\tCookie loginCookie = new Cookie(CookieKeys.LOGIN, login);\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tloginCookie.setDomain(domain);\n\t\t}\n\n\t\tloginCookie.setMaxAge(loginMaxAge);\n\t\tloginCookie.setPath(StringPool.SLASH);\n\n\t\tCookie screenNameCookie = new Cookie(\n\t\t\tCookieKeys.SCREEN_NAME,\n\t\t\tEncryptor.encrypt(company.getKeyObj(), user.getScreenName()));\n\n\t\tif (Validator.isNotNull(domain)) {\n\t\t\tscreenNameCookie.setDomain(domain);\n\t\t}\n\n\t\tscreenNameCookie.setMaxAge(loginMaxAge);\n\t\tscreenNameCookie.setPath(StringPool.SLASH);\n\n\t\tboolean secure = request.isSecure();\n\n\t\tif (secure) {\n\t\t\tBoolean httpsInitial = (Boolean)session.getAttribute(\n\t\t\t\tWebKeys.HTTPS_INITIAL);\n\n\t\t\tif ((httpsInitial == null) || !httpsInitial.booleanValue()) {\n\t\t\t\tsecure = false;\n\t\t\t}\n\t\t}\n\n\t\tCookieKeys.addCookie(request, response, companyIdCookie, secure);\n\t\tCookieKeys.addCookie(request, response, idCookie, secure);\n\t\tCookieKeys.addCookie(request, response, passwordCookie, secure);\n\t\tCookieKeys.addCookie(request, response, rememberMeCookie, secure);\n\t\tCookieKeys.addCookie(request, response, loginCookie, secure);\n\t\tCookieKeys.addCookie(request, response, screenNameCookie, secure);\n\t}","commit_id":"7e02e92b0429f978b8d0d162f3d4327db46c3260","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * \n\t * @param remoteUser\n\t * @param targetFragmentOwner\n\t * @return \"yes\" for success, \"no\" otherwise\n\t */\n\tpublic String swapToFragmentOwner(final String remoteUser, final String targetFragmentOwner, RequestContext requestContext) {\n\t\tIAuthorizationPrincipal principal = authorizationService.newPrincipal(remoteUser, IPerson.class);\n\t\tif(principal.hasPermission(UP_USERS, IMPERSONATE, targetFragmentOwner)) {\n\t\t\tPortletRequest portletRequest = (PortletRequest) requestContext.getExternalContext().getNativeRequest();\n\t\t\tPortletSession session = portletRequest.getPortletSession();\n\t\t\tsession.setAttribute(LoginController.SWAP_TARGET_UID, targetFragmentOwner, javax.portlet.PortletSession.APPLICATION_SCOPE);\n\t\t\treturn \"yes\";\n\t\t}\n\t\treturn \"no\";\n\t}","id":78333,"modified_method":"/**\n\t * \n\t * @param remoteUser\n\t * @param targetFragmentOwner\n\t * @return \"yes\" for success, \"no\" otherwise\n\t */\n\tpublic String swapToFragmentOwner(final String remoteUser, final String targetFragmentOwner, RequestContext requestContext) {\n\t\tPortletRequest portletRequest = (PortletRequest) requestContext.getExternalContext().getNativeRequest();\n\t\tthis.identitySwapperManager.impersonateUser(portletRequest, remoteUser, targetFragmentOwner);\n\t\treturn \"yes\";\n\t}","commit_id":"8e9aa73c0cfd52a9705b5e92d89491e990d42343","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n\t * @param legacyConfigurationLoader the legacyConfigurationLoader to set\n\t */\n\t@Autowired\n\tpublic void setConfigurationLoader(\n\t\t\tConfigurationLoader configurationLoader) {\n\t\tthis.configurationLoader = configurationLoader;\n\t}","id":78334,"modified_method":"@Autowired\n\tpublic void setConfigurationLoader(\n\t\t\tConfigurationLoader configurationLoader) {\n\t\tthis.configurationLoader = configurationLoader;\n\t}","commit_id":"8e9aa73c0cfd52a9705b5e92d89491e990d42343","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n\t * \n\t * @param remoteUser\n\t * @return\n\t */\n\tpublic Map<String, String> getAuthorizedDlmFragments(String remoteUser) {\n\t\tList<FragmentDefinition> fragments = this.configurationLoader.getFragments();\n\t\tIAuthorizationPrincipal principal = authorizationService.newPrincipal(remoteUser, IPerson.class);\n\t\tMap<String, String> results = new TreeMap<String, String>();\n\t\tfor(FragmentDefinition frag: fragments) {\n\t\t\tif(principal.hasPermission(UP_USERS, IMPERSONATE, frag.getOwnerId())) {\n\t\t\t\tresults.put(frag.getOwnerId(), frag.getName());\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}","id":78335,"modified_method":"/**\n\t * \n\t * @param remoteUser\n\t * @return\n\t */\n\tpublic Map<String, String> getAuthorizedDlmFragments(String remoteUser) {\n\t\tList<FragmentDefinition> fragments = this.configurationLoader.getFragments();\n\t\tMap<String, String> results = new TreeMap<String, String>();\n\t\tfor(FragmentDefinition frag: fragments) {\n\t\t\tif(this.identitySwapperManager.canImpersonateUser(remoteUser, frag.getOwnerId())) {\n\t\t\t\tresults.put(frag.getOwnerId(), frag.getName());\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}","commit_id":"8e9aa73c0cfd52a9705b5e92d89491e990d42343","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Process the incoming request and response.\n     * @param request HttpServletRequest object\n     * @param response HttpServletResponse object\n     * @throws ServletException\n     * @throws IOException\n     */\n    @RequestMapping\n    public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirect = this.getRedirectionUrl(request);\n        final HttpSession session = request.getSession(false);\n\n        if (session != null) {\n            // Record that an authenticated user is requesting to log out\n            try {\n                final IPerson person = personManager.getPerson(request);\n                if (person != null && person.getSecurityContext().isAuthenticated()) {\n                    this.portalEventFactory.publishLogoutEvent(request, this, person);\n                }\n            }\n            catch (final Exception e) {\n                log.error(\"Exception recording logout \" + \"associated with request \" + request, e);\n            }\n\n            final String originalUid = (String) session.getAttribute(LoginController.SWAP_ORIGINAL_UID);\n            //Logging out from a swapped user, just redirect to the Login servlet\n            if (originalUid != null) {\n                redirect = request.getContextPath() + \"/Login\";\n            }\n            else {\n                // Clear out the existing session for the user\n                try {\n                    session.invalidate();\n                }\n                catch (final IllegalStateException ise) {\n                    // IllegalStateException indicates session was already invalidated.\n                    // This is fine.  LogoutController is looking to guarantee the logged out session is invalid;\n                    // it need not insist that it be the one to perform the invalidating.\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"LogoutController encountered IllegalStateException invalidating a presumably already-invalidated session.\",\n                                ise);\n                    }\n                }\n            }\n        }\n\n        // Send the user back to the guest page\n        final String encodedRedirectURL = response.encodeRedirectURL(redirect);\n        response.sendRedirect(encodedRedirectURL);\n    }","id":78336,"modified_method":"/**\n     * Process the incoming request and response.\n     * @param request HttpServletRequest object\n     * @param response HttpServletResponse object\n     * @throws ServletException\n     * @throws IOException\n     */\n    @RequestMapping\n    public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String redirect = this.getRedirectionUrl(request);\n        final HttpSession session = request.getSession(false);\n\n        if (session != null) {\n            // Record that an authenticated user is requesting to log out\n            try {\n                final IPerson person = personManager.getPerson(request);\n                if (person != null && person.getSecurityContext().isAuthenticated()) {\n                    this.portalEventFactory.publishLogoutEvent(request, this, person);\n                }\n            }\n            catch (final Exception e) {\n                log.error(\"Exception recording logout \" + \"associated with request \" + request, e);\n            }\n\n            final String originalUid = this.identitySwapperManager.getOriginalUsername(session);\n            //Logging out from a swapped user, just redirect to the Login servlet\n            if (originalUid != null) {\n                redirect = request.getContextPath() + \"/Login\";\n            }\n            else {\n                // Clear out the existing session for the user\n                try {\n                    session.invalidate();\n                }\n                catch (final IllegalStateException ise) {\n                    // IllegalStateException indicates session was already invalidated.\n                    // This is fine.  LogoutController is looking to guarantee the logged out session is invalid;\n                    // it need not insist that it be the one to perform the invalidating.\n                    if (log.isTraceEnabled()) {\n                        log.trace(\"LogoutController encountered IllegalStateException invalidating a presumably already-invalidated session.\",\n                                ise);\n                    }\n                }\n            }\n        }\n\n        // Send the user back to the guest page\n        final String encodedRedirectURL = response.encodeRedirectURL(redirect);\n        response.sendRedirect(encodedRedirectURL);\n    }","commit_id":"8e9aa73c0cfd52a9705b5e92d89491e990d42343","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void doPortalAuthentication(HttpServletRequest request) {\n        // Clear out the existing session for the user if they have one\n        String targetUid = null;\n        String originalUid = null;\n        boolean swap = false;\n        if (request.isRequestedSessionIdValid()) {\n            try {\n                HttpSession s = request.getSession(false);\n                //Check if this is a swapped user hitting the Login servlet\n                originalUid = (String) s.getAttribute(LoginController.SWAP_ORIGINAL_UID);\n\n                //No original person in session so check for swap request\n                if (originalUid == null) {\n                    targetUid = (String) s.getAttribute(LoginController.SWAP_TARGET_UID);\n                    if (targetUid != null) {\n                        final IPerson person = personManager.getPerson(request);\n                        originalUid = person.getName();\n                        swap = true;\n                    }\n                }\n                else {\n                    final IPerson person = personManager.getPerson(request);\n                    targetUid = person.getName();\n                }\n\n                s.invalidate();\n            }\n            catch (IllegalStateException ise) {\n                // ISE indicates session was already invalidated.\n                // This is fine.  This servlet trying to guarantee that the session has been invalidated;\n                // it doesn't have to insist that it is the one that invalidated it.\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"LoginServlet attempted to invalidate an already invalid session.\", ise);\n                }\n            }\n        }\n\n        //  Create the user's session\n        HttpSession s = request.getSession(true);\n\n        final String requestedProfile = request.getParameter(LoginController.REQUESTED_PROFILE_KEY);\n        if (requestedProfile != null) {\n            s.setAttribute(SessionAttributeProfileMapperImpl.DEFAULT_SESSION_ATTRIBUTE_NAME, requestedProfile);\n        }\n\n        IPerson person = null;\n        try {\n            final HashMap<String, String> principals;\n            final HashMap<String, String> credentials;\n\n            // Get the person object associated with the request\n            person = personManager.getPerson(request);\n\n            //If doing an identity swap\n            if (targetUid != null && originalUid != null) {\n                if (swap) {\n                    swapperLog.warn(\"Swapping identity for '\" + originalUid + \"' to '\" + targetUid + \"'\");\n\n                    //Track the originating user\n                    s.setAttribute(LoginController.SWAP_ORIGINAL_UID, originalUid);\n\n                    //Setup the swapped person\n                    person.setUserName(targetUid);\n                    personManager.setImpersonating(request, true);\n                }\n                else {\n                    swapperLog.warn(\"Reverting swapped identity from '\" + targetUid + \"' to '\" + originalUid + \"'\");\n\n                    person.setUserName(originalUid);\n                    personManager.setImpersonating(request, false);\n                }\n\n                //Setup the custom security context\n                final IdentitySwapperPrincipal identitySwapperPrincipal = new IdentitySwapperPrincipal(person);\n                final IdentitySwapperSecurityContext identitySwapperSecurityContext = new IdentitySwapperSecurityContext(\n                        identitySwapperPrincipal);\n                person.setSecurityContext(identitySwapperSecurityContext);\n\n                principals = new HashMap<String, String>();\n                credentials = new HashMap<String, String>();\n            }\n            //Norm authN path\n            else {\n                // WE grab all of the principals and credentials from the request and load\n                // them into their respective HashMaps.\n                principals = getPropertyFromRequest(principalTokens, request);\n                credentials = getPropertyFromRequest(credentialTokens, request);\n            }\n\n            // Attempt to authenticate using the incoming request\n            authenticationService.authenticate(request, principals, credentials, person);\n        }\n        catch (Exception e) {\n            // Log the exception\n            logger.error(\"Exception authenticating the request\", e);\n            // Reset everything\n            request.getSession(false).invalidate();\n            // Add the authentication failure\n            request.getSession(true).setAttribute(LoginController.AUTH_ERROR_KEY, Boolean.TRUE);\n        }\n    }","id":78337,"modified_method":"private void doPortalAuthentication(HttpServletRequest request) {\n        // Clear out the existing session for the user if they have one\n        String targetUid = null;\n        String originalUid = null;\n        boolean swap = false;\n        if (request.isRequestedSessionIdValid()) {\n            try {\n                HttpSession s = request.getSession(false);\n                \n                if (s != null) {\n                    //Check if this is a swapped user hitting the Login servlet\n                    originalUid = this.identitySwapperManager.getOriginalUsername(s);\n                }\n\n                //No original person in session so check for swap request\n                if (originalUid == null) {\n                    targetUid = this.identitySwapperManager.getTargetUsername(s);\n                    if (targetUid != null) {\n                        final IPerson person = personManager.getPerson(request);\n                        originalUid = person.getName();\n                        swap = true;\n                    }\n                }\n                else {\n                    final IPerson person = personManager.getPerson(request);\n                    targetUid = person.getName();\n                }\n\n                if (s != null) {\n                    s.invalidate();\n                }\n            }\n            catch (IllegalStateException ise) {\n                // ISE indicates session was already invalidated.\n                // This is fine.  This servlet trying to guarantee that the session has been invalidated;\n                // it doesn't have to insist that it is the one that invalidated it.\n                if (logger.isTraceEnabled()) {\n                    logger.trace(\"LoginServlet attempted to invalidate an already invalid session.\", ise);\n                }\n            }\n        }\n\n        //  Create the user's session\n        HttpSession s = request.getSession(true);\n\n        final String requestedProfile = request.getParameter(LoginController.REQUESTED_PROFILE_KEY);\n        if (requestedProfile != null) {\n            s.setAttribute(SessionAttributeProfileMapperImpl.DEFAULT_SESSION_ATTRIBUTE_NAME, requestedProfile);\n        }\n\n        IPerson person = null;\n        try {\n            final HashMap<String, String> principals;\n            final HashMap<String, String> credentials;\n\n            // Get the person object associated with the request\n            person = personManager.getPerson(request);\n\n            //If doing an identity swap\n            if (targetUid != null && originalUid != null) {\n                if (swap) {\n                    swapperLog.warn(\"Swapping identity for '\" + originalUid + \"' to '\" + targetUid + \"'\");\n                    \n                    //Track the originating user\n                    this.identitySwapperManager.setOriginalUser(s, originalUid, targetUid);\n\n                    //Setup the swapped person\n                    person.setUserName(targetUid);\n                    personManager.setImpersonating(request, true);\n                }\n                else {\n                    swapperLog.warn(\"Reverting swapped identity from '\" + targetUid + \"' to '\" + originalUid + \"'\");\n\n                    person.setUserName(originalUid);\n                    personManager.setImpersonating(request, false);\n                }\n\n                //Setup the custom security context\n                final IdentitySwapperPrincipal identitySwapperPrincipal = new IdentitySwapperPrincipal(person);\n                final IdentitySwapperSecurityContext identitySwapperSecurityContext = new IdentitySwapperSecurityContext(\n                        identitySwapperPrincipal);\n                person.setSecurityContext(identitySwapperSecurityContext);\n\n                principals = new HashMap<String, String>();\n                credentials = new HashMap<String, String>();\n            }\n            //Norm authN path\n            else {\n                // WE grab all of the principals and credentials from the request and load\n                // them into their respective HashMaps.\n                principals = getPropertyFromRequest(principalTokens, request);\n                credentials = getPropertyFromRequest(credentialTokens, request);\n            }\n\n            // Attempt to authenticate using the incoming request\n            authenticationService.authenticate(request, principals, credentials, person);\n        }\n        catch (Exception e) {\n            // Log the exception\n            logger.error(\"Exception authenticating the request\", e);\n            // Reset everything\n            request.getSession(false).invalidate();\n            // Add the authentication failure\n            request.getSession(true).setAttribute(LoginController.AUTH_ERROR_KEY, Boolean.TRUE);\n        }\n    }","commit_id":"8e9aa73c0cfd52a9705b5e92d89491e990d42343","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n\t * Overwritten to lock collections before they are removed.\n\t */\n\tprotected Cacheable removeOne(Cacheable item) {\n\t\tCollection old;\n\t\tLock lock;\n\t\tdouble rd = 0, minRd = -1;\n\t\tint bucket = -1;\t\t\n\t\tfor (int i = 0; i < items.length; i++) {\n\t\t\told = (Collection)items[i];\n\t\t\tif (old == null) {\n\t\t\t\tbucket = i;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlock = old.getLock(); \n\t\t\t\t\t// calculate the reference density\n\t\t\t\t\trd =\n\t\t\t\t\t\told.getReferenceCount()\n\t\t\t\t\t\t\t/ (double)(totalReferences - old.getTimestamp());\n\t\t\t\t\t// attempt to acquire a read lock on the collection.\n\t\t\t\t\t// the collection is not considered for removal if the lock \n\t\t\t\t\t// cannot be acquired immediately.\n\t\t\t\t\tif(lock.attempt(Lock.READ_LOCK)) {\n\t\t\t\t\t\tif ((minRd < 0 || rd < minRd) && old.allowUnload()) {\n\t\t\t\t\t\t\tminRd = rd;\n\t\t\t\t\t\t\tbucket = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlock.release(Lock.READ_LOCK);\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bucket < 0)\n\t\t\tbucket = 0;\n\t\told = (Collection)items[bucket];\n\t\tif (old != null) {\n\t\t\tpool.getConfigurationManager().invalidate(old.getURI());\n\t\t\tmap.remove(old.getKey());\n\t\t\tnames.remove(old.getURI().getRawCollectionPath());\n\t\t\told.sync(true);\n\t\t}\n\t\titems[bucket] = item;\n\t\tmap.put(item.getKey(), item);\n        \n        accounting.replacedPage(item);\n        if (cacheManager != null && accounting.resizeNeeded()) {\n            accounting.stats();\n            cacheManager.requestMem(this);\n        }\n\t\treturn old;\n\t}","id":78338,"modified_method":"/**\n\t * Overwritten to lock collections before they are removed.\n\t */\n\tprotected Cacheable removeOne(Cacheable item) {\n\t\tCollection old;\n\t\tLock lock;\n\t\tdouble rd = 0, minRd = -1;\n\t\tint bucket = -1;\t\t\n\t\tfor (int i = 0; i < items.length; i++) {\n\t\t\told = (Collection)items[i];\n\t\t\tif (old == null) {\n\t\t\t\tbucket = i;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlock = old.getLock(); \n\t\t\t\t\t// calculate the reference density\n\t\t\t\t\trd =\n\t\t\t\t\t\told.getReferenceCount()\n\t\t\t\t\t\t\t/ (double)(totalReferences - old.getTimestamp());\n\t\t\t\t\t// attempt to acquire a read lock on the collection.\n\t\t\t\t\t// the collection is not considered for removal if the lock \n\t\t\t\t\t// cannot be acquired immediately.\n\t\t\t\t\tif(lock.attempt(Lock.READ_LOCK)) {\n\t\t\t\t\t\tif ((minRd < 0 || rd < minRd) && old.allowUnload()) {\n\t\t\t\t\t\t\tminRd = rd;\n\t\t\t\t\t\t\tbucket = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlock.release(Lock.READ_LOCK);\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bucket < 0)\n\t\t\tbucket = 0;\n\t\told = (Collection)items[bucket];\n\t\tif (old != null) {\n\t\t\tif(pool.getConfigurationManager()!=null){ // might be null during db initialization\n\t\t\t\tpool.getConfigurationManager().invalidate(old.getURI());\n            }\n\t\t\tmap.remove(old.getKey());\n\t\t\tnames.remove(old.getURI().getRawCollectionPath());\n\t\t\told.sync(true);\n\t\t}\n\t\titems[bucket] = item;\n\t\tmap.put(item.getKey(), item);\n        \n        accounting.replacedPage(item);\n        if (cacheManager != null && accounting.resizeNeeded()) {\n            accounting.stats();\n            cacheManager.requestMem(this);\n        }\n\t\treturn old;\n\t}","commit_id":"96cd5588de638be5bc0e844d6db9e39a444faaef","url":"https://github.com/eXist-db/exist"},{"original_method":"/** Generates the attributes for the specified properties\n\t * and namespaces.\n\t *\n\t * @param props a map of name and value pairs or null\n\t * if no properties at all.\n\t * Note: the value doesn't contain any EL expression.\n\t * @param namespaces a list of {@link Namespace}\n\t * to be generated, or null if not.\n\t * Note: EL expressions is not allowed\n\t */\n\tpublic static final\n\tvoid getAttributes(StringBuffer sb, Map<String, Object> props, Collection<Namespace> namespaces) {\n\t\tif (namespaces != null && !namespaces.isEmpty()) {\n\t\t\tfor (Namespace ns: namespaces) {\n\t\t\t\tsb.append(\" xmlns\");\n\t\t\t\tif (ns.getPrefix().length() > 0)\n\t\t\t\t\tsb.append(':').append(ns.getPrefix());\n\t\t\t\tsb.append(\"=\\\"\").append(ns.getURI()).append('\"');\n\t\t\t}\n\t\t}\n\n\t\tif (props != null && !props.isEmpty()) {\n\t\t\tfor (Map.Entry<String, Object> me: props.entrySet()) {\n\t\t\t\tHTMLs.appendAttribute(sb,\n\t\t\t\t\tme.getKey(), Objects.toString(me.getValue()));\n\t\t\t}\n\t\t}\n\t}","id":78339,"modified_method":"/** Generates the attributes for the specified properties\n\t * and namespaces.\n\t *\n\t * @param props a map of name and value pairs or null\n\t * if no properties at all.\n\t * Note: the value doesn't contain any EL expression.\n\t * @param namespaces a list of {@link Namespace}\n\t * to be generated, or null if not.\n\t * Note: EL expressions is not allowed\n\t */\n\tpublic static final\n\tvoid getAttributes(StringBuffer sb, Map<String, Object> props, Collection<Namespace> namespaces) {\n\t\tif (namespaces != null && !namespaces.isEmpty()) {\n\t\t\tfor (Namespace ns: namespaces) {\n\t\t\t\tsb.append(\" xmlns\");\n\t\t\t\tif (ns.getPrefix().length() > 0)\n\t\t\t\t\tsb.append(':').append(ns.getPrefix());\n\t\t\t\tsb.append(\"=\\\"\").append(ns.getURI()).append('\"');\n\t\t\t}\n\t\t}\n\n\t\tif (props != null && !props.isEmpty()) {\n\t\t\tfor (Map.Entry<String, Object> me: props.entrySet()) {\n\t\t\t\tHTMLs.appendAttribute(sb,\n\t\t\t\t\tme.getKey(), Objects.toString(me.getValue()), false);\n\t\t\t}\n\t\t}\n\t}","commit_id":"00062cd2482fae6e6ae10bf149f156170c3a3e7c","url":"https://github.com/zkoss/zk"},{"original_method":"public void invalidate() {\n\t\tif (!invalidateParent()) super.invalidate();\n\t\telse getParent().invalidate();\n\t}","id":78340,"modified_method":"public void invalidate() {\n\t\tif (!invalidateParent()) super.invalidate();\n\t\telse if (getParent() != null) getParent().invalidate();\n\t}","commit_id":"00062cd2482fae6e6ae10bf149f156170c3a3e7c","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n   * Process the incoming HttpServletRequest\n   * @param request\n   * @param response\n   * @exception ServletException\n   * @exception IOException\n   */\n  public void service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  \tCommonUtils.setNoCache(response);\n    \n    // Call to setCharacterEncoding method should be done before any call to req.getParameter() method.\n    try {\n        request.setCharacterEncoding(\"UTF-8\");\n    } catch (UnsupportedEncodingException uee) {\n        log.error(\"Unable to set UTF-8 character encoding!\", uee);\n    }\n    \n  \t/* Grab the target functional name, if any, off the login request.\n\t * Also any arguments for the target\n  \t * We will pass them  along after authentication.\n  \t */\n  \tString targetFname = request.getParameter(\"uP_fname\");\n  \tString targetArgs = request.getParameter(\"uP_args\");\n  \t// Clear out the existing session for the user\n    request.getSession().invalidate();\n  \t//  Retrieve the user's session\n    request.getSession(true);\n  \tIPerson person = null;\n    try {\n      // Get the person object associated with the request\n      person = PersonManagerFactory.getPersonManagerInstance().getPerson(request);\n      // WE grab all of the principals and credentials from the request and load\n      // them into their respective HashMaps.\n      HashMap principals = getPropertyFromRequest (principalTokens, request);\n      HashMap credentials = getPropertyFromRequest (credentialTokens, request);\n\n      // Attempt to authenticate using the incoming request\n      m_authenticationService.authenticate(principals, credentials, person);\n    } catch (Exception e) {\n      // Log the exception\n      log.error(\"Exception authenticating the request\", e);\n      // Reset everything\n      request.getSession(false).invalidate();\n      // Add the authentication failure\n      request.getSession(true).setAttribute(\"up_authenticationError\", \"true\");\n      person = null;\n    }\n    // Check to see if the person has been authenticated\n    if (person != null && person.getSecurityContext().isAuthenticated()) {\n      // Send the now authenticated user back to the PortalSessionManager servlet\n    \tString redirectTarget = null;\n\n\t\t\tif (targetFname == null){\n\t\t\t\tredirectTarget = request.getContextPath() + \"/\" + redirectString;\n\t\t\t} else {\n\t\t\t\tredirectTarget = request.getContextPath() + \"/\" +\n\t\t\t\t\"tag.idempotent.\" +  redirectString + \"?uP_fname=\" + targetFname;\n\t\t\t\tif (targetArgs != null) {\n\t\t\t\tredirectTarget = redirectTarget + \"&uP_args=\" + targetArgs;\n\t\t\t\t}\n\t\t\t} \n    \t    \t\n      response.sendRedirect(redirectTarget);\n    }\n    else {\n      if ( request.getMethod().equals(\"POST\") )\t\n       request.getSession(false).setAttribute(\"up_authenticationAttempted\", \"true\");\n      // Preserve the attempted username so it can be redisplayed to the user by CLogin\n      String attemptedUserName = request.getParameter(\"userName\");\n      if (attemptedUserName != null)\n        request.getSession(false).setAttribute(\"up_attemptedUserName\", request.getParameter(\"userName\"));\n      // Send the unauthenticated user back to the PortalSessionManager servlet\n      response.sendRedirect(request.getContextPath() + '/' + redirectString);\n    }\n  }","id":78341,"modified_method":"/**\n   * Process the incoming HttpServletRequest\n   * @param request\n   * @param response\n   * @exception ServletException\n   * @exception IOException\n   */\n  public void service (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n  \tCommonUtils.setNoCache(response);\n    \n    // Call to setCharacterEncoding method should be done before any call to req.getParameter() method.\n    try {\n        request.setCharacterEncoding(\"UTF-8\");\n    } catch (UnsupportedEncodingException uee) {\n        log.error(\"Unable to set UTF-8 character encoding!\", uee);\n    }\n    \n  \t/* Grab the target functional name, if any, off the login request.\n\t * Also any arguments for the target\n  \t * We will pass them  along after authentication.\n  \t */\n  \tString targetFname = request.getParameter(\"uP_fname\");\n  \tString targetArgs = request.getParameter(\"uP_args\");\n  \t// Clear out the existing session for the user\n    if (request.getSession(false) != null)\n        request.getSession().invalidate();\n    //  Retrieve the user's session\n    request.getSession(true);\n  \tIPerson person = null;\n    try {\n      // Get the person object associated with the request\n      person = PersonManagerFactory.getPersonManagerInstance().getPerson(request);\n      // WE grab all of the principals and credentials from the request and load\n      // them into their respective HashMaps.\n      HashMap principals = getPropertyFromRequest (principalTokens, request);\n      HashMap credentials = getPropertyFromRequest (credentialTokens, request);\n\n      // Attempt to authenticate using the incoming request\n      m_authenticationService.authenticate(principals, credentials, person);\n    } catch (Exception e) {\n      // Log the exception\n      log.error(\"Exception authenticating the request\", e);\n      // Reset everything\n      request.getSession(false).invalidate();\n      // Add the authentication failure\n      request.getSession(true).setAttribute(\"up_authenticationError\", \"true\");\n      person = null;\n    }\n    // Check to see if the person has been authenticated\n    if (person != null && person.getSecurityContext().isAuthenticated()) {\n      // Send the now authenticated user back to the PortalSessionManager servlet\n    \tString redirectTarget = null;\n\n\t\t\tif (targetFname == null){\n\t\t\t\tredirectTarget = request.getContextPath() + \"/\" + redirectString;\n\t\t\t} else {\n\t\t\t\tredirectTarget = request.getContextPath() + \"/\" +\n\t\t\t\t\"tag.idempotent.\" +  redirectString + \"?uP_fname=\" + targetFname;\n\t\t\t\tif (targetArgs != null) {\n\t\t\t\tredirectTarget = redirectTarget + \"&uP_args=\" + targetArgs;\n\t\t\t\t}\n\t\t\t} \n    \t    \t\n      response.sendRedirect(redirectTarget);\n    }\n    else {\n      if ( request.getMethod().equals(\"POST\") )\t\n       request.getSession(false).setAttribute(\"up_authenticationAttempted\", \"true\");\n      // Preserve the attempted username so it can be redisplayed to the user by CLogin\n      String attemptedUserName = request.getParameter(\"userName\");\n      if (attemptedUserName != null)\n        request.getSession(false).setAttribute(\"up_attemptedUserName\", request.getParameter(\"userName\"));\n      // Send the unauthenticated user back to the PortalSessionManager servlet\n      response.sendRedirect(request.getContextPath() + '/' + redirectString);\n    }\n  }","commit_id":"f92ef0a10bae97eb1171c796e4dcb4e7077b172c","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void remove(Cacheable item) {\n    \tfinal Collection col = (Collection) item;\n        super.remove(item);\n        names.remove(col.getName());\n        pool.getConfigurationManager().invalidate(col.getName());\n    }","id":78342,"modified_method":"public void remove(Cacheable item) {\n    \tfinal Collection col = (Collection) item;\n        super.remove(item);\n        names.remove(col.getName());\n        if(pool.getConfigurationManager() != null) // might be null during db initialization\n            pool.getConfigurationManager().invalidate(col.getName());\n    }","commit_id":"550851003928b6abc10c0ca3197527f2c79f6d2e","url":"https://github.com/eXist-db/exist"},{"original_method":"private void invalidateIfNeeded() {\n    if (myLabel.getRootPane() == null) return;\n\n    if (myLabel.getSize() != null && myLabel.getSize().equals(myLabel.getPreferredSize())) return;\n\n    setInactiveStateImage(null);\n\n    myLabel.invalidate();\n    myActionPanel.invalidate();\n\n    myTabs.revalidateAndRepaint(false);\n  }","id":78343,"modified_method":"private void invalidateIfNeeded() {\n    if (myLabel.getRootPane() == null) return;\n\n    if (myLabel.getSize() != null && myLabel.getSize().equals(myLabel.getPreferredSize())) return;\n\n    setInactiveStateImage(null);\n\n    myLabel.invalidate();\n\n    if (myActionPanel != null) {\n      myActionPanel.invalidate();\n    }\n\n    myTabs.revalidateAndRepaint(false);\n  }","commit_id":"d3a5ce2de726f8b05d441b306bb9e744680601fc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public synchronized void deleteSegment(UUID segmentId) {\n        while (currentlyLoading.contains(segmentId)) {\n            try {\n                wait(); // for another thread to finish loading the segment\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"Interrupted\", e);\n            }\n        }\n        segments.invalidate(segmentId);\n    }","id":78344,"modified_method":"@Override\n    public synchronized void deleteSegment(UUID segmentId) {\n        while (currentlyLoading.contains(segmentId)) {\n            try {\n                wait(); // for another thread to finish loading the segment\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"Interrupted\", e);\n            }\n        }\n        if (segments != null) {\n            segments.invalidate(segmentId);\n        }\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected AbstractStore(int cacheSize) {\n        this.segments = CacheLIRS.newBuilder()\n                .weigher(Segment.WEIGHER)\n                .maximumWeight(cacheSize)\n                .build();\n    }","id":78345,"modified_method":"protected AbstractStore(int cacheSizeMB) {\n        if (cacheSizeMB > 0) {\n            this.segments = CacheLIRS.newBuilder()\n                    .weigher(Segment.WEIGHER)\n                    .maximumWeight(cacheSizeMB * MB)\n                    .build();\n        } else {\n            this.segments = null;\n        }\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Segment readSegment(UUID id) {\n        Segment segment = segments.getIfPresent(id);\n        if (segment != null) {\n            return segment;\n        }\n\n        segment = getWriter().getCurrentSegment(id);\n        if (segment != null) {\n            return segment;\n        }\n\n        synchronized (this) {\n            segment = segments.getIfPresent(id);\n            while (segment == null && currentlyLoading.contains(id)) {\n                try {\n                    wait(); // for another thread to load the segment\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(\"Interrupted\", e);\n                }\n                segment = segments.getIfPresent(id);\n            }\n            if (segment != null) {\n                return segment;\n            }\n            currentlyLoading.add(id);\n        }\n\n        try {\n            segment = loadSegment(id);\n            if (segment == null) {\n                throw new IllegalStateException(\"Unable to find segment \" + id);\n            }\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Failed to load segment \" + id, e);\n        } finally {\n            synchronized (this) {\n                if (segment != null) {\n                    segments.put(id, segment);\n                }\n                currentlyLoading.remove(id);\n                notifyAll();\n            }\n        }\n\n        return segment;\n    }","id":78346,"modified_method":"@Override\n    public Segment readSegment(UUID id) {\n        Segment segment = null;\n        if (segments != null) {\n            segment = segments.getIfPresent(id);\n            if (segment != null) {\n                return segment;\n            }\n        }\n\n        segment = getWriter().getCurrentSegment(id);\n        if (segment != null) {\n            return segment;\n        }\n\n        if (segments == null) {\n            // no caching, just load the segment directly\n            try {\n                return loadSegment(id);\n            } catch (Exception e) {\n                throw new IllegalStateException(\"Failed to load segment \" + id, e);\n            }\n        }\n\n        synchronized (this) {\n            segment = segments.getIfPresent(id);\n            while (segment == null && currentlyLoading.contains(id)) {\n                try {\n                    wait(); // for another thread to load the segment\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(\"Interrupted\", e);\n                }\n                segment = segments.getIfPresent(id);\n            }\n            if (segment != null) {\n                return segment;\n            }\n            currentlyLoading.add(id);\n        }\n\n        try {\n            segment = loadSegment(id);\n            if (segment == null) {\n                throw new IllegalStateException(\"Unable to find segment \" + id);\n            }\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Failed to load segment \" + id, e);\n        } finally {\n            synchronized (this) {\n                if (segment != null) {\n                    segments.put(id, segment);\n                }\n                currentlyLoading.remove(id);\n                notifyAll();\n            }\n        }\n\n        return segment;\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public synchronized void close() {\n        while (!currentlyLoading.isEmpty()) {\n            try {\n                wait(); // for other threads to finish loading segments\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"Interrupted\", e);\n            }\n        }\n        records.invalidateAll();\n        segments.invalidateAll();\n    }","id":78347,"modified_method":"@Override\n    public synchronized void close() {\n        while (!currentlyLoading.isEmpty()) {\n            try {\n                wait(); // for other threads to finish loading segments\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\"Interrupted\", e);\n            }\n        }\n        records.invalidateAll();\n        if (segments != null) {\n            segments.invalidateAll();\n        }\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static void main(String[] args) throws Exception {\n        OptionParser parser = new OptionParser();\n        OptionSpec<File> base = parser.accepts(\"base\", \"Base directory\")\n                .withRequiredArg().ofType(File.class)\n                .defaultsTo(new File(\"target\"));\n        OptionSpec<String> host = parser.accepts(\"host\", \"MongoDB host\")\n                .withRequiredArg().defaultsTo(\"localhost\");\n        OptionSpec<Integer> port = parser.accepts(\"port\", \"MongoDB port\")\n                .withRequiredArg().ofType(Integer.class).defaultsTo(27017);\n        OptionSpec<String> dbName = parser.accepts(\"db\", \"MongoDB database\")\n                .withRequiredArg();\n        OptionSpec<Boolean> dropDBAfterTest = parser.accepts(\"dropDBAfterTest\", \"Whether to drop the MongoDB database after the test\")\n                .withOptionalArg().ofType(Boolean.class).defaultsTo(true);\n        OptionSpec<Boolean> mmap = parser.accepts(\"mmap\", \"TarMK memory mapping\")\n                .withOptionalArg().ofType(Boolean.class)\n                .defaultsTo(\"64\".equals(System.getProperty(\"sun.arch.data.model\")));\n        OptionSpec<Integer> cache = parser.accepts(\"cache\", \"cache size (MB)\")\n                .withRequiredArg().ofType(Integer.class).defaultsTo(100);\n        OptionSpec<File> wikipedia =\n                parser.accepts(\"wikipedia\", \"Wikipedia dump\")\n                .withRequiredArg().ofType(File.class);\n        OptionSpec<Boolean> runAsAdmin = parser.accepts(\"runAsAdmin\", \"Run test using admin session\")\n                .withRequiredArg().ofType(Boolean.class).defaultsTo(Boolean.FALSE);\n        OptionSpec<Integer> itemsToRead = parser.accepts(\"itemsToRead\", \"Number of items to read\")\n                .withRequiredArg().ofType(Integer.class).defaultsTo(1000);\n        OptionSpec<Integer> concurrency = parser.accepts(\"concurrency\", \"Number of test threads.\")\n                .withRequiredArg().ofType(Integer.class).withValuesSeparatedBy(',');\n        OptionSpec<Boolean> report = parser.accepts(\"report\", \"Whether to output intermediate results\")\n                .withOptionalArg().ofType(Boolean.class)\n                .defaultsTo(Boolean.FALSE);\n        OptionSpec<Boolean> randomUser = parser.accepts(\"randomUser\", \"Whether to use a random user to read.\")\n                        .withOptionalArg().ofType(Boolean.class)\n                        .defaultsTo(Boolean.FALSE);\n        OptionSpec<File> csvFile = parser.accepts(\"csvFile\", \"File to write a CSV version of the benchmark data.\")\n                .withOptionalArg().ofType(File.class);\n\n        OptionSet options = parser.parse(args);\n        int cacheSize = cache.value(options);\n        RepositoryFixture[] allFixtures = new RepositoryFixture[] {\n                new JackrabbitRepositoryFixture(\n                        base.value(options), cacheSize),\n                OakRepositoryFixture.getMemory(cacheSize * MB),\n                OakRepositoryFixture.getDefault(\n                        base.value(options), cacheSize * MB),\n                OakRepositoryFixture.getMongo(\n                        host.value(options), port.value(options),\n                        dbName.value(options), dropDBAfterTest.value(options),\n                        cacheSize * MB),\n                OakRepositoryFixture.getMongoNS(\n                        host.value(options), port.value(options),\n                        dbName.value(options), dropDBAfterTest.value(options),\n                        cacheSize * MB),\n                OakRepositoryFixture.getSegment(\n                        host.value(options), port.value(options), cacheSize * MB),\n                OakRepositoryFixture.getTar(\n                        base.value(options), 256 * MB, cacheSize * MB, mmap.value(options))\n        };\n        Benchmark[] allBenchmarks = new Benchmark[] {\n            new LoginTest(),\n            new LoginLogoutTest(),\n            new NamespaceTest(),\n            new NamespaceRegistryTest(),\n            new ReadPropertyTest(),\n            GetNodeTest.withAdmin(),\n            GetNodeTest.withAnonymous(),\n            new GetDeepNodeTest(),\n            new SetPropertyTest(),\n            new SmallFileReadTest(),\n            new SmallFileWriteTest(),\n            new ConcurrentReadTest(),\n            new ConcurrentReadWriteTest(),\n            new ConcurrentWriteReadTest(),\n            new ConcurrentWriteTest(),\n            new SimpleSearchTest(),\n            new SQL2SearchTest(),\n            new DescendantSearchTest(),\n            new SQL2DescendantSearchTest(),\n            new CreateManyChildNodesTest(),\n            new CreateManyNodesTest(),\n            new UpdateManyChildNodesTest(),\n            new TransientManyChildNodesTest(),\n            new WikipediaImport(wikipedia.value(options)),\n            new CreateNodesBenchmark(),\n            new ManyNodes(),\n            new ObservationTest(),\n            new XmlImportTest(),\n            new FlatTreeWithAceForSamePrincipalTest(),\n            new ReadDeepTreeTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ConcurrentReadDeepTreeTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ConcurrentReadSinglePolicyTreeTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ConcurrentReadAccessControlledTreeTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ConcurrentReadAccessControlledTreeTest2(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ConcurrentReadRandomNodeAndItsPropertiesTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ManyUserReadTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options),\n                    randomUser.value(options)),\n            new ConcurrentTraversalTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options),\n                    randomUser.value(options)),\n            ReadManyTest.linear(\"LinearReadEmpty\", 1, ReadManyTest.EMPTY),\n            ReadManyTest.linear(\"LinearReadFiles\", 1, ReadManyTest.FILES),\n            ReadManyTest.linear(\"LinearReadNodes\", 1, ReadManyTest.NODES),\n            ReadManyTest.uniform(\"UniformReadEmpty\", 1, ReadManyTest.EMPTY),\n            ReadManyTest.uniform(\"UniformReadFiles\", 1, ReadManyTest.FILES),\n            ReadManyTest.uniform(\"UniformReadNodes\", 1, ReadManyTest.NODES),\n            new ConcurrentCreateNodesTest(),\n            new SequentialCreateNodesTest(),\n        };\n\n        Set<String> argset = Sets.newHashSet(options.nonOptionArguments());\n        List<RepositoryFixture> fixtures = Lists.newArrayList();\n        for (RepositoryFixture fixture : allFixtures) {\n            if (argset.remove(fixture.toString())) {\n                fixtures.add(fixture);\n            }\n        }\n\n        List<Benchmark> benchmarks = Lists.newArrayList();\n        for (Benchmark benchmark : allBenchmarks) {\n            if (argset.remove(benchmark.toString())) {\n                benchmarks.add(benchmark);\n            }\n        }\n\n        if (argset.isEmpty()) {\n            PrintStream out = null;\n            if (options.has(csvFile)) {\n                out = new PrintStream(FileUtils.openOutputStream(csvFile.value(options), true));\n            }\n            for (Benchmark benchmark : benchmarks) {\n                if (benchmark instanceof CSVResultGenerator) {\n                    ((CSVResultGenerator) benchmark).setPrintStream(out);\n                }\n                benchmark.run(fixtures, options.valuesOf(concurrency));\n            }\n            if (out != null) {\n                out.close();\n            }\n        } else {\n            System.err.println(\"Unknown arguments: \" + argset);\n        }\n    }","id":78348,"modified_method":"public static void main(String[] args) throws Exception {\n        OptionParser parser = new OptionParser();\n        OptionSpec<File> base = parser.accepts(\"base\", \"Base directory\")\n                .withRequiredArg().ofType(File.class)\n                .defaultsTo(new File(\"target\"));\n        OptionSpec<String> host = parser.accepts(\"host\", \"MongoDB host\")\n                .withRequiredArg().defaultsTo(\"localhost\");\n        OptionSpec<Integer> port = parser.accepts(\"port\", \"MongoDB port\")\n                .withRequiredArg().ofType(Integer.class).defaultsTo(27017);\n        OptionSpec<String> dbName = parser.accepts(\"db\", \"MongoDB database\")\n                .withRequiredArg();\n        OptionSpec<Boolean> dropDBAfterTest = parser.accepts(\"dropDBAfterTest\", \"Whether to drop the MongoDB database after the test\")\n                .withOptionalArg().ofType(Boolean.class).defaultsTo(true);\n        OptionSpec<Boolean> mmap = parser.accepts(\"mmap\", \"TarMK memory mapping\")\n                .withOptionalArg().ofType(Boolean.class)\n                .defaultsTo(\"64\".equals(System.getProperty(\"sun.arch.data.model\")));\n        OptionSpec<Integer> cache = parser.accepts(\"cache\", \"cache size (MB)\")\n                .withRequiredArg().ofType(Integer.class).defaultsTo(100);\n        OptionSpec<File> wikipedia =\n                parser.accepts(\"wikipedia\", \"Wikipedia dump\")\n                .withRequiredArg().ofType(File.class);\n        OptionSpec<Boolean> runAsAdmin = parser.accepts(\"runAsAdmin\", \"Run test using admin session\")\n                .withRequiredArg().ofType(Boolean.class).defaultsTo(Boolean.FALSE);\n        OptionSpec<Integer> itemsToRead = parser.accepts(\"itemsToRead\", \"Number of items to read\")\n                .withRequiredArg().ofType(Integer.class).defaultsTo(1000);\n        OptionSpec<Integer> concurrency = parser.accepts(\"concurrency\", \"Number of test threads.\")\n                .withRequiredArg().ofType(Integer.class).withValuesSeparatedBy(',');\n        OptionSpec<Boolean> report = parser.accepts(\"report\", \"Whether to output intermediate results\")\n                .withOptionalArg().ofType(Boolean.class)\n                .defaultsTo(Boolean.FALSE);\n        OptionSpec<Boolean> randomUser = parser.accepts(\"randomUser\", \"Whether to use a random user to read.\")\n                        .withOptionalArg().ofType(Boolean.class)\n                        .defaultsTo(Boolean.FALSE);\n        OptionSpec<File> csvFile = parser.accepts(\"csvFile\", \"File to write a CSV version of the benchmark data.\")\n                .withOptionalArg().ofType(File.class);\n\n        OptionSet options = parser.parse(args);\n        int cacheSize = cache.value(options);\n        RepositoryFixture[] allFixtures = new RepositoryFixture[] {\n                new JackrabbitRepositoryFixture(\n                        base.value(options), cacheSize),\n                OakRepositoryFixture.getMemory(cacheSize * MB),\n                OakRepositoryFixture.getDefault(\n                        base.value(options), cacheSize * MB),\n                OakRepositoryFixture.getMongo(\n                        host.value(options), port.value(options),\n                        dbName.value(options), dropDBAfterTest.value(options),\n                        cacheSize * MB),\n                OakRepositoryFixture.getMongoNS(\n                        host.value(options), port.value(options),\n                        dbName.value(options), dropDBAfterTest.value(options),\n                        cacheSize * MB),\n                OakRepositoryFixture.getSegment(\n                        host.value(options), port.value(options), cacheSize),\n                OakRepositoryFixture.getTar(\n                        base.value(options), 256, cacheSize, mmap.value(options))\n        };\n        Benchmark[] allBenchmarks = new Benchmark[] {\n            new LoginTest(),\n            new LoginLogoutTest(),\n            new NamespaceTest(),\n            new NamespaceRegistryTest(),\n            new ReadPropertyTest(),\n            GetNodeTest.withAdmin(),\n            GetNodeTest.withAnonymous(),\n            new GetDeepNodeTest(),\n            new SetPropertyTest(),\n            new SmallFileReadTest(),\n            new SmallFileWriteTest(),\n            new ConcurrentReadTest(),\n            new ConcurrentReadWriteTest(),\n            new ConcurrentWriteReadTest(),\n            new ConcurrentWriteTest(),\n            new SimpleSearchTest(),\n            new SQL2SearchTest(),\n            new DescendantSearchTest(),\n            new SQL2DescendantSearchTest(),\n            new CreateManyChildNodesTest(),\n            new CreateManyNodesTest(),\n            new UpdateManyChildNodesTest(),\n            new TransientManyChildNodesTest(),\n            new WikipediaImport(wikipedia.value(options)),\n            new CreateNodesBenchmark(),\n            new ManyNodes(),\n            new ObservationTest(),\n            new XmlImportTest(),\n            new FlatTreeWithAceForSamePrincipalTest(),\n            new ReadDeepTreeTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ConcurrentReadDeepTreeTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ConcurrentReadSinglePolicyTreeTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ConcurrentReadAccessControlledTreeTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ConcurrentReadAccessControlledTreeTest2(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ConcurrentReadRandomNodeAndItsPropertiesTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options)),\n            new ManyUserReadTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options),\n                    randomUser.value(options)),\n            new ConcurrentTraversalTest(\n                    runAsAdmin.value(options),\n                    itemsToRead.value(options),\n                    report.value(options),\n                    randomUser.value(options)),\n            ReadManyTest.linear(\"LinearReadEmpty\", 1, ReadManyTest.EMPTY),\n            ReadManyTest.linear(\"LinearReadFiles\", 1, ReadManyTest.FILES),\n            ReadManyTest.linear(\"LinearReadNodes\", 1, ReadManyTest.NODES),\n            ReadManyTest.uniform(\"UniformReadEmpty\", 1, ReadManyTest.EMPTY),\n            ReadManyTest.uniform(\"UniformReadFiles\", 1, ReadManyTest.FILES),\n            ReadManyTest.uniform(\"UniformReadNodes\", 1, ReadManyTest.NODES),\n            new ConcurrentCreateNodesTest(),\n            new SequentialCreateNodesTest(),\n        };\n\n        Set<String> argset = Sets.newHashSet(options.nonOptionArguments());\n        List<RepositoryFixture> fixtures = Lists.newArrayList();\n        for (RepositoryFixture fixture : allFixtures) {\n            if (argset.remove(fixture.toString())) {\n                fixtures.add(fixture);\n            }\n        }\n\n        List<Benchmark> benchmarks = Lists.newArrayList();\n        for (Benchmark benchmark : allBenchmarks) {\n            if (argset.remove(benchmark.toString())) {\n                benchmarks.add(benchmark);\n            }\n        }\n\n        if (argset.isEmpty()) {\n            PrintStream out = null;\n            if (options.has(csvFile)) {\n                out = new PrintStream(FileUtils.openOutputStream(csvFile.value(options), true));\n            }\n            for (Benchmark benchmark : benchmarks) {\n                if (benchmark instanceof CSVResultGenerator) {\n                    ((CSVResultGenerator) benchmark).setPrintStream(out);\n                }\n                benchmark.run(fixtures, options.valuesOf(concurrency));\n            }\n            if (out != null) {\n                out.close();\n            }\n        } else {\n            System.err.println(\"Unknown arguments: \" + argset);\n        }\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public FileStore(File directory, int maxFileSize, int cacheSize,\n            boolean memoryMapping) throws IOException {\n        super(cacheSize);\n        checkNotNull(directory).mkdirs();\n        this.directory = directory;\n        this.maxFileSize = maxFileSize;\n        this.memoryMapping = memoryMapping;\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"bulk\", i);\n            File file = new File(directory, name);\n            if (file.isFile()) {\n                bulkFiles.add(new TarFile(file, maxFileSize, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"data\", i);\n            File file = new File(directory, name);\n            if (file.isFile()) {\n                dataFiles.add(new TarFile(file, maxFileSize, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        Segment segment = getWriter().getDummySegment();\n        for (TarFile tar : dataFiles) {\n            ByteBuffer buffer = tar.readEntry(JOURNALS_UUID);\n            if (buffer != null) {\n                checkState(JOURNAL_MAGIC == buffer.getLong());\n                int count = buffer.getInt();\n                for (int i = 0; i < count; i++) {\n                    byte[] b = new byte[buffer.getInt()];\n                    buffer.get(b);\n                    String name = new String(b, UTF_8);\n                    RecordId recordId = new RecordId(\n                            new UUID(buffer.getLong(), buffer.getLong()),\n                            buffer.getInt());\n                    journals.put(name, new FileJournal(\n                            this, new SegmentNodeState(segment, recordId)));\n                }\n            }\n        }\n\n        if (!journals.containsKey(\"root\")) {\n            NodeBuilder builder = EMPTY_NODE.builder();\n            builder.setChildNode(\"root\", EMPTY_NODE);\n            journals.put(\"root\", new FileJournal(this, builder.getNodeState()));\n        }\n    }","id":78349,"modified_method":"public FileStore(File directory, int maxFileSizeMB, int cacheSizeMB,\n            boolean memoryMapping) throws IOException {\n        super(cacheSizeMB);\n        checkNotNull(directory).mkdirs();\n        this.directory = directory;\n        this.maxFileSize = maxFileSizeMB * MB;\n        this.memoryMapping = memoryMapping;\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"bulk\", i);\n            File file = new File(directory, name);\n            if (file.isFile()) {\n                bulkFiles.add(new TarFile(file, maxFileSizeMB, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"data\", i);\n            File file = new File(directory, name);\n            if (file.isFile()) {\n                dataFiles.add(new TarFile(file, maxFileSizeMB, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        Segment segment = getWriter().getDummySegment();\n        for (TarFile tar : dataFiles) {\n            ByteBuffer buffer = tar.readEntry(JOURNALS_UUID);\n            if (buffer != null) {\n                checkState(JOURNAL_MAGIC == buffer.getLong());\n                int count = buffer.getInt();\n                for (int i = 0; i < count; i++) {\n                    byte[] b = new byte[buffer.getInt()];\n                    buffer.get(b);\n                    String name = new String(b, UTF_8);\n                    RecordId recordId = new RecordId(\n                            new UUID(buffer.getLong(), buffer.getLong()),\n                            buffer.getInt());\n                    journals.put(name, new FileJournal(\n                            this, new SegmentNodeState(segment, recordId)));\n                }\n            }\n        }\n\n        if (!journals.containsKey(\"root\")) {\n            NodeBuilder builder = EMPTY_NODE.builder();\n            builder.setChildNode(\"root\", EMPTY_NODE);\n            journals.put(\"root\", new FileJournal(this, builder.getNodeState()));\n        }\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public FileStore(File directory, int maxFileSize, boolean memoryMapping)\n            throws IOException {\n        this(directory, maxFileSize, DEFAULT_MEMORY_CACHE_SIZE, memoryMapping);\n    }","id":78350,"modified_method":"public FileStore(File directory, int maxFileSizeMB, boolean memoryMapping)\n            throws IOException {\n        this(directory, maxFileSizeMB, DEFAULT_MEMORY_CACHE_SIZE, memoryMapping);\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void upgrade(String olddir, String newdir) throws Exception {\n        RepositoryContext source = RepositoryContext.create(\n                RepositoryConfig.create(new File(olddir)));\n        try {\n            FileStore store = new FileStore(\n                    new File(newdir), 256 * 1024 * 1024, true);\n            try {\n                NodeStore target = new SegmentNodeStore(store);\n                new RepositoryUpgrade(source, target).copy();\n            } finally {\n                store.close();\n            }\n        } finally {\n            source.getRepository().shutdown();\n        }\n    }","id":78351,"modified_method":"private static void upgrade(String olddir, String newdir) throws Exception {\n        RepositoryContext source = RepositoryContext.create(\n                RepositoryConfig.create(new File(olddir)));\n        try {\n            FileStore store = new FileStore(new File(newdir), 256, true);\n            try {\n                NodeStore target = new SegmentNodeStore(store);\n                new RepositoryUpgrade(source, target).copy();\n            } finally {\n                store.close();\n            }\n        } finally {\n            source.getRepository().shutdown();\n        }\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static void main(String[] args) throws Exception {\n        printProductInfo();\n\n        String command = \"server\";\n        if (args.length > 0) {\n            command = args[0];\n            String[] tail = new String[args.length - 1];\n            System.arraycopy(args, 1, tail, 0, tail.length);\n            args = tail;\n        }\n        if (\"mk\".equals(command)) {\n            MicroKernelServer.main(args);\n        } else if (\"benchmark\".equals(command)){\n            BenchmarkRunner.main(args);\n        } else if (\"server\".equals(command)){\n            new HttpServer(URI, args);\n        } else if (\"upgrade\".equals(command)) {\n            if (args.length == 2) {\n                upgrade(args[0], args[1]);\n            } else {\n                System.err.println(\"usage: upgrade <olddir> <newdir>\");\n                System.exit(1);\n            }\n        } else if (\"tarmk\".equals(command)) {\n            if (args.length == 0) {\n                System.err.println(\"usage: tarmk <path> [id...]\");\n                System.exit(1);\n            } else {\n                System.out.println(\"TarMK \" + args[0]);\n                File file = new File(args[0]);\n                FileStore store = new FileStore(file, 256 * 1024 * 1024, false);\n                try {\n                    if (args.length == 1) {\n                        Map<UUID, List<UUID>> idmap = Maps.newHashMap();\n\n                        int dataCount = 0;\n                        long dataSize = 0;\n                        int bulkCount = 0;\n                        long bulkSize = 0;\n                        for (UUID uuid : store.getSegmentIds()) {\n                            if (SegmentIdFactory.isDataSegmentId(uuid)) {\n                                Segment segment = store.readSegment(uuid);\n                                dataCount++;\n                                dataSize += segment.size();\n                                idmap.put(uuid, segment.getReferencedIds());\n                            } else if (SegmentIdFactory.isBulkSegmentId(uuid)) {\n                                bulkCount++;\n                                bulkSize += store.readSegment(uuid).size();\n                                idmap.put(uuid, Collections.<UUID>emptyList());\n                            }\n                        }\n                        System.out.println(\"Total size:\");\n                        System.out.format(\n                                \"%6dMB in %6d data segments%n\",\n                                dataSize / (1024 * 1024), dataCount);\n                        System.out.format(\n                                \"%6dMB in %6d bulk segments%n\",\n                                bulkSize / (1024 * 1024), bulkCount);\n\n                        Set<UUID> garbage = newHashSet(idmap.keySet());\n                        Queue<UUID> queue = Queues.newArrayDeque();\n                        queue.add(store.getJournal(\"root\").getHead().getSegmentId());\n                        while (!queue.isEmpty()) {\n                            UUID id = queue.remove();\n                            if (garbage.remove(id)) {\n                                queue.addAll(idmap.get(id));\n                            }\n                        }\n                        dataCount = 0;\n                        dataSize = 0;\n                        bulkCount = 0;\n                        bulkSize = 0;\n                        for (UUID uuid : garbage) {\n                            if (SegmentIdFactory.isDataSegmentId(uuid)) {\n                                dataCount++;\n                                dataSize += store.readSegment(uuid).size();\n                            } else if (SegmentIdFactory.isBulkSegmentId(uuid)) {\n                                bulkCount++;\n                                bulkSize += store.readSegment(uuid).size();\n                            }\n                        }\n                        System.out.println(\"Available for garbage collection:\");\n                        System.out.format(\n                                \"%6dkB in %6d data segments%n\",\n                                dataSize / 1024, dataCount);\n                        System.out.format(\n                                \"%6dMB in %6d bulk segments%n\",\n                                bulkSize / (1024 * 1024), bulkCount);\n                    } else {\n                        for (int i = 1; i < args.length; i++) {\n                            UUID uuid = UUID.fromString(args[i]);\n                            System.out.println(store.readSegment(uuid));\n                        }\n                    }\n                } finally {\n                    store.close();\n                }\n            }\n        } else {\n            System.err.println(\"Unknown command: \" + command);\n            System.exit(1);\n        }\n    }","id":78352,"modified_method":"public static void main(String[] args) throws Exception {\n        printProductInfo();\n\n        String command = \"server\";\n        if (args.length > 0) {\n            command = args[0];\n            String[] tail = new String[args.length - 1];\n            System.arraycopy(args, 1, tail, 0, tail.length);\n            args = tail;\n        }\n        if (\"mk\".equals(command)) {\n            MicroKernelServer.main(args);\n        } else if (\"benchmark\".equals(command)){\n            BenchmarkRunner.main(args);\n        } else if (\"server\".equals(command)){\n            new HttpServer(URI, args);\n        } else if (\"upgrade\".equals(command)) {\n            if (args.length == 2) {\n                upgrade(args[0], args[1]);\n            } else {\n                System.err.println(\"usage: upgrade <olddir> <newdir>\");\n                System.exit(1);\n            }\n        } else if (\"tarmk\".equals(command)) {\n            if (args.length == 0) {\n                System.err.println(\"usage: tarmk <path> [id...]\");\n                System.exit(1);\n            } else {\n                System.out.println(\"TarMK \" + args[0]);\n                File file = new File(args[0]);\n                FileStore store = new FileStore(file, 256, false);\n                try {\n                    if (args.length == 1) {\n                        Map<UUID, List<UUID>> idmap = Maps.newHashMap();\n\n                        int dataCount = 0;\n                        long dataSize = 0;\n                        int bulkCount = 0;\n                        long bulkSize = 0;\n                        for (UUID uuid : store.getSegmentIds()) {\n                            if (SegmentIdFactory.isDataSegmentId(uuid)) {\n                                Segment segment = store.readSegment(uuid);\n                                dataCount++;\n                                dataSize += segment.size();\n                                idmap.put(uuid, segment.getReferencedIds());\n                            } else if (SegmentIdFactory.isBulkSegmentId(uuid)) {\n                                bulkCount++;\n                                bulkSize += store.readSegment(uuid).size();\n                                idmap.put(uuid, Collections.<UUID>emptyList());\n                            }\n                        }\n                        System.out.println(\"Total size:\");\n                        System.out.format(\n                                \"%6dMB in %6d data segments%n\",\n                                dataSize / (1024 * 1024), dataCount);\n                        System.out.format(\n                                \"%6dMB in %6d bulk segments%n\",\n                                bulkSize / (1024 * 1024), bulkCount);\n\n                        Set<UUID> garbage = newHashSet(idmap.keySet());\n                        Queue<UUID> queue = Queues.newArrayDeque();\n                        queue.add(store.getJournal(\"root\").getHead().getSegmentId());\n                        while (!queue.isEmpty()) {\n                            UUID id = queue.remove();\n                            if (garbage.remove(id)) {\n                                queue.addAll(idmap.get(id));\n                            }\n                        }\n                        dataCount = 0;\n                        dataSize = 0;\n                        bulkCount = 0;\n                        bulkSize = 0;\n                        for (UUID uuid : garbage) {\n                            if (SegmentIdFactory.isDataSegmentId(uuid)) {\n                                dataCount++;\n                                dataSize += store.readSegment(uuid).size();\n                            } else if (SegmentIdFactory.isBulkSegmentId(uuid)) {\n                                bulkCount++;\n                                bulkSize += store.readSegment(uuid).size();\n                            }\n                        }\n                        System.out.println(\"Available for garbage collection:\");\n                        System.out.format(\n                                \"%6dkB in %6d data segments%n\",\n                                dataSize / 1024, dataCount);\n                        System.out.format(\n                                \"%6dMB in %6d bulk segments%n\",\n                                bulkSize / (1024 * 1024), bulkCount);\n                    } else {\n                        for (int i = 1; i < args.length; i++) {\n                            UUID uuid = UUID.fromString(args[i]);\n                            System.out.println(store.readSegment(uuid));\n                        }\n                    }\n                } finally {\n                    store.close();\n                }\n            }\n        } else {\n            System.err.println(\"Unknown command: \" + command);\n            System.exit(1);\n        }\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public MemoryStore(NodeState root) {\r\n        super(1024 * 1024);\r\n        NodeBuilder builder = EMPTY_NODE.builder();\r\n        builder.setChildNode(\"root\", root);\r\n        journals.put(\"root\", new MemoryJournal(this, builder.getNodeState()));\r\n    }","id":78353,"modified_method":"public MemoryStore(NodeState root) {\r\n        super(0);\r\n        NodeBuilder builder = EMPTY_NODE.builder();\r\n        builder.setChildNode(\"root\", root);\r\n        journals.put(\"root\", new MemoryJournal(this, builder.getNodeState()));\r\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public MongoStore(DB db, int cacheSize) {\n        super(cacheSize);\n        this.db = checkNotNull(db);\n        this.segments = db.getCollection(\"segments\");\n        NodeBuilder builder = EMPTY_NODE.builder();\n        builder.child(\"root\");\n        journals.put(\"root\", new MongoJournal(\n                this, db.getCollection(\"journals\"),\n                concern, builder.getNodeState()));\n    }","id":78354,"modified_method":"public MongoStore(DB db, int cacheSizeMB) {\n        super(cacheSizeMB);\n        this.db = checkNotNull(db);\n        this.segments = db.getCollection(\"segments\");\n        NodeBuilder builder = EMPTY_NODE.builder();\n        builder.child(\"root\");\n        journals.put(\"root\", new MongoJournal(\n                this, db.getCollection(\"journals\"),\n                concern, builder.getNodeState()));\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static RepositoryFixture getSegment(\n            final String host, final int port, final int cacheSize) {\n        return new OakRepositoryFixture(\"Oak-Segment\") {\n            private SegmentStore[] stores;\n            private Mongo mongo;\n            @Override\n            public Repository[] setUpCluster(int n) throws Exception {\n                Repository[] cluster = new Repository[n];\n                stores = new SegmentStore[cluster.length];\n                mongo = new Mongo(host, port);\n                for (int i = 0; i < cluster.length; i++) {\n                    stores[i] = new MongoStore(mongo.getDB(unique), cacheSize);\n                    Oak oak = new Oak(new SegmentNodeStore(stores[i]));\n                    cluster[i] = new Jcr(oak).createRepository();\n                }\n                return cluster;\n            }\n            @Override\n            public void tearDownCluster() {\n                for (SegmentStore store : stores) {\n                    store.close();\n                }\n                mongo.getDB(unique).dropDatabase();\n                mongo.close();\n            }\n        };\n    }","id":78355,"modified_method":"public static RepositoryFixture getSegment(\n            final String host, final int port, final int cacheSizeMB) {\n        return new OakRepositoryFixture(\"Oak-Segment\") {\n            private SegmentStore[] stores;\n            private MongoClient mongo;\n            @Override\n            public Repository[] setUpCluster(int n) throws Exception {\n                Repository[] cluster = new Repository[n];\n                stores = new SegmentStore[cluster.length];\n                mongo = new MongoClient(host, port);\n                for (int i = 0; i < cluster.length; i++) {\n                    stores[i] = new MongoStore(mongo.getDB(unique), cacheSizeMB);\n                    Oak oak = new Oak(new SegmentNodeStore(stores[i]));\n                    cluster[i] = new Jcr(oak).createRepository();\n                }\n                return cluster;\n            }\n            @Override\n            public void tearDownCluster() {\n                for (SegmentStore store : stores) {\n                    store.close();\n                }\n                mongo.getDB(unique).dropDatabase();\n                mongo.close();\n            }\n        };\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static RepositoryFixture getTar(\n            final File base,\n            final int maxFileSize, final int cacheSize, final boolean memoryMapping) {\n        return new OakRepositoryFixture(\"Oak-Tar\") {\n            private SegmentStore[] stores;\n            @Override\n            public Repository[] setUpCluster(int n) throws Exception {\n                Repository[] cluster = new Repository[n];\n                stores = new FileStore[cluster.length];\n                for (int i = 0; i < cluster.length; i++) {\n                    stores[i] = new FileStore(\n                            new File(base, unique), maxFileSize, cacheSize, memoryMapping);\n                    Oak oak = new Oak(new SegmentNodeStore(stores[i]));\n                    cluster[i] = new Jcr(oak).createRepository();\n                }\n                return cluster;\n            }\n            @Override\n            public void tearDownCluster() {\n                for (SegmentStore store : stores) {\n                    store.close();\n                }\n                FileUtils.deleteQuietly(new File(base, unique));\n            }\n        };\n    }","id":78356,"modified_method":"public static RepositoryFixture getTar(\n            final File base, final int maxFileSizeMB, final int cacheSizeMB,\n            final boolean memoryMapping) {\n        return new OakRepositoryFixture(\"Oak-Tar\") {\n            private SegmentStore[] stores;\n            @Override\n            public Repository[] setUpCluster(int n) throws Exception {\n                Repository[] cluster = new Repository[n];\n                stores = new FileStore[cluster.length];\n                for (int i = 0; i < cluster.length; i++) {\n                    stores[i] = new FileStore(\n                            new File(base, unique),\n                            maxFileSizeMB, cacheSizeMB, memoryMapping);\n                    Oak oak = new Oak(new SegmentNodeStore(stores[i]));\n                    cluster[i] = new Jcr(oak).createRepository();\n                }\n                return cluster;\n            }\n            @Override\n            public void tearDownCluster() {\n                for (SegmentStore store : stores) {\n                    store.close();\n                }\n                FileUtils.deleteQuietly(new File(base, unique));\n            }\n        };\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Constructor as required by the JCR TCK.\n     *\n     * @param settings repository settings\n     * @throws javax.jcr.RepositoryException If an error occurs.\n     */\n    public OakSegmentMKRepositoryStub(Properties settings) throws RepositoryException {\n        super(settings);\n\n        Session session = null;\n        try {\n            this.connection = new Mongo(HOST, PORT);\n            Jcr jcr = new Jcr(new Oak(new SegmentNodeStore(\n                    new MongoStore(connection.getDB(DB), 4 * 1024 * 1024))));\n            this.repository = jcr.createRepository();\n\n            session = getRepository().login(superuser);\n            TestContentLoader loader = new TestContentLoader();\n            loader.loadTestContent(session);\n        } catch (Exception e) {\n            throw new RepositoryException(e);\n        } finally {\n            if (session != null) {\n                session.logout();\n            }\n        }\n        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                connection.close();\n            }\n        }));\n    }","id":78357,"modified_method":"/**\n     * Constructor as required by the JCR TCK.\n     *\n     * @param settings repository settings\n     * @throws javax.jcr.RepositoryException If an error occurs.\n     */\n    public OakSegmentMKRepositoryStub(Properties settings) throws RepositoryException {\n        super(settings);\n\n        Session session = null;\n        try {\n            this.connection = new MongoClient(HOST, PORT);\n            Jcr jcr = new Jcr(new Oak(new SegmentNodeStore(\n                    new MongoStore(connection.getDB(DB), 4))));\n            this.repository = jcr.createRepository();\n\n            session = getRepository().login(superuser);\n            TestContentLoader loader = new TestContentLoader();\n            loader.loadTestContent(session);\n        } catch (Exception e) {\n            throw new RepositoryException(e);\n        } finally {\n            if (session != null) {\n                session.logout();\n            }\n        }\n        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                connection.close();\n            }\n        }));\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static boolean isAvailable() {\n        try {\n            Mongo mongo = new Mongo(HOST, PORT);\n            try {\n                mongo.getDatabaseNames();\n                return true;\n            } finally {\n                mongo.close();\n            }\n        } catch (Exception e) {\n            return false;\n        }\n    }","id":78358,"modified_method":"public static boolean isAvailable() {\n        try {\n            MongoClient mongo = new MongoClient(HOST, PORT);\n            try {\n                mongo.getDatabaseNames();\n                return true;\n            } finally {\n                mongo.close();\n            }\n        } catch (Exception e) {\n            return false;\n        }\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Constructor as required by the JCR TCK.\n     *\n     * @param settings repository settings\n     * @throws javax.jcr.RepositoryException If an error occurs.\n     */\n    public OakTarMKRepositoryStub(Properties settings) throws RepositoryException {\n        super(settings);\n\n        Session session = null;\n        try {\n            File directory =\n                    new File(\"target\", \"tarmk-\" + System.currentTimeMillis());\n            this.store = new FileStore(directory, 1024 * 1024, false);\n            Jcr jcr = new Jcr(new Oak(new SegmentNodeStore(store)));\n            this.repository = jcr.createRepository();\n\n            session = getRepository().login(superuser);\n            TestContentLoader loader = new TestContentLoader();\n            loader.loadTestContent(session);\n        } catch (Exception e) {\n            throw new RepositoryException(e);\n        } finally {\n            if (session != null) {\n                session.logout();\n            }\n        }\n        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                store.close();\n            }\n        }));\n    }","id":78359,"modified_method":"/**\n     * Constructor as required by the JCR TCK.\n     *\n     * @param settings repository settings\n     * @throws javax.jcr.RepositoryException If an error occurs.\n     */\n    public OakTarMKRepositoryStub(Properties settings) throws RepositoryException {\n        super(settings);\n\n        Session session = null;\n        try {\n            File directory =\n                    new File(\"target\", \"tarmk-\" + System.currentTimeMillis());\n            this.store = new FileStore(directory, 1, false);\n            Jcr jcr = new Jcr(new Oak(new SegmentNodeStore(store)));\n            this.repository = jcr.createRepository();\n\n            session = getRepository().login(superuser);\n            TestContentLoader loader = new TestContentLoader();\n            loader.loadTestContent(session);\n        } catch (Exception e) {\n            throw new RepositoryException(e);\n        } finally {\n            if (session != null) {\n                session.logout();\n            }\n        }\n        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n            @Override\n            public void run() {\n                store.close();\n            }\n        }));\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Activate\n    public synchronized void activate(ComponentContext context)\n            throws IOException {\n        Dictionary<?, ?> properties = context.getProperties();\n        name = \"\" + properties.get(NAME);\n\n        String host = lookup(context, HOST);\n        if (host == null) {\n            String directory = lookup(context, DIRECTORY);\n            if (directory == null) {\n                directory = \"tarmk\";\n            }\n\n            String mode = lookup(context, MODE);\n            if (mode == null) {\n                mode = System.getProperty(MODE,\n                        System.getProperty(\"sun.arch.data.model\", \"32\"));\n            }\n\n            String size = lookup(context, SIZE);\n            if (size == null) {\n                size = System.getProperty(SIZE, \"268435456\"); // 256MB\n            }\n\n            mongo = null;\n            store = new FileStore(\n                    new File(directory),\n                    Integer.parseInt(size), \"64\".equals(mode));\n        } else {\n            int port = Integer.parseInt(String.valueOf(properties.get(PORT)));\n            String db = String.valueOf(properties.get(DB));\n            int cache = Integer.parseInt(String.valueOf(properties.get(CACHE)));\n\n            mongo = new Mongo(host, port);\n            store = new MongoStore(mongo.getDB(db), cache * MB);\n        }\n\n        delegate = new SegmentNodeStore(store);\n    }","id":78360,"modified_method":"@Activate\n    public synchronized void activate(ComponentContext context)\n            throws IOException {\n        Dictionary<?, ?> properties = context.getProperties();\n        name = \"\" + properties.get(NAME);\n\n        String host = lookup(context, HOST);\n        if (host == null) {\n            String directory = lookup(context, DIRECTORY);\n            if (directory == null) {\n                directory = \"tarmk\";\n            }\n\n            String mode = lookup(context, MODE);\n            if (mode == null) {\n                mode = System.getProperty(MODE,\n                        System.getProperty(\"sun.arch.data.model\", \"32\"));\n            }\n\n            String size = lookup(context, SIZE);\n            if (size == null) {\n                size = System.getProperty(SIZE, \"256\");\n            }\n\n            mongo = null;\n            store = new FileStore(\n                    new File(directory),\n                    Integer.parseInt(size), \"64\".equals(mode));\n        } else {\n            int port = Integer.parseInt(String.valueOf(properties.get(PORT)));\n            String db = String.valueOf(properties.get(DB));\n            int cache = Integer.parseInt(String.valueOf(properties.get(CACHE)));\n\n            mongo = new MongoClient(host, port);\n            store = new MongoStore(mongo.getDB(db), cache);\n        }\n\n        delegate = new SegmentNodeStore(store);\n    }","commit_id":"1079038048512196d5570e833ab4dd18229b1499","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@NotNull\n  @Override\n  public GlobalSearchScope getElementResolveScope(@NotNull PsiElement element) {\n    final GlobalSearchScope tempScope = JSInheritanceUtil.getEnforcedScope();\n    if (tempScope != null) {\n      return tempScope;\n    }\n\n    PsiElement explicitContext = JSResolveUtil.getContext(element);\n    if (explicitContext != null) element = explicitContext;\n    if (element instanceof PsiCodeFragment) {\n      final GlobalSearchScope forced = ((PsiCodeFragment)element).getForcedResolveScope();\n      if (forced != null) return forced;\n    }\n    final PsiFile containingFile = element.getContainingFile();\n    if (containingFile == null) return JSResolveUtil.getJavaScriptSymbolsResolveScope(element.getProject());\n    final PsiFile psiFile = containingFile.getOriginalFile();\n    VirtualFile file = psiFile.getVirtualFile();\n    final Project project = psiFile.getProject();\n    if (file == null) return JSResolveUtil.getJavaScriptSymbolsResolveScope(project);\n\n    final GlobalSearchScope scope = isApplicable(file) ? ResolveScopeManager.getInstance(project).getDefaultResolveScope(file) : null;\n    return scope != null ? scope : getResolveScope(file, project, false);\n  }","id":78361,"modified_method":"@NotNull\n  @Override\n  public GlobalSearchScope getElementResolveScope(@NotNull PsiElement element) {\n    final GlobalSearchScope tempScope = JSInheritanceUtil.getEnforcedScope();\n    if (tempScope != null) {\n      return tempScope;\n    }\n\n    PsiElement explicitContext = JSResolveUtil.getContext(element);\n    if (explicitContext != null) element = explicitContext;\n    if (element instanceof PsiCodeFragment) {\n      final GlobalSearchScope forced = ((PsiCodeFragment)element).getForcedResolveScope();\n      if (forced != null) return forced;\n    }\n    final PsiFile containingFile = element.getContainingFile();\n    if (containingFile == null) return JSResolveUtil.getJavaScriptSymbolsResolveScope(element.getProject());\n    final PsiFile psiFile = containingFile.getOriginalFile();\n    VirtualFile file = psiFile.getVirtualFile();\n    final Project project = psiFile.getProject();\n    if (file == null) return JSResolveUtil.getJavaScriptSymbolsResolveScope(project);\n\n    final GlobalSearchScope scope = isApplicable(file) ? ResolveScopeManager.getInstance(project).getDefaultResolveScope(file) : null;\n    if (scope != null) return scope;\n    final GlobalSearchScope fileResolveScope = getResolveScope(file, project, false);\n    return fileResolveScope != null ? fileResolveScope : JSResolveUtil.getJavaScriptSymbolsResolveScope(project);\n  }","commit_id":"931ff6815d1359f7b605b78898fb5556977d9a34","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public GlobalSearchScope getResolveScope() {\n    if (myBound != null) {\n      return myBound.getResolveScope();\n    }\n    else {\n      return GlobalSearchScope.allScope(myManager.getProject());\n    }\n  }","id":78362,"modified_method":"@NotNull\n  public GlobalSearchScope getResolveScope() {\n    if (myBound != null) {\n      GlobalSearchScope scope = myBound.getResolveScope();\n      if (scope != null) {\n        return scope;\n      }\n    }\n    return GlobalSearchScope.allScope(myManager.getProject());\n  }","commit_id":"35a41e8295d6b58baa91e0d4ddf482df6bfcb7fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiClassType getTupleType(GrExpression[] initializers, GrListOrMap listOrMap) {\n      PsiType[] result = new PsiType[initializers.length];\n      for (int i = 0; i < result.length; i++) {\n        result[i] = initializers[i].getType();\n      }\n      return new GrTupleType(result, JavaPsiFacade.getInstance(listOrMap.getProject()), listOrMap.getResolveScope());\n    }","id":78363,"modified_method":"private static PsiClassType getTupleType(GrExpression[] initializers, GrListOrMap listOrMap) {\n      JavaPsiFacade facade = JavaPsiFacade.getInstance(listOrMap.getProject());\n      GlobalSearchScope scope = listOrMap.getResolveScope();\n\n      if (initializers.length == 0) {\n        PsiType lType = PsiImplUtil.inferExpectedTypeForDiamond(listOrMap);\n\n        if (lType instanceof PsiClassType && InheritanceUtil.isInheritor(lType, CommonClassNames.JAVA_UTIL_LIST)) {\n          PsiClassType.ClassResolveResult classResolveResult = ((PsiClassType)lType).resolveGenerics();\n          PsiSubstitutor substitutor = classResolveResult.getSubstitutor();\n          \n          PsiClass list = facade.findClass(CommonClassNames.JAVA_UTIL_LIST, scope);\n          PsiClass arrayList = facade.findClass(CommonClassNames.JAVA_UTIL_ARRAY_LIST, scope);\n\n          if (list != null && arrayList != null) {\n            PsiSubstitutor arrayListSubstitutor =\n              PsiSubstitutor.EMPTY.put(arrayList.getTypeParameters()[0], substitutor.substitute(list.getTypeParameters()[0]));\n            return facade.getElementFactory().createType(arrayList, arrayListSubstitutor);\n          }\n        }\n      }\n\n      PsiType[] result = new PsiType[initializers.length];\n      for (int i = 0; i < result.length; i++) {\n        result[i] = initializers[i].getType();\n      }\n      return new GrTupleType(result, facade, scope);\n    }","commit_id":"01eed7f67bf94220995d6fe785bde5ba2939505d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    private static PsiClassType inferMapInitializerType(GrListOrMapImpl listOrMap, JavaPsiFacade facade, GlobalSearchScope scope) {\n      final HashMap<String, PsiType> stringEntries = new HashMap<String, PsiType>();\n      final ArrayList<Pair<PsiType, PsiType>> otherEntries = new ArrayList<Pair<PsiType, PsiType>>();\n      GrNamedArgument[] namedArgs = listOrMap.getNamedArguments();\n      for (GrNamedArgument namedArg : namedArgs) {\n        final GrArgumentLabel label = namedArg.getLabel();\n        final GrExpression expression = namedArg.getExpression();\n        if (label == null || expression == null) {\n          continue;\n        }\n\n        final String name = label.getName();\n        if (name != null) {\n          stringEntries.put(name, expression.getType());\n        } else {\n          otherEntries.add(Pair.create(label.getLabelType(), expression.getType()));\n        }\n      }\n\n      return new GrMapType(facade, scope, stringEntries, otherEntries);\n    }","id":78364,"modified_method":"@Nullable\n    private static PsiClassType inferMapInitializerType(GrListOrMapImpl listOrMap, JavaPsiFacade facade, GlobalSearchScope scope) {\n      final HashMap<String, PsiType> stringEntries = new HashMap<String, PsiType>();\n      final ArrayList<Pair<PsiType, PsiType>> otherEntries = new ArrayList<Pair<PsiType, PsiType>>();\n      GrNamedArgument[] namedArgs = listOrMap.getNamedArguments();\n\n      if (namedArgs.length == 0) {\n        PsiType lType = PsiImplUtil.inferExpectedTypeForDiamond(listOrMap);\n\n        if (lType instanceof PsiClassType && InheritanceUtil.isInheritor(lType, CommonClassNames.JAVA_UTIL_MAP)) {\n          PsiClassType.ClassResolveResult classResolveResult = ((PsiClassType)lType).resolveGenerics();\n          PsiSubstitutor substitutor = classResolveResult.getSubstitutor();\n          \n          PsiClass map = facade.findClass(CommonClassNames.JAVA_UTIL_MAP, scope);\n          PsiClass hashMap = facade.findClass(GroovyCommonClassNames.JAVA_UTIL_LINKED_HASH_MAP, scope);\n          if (map!=null && hashMap != null) {\n            PsiSubstitutor mapSubstitutor = PsiSubstitutor.EMPTY.\n              put(hashMap.getTypeParameters()[0], substitutor.substitute(map.getTypeParameters()[0])).\n              put(hashMap.getTypeParameters()[1], substitutor.substitute(map.getTypeParameters()[1]));\n            return facade.getElementFactory().createType(hashMap, mapSubstitutor);\n          }\n        }\n      }\n\n      for (GrNamedArgument namedArg : namedArgs) {\n        final GrArgumentLabel label = namedArg.getLabel();\n        final GrExpression expression = namedArg.getExpression();\n        if (label == null || expression == null) {\n          continue;\n        }\n\n        final String name = label.getName();\n        if (name != null) {\n          stringEntries.put(name, expression.getType());\n        } else {\n          otherEntries.add(Pair.create(label.getLabelType(), expression.getType()));\n        }\n      }\n\n      return new GrMapType(facade, scope, stringEntries, otherEntries);\n    }","commit_id":"01eed7f67bf94220995d6fe785bde5ba2939505d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiType inferExpectedTypeForDiamond(GrNewExpression diamondNew) {\n    PsiElement pparent = PsiUtil.skipParentheses(diamondNew.getParent(), true);\n    if (pparent instanceof GrAssignmentExpression &&\n        PsiTreeUtil.isAncestor(((GrAssignmentExpression)pparent).getRValue(), diamondNew, false)) {\n      GrExpression lValue = ((GrAssignmentExpression)pparent).getLValue();\n      if (PsiUtil.mightBeLValue(lValue)) {\n        return lValue.getNominalType();\n      }\n    }\n    else if (pparent instanceof GrVariable && ((GrVariable)pparent).getInitializerGroovy() == diamondNew) {\n      return ((GrVariable)pparent).getDeclaredType();\n    }\n    else if (pparent instanceof GrListOrMap) {\n      PsiElement ppparent = PsiUtil.skipParentheses(pparent.getParent(), true);\n\n      if (ppparent instanceof GrAssignmentExpression &&\n          PsiTreeUtil.isAncestor(((GrAssignmentExpression)ppparent).getRValue(), pparent, false)) {\n\n        PsiElement lValue = PsiUtil.skipParentheses(((GrAssignmentExpression)ppparent).getLValue(), false);\n        if (lValue instanceof GrTupleExpression) {\n          GrExpression[] initializers = ((GrListOrMap)pparent).getInitializers();\n          int index = ArrayUtil.find(initializers, diamondNew);\n          GrExpression[] expressions = ((GrTupleExpression)lValue).getExpressions();\n          if (index < expressions.length) {\n            return expressions[index].getNominalType();\n          }\n        }\n      }\n    }\n\n    return null;\n  }","id":78365,"modified_method":"@Nullable\n  public static PsiType inferExpectedTypeForDiamond(GrExpression diamondNew) {\n    PsiElement pparent = PsiUtil.skipParentheses(diamondNew.getParent(), true);\n    if (pparent instanceof GrAssignmentExpression &&\n        PsiTreeUtil.isAncestor(((GrAssignmentExpression)pparent).getRValue(), diamondNew, false)) {\n      GrExpression lValue = ((GrAssignmentExpression)pparent).getLValue();\n      if (PsiUtil.mightBeLValue(lValue)) {\n        return lValue.getNominalType();\n      }\n    }\n    else if (pparent instanceof GrVariable && ((GrVariable)pparent).getInitializerGroovy() == diamondNew) {\n      return ((GrVariable)pparent).getDeclaredType();\n    }\n    else if (pparent instanceof GrListOrMap) {\n      PsiElement ppparent = PsiUtil.skipParentheses(pparent.getParent(), true);\n\n      if (ppparent instanceof GrAssignmentExpression &&\n          PsiTreeUtil.isAncestor(((GrAssignmentExpression)ppparent).getRValue(), pparent, false)) {\n\n        PsiElement lValue = PsiUtil.skipParentheses(((GrAssignmentExpression)ppparent).getLValue(), false);\n        if (lValue instanceof GrTupleExpression) {\n          GrExpression[] initializers = ((GrListOrMap)pparent).getInitializers();\n          int index = ArrayUtil.find(initializers, diamondNew);\n          GrExpression[] expressions = ((GrTupleExpression)lValue).getExpressions();\n          if (index < expressions.length) {\n            return expressions[index].getNominalType();\n          }\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"01eed7f67bf94220995d6fe785bde5ba2939505d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiType getType() {\n    GrExpression invoked = getInvokedExpression();\n    if (invoked instanceof GrReferenceExpression) {\n      GrReferenceExpression refExpr = (GrReferenceExpression) invoked;\n      final GroovyResolveResult resolveResult = refExpr.advancedResolve();\n      PsiElement resolved = resolveResult.getElement();\n      PsiType returnType = null;\n      if (resolved instanceof PsiMethod && !GroovyPsiManager.getInstance(resolved.getProject()).isTypeBeingInferred(resolved)) {\n        returnType = ((PsiMethod) resolved).getReturnType();\n      } else if (resolved instanceof GrVariable) {\n        final PsiType type = ((GrVariable) resolved).getTypeGroovy();\n        if (type instanceof GrClosureType) {\n          returnType = ((GrClosureType) type).getClosureReturnType();\n        }\n      }\n      if (returnType != null) {\n        returnType = resolveResult.getSubstitutor().substitute(returnType);\n        returnType = TypesUtil.boxPrimitiveType(returnType, getManager(), getResolveScope());\n      }\n      if (refExpr.getDotTokenType() != GroovyTokenTypes.mSPREAD_DOT) {\n        return returnType;\n      } else {\n        return ResolveUtil.getListTypeForSpreadOperator(refExpr, returnType);\n      }\n    }\n\n    return null;\n  }","id":78366,"modified_method":"public PsiType getType() {\n    GrExpression invoked = getInvokedExpression();\n    if (invoked instanceof GrReferenceExpression) {\n      GrReferenceExpression refExpr = (GrReferenceExpression) invoked;\n      final GroovyResolveResult[] resolveResults = refExpr.multiResolve(false);\n      PsiManager manager = getManager();\n      GlobalSearchScope scope = getResolveScope();\n      PsiType result = null;\n      for (GroovyResolveResult resolveResult : resolveResults) {\n        PsiElement resolved = resolveResult.getElement();\n        PsiType returnType = null;\n        if (resolved instanceof PsiMethod && !GroovyPsiManager.getInstance(resolved.getProject()).isTypeBeingInferred(resolved)) {\n          returnType = ((PsiMethod) resolved).getReturnType();\n        } else if (resolved instanceof GrVariable) {\n          final PsiType type = ((GrVariable) resolved).getTypeGroovy();\n          if (type instanceof GrClosureType) {\n            returnType = ((GrClosureType) type).getClosureReturnType();\n          }\n        }\n        if (returnType == null) return null;\n        returnType = resolveResult.getSubstitutor().substitute(returnType);\n        returnType = TypesUtil.boxPrimitiveType(returnType, manager, scope);\n\n        if (result == null || returnType.isAssignableFrom(result)) result = returnType;\n        else if (!result.isAssignableFrom(returnType)) result = GenericsUtil.getLeastUpperBound(result, returnType, manager);\n      }\n\n      if (result == null) return null;\n\n      if (refExpr.getDotTokenType() != GroovyTokenTypes.mSPREAD_DOT) {\n        return result;\n      } else {\n        return ResolveUtil.getListTypeForSpreadOperator(refExpr, result);\n      }\n    }\n\n    return null;\n  }","commit_id":"a44f3af914ccc16c05797538b840bed62cd0f1e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiElement element = descriptor.getPsiElement();\n            final PsiElement parent = element.getParent();\n            final PsiTypeElement typeElement;\n            if (parent instanceof PsiVariable) {\n                final PsiVariable variable =\n                    (PsiVariable) parent;\n                typeElement = variable.getTypeElement();\n            } else if (parent instanceof PsiMethod) {\n                final PsiMethod method = (PsiMethod) parent;\n                typeElement = method.getReturnTypeElement();\n            } else {\n                return;\n            }\n            if (typeElement == null) {\n                return;\n            }\n            final PsiManager manager = element.getManager();\n            final PsiElementFactory factory = manager.getElementFactory();\n            final PsiClassType type =\n                    factory.createTypeByFQClassName(fqClassName,\n                            element.getResolveScope());\n            final PsiTypeElement newTypeElement =\n                    factory.createTypeElement(type);\n            typeElement.replace(newTypeElement);\n        }","id":78367,"modified_method":"protected void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiElement element = descriptor.getPsiElement();\n            final PsiElement parent = element.getParent();\n            final PsiTypeElement typeElement;\n            if (parent instanceof PsiVariable) {\n                final PsiVariable variable =\n                        (PsiVariable) parent;\n                typeElement = variable.getTypeElement();\n            } else if (parent instanceof PsiMethod) {\n                final PsiMethod method = (PsiMethod) parent;\n                typeElement = method.getReturnTypeElement();\n            } else {\n                return;\n            }\n            if (typeElement == null) {\n                return;\n            }\n            final PsiType oldType = typeElement.getType();\n            if (!(oldType instanceof PsiClassType)) {\n                return;\n            }\n            final PsiClassType classType = (PsiClassType)oldType;\n            final PsiType[] parameterTypes = classType.getParameters();\n            final PsiManager manager = element.getManager();\n            final GlobalSearchScope scope = element.getResolveScope();\n            final PsiClass aClass = manager.findClass(fqClassName, scope);\n            if (aClass == null) {\n                return;\n            }\n            final PsiTypeParameter[] typeParameters =\n                    aClass.getTypeParameters();\n            final PsiElementFactory factory = manager.getElementFactory();\n            final PsiClassType type;\n            if (typeParameters.length != 0 &&\n                    typeParameters.length == parameterTypes.length) {\n                final Map<PsiTypeParameter, PsiType> typeParameterMap =\n                        new HashMap();\n                for (int i = 0; i < typeParameters.length; i++) {\n                    PsiTypeParameter typeParameter = typeParameters[i];\n                    PsiType parameterType = parameterTypes[i];\n                    typeParameterMap.put(typeParameter, parameterType);\n                }\n                final PsiSubstitutor substitutor =\n                        factory.createSubstitutor(typeParameterMap);\n                type = factory.createType(aClass, substitutor);\n            } else {\n                type = factory.createTypeByFQClassName(fqClassName, scope);\n            }\n            final PsiTypeElement newTypeElement =\n                    factory.createTypeElement(type);\n            typeElement.replace(newTypeElement);\n        }","commit_id":"8403692cd184d3b01c57bcc737a424cf016091f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    protected InspectionGadgetsFix[] buildFixes(PsiElement location) {\n        final PsiElement parent = location.getParent();\n        final Collection<PsiClass> weakestClasses =\n                TypeMayBeWeakenedVisitor.calculateWeakestClassesNecessary(\n                        parent);\n        if (weakestClasses.isEmpty()) {\n            return null;\n        }\n        final List<InspectionGadgetsFix> fixes = new ArrayList();\n        for (PsiClass weakestClass : weakestClasses) {\n            final String qualifiedName = weakestClass.getQualifiedName();\n            fixes.add(new TypeMayBeWeakenedFix(qualifiedName));\n        }\n        return fixes.toArray(new InspectionGadgetsFix[fixes.size()]);\n    }","id":78368,"modified_method":"@Nullable\n    protected InspectionGadgetsFix[] buildFixes(PsiElement location) {\n        final PsiElement parent = location.getParent();\n        final Collection<PsiClass> weakestClasses =\n                calculateWeakestClassesNecessary(\n                        parent);\n        if (weakestClasses.isEmpty()) {\n            return null;\n        }\n        final List<InspectionGadgetsFix> fixes = new ArrayList();\n        for (PsiClass weakestClass : weakestClasses) {\n            final String qualifiedName = weakestClass.getQualifiedName();\n            fixes.add(new TypeMayBeWeakenedFix(qualifiedName));\n        }\n        return fixes.toArray(new InspectionGadgetsFix[fixes.size()]);\n    }","commit_id":"8403692cd184d3b01c57bcc737a424cf016091f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitVariable(PsiVariable variable) {\n            super.visitVariable(variable);\n            if (isOnTheFly() && variable instanceof PsiField) {\n                // checking variables with greater visibiltiy is too expensive\n                // for error checking in the editor\n                if (!variable.hasModifierProperty(PsiModifier.PRIVATE)) {\n                    return;\n                }\n            }\n            final Collection<PsiClass> weakestClasses =\n                    calculateWeakestClassesNecessary(variable);\n            if (weakestClasses.isEmpty()) {\n                return;\n            }\n            registerVariableError(variable, variable, weakestClasses);\n        }","id":78369,"modified_method":"public void visitVariable(PsiVariable variable) {\n            super.visitVariable(variable);\n            if (isOnTheFly() && variable instanceof PsiField) {\n                // checking variables with greater visibiltiy is too expensive\n                // for error checking in the editor\n                if (!variable.hasModifierProperty(PsiModifier.PRIVATE)) {\n                    return;\n                }\n            }\n            if (ignoreLocals) {\n                if (variable instanceof PsiLocalVariable) {\n                    return;\n                } else if (variable instanceof PsiParameter) {\n                    final PsiParameter parameter = (PsiParameter)variable;\n                    final PsiElement scope = parameter.getDeclarationScope();\n                    if (!(scope instanceof PsiMethod)) {\n                        return;\n                    }\n                    final PsiMethod method = (PsiMethod)scope;\n                    if (method.hasModifierProperty(PsiModifier.PRIVATE)) {\n                        return;\n                    }\n                }\n            }\n            final Collection<PsiClass> weakestClasses =\n                    calculateWeakestClassesNecessary(variable);\n            if (weakestClasses.isEmpty()) {\n                return;\n            }\n            registerVariableError(variable, variable, weakestClasses);\n        }","commit_id":"8403692cd184d3b01c57bcc737a424cf016091f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public NavigableMap<Cell, Cell> headMap(Cell toKey, boolean inclusive) {\n    int index = getValidIndex(toKey, inclusive, false);\n    // \"+1\" because the max index is one after the true index\n    return createSubCellFlatMap(minCellIdx, index+1, descending);\n  }","id":78370,"modified_method":"@Override\n  public NavigableMap<Cell, Cell> headMap(Cell toKey, boolean inclusive) {\n    if (descending) {\n      return createSubCellFlatMap(getValidIndex(toKey, inclusive, false), maxCellIdx, descending);\n    } else {\n      return createSubCellFlatMap(minCellIdx, getValidIndex(toKey, inclusive, false), descending);\n    }\n  }","commit_id":"b7e0e1578717709fc564832e95fac64a325da6aa","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Binary search for a given key in between given boundaries of the array.\n   * Positive returned numbers mean the index.\n   * Negative returned numbers means the key not found.\n   *\n   * The absolute value of the output is the\n   * possible insert index for the searched key\n   *\n   * In twos-complement, (-1 * insertion point)-1 is the bitwise not of the insert point.\n   *\n   *\n   * @param needle The key to look for in all of the entries\n   * @return Same return value as Arrays.binarySearch.\n   */\n  private int find(Cell needle) {\n    int begin = minCellIdx;\n    int end = maxCellIdx - 1;\n\n    while (begin <= end) {\n      int mid = (begin + end) >>> 1;\n      Cell midCell = getCell(mid);\n      int compareRes = comparator.compare(midCell, needle);\n\n      if (compareRes == 0) {\n        return mid;  // 0 means equals. We found the key\n      }\n\n      if (compareRes < 0) {\n        // midCell is less than needle so we need to look at farther up\n        begin = mid + 1;\n      } else {\n        // midCell is greater than needle so we need to look down\n        end = mid - 1;\n      }\n    }\n\n    return (-1 * begin)-1;\n  }","id":78371,"modified_method":"/**\n   * Binary search for a given key in between given boundaries of the array.\n   * Positive returned numbers mean the index.\n   * Negative returned numbers means the key not found.\n   *\n   * The absolute value of the output is the\n   * possible insert index for the searched key\n   *\n   * In twos-complement, (-1 * insertion point)-1 is the bitwise not of the insert point.\n   *\n   *\n   * @param needle The key to look for in all of the entries\n   * @return Same return value as Arrays.binarySearch.\n   */\n  private int find(Cell needle) {\n    int begin = minCellIdx;\n    int end = maxCellIdx - 1;\n\n    while (begin <= end) {\n      int mid = (begin + end) >>> 1;\n      Cell midCell = getCell(mid);\n      int compareRes = comparator.compare(midCell, needle);\n\n      if (compareRes == 0) {\n        return mid;  // 0 means equals. We found the key\n      }\n      // Key not found. Check the comparison results; reverse the meaning of\n      // the comparison in case the order is descending (using XOR)\n      if ((compareRes < 0) ^ descending) {\n        // midCell is less than needle so we need to look at farther up\n        begin = mid + 1;\n      } else {\n        // midCell is greater than needle so we need to look down\n        end = mid - 1;\n      }\n    }\n\n    return (-1 * begin)-1;\n  }","commit_id":"b7e0e1578717709fc564832e95fac64a325da6aa","url":"https://github.com/apache/hbase"},{"original_method":"private int getValidIndex(Cell key, boolean inclusive, boolean tail) {\n    int index = find(key);\n    int result = -1;\n\n    // if the key is found and to be included, for all possibilities, the answer is the found index\n    if (index >= 0 && inclusive) result = index;\n\n    // The compliment Operator (~) converts the returned insertion point to the real one\n    if (index<0) result = ~index;\n\n    if (tail && result==-1) {\n      if (index >= 0 && !inclusive)\n        result = (descending) ? index - 1 : index + 1;\n    } else if (result==-1) {\n      if (index >= 0 && !inclusive)\n        result = (descending) ? index + 1 : index - 1;\n    }\n\n    if (result < minCellIdx || result > maxCellIdx) {\n      throw new IllegalArgumentException(\"Index \" + result + \" (initial index \" + index + \") \"\n          + \" out of boundary, when looking for key \" + key + \". The minCellIdx is \" + minCellIdx\n          + \" and the maxCellIdx is \" + maxCellIdx + \". Finally, descending? \" + descending\n          + \" and was the key requested inclusively? \" + inclusive);\n    }\n    return result;\n  }","id":78372,"modified_method":"/**\n   * Get the index of the given anchor key for creating subsequent set.\n   * It doesn't matter whether the given key exists in the set or not.\n   * taking into consideration whether\n   * the key should be inclusive or exclusive.\n   */\n  private int getValidIndex(Cell key, boolean inclusive, boolean tail) {\n    final int index = find(key);\n    // get the valid (positive) insertion point from the output of the find() method\n    int insertionPoint = index < 0 ? ~index : index;\n\n    // correct the insertion point in case the given anchor key DOES EXIST in the set\n    if (index >= 0) {\n      if ( descending && !(tail ^ inclusive)) {\n        // for the descending case\n        // if anchor for head set (tail=false) AND anchor is not inclusive -> move the insertion pt\n        // if anchor for tail set (tail=true) AND the keys is inclusive -> move the insertion point\n        // because the end index of a set is the index of the cell after the maximal cell\n        insertionPoint += 1;\n      } else if ( !descending && (tail ^ inclusive)) {\n        // for the ascending case\n        // if anchor for head set (tail=false) AND anchor is inclusive -> move the insertion point\n        // because the end index of a set is the index of the cell after the maximal cell\n        // if anchor for tail set (tail=true) AND the keys is not inclusive -> move the insertion pt\n        insertionPoint += 1;\n      }\n    }\n    // insert the insertion point into the valid range,\n    // as we may enlarge it too much in the above correction\n    return Math.min(Math.max(insertionPoint, minCellIdx), maxCellIdx);\n}","commit_id":"b7e0e1578717709fc564832e95fac64a325da6aa","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public NavigableMap<Cell, Cell> tailMap(Cell fromKey, boolean inclusive) {\n    int index = (getValidIndex(fromKey, inclusive, true));\n    return createSubCellFlatMap(index, maxCellIdx, descending);\n  }","id":78373,"modified_method":"@Override\n  public NavigableMap<Cell, Cell> tailMap(Cell fromKey, boolean inclusive) {\n    if (descending) {\n      return createSubCellFlatMap(minCellIdx, getValidIndex(fromKey, inclusive, true), descending);\n    } else {\n      return createSubCellFlatMap(getValidIndex(fromKey, inclusive, true), maxCellIdx, descending);\n    }\n  }","commit_id":"b7e0e1578717709fc564832e95fac64a325da6aa","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public NavigableMap<Cell, Cell> subMap( Cell fromKey,\n                                                    boolean fromInclusive,\n                                                    Cell toKey,\n                                                    boolean toInclusive) {\n    int toIndex = getValidIndex(toKey, toInclusive, false);\n    int fromIndex = (getValidIndex(fromKey, fromInclusive, true));\n\n    if (fromIndex > toIndex) {\n      throw new IllegalArgumentException(\"Inconsistent range, when looking from \"\n          + fromKey + \" to \" + toKey);\n    }\n    return createSubCellFlatMap(fromIndex, toIndex+1, descending);\n  }","id":78374,"modified_method":"@Override\n  public NavigableMap<Cell, Cell> subMap( Cell fromKey,\n                                                    boolean fromInclusive,\n                                                    Cell toKey,\n                                                    boolean toInclusive) {\n    final int lessCellIndex = getValidIndex(fromKey, fromInclusive, true);\n    final int greaterCellIndex = getValidIndex(toKey, toInclusive, false);\n    if (descending) {\n      return createSubCellFlatMap(greaterCellIndex, lessCellIndex, descending);\n    } else {\n      return createSubCellFlatMap(lessCellIndex, greaterCellIndex, descending);\n    }\n  }","commit_id":"b7e0e1578717709fc564832e95fac64a325da6aa","url":"https://github.com/apache/hbase"},{"original_method":"private void testCellBlocks(CellSet cs) throws Exception {\n    final byte[] oneAndHalf = Bytes.toBytes(20);\n    final byte[] f = Bytes.toBytes(\"f\");\n    final byte[] q = Bytes.toBytes(\"q\");\n    final byte[] v = Bytes.toBytes(4);\n    final KeyValue outerCell = new KeyValue(oneAndHalf, f, q, 10, v);\n\n    assertEquals(NUM_OF_CELLS, cs.size());          // check size\n    assertFalse(cs.contains(outerCell));            // check outer cell\n\n    assertTrue(cs.contains(cells[0]));              // check existence of the first\n    Cell first = cs.first();\n    assertTrue(cells[0].equals(first));\n\n    assertTrue(cs.contains(cells[NUM_OF_CELLS - 1]));  // check last\n    Cell last = cs.last();\n    assertTrue(cells[NUM_OF_CELLS - 1].equals(last));\n\n    SortedSet<Cell> tail = cs.tailSet(cells[1]);    // check tail abd head sizes\n    assertEquals(NUM_OF_CELLS - 1, tail.size());\n    SortedSet<Cell> head = cs.headSet(cells[1]);\n    assertEquals(1, head.size());\n\n    SortedSet<Cell> tailOuter = cs.tailSet(outerCell);  // check tail starting from outer cell\n    assertEquals(NUM_OF_CELLS - 1, tailOuter.size());\n\n    Cell tailFirst = tail.first();\n    assertTrue(cells[1].equals(tailFirst));\n    Cell tailLast = tail.last();\n    assertTrue(cells[NUM_OF_CELLS - 1].equals(tailLast));\n\n    Cell headFirst = head.first();\n    assertTrue(cells[0].equals(headFirst));\n    Cell headLast = head.last();\n    assertTrue(cells[0].equals(headLast));\n  }","id":78375,"modified_method":"private void testCellBlocks(CellSet cs) throws Exception {\n    final byte[] oneAndHalf = Bytes.toBytes(20);\n    final byte[] f = Bytes.toBytes(\"f\");\n    final byte[] q = Bytes.toBytes(\"q\");\n    final byte[] v = Bytes.toBytes(4);\n    final KeyValue outerCell = new KeyValue(oneAndHalf, f, q, 10, v);\n\n    assertEquals(NUM_OF_CELLS, cs.size());          // check size\n    assertFalse(cs.contains(outerCell));            // check outer cell\n\n    assertTrue(cs.contains(ascCells[0]));              // check existence of the first\n    Cell first = cs.first();\n    assertTrue(ascCells[0].equals(first));\n\n    assertTrue(cs.contains(ascCells[NUM_OF_CELLS - 1]));  // check last\n    Cell last = cs.last();\n    assertTrue(ascCells[NUM_OF_CELLS - 1].equals(last));\n\n    SortedSet<Cell> tail = cs.tailSet(ascCells[1]);    // check tail abd head sizes\n    assertEquals(NUM_OF_CELLS - 1, tail.size());\n    SortedSet<Cell> head = cs.headSet(ascCells[1]);\n    assertEquals(1, head.size());\n\n    SortedSet<Cell> tailOuter = cs.tailSet(outerCell);  // check tail starting from outer cell\n    assertEquals(NUM_OF_CELLS - 1, tailOuter.size());\n\n    Cell tailFirst = tail.first();\n    assertTrue(ascCells[1].equals(tailFirst));\n    Cell tailLast = tail.last();\n    assertTrue(ascCells[NUM_OF_CELLS - 1].equals(tailLast));\n\n    Cell headFirst = head.first();\n    assertTrue(ascCells[0].equals(headFirst));\n    Cell headLast = head.last();\n    assertTrue(ascCells[0].equals(headLast));\n  }","commit_id":"b7e0e1578717709fc564832e95fac64a325da6aa","url":"https://github.com/apache/hbase"},{"original_method":"private void testIterators(CellSet cs) throws Exception {\n\n    // Assert that we have NUM_OF_CELLS values and that they are in order\n    int count = 0;\n    for (Cell kv: cs) {\n      assertEquals(\"\\n\\n-------------------------------------------------------------------\\n\"\n              + \"Comparing iteration number \" + (count + 1) + \" the returned cell: \" + kv\n              + \", the first Cell in the CellBlocksMap: \" + cells[count]\n              + \", and the same transformed to String: \" + cells[count].toString()\n              + \"\\n-------------------------------------------------------------------\\n\",\n              cells[count], kv);\n      count++;\n    }\n    assertEquals(NUM_OF_CELLS, count);\n\n    // Test descending iterator\n    count = 0;\n    for (Iterator<Cell> i = cs.descendingIterator(); i.hasNext();) {\n      Cell kv = i.next();\n      assertEquals(cells[NUM_OF_CELLS - (count + 1)], kv);\n      count++;\n    }\n    assertEquals(NUM_OF_CELLS, count);\n  }","id":78376,"modified_method":"private void testIterators(CellSet cs) throws Exception {\n\n    // Assert that we have NUM_OF_CELLS values and that they are in order\n    int count = 0;\n    for (Cell kv: cs) {\n      assertEquals(\"\\n\\n-------------------------------------------------------------------\\n\"\n              + \"Comparing iteration number \" + (count + 1) + \" the returned cell: \" + kv\n              + \", the first Cell in the CellBlocksMap: \" + ascCells[count]\n              + \", and the same transformed to String: \" + ascCells[count].toString()\n              + \"\\n-------------------------------------------------------------------\\n\",\n              ascCells[count], kv);\n      count++;\n    }\n    assertEquals(NUM_OF_CELLS, count);\n\n    // Test descending iterator\n    count = 0;\n    for (Iterator<Cell> i = cs.descendingIterator(); i.hasNext();) {\n      Cell kv = i.next();\n      assertEquals(ascCells[NUM_OF_CELLS - (count + 1)], kv);\n      count++;\n    }\n    assertEquals(NUM_OF_CELLS, count);\n  }","commit_id":"b7e0e1578717709fc564832e95fac64a325da6aa","url":"https://github.com/apache/hbase"},{"original_method":"public void testCellBlocksOnHeap() throws Exception {\n    CellSet cs = new CellSet(cbOnHeap);\n    testCellBlocks(cs);\n    testIterators(cs);\n  }","id":78377,"modified_method":"public void testCellBlocksOnHeap() throws Exception {\n    CellSet cs = new CellSet(ascCbOnHeap);\n    testCellBlocks(cs);\n    testIterators(cs);\n  }","commit_id":"b7e0e1578717709fc564832e95fac64a325da6aa","url":"https://github.com/apache/hbase"},{"original_method":"protected void setUp() throws Exception {\n    super.setUp();\n\n    // create array of Cells to bass to the CellFlatMap under CellSet\n    final byte[] one = Bytes.toBytes(15);\n    final byte[] two = Bytes.toBytes(25);\n    final byte[] three = Bytes.toBytes(35);\n    final byte[] four = Bytes.toBytes(45);\n\n    final byte[] f = Bytes.toBytes(\"f\");\n    final byte[] q = Bytes.toBytes(\"q\");\n    final byte[] v = Bytes.toBytes(4);\n\n    final KeyValue kv1 = new KeyValue(one, f, q, 10, v);\n    final KeyValue kv2 = new KeyValue(two, f, q, 20, v);\n    final KeyValue kv3 = new KeyValue(three, f, q, 30, v);\n    final KeyValue kv4 = new KeyValue(four, f, q, 40, v);\n\n    cells = new Cell[] {kv1,kv2,kv3,kv4};\n    cbOnHeap = new CellArrayMap(CellComparator.COMPARATOR,cells,0,NUM_OF_CELLS,false);\n\n    conf.setBoolean(SegmentFactory.USEMSLAB_KEY, true);\n    conf.setFloat(MemStoreChunkPool.CHUNK_POOL_MAXSIZE_KEY, 0.2f);\n    MemStoreChunkPool.chunkPoolDisabled = false;\n    mslab = new HeapMemStoreLAB(conf);\n  }","id":78378,"modified_method":"@Override\n  protected void setUp() throws Exception {\n    super.setUp();\n\n    // create array of Cells to bass to the CellFlatMap under CellSet\n    final byte[] one = Bytes.toBytes(15);\n    final byte[] two = Bytes.toBytes(25);\n    final byte[] three = Bytes.toBytes(35);\n    final byte[] four = Bytes.toBytes(45);\n\n    final byte[] f = Bytes.toBytes(\"f\");\n    final byte[] q = Bytes.toBytes(\"q\");\n    final byte[] v = Bytes.toBytes(4);\n\n    final KeyValue kv1 = new KeyValue(one, f, q, 10, v);\n    final KeyValue kv2 = new KeyValue(two, f, q, 20, v);\n    final KeyValue kv3 = new KeyValue(three, f, q, 30, v);\n    final KeyValue kv4 = new KeyValue(four, f, q, 40, v);\n    lowerOuterCell = new KeyValue(Bytes.toBytes(10), f, q, 10, v);\n    upperOuterCell = new KeyValue(Bytes.toBytes(50), f, q, 10, v);\n    ascCells = new Cell[] {kv1,kv2,kv3,kv4};\n    ascCbOnHeap = new CellArrayMap(CellComparator.COMPARATOR,ascCells,0,NUM_OF_CELLS,false);\n    descCells = new Cell[] {kv4,kv3,kv2,kv1};\n    descCbOnHeap = new CellArrayMap(CellComparator.COMPARATOR,descCells,0,NUM_OF_CELLS,true);\n    CONF.setBoolean(SegmentFactory.USEMSLAB_KEY, true);\n    CONF.setFloat(MemStoreChunkPool.CHUNK_POOL_MAXSIZE_KEY, 0.2f);\n    MemStoreChunkPool.chunkPoolDisabled = false;\n    mslab = new HeapMemStoreLAB(CONF);\n  }","commit_id":"b7e0e1578717709fc564832e95fac64a325da6aa","url":"https://github.com/apache/hbase"},{"original_method":"private static PropertyRecord createSinglePropertyValue( PropertyStore store, int recordId, int keyId,\n            Object value )\n    {\n        DynamicRecordAllocator stringAllocator = store.getStringStore();\n        DynamicRecordAllocator arrayAllocator = store.getArrayStore();\n\n        PropertyBlock block = new PropertyBlock();\n        PropertyStore.encodeValue( block, keyId, value, stringAllocator, arrayAllocator );\n\n        PropertyRecord record = new PropertyRecord( recordId );\n        record.addPropertyBlock( block );\n        record.setInUse( true );\n        updateRecord( store, record );\n\n        return record;\n    }","id":78379,"modified_method":"private static PropertyRecord createSinglePropertyValue( PropertyStore store, int keyId,\n            Object value )\n    {\n        DynamicRecordAllocator stringAllocator = store.getStringStore();\n        DynamicRecordAllocator arrayAllocator = store.getArrayStore();\n\n        PropertyBlock block = new PropertyBlock();\n        PropertyStore.encodeValue( block, keyId, value, stringAllocator, arrayAllocator );\n\n        PropertyRecord record = new PropertyRecord( store.nextId() );\n        record.addPropertyBlock( block );\n        record.setInUse( true );\n        updateRecord( store, record );\n\n        return record;\n    }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@After\n        public void tearDown()\n        {\n            neoStores.close();\n        }","id":78380,"modified_method":"@AfterClass\n        public static void tearDown() throws IOException\n        {\n            neoStores.close();\n            pageCache.close();\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void shouldReuseCorrectlyCursor() throws Throwable\n        {\n            // given\n            int recordId = 42;\n            int keyId = 11;\n            Object expectedValue = actualValue( this.expectedValue );\n\n            createSinglePropertyValue( propertyStore, recordId, keyId, expectedValue );\n\n            StorePropertyCursor storePropertyCursor = newStorePropertyCursor( propertyStore );\n\n            try ( Cursor<PropertyItem> cursor = storePropertyCursor.init( recordId, NO_LOCK ) )\n            {\n                assertTrue( cursor.next() );\n                PropertyItem item = cursor.get();\n                assertEquals( keyId, item.propertyKeyId() );\n                assertEqualValues( expectedValue, item );\n                assertFalse( cursor.next() );\n            }\n\n            // when using it\n            try ( Cursor<PropertyItem> cursor = storePropertyCursor.init( recordId, NO_LOCK ) )\n            {\n                // then\n                assertTrue( cursor.next() );\n                PropertyItem item = cursor.get();\n                assertEquals( keyId, item.propertyKeyId() );\n                assertEqualValues( expectedValue, item );\n                assertFalse( cursor.next() );\n            }\n        }","id":78381,"modified_method":"@Test\n        public void shouldReuseCorrectlyCursor() throws Throwable\n        {\n            // given\n            int keyId = 11;\n            Object expectedValue = actualValue( this.expectedValue );\n\n            long recordId = createSinglePropertyValue( propertyStore, keyId, expectedValue ).getId();\n\n            StorePropertyCursor storePropertyCursor = newStorePropertyCursor( propertyStore );\n\n            try ( Cursor<PropertyItem> cursor = storePropertyCursor.init( recordId, NO_LOCK ) )\n            {\n                assertTrue( cursor.next() );\n                PropertyItem item = cursor.get();\n                assertEquals( keyId, item.propertyKeyId() );\n                assertEqualValues( expectedValue, item );\n                assertFalse( cursor.next() );\n            }\n\n            // when using it\n            try ( Cursor<PropertyItem> cursor = storePropertyCursor.init( recordId, NO_LOCK ) )\n            {\n                // then\n                assertTrue( cursor.next() );\n                PropertyItem item = cursor.get();\n                assertEquals( keyId, item.propertyKeyId() );\n                assertEqualValues( expectedValue, item );\n                assertFalse( cursor.next() );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void skipAllRecordsWhenWholeChainNotInUse()\n        {\n            int firstPropertyId = 1;\n            int propertyKeyId = 42;\n            Object[] propertyValues = {\"1\", \"2\", 3, 4, 5L, 6L, '7', '8', \"9 and 10\"};\n\n            createPropertyChain( propertyStore, firstPropertyId, propertyKeyId, propertyValues );\n            int[] recordIds = generateRecordIds( firstPropertyId, 1, propertyValues.length );\n            markPropertyRecordsNoInUse( propertyStore, recordIds );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( firstPropertyId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                assertEquals( Collections.emptyList(), valuesFromCursor );\n            }\n        }","id":78382,"modified_method":"@Test\n        public void skipAllRecordsWhenWholeChainNotInUse()\n        {\n            int propertyKeyId = 42;\n            Object[] propertyValues = {\"1\", \"2\", 3, 4, 5L, 6L, '7', '8', \"9 and 10\"};\n\n            List<PropertyRecord> propertyChain = createPropertyChain( propertyStore, propertyKeyId, propertyValues );\n            long firstPropertyId = firstIdOf( propertyChain );\n            int[] recordIds = idsOf( propertyChain, 0, 1, propertyValues.length );\n            markPropertyRecordsNoInUse( propertyStore, recordIds );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( firstPropertyId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                assertEquals( Collections.emptyList(), valuesFromCursor );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void readPropertyValueWhenAllLongStringDynamicRecordsAreNotInUse()\n        {\n            int recordId = 1;\n            int keyId = 1;\n            String value = randomAscii( 255 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, recordId, keyId, value );\n\n            markDynamicRecordNotInUse( 0, keyId, record, propertyStore );\n            markDynamicRecordNotInUse( 1, keyId, record, propertyStore );\n            markDynamicRecordNotInUse( 2, keyId, record, propertyStore );\n\n            verifyPropertyValue( value, recordId );\n        }","id":78383,"modified_method":"@Test\n        public void readPropertyValueWhenAllLongStringDynamicRecordsAreNotInUse()\n        {\n            int keyId = 1;\n            String value = randomAscii( 255 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, keyId, value );\n\n            markDynamicRecordsNotInUse( keyId, record, propertyStore, 0, 1, 2 );\n\n            verifyPropertyValue( value, record.getId() );\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void readPropertyChainWithLongStringDynamicRecordsNotInUse()\n        {\n            int chainStartId = 1;\n            int keyId = 42;\n            Object[] values = {randomAscii( 255 ), randomAscii( 255 ), randomAscii( 255 )};\n            List<PropertyRecord> propertyChain = createPropertyChain( propertyStore, chainStartId, keyId, values );\n\n            markDynamicRecordNotInUse( 2, keyId, propertyChain.get( 1 ), propertyStore );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( chainStartId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                assertEquals( asList( values ), valuesFromCursor );\n            }\n        }","id":78384,"modified_method":"@Test\n        public void readPropertyChainWithLongStringDynamicRecordsNotInUse()\n        {\n            int keyId = 42;\n            Object[] values = {randomAscii( 255 ), randomAscii( 255 ), randomAscii( 255 )};\n            List<PropertyRecord> propertyChain = createPropertyChain( propertyStore, keyId, values );\n            long chainStartId = firstIdOf( propertyChain );\n\n            markDynamicRecordsNotInUse( keyId, propertyChain.get( 1 ), propertyStore, 2 );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( chainStartId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                assertEquals( asList( values ), valuesFromCursor );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void skipUnusedConsecutiveRecordsInChain()\n        {\n            int firstPropertyId = 1;\n            int propertyKeyId = 42;\n            Object[] propertyValues = {\"1\", \"2\", 3, 4, 5L, 6L, '7', '8', \"9 and 10\"};\n\n            createPropertyChain( propertyStore, firstPropertyId, propertyKeyId, propertyValues );\n            markPropertyRecordsNoInUse( propertyStore, generateRecordIds( firstPropertyId + 2, 1, 3 ) );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( firstPropertyId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                assertEquals( asList( \"1\", \"2\", 6L, '7', '8', \"9 and 10\" ), valuesFromCursor );\n            }\n        }","id":78385,"modified_method":"@Test\n        public void skipUnusedConsecutiveRecordsInChain()\n        {\n            int propertyKeyId = 42;\n            Object[] propertyValues = {\"1\", \"2\", 3, 4, 5L, 6L, '7', '8', \"9 and 10\"};\n\n            List<PropertyRecord> propertyChain = createPropertyChain( propertyStore, propertyKeyId, propertyValues );\n            long firstPropertyId = firstIdOf( propertyChain );\n            markPropertyRecordsNoInUse( propertyStore, idsOf( propertyChain, 2, 1, 3 ) );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( firstPropertyId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                assertEquals( asList( \"1\", \"2\", 6L, '7', '8', \"9 and 10\" ), valuesFromCursor );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void readPropertyValueWhenAllLongArrayDynamicRecordsAreNotInUse()\n        {\n            int recordId = 1;\n            int keyId = 1;\n            byte[] value = nextBytes( 320 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, recordId, keyId, value );\n\n            markDynamicRecordNotInUse( 0, keyId, record, propertyStore );\n            markDynamicRecordNotInUse( 1, keyId, record, propertyStore );\n            markDynamicRecordNotInUse( 2, keyId, record, propertyStore );\n\n            verifyPropertyValue( value, recordId );\n        }","id":78386,"modified_method":"@Test\n        public void readPropertyValueWhenAllLongArrayDynamicRecordsAreNotInUse()\n        {\n            int keyId = 1;\n            byte[] value = nextBytes( 320 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, keyId, value );\n\n            markDynamicRecordsNotInUse( keyId, record, propertyStore, 0, 1, 2 );\n\n            verifyPropertyValue( value, record.getId() );\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void readPropertyChainWithMultipleEntries()\n        {\n            int firstPropertyId = 1;\n            int propertyKeyId = 42;\n            Object[] propertyValues = {\"1\", \"2\", 3, 4, 5L, 6L, '7', '8', \"9 and 10\"};\n\n            createPropertyChain( propertyStore, firstPropertyId, propertyKeyId, propertyValues );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( firstPropertyId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                assertEquals( asList( propertyValues ), valuesFromCursor );\n            }\n        }","id":78387,"modified_method":"@Test\n        public void readPropertyChainWithMultipleEntries()\n        {\n            int propertyKeyId = 42;\n            Object[] propertyValues = {\"1\", \"2\", 3, 4, 5L, 6L, '7', '8', \"9 and 10\"};\n\n            long firstPropertyId = firstIdOf( createPropertyChain( propertyStore, propertyKeyId, propertyValues ) );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( firstPropertyId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                assertEquals( asList( propertyValues ), valuesFromCursor );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void readPropertyChainWithLongArrayDynamicRecordsNotInUse()\n        {\n            int chainStartId = 1;\n            int keyId = 42;\n            Object[] values = {nextBytes( 1024 ), nextBytes( 1024 ), nextBytes( 1024 )};\n            List<PropertyRecord> propertyChain = createPropertyChain( propertyStore, chainStartId, keyId, values );\n\n            markDynamicRecordNotInUse( 2, keyId, propertyChain.get( 1 ), propertyStore );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( chainStartId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                for ( int i = 0; i < valuesFromCursor.size(); i++ )\n                {\n                    Object value = valuesFromCursor.get( i );\n                    assertArrayEquals( (byte[]) values[i], (byte[]) value );\n                }\n            }\n        }","id":78388,"modified_method":"@Test\n        public void readPropertyChainWithLongArrayDynamicRecordsNotInUse()\n        {\n            int keyId = 42;\n            Object[] values = {nextBytes( 1024 ), nextBytes( 1024 ), nextBytes( 1024 )};\n            List<PropertyRecord> propertyChain = createPropertyChain( propertyStore, keyId, values );\n            long chainStartId = firstIdOf( propertyChain );\n\n            markDynamicRecordsNotInUse( keyId, propertyChain.get( 1 ), propertyStore, 2 );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( chainStartId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                for ( int i = 0; i < valuesFromCursor.size(); i++ )\n                {\n                    Object value = valuesFromCursor.get( i );\n                    assertArrayEquals( (byte[]) values[i], (byte[]) value );\n                }\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void shouldReturnTwoProperties() throws Throwable\n        {\n            // given\n            int recordId = 42;\n            int keyId1 = 11;\n            int keyId2 = 22;\n            Object expectedValue1 = actualValue( this.expectedValue1 );\n            Object expectedValue2 = actualValue( this.expectedValue2 );\n\n            createTwoPropertyValues( propertyStore, recordId, keyId1, expectedValue1, keyId2, expectedValue2 );\n\n            StorePropertyCursor storePropertyCursor = newStorePropertyCursor( propertyStore );\n\n            // when\n            try ( Cursor<PropertyItem> cursor = storePropertyCursor.init( recordId, NO_LOCK ) )\n            {\n                PropertyItem item;\n\n                // then\n                assertTrue( cursor.next() );\n                item = cursor.get();\n                assertEquals( keyId1, item.propertyKeyId() );\n                assertEqualValues( expectedValue1, item );\n\n                assertTrue( cursor.next() );\n                item = cursor.get();\n                assertEquals( keyId2, item.propertyKeyId() );\n                assertEqualValues( expectedValue2, item );\n\n                assertFalse( cursor.next() );\n            }\n        }","id":78389,"modified_method":"@Test\n        public void shouldReturnTwoProperties() throws Throwable\n        {\n            // given\n            int keyId1 = 11;\n            int keyId2 = 22;\n            Object expectedValue1 = actualValue( this.expectedValue1 );\n            Object expectedValue2 = actualValue( this.expectedValue2 );\n\n            long recordId = createTwoPropertyValues(\n                    propertyStore, keyId1, expectedValue1, keyId2, expectedValue2 ).getId();\n\n            StorePropertyCursor storePropertyCursor = newStorePropertyCursor( propertyStore );\n\n            // when\n            try ( Cursor<PropertyItem> cursor = storePropertyCursor.init( recordId, NO_LOCK ) )\n            {\n                PropertyItem item;\n\n                // then\n                assertTrue( cursor.next() );\n                item = cursor.get();\n                assertEquals( keyId1, item.propertyKeyId() );\n                assertEqualValues( expectedValue1, item );\n\n                assertTrue( cursor.next() );\n                item = cursor.get();\n                assertEquals( keyId2, item.propertyKeyId() );\n                assertEqualValues( expectedValue2, item );\n\n                assertFalse( cursor.next() );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void verifyPropertyValue( String expectedValue, int recordId )\n        {\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( recordId, NO_LOCK );\n                assertTrue( cursor.next() );\n                assertEquals( expectedValue, cursor.value() );\n                assertFalse( cursor.next() );\n            }\n        }","id":78390,"modified_method":"private void verifyPropertyValue( String expectedValue, long recordId )\n        {\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( recordId, NO_LOCK );\n                assertTrue( cursor.next() );\n                assertEquals( expectedValue, cursor.value() );\n                assertFalse( cursor.next() );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void shouldReturnAProperty() throws Throwable\n        {\n            // given\n            int recordId = 42;\n            int keyId = 11;\n            Object expectedValue = actualValue( this.expectedValue );\n\n            createSinglePropertyValue( propertyStore, recordId, keyId, expectedValue );\n\n            StorePropertyCursor storePropertyCursor = newStorePropertyCursor( propertyStore );\n\n            // when\n            try ( Cursor<PropertyItem> cursor = storePropertyCursor.init( recordId, NO_LOCK ) )\n            {\n                // then\n                assertTrue( cursor.next() );\n                PropertyItem item = cursor.get();\n                assertEquals( keyId, item.propertyKeyId() );\n                assertEqualValues( expectedValue, item );\n                assertFalse( cursor.next() );\n            }\n        }","id":78391,"modified_method":"@Test\n        public void shouldReturnAProperty() throws Throwable\n        {\n            // given\n            int keyId = 11;\n            Object expectedValue = actualValue( this.expectedValue );\n\n            long recordId = createSinglePropertyValue( propertyStore, keyId, expectedValue ).getId();\n\n            StorePropertyCursor storePropertyCursor = newStorePropertyCursor( propertyStore );\n\n            // when\n            try ( Cursor<PropertyItem> cursor = storePropertyCursor.init( recordId, NO_LOCK ) )\n            {\n                // then\n                assertTrue( cursor.next() );\n                PropertyItem item = cursor.get();\n                assertEquals( keyId, item.propertyKeyId() );\n                assertEqualValues( expectedValue, item );\n                assertFalse( cursor.next() );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static List<PropertyRecord> createPropertyChain( PropertyStore store, int firstRecordId, int keyId,\n            Object... values )\n    {\n        List<PropertyRecord> records = new ArrayList<>();\n\n        int nextRecordId = firstRecordId;\n        for ( Object value : values )\n        {\n            PropertyRecord record = createSinglePropertyValue( store, nextRecordId, keyId, value );\n            if ( !records.isEmpty() )\n            {\n                PropertyRecord previousRecord = records.get( records.size() - 1 );\n\n                record.setPrevProp( previousRecord.getId() );\n                store.updateRecord( record );\n\n                previousRecord.setNextProp( record.getId() );\n                store.updateRecord( previousRecord );\n            }\n            records.add( record );\n            nextRecordId++;\n        }\n\n        return records;\n    }","id":78392,"modified_method":"private static List<PropertyRecord> createPropertyChain( PropertyStore store, int keyId,\n            Object... values )\n    {\n        List<PropertyRecord> records = new ArrayList<>();\n\n        for ( Object value : values )\n        {\n            PropertyRecord record = createSinglePropertyValue( store, keyId, value );\n            if ( !records.isEmpty() )\n            {\n                PropertyRecord previousRecord = records.get( records.size() - 1 );\n\n                record.setPrevProp( previousRecord.getId() );\n                store.updateRecord( record );\n\n                previousRecord.setNextProp( record.getId() );\n                store.updateRecord( previousRecord );\n            }\n            records.add( record );\n        }\n\n        return records;\n    }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void createTwoPropertyValues( PropertyStore store, int recordId,\n            int keyId1, Object value1, int keyId2, Object value2 ) throws IOException\n    {\n        DynamicRecordAllocator stringAllocator = store.getStringStore();\n        DynamicRecordAllocator arrayAllocator = store.getArrayStore();\n\n        PropertyBlock block1 = new PropertyBlock();\n        PropertyStore.encodeValue( block1, keyId1, value1, stringAllocator, arrayAllocator );\n        PropertyBlock block2 = new PropertyBlock();\n        PropertyStore.encodeValue( block2, keyId2, value2, stringAllocator, arrayAllocator );\n\n        PropertyRecord record = new PropertyRecord( recordId );\n        record.addPropertyBlock( block1 );\n        if ( block1.getSize() + block2.getSize() <= PropertyRecordFormat.DEFAULT_PAYLOAD_SIZE )\n        {\n            record.addPropertyBlock( block2 );\n        }\n        else\n        {\n            PropertyRecord nextRecord = new PropertyRecord( recordId + 1 );\n            record.setNextProp( nextRecord.getId() );\n            nextRecord.addPropertyBlock( block2 );\n            nextRecord.setPrevProp( record.getId() );\n            nextRecord.setInUse( true );\n            updateRecord( store, nextRecord );\n        }\n\n        record.setInUse( true );\n        updateRecord( store, record );\n    }","id":78393,"modified_method":"private static PropertyRecord createTwoPropertyValues( PropertyStore store,\n            int keyId1, Object value1, int keyId2, Object value2 )\n    {\n        DynamicRecordAllocator stringAllocator = store.getStringStore();\n        DynamicRecordAllocator arrayAllocator = store.getArrayStore();\n\n        PropertyBlock block1 = new PropertyBlock();\n        PropertyStore.encodeValue( block1, keyId1, value1, stringAllocator, arrayAllocator );\n        PropertyBlock block2 = new PropertyBlock();\n        PropertyStore.encodeValue( block2, keyId2, value2, stringAllocator, arrayAllocator );\n\n        PropertyRecord record = new PropertyRecord( store.nextId() );\n        record.addPropertyBlock( block1 );\n        if ( block1.getSize() + block2.getSize() <= PropertyRecordFormat.DEFAULT_PAYLOAD_SIZE )\n        {\n            record.addPropertyBlock( block2 );\n        }\n        else\n        {\n            PropertyRecord nextRecord = new PropertyRecord( store.nextId() );\n            record.setNextProp( nextRecord.getId() );\n            nextRecord.addPropertyBlock( block2 );\n            nextRecord.setPrevProp( record.getId() );\n            nextRecord.setInUse( true );\n            updateRecord( store, nextRecord );\n        }\n\n        record.setInUse( true );\n        updateRecord( store, record );\n        return record;\n    }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void readPropertyValueWhenSomeLongArrayDynamicRecordsAreNotInUse()\n        {\n            int recordId = 1;\n            int keyId = 1;\n            byte[] value = nextBytes( 1024 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, recordId, keyId, value );\n\n            markDynamicRecordNotInUse( 1, keyId, record, propertyStore );\n            markDynamicRecordNotInUse( 3, keyId, record, propertyStore );\n            markDynamicRecordNotInUse( 5, keyId, record, propertyStore );\n            markDynamicRecordNotInUse( 7, keyId, record, propertyStore );\n\n            verifyPropertyValue( value, recordId );\n        }","id":78394,"modified_method":"@Test\n        public void readPropertyValueWhenSomeLongArrayDynamicRecordsAreNotInUse()\n        {\n            int keyId = 1;\n            byte[] value = nextBytes( 1024 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, keyId, value );\n\n            markDynamicRecordsNotInUse( keyId, record, propertyStore, 1, 3, 5, 7 );\n\n            verifyPropertyValue( value, record.getId() );\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void markDynamicRecordNotInUse( int dynamicRecordIndex, int keyId, PropertyRecord record,\n            PropertyStore store )\n    {\n        PropertyBlock propertyBlock = record.getPropertyBlock( keyId );\n        store.ensureHeavy( propertyBlock );\n        List<DynamicRecord> valueRecords = propertyBlock.getValueRecords();\n        DynamicRecord dynamicRecord = valueRecords.get( dynamicRecordIndex );\n        dynamicRecord.setInUse( false );\n        updateRecord( store, record );\n    }","id":78395,"modified_method":"private static void markDynamicRecordsNotInUse( int keyId, PropertyRecord record,\n            PropertyStore store, int... dynamicRecordIndexes )\n    {\n        PropertyBlock propertyBlock = record.getPropertyBlock( keyId );\n        store.ensureHeavy( propertyBlock );\n        List<DynamicRecord> valueRecords = propertyBlock.getValueRecords();\n        for ( int index : dynamicRecordIndexes )\n        {\n            DynamicRecord dynamicRecord = valueRecords.get( index );\n            dynamicRecord.setInUse( false );\n        }\n        updateRecord( store, record );\n    }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n        public void setup() throws IOException\n        {\n            EphemeralFileSystemAbstraction fs = fsRule.get();\n            LogProvider log = NullLogProvider.getInstance();\n\n            File storeDir = new File( \"store\" );\n            if ( fs.isDirectory( storeDir ) )\n            {\n                fs.deleteRecursively( storeDir );\n            }\n            fs.mkdirs( storeDir );\n            StoreFactory storeFactory = new StoreFactory( storeDir, pageCache, fs, log );\n            neoStores = storeFactory.openAllNeoStores( true );\n            propertyStore = neoStores.getPropertyStore();\n        }","id":78396,"modified_method":"@BeforeClass\n        public static void setUp() throws IOException\n        {\n            pageCache = pageCacheRule.getPageCache( fsRule.get() );\n            EphemeralFileSystemAbstraction fs = fsRule.get();\n            File storeDir = new File( \"store\" ).getAbsoluteFile();\n            if ( fs.isDirectory( storeDir ) )\n            {\n                fs.deleteRecursively( storeDir );\n            }\n            fs.mkdirs( storeDir );\n            neoStores = new StoreFactory( storeDir, pageCache, fs, NullLogProvider.getInstance() )\n                    .openAllNeoStores( true );\n            propertyStore = neoStores.getPropertyStore();\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void readPropertyValueWhenSomeLongStringDynamicRecordsAreNotInUse()\n        {\n            int recordId = 1;\n            int keyId = 1;\n            String value = randomAscii( 1000 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, recordId, keyId, value );\n\n            markDynamicRecordNotInUse( 1, keyId, record, propertyStore );\n            markDynamicRecordNotInUse( 3, keyId, record, propertyStore );\n            markDynamicRecordNotInUse( 5, keyId, record, propertyStore );\n            markDynamicRecordNotInUse( 7, keyId, record, propertyStore );\n\n            verifyPropertyValue( value, recordId );\n        }","id":78397,"modified_method":"@Test\n        public void readPropertyValueWhenSomeLongStringDynamicRecordsAreNotInUse()\n        {\n            int keyId = 1;\n            String value = randomAscii( 1000 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, keyId, value );\n\n            markDynamicRecordsNotInUse( keyId, record, propertyStore, 1, 3, 5, 7 );\n\n            verifyPropertyValue( value, record.getId() );\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void readPropertyValueWhenFirstLongStringDynamicRecordIsNotInUse()\n        {\n            int recordId = 1;\n            int keyId = 1;\n            String value = randomAscii( 255 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, recordId, keyId, value );\n            markDynamicRecordNotInUse( 0, keyId, record, propertyStore );\n\n            verifyPropertyValue( value, recordId );\n        }","id":78398,"modified_method":"@Test\n        public void readPropertyValueWhenFirstLongStringDynamicRecordIsNotInUse()\n        {\n            int keyId = 1;\n            String value = randomAscii( 255 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, keyId, value );\n            markDynamicRecordsNotInUse( keyId, record, propertyStore, 0 );\n\n            verifyPropertyValue( value, record.getId() );\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void callNextAfterReadingPropertyChain()\n        {\n            int firstPropertyId = 1;\n            int propertyKeyId = 42;\n\n            createPropertyChain( propertyStore, firstPropertyId, propertyKeyId, \"1\", \"2\" );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( firstPropertyId, NO_LOCK );\n\n                assertTrue( cursor.next() );\n                assertEquals( \"1\", cursor.value() );\n\n                assertTrue( cursor.next() );\n                assertEquals( \"2\", cursor.value() );\n\n                assertFalse( cursor.next() );\n                assertFalse( cursor.next() );\n                assertFalse( cursor.next() );\n            }\n        }","id":78399,"modified_method":"@Test\n        public void callNextAfterReadingPropertyChain()\n        {\n            int propertyKeyId = 42;\n\n            long firstPropertyId = firstIdOf( createPropertyChain( propertyStore, propertyKeyId, \"1\", \"2\" ) );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( firstPropertyId, NO_LOCK );\n\n                assertTrue( cursor.next() );\n                assertEquals( \"1\", cursor.value() );\n\n                assertTrue( cursor.next() );\n                assertEquals( \"2\", cursor.value() );\n\n                assertFalse( cursor.next() );\n                assertFalse( cursor.next() );\n                assertFalse( cursor.next() );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void readPropertyValueWhenFirstLongArrayDynamicRecordIsNotInUse()\n        {\n            int recordId = 1;\n            int keyId = 1;\n            byte[] value = nextBytes( 1024 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, recordId, keyId, value );\n            markDynamicRecordNotInUse( 0, keyId, record, propertyStore );\n\n            verifyPropertyValue( value, recordId );\n        }","id":78400,"modified_method":"@Test\n        public void readPropertyValueWhenFirstLongArrayDynamicRecordIsNotInUse()\n        {\n            int keyId = 1;\n            byte[] value = nextBytes( 1024 );\n            PropertyRecord record = createSinglePropertyValue( propertyStore, keyId, value );\n            markDynamicRecordsNotInUse( keyId, record, propertyStore, 0 );\n\n            verifyPropertyValue( value, record.getId() );\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void skipUnusedRecordsInChain()\n        {\n            int firstPropertyId = 1;\n            int propertyKeyId = 42;\n            Object[] propertyValues = {\"1\", \"2\", 3, 4, 5L, 6L, '7', '8', \"9 and 10\"};\n\n            createPropertyChain( propertyStore, firstPropertyId, propertyKeyId, propertyValues );\n            markPropertyRecordsNoInUse( propertyStore, generateRecordIds( firstPropertyId + 1, 2, 4 ) );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( firstPropertyId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                assertEquals( asList( \"1\", 3, 5L, '7', \"9 and 10\" ), valuesFromCursor );\n            }\n        }","id":78401,"modified_method":"@Test\n        public void skipUnusedRecordsInChain()\n        {\n            int propertyKeyId = 42;\n            Object[] propertyValues = {\"1\", \"2\", 3, 4, 5L, 6L, '7', '8', \"9 and 10\"};\n\n            List<PropertyRecord> propertyChain = createPropertyChain( propertyStore, propertyKeyId, propertyValues );\n            long firstPropertyId = firstIdOf( propertyChain );\n            markPropertyRecordsNoInUse( propertyStore, idsOf( propertyChain, 1, 2, 4 ) );\n\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( firstPropertyId, NO_LOCK );\n\n                List<Object> valuesFromCursor = asPropertyValuesList( cursor );\n                assertEquals( asList( \"1\", 3, 5L, '7', \"9 and 10\" ), valuesFromCursor );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void verifyPropertyValue( byte[] expectedValue, int recordId )\n        {\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( recordId, NO_LOCK );\n                assertTrue( cursor.next() );\n                assertArrayEquals( expectedValue, (byte[]) cursor.value() );\n                assertFalse( cursor.next() );\n            }\n        }","id":78402,"modified_method":"private void verifyPropertyValue( byte[] expectedValue, long recordId )\n        {\n            try ( StorePropertyCursor cursor = newStorePropertyCursor( propertyStore ) )\n            {\n                cursor.init( recordId, NO_LOCK );\n                assertTrue( cursor.next() );\n                assertArrayEquals( expectedValue, (byte[]) cursor.value() );\n                assertFalse( cursor.next() );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void shouldReturnAPropertyBySkippingOne() throws Throwable\n        {\n            // given\n            int recordId = 42;\n            int keyId1 = 11;\n            int keyId2 = 22;\n            Object expectedValue1 = actualValue( this.expectedValue1 );\n            Object expectedValue2 = actualValue( this.expectedValue2 );\n\n            createTwoPropertyValues( propertyStore, recordId, keyId1, expectedValue1, keyId2, expectedValue2 );\n\n            StorePropertyCursor storePropertyCursor = newStorePropertyCursor( propertyStore );\n\n            // when\n            try ( Cursor<PropertyItem> cursor = storePropertyCursor.init( recordId, NO_LOCK ) )\n            {\n                // then\n                assertTrue( cursor.next() );\n                PropertyItem item = cursor.get();\n                assertEquals( keyId1, item.propertyKeyId() );\n\n                // skipping first property\n\n                assertTrue( cursor.next() );\n                assertEquals( keyId2, item.propertyKeyId() );\n                assertEqualValues( expectedValue2, item );\n\n                assertFalse( cursor.next() );\n            }\n        }","id":78403,"modified_method":"@Test\n        public void shouldReturnAPropertyBySkippingOne() throws Throwable\n        {\n            // given\n            int keyId1 = 11;\n            int keyId2 = 22;\n            Object expectedValue1 = actualValue( this.expectedValue1 );\n            Object expectedValue2 = actualValue( this.expectedValue2 );\n\n            long recordId = createTwoPropertyValues(\n                    propertyStore, keyId1, expectedValue1, keyId2, expectedValue2 ).getId();\n\n            StorePropertyCursor storePropertyCursor = newStorePropertyCursor( propertyStore );\n\n            // when\n            try ( Cursor<PropertyItem> cursor = storePropertyCursor.init( recordId, NO_LOCK ) )\n            {\n                // then\n                assertTrue( cursor.next() );\n                PropertyItem item = cursor.get();\n                assertEquals( keyId1, item.propertyKeyId() );\n\n                // skipping first property\n\n                assertTrue( cursor.next() );\n                assertEquals( keyId2, item.propertyKeyId() );\n                assertEqualValues( expectedValue2, item );\n\n                assertFalse( cursor.next() );\n            }\n        }","commit_id":"518c33cb0bba29446ad3366a911a9e8b95215de5","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public Boolean fenceOff(VirtualMachine vm, Host host) {\n        if (host.getHypervisorType() != HypervisorType.KVM && host.getHypervisorType() != HypervisorType.LXC) {\n            s_logger.debug(\"Don't know how to fence non kvm hosts \" + host.getHypervisorType());\n            return null;\n        }\n\n        List<HostVO> hosts = _resourceMgr.listAllHostsInCluster(host.getClusterId());\n        FenceCommand fence = new FenceCommand(vm, host);\n\n        for (HostVO h : hosts) {\n            if (h.getHypervisorType() == HypervisorType.KVM || h.getHypervisorType() == HypervisorType.LXC) {\n                if (h.getStatus() != Status.Up) {\n                    continue;\n                }\n                if (h.getId() == host.getId()) {\n                    continue;\n                }\n                FenceAnswer answer;\n                try {\n                    answer = (FenceAnswer)_agentMgr.send(h.getId(), fence);\n                } catch (AgentUnavailableException e) {\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Moving on to the next host because \" + h.toString() + \" is unavailable\");\n                    }\n                    continue;\n                } catch (OperationTimedoutException e) {\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Moving on to the next host because \" + h.toString() + \" is unavailable\");\n                    }\n                    continue;\n                }\n                if (answer != null && answer.getResult()) {\n                    return true;\n                }\n            }\n        }\n\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Unable to fence off \" + vm.toString() + \" on \" + host.toString());\n        }\n\n        return false;\n    }","id":78404,"modified_method":"@Override\n    public Boolean fenceOff(VirtualMachine vm, Host host) {\n        if (host.getHypervisorType() != HypervisorType.KVM && host.getHypervisorType() != HypervisorType.LXC) {\n            s_logger.warn(\"Don't know how to fence non kvm hosts \" + host.getHypervisorType());\n            return null;\n        }\n\n        List<HostVO> hosts = _resourceMgr.listAllHostsInCluster(host.getClusterId());\n        FenceCommand fence = new FenceCommand(vm, host);\n\n        int i = 0;\n        for (HostVO h : hosts) {\n            if (h.getHypervisorType() == HypervisorType.KVM || h.getHypervisorType() == HypervisorType.LXC) {\n                if (h.getStatus() != Status.Up) {\n                    continue;\n                }\n\n                i++;\n\n                if (h.getId() == host.getId()) {\n                    continue;\n                }\n                FenceAnswer answer;\n                try {\n                    answer = (FenceAnswer)_agentMgr.send(h.getId(), fence);\n                } catch (AgentUnavailableException e) {\n                    s_logger.info(\"Moving on to the next host because \" + h.toString() + \" is unavailable\");\n                    continue;\n                } catch (OperationTimedoutException e) {\n                    s_logger.info(\"Moving on to the next host because \" + h.toString() + \" is unavailable\");\n                    continue;\n                }\n                if (answer != null && answer.getResult()) {\n                    return true;\n                }\n            }\n        }\n\n        _alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_HOST, host.getDataCenterId(), host.getPodId(),\n                            \"Unable to fence off host: \" + host.getId(),\n                            \"Fencing off host \" + host.getId() + \" did not succeed after asking \" + i + \" hosts. \" +\n                            \"Check Agent logs for more information.\");\n\n        s_logger.error(\"Unable to fence off \" + vm.toString() + \" on \" + host.toString());\n\n        return false;\n    }","commit_id":"fbe3b04a43ff7380a6874a2c331f372aa59ccf3d","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void testWithSingleNotKVM() {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.Any);\n        Mockito.when(host.getStatus()).thenReturn(Status.Down);\n        Mockito.when(host.getId()).thenReturn(1l);\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Collections.singletonList(host));\n        Assert.assertNull(fencer.fenceOff(virtualMachine, host));\n    }","id":78405,"modified_method":"@Test\n    public void testWithSingleNotKVM() {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.Any);\n        Mockito.when(host.getStatus()).thenReturn(Status.Down);\n        Mockito.when(host.getId()).thenReturn(1l);\n        Mockito.when(host.getDataCenterId()).thenReturn(1l);\n        Mockito.when(host.getPodId()).thenReturn(1l);\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Collections.singletonList(host));\n        Assert.assertNull(fencer.fenceOff(virtualMachine, host));\n    }","commit_id":"fbe3b04a43ff7380a6874a2c331f372aa59ccf3d","url":"https://github.com/apache/cloudstack"},{"original_method":"@Before\n    public void setup() {\n        fencer = new KVMFencer();\n        fencer._agentMgr = agentManager;\n        fencer._hostDao = hostDao;\n        fencer._resourceMgr = resourceManager;\n    }","id":78406,"modified_method":"@Before\n    public void setup() {\n        fencer = new KVMFencer();\n        fencer._agentMgr = agentManager;\n        fencer._alertMgr = alertMgr;\n        fencer._hostDao = hostDao;\n        fencer._resourceMgr = resourceManager;\n    }","commit_id":"fbe3b04a43ff7380a6874a2c331f372aa59ccf3d","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void testWithSingleHostDown() {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(host.getStatus()).thenReturn(Status.Down);\n        Mockito.when(host.getId()).thenReturn(1l);\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Collections.singletonList(host));\n        Assert.assertFalse(fencer.fenceOff(virtualMachine, host));\n    }","id":78407,"modified_method":"@Test\n    public void testWithSingleHostDown() {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(host.getDataCenterId()).thenReturn(1l);\n        Mockito.when(host.getPodId()).thenReturn(1l);\n        Mockito.when(host.getStatus()).thenReturn(Status.Down);\n        Mockito.when(host.getId()).thenReturn(1l);\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Collections.singletonList(host));\n        Assert.assertFalse(fencer.fenceOff(virtualMachine, host));\n    }","commit_id":"fbe3b04a43ff7380a6874a2c331f372aa59ccf3d","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void testWithSingleHost() {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(host.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getId()).thenReturn(1l);\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Collections.singletonList(host));\n        Assert.assertFalse(fencer.fenceOff(virtualMachine, host));\n    }","id":78408,"modified_method":"@Test\n    public void testWithSingleHost() {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(host.getDataCenterId()).thenReturn(1l);\n        Mockito.when(host.getPodId()).thenReturn(1l);\n        Mockito.when(host.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getId()).thenReturn(1l);\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Collections.singletonList(host));\n        Assert.assertFalse(fencer.fenceOff(virtualMachine, host));\n    }","commit_id":"fbe3b04a43ff7380a6874a2c331f372aa59ccf3d","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void testWithFailingFence() throws AgentUnavailableException, OperationTimedoutException {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(host.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getId()).thenReturn(1l);\n\n        HostVO secondHost = Mockito.mock(HostVO.class);\n        Mockito.when(secondHost.getClusterId()).thenReturn(1l);\n        Mockito.when(secondHost.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(secondHost.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getId()).thenReturn(2l);\n\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Arrays.asList(host, secondHost));\n\n        Mockito.when(agentManager.send(Matchers.anyLong(), Matchers.any(FenceCommand.class))).thenThrow(new AgentUnavailableException(2l));\n\n        Assert.assertFalse(fencer.fenceOff(virtualMachine, host));\n    }","id":78409,"modified_method":"@Test\n    public void testWithFailingFence() throws AgentUnavailableException, OperationTimedoutException {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(host.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getDataCenterId()).thenReturn(1l);\n        Mockito.when(host.getPodId()).thenReturn(1l);\n        Mockito.when(host.getId()).thenReturn(1l);\n\n        HostVO secondHost = Mockito.mock(HostVO.class);\n        Mockito.when(secondHost.getClusterId()).thenReturn(1l);\n        Mockito.when(secondHost.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(secondHost.getStatus()).thenReturn(Status.Up);\n        Mockito.when(secondHost.getDataCenterId()).thenReturn(1l);\n        Mockito.when(secondHost.getPodId()).thenReturn(1l);\n        Mockito.when(host.getId()).thenReturn(2l);\n\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Arrays.asList(host, secondHost));\n\n        Mockito.when(agentManager.send(Matchers.anyLong(), Matchers.any(FenceCommand.class))).thenThrow(new AgentUnavailableException(2l));\n\n        Assert.assertFalse(fencer.fenceOff(virtualMachine, host));\n    }","commit_id":"fbe3b04a43ff7380a6874a2c331f372aa59ccf3d","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void testWithHosts() throws AgentUnavailableException, OperationTimedoutException {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(host.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getId()).thenReturn(1l);\n\n        HostVO secondHost = Mockito.mock(HostVO.class);\n        Mockito.when(secondHost.getClusterId()).thenReturn(1l);\n        Mockito.when(secondHost.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(secondHost.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getId()).thenReturn(2l);\n\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Arrays.asList(host, secondHost));\n\n        FenceAnswer answer = new FenceAnswer(null, true, \"ok\");\n        Mockito.when(agentManager.send(Matchers.anyLong(), Matchers.any(FenceCommand.class))).thenReturn(answer);\n\n        Assert.assertTrue(fencer.fenceOff(virtualMachine, host));\n    }","id":78410,"modified_method":"@Test\n    public void testWithHosts() throws AgentUnavailableException, OperationTimedoutException {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(host.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getDataCenterId()).thenReturn(1l);\n        Mockito.when(host.getPodId()).thenReturn(1l);\n        Mockito.when(host.getId()).thenReturn(1l);\n\n        HostVO secondHost = Mockito.mock(HostVO.class);\n        Mockito.when(secondHost.getClusterId()).thenReturn(1l);\n        Mockito.when(secondHost.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(secondHost.getStatus()).thenReturn(Status.Up);\n        Mockito.when(secondHost.getDataCenterId()).thenReturn(1l);\n        Mockito.when(secondHost.getPodId()).thenReturn(1l);\n        Mockito.when(host.getId()).thenReturn(2l);\n\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Arrays.asList(host, secondHost));\n\n        FenceAnswer answer = new FenceAnswer(null, true, \"ok\");\n        Mockito.when(agentManager.send(Matchers.anyLong(), Matchers.any(FenceCommand.class))).thenReturn(answer);\n\n        Assert.assertTrue(fencer.fenceOff(virtualMachine, host));\n    }","commit_id":"fbe3b04a43ff7380a6874a2c331f372aa59ccf3d","url":"https://github.com/apache/cloudstack"},{"original_method":"@Test\n    public void testWithTimeoutingFence() throws AgentUnavailableException, OperationTimedoutException {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(host.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getId()).thenReturn(1l);\n\n        HostVO secondHost = Mockito.mock(HostVO.class);\n        Mockito.when(secondHost.getClusterId()).thenReturn(1l);\n        Mockito.when(secondHost.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(secondHost.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getId()).thenReturn(2l);\n\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Arrays.asList(host, secondHost));\n\n        Mockito.when(agentManager.send(Matchers.anyLong(), Matchers.any(FenceCommand.class))).thenThrow(new OperationTimedoutException(null, 2l, 0l, 0, false));\n\n        Assert.assertFalse(fencer.fenceOff(virtualMachine, host));\n    }","id":78411,"modified_method":"@Test\n    public void testWithTimeoutingFence() throws AgentUnavailableException, OperationTimedoutException {\n        HostVO host = Mockito.mock(HostVO.class);\n        Mockito.when(host.getClusterId()).thenReturn(1l);\n        Mockito.when(host.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(host.getStatus()).thenReturn(Status.Up);\n        Mockito.when(host.getDataCenterId()).thenReturn(1l);\n        Mockito.when(host.getPodId()).thenReturn(1l);\n        Mockito.when(host.getId()).thenReturn(1l);\n\n        HostVO secondHost = Mockito.mock(HostVO.class);\n        Mockito.when(secondHost.getClusterId()).thenReturn(1l);\n        Mockito.when(secondHost.getHypervisorType()).thenReturn(HypervisorType.KVM);\n        Mockito.when(secondHost.getStatus()).thenReturn(Status.Up);\n        Mockito.when(secondHost.getDataCenterId()).thenReturn(1l);\n        Mockito.when(secondHost.getPodId()).thenReturn(1l);\n        Mockito.when(host.getId()).thenReturn(2l);\n\n        VirtualMachine virtualMachine = Mockito.mock(VirtualMachine.class);\n\n        Mockito.when(resourceManager.listAllHostsInCluster(1l)).thenReturn(Arrays.asList(host, secondHost));\n\n        Mockito.when(agentManager.send(Matchers.anyLong(), Matchers.any(FenceCommand.class))).thenThrow(new OperationTimedoutException(null, 2l, 0l, 0, false));\n\n        Assert.assertFalse(fencer.fenceOff(virtualMachine, host));\n    }","commit_id":"fbe3b04a43ff7380a6874a2c331f372aa59ccf3d","url":"https://github.com/apache/cloudstack"},{"original_method":"public SpreadsheetRow(String source) {\n\n\n            if(logger.isDebugEnabled()) logger.debug(\"creating row from string \" + source);\n            rowcontent = new ArrayList();\n            CSV csv = new CSV();\n            rowcontent = csv.parse(source);\n\n            try {\n                if(logger.isDebugEnabled()) logger.debug(\"getuser name for \"+ rowcontent.get(0));\n                //userDisplayName = getUserDirectoryService().getUserDisplayName(tokens[0]);\n                userId = (String) rowcontent.get(0);\n                userDisplayName = ((User)rosterMap.get(rowcontent.get(0))).getDisplayName();\n                userUid = ((User)rosterMap.get(rowcontent.get(0))).getUserUid();\n                isKnown  = true;\n                if(logger.isDebugEnabled())logger.debug(\"get userid \"+ rowcontent.get(0) + \"username is \"+userDisplayName);\n\n            } catch (NullPointerException e) {\n                if(logger.isDebugEnabled()) logger.debug(\"User \" + rowcontent.get(0) + \" is unknown to this gradebook \");\n                if(logger.isDebugEnabled()) logger.error(e);\n                userDisplayName = \"unknown student\";\n                userId = (String) rowcontent.get(0);\n                userUid = null;\n                isKnown = false;\n\n            }\n\n        }","id":78412,"modified_method":"public SpreadsheetRow(String source) {\n\n\n            if(logger.isDebugEnabled()) logger.debug(\"creating row from string \" + source);\n            rowcontent = new ArrayList();\n            CSV csv = new CSV();\n            rowcontent = csv.parse(source);\n\n            try {\n                if(logger.isDebugEnabled()) logger.debug(\"getuser name for \"+ rowcontent.get(0));\n                //userDisplayName = getUserDirectoryService().getUserDisplayName(tokens[0]);\n                userId = (String) rowcontent.get(0);\n                userDisplayName = ((User)rosterMap.get(userId)).getDisplayName();\n                userUid = ((User)rosterMap.get(userId)).getUserUid();\n                isKnown  = true;\n                if(logger.isDebugEnabled())logger.debug(\"get userid \"+ rowcontent.get(0) + \"username is \"+userDisplayName);\n\n            } catch (NullPointerException e) {\n                logger.error(\"User \" + rowcontent.get(0) + \" is unknown to this gradebook: \" + e);\n                userDisplayName = \"unknown student\";\n                userId = (String) rowcontent.get(0);\n                userUid = null;\n                isKnown = false;\n\n            }\n\n        }","commit_id":"cc258e4ef889ee222b7088162a3af6048fe29dc3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String saveGrades(){\n\n        if(logger.isDebugEnabled())logger.debug(\"create assignment and save grades\");\n        if(logger.isDebugEnabled()) logger.debug(\"first check if all variables are numeric\");\n\n        Iterator iter = scores.entrySet().iterator();\n        while(iter.hasNext()){\n            Map.Entry entry  = (Map.Entry) iter.next();\n            String points =  (String) entry.getValue();\n            try{\n                if(logger.isDebugEnabled()) logger.debug(\"checking if \" +points +\" is a numeric value\");\n                if(!entry.getKey().equals(\"Assignment\"))Double.parseDouble(points);\n            }catch(NumberFormatException e){\n                if(logger.isDebugEnabled()) logger.debug(points + \" is not a numeric value\");\n                FacesUtil.addRedirectSafeMessage(getLocalizedString(\"import_assignment_notsupported\"));\n\n                return \"spreadsheetPreview\";\n            }\n\n        }\n\n\n        try {\n            assignmentId = getGradebookManager().createAssignment(getGradebookId(), assignment.getName(), assignment.getPointsPossible(), assignment.getDueDate(), new Boolean(assignment.isNotCounted()),new Boolean(assignment.isReleased()));\n            FacesUtil.addRedirectSafeMessage(getLocalizedString(\"add_assignment_save\", new String[] {assignment.getName()}));\n\n            assignment = getGradebookManager().getAssignmentWithStats(assignmentId);\n            graderecords = new GradeRecordSet(assignment);\n\n            if(logger.isDebugEnabled())logger.debug(\"remove title entry form map\");\n            scores.remove(\"Assignment\");\n            if(logger.isDebugEnabled())logger.debug(\"iterate through scores and and save assignment grades\");\n\n            Iterator it = scores.entrySet().iterator();\n            while(it.hasNext()){\n\n                Map.Entry entry = (Map.Entry) it.next();\n                String uid = (String) entry.getKey();\n                String points = (String) entry.getValue();\n                AssignmentGradeRecord asnGradeRecord = new AssignmentGradeRecord(assignment,uid,Double.valueOf(points));\n                graderecords.addGradeRecord(asnGradeRecord);\n                if(logger.isDebugEnabled())logger.debug(\"added grades for \" + uid + \" - points scored \" +points);\n\n            }\n\n            if(logger.isDebugEnabled())logger.debug(\"persist grade records to database\");\n            Set mismatchedScores  = getGradebookManager().updateAssignmentGradeRecords(graderecords);\n\n            return  \"spreadsheetPreview\";\n        } catch (ConflictingAssignmentNameException e) {\n            if(logger.isErrorEnabled())logger.error(e);\n            FacesUtil.addErrorMessage(getLocalizedString(\"add_assignment_name_conflict_failure\"));\n        }\n\n        return null;\n    }","id":78413,"modified_method":"public String saveGrades(){\n\n        if(logger.isDebugEnabled())logger.debug(\"create assignment and save grades\");\n        if(logger.isDebugEnabled()) logger.debug(\"first check if all variables are numeric\");\n\n        logger.debug(\"********************\" + scores);\n        \n        Iterator iter = scores.entrySet().iterator();\n        while(iter.hasNext()){\n            Map.Entry entry  = (Map.Entry) iter.next();\n            String points =  (String) entry.getValue();\n            try{\n                if(logger.isDebugEnabled()) logger.debug(\"checking if \" +points +\" is a numeric value\");\n                if(!entry.getKey().equals(\"Assignment\"))Double.parseDouble(points);\n            }catch(NumberFormatException e){\n                if(logger.isDebugEnabled()) logger.debug(points + \" is not a numeric value\");\n                FacesUtil.addRedirectSafeMessage(getLocalizedString(\"import_assignment_notsupported\"));\n\n                return \"spreadsheetPreview\";\n            }\n\n        }\n\n\n        try {\n            assignmentId = getGradebookManager().createAssignment(getGradebookId(), assignment.getName(), assignment.getPointsPossible(), assignment.getDueDate(), new Boolean(assignment.isNotCounted()),new Boolean(assignment.isReleased()));\n            FacesUtil.addRedirectSafeMessage(getLocalizedString(\"add_assignment_save\", new String[] {assignment.getName()}));\n\n            assignment = getGradebookManager().getAssignmentWithStats(assignmentId);\n            graderecords = new GradeRecordSet(assignment);\n\n            if(logger.isDebugEnabled())logger.debug(\"remove title entry form map\");\n            scores.remove(\"Assignment\");\n            if(logger.isDebugEnabled())logger.debug(\"iterate through scores and and save assignment grades\");\n\n            Iterator it = scores.entrySet().iterator();\n            while(it.hasNext()){\n\n                Map.Entry entry = (Map.Entry) it.next();\n                String uid = (String) entry.getKey();\n                String points = (String) entry.getValue();\n                AssignmentGradeRecord asnGradeRecord = new AssignmentGradeRecord(assignment,uid,Double.valueOf(points));\n                graderecords.addGradeRecord(asnGradeRecord);\n                if(logger.isDebugEnabled())logger.debug(\"added grades for \" + uid + \" - points scored \" +points);\n\n            }\n\n            if(logger.isDebugEnabled())logger.debug(\"persist grade records to database\");\n            Set mismatchedScores  = getGradebookManager().updateAssignmentGradeRecords(graderecords);\n\n            return  \"spreadsheetPreview\";\n        } catch (ConflictingAssignmentNameException e) {\n            if(logger.isErrorEnabled())logger.error(e);\n            FacesUtil.addErrorMessage(getLocalizedString(\"add_assignment_name_conflict_failure\"));\n        }\n\n        return null;\n    }","commit_id":"cc258e4ef889ee222b7088162a3af6048fe29dc3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/** parse: break the input String into fields\n         * @return java.util.Iterator containing each field\n         * from the original as a String, in order.\n         */\n        public List parse(String line)\n        {\n            StringBuffer sb = new StringBuffer();\n            list.clear();      // recycle to initial state\n            int i = 0;\n\n            if (line.length() == 0) {\n                list.add(line);\n                return list;\n            }\n\n            do {\n                sb.setLength(0);\n                if (i < line.length() && line.charAt(i) == '\"')\n                    i = advQuoted(line, sb, ++i);  // skip quote\n                else\n                    i = advPlain(line, sb, i);\n                list.add(sb.toString());\n                i++;\n            } while (i < line.length());\n\n            return list;\n        }","id":78414,"modified_method":"/** parse: break the input String into fields\n         * @return java.util.Iterator containing each field\n         * from the original as a String, in order.\n         */\n        public List parse(String line)\n        {\n            StringBuffer sb = new StringBuffer();\n            list.clear();      // recycle to initial state\n            int i = 0;\n\n            if (line.length() == 0) {\n                list.add(line);\n                return list;\n            }\n\n            do {\n                sb.setLength(0);\n                if (i < line.length() && line.charAt(i) == '\"')\n                    i = advQuoted(line, sb, ++i);  // skip quote\n                else\n                    i = advPlain(line, sb, i);\n                list.add(sb.toString());\n                i++;\n            } while (i < line.length());\n            if(logger.isDebugEnabled()) {\n                StringBuffer logBuffer = new StringBuffer(\"Parsed \" + line + \" as: \");\n                for(Iterator iter = list.iterator(); iter.hasNext();) {\n                \tlogBuffer.append(iter.next());\n                \tif(iter.hasNext()) {\n                \t\tlogBuffer.append(\", \");\n                \t}\n                }\n                logger.debug(\"Parsed source string \" + line + \" as \" + logBuffer.toString() + \", length=\" + list.size());\n            }\n            return list;\n\n        }","commit_id":"cc258e4ef889ee222b7088162a3af6048fe29dc3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String importData(){\n\n        FacesContext facesContext = FacesContext.getCurrentInstance();\n        HttpServletRequest request = (HttpServletRequest) facesContext.getExternalContext().getRequest();\n\n        if(logger.isDebugEnabled())logger.debug(\"processFile()\");\n        String selectedColumn =  request.getParameter(\"form:assignment\");\n        if(logger.isDebugEnabled())logger.debug(\"the selected column is \" + selectedColumn);\n\n        selectedAssignment = new HashMap();\n        try{\n            selectedAssignment.put(\"Assignment\", assignmentHeaders.get(Integer.parseInt(selectedColumn) - 1));\n        }catch(Exception e){\n            if(logger.isDebugEnabled())logger.debug(\"no assignment selected\");\n            FacesUtil.addErrorMessage(getLocalizedString(\"import_preview_assignment_selection_failure\"));\n            return null;\n        }\n\n        Iterator it = studentRows.iterator();\n        if(logger.isDebugEnabled())logger.debug(\"number of student rows \"+studentRows.size() );\n         int i = 0;\n         while(it.hasNext()){\n\n             if(logger.isDebugEnabled())logger.debug(\"row \" + i);\n             SpreadsheetRow row = (SpreadsheetRow) it.next();\n             List line = row.getRowcontent();\n\n             String userid = \"\";\n             String user = (String)line.get(0);\n             try{\n                 userid = ((User)rosterMap.get(line.get(0))).getUserUid();\n             }catch(Exception e){\n                 if(logger.isDebugEnabled())logger.debug(\"user \"+ user + \"is not known to the system\");\n                 userid = \"\";\n             }\n             String points;\n             try{\n                 points = (String) line.get(Integer.parseInt(selectedColumn));\n             }catch(NumberFormatException e){\n                 if(logger.isDebugEnabled())logger.error(e);\n                 points = \"\";\n\n             }\n             if(logger.isDebugEnabled())logger.debug(\"user \"+user + \" userid \" + userid +\" points \"+points);\n             if(!points.equals(\"\") && (!userid.equals(\"\"))){\n                 selectedAssignment.put(userid,points);\n             }\n             i++;\n         }\n        if(logger.isDebugEnabled())logger.debug(\"scores to import \"+ i);\n\n        spreadsheet.setSelectedAssignment(selectedAssignment);\n\n        if(assignment == null) {\n            assignment = new Assignment();\n            assignment.setReleased(true);\n        }\n\n        try{\n            scores =  spreadsheet.getSelectedAssignment();\n            assignment.setName((String) scores.get(\"Assignment\"));\n        }catch(NullPointerException npe){\n            if(logger.isDebugEnabled()) logger.debug(\"scores not set\");\n        }\n\n        return \"spreadsheetImport\";\n    }","id":78415,"modified_method":"public String importData(){\n\n        FacesContext facesContext = FacesContext.getCurrentInstance();\n        HttpServletRequest request = (HttpServletRequest) facesContext.getExternalContext().getRequest();\n\n        if(logger.isDebugEnabled())logger.debug(\"processFile()\");\n        String selectedColumn =  request.getParameter(\"form:assignment\");\n        if(logger.isDebugEnabled())logger.debug(\"the selected column is \" + selectedColumn);\n\n        selectedAssignment = new HashMap();\n        try{\n            selectedAssignment.put(\"Assignment\", assignmentHeaders.get(Integer.parseInt(selectedColumn) - 1));\n        }catch(Exception e){\n            if(logger.isDebugEnabled())logger.debug(\"no assignment selected\");\n            FacesUtil.addErrorMessage(getLocalizedString(\"import_preview_assignment_selection_failure\"));\n            return null;\n        }\n\n        Iterator it = studentRows.iterator();\n        if(logger.isDebugEnabled())logger.debug(\"number of student rows \"+studentRows.size() );\n         int i = 0;\n         while(it.hasNext()){\n\n             if(logger.isDebugEnabled())logger.debug(\"row \" + i);\n             SpreadsheetRow row = (SpreadsheetRow) it.next();\n             List line = row.getRowcontent();\n\n             String userid = \"\";\n             String user = (String)line.get(0);\n             try{\n                 userid = ((User)rosterMap.get(line.get(0))).getUserUid();\n             }catch(Exception e){\n                 if(logger.isDebugEnabled())logger.debug(\"user \"+ user + \"is not known to the system\");\n                 userid = \"\";\n             }\n             \n             String points;\n             try{\n            \t int index = Integer.parseInt(selectedColumn);\n            \t if(line.size() > index) {\n                     points = (String) line.get(index);\n            \t } else {\n            \t\t logger.info(\"unable to find any points for \" + userid + \" in spreadsheet\");\n            \t\t points = \"\";\n            \t }\n             }catch(NumberFormatException e){\n                 if(logger.isDebugEnabled())logger.error(e);\n                 points = \"\";\n             }\n             if(logger.isDebugEnabled())logger.debug(\"user \"+user + \" userid \" + userid +\" points \"+points);\n             if(!\"\".equals(points) && (!\"\".equals(userid))){\n                 selectedAssignment.put(userid,points);\n             }\n             i++;\n         }\n        if(logger.isDebugEnabled())logger.debug(\"scores to import \"+ i);\n\n        spreadsheet.setSelectedAssignment(selectedAssignment);\n\n        if(assignment == null) {\n            assignment = new Assignment();\n            assignment.setReleased(true);\n        }\n\n        try{\n            scores =  spreadsheet.getSelectedAssignment();\n            assignment.setName((String) scores.get(\"Assignment\"));\n        }catch(NullPointerException npe){\n            if(logger.isDebugEnabled()) logger.debug(\"scores not set\");\n        }\n\n        return \"spreadsheetImport\";\n    }","commit_id":"cc258e4ef889ee222b7088162a3af6048fe29dc3","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\tprotected void doReceive(Message message) throws Exception {\n\t\tlong backgroundTaskId = (Long)message.get(\"backgroundTaskId\");\n\n\t\tBackgroundTaskThreadLocal.setBackgroundTaskId(backgroundTaskId);\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tBackgroundTask backgroundTask =\n\t\t\tBackgroundTaskLocalServiceUtil.amendBackgroundTask(\n\t\t\t\tbackgroundTaskId, null,\n\t\t\t\tBackgroundTaskConstants.STATUS_IN_PROGRESS, serviceContext);\n\n\t\tif (backgroundTask == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tBackgroundTaskExecutor backgroundTaskExecutor = null;\n\t\tBackgroundTaskStatusMessageListener\n\t\t\tbackgroundTaskStatusMessageListener = null;\n\n\t\tint status = backgroundTask.getStatus();\n\t\tString statusMessage = null;\n\n\t\ttry {\n\t\t\tClassLoader classLoader = ClassLoaderUtil.getPortalClassLoader();\n\n\t\t\tString servletContextNames =\n\t\t\t\tbackgroundTask.getServletContextNames();\n\n\t\t\tif (Validator.isNotNull(servletContextNames)) {\n\t\t\t\tclassLoader = ClassLoaderUtil.getAggregatePluginsClassLoader(\n\t\t\t\t\tStringUtil.split(servletContextNames), false);\n\t\t\t}\n\n\t\t\tbackgroundTaskExecutor =\n\t\t\t\t(BackgroundTaskExecutor)InstanceFactory.newInstance(\n\t\t\t\t\tclassLoader, backgroundTask.getTaskExecutorClassName());\n\n\t\t\tbackgroundTaskExecutor = wrapBackgroundTaskExecutor(\n\t\t\t\tbackgroundTaskExecutor, classLoader);\n\n\t\t\tBackgroundTaskStatusRegistryUtil.registerBackgroundTaskStatus(\n\t\t\t\tbackgroundTaskId);\n\n\t\t\tBackgroundTaskStatusMessageTranslator\n\t\t\t\tbackgroundTaskStatusMessageTranslator =\n\t\t\t\tbackgroundTaskExecutor.\n\t\t\t\t\tgetBackgroundTaskStatusMessageTranslator();\n\n\t\t\tif (backgroundTaskStatusMessageTranslator != null) {\n\t\t\t\tbackgroundTaskStatusMessageListener =\n\t\t\t\t\tnew BackgroundTaskStatusMessageListener(\n\t\t\t\t\t\tbackgroundTaskId,\n\t\t\t\t\t\tbackgroundTaskStatusMessageTranslator);\n\n\t\t\t\tMessageBusUtil.registerMessageListener(\n\t\t\t\t\tDestinationNames.BACKGROUND_TASK_STATUS,\n\t\t\t\t\tbackgroundTaskStatusMessageListener);\n\t\t\t}\n\n\t\t\tBackgroundTaskResult backgroundTaskResult =\n\t\t\t\tbackgroundTaskExecutor.execute(backgroundTask);\n\n\t\t\tstatus = backgroundTaskResult.getStatus();\n\t\t\tstatusMessage = backgroundTaskResult.getStatusMessage();\n\t\t}\n\t\tcatch (DuplicateLockException e) {\n\t\t\tstatus = BackgroundTaskConstants.STATUS_QUEUED;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tstatus = BackgroundTaskConstants.STATUS_FAILED;\n\n\t\t\tif (backgroundTaskExecutor != null) {\n\t\t\t\tstatusMessage = backgroundTaskExecutor.handleException(\n\t\t\t\t\tbackgroundTask, e);\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\tif (statusMessage != null) {\n\t\t\t\t\tstatusMessage.concat(StackTraceUtil.getStackTrace(e));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstatusMessage = StackTraceUtil.getStackTrace(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Unable to execute background task\", e);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tBackgroundTaskLocalServiceUtil.amendBackgroundTask(\n\t\t\t\tbackgroundTaskId, null, status, statusMessage, serviceContext);\n\n\t\t\tBackgroundTaskStatusRegistryUtil.unregisterBackgroundTaskStatus(\n\t\t\t\tbackgroundTaskId);\n\n\t\t\tif (backgroundTaskStatusMessageListener != null) {\n\t\t\t\tMessageBusUtil.unregisterMessageListener(\n\t\t\t\t\tDestinationNames.BACKGROUND_TASK_STATUS,\n\t\t\t\t\tbackgroundTaskStatusMessageListener);\n\t\t\t}\n\n\t\t\tMessage responseMessage = new Message();\n\n\t\t\tresponseMessage.put(\n\t\t\t\t\"backgroundTaskId\", backgroundTask.getBackgroundTaskId());\n\t\t\tresponseMessage.put(\"name\", backgroundTask.getName());\n\t\t\tresponseMessage.put(\"status\", status);\n\t\t\tresponseMessage.put(\n\t\t\t\t\"taskExecutorClassName\",\n\t\t\t\tbackgroundTask.getTaskExecutorClassName());\n\n\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\tDestinationNames.BACKGROUND_TASK_STATUS, responseMessage);\n\t\t}\n\t}","id":78416,"modified_method":"@Override\n\tprotected void doReceive(Message message) throws Exception {\n\t\tlong backgroundTaskId = (Long)message.get(\"backgroundTaskId\");\n\n\t\tBackgroundTaskThreadLocal.setBackgroundTaskId(backgroundTaskId);\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tBackgroundTask backgroundTask =\n\t\t\tBackgroundTaskLocalServiceUtil.amendBackgroundTask(\n\t\t\t\tbackgroundTaskId, null,\n\t\t\t\tBackgroundTaskConstants.STATUS_IN_PROGRESS, serviceContext);\n\n\t\tif (backgroundTask == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tBackgroundTaskExecutor backgroundTaskExecutor = null;\n\t\tBackgroundTaskStatusMessageListener\n\t\t\tbackgroundTaskStatusMessageListener = null;\n\n\t\tint status = backgroundTask.getStatus();\n\t\tString statusMessage = null;\n\n\t\ttry {\n\t\t\tClassLoader classLoader = ClassLoaderUtil.getPortalClassLoader();\n\n\t\t\tString servletContextNames =\n\t\t\t\tbackgroundTask.getServletContextNames();\n\n\t\t\tif (Validator.isNotNull(servletContextNames)) {\n\t\t\t\tclassLoader = ClassLoaderUtil.getAggregatePluginsClassLoader(\n\t\t\t\t\tStringUtil.split(servletContextNames), false);\n\t\t\t}\n\n\t\t\tbackgroundTaskExecutor =\n\t\t\t\t(BackgroundTaskExecutor)InstanceFactory.newInstance(\n\t\t\t\t\tclassLoader, backgroundTask.getTaskExecutorClassName());\n\n\t\t\tbackgroundTaskExecutor = wrapBackgroundTaskExecutor(\n\t\t\t\tbackgroundTaskExecutor, classLoader);\n\n\t\t\tBackgroundTaskStatusRegistryUtil.registerBackgroundTaskStatus(\n\t\t\t\tbackgroundTaskId);\n\n\t\t\tBackgroundTaskStatusMessageTranslator\n\t\t\t\tbackgroundTaskStatusMessageTranslator =\n\t\t\t\tbackgroundTaskExecutor.\n\t\t\t\t\tgetBackgroundTaskStatusMessageTranslator();\n\n\t\t\tif (backgroundTaskStatusMessageTranslator != null) {\n\t\t\t\tbackgroundTaskStatusMessageListener =\n\t\t\t\t\tnew BackgroundTaskStatusMessageListener(\n\t\t\t\t\t\tbackgroundTaskId,\n\t\t\t\t\t\tbackgroundTaskStatusMessageTranslator);\n\n\t\t\t\tMessageBusUtil.registerMessageListener(\n\t\t\t\t\tDestinationNames.BACKGROUND_TASK_STATUS,\n\t\t\t\t\tbackgroundTaskStatusMessageListener);\n\t\t\t}\n\n\t\t\tBackgroundTaskResult backgroundTaskResult =\n\t\t\t\tbackgroundTaskExecutor.execute(backgroundTask);\n\n\t\t\tstatus = backgroundTaskResult.getStatus();\n\t\t\tstatusMessage = backgroundTaskResult.getStatusMessage();\n\t\t}\n\t\tcatch (DuplicateLockException e) {\n\t\t\tstatus = BackgroundTaskConstants.STATUS_QUEUED;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tstatus = BackgroundTaskConstants.STATUS_FAILED;\n\n\t\t\tif (backgroundTaskExecutor != null) {\n\t\t\t\tstatusMessage = backgroundTaskExecutor.handleException(\n\t\t\t\t\tbackgroundTask, e);\n\t\t\t}\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\tif (statusMessage != null) {\n\t\t\t\t\tstatusMessage.concat(StackTraceUtil.getStackTrace(e));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstatusMessage = StackTraceUtil.getStackTrace(e);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_log.error(\"Unable to execute background task\", e);\n\t\t}\n\t\tfinally {\n\t\t\tBackgroundTaskLocalServiceUtil.amendBackgroundTask(\n\t\t\t\tbackgroundTaskId, null, status, statusMessage, serviceContext);\n\n\t\t\tBackgroundTaskStatusRegistryUtil.unregisterBackgroundTaskStatus(\n\t\t\t\tbackgroundTaskId);\n\n\t\t\tif (backgroundTaskStatusMessageListener != null) {\n\t\t\t\tMessageBusUtil.unregisterMessageListener(\n\t\t\t\t\tDestinationNames.BACKGROUND_TASK_STATUS,\n\t\t\t\t\tbackgroundTaskStatusMessageListener);\n\t\t\t}\n\n\t\t\tMessage responseMessage = new Message();\n\n\t\t\tresponseMessage.put(\n\t\t\t\t\"backgroundTaskId\", backgroundTask.getBackgroundTaskId());\n\t\t\tresponseMessage.put(\"name\", backgroundTask.getName());\n\t\t\tresponseMessage.put(\"status\", status);\n\t\t\tresponseMessage.put(\n\t\t\t\t\"taskExecutorClassName\",\n\t\t\t\tbackgroundTask.getTaskExecutorClassName());\n\n\t\t\tMessageBusUtil.sendMessage(\n\t\t\t\tDestinationNames.BACKGROUND_TASK_STATUS, responseMessage);\n\t\t}\n\t}","commit_id":"b46019fcf76e2f2b175809fada5ff0506c813639","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void checkUpdate(ArrayList remarks, StepMeta stepinfo, Row prev)\n\t{\n\t\tLogWriter log = LogWriter.getInstance();\n\t\t\n\t\tCheckResult cr;\n\t\tString error_message = \"\";\n\n\t\tif (database != null)\n\t\t{\n\t\t\tDatabase db = new Database(database);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdb.connect();\n\t\t\t\tif (tableName != null && tableName.length() != 0)\n\t\t\t\t{\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\tboolean error_found = false;\n\t\t\t\t\terror_message = \"\";\n\n\t\t\t\t\tRow r = db.getTableFields(tableName);\n\t\t\t\t\tif (r != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0; i < fieldLookup.length; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString lufield = fieldLookup[i];\n\t\t\t\t\t\t\tlog.logDebug(toString(), \"Check lookupfield #\" + i + \" --> \" + lufield\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" in lookup table...\");\n\t\t\t\t\t\t\tValue v = r.searchValue(lufield);\n\t\t\t\t\t\t\tif (v == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (first)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\t\t\terror_message += \"Missing compare fields in target table:\" + Const.CR;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\terror_found = true;\n\t\t\t\t\t\t\t\terror_message += \"\\t\\t\" + lufield + Const.CR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (error_found)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK,\n\t\t\t\t\t\t\t\t\t\"All lookup fields found in the dimension table.\", stepinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremarks.add(cr);\n\n\t\t\t\t\t\t/* Also, check the fields: tk, version, from-to, ... */\n                        if (keyField!=null && keyField.length()>0)\n                        {\n    \t\t\t\t\t\tif (r.searchValueIndex(keyField) < 0)\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\terror_message = \"Technical key [\" + keyField + \"] not found in target dimension table.\"\n    \t\t\t\t\t\t\t\t\t\t\t+ Const.CR;\n    \t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\telse\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\terror_message = \"Technical key [\" + keyField + \"] found in target dimension table.\"\n    \t\t\t\t\t\t\t\t\t\t\t+ Const.CR;\n    \t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepinfo);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tremarks.add(cr);\n                        }\n                        else\n                        {\n                            error_message = \"Please specify a fieldname to store the technical/surrogate key of the dimension in.\" + Const.CR;\n                            remarks.add( new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo) );\n                        }\n\n                        if (versionField != null && versionField.length() > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r.searchValueIndex(versionField) < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"Version field [\" + versionField\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"] not found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"Version field [\" + versionField + \"] found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t\t}\n                        else\n                        {\n                            error_message = \"Please specify a fieldname to store the version of the dimension entry in.\" + Const.CR;\n                            remarks.add( new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo) );\n                        }\n\n\t\t\t\t\t\tif (dateFrom != null && dateFrom.length() > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r.searchValueIndex(dateFrom) < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"Start of daterange field [\" + dateFrom\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"] not found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"Start of daterange field [\" + dateFrom\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"] found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t\t}\n                        else\n                        {\n                            error_message = \"Please specify a fieldname to store the start of the date range of the dimension entry in.\" + Const.CR;\n                            remarks.add( new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo) );\n                        }\n\n\t\t\t\t\t\tif (dateTo != null && dateTo.length() > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r.searchValueIndex(dateTo) < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"End of daterange field [\" + dateTo\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"] not found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"End of daterange field [\" + dateTo\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"] found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t\t}\n                        else\n                        {\n                            error_message = \"Please specify a fieldname to store the end of the date range of the dimension entry in.\" + Const.CR;\n                            remarks.add( new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo) );\n                        }\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\terror_message = \"Couldn't read the table info, please check the table-name & permissions.\";\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Look up fields in the input stream <prev>\n\t\t\t\tif (prev != null && prev.size() > 0)\n\t\t\t\t{\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\terror_message = \"\";\n\t\t\t\t\tboolean error_found = false;\n\n\t\t\t\t\tfor (int i = 0; i < fieldStream.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDebug(toString(), \"Check field #\" + i + \" --> \" + fieldStream[i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \", in inputstream from previous steps\");\n\t\t\t\t\t\tValue v = prev.searchValue(fieldStream[i]);\n\t\t\t\t\t\tif (v == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (first)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\t\terror_message += \"Missing fields, not found in input from previous steps:\" + Const.CR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\terror_found = true;\n\t\t\t\t\t\t\terror_message += \"\\t\\t\" + fieldStream[i] + Const.CR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (error_found)\n\t\t\t\t\t{\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"All fields found in the input stream.\",\n\t\t\t\t\t\t\t\tstepinfo);\n\t\t\t\t\t}\n\t\t\t\t\tremarks.add(cr);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terror_message = \"Couldn't read fields from the previous step.\" + Const.CR;\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\tremarks.add(cr);\n\t\t\t\t}\n\n\t\t\t\t// Check sequence\n\t\t\t\tif (database.supportsSequences() && sequenceName != null && sequenceName.length() != 0)\n\t\t\t\t{\n\t\t\t\t\tValue last = db.checkSequence(sequenceName);\n\t\t\t\t\tif (last != null)\n\t\t\t\t\t{\n\t\t\t\t\t\terror_message = \"No problem reading sequence \" + sequenceName + \", it's at value \" + last;\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepinfo);\n\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\terror_message += \"Error reading sequence \" + sequenceName + \"!\";\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (KettleException e)\n\t\t\t{\n\t\t\t\terror_message = \"Couldn't connect to database, please check the connection: \" + e.getMessage();\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror_message = \"Please select a connection name!\";\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\tremarks.add(cr);\n\t\t}\n\t}","id":78417,"modified_method":"private void checkUpdate(ArrayList remarks, StepMeta stepinfo, Row prev)\n\t{\n\t\tLogWriter log = LogWriter.getInstance();\n\t\t\n\t\tCheckResult cr;\n\t\tString error_message = \"\";\n\n\t\tif (database != null)\n\t\t{\n\t\t\tDatabase db = new Database(database);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdb.connect();\n\t\t\t\tif (tableName != null && tableName.length() != 0)\n\t\t\t\t{\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\tboolean error_found = false;\n\t\t\t\t\terror_message = \"\";\n\n\t\t\t\t\tRow r = db.getTableFields(tableName);\n\t\t\t\t\tif (r != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int i = 0; i < fieldLookup.length; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString lufield = fieldLookup[i];\n\t\t\t\t\t\t\tlog.logDebug(toString(), \"Check lookupfield #\" + i + \" --> \" + lufield\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t+ \" in lookup table...\");\n\t\t\t\t\t\t\tValue v = r.searchValue(lufield);\n\t\t\t\t\t\t\tif (v == null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (first)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\t\t\terror_message += \"Missing compare fields in target table:\" + Const.CR;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\terror_found = true;\n\t\t\t\t\t\t\t\terror_message += \"\\t\\t\" + lufield + Const.CR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (error_found)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK,\n\t\t\t\t\t\t\t\t\t\"All lookup fields found in the dimension table.\", stepinfo);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremarks.add(cr);\n\n\t\t\t\t\t\t/* Also, check the fields: tk, version, from-to, ... */\n                        if (keyField!=null && keyField.length()>0)\n                        {\n    \t\t\t\t\t\tif (r.searchValueIndex(keyField) < 0)\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\terror_message = \"Technical key [\" + keyField + \"] not found in target dimension table.\"\n    \t\t\t\t\t\t\t\t\t\t\t+ Const.CR;\n    \t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\telse\n    \t\t\t\t\t\t{\n    \t\t\t\t\t\t\terror_message = \"Technical key [\" + keyField + \"] found in target dimension table.\"\n    \t\t\t\t\t\t\t\t\t\t\t+ Const.CR;\n    \t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepinfo);\n    \t\t\t\t\t\t}\n    \t\t\t\t\t\tremarks.add(cr);\n                        }\n                        else\n                        {\n                            error_message = \"Please specify a fieldname to store the technical/surrogate key of the dimension in.\" + Const.CR;\n                            remarks.add( new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo) );\n                        }\n\n                        if (versionField != null && versionField.length() > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r.searchValueIndex(versionField) < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"Version field [\" + versionField\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"] not found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"Version field [\" + versionField + \"] found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t\t}\n                        else\n                        {\n                            error_message = \"Please specify a fieldname to store the version of the dimension entry in.\" + Const.CR;\n                            remarks.add( new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo) );\n                        }\n\n\t\t\t\t\t\tif (dateFrom != null && dateFrom.length() > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r.searchValueIndex(dateFrom) < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"Start of daterange field [\" + dateFrom\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"] not found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"Start of daterange field [\" + dateFrom\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"] found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t\t}\n                        else\n                        {\n                            error_message = \"Please specify a fieldname to store the start of the date range of the dimension entry in.\" + Const.CR;\n                            remarks.add( new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo) );\n                        }\n\n\t\t\t\t\t\tif (dateTo != null && dateTo.length() > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (r.searchValueIndex(dateTo) < 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"End of daterange field [\" + dateTo\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"] not found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\terror_message = \"End of daterange field [\" + dateTo\n\t\t\t\t\t\t\t\t\t\t\t\t+ \"] found in target dimension table.\" + Const.CR;\n\t\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepinfo);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t\t}\n                        else\n                        {\n                            error_message = \"Please specify a fieldname to store the end of the date range of the dimension entry in.\" + Const.CR;\n                            remarks.add( new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo) );\n                        }\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\terror_message = \"Couldn't read the table info, please check the table-name & permissions.\";\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Look up fields in the input stream <prev>\n\t\t\t\tif (prev != null && prev.size() > 0)\n\t\t\t\t{\n\t\t\t\t\tboolean first = true;\n\t\t\t\t\terror_message = \"\";\n\t\t\t\t\tboolean error_found = false;\n\n\t\t\t\t\tfor (int i = 0; i < fieldStream.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logDebug(toString(), \"Check field #\" + i + \" --> \" + fieldStream[i]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+ \", in inputstream from previous steps\");\n\t\t\t\t\t\tValue v = prev.searchValue(fieldStream[i]);\n\t\t\t\t\t\tif (v == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (first)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\t\terror_message += \"Missing fields, not found in input from previous steps:\" + Const.CR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\terror_found = true;\n\t\t\t\t\t\t\terror_message += \"\\t\\t\" + fieldStream[i] + Const.CR;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (error_found)\n\t\t\t\t\t{\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"All fields found in the input stream.\",\n\t\t\t\t\t\t\t\tstepinfo);\n\t\t\t\t\t}\n\t\t\t\t\tremarks.add(cr);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\terror_message = \"Couldn't read fields from the previous step.\" + Const.CR;\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\tremarks.add(cr);\n\t\t\t\t}\n\n\t\t\t\t// Check sequence\n\t\t\t\tif (database.supportsSequences() && sequenceName != null && sequenceName.length() != 0)\n\t\t\t\t{\n\t\t\t\t\tif (db.checkSequenceExists(sequenceName))\n\t\t\t\t\t{\n\t\t\t\t\t\terror_message = \"Sequence \" + sequenceName + \" exists.\";\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepinfo);\n\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\terror_message += \"Sequence \" + sequenceName + \" couldn't be found!\";\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\t\t\tremarks.add(cr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (KettleException e)\n\t\t\t{\n\t\t\t\terror_message = \"Couldn't connect to database, please check the connection: \" + e.getMessage();\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\t\tremarks.add(cr);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\terror_message = \"Please select a connection name!\";\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepinfo);\n\t\t\tremarks.add(cr);\n\t\t}\n\t}","commit_id":"8085f10602a0776939633cabe7f4f672f363f69b","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void check(ArrayList remarks, StepMeta stepMeta, Row prev, String input[], String output[], Row info)\r\n\t{\r\n\t\tCheckResult cr;\r\n\t\tString error_message = \"\"; //$NON-NLS-1$\r\n\r\n\t\tif (database!=null)\r\n\t\t{\r\n\t\t\tDatabase db = new Database(database);\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdb.connect();\r\n\r\n\t\t\t\tif (tablename!=null && tablename.length()!=0)\r\n\t\t\t\t{\r\n\t\t\t\t\tboolean first=true;\r\n\t\t\t\t\tboolean error_found=false;\r\n\t\t\t\t\terror_message = \"\"; //$NON-NLS-1$\r\n\r\n\t\t\t\t\tRow r = db.getTableFields(tablename);\r\n\t\t\t\t\tif (r!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int i=0;i<keyLookup.length;i++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tString lufield = keyLookup[i];\r\n\r\n\t\t\t\t\t\t\tValue v = r.searchValue(lufield);\r\n\t\t\t\t\t\t\tif (v==null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif (first)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tfirst=false;\r\n\t\t\t\t\t\t\t\t\terror_message+=Messages.getString(\"CombinationLookupMeta.CheckResult.MissingCompareFields\")+Const.CR; //$NON-NLS-1$\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\terror_found=true;\r\n\t\t\t\t\t\t\t\terror_message+=\"\\t\\t\"+lufield+Const.CR;  //$NON-NLS-1$\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (error_found)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"CombinationLookupMeta.CheckResult.AllFieldsFound\"), stepMeta); //$NON-NLS-1$\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tremarks.add(cr);\r\n\r\n\t\t\t\t\t\t/* Also, check the fields: tk, version, from-to, ... */\r\n\t\t\t\t\t\tif ( r.searchValueIndex(technicalKeyField)<0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\terror_message=Messages.getString(\"CombinationLookupMeta.CheckResult.TechnicalKeyNotFound\",technicalKeyField)+Const.CR; //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\terror_message=Messages.getString(\"CombinationLookupMeta.CheckResult.TechnicalKeyFound\",technicalKeyField)+Const.CR; //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepMeta);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tremarks.add(cr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\terror_message=Messages.getString(\"CombinationLookupMeta.CheckResult.CouldNotReadTableInfo\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\tremarks.add(cr);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Look up fields in the input stream <prev>\r\n\t\t\t\tif (prev!=null && prev.size()>0)\r\n\t\t\t\t{\r\n\t\t\t\t\tboolean first=true;\r\n\t\t\t\t\terror_message = \"\"; //$NON-NLS-1$\r\n\t\t\t\t\tboolean error_found = false;\r\n\r\n\t\t\t\t\tfor (int i=0;i<keyField.length;i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tValue v = prev.searchValue(keyField[i]);\r\n\t\t\t\t\t\tif (v==null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (first)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tfirst=false;\r\n\t\t\t\t\t\t\t\terror_message+=Messages.getString(\"CombinationLookupMeta.CheckResult.MissingFields\")+Const.CR; //$NON-NLS-1$\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\terror_found=true;\r\n\t\t\t\t\t\t\terror_message+=\"\\t\\t\"+keyField[i]+Const.CR;  //$NON-NLS-1$\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (error_found)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"CombinationLookupMeta.CheckResult.AllFieldsFoundInInputStream\"), stepMeta); //$NON-NLS-1$\r\n\t\t\t\t\t}\r\n\t\t\t\t\tremarks.add(cr);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\terror_message=Messages.getString(\"CombinationLookupMeta.CheckResult.CouldNotReadFields\")+Const.CR; //$NON-NLS-1$\r\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\tremarks.add(cr);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check sequence\r\n    \t\t\tif (database.supportsSequences() && CREATION_METHOD_SEQUENCE.equals(getTechKeyCreation()) )\r\n\t\t\t\t{\r\n    \t\t\t\tif ( sequenceFrom == null || sequenceFrom.length() == 0 )\r\n    \t\t\t\t{\r\n\t\t\t\t\t\terror_message+=Messages.getString(\"CombinationLookupMeta.CheckResult.ErrorNoSequenceName\") + \"!\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\tremarks.add(cr);\r\n    \t\t\t\t}\r\n    \t\t\t\telse\r\n    \t\t\t\t{\r\n    \t\t\t\t    // It doesn't make sense to check the sequence name\r\n    \t\t\t\t\t// if it's not filled in.\r\n\t\t\t\t\t    Value last = db.checkSequence(sequenceFrom);\r\n\t\t\t\t\t    if (last!=null)\r\n\t\t\t\t\t    {\r\n\t\t\t\t\t\t    error_message = Messages.getString(\"CombinationLookupMeta.CheckResult.ReadingSequenceOK\",sequenceFrom,\"\"+last); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t \t    cr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepMeta);\r\n\t\t\t\t\t\t    remarks.add(cr);\r\n\t\t\t\t\t    }\r\n\t\t\t\t\t    else\r\n\t\t\t\t\t    {\r\n\t\t\t\t\t\t    error_message+=Messages.getString(\"CombinationLookupMeta.CheckResult.ErrorReadingSequence\")+sequenceFrom+\"!\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\t    cr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\t    remarks.add(cr);\r\n\t\t\t\t\t    }\r\n    \t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( techKeyCreation != null )\r\n\t\t\t\t{\r\n\t\t\t\t    // post 2.2 version\r\n\t\t\t\t\tif ( !(CREATION_METHOD_AUTOINC.equals(techKeyCreation) ||\r\n\t\t\t\t\t       CREATION_METHOD_SEQUENCE.equals(techKeyCreation) ||\r\n\t\t\t\t\t       CREATION_METHOD_TABLEMAX.equals(techKeyCreation)) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\terror_message+=Messages.getString(\"CombinationLookupMeta.CheckResult.ErrorTechKeyCreation\")+ \": \" + techKeyCreation +\"!\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\tremarks.add(cr);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch(KettleException e)\r\n\t\t\t{\r\n\t\t\t\terror_message = Messages.getString(\"CombinationLookupMeta.CheckResult.ErrorOccurred\")+e.getMessage(); //$NON-NLS-1$\r\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\tremarks.add(cr);\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\tdb.disconnect();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\terror_message = Messages.getString(\"CombinationLookupMeta.CheckResult.InvalidConnection\"); //$NON-NLS-1$\r\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\tremarks.add(cr);\r\n\t\t}\r\n\r\n\t\t// See if we have input streams leading to this step!\r\n\t\tif (input.length>0)\r\n\t\t{\r\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"CombinationLookupMeta.CheckResult.ReceivingInfoFromOtherSteps\"), stepMeta); //$NON-NLS-1$\r\n\t\t\tremarks.add(cr);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"CombinationLookupMeta.CheckResult.NoInputReceived\"), stepMeta); //$NON-NLS-1$\r\n\t\t\tremarks.add(cr);\r\n\t\t}\r\n\t}","id":78418,"modified_method":"public void check(ArrayList remarks, StepMeta stepMeta, Row prev, String input[], String output[], Row info)\r\n\t{\r\n\t\tCheckResult cr;\r\n\t\tString error_message = \"\"; //$NON-NLS-1$\r\n\r\n\t\tif (database!=null)\r\n\t\t{\r\n\t\t\tDatabase db = new Database(database);\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tdb.connect();\r\n\r\n\t\t\t\tif (!Const.isEmpty(tablename))\r\n\t\t\t\t{\r\n\t\t\t\t\tboolean first=true;\r\n\t\t\t\t\tboolean error_found=false;\r\n\t\t\t\t\terror_message = \"\"; //$NON-NLS-1$\r\n\r\n\t\t\t\t\tRow r = db.getTableFields(tablename);\r\n\t\t\t\t\tif (r!=null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfor (int i=0;i<keyLookup.length;i++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tString lufield = keyLookup[i];\r\n\r\n\t\t\t\t\t\t\tValue v = r.searchValue(lufield);\r\n\t\t\t\t\t\t\tif (v==null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif (first)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tfirst=false;\r\n\t\t\t\t\t\t\t\t\terror_message+=Messages.getString(\"CombinationLookupMeta.CheckResult.MissingCompareFields\")+Const.CR; //$NON-NLS-1$\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\terror_found=true;\r\n\t\t\t\t\t\t\t\terror_message+=\"\\t\\t\"+lufield+Const.CR;  //$NON-NLS-1$\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (error_found)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"CombinationLookupMeta.CheckResult.AllFieldsFound\"), stepMeta); //$NON-NLS-1$\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tremarks.add(cr);\r\n\r\n\t\t\t\t\t\t/* Also, check the fields: tk, version, from-to, ... */\r\n\t\t\t\t\t\tif ( r.searchValueIndex(technicalKeyField)<0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\terror_message=Messages.getString(\"CombinationLookupMeta.CheckResult.TechnicalKeyNotFound\",technicalKeyField)+Const.CR; //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\terror_message=Messages.getString(\"CombinationLookupMeta.CheckResult.TechnicalKeyFound\",technicalKeyField)+Const.CR; //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepMeta);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tremarks.add(cr);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\terror_message=Messages.getString(\"CombinationLookupMeta.CheckResult.CouldNotReadTableInfo\"); //$NON-NLS-1$\r\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\tremarks.add(cr);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Look up fields in the input stream <prev>\r\n\t\t\t\tif (prev!=null && prev.size()>0)\r\n\t\t\t\t{\r\n\t\t\t\t\tboolean first=true;\r\n\t\t\t\t\terror_message = \"\"; //$NON-NLS-1$\r\n\t\t\t\t\tboolean error_found = false;\r\n\r\n\t\t\t\t\tfor (int i=0;i<keyField.length;i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tValue v = prev.searchValue(keyField[i]);\r\n\t\t\t\t\t\tif (v==null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif (first)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tfirst=false;\r\n\t\t\t\t\t\t\t\terror_message+=Messages.getString(\"CombinationLookupMeta.CheckResult.MissingFields\")+Const.CR; //$NON-NLS-1$\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\terror_found=true;\r\n\t\t\t\t\t\t\terror_message+=\"\\t\\t\"+keyField[i]+Const.CR;  //$NON-NLS-1$\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (error_found)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"CombinationLookupMeta.CheckResult.AllFieldsFoundInInputStream\"), stepMeta); //$NON-NLS-1$\r\n\t\t\t\t\t}\r\n\t\t\t\t\tremarks.add(cr);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\terror_message=Messages.getString(\"CombinationLookupMeta.CheckResult.CouldNotReadFields\")+Const.CR; //$NON-NLS-1$\r\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\tremarks.add(cr);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check sequence\r\n    \t\t\tif (database.supportsSequences() && CREATION_METHOD_SEQUENCE.equals(getTechKeyCreation()) )\r\n\t\t\t\t{\r\n    \t\t\t\tif ( Const.isEmpty(sequenceFrom) )\r\n    \t\t\t\t{\r\n\t\t\t\t\t\terror_message+=Messages.getString(\"CombinationLookupMeta.CheckResult.ErrorNoSequenceName\") + \"!\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\tremarks.add(cr);\r\n    \t\t\t\t}\r\n    \t\t\t\telse\r\n    \t\t\t\t{\r\n    \t\t\t\t    // It doesn't make sense to check the sequence name\r\n    \t\t\t\t\t// if it's not filled in.\r\n\t\t\t\t\t    if (db.checkSequenceExists(sequenceFrom))\r\n\t\t\t\t\t    {\r\n\t\t\t\t\t\t    error_message = Messages.getString(\"CombinationLookupMeta.CheckResult.ReadingSequenceOK\",sequenceFrom); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t \t    cr = new CheckResult(CheckResult.TYPE_RESULT_OK, error_message, stepMeta);\r\n\t\t\t\t\t\t    remarks.add(cr);\r\n\t\t\t\t\t    }\r\n\t\t\t\t\t    else\r\n\t\t\t\t\t    {\r\n\t\t\t\t\t\t    error_message+=Messages.getString(\"CombinationLookupMeta.CheckResult.ErrorReadingSequence\")+sequenceFrom+\"!\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\t    cr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\t    remarks.add(cr);\r\n\t\t\t\t\t    }\r\n    \t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( techKeyCreation != null )\r\n\t\t\t\t{\r\n\t\t\t\t    // post 2.2 version\r\n\t\t\t\t\tif ( !(CREATION_METHOD_AUTOINC.equals(techKeyCreation) ||\r\n\t\t\t\t\t       CREATION_METHOD_SEQUENCE.equals(techKeyCreation) ||\r\n\t\t\t\t\t       CREATION_METHOD_TABLEMAX.equals(techKeyCreation)) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\terror_message+=Messages.getString(\"CombinationLookupMeta.CheckResult.ErrorTechKeyCreation\")+ \": \" + techKeyCreation +\"!\"; //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\t\t\tremarks.add(cr);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch(KettleException e)\r\n\t\t\t{\r\n\t\t\t\terror_message = Messages.getString(\"CombinationLookupMeta.CheckResult.ErrorOccurred\")+e.getMessage(); //$NON-NLS-1$\r\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\t\tremarks.add(cr);\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\tdb.disconnect();\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\terror_message = Messages.getString(\"CombinationLookupMeta.CheckResult.InvalidConnection\"); //$NON-NLS-1$\r\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, error_message, stepMeta);\r\n\t\t\tremarks.add(cr);\r\n\t\t}\r\n\r\n\t\t// See if we have input streams leading to this step!\r\n\t\tif (input.length>0)\r\n\t\t{\r\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, Messages.getString(\"CombinationLookupMeta.CheckResult.ReceivingInfoFromOtherSteps\"), stepMeta); //$NON-NLS-1$\r\n\t\t\tremarks.add(cr);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, Messages.getString(\"CombinationLookupMeta.CheckResult.NoInputReceived\"), stepMeta); //$NON-NLS-1$\r\n\t\t\tremarks.add(cr);\r\n\t\t}\r\n\t}","commit_id":"bc737c1a0c6f1012e091f5752892b544ad2ce31e","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void check(ArrayList remarks, StepMeta stepMeta, Row prev, String input[], String output[], Row info)\n\t{\n\t\tCheckResult cr;\n\t\tif (useDatabase)\n\t\t{\n\t\t\tDatabase db = new Database(database);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdb.connect();\n\t\t\t\tValue last = db.checkSequence(sequenceName);\n\t\t\t\tif (last!=null)\n\t\t\t\t{\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Sequence is at value \"+last, stepMeta);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"Last value of sequence couldn't be found\", stepMeta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"Unable to connect to database to verify sequence because of an error: \"+Const.CR+e.getMessage(), stepMeta);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tdb.disconnect();\n\t\t\t}\n\t\t\tremarks.add(cr);\n\t\t}\n\t\t\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Step is receiving info from other steps.\", stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"No input received from other steps!\", stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t}","id":78419,"modified_method":"public void check(ArrayList remarks, StepMeta stepMeta, Row prev, String input[], String output[], Row info)\n\t{\n\t\tCheckResult cr;\n\t\tif (useDatabase)\n\t\t{\n\t\t\tDatabase db = new Database(database);\n\t\t\ttry\n\t\t\t{\n\t\t\t\tdb.connect();\n\t\t\t\tif (db.checkSequenceExists(sequenceName))\n\t\t\t\t{\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Sequence exits.\", stepMeta);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"The sequence [\"+sequenceName+\"] couldn't be found\", stepMeta);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(KettleException e)\n\t\t\t{\n\t\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"Unable to connect to database to verify sequence because of an error: \"+Const.CR+e.getMessage(), stepMeta);\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tdb.disconnect();\n\t\t\t}\n\t\t\tremarks.add(cr);\n\t\t}\n\t\t\n\t\tif (input.length>0)\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_OK, \"Step is receiving info from other steps.\", stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcr = new CheckResult(CheckResult.TYPE_RESULT_ERROR, \"No input received from other steps!\", stepMeta);\n\t\t\tremarks.add(cr);\n\t\t}\n\t}","commit_id":"4b3f317094bc11e0bd825d411c2e7f7011c1eb14","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public SQLStatement getSQLStatements(TransMeta transMeta, StepMeta stepMeta, Row prev)\n\t{\n\t\tSQLStatement retval = new SQLStatement(stepMeta.getName(), database, null); // default: nothing to do!\n\t\n\t\tif (useDatabase) // Otherwise, don't bother!\n\t\t{\n\t\t\tif (database!=null)\n\t\t\t{\n\t\t\t\tDatabase db = new Database(database);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tdb.connect();\n\t\t\t\t\tValue last = db.checkSequence(sequenceName);\n\t\t\t\t\tif (last==null)\n\t\t\t\t\t{\n\t\t\t\t\t\tString cr_table = db.getCreateSequenceStatement(sequenceName, startAt, incrementBy, maxValue, true);\n\t\t\t\t\t\tretval.setSQL(cr_table);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tretval.setSQL(null); // Empty string means: nothing to do: set it to null...\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(KettleException e)\n\t\t\t\t{\n\t\t\t\t\tretval.setError(\"I was unable to connect to the database to verify the status of the table.\"+Const.CR+e.getMessage());\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tdb.disconnect();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tretval.setError(\"There is no connection defined in this step.\");\n\t\t\t}\n\t\t}\n\n\t\treturn retval;\n\t}","id":78420,"modified_method":"public SQLStatement getSQLStatements(TransMeta transMeta, StepMeta stepMeta, Row prev)\n\t{\n\t\tSQLStatement retval = new SQLStatement(stepMeta.getName(), database, null); // default: nothing to do!\n\t\n\t\tif (useDatabase) // Otherwise, don't bother!\n\t\t{\n\t\t\tif (database!=null)\n\t\t\t{\n\t\t\t\tDatabase db = new Database(database);\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tdb.connect();\n\t\t\t\t\tif (!db.checkSequenceExists(sequenceName))\n\t\t\t\t\t{\n\t\t\t\t\t\tString cr_table = db.getCreateSequenceStatement(sequenceName, startAt, incrementBy, maxValue, true);\n\t\t\t\t\t\tretval.setSQL(cr_table);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tretval.setSQL(null); // Empty string means: nothing to do: set it to null...\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(KettleException e)\n\t\t\t\t{\n\t\t\t\t\tretval.setError(\"I was unable to connect to the database to verify the status of the table.\"+Const.CR+e.getMessage());\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\tdb.disconnect();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tretval.setError(\"There is no connection defined in this step.\");\n\t\t\t}\n\t\t}\n\n\t\treturn retval;\n\t}","commit_id":"c5f88a63dc68db8e00bc9b08b8c7daacb671d4ba","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void jbInit() throws Exception{\n        border1 = BorderFactory.createEmptyBorder();\n        border2 = BorderFactory.createEmptyBorder();\n        jSplitPane1.setOrientation(JSplitPane.VERTICAL_SPLIT);\n        tokenPane.setEditable(false);\n        tokenPane.setText(\"\");\n        scriptPane.setFont(new java.awt.Font(\"DialogInput\", 0, 12));\n        scriptPane.setEditable(false);\n        scriptPane.setMargin(new Insets(5, 5, 5, 5));\n        scriptPane.setText(\"\");\n        jScrollPane1.setBorder(border1);\n        jScrollPane2.setBorder(border1);\n        jSplitPane1.setMinimumSize(new Dimension(800,600));\n        mainPanel.add(jSplitPane1, BorderLayout.CENTER);\n        mainPanel.add(jbutton,BorderLayout.NORTH);\n        this.getContentPane().add(mainPanel);\n        jSplitPane1.add(jScrollPane1, JSplitPane.LEFT);\n        jScrollPane1.getViewport().add(tokenPane, null);\n        jSplitPane1.add(jScrollPane2, JSplitPane.RIGHT);\n        jScrollPane2.getViewport().add(scriptPane, null);\n\n        jScrollPane1.setColumnHeaderView(new JLabel(\" Token Stream:\"));\n        jScrollPane2.setColumnHeaderView(new JLabel(\" Input Script:\"));\n        jSplitPane1.setResizeWeight(0.5);\n    }","id":78421,"modified_method":"private void jbInit() throws Exception {\n        final Border border1 = BorderFactory.createEmptyBorder();\n        jSplitPane1.setOrientation(JSplitPane.VERTICAL_SPLIT);\n        tokenPane.setEditable(false);\n        tokenPane.setText(\"\");\n        scriptPane.setFont(new java.awt.Font(\"DialogInput\", 0, 12));\n        scriptPane.setEditable(false);\n        scriptPane.setMargin(new Insets(5, 5, 5, 5));\n        scriptPane.setText(\"\");\n        jScrollPane1.setBorder(border1);\n        jScrollPane2.setBorder(border1);\n        jSplitPane1.setMinimumSize(new Dimension(800, 600));\n        mainPanel.add(jSplitPane1, BorderLayout.CENTER);\n        mainPanel.add(jbutton, BorderLayout.NORTH);\n        this.getContentPane().add(mainPanel);\n        jSplitPane1.add(jScrollPane1, JSplitPane.LEFT);\n        jScrollPane1.getViewport().add(tokenPane, null);\n        jSplitPane1.add(jScrollPane2, JSplitPane.RIGHT);\n        jScrollPane2.getViewport().add(scriptPane, null);\n\n        jScrollPane1.setColumnHeaderView(new JLabel(\" Token Stream:\"));\n        jScrollPane2.setColumnHeaderView(new JLabel(\" Input Script:\"));\n        jSplitPane1.setResizeWeight(0.5);\n    }","commit_id":"571e8eea4472b7b20b0ef80fed3af35a22eb7b91","url":"https://github.com/apache/groovy"},{"original_method":"private void scanScript(File file) throws Exception{\n        scriptPane.read(new FileReader(file), null);\n\n        // create lexer\n        Constructor constructor = lexerClass.getConstructor(new Class[]{InputStream.class});\n        CharScanner lexer = (CharScanner) constructor.newInstance(new Object[]{new FileInputStream(file)});\n\n        tokenPane.setEditable(true);\n        tokenPane.setText(\"\");\n\n        int line = 1;\n        ButtonGroup bg = new ButtonGroup();\n        Token token = null;\n\n        while(true){\n            token = lexer.nextToken();\n            JToggleButton tokenButton = new JToggleButton((String) tokens.get(Integer.valueOf(token.getType())));\n            bg.add(tokenButton);\n            tokenButton.addActionListener(this);\n            tokenButton.setToolTipText(token.getText());\n            tokenButton.putClientProperty(\"token\", token);\n            tokenButton.setMargin(new Insets(0, 1, 0, 1));\n            tokenButton.setFocusPainted(false);\n            if(token.getLine()>line){\n                tokenPane.getDocument().insertString(tokenPane.getDocument().getLength(), \"\\n\", null);\n                line = token.getLine();\n            }\n            insertComponent(tokenButton);\n            if(token.getType()==Token.EOF_TYPE)\n                break;\n        }\n\n        tokenPane.setEditable(false);\n        tokenPane.setCaretPosition(0);\n    }","id":78422,"modified_method":"private void scanScript(final File file) throws Exception {\n        scriptPane.read(new FileReader(file), null);\n\n        // create lexer\n        final Constructor constructor = lexerClass.getConstructor(InputStream.class);\n        final FileInputStream fileInputStream = new FileInputStream(file);\n        final CharScanner lexer = (CharScanner) constructor.newInstance(fileInputStream);\n\n        tokenPane.setEditable(true);\n        tokenPane.setText(\"\");\n\n        int line = 1;\n        final ButtonGroup bg = new ButtonGroup();\n        Token token;\n\n        while (true) {\n            token = lexer.nextToken();\n            JToggleButton tokenButton = new JToggleButton((String) tokens.get(Integer.valueOf(token.getType())));\n            bg.add(tokenButton);\n            tokenButton.addActionListener(this);\n            tokenButton.setToolTipText(token.getText());\n            tokenButton.putClientProperty(\"token\", token);\n            tokenButton.setMargin(new Insets(0, 1, 0, 1));\n            tokenButton.setFocusPainted(false);\n            if (token.getLine() > line) {\n                tokenPane.getDocument().insertString(tokenPane.getDocument().getLength(), \"\\n\", null);\n                line = token.getLine();\n            }\n            insertComponent(tokenButton);\n            if (token.getType() == Token.EOF_TYPE){\n                break;\n            }\n        }\n\n        tokenPane.setEditable(false);\n        tokenPane.setCaretPosition(0);\n        fileInputStream.close();\n    }","commit_id":"571e8eea4472b7b20b0ef80fed3af35a22eb7b91","url":"https://github.com/apache/groovy"},{"original_method":"public LexerFrame(Class lexerClass, Class tokenTypesClass){\n        super(\"Token Steam Viewer\");\n        this.lexerClass = lexerClass;\n        try{\n            jbInit();\n            setSize(500, 500);\n            listTokens(tokenTypesClass);\n\n            final JPopupMenu popup = new JPopupMenu();\n            popup.add(loadFileAction);\n\n            jbutton.setSize(30,30);\n            jbutton.addMouseListener(new MouseAdapter(){\n                public void mouseReleased(MouseEvent e) {\n                    //if(e.isPopupTrigger())\n                        popup.show(scriptPane, e.getX(), e.getY());\n                }\n            });\n            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        } catch(Exception e){\n            e.printStackTrace();\n        }\n    }","id":78423,"modified_method":"public LexerFrame(Class lexerClass, Class tokenTypesClass) {\n        super(\"Token Steam Viewer\");\n        this.lexerClass = lexerClass;\n        try {\n            jbInit();\n            setSize(500, 500);\n            listTokens(tokenTypesClass);\n\n            final JPopupMenu popup = new JPopupMenu();\n            popup.add(loadFileAction);\n\n            jbutton.setSize(30, 30);\n            jbutton.addMouseListener(new MouseAdapter() {\n                public void mouseReleased(MouseEvent e) {\n                    //if(e.isPopupTrigger())\n                    popup.show(scriptPane, e.getX(), e.getY());\n                }\n            });\n            setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }","commit_id":"571e8eea4472b7b20b0ef80fed3af35a22eb7b91","url":"https://github.com/apache/groovy"},{"original_method":"private void listTokens(Class tokenTypes) throws Exception{\n        Field field[] = tokenTypes.getDeclaredFields();\n        for(int i = 0; i<field.length; i++)\n            tokens.put(field[i].get(null), field[i].getName());\n    }","id":78424,"modified_method":"private void listTokens(Class tokenTypes) throws Exception {\n        for (Field field : tokenTypes.getDeclaredFields()) {\n            tokens.put(field.get(null), field.getName());\n        }\n    }","commit_id":"571e8eea4472b7b20b0ef80fed3af35a22eb7b91","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public Boolean isHolder(Class<?> cls, Type type) {\n        if (cls.getSimpleName().equals(\"Holder\")\n            && cls.getDeclaredFields().length == 1\n            && \"value\".equals(cls.getDeclaredFields()[0].getName())\n            && Modifier.isPublic(cls.getDeclaredFields()[0].getModifiers())) {\n            return Boolean.TRUE;\n        }\n        return Boolean.FALSE;\n    }","id":78425,"modified_method":"@Override\n    public Boolean isHolder(Class<?> cls, Type type) {\n        if (cls.getSimpleName().equals(\"Holder\")) {\n            for (Field f : cls.getDeclaredFields()) {\n                if (Modifier.isStatic(f.getModifiers())) { \n                    continue;\n                }\n                if (Modifier.isPublic(f.getModifiers())\n                    && \"value\".equals(f.getName())) {\n                    return Boolean.TRUE;\n                }\n            }\n            return Boolean.TRUE;\n        }\n        return Boolean.FALSE;\n    }","commit_id":"e1d397a0f0ef052834607d64dede97b8bfb7f159","url":"https://github.com/apache/cxf"},{"original_method":"public FramesBase fillInto( FramesHandler h ) {\n        throw H2O.fail();\n    }","id":78426,"modified_method":"public FramesBase fillInto( FramesHandler h ) {\n    h.key = this.key;\n\n    if (null != frames) {\n      h.frames = new Frame[frames.length];\n\n      int i = 0;\n      for (FrameV1 frame : this.frames) {\n        h.frames[i++] = frame._fr;\n      }\n    }\n    return this;\n  }","commit_id":"c0c924e06eda8127a1904d18ab891b95b84a2d65","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public FramesBase fillFrom( FramesHandler h ) {\n        return this;\n    }","id":78427,"modified_method":"public FramesBase fillFrom( FramesHandler h ) {\n    this.key = h.key;\n\n    if (null != h.frames) {\n      this.frames = new FrameV1[h.frames.length];\n\n      int i = 0;\n      for (Frame frame : h.frames) {\n        this.frames[i++] = new FrameV1(frame);\n      }\n    }\n    return this;\n  }","commit_id":"c0c924e06eda8127a1904d18ab891b95b84a2d65","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override protected FramesBase schema(int version) {\n    switch (version) {\n    case 3:\n      return new FramesV3();\n    default:\n      throw H2O.fail(\"Bad version for Frames schema: \" + version);\n    }\n  }","id":78428,"modified_method":"@Override protected FramesBase schema(int version) {\n    switch (version) {\n    case 2:\n      return new FramesV2();\n    default:\n      throw H2O.fail(\"Bad version for Frames schema: \" + version);\n    }\n  }","commit_id":"c0c924e06eda8127a1904d18ab891b95b84a2d65","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private static String register(String method, String url, Class hclass, String hmeth) {\n    try {\n      assert lookup(method,url)==null; // Not shadowed\n      Method meth = hclass.getDeclaredMethod(hmeth);\n      _handlers.put(method+url,meth);\n      return url;\n    } catch( NoSuchMethodException nsme ) {\n      throw new Error(\"NoSuchMethodException: \"+hclass.getName()+\".\"+hmeth);\n    }\n  }","id":78429,"modified_method":"private static String register(String method, String url, Class hclass, String hmeth) {\n    try {\n      assert lookup(method,url)==null; // Not shadowed\n      Method meth = hclass.getDeclaredMethod(hmeth);\n      _handlers.put(Pattern.compile(method + url), meth);\n      return url;\n    } catch( NoSuchMethodException nsme ) {\n      throw new Error(\"NoSuchMethodException: \"+hclass.getName()+\".\"+hmeth);\n    }\n  }","commit_id":"c0c924e06eda8127a1904d18ab891b95b84a2d65","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public static String[] frameChoices( int version, Frame fr ) {\n    ArrayList<String> al = new ArrayList<>();\n    for( String x : _handlers.keySet() ) {\n      try {\n        Method meth = _handlers.get(x);\n        Class clz0 = meth.getDeclaringClass();\n        Class<Handler> clz = (Class<Handler>)clz0;\n        Handler h = clz.newInstance();\n        String url = h.schema(version).acceptsFrame(fr);\n        if( url != null ) al.add(url);\n      }\n      catch( InstantiationException | IllegalArgumentException | IllegalAccessException ignore ) { }\n    }\n    return al.toArray(new String[al.size()]);\n  }","id":78430,"modified_method":"public static String[] frameChoices( int version, Frame fr ) {\n    ArrayList<String> al = new ArrayList<>();\n    for( Pattern p : _handlers.keySet() ) {\n      try {\n        Method meth = _handlers.get(p);\n        Class clz0 = meth.getDeclaringClass();\n        Class<Handler> clz = (Class<Handler>)clz0;\n        Handler h = clz.newInstance();\n        String url = h.schema(version).acceptsFrame(fr);\n        if( url != null ) al.add(url);\n      }\n      catch( InstantiationException | IllegalArgumentException | IllegalAccessException ignore ) { }\n    }\n    return al.toArray(new String[al.size()]);\n  }","commit_id":"c0c924e06eda8127a1904d18ab891b95b84a2d65","url":"https://github.com/h2oai/h2o-3"},{"original_method":"@Override public Response serve( String uri, String method, Properties header, Properties parms ) {\n    // Jack priority for user-visible requests\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY-1);\n\n    // determine version\n    int version = parseVersion(uri);\n    int idx = version>>16;\n    version &= 0xFFFF;\n    String uripath = uri.substring(idx);\n\n    // determine the request type\n    RequestType type = RequestType.requestType(uripath);\n    String path = type.requestName(uripath); // Strip suffix type from middle of URI\n\n    // Load resources, or dispatch on handled requests\n    maybeLogRequest(path, method, parms);\n    try {\n      // Find handler for url\n      Method meth = lookup(method,path);\n      // if the request is not known, treat as resource request, or 404 if not found\n      if( meth == null ) return getResource(uri);\n      // TODO: handlers should return an object that has the result as well as the needed http headers including status code\n      return wrap(HTTP_OK,handle(type,meth,version,parms),type);\n    } catch( IllegalArgumentException e ) {\n      return wrap(HTTP_BADREQUEST,new HTTP404V1(e.getMessage(),uri),type);\n    } catch( Exception e ) {\n      // make sure that no Exception is ever thrown out from the request\n      return wrap(\"unimplemented\".equals(e.getMessage())? HTTP_NOTIMPLEMENTED : HTTP_INTERNALERROR, new HTTP500V1(e),type);\n    }\n  }","id":78431,"modified_method":"@Override public Response serve( String uri, String method, Properties header, Properties parms ) {\n    // Jack priority for user-visible requests\n    Thread.currentThread().setPriority(Thread.MAX_PRIORITY-1);\n\n    // determine version\n    int version = parseVersion(uri);\n    int idx = version>>16;\n    version &= 0xFFFF;\n    String uripath = uri.substring(idx);\n\n    // determine the request type\n    RequestType type = RequestType.requestType(uripath);\n    String path = type.requestName(uripath); // Strip suffix type from middle of URI\n\n    // Load resources, or dispatch on handled requests\n    maybeLogRequest(path, method, parms);\n    try {\n      // Find handler for url\n      Method meth = lookup(method,path);\n      // if the request is not known, treat as resource request, or 404 if not found\n      if( meth == null )\n        return getResource(uri);\n      else\n        return wrap(HTTP_OK,handle(type,meth,version,parms),type);\n    } catch( IllegalArgumentException e ) {\n      return wrap(HTTP_BADREQUEST,new HTTP404V1(e.getMessage(),uri),type);\n    } catch( Exception e ) {\n      // make sure that no Exception is ever thrown out from the request\n      return wrap(\"unimplemented\".equals(e.getMessage())? HTTP_NOTIMPLEMENTED : HTTP_INTERNALERROR, new HTTP500V1(e),type);\n    }\n  }","commit_id":"c0c924e06eda8127a1904d18ab891b95b84a2d65","url":"https://github.com/h2oai/h2o-3"},{"original_method":"private static Method lookup( String method, String url ) {\n    String s = method+url;\n    for( String x : _handlers.keySet() )\n      if( x.equals(s) )         // TODO: regex\n        return _handlers.get(x);\n    return null;\n  }","id":78432,"modified_method":"private static Method lookup( String method, String url ) {\n    String s = method+url;\n    for( Pattern p : _handlers.keySet() )\n      if (p.matcher(s).matches())\n        return _handlers.get(p);\n    return null;\n  }","commit_id":"c0c924e06eda8127a1904d18ab891b95b84a2d65","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public S fillFrom( Properties parms ) {\n    // Get passed-in fields, assign into Schema\n    Class clz = getClass();\n    for( String key : parms.stringPropertyNames() ) {\n      try {\n        Field f = clz.getDeclaredField(key); // No such field error, if parm is junk\n        int mods = f.getModifiers();\n        if( Modifier.isTransient(mods) || Modifier.isStatic(mods) )\n          // Attempting to set a transient or static; treat same as junk fieldname\n          throw new IllegalArgumentException(\"Unknown argument \"+key);\n        // Only support a single annotation which is an API, and is required\n        API api = (API)f.getAnnotations()[0]; \n        // Must have one of these set to be an input field\n        if( api.validation().length()==0 && \n            api.values    ().length()==0 && \n            api.dependsOn ().length  ==0 ) \n          throw new IllegalArgumentException(\"Attempting to set output field \"+key);\n\n        // Primitive parse by field type\n        f.set(this,parse(parms.getProperty(key),f.getType()));\n        \n      } catch( NoSuchFieldException nsfe ) { // Convert missing-field to IAE\n        throw new IllegalArgumentException(\"Unknown argument \"+key);\n      } catch( ArrayIndexOutOfBoundsException aioobe ) {\n        // Come here if missing annotation\n        throw new RuntimeException(\"Broken internal schema; missing API annotation: \"+key);\n      } catch( IllegalAccessException iae ) {\n        // Come here if field is final or private\n        throw new RuntimeException(\"Broken internal schema; cannot be private nor final: \"+key);\n      }\n    }\n    // Here every thing in 'parms' was set into some field - so we have already\n    // checked for unknown or extra parms.\n\n    // Confirm required fields are set\n    do {\n      for( Field f : clz.getDeclaredFields() ) {\n        int mods = f.getModifiers();\n        if( Modifier.isTransient(mods) || Modifier.isStatic(mods) )\n          continue;             // Ignore transient & static\n        API api = (API)f.getAnnotations()[0]; \n        if( api.validation().length() > 0 ) {\n          // TODO: execute \"validation language\" in the BackEnd, which includes a \"required check\", if any\n          if( parms.getProperty(f.getName()) == null )\n            throw new IllegalArgumentException(\"Required field \"+f.getName()+\" not specified\");\n        }      \n      }\n      clz = clz.getSuperclass();\n    } while( Iced.class.isAssignableFrom(clz.getSuperclass()) );\n    return (S)this;\n  }","id":78433,"modified_method":"public S fillFrom( Properties parms ) {\n    // Get passed-in fields, assign into Schema\n\n    Map<String, Field> fields = new HashMap<>();\n    try {\n      Class clz = getClass();\n      do {\n        Field[] some_fields = clz.getDeclaredFields();\n\n        for (Field f : some_fields)\n          if (null == fields.get(f.getName()))\n            fields.put(f.getName(), f);\n\n        clz = clz.getSuperclass();\n      } while (Iced.class.isAssignableFrom(clz.getSuperclass()));\n    }\n    catch (SecurityException e) {\n        throw new RuntimeException(\"Exception accessing fields: \" + e);\n    }\n\n    for( String key : parms.stringPropertyNames() ) {\n      try {\n        Field f = fields.get(key); // No such field error, if parm is junk\n\n        if (null == f)\n          throw new IllegalArgumentException(\"Unknown argument: \" + key);\n\n        int mods = f.getModifiers();\n        if( Modifier.isTransient(mods) || Modifier.isStatic(mods) )\n          // Attempting to set a transient or static; treat same as junk fieldname\n          throw new IllegalArgumentException(\"Unknown argument \"+key);\n        // Only support a single annotation which is an API, and is required\n        API api = (API)f.getAnnotations()[0];\n        // Must have one of these set to be an input field\n        if( api.direction() == API.Direction.OUTPUT )\n          throw new IllegalArgumentException(\"Attempting to set output field \"+key);\n\n        // Primitive parse by field type\n        f.set(this,parse(parms.getProperty(key),f.getType()));\n\n      } catch( ArrayIndexOutOfBoundsException aioobe ) {\n        // Come here if missing annotation\n        throw new RuntimeException(\"Broken internal schema; missing API annotation: \"+key);\n      } catch( IllegalAccessException iae ) {\n        // Come here if field is final or private\n        throw new RuntimeException(\"Broken internal schema; cannot be private nor final: \"+key);\n      }\n    }\n    // Here every thing in 'parms' was set into some field - so we have already\n    // checked for unknown or extra parms.\n\n    // Confirm required fields are set\n    for( Field f : fields.values() ) {\n      int mods = f.getModifiers();\n      if( Modifier.isTransient(mods) || Modifier.isStatic(mods) )\n        continue;             // Ignore transient & static\n      API api = (API)f.getAnnotations()[0];\n      if( api.required() ) {\n        if( parms.getProperty(f.getName()) == null )\n          throw new IllegalArgumentException(\"Required field \"+f.getName()+\" not specified\");\n      }\n      // TODO: execute \"validation language\" in the BackEnd, which includes a \"required check\", if any\n    }\n    return (S)this;\n  }","commit_id":"c0c924e06eda8127a1904d18ab891b95b84a2d65","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public List<Command> getCommands() {\n    return commands;\n  }","id":78434,"modified_method":"public Command getCommand() {\n    return command;\n  }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"public List<Command> getCleanUpCommands() {\n    return cleanUpCommands;\n  }","id":78435,"modified_method":"public Command getCleanUpCommand() {\n    return cleanUpCommand;\n  }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"public void setCleanUpCommands(List<Command> cleanUpCommands) {\n    this.cleanUpCommands = cleanUpCommands;  \n  }","id":78436,"modified_method":"public void setCleanUpCommand(Command cleanUpCommand) {\n    this.cleanUpCommand = cleanUpCommand;  \n  }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"public ServerStatus getServerStatus() {\n    return serverStatus;\n  }","id":78437,"modified_method":"public State getServerStatus() {\n    return serverStatus;\n  }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"public void setServerStatus(ServerStatus serverStatus) {\n    this.serverStatus = serverStatus;\n  }","id":78438,"modified_method":"public void setServerStatus(State serverStatus) {\n    this.serverStatus = serverStatus;\n  }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"public ClusterDefinition updateCluster(String clusterName, ClusterDefinition c) throws Exception {\n        \n        /*\n         * Validate cluster definition\n         */\n        if (c.getName() == null || c.getName().equals(\"\") || !c.getName().equals(clusterName)) {\n            String msg = \"Cluster name in resource URI [\"+clusterName+\"] does not match with one specified in update request element\";\n            throw new WebApplicationException((new ExceptionResponse(msg, Response.Status.BAD_REQUEST)).get());\n        }\n        \n        /*\n         * Check if cluster already exists. \n         * TODO: If PUT is idempotent, then should following check is valid?  \n         */\n        if (!this.operational_clusters.containsKey(clusterName)) {\n            String msg = \"Cluster [\"+clusterName+\"] does not exits\";\n            throw new WebApplicationException((new ExceptionResponse(msg, Response.Status.NOT_FOUND)).get());\n        }\n        \n        Cluster cls = this.operational_clusters.get(clusterName);\n        /*\n         * Time being we will keep entire updated copy as new revision\n         */\n        ClusterDefinition newcd = new ClusterDefinition ();\n        \n        synchronized (cls.getClusterDefinitionRevisionsList()) {\n            if (c.getBlueprintName() != null) {\n                newcd.setBlueprintName(c.getBlueprintName());\n            } else {\n                newcd.setBlueprintName(cls.getLatestClusterDefinition().getBlueprintName());\n            }\n            if (c.getBlueprintRevision() != null) {\n                newcd.setBlueprintRevision(c.getBlueprintRevision());\n            } else {\n                newcd.setBlueprintRevision(cls.getLatestClusterDefinition().getBlueprintRevision());\n            }\n            if (c.getDescription() != null) {\n                newcd.setDescription(c.getDescription());\n            } else {\n                newcd.setDescription(cls.getLatestClusterDefinition().getDescription());\n            }\n            if (c.getGoalState() != null) {\n                newcd.setGoalState(c.getGoalState());\n            } else {\n                newcd.setGoalState(cls.getLatestClusterDefinition().getGoalState());\n            }\n            if (c.getActiveServices() != null) {\n                newcd.setActiveServices(c.getActiveServices());\n            } else {\n                newcd.setActiveServices(cls.getLatestClusterDefinition().getActiveServices());\n            }\n            \n            /*\n             * TODO: What if controller is crashed after updateClusterNodesReservation \n             * before updating and adding new revision of cluster definition?\n             */\n            if (c.getNodes() != null) {\n                newcd.setNodes(c.getNodes());\n                updateClusterNodesReservation (cls.getID(), c);\n            } else {\n                newcd.setNodes(cls.getLatestClusterDefinition().getNodes());\n            }\n            if (c.getRoleToNodes() != null) {\n                newcd.setRoleToNodesMap(c.getRoleToNodes());\n                updateNodeToRolesAssociation(newcd.getNodes(), c.getRoleToNodes());\n            }  \n            \n            /*\n             *  Update the last update time & revision\n             */\n            cls.getClusterState().setLastUpdateTime(new Date());\n            cls.addClusterDefinition(newcd);\n            \n            /*\n             * TODO: Persist the latest cluster definition under new revision\n             */\n            \n        }\n        return cls.getLatestClusterDefinition();\n    }","id":78439,"modified_method":"public ClusterDefinition updateCluster(String clusterName, ClusterDefinition c) throws Exception {\n        \n        /*\n         * Validate cluster definition\n         */\n        if (c.getName() == null || c.getName().equals(\"\") || !c.getName().equals(clusterName)) {\n            String msg = \"Cluster name in resource URI [\"+clusterName+\"] does not match with one specified in update request element\";\n            throw new WebApplicationException((new ExceptionResponse(msg, Response.Status.BAD_REQUEST)).get());\n        }\n        \n        /*\n         * Check if cluster already exists. \n         * TODO: If PUT is idempotent, then should following check is valid?  \n         */\n        if (!this.operational_clusters.containsKey(clusterName)) {\n            String msg = \"Cluster [\"+clusterName+\"] does not exits\";\n            throw new WebApplicationException((new ExceptionResponse(msg, Response.Status.NOT_FOUND)).get());\n        }\n        \n        Cluster cls = this.operational_clusters.get(clusterName);\n        /*\n         * Time being we will keep entire updated copy as new revision\n         */\n        ClusterDefinition newcd = new ClusterDefinition ();\n        \n        synchronized (cls.getClusterDefinitionRevisionsList()) {\n            if (c.getBlueprintName() != null) {\n                newcd.setBlueprintName(c.getBlueprintName());\n            } else {\n                newcd.setBlueprintName(cls.getLatestClusterDefinition().getBlueprintName());\n            }\n            if (c.getBlueprintRevision() != null) {\n                newcd.setBlueprintRevision(c.getBlueprintRevision());\n            } else {\n                newcd.setBlueprintRevision(cls.getLatestClusterDefinition().getBlueprintRevision());\n            }\n            if (c.getDescription() != null) {\n                newcd.setDescription(c.getDescription());\n            } else {\n                newcd.setDescription(cls.getLatestClusterDefinition().getDescription());\n            }\n            if (c.getGoalState() != null) {\n                newcd.setGoalState(c.getGoalState());\n            } else {\n                newcd.setGoalState(cls.getLatestClusterDefinition().getGoalState());\n            }\n            if (c.getActiveServices() != null) {\n                newcd.setActiveServices(c.getActiveServices());\n            } else {\n                newcd.setActiveServices(cls.getLatestClusterDefinition().getActiveServices());\n            }\n            \n            /*\n             * TODO: What if controller is crashed after updateClusterNodesReservation \n             * before updating and adding new revision of cluster definition?\n             */\n            if (c.getNodes() != null) {\n                newcd.setNodes(c.getNodes());\n                updateClusterNodesReservation (cls.getID(), c);\n            } else {\n                newcd.setNodes(cls.getLatestClusterDefinition().getNodes());\n            }\n            if (c.getRoleToNodes() != null) {\n                newcd.setRoleToNodesMap(c.getRoleToNodes());\n                updateNodeToRolesAssociation(newcd.getNodes(), c.getRoleToNodes());\n            }  \n            \n            /*\n             *  Update the last update time & revision\n             */\n            cls.getClusterState().setLastUpdateTime(new Date());\n            cls.addClusterDefinition(newcd);\n            \n            /*\n             * TODO: Persist the latest cluster definition under new revision\n             */\n            ClusterFSM clusterFSM = StateMachineInvoker.\n                getStateMachineClusterInstance(cls.getID(), \n                    c.getBlueprintName(), c.getBlueprintRevision());\n            if(c.getGoalState().equals(ClusterState.CLUSTER_STATE_ACTIVE)) {\n              clusterFSM.activate();\n            } else if(c.getGoalState().\n                equals(ClusterState.CLUSTER_STATE_INACTIVE)) {\n              clusterFSM.deactivate();\n            } else if(c.getGoalState().\n                equals(ClusterState.CLUSTER_STATE_ATTIC)) {\n              clusterFSM.deactivate();\n              clusterFSM.terminate();\n            }\n        }\n        return cls.getLatestClusterDefinition();\n    }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"public Command(String user, String[] cmd) {\n    this.cmd = cmd;\n    this.user = user;\n  }","id":78440,"modified_method":"public Command(String user, String cmd, String[] param) {\n    this.cmd = cmd;\n    this.user = user;\n    this.param = param;\n  }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"public void setCmd(String[] cmd) {\n    this.cmd = cmd;\n  }","id":78441,"modified_method":"public void setCmd(String cmd) {\n    this.cmd = cmd;\n  }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Sample controller to agent response message\n   * \n   * @response.representation.200.example { \"a\" : \"b\" }\n   * @response.representation.200.doc Print an example of Controller Response to Agent\n   * @response.representation.200.mediaType application/json\n   * @return ControllerResponse A list of command to execute on agent\n   */\n  @Path(\"response/sample\")\n  @GET\n  @Produces(\"application/json\")\n  public ControllerResponse getControllerResponse() {\n    ControllerResponse controllerResponse = new ControllerResponse();\n    controllerResponse.setResponseId(\"id-00002\");    \n    List<Command> commands = new ArrayList<Command>();\n    String[] cmd = { \"top\" };\n    commands.add(new Command(\"root\", cmd));\n\n    List<Command> cleanUps = new ArrayList<Command>();\n    String[] cleanUpCmd = { \"ls\", \"-t\" };\n    cleanUps.add(new Command(\"hdfs\", cleanUpCmd));\n    cleanUps.add(new Command(\"hdfs\", cleanUpCmd));\n    \n    Action action = new Action();\n    action.setBluePrintName(\"blueprint\");\n    action.setBluePrintRevision(\"0.1\");\n    action.setUser(\"hdfs\");\n    action.setComponent(\"hdfs\");\n    action.setRole(\"datanode\");\n    action.setKind(Kind.STOP_ACTION);\n    action.setSignal(Signal.KILL);\n    action.setClusterId(\"cluster-001\");\n    action.setId(\"action-001\");\n\n    Action action2 = new Action();\n    action2.setBluePrintName(\"blueprint\");\n    action2.setBluePrintRevision(\"0.1\");\n    action2.setUser(\"hdfs\");\n    action2.setKind(Kind.START_ACTION);\n    action2.setId(\"action-002\");\n    action2.setClusterId(\"cluster-002\");\n    action2.setCommands(commands);\n    action2.setCleanUpCommands(cleanUps);\n    action2.setComponent(\"hdfs\");\n    action2.setRole(\"datanode\");\n    \n    Action action3 = new Action();\n    action3.setBluePrintName(\"blueprint\");\n    action3.setBluePrintRevision(\"0.1\");\n    action3.setUser(\"hdfs\");\n    action3.setKind(Kind.RUN_ACTION);\n    action3.setId(\"action-003\");\n    action3.setClusterId(\"cluster-002\");\n    List<Command> configFiles = new ArrayList<Command>();\n    String[] writeFile = { \n        \"ambari-write-file\",\n        \"hdfs\",\n        \"hadoop\",\n        \"0700\",\n        \"/tmp/test\",\n        \"content of file\"\n        };\n    configFiles.add(new Command(\"hdfs\", writeFile));\n    action3.setCommands(configFiles);\n    List<Action> actions = new ArrayList<Action>();\n    actions.add(action);\n    actions.add(action2);\n    actions.add(action3);\n    controllerResponse.setActions(actions);\n    return controllerResponse;\n  }","id":78442,"modified_method":"/**\n   * Sample controller to agent response message\n   * \n   * @response.representation.200.example { \"a\" : \"b\" }\n   * @response.representation.200.doc Print an example of Controller Response to Agent\n   * @response.representation.200.mediaType application/json\n   * @return ControllerResponse A list of command to execute on agent\n   */\n  @Path(\"response/sample\")\n  @GET\n  @Produces(\"application/json\")\n  public ControllerResponse getControllerResponse() {\n    ControllerResponse controllerResponse = new ControllerResponse();\n    controllerResponse.setResponseId(\"id-00002\");    \n    \n    String cmd = \"import os\\nos._exit(0)\";\n    String[] param = { \"cluster\", \"role\" };\n\n    Command command = new Command(\"root\", cmd, param);\n    Command cleanUp = new Command(\"root\", cmd, param);\n    \n    Action action = new Action();\n    action.setKind(Kind.CREATE_STRUCTURE_ACTION);\n    action.setComponent(\"hdfs\");\n    action.setRole(\"datanode\");\n    \n    Action action1 = new Action();\n    action1.setBluePrintName(\"blueprint\");\n    action1.setBluePrintRevision(\"0.1\");\n    action1.setUser(\"hdfs\");\n    action1.setComponent(\"hdfs\");\n    action1.setRole(\"datanode\");\n    action1.setKind(Kind.STOP_ACTION);\n    action1.setSignal(Signal.KILL);\n    action1.setClusterId(\"cluster-001\");\n    action1.setId(\"action-001\");\n\n    Action action2 = new Action();\n    action2.setBluePrintName(\"blueprint\");\n    action2.setBluePrintRevision(\"0.1\");\n    action2.setUser(\"hdfs\");\n    action2.setKind(Kind.START_ACTION);\n    action2.setId(\"action-002\");\n    action2.setClusterId(\"cluster-002\");\n    action2.setCommand(command);\n    action2.setCleanUpCommand(cleanUp);\n    action2.setComponent(\"hdfs\");\n    action2.setRole(\"datanode\");\n    \n    Action action3 = new Action();\n    action3.setBluePrintName(\"blueprint\");\n    action3.setBluePrintRevision(\"0.1\");\n    action3.setUser(\"hdfs\");\n    action3.setKind(Kind.RUN_ACTION);\n    action3.setId(\"action-003\");\n    action3.setClusterId(\"cluster-002\");\n    action3.setCommand(command);\n    action3.setCleanUpCommand(cleanUp);\n    \n    Action action4 = new Action();\n    action4.setKind(Kind.DELETE_STRUCTURE_ACTION);\n    action4.setComponent(\"hdfs\");\n    action4.setRole(\"datanode\");\n    \n    List<Action> actions = new ArrayList<Action>();\n    actions.add(action);\n    actions.add(action1);\n    actions.add(action2);\n    actions.add(action3);\n    actions.add(action4);\n    controllerResponse.setActions(actions);\n    return controllerResponse;\n  }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"/** \n   * Update state of the node (Internal API to be used by Ambari agent).\n   *  \n   * @response.representation.200.doc This API is invoked by Ambari agent running\n   *  on a cluster to update the state of various services running on the node.\n   * @response.representation.200.mediaType application/json\n   * @response.representation.500.doc Error in accepting heartbeat message\n   * @param message Heartbeat message\n   */\n  @Path(\"heartbeat/{hostname}\")\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})\n  public ControllerResponse heartbeat(HeartBeat message) {\n    ControllerResponse controllerResponse = new ControllerResponse();\n    controllerResponse.setResponseId(\"id-00002\");    \n    List<Command> commands = new ArrayList<Command>();\n    String[] cmd = { \"ls\", \"-l\" };\n    commands.add(new Command(\"root\", cmd));\n    commands.add(new Command(\"root\", cmd));\n    commands.add(new Command(\"root\", cmd));\n\n    List<Command> cleanUps = new ArrayList<Command>();\n    String[] cleanUpCmd = { \"ls\", \"-t\" };\n    cleanUps.add(new Command(\"hdfs\", cleanUpCmd));\n    cleanUps.add(new Command(\"hdfs\", cleanUpCmd));\n    \n    Action action = new Action();\n    action.setUser(\"hdfs\");\n    action.setComponent(\"hdfs\");\n    action.setRole(\"datanode\");\n    action.setKind(Kind.STOP_ACTION);\n    action.setSignal(Signal.KILL);\n    action.setClusterId(\"cluster-001\");\n    action.setBluePrintName(\"blueprint\");\n    action.setBluePrintRevision(\"0.1\");\n    action.setId(\"action-001\");\n\n    Action action2 = new Action();\n    action2.setUser(\"hdfs\");\n    action2.setKind(Kind.START_ACTION);\n    action2.setId(\"action-002\");\n    action2.setClusterId(\"cluster-002\");\n    action2.setCommands(commands);\n    action2.setCleanUpCommands(cleanUps);\n    action2.setComponent(\"hdfs\");\n    action2.setBluePrintName(\"blueprint\");\n    action2.setBluePrintRevision(\"0.2\");\n    action2.setRole(\"datanode\");\n\n    Action action3 = new Action();\n    action3.setUser(\"hdfs\");\n    action3.setKind(Kind.RUN_ACTION);\n    action3.setId(\"action-003\");\n    action3.setBluePrintName(\"blueprint\");\n    action3.setBluePrintRevision(\"0.2\");\n    action3.setClusterId(\"cluster-003\");\n    action3.setCommands(commands);\n    action3.setCleanUpCommands(cleanUps);\n\n    List<Action> actions = new ArrayList<Action>();\n    actions.add(action);\n    actions.add(action2);\n    actions.add(action3);\n    controllerResponse.setActions(actions);\n    return controllerResponse;\n  }","id":78443,"modified_method":"/** \n   * Update state of the node (Internal API to be used by Ambari agent).\n   *  \n   * @response.representation.200.doc This API is invoked by Ambari agent running\n   *  on a cluster to update the state of various services running on the node.\n   * @response.representation.200.mediaType application/json\n   * @response.representation.200.example { \"a\" : \"b\" }\n   * @response.representation.500.doc Error in accepting heartbeat message\n   * @param message Heartbeat message\n   */\n  @Path(\"heartbeat/{hostname}\")\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})\n  public ControllerResponse heartbeat(HeartBeat message) {\n    ControllerResponse controllerResponse = new ControllerResponse();\n    controllerResponse.setResponseId(\"id-00002\");    \n    String cmd = \"import os\\nos._exit(0)\";\n    String[] param = { \"cluster\", \"role\" };\n    Command command = new Command(\"root\", cmd, param);\n\n    Command cleanUp = new Command(\"root\", cmd, param);\n    \n    Action action = new Action();\n    action.setUser(\"hdfs\");\n    action.setComponent(\"hdfs\");\n    action.setRole(\"datanode\");\n    action.setKind(Kind.STOP_ACTION);\n    action.setSignal(Signal.KILL);\n    action.setClusterId(\"cluster-001\");\n    action.setBluePrintName(\"blueprint\");\n    action.setBluePrintRevision(\"0.1\");\n    action.setId(\"action-001\");\n\n    Action action2 = new Action();\n    action2.setUser(\"hdfs\");\n    action2.setKind(Kind.START_ACTION);\n    action2.setId(\"action-002\");\n    action2.setClusterId(\"cluster-002\");\n    action2.setCommand(command);\n    action2.setCleanUpCommand(cleanUp);\n    action2.setComponent(\"hdfs\");\n    action2.setBluePrintName(\"blueprint\");\n    action2.setBluePrintRevision(\"0.2\");\n    action2.setRole(\"datanode\");\n\n    Action action3 = new Action();\n    action3.setUser(\"hdfs\");\n    action3.setKind(Kind.RUN_ACTION);\n    action3.setId(\"action-003\");\n    action3.setBluePrintName(\"blueprint\");\n    action3.setBluePrintRevision(\"0.2\");\n    action3.setClusterId(\"cluster-003\");\n    action3.setCommand(command);\n    action3.setCleanUpCommand(cleanUp);\n\n    List<Action> actions = new ArrayList<Action>();\n    actions.add(action);\n    actions.add(action2);\n    actions.add(action3);\n    controllerResponse.setActions(actions);\n    return controllerResponse;\n  }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"private static List<Action> getInstallAndUninstallActions(\n      HeartBeat heartbeat, ClusterFSM desiredClusterFSM, \n      ClusterContext context, StartedComponentServers componentServers)\n          throws IOException {\n    List<AgentRoleState> agentRoleStates = \n        heartbeat.getInstalledRoleStates();\n    List<Action> killAndUninstallCmds = new ArrayList<Action>();\n    //Go over all the reported role states, and stop/uninstall the\n    //unnecessary ones\n    for (AgentRoleState agentRoleState : agentRoleStates) {\n      boolean stopRole = false;\n      boolean uninstall = false;\n      \n      ClusterFSM clusterFSM = StateMachineInvoker\n          .getStateMachineClusterInstance(agentRoleState.getClusterId(), \n              agentRoleState.getBluePrintName(), \n              agentRoleState.getBluePrintRevision());\n      if (clusterFSM == null) {\n        //ask the agent to stop everything belonging to this role\n        //since the controller can't be in a state where the clusterFSM\n        //is null and the cluster is not in ATTIC or deleted state\n        stopRole = true;\n        uninstall = true;\n      }\n      if (clusterFSM != null) {\n        if (clusterFSM.getClusterState().getState()\n            .equals(ClusterState.CLUSTER_STATE_INACTIVE)) {\n          stopRole = true;\n          uninstall = false;\n        }\n        else if (clusterFSM.getClusterState().getState()\n            .equals(ClusterState.CLUSTER_STATE_ATTIC)) {\n          stopRole = true;\n          uninstall = true;\n        }\n      }\n      if (stopRole && \n        agentRoleState.getServerStatus().state == ServerStatus.State.STARTED) {\n        //TODO: not sure whether this requires to be done...\n        Action action = new Action();\n        action.setClusterId(agentRoleState.getClusterId());\n        action.setBluePrintName(agentRoleState.getBluePrintName());\n        action.setBluePrintRevision(agentRoleState.getBluePrintRevision());\n        action.setRole(agentRoleState.getRoleName());\n        action.setComponent(agentRoleState.getComponentName());\n        action.setKind(Kind.STOP_ACTION);\n        action.setSignal(Signal.KILL);\n        killAndUninstallCmds.add(action);\n      }\n      if (uninstall) {\n        //TODO: get reference to the plugin impl for this service/component\n        HDFSPluginImpl plugin = new HDFSPluginImpl();\n        List<Action> uninstallAction = plugin.uninstall(context);\n        killAndUninstallCmds.addAll(uninstallAction);\n      }\n      if (!stopRole && !uninstall) {\n        componentServers.roleServerStarted(agentRoleState.getComponentName(), \n              agentRoleState.getRoleName());\n      }\n    }\n    return killAndUninstallCmds;\n  }","id":78444,"modified_method":"private static List<Action> getInstallAndUninstallActions(\n      HeartBeat heartbeat, ClusterFSM desiredClusterFSM, \n      ClusterContext context, StartedComponentServers componentServers)\n          throws IOException {\n    List<AgentRoleState> agentRoleStates = \n        heartbeat.getInstalledRoleStates();\n    List<Action> killAndUninstallCmds = new ArrayList<Action>();\n    //Go over all the reported role states, and stop/uninstall the\n    //unnecessary ones\n    for (AgentRoleState agentRoleState : agentRoleStates) {\n      boolean stopRole = false;\n      boolean uninstall = false;\n      \n      ClusterFSM clusterFSM = StateMachineInvoker\n          .getStateMachineClusterInstance(agentRoleState.getClusterId(), \n              agentRoleState.getBluePrintName(), \n              agentRoleState.getBluePrintRevision());\n      if (clusterFSM == null) {\n        //ask the agent to stop everything belonging to this role\n        //since the controller can't be in a state where the clusterFSM\n        //is null and the cluster is not in ATTIC or deleted state\n        stopRole = true;\n        uninstall = true;\n      }\n      if (clusterFSM != null) {\n        if (clusterFSM.getClusterState().getState()\n            .equals(ClusterState.CLUSTER_STATE_INACTIVE)) {\n          stopRole = true;\n          uninstall = false;\n        }\n        else if (clusterFSM.getClusterState().getState()\n            .equals(ClusterState.CLUSTER_STATE_ATTIC)) {\n          stopRole = true;\n          uninstall = true;\n        }\n      }\n      if (stopRole && \n        agentRoleState.getServerStatus() == AgentRoleState.State.STARTED) {\n        //TODO: not sure whether this requires to be done...\n        Action action = new Action();\n        action.setClusterId(agentRoleState.getClusterId());\n        action.setBluePrintName(agentRoleState.getBluePrintName());\n        action.setBluePrintRevision(agentRoleState.getBluePrintRevision());\n        action.setRole(agentRoleState.getRoleName());\n        action.setComponent(agentRoleState.getComponentName());\n        action.setKind(Kind.STOP_ACTION);\n        action.setSignal(Signal.KILL);\n        killAndUninstallCmds.add(action);\n      }\n      if (uninstall) {\n        //TODO: get reference to the plugin impl for this service/component\n        HDFSPluginImpl plugin = new HDFSPluginImpl();\n        List<Action> uninstallAction = plugin.uninstall(context);\n        killAndUninstallCmds.addAll(uninstallAction);\n      }\n      if (!stopRole && !uninstall) {\n        componentServers.roleServerStarted(agentRoleState.getComponentName(), \n              agentRoleState.getRoleName());\n      }\n    }\n    return killAndUninstallCmds;\n  }","commit_id":"8ac818ad88c95661085feff1b276d99f339aeea8","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * User reflection to reset the private static member sLoginUser in LoginUser.\n   *\n   * @throws Exception thrown if the user fields cannot be set\n   */\n  @Before\n  public void before() throws Exception {\n    Field field = LoginUser.class.getDeclaredField(\"sLoginUser\");\n    field.setAccessible(true);\n    field.set(null, null);\n  }","id":78445,"modified_method":"/**\n   * User reflection to reset the private static member sLoginUser in LoginUser.\n   */\n  @Before\n  public void before() throws Exception {\n    Field field = LoginUser.class.getDeclaredField(\"sLoginUser\");\n    field.setAccessible(true);\n    field.set(null, null);\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test whether we can get login user with conf in CUSTOM mode, when user name is set to an\n   * empty string in the application configuration. In this case, login should return the OS user\n   * instead of empty string.\n   *\n   * @throws Exception thrown if the current user cannot be retrieved\n   */\n  @Test\n  public void getCustomLoginUserWhenNotProvidedByAppTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"CUSTOM\");\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), System.getProperty(\"user.name\"));\n  }","id":78446,"modified_method":"/**\n   * Test whether we can get login user with conf in CUSTOM mode, when user name is set to an\n   * empty string in the application configuration. In this case, login should return the OS user\n   * instead of empty string.\n   */\n  @Test\n  public void getCustomLoginUserWhenNotProvidedByAppTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"CUSTOM\");\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), System.getProperty(\"user.name\"));\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test whether we can get exception when getting a login user in non-security mode.\n   *\n   * @throws Exception thrown if the current user cannot be retrieved\n   */\n  @Test\n  public void securityEnabledTest() throws Exception {\n    // TODO(dong): add Kerberos in the white list when it is supported.\n    // throw exception when AuthType is not \"SIMPLE\", or \"CUSTOM\"\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"NOSASL\");\n\n    mThrown.expect(UnsupportedOperationException.class);\n    mThrown.expectMessage(\"User is not supported in NOSASL mode\");\n    LoginUser.get(conf);\n  }","id":78447,"modified_method":"/**\n   * Test whether we can get exception when getting a login user in non-security mode.\n   */\n  @Test\n  public void securityEnabledTest() throws Exception {\n    // TODO(dong): add Kerberos in the white list when it is supported.\n    // throw exception when AuthType is not \"SIMPLE\", or \"CUSTOM\"\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"NOSASL\");\n\n    mThrown.expect(UnsupportedOperationException.class);\n    mThrown.expectMessage(\"User is not supported in NOSASL mode\");\n    LoginUser.get(conf);\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test whether we can get login user with conf in SIMPLE mode, when a user list is provided by\n   * by the application through configuration.\n   *\n   * @throws Exception thrown if the current user cannot be retrieved\n   */\n  @Test\n  public void getSimpleLoginUserListProvidedByAppTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\");\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"tachyon-user, superuser\");\n\n    User loginUser = LoginUser.get(conf);\n\n    // The user list is considered as a single user name.\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), \"tachyon-user, superuser\");\n  }","id":78448,"modified_method":"/**\n   * Test whether we can get login user with conf in SIMPLE mode, when a user list is provided by\n   * by the application through configuration.\n   */\n  @Test\n  public void getSimpleLoginUserListProvidedByAppTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\");\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"tachyon-user, superuser\");\n\n    User loginUser = LoginUser.get(conf);\n\n    // The user list is considered as a single user name.\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), \"tachyon-user, superuser\");\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test whether we can get login user with conf in SIMPLE mode, when user name is provided by\n   * the application through configuration.\n   *\n   * @throws Exception thrown if the current user cannot be retrieved\n   */\n  @Test\n  public void getSimpleLoginUserProvidedByAppTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\");\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"tachyon-user\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), \"tachyon-user\");\n  }","id":78449,"modified_method":"/**\n   * Test whether we can get login user with conf in SIMPLE mode, when user name is provided by\n   * the application through configuration.\n   */\n  @Test\n  public void getSimpleLoginUserProvidedByAppTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\");\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"tachyon-user\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), \"tachyon-user\");\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test whether we can get login user with conf in CUSTOM mode.\n   *\n   * @throws Exception thrown if the current user cannot be retrieved\n   */\n  @Test\n  public void getCustomLoginUserTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"CUSTOM\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), System.getProperty(\"user.name\"));\n  }","id":78450,"modified_method":"/**\n   * Test whether we can get login user with conf in CUSTOM mode.\n   */\n  @Test\n  public void getCustomLoginUserTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"CUSTOM\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), System.getProperty(\"user.name\"));\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test whether we can get login user with conf in SIMPLE mode, when user name is set to an\n   * empty string in the application configuration. In this case, login should return the OS user\n   * instead of empty string.\n   *\n   * @throws Exception thrown if the current user cannot be retrieved\n   */\n  @Test\n  public void getSimpleLoginUserWhenNotProvidedByAppTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\");\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), System.getProperty(\"user.name\"));\n  }","id":78451,"modified_method":"/**\n   * Test whether we can get login user with conf in SIMPLE mode, when user name is set to an\n   * empty string in the application configuration. In this case, login should return the OS user\n   * instead of empty string.\n   */\n  @Test\n  public void getSimpleLoginUserWhenNotProvidedByAppTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\");\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), System.getProperty(\"user.name\"));\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test whether we can get login user with conf in CUSTOM mode, when user name is provided by\n   * the application through configuration.\n   *\n   * @throws Exception thrown if the current user cannot be retrieved\n   */\n  @Test\n  public void getCustomLoginUserProvidedByAppTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"CUSTOM\");\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"tachyon-user\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), \"tachyon-user\");\n  }","id":78452,"modified_method":"/**\n   * Test whether we can get login user with conf in CUSTOM mode, when user name is provided by\n   * the application through configuration.\n   */\n  @Test\n  public void getCustomLoginUserProvidedByAppTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"CUSTOM\");\n    conf.set(Constants.SECURITY_LOGIN_USERNAME, \"tachyon-user\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), \"tachyon-user\");\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Test whether we can get login user with conf in SIMPLE mode.\n   *\n   * @throws Exception thrown if the current user cannot be retrieved\n   */\n  @Test\n  public void getSimpleLoginUserTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), System.getProperty(\"user.name\"));\n  }","id":78453,"modified_method":"/**\n   * Test whether we can get login user with conf in SIMPLE mode.\n   */\n  @Test\n  public void getSimpleLoginUserTest() throws Exception {\n    TachyonConf conf = new TachyonConf();\n    conf.set(Constants.SECURITY_AUTHENTICATION_TYPE, \"SIMPLE\");\n\n    User loginUser = LoginUser.get(conf);\n\n    Assert.assertNotNull(loginUser);\n    Assert.assertEquals(loginUser.getName(), System.getProperty(\"user.name\"));\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * This test verifies whether the {@link tachyon.security.User} could be used in Java security\n   * framework.\n   */\n  @Test\n  public void usedInSecurityContextTest() {\n    // add new users into Subject\n    Subject subject = new Subject();\n    subject.getPrincipals().add(new User(\"realUser\"));\n    subject.getPrincipals().add(new User(\"proxyUser\"));\n\n    // fetch added users\n    User[] users = subject.getPrincipals(User.class).toArray(new User[0]);\n\n    // verification\n    Assert.assertEquals(2, users.length);\n    Assert.assertNotEquals(users[0], users[1]);\n  }","id":78454,"modified_method":"/**\n   * This test verifies whether the {@link tachyon.security.User} could be used in Java security\n   * framework.\n   */\n  @Test\n  public void usedInSecurityContextTest() {\n    // add new users into Subject\n    Subject subject = new Subject();\n    subject.getPrincipals().add(new User(\"realUser\"));\n    subject.getPrincipals().add(new User(\"proxyUser\"));\n\n    // fetch added users\n    Set<User> users = subject.getPrincipals(User.class);\n\n    // verification\n    Assert.assertEquals(2, users.size());\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * This test verifies that full realm names format is supported.\n   */\n  @Test\n  public void realmAsUserName() {\n    // Add new users into Subject.\n    Subject subject = new Subject();\n    subject.getPrincipals().add(new User(\"admin/admin@EXAMPLE.com\"));\n    subject.getPrincipals().add(new User(\"admin/mbox.example.com@EXAMPLE.com\"));\n    subject.getPrincipals().add(new User(\"imap/mbox.example.com@EXAMPLE.COM\"));\n\n    // Fetch added users.\n    User[] users = subject.getPrincipals(User.class).toArray(new User[0]);\n    Assert.assertEquals(3, users.length);\n    Assert.assertNotEquals(users[0], users[1]);\n    Assert.assertNotEquals(users[1], users[2]);\n\n    // Add similar user name without domain name.\n    subject.getPrincipals().add(new User(\"admin\"));\n    subject.getPrincipals().add(new User(\"imap\"));\n\n    users = subject.getPrincipals(User.class).toArray(new User[0]);\n    Assert.assertEquals(5, users.length);\n    Assert.assertNotEquals(users[0], users[3]);\n    Assert.assertNotEquals(users[2], users[4]);\n  }","id":78455,"modified_method":"/**\n   * This test verifies that full realm format is valid as User name.\n   */\n  @Test\n  public void realmAsUserName() {\n    // Add new users into Subject.\n    Subject subject = new Subject();\n    subject.getPrincipals().add(new User(\"admin/admin@EXAMPLE.com\"));\n    subject.getPrincipals().add(new User(\"admin/mbox.example.com@EXAMPLE.com\"));\n    subject.getPrincipals().add(new User(\"imap/mbox.example.com@EXAMPLE.COM\"));\n\n    // Fetch added users.\n    Set<User> users = subject.getPrincipals(User.class);\n    Assert.assertEquals(3, users.size());\n\n    // Add similar user name without domain name.\n    subject.getPrincipals().add(new User(\"admin\"));\n    subject.getPrincipals().add(new User(\"imap\"));\n\n    users = subject.getPrincipals(User.class);\n    Assert.assertEquals(5, users.size());\n  }","commit_id":"d76eee30936108be19a58a3729f560e27cf51ad9","url":"https://github.com/amplab/tachyon"},{"original_method":"public DocumentHandler(ComponentManager componentManager, String wiki)\n    {\n        super(componentManager);\n\n        setCurrentBean(new XWikiDocument(new DocumentReference(wiki, \"XWiki\", \"Page\")));\n\n        // Default syntax in a XAR is xwiki/1.0\n        getDocument().setSyntax(Syntax.XWIKI_1_0);\n\n        // skip useless known elements\n        this.skippedElements.add(\"version\");\n        this.skippedElements.add(\"minorEdit\");\n        this.skippedElements.add(\"comment\");\n        this.skippedElements.add(\"creator\");\n        this.skippedElements.add(\"author\");\n        this.skippedElements.add(\"contentAuthor\");\n        this.skippedElements.add(\"creationDate\");\n        this.skippedElements.add(\"date\");\n        this.skippedElements.add(\"contentUpdateDate\");\n    }","id":78456,"modified_method":"public DocumentHandler(ComponentManager componentManager, String wiki)\n    {\n        super(componentManager);\n\n        setCurrentBean(new XWikiDocument(new DocumentReference(wiki, \"XWiki\", \"Page\")));\n\n        // Default syntax in a XAR is xwiki/1.0\n        getDocument().setSyntax(Syntax.XWIKI_1_0);\n\n        // skip useless known elements\n        this.skippedElements.add(\"version\");\n        this.skippedElements.add(\"minorEdit\");\n        this.skippedElements.add(\"comment\");\n        this.skippedElements.add(\"creationDate\");\n        this.skippedElements.add(\"date\");\n        this.skippedElements.add(\"contentUpdateDate\");\n    }","commit_id":"9fe3ee7eb0609602b62cf2416186275387381275","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveDocument(String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            XWikiDocument currentDocument = getDatabaseDocument();\n            XWikiDocument nextDocument = getDocument();\n\n            if (this.configuration.isLogEnabled()) {\n                LOGGER.info(\"Importing document [{}] in language [{}]...\", nextDocument.getDocumentReference(),\n                    nextDocument.getRealLanguage());\n            }\n\n            // Merge and save\n            if (currentDocument != null && this.hasCurrentDocument == Boolean.TRUE) {\n                XWikiDocument previousDocument = getPreviousDocument();\n\n                if (previousDocument != null) {\n                    // 3 ways merge\n                    XWikiDocument mergedDocument = currentDocument.clone();\n\n                    MergeResult documentMergeResult =\n                        mergedDocument.merge(previousDocument, nextDocument,\n                            this.configuration.getMergeConfiguration(), context);\n\n                    if (documentMergeResult.isModified()) {\n                        if (this.configuration.isInteractive()\n                            && !documentMergeResult.getLog().getLogs(LogLevel.ERROR).isEmpty()) {\n                            // Indicate future author to whoever is going to answer the question\n                            nextDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            mergedDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            DocumentReference userReference = getUserReference(context);\n                            nextDocument.setAuthorReference(userReference);\n                            nextDocument.setContentAuthorReference(userReference);\n                            mergedDocument.setAuthorReference(userReference);\n                            mergedDocument.setContentAuthorReference(userReference);\n\n                            XWikiDocument documentToSave =\n                                askDocumentToSave(currentDocument, previousDocument, nextDocument, mergedDocument);\n\n                            if (documentToSave != currentDocument) {\n                                saveDocument(documentToSave, comment, context);\n                            }\n                        } else {\n                            saveDocument(mergedDocument, comment, context);\n                        }\n                    }\n\n                    this.mergeResult =\n                        new XarEntryMergeResult(new XarEntry(mergedDocument.getDocumentReference(),\n                            mergedDocument.getLanguage()), documentMergeResult);\n                } else {\n                    // already existing document in database but without previous version\n                    if (!currentDocument.equalsData(nextDocument)) {\n                        XWikiDocument documentToSave;\n                        if (this.configuration.isInteractive()) {\n                            // Indicate future author to whoever is going to answer the question\n                            nextDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            DocumentReference userReference = getUserReference(context);\n                            nextDocument.setAuthorReference(userReference);\n                            nextDocument.setContentAuthorReference(userReference);\n\n                            documentToSave = askDocumentToSave(currentDocument, previousDocument, nextDocument, null);\n                        } else {\n                            documentToSave = nextDocument;\n                        }\n\n                        if (documentToSave != currentDocument) {\n                            saveDocument(documentToSave, comment, context);\n                        }\n                    }\n                }\n            } else {\n                saveDocument(nextDocument, comment, context);\n            }\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save document\", e);\n        }\n    }","id":78457,"modified_method":"private void saveDocument(String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            XWikiDocument currentDocument = getDatabaseDocument();\n            XWikiDocument nextDocument = getDocument();\n\n            if (this.configuration.isLogEnabled()) {\n                LOGGER.info(\"Importing document [{}] in language [{}]...\", nextDocument.getDocumentReference(),\n                    nextDocument.getRealLanguage());\n            }\n\n            // Merge and save\n            if (currentDocument != null && this.hasCurrentDocument == Boolean.TRUE) {\n                XWikiDocument previousDocument = getPreviousDocument();\n\n                if (previousDocument != null) {\n                    // 3 ways merge\n                    XWikiDocument mergedDocument = currentDocument.clone();\n\n                    MergeResult documentMergeResult =\n                        mergedDocument.merge(previousDocument, nextDocument,\n                            this.configuration.getMergeConfiguration(), context);\n\n                    if (documentMergeResult.isModified()) {\n                        if (this.configuration.isInteractive()\n                            && !documentMergeResult.getLog().getLogs(LogLevel.ERROR).isEmpty()) {\n                            // Indicate future author to whoever is going to answer the question\n                            nextDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            mergedDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            DocumentReference userReference = getUserReference(context);\n                            if (userReference != null) {\n                                nextDocument.setAuthorReference(userReference);\n                                nextDocument.setContentAuthorReference(userReference);\n                                mergedDocument.setAuthorReference(userReference);\n                                mergedDocument.setContentAuthorReference(userReference);\n                            }\n\n                            XWikiDocument documentToSave =\n                                askDocumentToSave(currentDocument, previousDocument, nextDocument, mergedDocument);\n\n                            if (documentToSave != currentDocument) {\n                                saveDocument(documentToSave, comment, context);\n                            }\n                        } else {\n                            saveDocument(mergedDocument, comment, context);\n                        }\n                    }\n\n                    this.mergeResult =\n                        new XarEntryMergeResult(new XarEntry(mergedDocument.getDocumentReference(),\n                            mergedDocument.getLanguage()), documentMergeResult);\n                } else {\n                    // already existing document in database but without previous version\n                    if (!currentDocument.equalsData(nextDocument)) {\n                        XWikiDocument documentToSave;\n                        if (this.configuration.isInteractive()) {\n                            // Indicate future author to whoever is going to answer the question\n                            nextDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            DocumentReference userReference = getUserReference(context);\n                            nextDocument.setAuthorReference(userReference);\n                            nextDocument.setContentAuthorReference(userReference);\n\n                            documentToSave = askDocumentToSave(currentDocument, previousDocument, nextDocument, null);\n                        } else {\n                            documentToSave = nextDocument;\n                        }\n\n                        if (documentToSave != currentDocument) {\n                            saveDocument(documentToSave, comment, context);\n                        }\n                    }\n                }\n            } else {\n                saveDocument(nextDocument, comment, context);\n            }\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save document\", e);\n        }\n    }","commit_id":"9fe3ee7eb0609602b62cf2416186275387381275","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveDocument(XWikiDocument document, String comment, XWikiContext context) throws Exception\n    {\n        XWikiDocument currentDocument = getDatabaseDocument();\n        DocumentReference userReference = getUserReference(context);\n\n        if (!currentDocument.isNew()) {\n            if (document != currentDocument) {\n                if (document.isNew()) {\n                    currentDocument.apply(document);\n                } else {\n                    currentDocument = document;\n                }\n            }\n        } else {\n            currentDocument = document;\n            currentDocument.setCreatorReference(userReference);\n        }\n\n        currentDocument.setAuthorReference(userReference);\n        currentDocument.setContentAuthorReference(userReference);\n\n        context.getWiki().saveDocument(currentDocument, comment, context);\n    }","id":78458,"modified_method":"private void saveDocument(XWikiDocument document, String comment, XWikiContext context) throws Exception\n    {\n        XWikiDocument currentDocument = getDatabaseDocument();\n        DocumentReference userReference = getUserReference(context);\n\n        if (!currentDocument.isNew()) {\n            if (document != currentDocument) {\n                if (document.isNew()) {\n                    currentDocument.apply(document);\n                } else {\n                    currentDocument = document;\n                }\n            }\n        } else {\n            currentDocument = document;\n            if (userReference != null) {\n                currentDocument.setCreatorReference(userReference);\n            }\n        }\n\n        if (userReference != null) {\n            currentDocument.setAuthorReference(userReference);\n            currentDocument.setContentAuthorReference(userReference);\n        }\n\n        context.getWiki().saveDocument(currentDocument, comment, context);\n    }","commit_id":"9fe3ee7eb0609602b62cf2416186275387381275","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveAttachment(XWikiAttachment attachment, String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            // Set proper author\n            XWikiDocument document = getDocument();\n            document.setAuthorReference(getUserReference(context));\n            attachment.setAuthor(getUserString(context));\n\n            XWikiDocument dbDocument = getDatabaseDocument();\n\n            XWikiAttachment dbAttachment = dbDocument.getAttachment(attachment.getFilename());\n\n            if (dbAttachment == null) {\n                attachment.setDoc(dbDocument);\n                dbDocument.getAttachmentList().add(attachment);\n            } else {\n                dbAttachment.setContent(attachment.getContentInputStream(context));\n                dbAttachment.setFilename(attachment.getFilename());\n                dbAttachment.setAuthor(attachment.getAuthor());\n            }\n\n            context.getWiki().saveDocument(dbDocument, comment, context);\n\n            // reset content to since it could consume lots of memory and it's not used in diff for now\n            attachment.setAttachment_content(null);\n            getDocument().getAttachmentList().add(attachment);\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save attachment [\" + attachment + \"]\", e);\n        }\n    }","id":78459,"modified_method":"private void saveAttachment(XWikiAttachment attachment, String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            XWikiDocument document = getDocument();\n\n            // Set proper author\n            DocumentReference userReference = getUserReference(context);\n            if (userReference != null) {\n                document.setAuthorReference(userReference);\n                attachment.setAuthor(getUserString(context));\n            }\n\n            XWikiDocument dbDocument = getDatabaseDocument();\n\n            XWikiAttachment dbAttachment = dbDocument.getAttachment(attachment.getFilename());\n\n            if (dbAttachment == null) {\n                attachment.setDoc(dbDocument);\n                dbDocument.getAttachmentList().add(attachment);\n            } else {\n                dbAttachment.setContent(attachment.getContentInputStream(context));\n                dbAttachment.setFilename(attachment.getFilename());\n                dbAttachment.setAuthor(attachment.getAuthor());\n            }\n\n            context.getWiki().saveDocument(dbDocument, comment, context);\n\n            // reset content to since it could consume lots of memory and it's not used in diff for now\n            attachment.setAttachment_content(null);\n            getDocument().getAttachmentList().add(attachment);\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save attachment [\" + attachment + \"]\", e);\n        }\n    }","commit_id":"9fe3ee7eb0609602b62cf2416186275387381275","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the author name that we want to print in the notification message we send to the IRC channel.\n     *\n     * @param xcontext the XWiki Context from which we extract the current user\n     * @return the author name\n     * @throws IRCBotException if we cannot access the XWikiContext\n     */\n    private String getNotificationAuthor(XWikiContext xcontext) throws IRCBotException\n    {\n        return this.serializer.serialize(xcontext.getUserReference());\n    }","id":78460,"modified_method":"/**\n     * Get the author name that we want to print in the notification message we send to the IRC channel.\n     *\n     * @param xcontext the XWiki Context from which we extract the current user\n     * @return the author name\n     * @throws IRCBotException if we cannot access the XWikiContext\n     */\n    private String getNotificationAuthor(XWikiContext xcontext) throws IRCBotException\n    {\n        String user;\n\n        DocumentReference userReference = xcontext.getUserReference();\n        if (userReference != null) {\n            user = this.serializer.serialize(userReference);\n        } else {\n            user = \"Guest\";\n        }\n\n        return user;\n    }","commit_id":"0266ec683641d957834a7eb246e9c72cc24d1e0b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void onEventWhenDocumentCreatedAndNotExcluded() throws Exception\n    {\n        final IRCBot bot = getComponentManager().getInstance(IRCBot.class);\n        final EntityReferenceSerializer<String> serializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        final DocumentReference reference = new DocumentReference(\"wiki\", \"space\", \"page\");\n        final DocumentModifiedEventListenerConfiguration configuration =\n            getComponentManager().getInstance(DocumentModifiedEventListenerConfiguration.class);\n        final DocumentReference userReference = new DocumentReference(\"userwiki\", \"userspace\", \"userpage\");\n\n        // We simulate an EC without any XAR started information\n        final Execution execution = getComponentManager().getInstance(Execution.class);\n        final ExecutionContext ec = new ExecutionContext();\n\n        Utils.setComponentManager(getComponentManager());\n        final XWikiContext xwikiContext = new XWikiContext();\n        final XWikiURLFactory factory = getMockery().mock(XWikiURLFactory.class);\n        xwikiContext.setURLFactory(factory);\n        xwikiContext.setUserReference(userReference);\n\n        getMockery().checking(new Expectations()\n        {{\n            oneOf(bot).isConnected();\n            will(returnValue(true));\n            oneOf(serializer).serialize(reference);\n            will(returnValue(\"wiki:space.page\"));\n            oneOf(execution).getContext();\n            will(returnValue(ec));\n            oneOf(configuration).getExclusionPatterns();\n            will(returnValue(Collections.emptyList()));\n            oneOf(serializer).serialize(userReference);\n            will(returnValue(\"userwiki:userspace.userpage\"));\n            oneOf(factory).createExternalURL(\"space\", \"page\", \"view\", null, null, \"wiki\", xwikiContext);\n            will(returnValue(new URL(\"http://someurl\")));\n            oneOf(bot).getChannelsNames();\n            will(returnValue(Collections.singleton(\"channel\")));\n\n            // The test is here!\n            oneOf(bot).sendMessage(\"channel\", \"wiki:space.page was created by userwiki:userspace.userpage (comment) - \"\n                + \"http://someurl\");\n        }});\n\n        XWikiDocument document = new XWikiDocument(reference);\n        document.setAuthorReference(userReference);\n        document.setComment(\"comment\");\n\n        this.listener.onEvent(new DocumentCreatedEvent(reference), document, xwikiContext);\n    }","id":78461,"modified_method":"@Test\n    public void onEventWhenDocumentCreatedAndNotExcluded() throws Exception\n    {\n        final IRCBot bot = getComponentManager().getInstance(IRCBot.class);\n        final EntityReferenceSerializer<String> serializer =\n            getComponentManager().getInstance(EntityReferenceSerializer.TYPE_STRING);\n        final DocumentReference reference = new DocumentReference(\"wiki\", \"space\", \"page\");\n        final DocumentModifiedEventListenerConfiguration configuration =\n            getComponentManager().getInstance(DocumentModifiedEventListenerConfiguration.class);\n        final DocumentReference userReference = new DocumentReference(\"userwiki\", \"userspace\", \"userpage\");\n\n        // We simulate an EC without any XAR started information\n        final Execution execution = getComponentManager().getInstance(Execution.class);\n        final ExecutionContext ec = new ExecutionContext();\n\n        Utils.setComponentManager(getComponentManager());\n        final XWikiContext xwikiContext = new XWikiContext();\n        final XWikiURLFactory factory = getMockery().mock(XWikiURLFactory.class);\n        xwikiContext.setURLFactory(factory);\n        xwikiContext.setUserReference(userReference);\n\n        getMockery().checking(new Expectations()\n        {{\n            oneOf(bot).isConnected();\n            will(returnValue(true));\n            oneOf(serializer).serialize(reference);\n            will(returnValue(\"wiki:space.page\"));\n            oneOf(execution).getContext();\n            will(returnValue(ec));\n            oneOf(configuration).getExclusionPatterns();\n            will(returnValue(Collections.emptyList()));\n            oneOf(serializer).serialize(userReference);\n            will(returnValue(\"userwiki:userspace.userpage\"));\n            oneOf(factory).createExternalURL(\"space\", \"page\", \"view\", null, null, \"wiki\", xwikiContext);\n            will(returnValue(new URL(\"http://someurl\")));\n            oneOf(bot).getChannelsNames();\n            will(returnValue(Collections.singleton(\"channel\")));\n\n            // The test is here!\n            oneOf(bot).sendMessage(\"channel\", \"wiki:space.page was created by userwiki:userspace.userpage (comment) - \"\n                + \"http://someurl\");\n        }});\n\n        XWikiDocument document = new XWikiDocument(reference);\n        document.setComment(\"comment\");\n\n        this.listener.onEvent(new DocumentCreatedEvent(reference), document, xwikiContext);\n    }","commit_id":"0266ec683641d957834a7eb246e9c72cc24d1e0b","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Create an {@link InstallRequest} instance based on passed parameters.\n     * \n     * @param id the identifier of the extension to install\n     * @param version the version to install\n     * @param namespace the (optional) namespace where to install the extension; if {@code null} or empty, the extension\n     *            will be installed globally\n     * @return the {@link InstallRequest}\n     */\n    public InstallRequest createInstallRequest(String id, String version, String namespace)\n    {\n        InstallRequest installRequest = createInstallPlanRequest(id, version, namespace);\n\n        installRequest.setId(getJobId(EXTENSIONACTION_JOBID_PREFIX, id, namespace));\n        installRequest.setInteractive(true);\n        installRequest.setProperty(PROPERTY_JOB_TYPE, InstallJob.JOBTYPE);\n\n        return installRequest;\n    }","id":78462,"modified_method":"/**\n     * Create an {@link InstallRequest} instance based on passed parameters.\n     * \n     * @param id the identifier of the extension to install\n     * @param version the version to install\n     * @param namespace the (optional) namespace where to install the extension; if {@code null} or empty, the extension\n     *            will be installed globally\n     * @return the {@link InstallRequest}\n     */\n    public InstallRequest createInstallRequest(String id, String version, String namespace)\n    {\n        InstallRequest installRequest = createInstallPlanRequest(id, version, namespace);\n\n        installRequest.setId(getJobId(EXTENSIONACTION_JOBID_PREFIX, id, namespace));\n        installRequest.setInteractive(true);\n        installRequest.setProperty(PROPERTY_JOB_TYPE, InstallJob.JOBTYPE);\n        DocumentReference currentUserReference = this.documentAccessBridge.getCurrentUserReference();\n        if (currentUserReference != null) {\n            // We set the string value because the extension repository doesn't know how to serialize/parse an extension\n            // property whose value is a DocumentReference, and adding support for it requires considerable refactoring\n            // because ExtensionPropertySerializers are not components (they are currently hard-coded).\n            installRequest.setExtensionProperty(PROPERTY_USERREFERENCE, currentUserReference.toString());\n        }\n\n        return installRequest;\n    }","commit_id":"9b115f4acd8dcbe08f1b7f91400dcf0d32518bc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public <S> S get(Extension unsafe)\n    {\n        Extension safe;\n\n        if (unsafe instanceof CoreExtension) {\n            safe = new SafeCoreExtension<CoreExtension>((CoreExtension) unsafe, this.defaultSafeProvider);\n        } else if (unsafe instanceof InstalledExtension) {\n            safe =\n                new SafeInstalledExtension<InstalledExtension>((InstalledExtension) unsafe, this.defaultSafeProvider);\n        } else if (unsafe instanceof LocalExtension) {\n            safe = new SafeLocalExtension<LocalExtension>((LocalExtension) unsafe, this.defaultSafeProvider);\n        } else if (unsafe instanceof RatingExtension) {\n            safe = new SafeRatingExtension<RatingExtension>((RatingExtension) unsafe, this.defaultSafeProvider);\n        } else {\n            safe = new SafeExtension<Extension>(unsafe, this.defaultSafeProvider);\n        }\n\n        return (S) safe;\n    }","id":78463,"modified_method":"@Override\n    public <S> S get(Extension unsafe)\n    {\n        Extension safe;\n\n        if (unsafe instanceof CoreExtension) {\n            safe = new SafeCoreExtension<CoreExtension>((CoreExtension) unsafe, this.defaultSafeProvider);\n        } else if (unsafe instanceof InstalledExtension) {\n            safe = new SafeInstalledExtension<InstalledExtension>((InstalledExtension) unsafe, this.defaultSafeProvider,\n                this.documentReferenceResolver);\n        } else if (unsafe instanceof LocalExtension) {\n            safe = new SafeLocalExtension<LocalExtension>((LocalExtension) unsafe, this.defaultSafeProvider);\n        } else if (unsafe instanceof RatingExtension) {\n            safe = new SafeRatingExtension<RatingExtension>((RatingExtension) unsafe, this.defaultSafeProvider);\n        } else {\n            safe = new SafeExtension<Extension>(unsafe, this.defaultSafeProvider);\n        }\n\n        return (S) safe;\n    }","commit_id":"9b115f4acd8dcbe08f1b7f91400dcf0d32518bc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param localExtension the wrapped local extension\n     * @param safeProvider the provider of instances safe for public scripts\n     */\n    public SafeInstalledExtension(T localExtension, ScriptSafeProvider<Object> safeProvider)\n    {\n        super(localExtension, safeProvider);\n    }","id":78464,"modified_method":"/**\n     * @param localExtension the wrapped local extension\n     * @param safeProvider the provider of instances safe for public scripts\n     * @param documentReferenceResolver used to resolve the reference of the user that installed the extension\n     */\n    public SafeInstalledExtension(T localExtension, ScriptSafeProvider<Object> safeProvider,\n        DocumentReferenceResolver<String> documentReferenceResolver)\n    {\n        super(localExtension, safeProvider);\n\n        this.documentReferenceResolver = documentReferenceResolver;\n    }","commit_id":"9b115f4acd8dcbe08f1b7f91400dcf0d32518bc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public InstalledExtension installExtension(LocalExtension extension, String namespace, boolean dependency)\n    {\n        if (!this.hasProgrammingRight) {\n            setError(new UnsupportedOperationException(FORBIDDEN));\n\n            return null;\n        }\n\n        setError(null);\n\n        try {\n            return safe(getWrapped().installExtension(extension, namespace, dependency));\n        } catch (InstallException e) {\n            setError(e);\n        }\n\n        return null;\n    }","id":78465,"modified_method":"@Override\n    public InstalledExtension installExtension(LocalExtension extension, String namespace, boolean dependency)\n    {\n        return installExtension(extension, namespace, dependency, Collections.<String, Object>emptyMap());\n    }","commit_id":"9b115f4acd8dcbe08f1b7f91400dcf0d32518bc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void onWikiCreated(WikiCreatedEvent event, XWikiContext context)\n    {\n        String namespace = \"wiki:\" + event.getWikiId();\n\n        Collection<InstalledExtension> installedExtensions = this.installedRepository.getInstalledExtensions(null);\n\n        InstallRequest installRequest = new InstallRequest();\n        installRequest.setProperty(\"user.reference\", context.getUserReference());\n        installRequest.setVerbose(false);\n        // TODO: make it interactive ? (require wiki creation to be job based)\n        installRequest.setInteractive(false);\n\n        ExtensionHandler xarHandler = this.xarHandlerProvider.get();\n\n        for (InstalledExtension installedExtension : installedExtensions) {\n            if (installedExtension.getType().equals(XarExtensionHandler.TYPE)) {\n                installRequest.addExtension(installedExtension.getId());\n\n                try {\n                    xarHandler.install(installedExtension, namespace, installRequest);\n                } catch (InstallException e) {\n                    this.logger.error(\"Failed to import extension [{}] in wiki [{}]\", installedExtension,\n                        event.getWikiId(), e);\n                }\n            }\n        }\n    }","id":78466,"modified_method":"private void onWikiCreated(WikiCreatedEvent event, XWikiContext context)\n    {\n        String namespace = \"wiki:\" + event.getWikiId();\n\n        Collection<InstalledExtension> installedExtensions = this.installedRepository.getInstalledExtensions(null);\n\n        InstallRequest installRequest = new InstallRequest();\n        DocumentReference userReference = context.getUserReference();\n        if (userReference != null) {\n            installRequest.setProperty(PROPERTY_USER_REFERENCE, userReference);\n            // We set the string value because the extension repository doesn't know how to serialize/parse an extension\n            // property whose value is a DocumentReference, and adding support for it requires considerable refactoring\n            // because ExtensionPropertySerializers are not components (they are currently hard-coded).\n            installRequest.setExtensionProperty(PROPERTY_USER_REFERENCE, userReference.toString());\n        }\n        installRequest.setVerbose(false);\n        // TODO: make it interactive ? (require wiki creation to be job based)\n        installRequest.setInteractive(false);\n\n        ExtensionHandler xarHandler = this.xarHandlerProvider.get();\n\n        for (InstalledExtension installedExtension : installedExtensions) {\n            if (installedExtension.getType().equals(XarExtensionHandler.TYPE)) {\n                installRequest.addExtension(installedExtension.getId());\n\n                try {\n                    xarHandler.install(installedExtension, namespace, installRequest);\n                } catch (InstallException e) {\n                    this.logger.error(\"Failed to import extension [{}] in wiki [{}]\", installedExtension,\n                        event.getWikiId(), e);\n                }\n            }\n        }\n    }","commit_id":"9b115f4acd8dcbe08f1b7f91400dcf0d32518bc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Make sure the provided XAR extension properly is registered in the installed extensions index.\n     * <p>\n     * Start an asynchronous Job.\n     * \n     * @param id the extension identifier\n     * @param version the extension version\n     * @param wiki the wiki where the extension is installed\n     * @return the {@link Job} object which can be used to monitor the progress of the installation process, or\n     *         {@code null} in case of failure\n     */\n    public Job repairInstalledExtension(String id, String version, String wiki)\n    {\n        setError(null);\n\n        if (!this.documentAccessBridge.hasProgrammingRights()) {\n            setError(new JobException(\"Need programming right to repair a XAR\"));\n            return null;\n        }\n\n        String namespace = \"wiki:\" + wiki;\n\n        InstallRequest installRequest = new InstallRequest();\n        installRequest.setId(getJobId(ExtensionManagerScriptService.EXTENSIONACTION_JOBID_PREFIX, id, namespace));\n        installRequest.addExtension(new ExtensionId(id, version));\n        if (StringUtils.isNotBlank(namespace)) {\n            installRequest.addNamespace(namespace);\n        }\n\n        Job job = null;\n        try {\n            job = this.jobExecutor.execute(RepairXarJob.JOBTYPE, installRequest);\n        } catch (Exception e) {\n            setError(e);\n        }\n\n        return job;\n    }","id":78467,"modified_method":"/**\n     * Make sure the provided XAR extension properly is registered in the installed extensions index.\n     * <p>\n     * Start an asynchronous Job.\n     * \n     * @param id the extension identifier\n     * @param version the extension version\n     * @param wiki the wiki where the extension is installed\n     * @return the {@link Job} object which can be used to monitor the progress of the installation process, or\n     *         {@code null} in case of failure\n     */\n    public Job repairInstalledExtension(String id, String version, String wiki)\n    {\n        setError(null);\n\n        if (!this.documentAccessBridge.hasProgrammingRights()) {\n            setError(new JobException(\"Need programming right to repair a XAR\"));\n            return null;\n        }\n\n        String namespace = \"wiki:\" + wiki;\n\n        InstallRequest installRequest = new InstallRequest();\n        installRequest.setId(getJobId(ExtensionManagerScriptService.EXTENSIONACTION_JOBID_PREFIX, id, namespace));\n        DocumentReference currentUserReference = this.documentAccessBridge.getCurrentUserReference();\n        if (currentUserReference != null) {\n            installRequest.setProperty(PROPERTY_USER_REFERENCE, currentUserReference);\n            // We set the string value because the extension repository doesn't know how to serialize/parse an extension\n            // property whose value is a DocumentReference, and adding support for it requires considerable refactoring\n            // because ExtensionPropertySerializers are not components (they are currently hard-coded).\n            installRequest.setExtensionProperty(PROPERTY_USER_REFERENCE, currentUserReference.toString());\n        }\n        installRequest.addExtension(new ExtensionId(id, version));\n        if (StringUtils.isNotBlank(namespace)) {\n            installRequest.addNamespace(namespace);\n        }\n\n        Job job = null;\n        try {\n            job = this.jobExecutor.execute(RepairXarJob.JOBTYPE, installRequest);\n        } catch (Exception e) {\n            setError(e);\n        }\n\n        return job;\n    }","commit_id":"9b115f4acd8dcbe08f1b7f91400dcf0d32518bc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public InstalledExtension installExtension(LocalExtension extension, String namespace, boolean dependency)\n        throws InstallException\n    {\n        throw new UnsupportedOperationException(\"Not implemented\");\n    }","id":78468,"modified_method":"@Override\n    public InstalledExtension installExtension(LocalExtension extension, String namespace, boolean dependency)\n        throws InstallException\n    {\n        return installExtension(extension, namespace, dependency, Collections.<String, Object>emptyMap());\n    }","commit_id":"9b115f4acd8dcbe08f1b7f91400dcf0d32518bc0","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public DocumentHandler(ComponentManager componentManager, String wiki)\n    {\n        super(componentManager);\n\n        setCurrentBean(new XWikiDocument(new DocumentReference(wiki, \"XWiki\", \"Page\")));\n\n        // Default syntax in a XAR is xwiki/1.0\n        getDocument().setSyntax(Syntax.XWIKI_1_0);\n\n        // skip useless known elements\n        this.skippedElements.add(\"version\");\n        this.skippedElements.add(\"minorEdit\");\n        this.skippedElements.add(\"comment\");\n        this.skippedElements.add(\"creator\");\n        this.skippedElements.add(\"author\");\n        this.skippedElements.add(\"contentAuthor\");\n        this.skippedElements.add(\"creationDate\");\n        this.skippedElements.add(\"date\");\n        this.skippedElements.add(\"contentUpdateDate\");\n    }","id":78469,"modified_method":"public DocumentHandler(ComponentManager componentManager, String wiki)\n    {\n        super(componentManager);\n\n        setCurrentBean(new XWikiDocument(new DocumentReference(wiki, \"XWiki\", \"Page\")));\n\n        // Default syntax in a XAR is xwiki/1.0\n        getDocument().setSyntax(Syntax.XWIKI_1_0);\n\n        // skip useless known elements\n        this.skippedElements.add(\"version\");\n        this.skippedElements.add(\"minorEdit\");\n        this.skippedElements.add(\"comment\");\n        this.skippedElements.add(\"creationDate\");\n        this.skippedElements.add(\"date\");\n        this.skippedElements.add(\"contentUpdateDate\");\n    }","commit_id":"af3478b5843efe29b4fa121664a118ea7eea869d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveDocument(String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            XWikiDocument currentDocument = getDatabaseDocument();\n            XWikiDocument nextDocument = getDocument();\n\n            if (this.configuration.isLogEnabled()) {\n                LOGGER.info(\"Importing document [{}] in language [{}]...\", nextDocument.getDocumentReference(),\n                    nextDocument.getRealLanguage());\n            }\n\n            // Merge and save\n            if (currentDocument != null && this.hasCurrentDocument == Boolean.TRUE) {\n                XWikiDocument previousDocument = getPreviousDocument();\n\n                if (previousDocument != null) {\n                    // 3 ways merge\n                    XWikiDocument mergedDocument = currentDocument.clone();\n\n                    MergeResult documentMergeResult =\n                        mergedDocument.merge(previousDocument, nextDocument,\n                            this.configuration.getMergeConfiguration(), context);\n\n                    if (documentMergeResult.isModified()) {\n                        if (this.configuration.isInteractive()\n                            && !documentMergeResult.getLog().getLogs(LogLevel.ERROR).isEmpty()) {\n                            // Indicate future author to whoever is going to answer the question\n                            nextDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            mergedDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            DocumentReference userReference = getUserReference(context);\n                            nextDocument.setAuthorReference(userReference);\n                            nextDocument.setContentAuthorReference(userReference);\n                            mergedDocument.setAuthorReference(userReference);\n                            mergedDocument.setContentAuthorReference(userReference);\n\n                            XWikiDocument documentToSave =\n                                askDocumentToSave(currentDocument, previousDocument, nextDocument, mergedDocument);\n\n                            if (documentToSave != currentDocument) {\n                                saveDocument(documentToSave, comment, context);\n                            }\n                        } else {\n                            saveDocument(mergedDocument, comment, context);\n                        }\n                    }\n\n                    this.mergeResult =\n                        new XarEntryMergeResult(new XarEntry(mergedDocument.getDocumentReference(),\n                            mergedDocument.getLanguage()), documentMergeResult);\n                } else {\n                    // already existing document in database but without previous version\n                    if (!currentDocument.equalsData(nextDocument)) {\n                        XWikiDocument documentToSave;\n                        if (this.configuration.isInteractive()) {\n                            // Indicate future author to whoever is going to answer the question\n                            nextDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            DocumentReference userReference = getUserReference(context);\n                            nextDocument.setAuthorReference(userReference);\n                            nextDocument.setContentAuthorReference(userReference);\n\n                            documentToSave = askDocumentToSave(currentDocument, previousDocument, nextDocument, null);\n                        } else {\n                            documentToSave = nextDocument;\n                        }\n\n                        if (documentToSave != currentDocument) {\n                            saveDocument(documentToSave, comment, context);\n                        }\n                    }\n                }\n            } else {\n                saveDocument(nextDocument, comment, context);\n            }\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save document\", e);\n        }\n    }","id":78470,"modified_method":"private void saveDocument(String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            XWikiDocument currentDocument = getDatabaseDocument();\n            XWikiDocument nextDocument = getDocument();\n\n            if (this.configuration.isLogEnabled()) {\n                LOGGER.info(\"Importing document [{}] in language [{}]...\", nextDocument.getDocumentReference(),\n                    nextDocument.getRealLanguage());\n            }\n\n            // Merge and save\n            if (currentDocument != null && this.hasCurrentDocument == Boolean.TRUE) {\n                XWikiDocument previousDocument = getPreviousDocument();\n\n                if (previousDocument != null) {\n                    // 3 ways merge\n                    XWikiDocument mergedDocument = currentDocument.clone();\n\n                    MergeResult documentMergeResult =\n                        mergedDocument.merge(previousDocument, nextDocument,\n                            this.configuration.getMergeConfiguration(), context);\n\n                    if (documentMergeResult.isModified()) {\n                        if (this.configuration.isInteractive()\n                            && !documentMergeResult.getLog().getLogs(LogLevel.ERROR).isEmpty()) {\n                            // Indicate future author to whoever is going to answer the question\n                            nextDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            mergedDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            DocumentReference userReference = getUserReference(context);\n                            if (userReference != null) {\n                                nextDocument.setAuthorReference(userReference);\n                                nextDocument.setContentAuthorReference(userReference);\n                                mergedDocument.setAuthorReference(userReference);\n                                mergedDocument.setContentAuthorReference(userReference);\n                            }\n\n                            XWikiDocument documentToSave =\n                                askDocumentToSave(currentDocument, previousDocument, nextDocument, mergedDocument);\n\n                            if (documentToSave != currentDocument) {\n                                saveDocument(documentToSave, comment, context);\n                            }\n                        } else {\n                            saveDocument(mergedDocument, comment, context);\n                        }\n                    }\n\n                    this.mergeResult =\n                        new XarEntryMergeResult(new XarEntry(mergedDocument.getDocumentReference(),\n                            mergedDocument.getLanguage()), documentMergeResult);\n                } else {\n                    // already existing document in database but without previous version\n                    if (!currentDocument.equalsData(nextDocument)) {\n                        XWikiDocument documentToSave;\n                        if (this.configuration.isInteractive()) {\n                            // Indicate future author to whoever is going to answer the question\n                            nextDocument.setCreatorReference(currentDocument.getCreatorReference());\n                            DocumentReference userReference = getUserReference(context);\n                            nextDocument.setAuthorReference(userReference);\n                            nextDocument.setContentAuthorReference(userReference);\n\n                            documentToSave = askDocumentToSave(currentDocument, previousDocument, nextDocument, null);\n                        } else {\n                            documentToSave = nextDocument;\n                        }\n\n                        if (documentToSave != currentDocument) {\n                            saveDocument(documentToSave, comment, context);\n                        }\n                    }\n                }\n            } else {\n                saveDocument(nextDocument, comment, context);\n            }\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save document\", e);\n        }\n    }","commit_id":"af3478b5843efe29b4fa121664a118ea7eea869d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveAttachment(XWikiAttachment attachment, String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            // Set proper author\n            XWikiDocument document = getDocument();\n            document.setAuthorReference(getUserReference(context));\n            attachment.setAuthor(getUserString(context));\n\n            XWikiDocument dbDocument = getDatabaseDocument();\n\n            XWikiAttachment dbAttachment = dbDocument.getAttachment(attachment.getFilename());\n\n            if (dbAttachment == null) {\n                attachment.setDoc(dbDocument);\n                dbDocument.getAttachmentList().add(attachment);\n            } else {\n                dbAttachment.setContent(attachment.getContentInputStream(context));\n                dbAttachment.setFilename(attachment.getFilename());\n                dbAttachment.setAuthor(attachment.getAuthor());\n            }\n\n            context.getWiki().saveDocument(dbDocument, comment, context);\n\n            // reset content to since it could consume lots of memory and it's not used in diff for now\n            attachment.setAttachment_content(null);\n            getDocument().getAttachmentList().add(attachment);\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save attachment [\" + attachment + \"]\", e);\n        }\n    }","id":78471,"modified_method":"private void saveAttachment(XWikiAttachment attachment, String comment) throws SAXException\n    {\n        try {\n            XWikiContext context = getXWikiContext();\n\n            XWikiDocument document = getDocument();\n\n            // Set proper author\n            DocumentReference userReference = getUserReference(context);\n            if (userReference != null) {\n                document.setAuthorReference(userReference);\n                attachment.setAuthor(getUserString(context));\n            }\n\n            XWikiDocument dbDocument = getDatabaseDocument();\n\n            XWikiAttachment dbAttachment = dbDocument.getAttachment(attachment.getFilename());\n\n            if (dbAttachment == null) {\n                attachment.setDoc(dbDocument);\n                dbDocument.getAttachmentList().add(attachment);\n            } else {\n                dbAttachment.setContent(attachment.getContentInputStream(context));\n                dbAttachment.setFilename(attachment.getFilename());\n                dbAttachment.setAuthor(attachment.getAuthor());\n            }\n\n            context.getWiki().saveDocument(dbDocument, comment, context);\n\n            // reset content to since it could consume lots of memory and it's not used in diff for now\n            attachment.setAttachment_content(null);\n            getDocument().getAttachmentList().add(attachment);\n        } catch (Exception e) {\n            throw new SAXException(\"Failed to save attachment [\" + attachment + \"]\", e);\n        }\n    }","commit_id":"af3478b5843efe29b4fa121664a118ea7eea869d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void saveDocument(XWikiDocument document, String comment, XWikiContext context) throws Exception\n    {\n        XWikiDocument currentDocument = getDatabaseDocument();\n        DocumentReference userReference = getUserReference(context);\n\n        if (!currentDocument.isNew()) {\n            if (document != currentDocument) {\n                if (document.isNew()) {\n                    currentDocument.apply(document);\n                } else {\n                    currentDocument = document;\n                }\n            }\n        } else {\n            currentDocument = document;\n            currentDocument.setCreatorReference(userReference);\n        }\n\n        currentDocument.setAuthorReference(userReference);\n        currentDocument.setContentAuthorReference(userReference);\n\n        context.getWiki().saveDocument(currentDocument, comment, context);\n    }","id":78472,"modified_method":"private void saveDocument(XWikiDocument document, String comment, XWikiContext context) throws Exception\n    {\n        XWikiDocument currentDocument = getDatabaseDocument();\n        DocumentReference userReference = getUserReference(context);\n\n        if (!currentDocument.isNew()) {\n            if (document != currentDocument) {\n                if (document.isNew()) {\n                    currentDocument.apply(document);\n                } else {\n                    currentDocument = document;\n                }\n            }\n        } else {\n            currentDocument = document;\n            if (userReference != null) {\n                currentDocument.setCreatorReference(userReference);\n            }\n        }\n\n        if (userReference != null) {\n            currentDocument.setAuthorReference(userReference);\n            currentDocument.setContentAuthorReference(userReference);\n        }\n\n        context.getWiki().saveDocument(currentDocument, comment, context);\n    }","commit_id":"af3478b5843efe29b4fa121664a118ea7eea869d","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"protected void initStrategies(ApplicationContext context) {\n\n\t\tthis.handlerMappings = new ArrayList<>(BeanFactoryUtils.beansOfTypeIncludingAncestors(\n\t\t\t\tcontext, HandlerMapping.class, true, false).values());\n\n\t\tthis.handlerAdapters = new ArrayList<>(BeanFactoryUtils.beansOfTypeIncludingAncestors(\n\t\t\t\tcontext, HandlerAdapter.class, true, false).values());\n\n\t\tthis.resultHandlers = new ArrayList<>(BeanFactoryUtils.beansOfTypeIncludingAncestors(\n\t\t\t\tcontext, HandlerResultHandler.class, true, false).values());\n\t}","id":78473,"modified_method":"protected void initStrategies(ApplicationContext context) {\n\n\t\tMap<String, HandlerMapping> mappingBeans =\n\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);\n\n\t\tthis.handlerMappings = new ArrayList<>(mappingBeans.values());\n\t\tAnnotationAwareOrderComparator.sort(this.handlerMappings);\n\n\t\tMap<String, HandlerAdapter> adapterBeans =\n\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);\n\n\t\tthis.handlerAdapters = new ArrayList<>(adapterBeans.values());\n\t\tAnnotationAwareOrderComparator.sort(this.handlerAdapters);\n\n\t\tMap<String, HandlerResultHandler> beans =\n\t\t\t\tBeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerResultHandler.class, true, false);\n\n\t\tthis.resultHandlers = new ArrayList<>(beans.values());\n\t\tAnnotationAwareOrderComparator.sort(this.resultHandlers);\n\t}","commit_id":"202825554c022e4262fe3bd20a34faf01ab9d620","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Publisher<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tObject handler = getHandler(request);\n\t\tif (handler == null) {\n\t\t\t// No exception handling mechanism yet\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn Streams.empty();\n\t\t}\n\n\t\tHandlerAdapter handlerAdapter = getHandlerAdapter(handler);\n\t\tPublisher<HandlerResult> resultPublisher = handlerAdapter.handle(request, response, handler);\n\n\t\treturn Streams.wrap(resultPublisher).concatMap((HandlerResult result) -> {\n\t\t\tfor (HandlerResultHandler resultHandler : resultHandlers) {\n\t\t\t\tif (resultHandler.supports(result)) {\n\t\t\t\t\treturn resultHandler.handleResult(request, response, result);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Streams.fail(new IllegalStateException(\n\t\t\t\t\t\"No HandlerResultHandler for \" + result.getReturnValue()));\n\t\t});\n\t}","id":78474,"modified_method":"@Override\n\tpublic Publisher<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Processing \" + request.getMethod() + \" request for [\" + request.getURI() + \"]\");\n\t\t}\n\n\t\tObject handler = getHandler(request);\n\t\tif (handler == null) {\n\t\t\t// No exception handling mechanism yet\n\t\t\tresponse.setStatusCode(HttpStatus.NOT_FOUND);\n\t\t\treturn Streams.empty();\n\t\t}\n\n\t\tHandlerAdapter handlerAdapter = getHandlerAdapter(handler);\n\t\tPublisher<HandlerResult> resultPublisher = handlerAdapter.handle(request, response, handler);\n\n\t\treturn Streams.wrap(resultPublisher).concatMap((HandlerResult result) -> {\n\t\t\tfor (HandlerResultHandler resultHandler : resultHandlers) {\n\t\t\t\tif (resultHandler.supports(result)) {\n\t\t\t\t\treturn resultHandler.handleResult(request, response, result);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Streams.fail(new IllegalStateException(\n\t\t\t\t\t\"No HandlerResultHandler for \" + result.getValue()));\n\t\t});\n\t}","commit_id":"202825554c022e4262fe3bd20a34faf01ab9d620","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public HandlerResult(Object returnValue) {\n\t\tthis.returnValue = returnValue;\n\t}","id":78475,"modified_method":"public HandlerResult(Object handler, Object value) {\n\t\tthis.handler = handler;\n\t\tthis.value = value;\n\t}","commit_id":"202825554c022e4262fe3bd20a34faf01ab9d620","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public Object getReturnValue() {\n\t\treturn this.returnValue;\n\t}","id":78476,"modified_method":"public Object getValue() {\n\t\treturn this.value;\n\t}","commit_id":"202825554c022e4262fe3bd20a34faf01ab9d620","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tAsyncContext context = request.startAsync();\n\t\tAsyncContextSynchronizer contextSynchronizer = new AsyncContextSynchronizer(context);\n\n\t\tRequestBodyPublisher requestPublisher = new RequestBodyPublisher(contextSynchronizer, BUFFER_SIZE);\n\t\trequest.getInputStream().setReadListener(requestPublisher);\n\t\tServletServerHttpRequest httpRequest = new ServletServerHttpRequest(request, requestPublisher);\n\n\t\tResponseBodySubscriber responseSubscriber = new ResponseBodySubscriber(contextSynchronizer);\n\t\tresponse.getOutputStream().setWriteListener(responseSubscriber);\n\t\tServletServerHttpResponse httpResponse = new ServletServerHttpResponse(response, responseSubscriber);\n\n\t\tHandlerResultSubscriber resultSubscriber = new HandlerResultSubscriber(contextSynchronizer);\n\t\tthis.handler.handle(httpRequest, httpResponse).subscribe(resultSubscriber);\n\t}","id":78477,"modified_method":"@Override\n\tprotected void service(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\tAsyncContext context = request.startAsync();\n\t\tAsyncContextSynchronizer contextSynchronizer = new AsyncContextSynchronizer(context);\n\n\t\tRequestBodyPublisher requestPublisher = new RequestBodyPublisher(contextSynchronizer, BUFFER_SIZE);\n\t\trequest.getInputStream().setReadListener(requestPublisher);\n\t\tServletServerHttpRequest httpRequest = new ServletServerHttpRequest(request, requestPublisher);\n\n\t\tResponseBodySubscriber responseSubscriber = new ResponseBodySubscriber(contextSynchronizer);\n\t\tresponse.getOutputStream().setWriteListener(responseSubscriber);\n\t\tServletServerHttpResponse httpResponse = new ServletServerHttpResponse(response, responseSubscriber);\n\n\t\tHandlerResultSubscriber resultSubscriber = new HandlerResultSubscriber(contextSynchronizer, httpResponse);\n\t\tthis.handler.handle(httpRequest, httpResponse).subscribe(resultSubscriber);\n\t}","commit_id":"202825554c022e4262fe3bd20a34faf01ab9d620","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tpublic void onError(Throwable ex) {\n\t\t\tlogger.error(\"Error from request handling. Completing the request.\", ex);\n\t\t\tthis.synchronizer.complete();\n\t\t}","id":78478,"modified_method":"@Override\n\t\tpublic void onError(Throwable ex) {\n\t\t\tlogger.error(\"Error from request handling. Completing the request.\", ex);\n\t\t\tthis.response.setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t\tthis.synchronizer.complete();\n\t\t}","commit_id":"202825554c022e4262fe3bd20a34faf01ab9d620","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public HandlerResultSubscriber(AsyncContextSynchronizer synchronizer) {\n\t\t\tthis.synchronizer = synchronizer;\n\t\t}","id":78479,"modified_method":"public HandlerResultSubscriber(AsyncContextSynchronizer synchronizer, ServletServerHttpResponse response) {\n\t\t\tthis.synchronizer = synchronizer;\n\t\t\tthis.response = response;\n\t\t}","commit_id":"202825554c022e4262fe3bd20a34faf01ab9d620","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void writeHeaders() {\n\t\tif (!this.headersWritten) {\n\t\t\tfor (String name : this.headers.keySet()) {\n\t\t\t\tthis.response.setHeader(name, this.headers.get(name));\n\t\t\t}\n\t\t}\n\t}","id":78480,"modified_method":"private void writeHeaders() {\n\t\tif (!this.headersWritten) {\n\t\t\tfor (String name : this.headers.keySet()) {\n\t\t\t\tfor (String value : this.headers.get(name)) {\n\t\t\t\t\tthis.response.addHeader(name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"202825554c022e4262fe3bd20a34faf01ab9d620","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public boolean isAcceptable(Object element, PsiElement context) {\n    PsiElement previous = PsiImplUtil.realPrevious(context.getParent().getPrevSibling());\n    if (previous == null ||\n        !GroovyTokenTypes.mAT.equals(previous.getNode().getElementType())) {\n      return false;\n    }\n    if (context.getParent() instanceof GrReferenceElement &&\n        context.getParent().getParent() instanceof GrAnnotation) {\n      return true;\n    }\n    return false;\n  }","id":78481,"modified_method":"public boolean isAcceptable(Object element, PsiElement context) {\n    PsiElement previous = PsiImplUtil.realPrevious(context.getPrevSibling());\n    if (previous != null &&\n        GroovyTokenTypes.mAT.equals(previous.getNode().getElementType()) &&\n        context.getParent() != null &&\n        context.getParent().getParent() instanceof GroovyFile) {\n      return true;\n    }\n    if (context.getParent() instanceof PsiErrorElement &&\n        context.getParent().getParent() instanceof GrAnnotation) {\n      return true;\n    }\n    return false;\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAcceptable(Object element, PsiElement context) {\n    PsiElement previous = PsiImplUtil.realPrevious(context.getParent().getPrevSibling());\n    if (previous != null &&\n        GroovyTokenTypes.mAT.equals(previous.getNode().getElementType())) {\n      return false;\n    }\n    if (GroovyCompletionUtil.asSimpleVariable(context) ||\n        GroovyCompletionUtil.asTypedMethod(context) ||\n        GroovyCompletionUtil.asVariableInBlock(context)) {\n      return true;\n    }\n    if ((context.getParent() instanceof GrParameter &&\n        ((GrParameter) context.getParent()).getTypeElementGroovy() == null) ||\n        context.getParent() instanceof GrReferenceElement &&\n            !(context.getParent().getParent() instanceof GrImportStatement) &&\n            !(context.getParent().getParent() instanceof GrPackageDefinition)) {\n      return !(previous != null &&\n          GroovyTokenTypes.mAT.equals(previous.getNode().getElementType()));\n    }\n    if (PsiImplUtil.realPrevious(context.getParent().getPrevSibling()) instanceof GrModifierList) {\n      return true;\n    }\n    if (PsiImplUtil.realPrevious(context.getPrevSibling()) instanceof GrModifierList) {\n      return true;\n    }\n    return context.getParent() instanceof GrExpression &&\n        context.getParent().getParent() instanceof GroovyFile &&\n        GroovyCompletionUtil.isNewStatement(context, false);\n  }","id":78482,"modified_method":"public boolean isAcceptable(Object element, PsiElement context) {\n    PsiElement previous = PsiImplUtil.realPrevious(context.getParent().getPrevSibling());\n    if (previous != null &&\n        GroovyTokenTypes.mAT.equals(previous.getNode().getElementType())) {\n      return false;\n    }\n    if (GroovyCompletionUtil.asSimpleVariable(context) ||\n        GroovyCompletionUtil.asTypedMethod(context) ||\n        GroovyCompletionUtil.asVariableInBlock(context)) {\n      return true;\n    }\n    if (context.getParent() instanceof PsiErrorElement &&\n        context.getParent().getParent() instanceof GrGspDeclarationHolder &&\n        GroovyCompletionUtil.isNewStatement(context, false)) {\n      return true;\n    }\n    if ((context.getParent() instanceof GrParameter &&\n        ((GrParameter) context.getParent()).getTypeElementGroovy() == null) ||\n        context.getParent() instanceof GrReferenceElement &&\n            !(context.getParent().getParent() instanceof GrImportStatement) &&\n            !(context.getParent().getParent() instanceof GrPackageDefinition)) {\n      return !(previous != null &&\n          GroovyTokenTypes.mAT.equals(previous.getNode().getElementType()));\n    }\n    if (PsiImplUtil.realPrevious(context.getParent().getPrevSibling()) instanceof GrModifierList) {\n      return true;\n    }\n    if (PsiImplUtil.realPrevious(context.getPrevSibling()) instanceof GrModifierList) {\n      return true;\n    }\n    return context.getParent() instanceof GrExpression &&\n        context.getParent().getParent() instanceof GroovyFile &&\n        GroovyCompletionUtil.isNewStatement(context, false);\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAcceptable(Object element, PsiElement context) {\n    if (GroovyCompletionUtil.asSimpleVariable(context) ||\n        GroovyCompletionUtil.asTypedMethod(context) ||\n        GroovyCompletionUtil.asVariableInBlock(context)) {\n      return true;\n    }\n    if ((context.getParent() instanceof GrParameter &&\n        ((GrParameter) context.getParent()).getTypeElementGroovy() == null) ||\n        context.getParent() instanceof GrReferenceElement  &&\n        !(context.getParent() instanceof GrReferenceExpression)  &&\n        !(context.getParent().getParent() instanceof GrImportStatement) &&\n        !(context.getParent().getParent() instanceof GrPackageDefinition)) {\n      return true;\n    }\n    if (PsiImplUtil.realPrevious(context.getParent().getPrevSibling()) instanceof GrModifierList) {\n      return true;\n    }\n    if (PsiImplUtil.realPrevious(context.getPrevSibling()) instanceof GrModifierList) {\n      return true;\n    }\n    return context.getParent() instanceof GrExpression &&\n        context.getParent().getParent() instanceof GroovyFile &&\n        GroovyCompletionUtil.isNewStatement(context, false);\n  }","id":78483,"modified_method":"public boolean isAcceptable(Object element, PsiElement context) {\n    if (GroovyCompletionUtil.asSimpleVariable(context) ||\n        GroovyCompletionUtil.asTypedMethod(context) ||\n        GroovyCompletionUtil.asVariableInBlock(context)) {\n      return true;\n    }\n    if (context.getParent() instanceof PsiErrorElement &&\n        context.getParent().getParent() instanceof GrGspDeclarationHolder &&\n        GroovyCompletionUtil.isNewStatement(context, false)) {\n      return true;\n    }\n    if ((context.getParent() instanceof GrParameter &&\n        ((GrParameter) context.getParent()).getTypeElementGroovy() == null) ||\n        context.getParent() instanceof GrReferenceElement &&\n            !(context.getParent() instanceof GrReferenceExpression) &&\n            !(context.getParent().getParent() instanceof GrImportStatement) &&\n            !(context.getParent().getParent() instanceof GrPackageDefinition)) {\n      return true;\n    }\n    if (PsiImplUtil.realPrevious(context.getParent().getPrevSibling()) instanceof GrModifierList) {\n      return true;\n    }\n    if (PsiImplUtil.realPrevious(context.getPrevSibling()) instanceof GrModifierList) {\n      return true;\n    }\n    return context.getParent() instanceof GrExpression &&\n        context.getParent().getParent() instanceof GroovyFile &&\n        GroovyCompletionUtil.isNewStatement(context, false);\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiElement getNameIdentifierGroovy() {\n    return findChildByType(GroovyTokenTypes.mIDENT);\n  }","id":78484,"modified_method":"@NotNull\n  public PsiElement getNameIdentifierGroovy() {\n    PsiElement ident = findChildByType(GroovyTokenTypes.mIDENT);\n    assert ident != null;\n    return ident;\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean hasModifierProperty(@NonNls @NotNull String property) {\n    PsiModifierList modifierList = getModifierList();\n    if (modifierList != null) return modifierList.hasModifierProperty(property);\n    return false;\n  }","id":78485,"modified_method":"public boolean hasModifierProperty(@NonNls @NotNull String property) {\n    PsiModifierList modifierList = getModifierList();\n    return modifierList != null && modifierList.hasModifierProperty(property);\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void annotate(PsiElement element, AnnotationHolder holder) {\n    if (element instanceof GrCodeReferenceElement) {\n      checkReferenceElement(holder, (GrCodeReferenceElement) element);\n    } else if (element instanceof GrReferenceExpression) {\n      checkReferenceExpression(holder, (GrReferenceExpression) element);\n    } else if (element instanceof GrTypeDefinition) {\n      checkTypeDefinition(holder, (GrTypeDefinition) element);\n      checkTypeDefinitionModifiers(holder, (GrTypeDefinition) element);\n      checkDuplicateMethod(((GrTypeDefinition) element).getBody().getMethods(), holder);\n      checkImplementedMethodsOfClass(holder, (GrTypeDefinition) element);\n    } else if (element instanceof GrMethod) {\n      checkMethodDefinitionModifiers(holder, (GrMethod) element);\n      checkInnerMethod(holder, (GrMethod) element);\n      addOverrideGutter(holder, (GrMethod) element);\n    } else if (element instanceof GrVariableDeclaration) {\n      checkVariableDeclaration(holder, (GrVariableDeclaration) element);\n    } else if (element instanceof GrVariable) {\n      checkVariable(holder, (GrVariable) element);\n    } else if (element instanceof GrAssignmentExpression) {\n      checkAssignmentExpression((GrAssignmentExpression) element, holder);\n    } else if (element instanceof GrNamedArgument) {\n      checkCommandArgument((GrNamedArgument) element, holder);\n    } else if (element instanceof GrReturnStatement) {\n      checkReturnStatement((GrReturnStatement) element, holder);\n    } else if (element instanceof GrListOrMap) {\n      checkMap(((GrListOrMap) element).getNamedArguments(), holder);\n    } else if (element instanceof GrNewExpression) {\n      checkNewExpression(holder, (GrNewExpression) element);\n    } else if (element instanceof GrConstructorInvocation) {\n      checkConstructorInvocation(holder, (GrConstructorInvocation) element);\n    } else if (element instanceof GroovyFile) {\n      final GroovyFile file = (GroovyFile) element;\n      if (file.isScript()) {\n        checkScriptDuplicateMethod(file.getTopLevelDefinitions(), holder);\n      }\n      if (DomainClassUtils.isDomainClass(element.getContainingFile().getVirtualFile())) {\n        checkDomainClass((GroovyFile) element, holder);\n      }\n    } else if (!(element instanceof PsiWhiteSpace) && element.getContainingFile() instanceof GroovyFile) {\n      GroovyImportsTracker.getInstance(element.getProject()).markFileAnnotated((GroovyFile) element.getContainingFile());\n    }\n  }","id":78486,"modified_method":"public void annotate(PsiElement element, AnnotationHolder holder) {\n    if (element instanceof GrCodeReferenceElement) {\n      checkReferenceElement(holder, (GrCodeReferenceElement) element);\n    } else if (element instanceof GrReferenceExpression) {\n      checkReferenceExpression(holder, (GrReferenceExpression) element);\n    } else if (element instanceof GrTypeDefinition) {\n      checkTypeDefinition(holder, (GrTypeDefinition) element);\n      checkTypeDefinitionModifiers(holder, (GrTypeDefinition) element);\n      checkDuplicateMethod(((GrTypeDefinition) element).getBody().getMethods(), holder);\n      checkImplementedMethodsOfClass(holder, (GrTypeDefinition) element);\n    } else if (element instanceof GrMethod) {\n      checkMethodDefinitionModifiers(holder, (GrMethod) element);\n      checkInnerMethod(holder, (GrMethod) element);\n      addOverrideGutter(holder, (GrMethod) element);\n    } else if (element instanceof GrVariableDeclaration) {\n      checkVariableDeclaration(holder, (GrVariableDeclaration) element);\n    } else if (element instanceof GrVariable) {\n      if (element instanceof GrMember) highlightMember(holder, ((GrMember) element));\n      checkVariable(holder, (GrVariable) element);\n    } else if (element instanceof GrAssignmentExpression) {\n      checkAssignmentExpression((GrAssignmentExpression) element, holder);\n    } else if (element instanceof GrNamedArgument) {\n      checkCommandArgument((GrNamedArgument) element, holder);\n    } else if (element instanceof GrReturnStatement) {\n      checkReturnStatement((GrReturnStatement) element, holder);\n    } else if (element instanceof GrListOrMap) {\n      checkMap(((GrListOrMap) element).getNamedArguments(), holder);\n    } else if (element instanceof GrNewExpression) {\n      checkNewExpression(holder, (GrNewExpression) element);\n    } else if (element instanceof GrConstructorInvocation) {\n      checkConstructorInvocation(holder, (GrConstructorInvocation) element);\n    } else if (element instanceof GroovyFile) {\n      final GroovyFile file = (GroovyFile) element;\n      if (file.isScript()) {\n        checkScriptDuplicateMethod(file.getTopLevelDefinitions(), holder);\n      }\n      if (DomainClassUtils.isDomainClass(element.getContainingFile().getVirtualFile())) {\n        checkDomainClass((GroovyFile) element, holder);\n      }\n    } else if (!(element instanceof PsiWhiteSpace) && element.getContainingFile() instanceof GroovyFile) {\n      GroovyImportsTracker.getInstance(element.getProject()).markFileAnnotated((GroovyFile) element.getContainingFile());\n    }\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkReferenceElement(AnnotationHolder holder, final GrCodeReferenceElement refElement) {\n    final PsiElement parent = refElement.getParent();\n    GroovyResolveResult resolveResult = refElement.advancedResolve();\n    registerUsedImport(refElement, resolveResult);\n    if (refElement.getReferenceName() != null) {\n\n      if (parent instanceof GrImportStatement &&\n          ((GrImportStatement) parent).isStatic() &&\n          refElement.multiResolve(false).length > 0) {\n        return;\n      }\n\n      checkSingleResolvedElement(holder, refElement, resolveResult);\n    }\n\n  }","id":78487,"modified_method":"private void checkReferenceElement(AnnotationHolder holder, final GrCodeReferenceElement refElement) {\n    final PsiElement parent = refElement.getParent();\n    GroovyResolveResult resolveResult = refElement.advancedResolve();\n    highlightAnnotation(holder, refElement, resolveResult);\n    registerUsedImport(refElement, resolveResult);\n    highlightAnnotation(holder, refElement, resolveResult);\n    if (refElement.getReferenceName() != null) {\n\n      if (parent instanceof GrImportStatement &&\n          ((GrImportStatement) parent).isStatic() &&\n          refElement.multiResolve(false).length > 0) {\n        return;\n      }\n\n      checkSingleResolvedElement(holder, refElement, resolveResult);\n    }\n\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkAssignmentExpression(GrAssignmentExpression assignment, AnnotationHolder holder) {\n    IElementType opToken = assignment.getOperationToken();\n    if (opToken == GroovyTokenTypes.mASSIGN) {\n      GrExpression lValue = assignment.getLValue();\n      GrExpression rValue = assignment.getRValue();\n      if (lValue != null && rValue != null) {\n        PsiType lType = lValue.getType();\n        PsiType rType = rValue.getType();\n        if (lType != null && rType != null) {\n          checkAssignability(holder, lType, rType, rValue);\n        }\n      }\n    }\n  }","id":78488,"modified_method":"private void checkAssignmentExpression(GrAssignmentExpression assignment, AnnotationHolder holder) {\n    IElementType opToken = assignment.getOperationToken();\n    if (opToken == GroovyTokenTypes.mASSIGN) {\n      GrExpression lValue = assignment.getLValue();\n      GrExpression rValue = assignment.getRValue();\n      if (rValue != null) {\n        PsiType lType = lValue.getType();\n        PsiType rType = rValue.getType();\n        if (lType != null && rType != null) {\n          checkAssignability(holder, lType, rType, rValue);\n        }\n      }\n    }\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkReferenceExpression(AnnotationHolder holder, final GrReferenceExpression refExpr) {\n    GroovyResolveResult resolveResult = refExpr.advancedResolve();\n    registerUsedImport(refExpr, resolveResult);\n    PsiElement resolved = resolveResult.getElement();\n    if (resolved != null) {\n      if (!resolveResult.isAccessible()) {\n        String message = GroovyBundle.message(\"cannot.access\", refExpr.getReferenceName());\n        holder.createWarningAnnotation(refExpr, message);\n      } else if (resolved instanceof PsiMethod && resolved.getUserData(GrMethod.BUILDER_METHOD) == null) {\n        checkMethodApplicability(resolveResult, refExpr, holder);\n      }\n      if (isAssignmentLHS(refExpr) || resolved instanceof PsiPackage) return;\n    } else {\n      if (isAssignmentLHS(refExpr)) return;\n\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      if (qualifier == null) {\n        GroovyPsiElement context = PsiTreeUtil.getParentOfType(refExpr, GrMethod.class, GrField.class, GrClosableBlock.class);\n        if (context instanceof PsiModifierListOwner && ((PsiModifierListOwner) context).hasModifierProperty(PsiModifier.STATIC)) {\n          Annotation annotation = holder.createErrorAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n          annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n          return;\n        }\n      }\n    }\n\n    if (refExpr.getType() == null) {\n      PsiElement refNameElement = refExpr.getReferenceNameElement();\n      PsiElement elt = refNameElement == null ? refExpr : refNameElement;\n      Annotation annotation = holder.createInformationAnnotation(elt,\n          GroovyBundle.message(\"untyped.access\", refExpr.getReferenceName()));\n      if (resolved == null && refExpr.getQualifierExpression() == null) {\n        if (!(refExpr.getParent() instanceof GrCallExpression)) {\n          registerCreateClassByTypeFix(refExpr, annotation, false);\n        }\n        registerAddImportFixes(refExpr, annotation);\n      }\n\n      //annotation.setEnforcedTextAttributes(new TextAttributes(Color.black, null, Color.black, EffectType.LINE_UNDERSCORE, 0));\n      annotation.setTextAttributes(DefaultHighlighter.UNTYPED_ACCESS);\n    }\n  }","id":78489,"modified_method":"private void checkReferenceExpression(AnnotationHolder holder, final GrReferenceExpression refExpr) {\n    GroovyResolveResult resolveResult = refExpr.advancedResolve();\n    registerUsedImport(refExpr, resolveResult);\n    PsiElement resolved = resolveResult.getElement();\n    if (resolved != null) {\n      if (resolved instanceof PsiMember) {\n        highlightMemberResolved(holder, refExpr, ((PsiMember) resolved));\n      }\n      if (!resolveResult.isAccessible()) {\n        String message = GroovyBundle.message(\"cannot.access\", refExpr.getReferenceName());\n        holder.createWarningAnnotation(refExpr, message);\n      } else if (resolved instanceof PsiMethod && resolved.getUserData(GrMethod.BUILDER_METHOD) == null) {\n        checkMethodApplicability(resolveResult, refExpr, holder);\n      }\n      if (isAssignmentLHS(refExpr) || resolved instanceof PsiPackage) return;\n    } else {\n      if (isAssignmentLHS(refExpr)) return;\n\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      if (qualifier == null) {\n        GroovyPsiElement context = PsiTreeUtil.getParentOfType(refExpr, GrMethod.class, GrField.class, GrClosableBlock.class);\n        if (context instanceof PsiModifierListOwner && ((PsiModifierListOwner) context).hasModifierProperty(PsiModifier.STATIC)) {\n          Annotation annotation = holder.createErrorAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n          annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n          return;\n        }\n      }\n    }\n\n    if (refExpr.getType() == null) {\n      PsiElement refNameElement = refExpr.getReferenceNameElement();\n      PsiElement elt = refNameElement == null ? refExpr : refNameElement;\n      Annotation annotation = holder.createInformationAnnotation(elt,\n          GroovyBundle.message(\"untyped.access\", refExpr.getReferenceName()));\n      if (resolved == null && refExpr.getQualifierExpression() == null) {\n        if (!(refExpr.getParent() instanceof GrCallExpression)) {\n          registerCreateClassByTypeFix(refExpr, annotation, false);\n        }\n        registerAddImportFixes(refExpr, annotation);\n      }\n\n      //annotation.setEnforcedTextAttributes(new TextAttributes(Color.black, null, Color.black, EffectType.LINE_UNDERSCORE, 0));\n      annotation.setTextAttributes(DefaultHighlighter.UNTYPED_ACCESS);\n    }\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkTypeDefinition(AnnotationHolder holder, GrTypeDefinition typeDefinition) {\n    if (GroovyElementTypes.CLASS_BODY.equals(typeDefinition.getNode().getTreeParent().getElementType())) {\n      holder.createErrorAnnotation(typeDefinition.getNameIdentifierGroovy(), \"Inner classes are not supported in Groovy\");\n    }\n\n    //TODO: add quickfix to change implements -> extends or class to interface \n    final GrImplementsClause implementsClause = typeDefinition.getImplementsClause();\n    if (implementsClause != null) {\n      checkForImplementingInterface(holder, implementsClause);\n    }\n\n    final GrExtendsClause extendsClause = typeDefinition.getExtendsClause();\n    if (extendsClause != null) {\n      checkForExtendingClass(holder, extendsClause);\n    }\n  }","id":78490,"modified_method":"private void checkTypeDefinition(AnnotationHolder holder, GrTypeDefinition typeDefinition) {\n    if (typeDefinition != null &&\n        typeDefinition.isAnnotationType()) {\n      Annotation annotation = holder.createInfoAnnotation(typeDefinition.getNameIdentifierGroovy(), null);\n      annotation.setTextAttributes(DefaultHighlighter.ANNOTATION);\n    }\n\n    if (GroovyElementTypes.CLASS_BODY.equals(typeDefinition.getNode().getTreeParent().getElementType())) {\n      holder.createErrorAnnotation(typeDefinition.getNameIdentifierGroovy(), \"Inner classes are not supported in Groovy\");\n    }\n\n    //TODO: add quickfix to change implements -> extends or class to interface \n    final GrImplementsClause implementsClause = typeDefinition.getImplementsClause();\n    if (implementsClause != null) {\n      checkForImplementingInterface(holder, implementsClause);\n    }\n\n    final GrExtendsClause extendsClause = typeDefinition.getExtendsClause();\n    if (extendsClause != null) {\n      checkForExtendingClass(holder, extendsClause);\n    }\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NonNls\n  @NotNull\n  public String getDemoText() {\n    return \"import javax.swing.JPanel\\n\" +\n        \"class Demo {\\n\" +\n        \"//This is a line comment\\n\" +\n        \"/*This is a block comment*/\\n\" +\n        \"  JPanel panel = new JPanel()\\n\" +\n        \"  panel.size = [10, 10]\\n\" +\n        \"}\";\n  }","id":78491,"modified_method":"@NonNls\n  @NotNull\n  public String getDemoText() {\n    return \"import javax.swing.JPanel\\n\" +\n        \"  ### \\n\" +\n        \"<annotation>@SpecialBean<\/annotation> \\n\" +\n        \"class Demo {\\n\" +\n        \"//This is a line comment\\n\" +\n        \"/* This is a block comment */\\n\" +\n        \"  static def foo(int i) { return [i, i] }\\n\" +\n        \"  JPanel <field>panel<\/field> = new JPanel()\\n\" +\n        \"}\\n\" +\n        \"\\n\" +\n        \"new Demo().<field>panel<\/field>.<mc>size<\/mc> = \" +\n        \"Demo.<statmet>foo<\/statmet>(\\\"2${3}9\\\".toInteger()) \\n\" +\n        \"'JetBrains'.matches(/Jw+/) \\n\" +\n        \"<untyped>untyped<\/untyped>.<untyped>doSomething<\/untyped>()\";\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Map<String, TextAttributesKey> getAdditionalHighlightingTagToDescriptorMap() {\n    return null;\n  }","id":78492,"modified_method":"@Nullable\n  public Map<String, TextAttributesKey> getAdditionalHighlightingTagToDescriptorMap() {\n    Map<String, TextAttributesKey> map = new HashMap<String, TextAttributesKey>();\n    map.put(\"annotation\", DefaultHighlighter.ANNOTATION);\n    map.put(\"statmet\", DefaultHighlighter.STATIC_METHOD_ACCESS);\n    map.put(\"statfield\", DefaultHighlighter.STATIC_FIELD);\n    map.put(\"field\", DefaultHighlighter.INSTANCE_FIELD);\n    map.put(\"mc\", DefaultHighlighter.METHOD_CALL);\n    map.put(\"untyped\", DefaultHighlighter.UNTYPED_ACCESS);\n\n    return map;\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAcceptable(Object element, PsiElement context) {\n    if (GroovyCompletionUtil.asSimpleVariable(context) ||\n        GroovyCompletionUtil.asTypedMethod(context)) {\n      return true;\n    }\n    if (context.getParent() instanceof GrExpression &&\n        context.getParent().getParent() instanceof GroovyFile &&\n        GroovyCompletionUtil.isNewStatement(context, false)) {\n      return true;\n    }\n    ASTNode astNode = context.getNode();\n    if (context.getTextRange().getStartOffset() == 0 && astNode != null &&\n        !(GspTokenTypesEx.GSP_TEMPLATE_DATA == astNode.getElementType())) {\n      return true;\n    }\n    final PsiElement leaf = GroovyCompletionUtil.getLeafByOffset(context.getTextRange().getStartOffset() - 1, context);\n    if (leaf != null &&\n        GroovyCompletionUtil.isNewStatement(context, false)) {\n      PsiElement parent = leaf.getParent();\n      if (parent instanceof GroovyFile) {\n        return true;\n      }\n    }\n    return context.getParent() instanceof GrExpression &&\n        context.getParent().getParent() instanceof GrApplicationStatement &&\n        context.getParent().getParent().getParent() instanceof GroovyFile &&\n        GroovyCompletionUtil.isNewStatement(context, false);\n  }","id":78493,"modified_method":"public boolean isAcceptable(Object element, PsiElement context) {\n    if (GroovyCompletionUtil.asSimpleVariable(context) ||\n\n        GroovyCompletionUtil.asTypedMethod(context)) {\n      return true;\n    }\n    if (context.getParent() instanceof GrExpression &&\n        context.getParent().getParent() instanceof GroovyFile &&\n        GroovyCompletionUtil.isNewStatement(context, false)) {\n      return true;\n    }\n    if (context.getParent() instanceof PsiErrorElement &&\n        context.getParent().getParent() instanceof GrGspDeclarationHolder &&\n        GroovyCompletionUtil.isNewStatement(context, false)) {\n      return true;\n    }\n    ASTNode astNode = context.getNode();\n    if (context.getTextRange().getStartOffset() == 0 && astNode != null &&\n        !(GspTokenTypesEx.GSP_TEMPLATE_DATA == astNode.getElementType())) {\n      return true;\n    }\n    final PsiElement leaf = GroovyCompletionUtil.getLeafByOffset(context.getTextRange().getStartOffset() - 1, context);\n    if (leaf != null &&\n        GroovyCompletionUtil.isNewStatement(context, false)) {\n      PsiElement parent = leaf.getParent();\n      if (parent instanceof GroovyFile) {\n        return true;\n      }\n    }\n    return context.getParent() instanceof GrExpression &&\n        context.getParent().getParent() instanceof GrApplicationStatement &&\n        context.getParent().getParent().getParent() instanceof GroovyFile &&\n        GroovyCompletionUtil.isNewStatement(context, false);\n  }","commit_id":"b5d7ed3ec402b73c22050389523c1c2663c4e485","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JetNodeType parseProperty() {\n        return parseProperty(false);\n    }","id":78494,"modified_method":"private IElementType parseProperty() {\n        return parseProperty(false);\n    }","commit_id":"e2a3ada02dce0528042c69e28efee3fd5a76ab06","url":"https://github.com/JetBrains/kotlin"},{"original_method":"JetNodeType parseProperty(boolean local) {\n        if (at(VAL_KEYWORD) || at(VAR_KEYWORD)) {\n            advance(); // VAL_KEYWORD or VAR_KEYWORD\n        }\n        else {\n            errorAndAdvance(\"Expecting 'val' or 'var'\");\n        }\n\n        boolean typeParametersDeclared = at(LT) && parseTypeParameterList(TokenSet.create(IDENTIFIER, EQ, COLON, SEMICOLON));\n\n        TokenSet propertyNameFollow = TokenSet.create(COLON, EQ, LBRACE, RBRACE, SEMICOLON, VAL_KEYWORD, VAR_KEYWORD, FUN_KEYWORD, CLASS_KEYWORD);\n\n        myBuilder.disableJoiningComplexTokens();\n\n        // TODO: extract constant\n        int lastDot = matchTokenStreamPredicate(new LastBefore(\n                new AtSet(DOT, SAFE_ACCESS),\n                new AbstractTokenStreamPredicate() {\n                    @Override\n                    public boolean matching(boolean topLevel) {\n                        if (topLevel && (at(EQ) || at(COLON))) return true;\n                        if (topLevel && at(IDENTIFIER)) {\n                            IElementType lookahead = lookahead(1);\n                            return lookahead != LT && lookahead != DOT && lookahead != SAFE_ACCESS && lookahead != QUEST;\n                        }\n                        return false;\n                    }\n                }));\n\n        parseReceiverType(\"property\", propertyNameFollow, lastDot);\n\n        myBuilder.restoreJoiningComplexTokensState();\n\n        if (at(COLON)) {\n            advance(); // COLON\n            if (!parseIdeTemplate()) {\n                parseTypeRef();\n            }\n        }\n\n        parseTypeConstraintsGuarded(typeParametersDeclared);\n\n        if (local) {\n            if (at(EQ)) {\n                advance(); // EQ\n                myExpressionParsing.parseExpression();\n                // \"val a = 1; b\" must not be an infix call of b on \"val ...;\"\n            }\n        }\n        else {\n            if (at(EQ)) {\n                advance(); // EQ\n                myExpressionParsing.parseExpression();\n                consumeIf(SEMICOLON);\n            }\n\n            if (parsePropertyGetterOrSetter()) {\n                parsePropertyGetterOrSetter();\n            }\n            if  (!atSet(EOL_OR_SEMICOLON, RBRACE)) {\n                if (getLastToken() != SEMICOLON) {\n                    errorUntil(\"Property getter or setter expected\", TokenSet.create(EOL_OR_SEMICOLON));\n                }\n            }\n            else {\n                consumeIf(SEMICOLON);\n            }\n        }\n\n\n        return PROPERTY;\n    }","id":78495,"modified_method":"IElementType parseProperty(boolean local) {\n        if (at(VAL_KEYWORD) || at(VAR_KEYWORD)) {\n            advance(); // VAL_KEYWORD or VAR_KEYWORD\n        }\n        else {\n            errorAndAdvance(\"Expecting 'val' or 'var'\");\n        }\n\n        boolean typeParametersDeclared = at(LT) && parseTypeParameterList(TokenSet.create(IDENTIFIER, EQ, COLON, SEMICOLON));\n\n        TokenSet propertyNameFollow = TokenSet.create(COLON, EQ, LBRACE, RBRACE, SEMICOLON, VAL_KEYWORD, VAR_KEYWORD, FUN_KEYWORD, CLASS_KEYWORD);\n\n        myBuilder.disableJoiningComplexTokens();\n\n        // TODO: extract constant\n        int lastDot = matchTokenStreamPredicate(new LastBefore(\n                new AtSet(DOT, SAFE_ACCESS),\n                new AbstractTokenStreamPredicate() {\n                    @Override\n                    public boolean matching(boolean topLevel) {\n                        if (topLevel && (at(EQ) || at(COLON))) return true;\n                        if (topLevel && at(IDENTIFIER)) {\n                            IElementType lookahead = lookahead(1);\n                            return lookahead != LT && lookahead != DOT && lookahead != SAFE_ACCESS && lookahead != QUEST;\n                        }\n                        return false;\n                    }\n                }));\n\n        parseReceiverType(\"property\", propertyNameFollow, lastDot);\n\n        myBuilder.restoreJoiningComplexTokensState();\n\n        if (at(COLON)) {\n            advance(); // COLON\n            if (!parseIdeTemplate()) {\n                parseTypeRef();\n            }\n        }\n\n        parseTypeConstraintsGuarded(typeParametersDeclared);\n\n        if (local) {\n            if (at(EQ)) {\n                advance(); // EQ\n                myExpressionParsing.parseExpression();\n                // \"val a = 1; b\" must not be an infix call of b on \"val ...;\"\n            }\n        }\n        else {\n            if (at(EQ)) {\n                advance(); // EQ\n                myExpressionParsing.parseExpression();\n                consumeIf(SEMICOLON);\n            }\n\n            if (parsePropertyGetterOrSetter()) {\n                parsePropertyGetterOrSetter();\n            }\n            if  (!atSet(EOL_OR_SEMICOLON, RBRACE)) {\n                if (getLastToken() != SEMICOLON) {\n                    errorUntil(\"Property getter or setter expected\", TokenSet.create(EOL_OR_SEMICOLON));\n                }\n            }\n            else {\n                consumeIf(SEMICOLON);\n            }\n        }\n\n\n        return PROPERTY;\n    }","commit_id":"e2a3ada02dce0528042c69e28efee3fd5a76ab06","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public SearchScope getUseScope() {\n        if (isLocal()) {\n            PsiElement block = PsiTreeUtil.getParentOfType(this, JetBlockExpression.class, JetClassInitializer.class);\n            if (block == null) return super.getUseScope();\n            else return new LocalSearchScope(block);\n        }   else return super.getUseScope();\n    }","id":78496,"modified_method":"@NotNull\n    @Override\n    public SearchScope getUseScope() {\n        if (isLocal()) {\n            @SuppressWarnings(\"unchecked\") PsiElement block = PsiTreeUtil.getParentOfType(this, JetBlockExpression.class, JetClassInitializer.class);\n            if (block == null) return super.getUseScope();\n            else return new LocalSearchScope(block);\n        }   else return super.getUseScope();\n    }","commit_id":"e2a3ada02dce0528042c69e28efee3fd5a76ab06","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public boolean isLocal() {\n        PsiElement parent = getParent();\n        return !(parent instanceof JetFile || parent instanceof JetClassBody || parent instanceof JetNamespaceBody);\n    }","id":78497,"modified_method":"public boolean isLocal() {\n        PsiJetPropertyStub stub = getStub();\n        if (stub != null) {\n            return stub.isLocal();\n        }\n\n        PsiElement parent = getParent();\n        return !(parent instanceof JetFile || parent instanceof JetClassBody || parent instanceof JetNamespaceBody);\n    }","commit_id":"e2a3ada02dce0528042c69e28efee3fd5a76ab06","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public ASTNode getValOrVarNode() {\n        return getNode().findChildByType(TokenSet.create(VAL_KEYWORD, VAR_KEYWORD));\n    }","id":78498,"modified_method":"@NotNull\n    public ASTNode getValOrVarNode() {\n        ASTNode node = getNode().findChildByType(TokenSet.create(VAL_KEYWORD, VAR_KEYWORD));\n        assert node != null : \"Val or var should always exist for property\";\n        return node;\n    }","commit_id":"e2a3ada02dce0528042c69e28efee3fd5a76ab06","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public boolean isVar() {\n        return getNode().findChildByType(JetTokens.VAR_KEYWORD) != null;\n    }","id":78499,"modified_method":"public boolean isVar() {\n        PsiJetPropertyStub stub = getStub();\n        if (stub != null) {\n            return stub.isVar();\n        }\n\n        return getNode().findChildByType(JetTokens.VAR_KEYWORD) != null;\n    }","commit_id":"e2a3ada02dce0528042c69e28efee3fd5a76ab06","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void refresh() {\n      super.refresh();\n      myAuthorField.setText(null);\n      myAuthorDate = null;\n      reset();\n    }","id":78500,"modified_method":"@Override\n    public void refresh() {\n      myAmendComponent.refresh();\n      myAuthorField.setText(null);\n      myAuthorDate = null;\n      reset();\n    }","commit_id":"2feb9cd1fa7fbf60b9d8b7a6e19829a8c7a3344c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void saveState() {\n      String author = myAuthorField.getText();\n      if (StringUtil.isEmptyOrSpaces(author)) {\n        myNextCommitAuthor = null;\n      }\n      else {\n        myNextCommitAuthor = GitCommitAuthorCorrector.correct(author);\n        mySettings.saveCommitAuthor(myNextCommitAuthor);\n      }\n      myNextCommitAmend = myAmend.isSelected();\n      myNextCommitAuthorDate = myAuthorDate;\n    }","id":78501,"modified_method":"@Override\n    public void saveState() {\n      String author = myAuthorField.getText();\n      if (StringUtil.isEmptyOrSpaces(author)) {\n        myNextCommitAuthor = null;\n      }\n      else {\n        myNextCommitAuthor = GitCommitAuthorCorrector.correct(author);\n        mySettings.saveCommitAuthor(myNextCommitAuthor);\n      }\n      myNextCommitAmend = myAmendComponent.isAmend();\n      myNextCommitAuthorDate = myAuthorDate;\n    }","commit_id":"2feb9cd1fa7fbf60b9d8b7a6e19829a8c7a3344c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"GitCheckinOptions(@NotNull final Project project, @NotNull CheckinProjectPanel panel) {\n      super(project, panel);\n      myVcs = GitVcs.getInstance(project);\n      final Insets insets = JBUI.insets(2);\n      // add authors drop down\n      GridBagConstraints c = new GridBagConstraints();\n      c.gridx = 0;\n      c.gridy = 0;\n      c.anchor = GridBagConstraints.WEST;\n      c.insets = insets;\n      final JLabel authorLabel = new JLabel(GitBundle.message(\"commit.author\"));\n      myPanel.add(authorLabel, c);\n\n      c = new GridBagConstraints();\n      c.anchor = GridBagConstraints.CENTER;\n      c.insets = insets;\n      c.gridx = 1;\n      c.gridy = 0;\n      c.weightx = 1;\n      c.fill = GridBagConstraints.HORIZONTAL;\n\n      Set<String> authors = new HashSet<>(getUsersList(project));\n      addAll(authors, mySettings.getCommitAuthors());\n      List<String> list = new ArrayList<>(authors);\n      Collections.sort(list);\n\n      myAuthorField = createTextField(project, list);\n\n      authorLabel.setLabelFor(myAuthorField);\n      myAuthorField.setToolTipText(GitBundle.getString(\"commit.author.tooltip\"));\n      myPanel.add(myAuthorField, c);\n    }","id":78502,"modified_method":"GitCheckinOptions(@NotNull Project project, @NotNull CheckinProjectPanel panel) {\n      myVcs = assertNotNull(GitVcs.getInstance(project));\n\n      myAuthorField = createTextField(project, getAuthors(project));\n      myAuthorField.setToolTipText(GitBundle.getString(\"commit.author.tooltip\"));\n      JLabel authorLabel = new JBLabel(GitBundle.message(\"commit.author\"));\n      authorLabel.setLabelFor(myAuthorField);\n\n      myAmendComponent = new MyAmendComponent(project, panel);\n\n      GridBag gb = new GridBag().\n        setDefaultAnchor(GridBagConstraints.WEST).\n        setDefaultInsets(JBUI.insets(2));\n      myPanel = new JPanel(new GridBagLayout());\n      myPanel.add(authorLabel, gb.nextLine().next());\n      myPanel.add(myAuthorField, gb.next().fillCellHorizontally().weightx(1));\n      myPanel.add(myAmendComponent.getComponent(), gb.nextLine().next().coverLine());\n    }","commit_id":"2feb9cd1fa7fbf60b9d8b7a6e19829a8c7a3344c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void refresh() {\n      super.refresh();\n      restoreState();\n    }","id":78503,"modified_method":"@Override\n    public void refresh() {\n      myAmend.refresh();\n      restoreState();\n    }","commit_id":"2feb9cd1fa7fbf60b9d8b7a6e19829a8c7a3344c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void saveState() {\n      myNextCommitAmend = myAmend.isSelected();\n      myShouldCommitSubrepos = myCommitSubrepos.isSelected();\n    }","id":78504,"modified_method":"@Override\n    public void saveState() {\n      myNextCommitAmend = myAmend.isAmend();\n      myShouldCommitSubrepos = myCommitSubrepos.isSelected();\n    }","commit_id":"2feb9cd1fa7fbf60b9d8b7a6e19829a8c7a3344c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public HgCommitAdditionalComponent(@NotNull Project project, @NotNull CheckinProjectPanel panel) {\n      super(project, panel);\n      HgVcs myVcs = HgVcs.getInstance(myProject);\n      myAmend.setEnabled(myVcs != null && myVcs.getVersion().isAmendSupported());\n      myAmend.setText(myAmend.getText() + \" (QRefresh)\");\n      final Insets insets = JBUI.insets(2);\n      // add commit subrepos checkbox\n      GridBagConstraints c = new GridBagConstraints();\n      c.anchor = GridBagConstraints.CENTER;\n      c.insets = insets;\n      c.gridx = 1;\n      c.gridy = 2;\n      c.weightx = 1;\n      c.fill = GridBagConstraints.HORIZONTAL;\n      myCommitSubrepos = new JCheckBox(\"Commit subrepositories\", false);\n      myCommitSubrepos.setToolTipText(XmlStringUtil.wrapInHtml(\n        \"Commit all subrepos for selected repositories.<br>\" +\n        \" <code>hg ci <i><b>files<\/b><\/i> -S <i><b>subrepos<\/b><\/i><\/code>\"));\n      myCommitSubrepos.setMnemonic('s');\n      myPanel.add(myCommitSubrepos, c);\n      Collection<HgRepository> repos =\n        HgActionUtil.collectRepositoriesFromFiles(HgUtil.getRepositoryManager(myProject), myCheckinPanel.getRoots());\n      myCommitSubrepos.setVisible(ContainerUtil.exists(repos, new Condition<HgRepository>() {\n        @Override\n        public boolean value(HgRepository repository) {\n          return repository.hasSubrepos();\n        }\n      }));\n      myCommitSubrepos.addActionListener(new MySelectionListener(myAmend));\n      myAmend.addActionListener(new MySelectionListener(myCommitSubrepos));\n    }","id":78505,"modified_method":"public HgCommitAdditionalComponent(@NotNull Project project, @NotNull CheckinProjectPanel panel) {\n      HgVcs myVcs = HgVcs.getInstance(myProject);\n\n      myAmend = new MyAmendComponent(project, panel, \"Amend Commit (QRefresh)\");\n      myAmend.getComponent().setEnabled(myVcs != null && myVcs.getVersion().isAmendSupported());\n\n      myCommitSubrepos = new JCheckBox(\"Commit subrepositories\", false);\n      myCommitSubrepos.setToolTipText(XmlStringUtil.wrapInHtml(\n        \"Commit all subrepos for selected repositories.<br>\" +\n        \" <code>hg ci <i><b>files<\/b><\/i> -S <i><b>subrepos<\/b><\/i><\/code>\"));\n      myCommitSubrepos.setMnemonic('s');\n      Collection<HgRepository> repos = HgActionUtil.collectRepositoriesFromFiles(HgUtil.getRepositoryManager(myProject), panel.getRoots());\n      myCommitSubrepos.setVisible(ContainerUtil.exists(repos, HgRepository::hasSubrepos));\n\n      myCommitSubrepos.addActionListener(new MySelectionListener(myAmend.getCheckBox()));\n      myAmend.getCheckBox().addActionListener(new MySelectionListener(myCommitSubrepos));\n\n      GridBag gb = new GridBag().\n        setDefaultInsets(JBUI.insets(2)).\n        setDefaultAnchor(GridBagConstraints.WEST).\n        setDefaultWeightX(1).\n        setDefaultFill(GridBagConstraints.HORIZONTAL);\n      myPanel = new JPanel(new GridBagLayout());\n      myPanel.add(myAmend.getComponent(), gb.nextLine().next());\n      myPanel.add(myCommitSubrepos, gb.nextLine().next());\n    }","commit_id":"2feb9cd1fa7fbf60b9d8b7a6e19829a8c7a3344c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addGui(final DownloadDialog gui) {\n        buildDownloadAreaInputFields();\n        final JPanel dlg = new JPanel(new GridBagLayout());\n\n        tfOsmUrl.getDocument().addDocumentListener(new OsmUrlRefresher());\n\n        // select content on receiving focus. this seems to be the default in the\n        // windows look+feel but not for others. needs invokeLater to avoid strange\n        // side effects that will cancel out the newly made selection otherwise.\n        tfOsmUrl.addFocusListener(new SelectAllOnFocusHandler(tfOsmUrl));\n        tfOsmUrl.setLineWrap(true);\n        tfOsmUrl.setBorder(latlon[0].getBorder());\n\n        dlg.add(new JLabel(tr(\"min lat\")), GBC.std().insets(10,20,5,0));\n        dlg.add(latlon[0], GBC.std().insets(0,20,0,0));\n        dlg.add(new JLabel(tr(\"min lon\")), GBC.std().insets(10,20,5,0));\n        dlg.add(latlon[1], GBC.eol().insets(0,20,0,0));\n        dlg.add(new JLabel(tr(\"max lat\")), GBC.std().insets(10,0,5,0));\n        dlg.add(latlon[2], GBC.std());\n        dlg.add(new JLabel(tr(\"max lon\")), GBC.std().insets(10,0,5,0));\n        dlg.add(latlon[3], GBC.eol());\n\n        dlg.add(new JLabel(tr(\"URL from www.openstreetmap.org (you can paste an URL here to download the area)\")), GBC.eol().insets(10,20,5,0));\n        dlg.add(tfOsmUrl, GBC.eop().insets(10,0,5,0).fill());\n        tfOsmUrl.addMouseListener(\n                new MouseAdapter() {\n                    @Override\n                    public void mousePressed(MouseEvent e) {\n                        checkPopup(e);\n                    }\n\n                    @Override\n                    public void mouseClicked(MouseEvent e) {\n                        checkPopup(e);\n                    }\n\n                    @Override\n                    public void mouseReleased(MouseEvent e) {\n                        checkPopup(e);\n                    }\n\n                    private void checkPopup(MouseEvent e) {\n                        if (e.isPopupTrigger()) {\n                            OsmUrlPopup popup = new OsmUrlPopup();\n                            popup.show(tfOsmUrl, e.getX(), e.getY());\n                        }\n                    }\n                }\n        );\n        dlg.add(showUrl, GBC.eop().insets(10,0,5,5));\n        showUrl.setEditable(false);\n        showUrl.setBackground(dlg.getBackground());\n        showUrl.addFocusListener(new SelectAllOnFocusHandler(showUrl));\n\n        gui.addDownloadAreaSelector(dlg, tr(\"Bounding Box\"));\n        this.parent = gui;\n    }","id":78506,"modified_method":"public void addGui(final DownloadDialog gui) {\n        buildDownloadAreaInputFields();\n        final JPanel dlg = new JPanel(new GridBagLayout());\n\n        tfOsmUrl.getDocument().addDocumentListener(new OsmUrlRefresher());\n\n        // select content on receiving focus. this seems to be the default in the\n        // windows look+feel but not for others. needs invokeLater to avoid strange\n        // side effects that will cancel out the newly made selection otherwise.\n        tfOsmUrl.addFocusListener(new SelectAllOnFocusHandler(tfOsmUrl));\n        tfOsmUrl.setLineWrap(true);\n        tfOsmUrl.setBorder(latlon[0].getBorder());\n\n        dlg.add(new JLabel(tr(\"min lat\")), GBC.std().insets(10,20,5,0));\n        dlg.add(latlon[0], GBC.std().insets(0,20,0,0));\n        dlg.add(new JLabel(tr(\"min lon\")), GBC.std().insets(10,20,5,0));\n        dlg.add(latlon[1], GBC.eol().insets(0,20,0,0));\n        dlg.add(new JLabel(tr(\"max lat\")), GBC.std().insets(10,0,5,0));\n        dlg.add(latlon[2], GBC.std());\n        dlg.add(new JLabel(tr(\"max lon\")), GBC.std().insets(10,0,5,0));\n        dlg.add(latlon[3], GBC.eol());\n\n        final JButton btnClear = new JButton(tr(\"Clear textarea\"));\n        btnClear.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent arg0) {\n                tfOsmUrl.setText(\"\");\n            }\n        });\n        dlg.add(btnClear, GBC.eol().insets(10,20,0,0));\n\n        dlg.add(new JLabel(tr(\"URL from www.openstreetmap.org (you can paste an URL here to download the area)\")), GBC.eol().insets(10,5,5,0));\n        dlg.add(tfOsmUrl, GBC.eop().insets(10,0,5,0).fill());\n        tfOsmUrl.addMouseListener(\n                new MouseAdapter() {\n                    @Override\n                    public void mousePressed(MouseEvent e) {\n                        checkPopup(e);\n                    }\n\n                    @Override\n                    public void mouseClicked(MouseEvent e) {\n                        checkPopup(e);\n                    }\n\n                    @Override\n                    public void mouseReleased(MouseEvent e) {\n                        checkPopup(e);\n                    }\n\n                    private void checkPopup(MouseEvent e) {\n                        if (e.isPopupTrigger()) {\n                            OsmUrlPopup popup = new OsmUrlPopup();\n                            popup.show(tfOsmUrl, e.getX(), e.getY());\n                        }\n                    }\n                }\n        );\n        dlg.add(showUrl, GBC.eop().insets(10,0,5,5));\n        showUrl.setEditable(false);\n        showUrl.setBackground(dlg.getBackground());\n        showUrl.addFocusListener(new SelectAllOnFocusHandler(showUrl));\n\n        gui.addDownloadAreaSelector(dlg, tr(\"Bounding Box\"));\n        this.parent = gui;\n    }","commit_id":"2648216b0ec9cb38291cbb2c20866e1b36ba2c09","url":"https://github.com/openstreetmap/josm"},{"original_method":"public MainMenu() {\r\n\t\tfileMenu.setMnemonic('F');\r\n\t\tfileMenu.add(newAction);\r\n\t\tfileMenu.add(open);\r\n\t\tfileMenu.add(save);\r\n\t\tfileMenu.add(saveAs);\r\n\t\tfileMenu.add(gpxExport);\r\n\t\tfileMenu.addSeparator();\r\n\t\tfileMenu.add(exit);\r\n\t\tadd(fileMenu);\r\n\r\n\t\teditMenu.setMnemonic('E');\r\n\t\teditMenu.add(undo);\r\n\t\teditMenu.add(redo);\r\n\t\teditMenu.addSeparator();\r\n\t\teditMenu.add(selectAll);\r\n\t\teditMenu.add(unselectAll);\r\n\t\teditMenu.addSeparator();\r\n\t\teditMenu.add(search);\r\n\t\teditMenu.addSeparator();\r\n\t\teditMenu.add(preferences);\r\n\t\tadd(editMenu);\r\n\t\t\r\n\t\tviewMenu.setMnemonic('V');\r\n\t\tviewMenu.setVisible(false);\r\n\t\tviewMenu.add(zoomToMenu);\r\n\t\tfor (String mode : AutoScaleAction.modes)\r\n\t\t\tzoomToMenu.add(new AutoScaleAction(mode));\r\n\t\tadd(viewMenu);\r\n\r\n\t\ttoolsMenu.setMnemonic('T');\r\n\t\ttoolsMenu.add(alignInCircle);\r\n\t\ttoolsMenu.add(alignInLine);\r\n\t\ttoolsMenu.addSeparator();\r\n\t\ttoolsMenu.add(reverseWay);\r\n\t\ttoolsMenu.addSeparator();\r\n\t\ttoolsMenu.add(splitWay);\r\n\t\ttoolsMenu.add(combineWay);\r\n\t\tadd(toolsMenu);\r\n\r\n\t\tconnectionMenu.setMnemonic('C');\r\n\t\tconnectionMenu.add(download);\r\n\t\tconnectionMenu.add(upload);\r\n\t\tadd(connectionMenu);\r\n\r\n\t\tlayerMenu.setMnemonic('L');\r\n\t\tadd(layerMenu);\r\n\t\tlayerMenu.setVisible(false);\r\n\r\n\t\tJMenuItem check = new JMenuItem(\"DEBUG: Check Dataset\");\r\n\t\tcheck.addActionListener(new ActionListener(){\r\n\t\t\tpublic void actionPerformed(ActionEvent e) {\r\n\t\t\t\tDataSetChecker.check();\r\n            }\r\n\t\t});\r\n\t\thelpMenu.add(check);\r\n\r\n\t\thelpMenu.setMnemonic('H');\r\n\t\thelpMenu.add(help);\r\n\t\thelpMenu.add(about);\r\n\t\tadd(helpMenu);\r\n    }","id":78507,"modified_method":"public MainMenu() {\r\n\t\tfileMenu.setMnemonic('F');\r\n\t\tfileMenu.add(newAction);\r\n\t\tfileMenu.add(open);\r\n\t\tfileMenu.add(save);\r\n\t\tfileMenu.add(saveAs);\r\n\t\tfileMenu.add(gpxExport);\r\n\t\tfileMenu.addSeparator();\r\n\t\tfileMenu.add(exit);\r\n\t\tadd(fileMenu);\r\n\r\n\t\teditMenu.setMnemonic('E');\r\n\t\teditMenu.add(undo);\r\n\t\teditMenu.add(redo);\r\n\t\teditMenu.addSeparator();\r\n\t\teditMenu.add(selectAll);\r\n\t\teditMenu.add(unselectAll);\r\n\t\teditMenu.addSeparator();\r\n\t\teditMenu.add(search);\r\n\t\teditMenu.addSeparator();\r\n\t\teditMenu.add(preferences);\r\n\t\tadd(editMenu);\r\n\t\t\r\n\t\tviewMenu.setMnemonic('V');\r\n\t\tviewMenu.setVisible(false);\r\n\t\tviewMenu.add(zoomToMenu);\r\n\t\tfor (String mode : AutoScaleAction.modes)\r\n\t\t\tzoomToMenu.add(new AutoScaleAction(mode));\r\n\t\tadd(viewMenu);\r\n\r\n\t\ttoolsMenu.setMnemonic('T');\r\n\t\ttoolsMenu.add(alignInCircle);\r\n\t\ttoolsMenu.add(alignInLine);\r\n\t\ttoolsMenu.addSeparator();\r\n\t\ttoolsMenu.add(reverseWay);\r\n\t\ttoolsMenu.addSeparator();\r\n\t\ttoolsMenu.add(splitWay);\r\n\t\ttoolsMenu.add(combineWay);\r\n\t\tadd(toolsMenu);\r\n\r\n\t\tconnectionMenu.setMnemonic('C');\r\n\t\tconnectionMenu.add(download);\r\n\t\tconnectionMenu.add(upload);\r\n\t\tadd(connectionMenu);\r\n\r\n\t\tlayerMenu.setMnemonic('L');\r\n\t\tadd(layerMenu);\r\n\t\tlayerMenu.setVisible(false);\r\n\n\t\tadd(presetsMenu);\n\t\t\r\n\t\tJMenuItem check = new JMenuItem(\"DEBUG: Check Dataset\");\r\n\t\tcheck.addActionListener(new ActionListener(){\r\n\t\t\tpublic void actionPerformed(ActionEvent e) {\r\n\t\t\t\tDataSetChecker.check();\r\n            }\r\n\t\t});\r\n\t\thelpMenu.add(check);\r\n\r\n\t\thelpMenu.setMnemonic('H');\r\n\t\thelpMenu.add(help);\r\n\t\thelpMenu.add(about);\r\n\t\tadd(helpMenu);\n\t\t\n    }","commit_id":"2aca21162059132c365072029c4242cab2117d73","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void addGui(PreferenceDialog gui) {\r\n\t\tfor (int i = 0; i < projectionCombo.getItemCount(); ++i) {\r\n\t\t\tif (projectionCombo.getItemAt(i).getClass().getName().equals(Main.pref.get(\"projection\"))) {\r\n\t\t\t\tprojectionCombo.setSelectedIndex(i);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tprojectionCombo.addActionListener(gui.requireRestartAction);\r\n\r\n\t\tgui.map.add(new JLabel(tr(\"Projection method\")), GBC.std());\r\n\t\tgui.map.add(GBC.glue(5,0), GBC.std().fill(GBC.HORIZONTAL));\r\n\t\tgui.map.add(projectionCombo, GBC.eop().fill(GBC.HORIZONTAL).insets(0,0,0,5));\r\n    }","id":78508,"modified_method":"public void addGui(PreferenceDialog gui) {\r\n\t\tfor (int i = 0; i < projectionCombo.getItemCount(); ++i) {\r\n\t\t\tif (projectionCombo.getItemAt(i).getClass().getName().equals(Main.pref.get(\"projection\"))) {\r\n\t\t\t\tprojectionCombo.setSelectedIndex(i);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tprojectionCombo.addActionListener(gui.requireRestartAction);\r\n\t\t\n\t\tJPanel projPanel = new JPanel();\n\t\tprojPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(Color.gray), tr(\"Map Projection\")));\n\t\tprojPanel.setLayout(new GridBagLayout());\r\n\t\tprojPanel.add(new JLabel(tr(\"Projection method\")), GBC.std().insets(5,5,0,5));\r\n\t\tprojPanel.add(GBC.glue(5,0), GBC.std().fill(GBC.HORIZONTAL));\r\n\t\tprojPanel.add(projectionCombo, GBC.eop().fill(GBC.HORIZONTAL).insets(0,5,5,5));\n\t\tgui.map.add(projPanel, GBC.eol().insets(0,0,0,10).fill(GBC.HORIZONTAL));\r\n    }","commit_id":"2aca21162059132c365072029c4242cab2117d73","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * Create a new PropertiesDialog\n\t */\n\tpublic PropertiesDialog(MapFrame mapFrame) {\n\t\tsuper(tr(\"Properties/Memberships\"), \"propertiesdialog\", tr(\"Properties for selected objects.\"), KeyEvent.VK_P, 150);\n\n\t\tif (TaggingPresetPreference.taggingPresets.size() > 0) {\n\t\t\tVector<ActionListener> allPresets = new Vector<ActionListener>();\n\t\t\tfor (final TaggingPreset p : TaggingPresetPreference.taggingPresets)\n\t\t\t\tallPresets.add(new ForwardActionListener(this, p));\n\n\t\t\tallPresets.add(0, new ForwardActionListener(this, new TaggingPreset()));\n\t\t\ttaggingPresets.setModel(new DefaultComboBoxModel(allPresets));\n\t\t\tJPanel north = new JPanel(new GridBagLayout());\n\t\t\tnorth.add(getComponent(0),GBC.eol().fill(GBC.HORIZONTAL));\n\t\t\tnorth.add(taggingPresets,GBC.eol().fill(GBC.HORIZONTAL));\n\t\t\tadd(north, BorderLayout.NORTH);\n\t\t}\n\t\ttaggingPresets.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tTaggingPreset preset = ((ForwardActionListener)taggingPresets.getSelectedItem()).preset;\n\t\t\t\tpreset.actionPerformed(e);\n\t\t\t\ttaggingPresets.setSelectedItem(null);\n\t\t\t}\n\t\t});\n\t\ttaggingPresets.setRenderer(new TaggingCellRenderer());\n\n\t\t// setting up the properties table\n\t\t\n\t\tpropertyData.setColumnIdentifiers(new String[]{tr(\"Key\"),tr(\"Value\")});\n\t\tpropertyTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\t\n\t\tpropertyTable.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer(){\n\t\t\t@Override public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n\t\t\t\tComponent c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n\t\t\t\tif (c instanceof JLabel) {\n\t\t\t\t\tString str = ((JComboBox) value).getEditor().getItem().toString();\n\t\t\t\t\t((JLabel)c).setText(str);\n\t\t\t\t\tif (str.equals(tr(\"<different>\")))\n\t\t\t\t\t\tc.setFont(c.getFont().deriveFont(Font.ITALIC));\n\t\t\t\t}\n\t\t\t\treturn c;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// setting up the membership table\n\t\t\n\t\tmembershipData.setColumnIdentifiers(new String[]{tr(\"Member Of\"),tr(\"Role\")});\n\t\tmembershipTable.setRowSelectionAllowed(false);\n\t\t\n\t\tmembershipTable.getColumnModel().getColumn(0).setCellRenderer(new DefaultTableCellRenderer() {\n\t\t\t@Override public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n\t\t\t\tComponent c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n\t\t\t\tif (c instanceof JLabel) {\n\t\t\t\t\tnameVisitor.visit((Relation)value);\n\t\t\t\t\t((JLabel)c).setText(nameVisitor.name);\n\t\t\t\t}\n\t\t\t\treturn c;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// combine both tables and wrap them in a scrollPane\n\t\tJPanel bothTables = new JPanel();\n\t\tbothTables.setLayout(new GridBagLayout());\n\t\tbothTables.add(propertyTable.getTableHeader(), GBC.eol().fill(GBC.HORIZONTAL));\n\t\tbothTables.add(propertyTable, GBC.eol().fill(GBC.BOTH));\n\t\tbothTables.add(membershipTable.getTableHeader(), GBC.eol().fill(GBC.HORIZONTAL));\n\t\tbothTables.add(membershipTable, GBC.eol().fill(GBC.BOTH));\n\t\t\n\t\tDblClickWatch dblClickWatch = new DblClickWatch();\n\t\tpropertyTable.addMouseListener(dblClickWatch);\n\t\tmembershipTable.addMouseListener(dblClickWatch);\n\t\tJScrollPane scrollPane = new JScrollPane(bothTables);\n\t\tscrollPane.addMouseListener(dblClickWatch);\n\t\tadd(scrollPane, BorderLayout.CENTER);\n\n\t\tJPanel buttonPanel = new JPanel(new GridLayout(1,3));\n\t\tActionListener buttonAction = new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tint sel = propertyTable.getSelectedRow();\n\t\t\t\tif (e.getActionCommand().equals(\"Add\"))\n\t\t\t\t\tadd();\n\t\t\t\telse if (e.getActionCommand().equals(\"Edit\")) {\n\t\t\t\t\tif (sel == -1)\n\t\t\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Please select the row to edit.\"));\n\t\t\t\t\telse\n\t\t\t\t\t\tpropertyEdit(sel);\n\t\t\t\t} else if (e.getActionCommand().equals(\"Delete\")) {\n\t\t\t\t\tif (sel == -1)\n\t\t\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Please select the row to delete.\"));\n\t\t\t\t\telse\n\t\t\t\t\t\tdelete(sel);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tbuttonPanel.add(createButton(marktr(\"Add\"),tr(\"Add a new key/value pair to all objects\"), KeyEvent.VK_A, buttonAction));\n\t\tbuttonPanel.add(createButton(marktr(\"Edit\"),tr( \"Edit the value of the selected key for all objects\"), KeyEvent.VK_E, buttonAction));\n\t\tbuttonPanel.add(createButton(marktr(\"Delete\"),tr(\"Delete the selected key in all objects\"), KeyEvent.VK_D, buttonAction));\n\t\tadd(buttonPanel, BorderLayout.SOUTH);\n\n\t\tDataSet.selListeners.add(this);\n\t}","id":78509,"modified_method":"/**\n\t * Create a new PropertiesDialog\n\t */\n\tpublic PropertiesDialog(MapFrame mapFrame) {\n\t\tsuper(tr(\"Properties/Memberships\"), \"propertiesdialog\", tr(\"Properties for selected objects.\"), KeyEvent.VK_P, 150);\n\n\t\t// ---------------------------------------\n\t\t// This drop-down will probably be removed soon.\n\t\t//\n\t\tif (TaggingPresetPreference.taggingPresets.size() > 0) {\n\t\t\tVector<ActionListener> allPresets = new Vector<ActionListener>();\n\t\t\tfor (final TaggingPreset p : TaggingPresetPreference.taggingPresets)\n\t\t\t\tallPresets.add(new ForwardActionListener(this, p));\n\n\t\t\tTaggingPreset empty = new TaggingPreset();\n\t\t\t// empty.setName(\"this drop-down will be removed soon\");\n\t\t\tallPresets.add(0, new ForwardActionListener(this, empty));\n\t\t\ttaggingPresets.setModel(new DefaultComboBoxModel(allPresets));\n\t\t\tJPanel north = new JPanel(new GridBagLayout());\n\t\t\tnorth.add(getComponent(0),GBC.eol().fill(GBC.HORIZONTAL));\n\t\t\tnorth.add(taggingPresets,GBC.eol().fill(GBC.HORIZONTAL));\n\t\t\tadd(north, BorderLayout.NORTH);\n\t\t}\n\t\ttaggingPresets.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tTaggingPreset preset = ((ForwardActionListener)taggingPresets.getSelectedItem()).preset;\n\t\t\t\tpreset.actionPerformed(e);\n\t\t\t\ttaggingPresets.setSelectedItem(null);\n\t\t\t}\n\t\t});\n\t\ttaggingPresets.setRenderer(new TaggingCellRenderer());\n\t\t\n\t\t// End of \"will be removed soon\".\n\t\t// --------------------------------------------\n\n\t\t// setting up the properties table\n\t\t\n\t\tpropertyData.setColumnIdentifiers(new String[]{tr(\"Key\"),tr(\"Value\")});\n\t\tpropertyTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\t\n\t\tpropertyTable.getColumnModel().getColumn(1).setCellRenderer(new DefaultTableCellRenderer(){\n\t\t\t@Override public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n\t\t\t\tComponent c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n\t\t\t\tif (c instanceof JLabel) {\n\t\t\t\t\tString str = ((JComboBox) value).getEditor().getItem().toString();\n\t\t\t\t\t((JLabel)c).setText(str);\n\t\t\t\t\tif (str.equals(tr(\"<different>\")))\n\t\t\t\t\t\tc.setFont(c.getFont().deriveFont(Font.ITALIC));\n\t\t\t\t}\n\t\t\t\treturn c;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// setting up the membership table\n\t\t\n\t\tmembershipData.setColumnIdentifiers(new String[]{tr(\"Member Of\"),tr(\"Role\")});\n\t\tmembershipTable.setRowSelectionAllowed(false);\n\t\t\n\t\tmembershipTable.getColumnModel().getColumn(0).setCellRenderer(new DefaultTableCellRenderer() {\n\t\t\t@Override public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n\t\t\t\tComponent c = super.getTableCellRendererComponent(table, value, isSelected, false, row, column);\n\t\t\t\tif (c instanceof JLabel) {\n\t\t\t\t\tnameVisitor.visit((Relation)value);\n\t\t\t\t\t((JLabel)c).setText(nameVisitor.name);\n\t\t\t\t}\n\t\t\t\treturn c;\n\t\t\t}\n\t\t});\n\t\t\n\t\t// combine both tables and wrap them in a scrollPane\n\t\tJPanel bothTables = new JPanel();\n\t\tbothTables.setLayout(new GridBagLayout());\n\t\tbothTables.add(propertyTable.getTableHeader(), GBC.eol().fill(GBC.HORIZONTAL));\n\t\tbothTables.add(propertyTable, GBC.eol().fill(GBC.BOTH));\n\t\tbothTables.add(membershipTable.getTableHeader(), GBC.eol().fill(GBC.HORIZONTAL));\n\t\tbothTables.add(membershipTable, GBC.eol().fill(GBC.BOTH));\n\t\t\n\t\tDblClickWatch dblClickWatch = new DblClickWatch();\n\t\tpropertyTable.addMouseListener(dblClickWatch);\n\t\tmembershipTable.addMouseListener(dblClickWatch);\n\t\tJScrollPane scrollPane = new JScrollPane(bothTables);\n\t\tscrollPane.addMouseListener(dblClickWatch);\n\t\tadd(scrollPane, BorderLayout.CENTER);\n\n\t\tJPanel buttonPanel = new JPanel(new GridLayout(1,3));\n\t\tActionListener buttonAction = new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tint sel = propertyTable.getSelectedRow();\n\t\t\t\tif (e.getActionCommand().equals(\"Add\"))\n\t\t\t\t\tadd();\n\t\t\t\telse if (e.getActionCommand().equals(\"Edit\")) {\n\t\t\t\t\tif (sel == -1)\n\t\t\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Please select the row to edit.\"));\n\t\t\t\t\telse\n\t\t\t\t\t\tpropertyEdit(sel);\n\t\t\t\t} else if (e.getActionCommand().equals(\"Delete\")) {\n\t\t\t\t\tif (sel == -1)\n\t\t\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Please select the row to delete.\"));\n\t\t\t\t\telse\n\t\t\t\t\t\tdelete(sel);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tbuttonPanel.add(createButton(marktr(\"Add\"),tr(\"Add a new key/value pair to all objects\"), KeyEvent.VK_A, buttonAction));\n\t\tbuttonPanel.add(createButton(marktr(\"Edit\"),tr( \"Edit the value of the selected key for all objects\"), KeyEvent.VK_E, buttonAction));\n\t\tbuttonPanel.add(createButton(marktr(\"Delete\"),tr(\"Delete the selected key in all objects\"), KeyEvent.VK_D, buttonAction));\n\t\tadd(buttonPanel, BorderLayout.SOUTH);\n\n\t\tDataSet.selListeners.add(this);\n\t}","commit_id":"2aca21162059132c365072029c4242cab2117d73","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n\t * Called from the XML parser to set the icon\n\t */\n\tpublic void setIcon(String iconName) {\n\t\tImageIcon icon = ImageProvider.getIfAvailable(null, iconName);\n\t\tif (icon == null)\n\t\t\ticon = new ImageIcon(iconName);\n\t\tif (Math.max(icon.getIconHeight(), icon.getIconWidth()) != 24)\n\t\t\ticon = new ImageIcon(icon.getImage().getScaledInstance(24, 24, Image.SCALE_SMOOTH));\n\t\tputValue(Action.SMALL_ICON, icon);\n\t}","id":78510,"modified_method":"/**\n\t * Called from the XML parser to set the icon\n\t * \n\t * FIXME for Java 1.6 - use 24x24 icons for LARGE_ICON_KEY (button bar)\n\t * and the 16x16 icons for SMALL_ICON.\n\t */\n\tpublic void setIcon(String iconName) {\n\t\tImageIcon icon = ImageProvider.getIfAvailable(null, iconName);\n\t\tif (icon == null)\n\t\t\ticon = new ImageIcon(iconName);\n\t\tif (Math.max(icon.getIconHeight(), icon.getIconWidth()) != 16)\n\t\t\ticon = new ImageIcon(icon.getImage().getScaledInstance(16, 16, Image.SCALE_SMOOTH));\n\t\tputValue(Action.SMALL_ICON, icon);\n\t}","commit_id":"2aca21162059132c365072029c4242cab2117d73","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static Collection<TaggingPreset> readFromPreferences() {\n\t\tLinkedList<TaggingPreset> allPresets = new LinkedList<TaggingPreset>();\n\t\tString allTaggingPresets = Main.pref.get(\"taggingpreset.sources\");\n\t\tStringTokenizer st = new StringTokenizer(allTaggingPresets, \";\");\n\t\twhile (st.hasMoreTokens()) {\n\t\t\tInputStream in = null;\n\t\t\tString source = st.nextToken();\n\t\t\ttry {\n\t\t\t\tif (source.startsWith(\"http\") || source.startsWith(\"ftp\") || source.startsWith(\"file\"))\n\t\t\t\t\tin = new URL(source).openStream();\n\t\t\t\telse if (source.startsWith(\"resource://\"))\n\t\t\t\t\tin = Main.class.getResourceAsStream(source.substring(\"resource:/\".length()));\n\t\t\t\telse\n\t\t\t\t\tin = new FileInputStream(source);\n\t\t\t\tallPresets.addAll(TaggingPreset.readAll(in));\n\t\t\t\tin.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Could not read tagging preset source: {0}\",source));\n\t\t\t} catch (SAXException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Error parsing {0}: \", source)+e.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn allPresets;\n\t}","id":78511,"modified_method":"public static Collection<TaggingPreset> readFromPreferences() {\n\t\tLinkedList<TaggingPreset> allPresets = new LinkedList<TaggingPreset>();\n\t\tString allTaggingPresets = Main.pref.get(\"taggingpreset.sources\");\n\t\t\n\t\tif (Main.pref.getBoolean(\"taggingpreset.enable-defaults\")) {\n\t\t\tInputStream in = Main.class.getResourceAsStream(\"/presets/presets.xml\");\n\t\t\ttry {\n\t\t\t\tallPresets.addAll(TaggingPreset.readAll(in));\n\t\t\t} catch (SAXException x) {\n\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Error parsing presets.xml: \")+x.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(allTaggingPresets, \";\");\n\t\twhile (st.hasMoreTokens()) {\n\t\t\tInputStream in = null;\n\t\t\tString source = st.nextToken();\n\t\t\ttry {\n\t\t\t\tif (source.startsWith(\"http\") || source.startsWith(\"ftp\") || source.startsWith(\"file\"))\n\t\t\t\t\tin = new URL(source).openStream();\n\t\t\t\telse if (source.startsWith(\"resource://\")) \n\t\t\t\t\tin = Main.class.getResourceAsStream(source.substring(\"resource:/\".length()));\n\t\t\t\telse\n\t\t\t\t\tin = new FileInputStream(source);\n\t\t\t\tallPresets.addAll(TaggingPreset.readAll(in));\n\t\t\t\tin.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Could not read tagging preset source: {0}\",source));\n\t\t\t} catch (SAXException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Error parsing {0}: \", source)+e.getMessage());\n\t\t\t}\n\t\t}\n\t\treturn allPresets;\n\t}","commit_id":"2aca21162059132c365072029c4242cab2117d73","url":"https://github.com/openstreetmap/josm"},{"original_method":"/** \n\t * Initialize the tagging presets (load and may display error)\n\t */\n\tpublic static void initialize() {\n\t\ttaggingPresets = TaggingPreset.readFromPreferences();\n\t}","id":78512,"modified_method":"/** \n\t * Initialize the tagging presets (load and may display error)\n\t */\n\tpublic static void initialize() {\n\t\ttaggingPresets = TaggingPreset.readFromPreferences();\n\t\tfor (final TaggingPreset p : taggingPresets) {\n\t\t\tif (p.getValue(Action.NAME).equals(\" \")) {\n\t\t\t\tMain.main.menu.presetsMenu.add(new JSeparator());\n\t\t\t} else {\n\t\t\t\tMain.main.menu.presetsMenu.add(new JMenuItem(p));\n\t\t\t}\n\t\t}\t\t\n\t}","commit_id":"2aca21162059132c365072029c4242cab2117d73","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void addGui(final PreferenceDialog gui) {\n\t\ttaggingPresetSources = new JList(new DefaultListModel());\n\t\tString annos = Main.pref.get(\"taggingpreset.sources\");\n\t\tStringTokenizer st = new StringTokenizer(annos, \";\");\n\t\twhile (st.hasMoreTokens())\n\t\t\t((DefaultListModel)taggingPresetSources.getModel()).addElement(st.nextToken());\n\n\t\tJButton addAnno = new JButton(tr(\"Add\"));\n\t\taddAnno.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tString source = JOptionPane.showInputDialog(Main.parent, tr(\"Tagging preset source\"));\n\t\t\t\tif (source == null)\n\t\t\t\t\treturn;\n\t\t\t\t((DefaultListModel)taggingPresetSources.getModel()).addElement(source);\n\t\t\t\tgui.requiresRestart = true;\n\t\t\t}\n\t\t});\n\n\t\tJButton editAnno = new JButton(tr(\"Edit\"));\n\t\teditAnno.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif (taggingPresetSources.getSelectedIndex() == -1)\n\t\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Please select the row to edit.\"));\n\t\t\t\telse {\n\t\t\t\t\tString source = JOptionPane.showInputDialog(Main.parent, tr(\"Tagging preset source\"), taggingPresetSources.getSelectedValue());\n\t\t\t\t\tif (source == null)\n\t\t\t\t\t\treturn;\n\t\t\t\t\t((DefaultListModel)taggingPresetSources.getModel()).setElementAt(source, taggingPresetSources.getSelectedIndex());\n\t\t\t\t\tgui.requiresRestart = true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tJButton deleteAnno = new JButton(tr(\"Delete\"));\n\t\tdeleteAnno.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif (taggingPresetSources.getSelectedIndex() == -1)\n\t\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Please select the row to delete.\"));\n\t\t\t\telse {\n\t\t\t\t\t((DefaultListModel)taggingPresetSources.getModel()).remove(taggingPresetSources.getSelectedIndex());\n\t\t\t\t\tgui.requiresRestart = true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttaggingPresetSources.setVisibleRowCount(3);\n\n\t\ttaggingPresetSources.setToolTipText(tr(\"The sources (url or filename) of tagging preset definition files. See http://josm.openstreetmap.de/wiki/TaggingPresets for help.\"));\n\t\taddAnno.setToolTipText(tr(\"Add a new tagging preset source to the list.\"));\n\t\tdeleteAnno.setToolTipText(tr(\"Delete the selected source from the list.\"));\n\n\t\tgui.map.add(new JLabel(tr(\"Tagging preset sources\")), GBC.eol().insets(0,5,0,0));\n\t\tgui.map.add(new JScrollPane(taggingPresetSources), GBC.eol().fill(GBC.BOTH));\n\t\tJPanel buttonPanel = new JPanel(new GridBagLayout());\n\t\tgui.map.add(buttonPanel, GBC.eol().fill(GBC.HORIZONTAL));\n\t\tbuttonPanel.add(Box.createHorizontalGlue(), GBC.std().fill(GBC.HORIZONTAL));\n\t\tbuttonPanel.add(addAnno, GBC.std().insets(0,5,0,0));\n\t\tbuttonPanel.add(editAnno, GBC.std().insets(5,5,5,0));\n\t\tbuttonPanel.add(deleteAnno, GBC.std().insets(0,5,0,0));\n\t}","id":78513,"modified_method":"public void addGui(final PreferenceDialog gui) {\n\t\t\n\t\ttaggingPresetSources = new JList(new DefaultListModel());\n\t\tenableDefault = new JCheckBox(tr(\"Enable built-in defaults\"), \n\t\t\t\tMain.pref.getBoolean(\"taggingpreset.enable-defaults\"));\n\n\t\tString annos = Main.pref.get(\"taggingpreset.sources\");\n\t\tStringTokenizer st = new StringTokenizer(annos, \";\");\n\t\twhile (st.hasMoreTokens())\n\t\t\t((DefaultListModel)taggingPresetSources.getModel()).addElement(st.nextToken());\n\n\t\tJButton addAnno = new JButton(tr(\"Add\"));\n\t\taddAnno.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tString source = JOptionPane.showInputDialog(Main.parent, tr(\"Tagging preset source\"));\n\t\t\t\tif (source == null)\n\t\t\t\t\treturn;\n\t\t\t\t((DefaultListModel)taggingPresetSources.getModel()).addElement(source);\n\t\t\t\tgui.requiresRestart = true;\n\t\t\t}\n\t\t});\n\n\t\tJButton editAnno = new JButton(tr(\"Edit\"));\n\t\teditAnno.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif (taggingPresetSources.getSelectedIndex() == -1)\n\t\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Please select the row to edit.\"));\n\t\t\t\telse {\n\t\t\t\t\tString source = JOptionPane.showInputDialog(Main.parent, tr(\"Tagging preset source\"), taggingPresetSources.getSelectedValue());\n\t\t\t\t\tif (source == null)\n\t\t\t\t\t\treturn;\n\t\t\t\t\t((DefaultListModel)taggingPresetSources.getModel()).setElementAt(source, taggingPresetSources.getSelectedIndex());\n\t\t\t\t\tgui.requiresRestart = true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tJButton deleteAnno = new JButton(tr(\"Delete\"));\n\t\tdeleteAnno.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tif (taggingPresetSources.getSelectedIndex() == -1)\n\t\t\t\t\tJOptionPane.showMessageDialog(Main.parent, tr(\"Please select the row to delete.\"));\n\t\t\t\telse {\n\t\t\t\t\t((DefaultListModel)taggingPresetSources.getModel()).remove(taggingPresetSources.getSelectedIndex());\n\t\t\t\t\tgui.requiresRestart = true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\ttaggingPresetSources.setVisibleRowCount(3);\n\n\t\ttaggingPresetSources.setToolTipText(tr(\"The sources (url or filename) of tagging preset definition files. See http://josm.openstreetmap.de/wiki/TaggingPresets for help.\"));\n\t\taddAnno.setToolTipText(tr(\"Add a new tagging preset source to the list.\"));\n\t\tdeleteAnno.setToolTipText(tr(\"Delete the selected source from the list.\"));\n\n\t\tJPanel tpPanel = new JPanel();\n\t\ttpPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createLineBorder(Color.gray), tr(\"Tagging Presets\")));\n\t\ttpPanel.setLayout(new GridBagLayout());\n\t\ttpPanel.add(enableDefault, GBC.eol().insets(5,5,5,0));\n\t\ttpPanel.add(new JLabel(tr(\"Tagging preset sources\")), GBC.eol().insets(5,5,5,0));\n\t\ttpPanel.add(new JScrollPane(taggingPresetSources), GBC.eol().insets(5,0,5,0).fill(GBC.BOTH));\n\t\tJPanel buttonPanel = new JPanel(new GridBagLayout());\n\t\ttpPanel.add(buttonPanel, GBC.eol().insets(5,0,5,5).fill(GBC.HORIZONTAL));\n\t\tbuttonPanel.add(Box.createHorizontalGlue(), GBC.std().fill(GBC.HORIZONTAL));\n\t\tbuttonPanel.add(addAnno, GBC.std().insets(0,5,0,0));\n\t\tbuttonPanel.add(editAnno, GBC.std().insets(5,5,5,0));\n\t\tbuttonPanel.add(deleteAnno, GBC.std().insets(0,5,0,0));\n\t\tgui.map.add(tpPanel, GBC.eol().fill(GBC.BOTH));\n\t}","commit_id":"2aca21162059132c365072029c4242cab2117d73","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void ok() {\n\t\tif (taggingPresetSources.getModel().getSize() > 0) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < taggingPresetSources.getModel().getSize(); ++i)\n\t\t\t\tsb.append(\";\"+taggingPresetSources.getModel().getElementAt(i));\n\t\t\tMain.pref.put(\"taggingpreset.sources\", sb.toString().substring(1));\n\t\t} else\n\t\t\tMain.pref.put(\"taggingpreset.sources\", null);\n\t}","id":78514,"modified_method":"public void ok() {\n\t\tMain.pref.put(\"taggingpreset.enable-defaults\", enableDefault.getSelectedObjects() != null);\n\t\tif (taggingPresetSources.getModel().getSize() > 0) {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < taggingPresetSources.getModel().getSize(); ++i)\n\t\t\t\tsb.append(\";\"+taggingPresetSources.getModel().getElementAt(i));\n\t\t\tMain.pref.put(\"taggingpreset.sources\", sb.toString().substring(1));\n\t\t} else\n\t\t\tMain.pref.put(\"taggingpreset.sources\", null);\n\t}","commit_id":"2aca21162059132c365072029c4242cab2117d73","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void actionPerformed(ActionEvent e) {\n        \n        // create the popUp window to display progress\n        String title = \"Indexing files in \" + name;\n\n        final JFrame frame = new JFrame(title);\n        final JDialog popUpWindow = new JDialog(frame, title, true); // to make the popUp Window  modal\n\n        // initialize panel\n        final IndexProgressPanel panel = new IndexProgressPanel();\n\n        final SwingWorker task = new SwingWorker<Integer, String>() {\n\n            @Override\n            protected Integer doInBackground() throws Exception {\n                Ingester ingester = solrCore.getIngester();\n\n                Collection<FsContent> files = c.accept(new GetIngestableFilesContentVisitor());\n\n                setProgress(0);\n\n                // track number complete or with errors\n                int fileCount = files.size();\n                int finishedFiles = 0;\n                int problemFiles = 0;\n                \n                for (FsContent f : files) {\n                    if (isCancelled()) {\n                        return problemFiles;\n                    }\n\n                    this.publish(\"Indexing \" + (finishedFiles + 1) + \"/\" + fileCount + \": \" + f.getName());\n\n                    try {\n                        ingester.ingest(f);\n                    } catch (IngesterException ex) {\n                        logger.log(Level.INFO, \"Ingester had a problem with file '\" + f.getName() + \"' (id: \" + f.getId() + \").\", ex);\n                        problemFiles++;\n                    }\n\n                    setProgress(++finishedFiles * 100 / fileCount);\n                }\n\n                ingester.commit();\n\n                return problemFiles;\n            }\n\n            @Override\n            protected void done() {\n                int problemFiles = 0;\n                \n                try {\n                    if (!this.isCancelled()) {\n                        problemFiles = get();\n                    }\n\n                } catch (InterruptedException ex) {\n                    // shouldn't be interrupted except by cancel\n                    throw new RuntimeException(ex);\n                } catch (ExecutionException ex) {\n                    logger.log(Level.SEVERE, \"Fatal error during ingest.\", ex);\n                } finally {\n                    popUpWindow.setVisible(false);\n                    popUpWindow.dispose();\n                    \n                    // notify user if there were problem files\n                    if (problemFiles > 0) {\n                        displayProblemFilesDialog(problemFiles);\n                    }\n                }\n            }\n\n            @Override\n            protected void process(List<String> messages) {\n\n                // display the latest message\n                if (!messages.isEmpty()) {\n                    panel.setStatusText(messages.get(messages.size() - 1));\n                }\n\n                panel.setProgressBar(getProgress());\n            }\n        };\n\n        panel.addCancelButtonActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                task.cancel(true);\n            }\n        });\n\n        popUpWindow.add(panel);\n        popUpWindow.pack();\n        popUpWindow.setResizable(false);\n\n        // set the location of the popUp Window on the center of the screen\n        Dimension screenDimension = Toolkit.getDefaultToolkit().getScreenSize();\n        double w = popUpWindow.getSize().getWidth();\n        double h = popUpWindow.getSize().getHeight();\n        popUpWindow.setLocation((int) ((screenDimension.getWidth() - w) / 2), (int) ((screenDimension.getHeight() - h) / 2));\n\n        popUpWindow.addWindowListener(new WindowAdapter() {\n\n            @Override\n            public void windowClosing(WindowEvent e) {\n                // deal with being Xed out of\n                if (!task.isDone()) {\n                    task.cancel(true);\n                }\n            }\n        });\n\n\n        task.execute();\n        // display the window\n        popUpWindow.setVisible(true);\n    }","id":78515,"modified_method":"@Override\n    public void actionPerformed(ActionEvent e) {\n\n        // create the popUp window to display progress\n        String title = \"Indexing files in \" + name;\n\n        final JFrame frame = new JFrame(title);\n        final JDialog popUpWindow = new JDialog(frame, title, true); // to make the popUp Window  modal\n\n        // initialize panel\n        final IndexProgressPanel panel = new IndexProgressPanel();\n\n        final SwingWorker task = new SwingWorker<Integer, String>() {\n\n            @Override\n            protected Integer doInBackground() throws Exception {\n                Ingester ingester = solrCore.getIngester();\n\n                Collection<FsContent> files = c.accept(new GetIngestableFilesContentVisitor());\n\n                setProgress(0);\n\n                // track number complete or with errors\n                int fileCount = files.size();\n                int finishedFiles = 0;\n                int problemFiles = 0;\n\n                for (FsContent f : files) {\n                    if (isCancelled()) {\n                        return problemFiles;\n                    }\n\n                    this.publish(\"Indexing \" + (finishedFiles + 1) + \"/\" + fileCount + \": \" + f.getName());\n\n                    try {\n                        ingester.ingest(f);\n                    } catch (IngesterException ex) {\n                        logger.log(Level.INFO, \"Ingester had a problem with file '\" + f.getName() + \"' (id: \" + f.getId() + \").\", ex);\n                        problemFiles++;\n                    }\n\n                    setProgress(++finishedFiles * 100 / fileCount);\n                }\n\n                ingester.commit();\n\n                try {\n                    final int numIndexedFiles = KeywordSearch.getServer().getCore().queryNumIndexedFiles();\n                    KeywordSearch.changeSupport.firePropertyChange(KeywordSearch.NUM_FILES_CHANGE_EVT, null, new Integer(numIndexedFiles));\n                } catch (SolrServerException se) {\n                    logger.log(Level.SEVERE, \"Error executing Solr query, \" + se.getMessage());\n                }\n\n                return problemFiles;\n            }\n\n            @Override\n            protected void done() {\n                int problemFiles = 0;\n\n                try {\n                    if (!this.isCancelled()) {\n                        problemFiles = get();\n                    }\n\n                } catch (InterruptedException ex) {\n                    // shouldn't be interrupted except by cancel\n                    throw new RuntimeException(ex);\n                } catch (ExecutionException ex) {\n                    logger.log(Level.SEVERE, \"Fatal error during ingest.\", ex);\n                } finally {\n                    popUpWindow.setVisible(false);\n                    popUpWindow.dispose();\n\n                    // notify user if there were problem files\n                    if (problemFiles > 0) {\n                        displayProblemFilesDialog(problemFiles);\n                    }\n                }\n            }\n\n            @Override\n            protected void process(List<String> messages) {\n\n                // display the latest message\n                if (!messages.isEmpty()) {\n                    panel.setStatusText(messages.get(messages.size() - 1));\n                }\n\n                panel.setProgressBar(getProgress());\n            }\n        };\n\n        panel.addCancelButtonActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                task.cancel(true);\n            }\n        });\n\n        popUpWindow.add(panel);\n        popUpWindow.pack();\n        popUpWindow.setResizable(false);\n\n        // set the location of the popUp Window on the center of the screen\n        Dimension screenDimension = Toolkit.getDefaultToolkit().getScreenSize();\n        double w = popUpWindow.getSize().getWidth();\n        double h = popUpWindow.getSize().getHeight();\n        popUpWindow.setLocation((int) ((screenDimension.getWidth() - w) / 2), (int) ((screenDimension.getHeight() - h) / 2));\n\n        popUpWindow.addWindowListener(new WindowAdapter() {\n\n            @Override\n            public void windowClosing(WindowEvent e) {\n                // deal with being Xed out of\n                if (!task.isDone()) {\n                    task.cancel(true);\n                }\n            }\n        });\n\n\n        task.execute();\n        // display the window\n        popUpWindow.setVisible(true);\n    }","commit_id":"71fafdb6bd761b7455b7b0983d130730ab32cc49","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public KeywordSearchDataExplorer() {\n        this.setTheInstance();\n        this.tc = new KeywordSearchTopComponent();\n        this.tc.addSearchButtonListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                tc.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                try {\n                    search(tc.getQueryText());\n                } finally {\n                    tc.setCursor(null);\n                }\n            }\n        });\n    }","id":78516,"modified_method":"public KeywordSearchDataExplorer() {\n        this.setTheInstance();\n        this.tc = new KeywordSearchTopComponent();\n        this.tc.addSearchButtonListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                tc.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                try {\n                    search(tc.getQueryText());\n                } finally {\n                    tc.setCursor(null);\n                }\n            }\n        });\n\n        KeywordSearch.changeSupport.addPropertyChangeListener(KeywordSearch.NUM_FILES_CHANGE_EVT, new IndexChangeListener());\n    }","commit_id":"71fafdb6bd761b7455b7b0983d130730ab32cc49","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        queryTextArea = new javax.swing.JTextArea();\n        searchButton = new javax.swing.JButton();\n        queryLabel = new javax.swing.JLabel();\n\n        queryTextArea.setColumns(20);\n        queryTextArea.setRows(5);\n        jScrollPane1.setViewportView(queryTextArea);\n\n        searchButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.searchButton.text\")); // NOI18N\n\n        queryLabel.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.queryLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(queryLabel))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 302, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(searchButton)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(queryLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(18, 18, 18)\n                .addComponent(searchButton)\n                .addContainerGap(132, Short.MAX_VALUE))\n        );\n    }","id":78517,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        queryTextArea = new javax.swing.JTextArea();\n        searchButton = new javax.swing.JButton();\n        queryLabel = new javax.swing.JLabel();\n        filesIndexedNameLabel = new javax.swing.JLabel();\n        filesIndexedValLabel = new javax.swing.JLabel();\n\n        queryTextArea.setColumns(20);\n        queryTextArea.setRows(5);\n        jScrollPane1.setViewportView(queryTextArea);\n\n        searchButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.searchButton.text\")); // NOI18N\n\n        queryLabel.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.queryLabel.text\")); // NOI18N\n\n        filesIndexedNameLabel.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.filesIndexedNameLabel.text\")); // NOI18N\n\n        filesIndexedValLabel.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.filesIndexedValLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(queryLabel)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 599, Short.MAX_VALUE)\n                    .addComponent(searchButton)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(filesIndexedNameLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(filesIndexedValLabel)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(queryLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(18, 18, 18)\n                .addComponent(searchButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(filesIndexedNameLabel)\n                    .addComponent(filesIndexedValLabel))\n                .addContainerGap(107, Short.MAX_VALUE))\n        );\n\n        filesIndexedNameLabel.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.filesIndexedNameLabel.AccessibleContext.accessibleName\")); // NOI18N\n        filesIndexedValLabel.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.filesIndexedValLabel.AccessibleContext.accessibleName\")); // NOI18N\n    }","commit_id":"71fafdb6bd761b7455b7b0983d130730ab32cc49","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** Creates new form KeywordSearchTopComponent */\n    public KeywordSearchTopComponent() {\n        initComponents();\n        setName(\"Keyword Search\");\n\n        putClientProperty(TopComponent.PROP_CLOSING_DISABLED, Boolean.TRUE);\n    }","id":78518,"modified_method":"/** Creates new form KeywordSearchTopComponent */\n    public KeywordSearchTopComponent() {\n        initComponents();\n        setName(\"Keyword Search\");\n\n        searchButton.setEnabled(false);\n\n        putClientProperty(TopComponent.PROP_CLOSING_DISABLED, Boolean.TRUE);\n\n        //register with server Actions\n        serverChangeListener = new KeywordSearchServerListener();\n        KeywordSearch.getServer().addServerActionListener(serverChangeListener);\n    }","commit_id":"71fafdb6bd761b7455b7b0983d130730ab32cc49","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"void closeCore() {\n        if (currentCore == null) {\n            throw new RuntimeException(\"No currently open Core!\");\n        }\n        currentCore.close();\n        currentCore = null;\n    }","id":78519,"modified_method":"void closeCore() {\n        if (currentCore == null) {\n            throw new RuntimeException(\"No currently open Core!\");\n        }\n        currentCore.close();\n        currentCore = null;\n        serverAction.putValue(CORE_EVT, CORE_EVT_STATES.STOPPED);\n    }","commit_id":"71fafdb6bd761b7455b7b0983d130730ab32cc49","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * New instance for the server at the given URL\n     * @param url should be something like \"http://localhost:8983/solr/\"\n     */\n    Server(String url) {\n        try {\n            this.solr = new CommonsHttpSolrServer(url);\n        } catch (MalformedURLException ex) {\n            throw new RuntimeException(ex);\n        }\n        \n        solrFolder = InstalledFileLocator.getDefault().locate(\"solr\", Server.class.getPackage().getName(), false);\n        instanceDir = solrFolder.getAbsolutePath() + File.separator + \"solr\";\n    }","id":78520,"modified_method":"/**\n     * New instance for the server at the given URL\n     * @param url should be something like \"http://localhost:8983/solr/\"\n     */\n    Server(String url) {\n        try {\n            this.solr = new CommonsHttpSolrServer(url);\n        } catch (MalformedURLException ex) {\n            throw new RuntimeException(ex);\n        }\n        \n        serverAction = new ServerAction();\n        solrFolder = InstalledFileLocator.getDefault().locate(\"solr\", Server.class.getPackage().getName(), false);\n        instanceDir = solrFolder.getAbsolutePath() + File.separator + \"solr\";\n    }","commit_id":"71fafdb6bd761b7455b7b0983d130730ab32cc49","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"void openCore() {\n        if (currentCore != null) {\n            throw new RuntimeException(\"Already an open Core!\");\n        }\n        currentCore = openCore(Case.getCurrentCase());\n    }","id":78521,"modified_method":"void openCore() {\n        if (currentCore != null) {\n            throw new RuntimeException(\"Already an open Core!\");\n        }\n        currentCore = openCore(Case.getCurrentCase());\n        serverAction.putValue(CORE_EVT, CORE_EVT_STATES.STARTED);\n    }","commit_id":"71fafdb6bd761b7455b7b0983d130730ab32cc49","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void actionPerformed(ActionEvent e) {\n        \n        // create the popUp window to display progress\n        String title = \"Indexing files in \" + name;\n\n        final JFrame frame = new JFrame(title);\n        final JDialog popUpWindow = new JDialog(frame, title, true); // to make the popUp Window  modal\n\n        // initialize panel\n        final IndexProgressPanel panel = new IndexProgressPanel();\n\n        final SwingWorker task = new SwingWorker<Integer, String>() {\n\n            @Override\n            protected Integer doInBackground() throws Exception {\n                Ingester ingester = solrCore.getIngester();\n\n                Collection<FsContent> files = c.accept(new GetIngestableFilesContentVisitor());\n\n                setProgress(0);\n\n                // track number complete or with errors\n                int fileCount = files.size();\n                int finishedFiles = 0;\n                int problemFiles = 0;\n                \n                for (FsContent f : files) {\n                    if (isCancelled()) {\n                        return problemFiles;\n                    }\n\n                    this.publish(\"Indexing \" + (finishedFiles + 1) + \"/\" + fileCount + \": \" + f.getName());\n\n                    try {\n                        ingester.ingest(f);\n                    } catch (IngesterException ex) {\n                        logger.log(Level.INFO, \"Ingester had a problem with file '\" + f.getName() + \"' (id: \" + f.getId() + \").\", ex);\n                        problemFiles++;\n                    }\n\n                    setProgress(++finishedFiles * 100 / fileCount);\n                }\n\n                ingester.commit();\n\n                return problemFiles;\n            }\n\n            @Override\n            protected void done() {\n                int problemFiles = 0;\n                \n                try {\n                    if (!this.isCancelled()) {\n                        problemFiles = get();\n                    }\n\n                } catch (InterruptedException ex) {\n                    // shouldn't be interrupted except by cancel\n                    throw new RuntimeException(ex);\n                } catch (ExecutionException ex) {\n                    logger.log(Level.SEVERE, \"Fatal error during ingest.\", ex);\n                } finally {\n                    popUpWindow.setVisible(false);\n                    popUpWindow.dispose();\n                    \n                    // notify user if there were problem files\n                    if (problemFiles > 0) {\n                        displayProblemFilesDialog(problemFiles);\n                    }\n                }\n            }\n\n            @Override\n            protected void process(List<String> messages) {\n\n                // display the latest message\n                if (!messages.isEmpty()) {\n                    panel.setStatusText(messages.get(messages.size() - 1));\n                }\n\n                panel.setProgressBar(getProgress());\n            }\n        };\n\n        panel.addCancelButtonActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                task.cancel(true);\n            }\n        });\n\n        popUpWindow.add(panel);\n        popUpWindow.pack();\n        popUpWindow.setResizable(false);\n\n        // set the location of the popUp Window on the center of the screen\n        Dimension screenDimension = Toolkit.getDefaultToolkit().getScreenSize();\n        double w = popUpWindow.getSize().getWidth();\n        double h = popUpWindow.getSize().getHeight();\n        popUpWindow.setLocation((int) ((screenDimension.getWidth() - w) / 2), (int) ((screenDimension.getHeight() - h) / 2));\n\n        popUpWindow.addWindowListener(new WindowAdapter() {\n\n            @Override\n            public void windowClosing(WindowEvent e) {\n                // deal with being Xed out of\n                if (!task.isDone()) {\n                    task.cancel(true);\n                }\n            }\n        });\n\n\n        task.execute();\n        // display the window\n        popUpWindow.setVisible(true);\n    }","id":78522,"modified_method":"@Override\n    public void actionPerformed(ActionEvent e) {\n\n        // create the popUp window to display progress\n        String title = \"Indexing files in \" + name;\n\n        final JFrame frame = new JFrame(title);\n        final JDialog popUpWindow = new JDialog(frame, title, true); // to make the popUp Window  modal\n\n        // initialize panel\n        final IndexProgressPanel panel = new IndexProgressPanel();\n\n        final SwingWorker task = new SwingWorker<Integer, String>() {\n\n            @Override\n            protected Integer doInBackground() throws Exception {\n                Ingester ingester = solrCore.getIngester();\n\n                Collection<FsContent> files = c.accept(new GetIngestableFilesContentVisitor());\n\n                setProgress(0);\n\n                // track number complete or with errors\n                int fileCount = files.size();\n                int finishedFiles = 0;\n                int problemFiles = 0;\n\n                for (FsContent f : files) {\n                    if (isCancelled()) {\n                        return problemFiles;\n                    }\n\n                    this.publish(\"Indexing \" + (finishedFiles + 1) + \"/\" + fileCount + \": \" + f.getName());\n\n                    try {\n                        ingester.ingest(f);\n                    } catch (IngesterException ex) {\n                        logger.log(Level.INFO, \"Ingester had a problem with file '\" + f.getName() + \"' (id: \" + f.getId() + \").\", ex);\n                        problemFiles++;\n                    }\n\n                    setProgress(++finishedFiles * 100 / fileCount);\n                }\n\n                ingester.commit();\n\n                try {\n                    final int numIndexedFiles = KeywordSearch.getServer().getCore().queryNumIndexedFiles();\n                    KeywordSearch.changeSupport.firePropertyChange(KeywordSearch.NUM_FILES_CHANGE_EVT, null, new Integer(numIndexedFiles));\n                } catch (SolrServerException se) {\n                    logger.log(Level.SEVERE, \"Error executing Solr query, \" + se.getMessage());\n                }\n\n                return problemFiles;\n            }\n\n            @Override\n            protected void done() {\n                int problemFiles = 0;\n\n                try {\n                    if (!this.isCancelled()) {\n                        problemFiles = get();\n                    }\n\n                } catch (InterruptedException ex) {\n                    // shouldn't be interrupted except by cancel\n                    throw new RuntimeException(ex);\n                } catch (ExecutionException ex) {\n                    logger.log(Level.SEVERE, \"Fatal error during ingest.\", ex);\n                } finally {\n                    popUpWindow.setVisible(false);\n                    popUpWindow.dispose();\n\n                    // notify user if there were problem files\n                    if (problemFiles > 0) {\n                        displayProblemFilesDialog(problemFiles);\n                    }\n                }\n            }\n\n            @Override\n            protected void process(List<String> messages) {\n\n                // display the latest message\n                if (!messages.isEmpty()) {\n                    panel.setStatusText(messages.get(messages.size() - 1));\n                }\n\n                panel.setProgressBar(getProgress());\n            }\n        };\n\n        panel.addCancelButtonActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                task.cancel(true);\n            }\n        });\n\n        popUpWindow.add(panel);\n        popUpWindow.pack();\n        popUpWindow.setResizable(false);\n\n        // set the location of the popUp Window on the center of the screen\n        Dimension screenDimension = Toolkit.getDefaultToolkit().getScreenSize();\n        double w = popUpWindow.getSize().getWidth();\n        double h = popUpWindow.getSize().getHeight();\n        popUpWindow.setLocation((int) ((screenDimension.getWidth() - w) / 2), (int) ((screenDimension.getHeight() - h) / 2));\n\n        popUpWindow.addWindowListener(new WindowAdapter() {\n\n            @Override\n            public void windowClosing(WindowEvent e) {\n                // deal with being Xed out of\n                if (!task.isDone()) {\n                    task.cancel(true);\n                }\n            }\n        });\n\n\n        task.execute();\n        // display the window\n        popUpWindow.setVisible(true);\n    }","commit_id":"0e35b91d02f5669e7c5d6d1753df227d7d58dabd","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public KeywordSearchDataExplorer() {\n        this.setTheInstance();\n        this.tc = new KeywordSearchTopComponent();\n        this.tc.addSearchButtonListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                tc.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                try {\n                    search(tc.getQueryText());\n                } finally {\n                    tc.setCursor(null);\n                }\n            }\n        });\n    }","id":78523,"modified_method":"public KeywordSearchDataExplorer() {\n        this.setTheInstance();\n        this.tc = new KeywordSearchTopComponent();\n        this.tc.addSearchButtonListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                tc.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));\n                try {\n                    search(tc.getQueryText());\n                } finally {\n                    tc.setCursor(null);\n                }\n            }\n        });\n\n        KeywordSearch.changeSupport.addPropertyChangeListener(KeywordSearch.NUM_FILES_CHANGE_EVT, new IndexChangeListener());\n    }","commit_id":"0e35b91d02f5669e7c5d6d1753df227d7d58dabd","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        queryTextArea = new javax.swing.JTextArea();\n        searchButton = new javax.swing.JButton();\n        queryLabel = new javax.swing.JLabel();\n\n        queryTextArea.setColumns(20);\n        queryTextArea.setRows(5);\n        jScrollPane1.setViewportView(queryTextArea);\n\n        searchButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.searchButton.text\")); // NOI18N\n\n        queryLabel.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.queryLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(queryLabel))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 302, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addComponent(searchButton)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(queryLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(18, 18, 18)\n                .addComponent(searchButton)\n                .addContainerGap(132, Short.MAX_VALUE))\n        );\n    }","id":78524,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        queryTextArea = new javax.swing.JTextArea();\n        searchButton = new javax.swing.JButton();\n        queryLabel = new javax.swing.JLabel();\n        filesIndexedNameLabel = new javax.swing.JLabel();\n        filesIndexedValLabel = new javax.swing.JLabel();\n\n        queryTextArea.setColumns(20);\n        queryTextArea.setRows(5);\n        jScrollPane1.setViewportView(queryTextArea);\n\n        searchButton.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.searchButton.text\")); // NOI18N\n\n        queryLabel.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.queryLabel.text\")); // NOI18N\n\n        filesIndexedNameLabel.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.filesIndexedNameLabel.text\")); // NOI18N\n\n        filesIndexedValLabel.setText(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.filesIndexedValLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(queryLabel)\n                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 599, Short.MAX_VALUE)\n                    .addComponent(searchButton)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(filesIndexedNameLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(filesIndexedValLabel)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(queryLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(18, 18, 18)\n                .addComponent(searchButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(filesIndexedNameLabel)\n                    .addComponent(filesIndexedValLabel))\n                .addContainerGap(107, Short.MAX_VALUE))\n        );\n\n        filesIndexedNameLabel.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.filesIndexedNameLabel.AccessibleContext.accessibleName\")); // NOI18N\n        filesIndexedValLabel.getAccessibleContext().setAccessibleName(org.openide.util.NbBundle.getMessage(KeywordSearchTopComponent.class, \"KeywordSearchTopComponent.filesIndexedValLabel.AccessibleContext.accessibleName\")); // NOI18N\n    }","commit_id":"0e35b91d02f5669e7c5d6d1753df227d7d58dabd","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** Creates new form KeywordSearchTopComponent */\n    public KeywordSearchTopComponent() {\n        initComponents();\n        setName(\"Keyword Search\");\n\n        putClientProperty(TopComponent.PROP_CLOSING_DISABLED, Boolean.TRUE);\n    }","id":78525,"modified_method":"/** Creates new form KeywordSearchTopComponent */\n    public KeywordSearchTopComponent() {\n        initComponents();\n        setName(\"Keyword Search\");\n\n        searchButton.setEnabled(false);\n\n        putClientProperty(TopComponent.PROP_CLOSING_DISABLED, Boolean.TRUE);\n\n        //register with server Actions\n        serverChangeListener = new KeywordSearchServerListener();\n        KeywordSearch.getServer().addServerActionListener(serverChangeListener);\n    }","commit_id":"0e35b91d02f5669e7c5d6d1753df227d7d58dabd","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"void openCore() {\n        if (currentCore != null) {\n            throw new RuntimeException(\"Already an open Core!\");\n        }\n        currentCore = openCore(Case.getCurrentCase());\n    }","id":78526,"modified_method":"void openCore() {\n        if (currentCore != null) {\n            throw new RuntimeException(\"Already an open Core!\");\n        }\n        currentCore = openCore(Case.getCurrentCase());\n        serverAction.putValue(CORE_EVT, CORE_EVT_STATES.STARTED);\n    }","commit_id":"0e35b91d02f5669e7c5d6d1753df227d7d58dabd","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * New instance for the server at the given URL\n     * @param url should be something like \"http://localhost:8983/solr/\"\n     */\n    Server(String url) {\n        try {\n            this.solr = new CommonsHttpSolrServer(url);\n        } catch (MalformedURLException ex) {\n            throw new RuntimeException(ex);\n        }\n        \n        solrFolder = InstalledFileLocator.getDefault().locate(\"solr\", Server.class.getPackage().getName(), false);\n        instanceDir = solrFolder.getAbsolutePath() + File.separator + \"solr\";\n    }","id":78527,"modified_method":"/**\n     * New instance for the server at the given URL\n     * @param url should be something like \"http://localhost:8983/solr/\"\n     */\n    Server(String url) {\n        try {\n            this.solr = new CommonsHttpSolrServer(url);\n        } catch (MalformedURLException ex) {\n            throw new RuntimeException(ex);\n        }\n        \n        serverAction = new ServerAction();\n        solrFolder = InstalledFileLocator.getDefault().locate(\"solr\", Server.class.getPackage().getName(), false);\n        instanceDir = solrFolder.getAbsolutePath() + File.separator + \"solr\";\n    }","commit_id":"0e35b91d02f5669e7c5d6d1753df227d7d58dabd","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"void closeCore() {\n        if (currentCore == null) {\n            throw new RuntimeException(\"No currently open Core!\");\n        }\n        currentCore.close();\n        currentCore = null;\n    }","id":78528,"modified_method":"void closeCore() {\n        if (currentCore == null) {\n            throw new RuntimeException(\"No currently open Core!\");\n        }\n        currentCore.close();\n        currentCore = null;\n        serverAction.putValue(CORE_EVT, CORE_EVT_STATES.STOPPED);\n    }","commit_id":"0e35b91d02f5669e7c5d6d1753df227d7d58dabd","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public List<Action> visit(FileNode f) {\n            List<Action> actions = new ArrayList<Action>();\n            if(!f.getDirectoryBrowseMode()) {\n                actions.add(new ViewContextAction(\"View File in Directory\", f));\n                actions.add(null); // creates a menu separator\n            }\n            actions.add(new NewWindowViewAction(\"View in New Window\", f));\n            actions.add(new ExternalViewerAction(\"Open in External Viewer\", f));\n            actions.add(null); // creates a menu separator\n            actions.add(new ExtractAction(\"Extract File\", f));\n            actions.add(new HashSearchAction(\"Search for similar MD5\", f));\n            return actions;\n        }","id":78529,"modified_method":"@Override\n        public List<Action> visit(FileNode f) {\n            List<Action> actions = new ArrayList<Action>();\n            if(!f.getDirectoryBrowseMode()) {\n                actions.add(new ViewContextAction(\"View File in Directory\", f));\n                actions.add(null); // creates a menu separator\n            }\n            actions.add(new NewWindowViewAction(\"View in New Window\", f));\n            actions.add(new ExternalViewerAction(\"Open in External Viewer\", f));\n            actions.add(null); // creates a menu separator\n            actions.add(new ExtractAction(\"Extract File\", f));\n            actions.add(new HashSearchAction(\"Search for files with the same MD5 hash\", f));\n            return actions;\n        }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public List<Action> visit(BlackboardArtifactNode ban) {\n            List<Action> actions = new ArrayList<Action>();\n            BlackboardArtifact ba = ban.getLookup().lookup(BlackboardArtifact.class);\n            if(ba.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()\n                    || ba.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n                actions.add(new ViewContextAction(\"View File in Directory\", ban));\n            } else {\n                Content c = findLinked(ban);\n                if (c != null) {\n                    actions.add(new ViewContextAction(\"View File in Directory\", c));\n                }\n                actions.add(new ViewContextAction(\"View Source File in Directory\", ban));\n            }\n            File f = ban.getLookup().lookup(File.class);\n            if(f != null) {\n                actions.add(null); // creates a menu separator\n                actions.add(new NewWindowViewAction(\"View in New Window\", new FileNode(f)));\n                actions.add(new ExternalViewerAction(\"Open in External Viewer\", new FileNode(f)));\n                actions.add(null); // creates a menu separator\n                actions.add(new ExtractAction(\"Extract File\", new FileNode(f)));\n                actions.add(new HashSearchAction(\"Search for similar MD5\", new FileNode(f)));\n            }\n            return actions;\n        }","id":78530,"modified_method":"@Override\n        public List<Action> visit(BlackboardArtifactNode ban) {\n            List<Action> actions = new ArrayList<Action>();\n            BlackboardArtifact ba = ban.getLookup().lookup(BlackboardArtifact.class);\n            if(ba.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_HASHSET_HIT.getTypeID()\n                    || ba.getArtifactTypeID() == BlackboardArtifact.ARTIFACT_TYPE.TSK_KEYWORD_HIT.getTypeID()) {\n                actions.add(new ViewContextAction(\"View File in Directory\", ban));\n            } else {\n                Content c = findLinked(ban);\n                if (c != null) {\n                    actions.add(new ViewContextAction(\"View File in Directory\", c));\n                }\n                actions.add(new ViewContextAction(\"View Source File in Directory\", ban));\n            }\n            File f = ban.getLookup().lookup(File.class);\n            if(f != null) {\n                actions.add(null); // creates a menu separator\n                actions.add(new NewWindowViewAction(\"View in New Window\", new FileNode(f)));\n                actions.add(new ExternalViewerAction(\"Open in External Viewer\", new FileNode(f)));\n                actions.add(null); // creates a menu separator\n                actions.add(new ExtractAction(\"Extract File\", new FileNode(f)));\n                actions.add(new HashSearchAction(\"Search for files with the same MD5 hash\", new FileNode(f)));\n            }\n            return actions;\n        }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Find all files with the same MD5 hash as this' fsContent. fsContent should\n     * be previously set by calling the search function, which in turn calls performAction.\n     */\n    @Override\n    public void performAction() {\n        // Make sure all files have an md5 hash\n        if(HashDbSearcher.isReady()) {\n            // Get the map of hashes to FsContent and send it to the manager\n            List<FsContent> files = HashDbSearcher.findFilesByMd5(fsContent.getMd5Hash());\n            Map<String, List<FsContent>> map = new LinkedHashMap<String, List<FsContent>>();\n            map.put(fsContent.getMd5Hash(), files);\n            HashDbSearchManager man = new HashDbSearchManager(map);\n            man.execute();\n        }\n    }","id":78531,"modified_method":"/**\n     * Find all files with the same MD5 hash as this' fsContent. fsContent should\n     * be previously set by calling the search function, which in turn calls performAction.\n     */\n    @Override\n    public void performAction() {\n        // Make sure all files have an md5 hash\n        if(HashDbSearcher.isReady()) {\n            // Get the map of hashes to FsContent and send it to the manager\n            List<FsContent> files = HashDbSearcher.findFilesByMd5(fsContent.getMd5Hash());\n            for(int i=0; i<files.size(); i++) {\n                try {\n                    // If they are the same file, remove it from the list\n                    if(files.get(i).getUniquePath().equals(fsContent.getUniquePath())) {\n                        files.remove(i);\n                    }\n                } catch (TskCoreException ex) {\n                    Exceptions.printStackTrace(ex);\n                }\n            }\n            if(!files.isEmpty()) {\n                Map<String, List<FsContent>> map = new LinkedHashMap<String, List<FsContent>>();\n                map.put(fsContent.getMd5Hash(), files);\n                HashDbSearchManager man = new HashDbSearchManager(map);\n                man.execute();\n            } else {\n                JOptionPane.showMessageDialog(null, \"No other files with the same MD5 hash were found.\");\n            }\n        }\n    }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Search through all tsk_files to find ones with the same hashes as the\n     * hashes given.\n     */\n    boolean doSearch() {\n        // Make sure all files have an md5 hash\n        if(HashDbSearcher.isReady()) {\n            if(hashTable.getRowCount()!=0) {\n                errorField.setVisible(false);\n                // Get all the rows in the table\n                int numRows = hashTable.getRowCount();\n                ArrayList<String> hashes = new ArrayList<String>();\n                for(int i=0; i<numRows; i++) {\n                    hashes.add((String) hashTable.getValueAt(i, 0));\n                }\n                // Get the map of hashes to FsContent and send it to the manager\n                Map<String, List<FsContent>> map = HashDbSearcher.findFilesBymd5(hashes);\n                HashDbSearchManager man = new HashDbSearchManager(map);\n                man.execute();\n                return true;\n            } else {\n                errorField.setText(\"No hashes have been entered.\");\n                errorField.setVisible(true);\n                return false;\n            }\n        } else {\n            errorField.setText(\"Error: Not all files have been hashed.\");\n            errorField.setVisible(true);\n            return false;\n        }\n    }","id":78532,"modified_method":"/**\n     * Search through all tsk_files to find ones with the same hashes as the\n     * hashes given.\n     */\n    boolean doSearch() {\n        // Make sure all files have an md5 hash\n        if(HashDbSearcher.isReady()) {\n            if(hashTable.getRowCount()!=0) {\n                errorField.setVisible(false);\n                // Get all the rows in the table\n                int numRows = hashTable.getRowCount();\n                ArrayList<String> hashes = new ArrayList<String>();\n                for(int i=0; i<numRows; i++) {\n                    hashes.add((String) hashTable.getValueAt(i, 0));\n                }\n                // Get the map of hashes to FsContent and send it to the manager\n                Map<String, List<FsContent>> map = HashDbSearcher.findFilesBymd5(hashes);\n                HashDbSearchManager man = new HashDbSearchManager(map);\n                man.execute();\n                return true;\n            } else {\n                errorField.setText(\"Error: No hashes have been entered.\");\n                errorField.setVisible(true);\n                return false;\n            }\n        } else {\n            errorField.setText(\"Error: Not all files have been hashed.\");\n            errorField.setVisible(true);\n            return false;\n        }\n    }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        hashTable = new javax.swing.JTable();\n        hashField = new javax.swing.JTextField();\n        addButton = new javax.swing.JButton();\n        hashLabel = new javax.swing.JLabel();\n        searchButton = new javax.swing.JButton();\n        removeButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n        titleLabel = new javax.swing.JLabel();\n        errorField = new javax.swing.JLabel();\n        saveBox = new javax.swing.JCheckBox();\n\n        hashTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n                \"MD5 Hashes\"\n            }\n        ) {\n            Class[] types = new Class [] {\n                java.lang.String.class\n            };\n            boolean[] canEdit = new boolean [] {\n                false\n            };\n\n            public Class getColumnClass(int columnIndex) {\n                return types [columnIndex];\n            }\n\n            public boolean isCellEditable(int rowIndex, int columnIndex) {\n                return canEdit [columnIndex];\n            }\n        });\n        jScrollPane1.setViewportView(hashTable);\n        hashTable.getColumnModel().getColumn(0).setHeaderValue(org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashTable.columnModel.title0\")); // NOI18N\n\n        hashField.setText(org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(addButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.addButton.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashLabel, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(searchButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.searchButton.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(removeButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.removeButton.text\")); // NOI18N\n\n        titleLabel.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(titleLabel, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.titleLabel.text\")); // NOI18N\n\n        errorField.setForeground(new java.awt.Color(255, 0, 0));\n        org.openide.awt.Mnemonics.setLocalizedText(errorField, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.errorField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(saveBox, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.saveBox.text\")); // NOI18N\n        saveBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveBoxActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addGap(0, 0, Short.MAX_VALUE)\n                        .addComponent(errorField)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(searchButton))\n                    .addGroup(layout.createSequentialGroup()\n                        .addContainerGap()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(jScrollPane1)\n                            .addComponent(jSeparator1)\n                            .addGroup(layout.createSequentialGroup()\n                                .addComponent(hashLabel)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(hashField))\n                            .addGroup(layout.createSequentialGroup()\n                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                                    .addComponent(titleLabel)\n                                    .addGroup(layout.createSequentialGroup()\n                                        .addGap(61, 61, 61)\n                                        .addComponent(addButton)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                        .addComponent(removeButton)\n                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                        .addComponent(saveBox)))\n                                .addGap(0, 0, Short.MAX_VALUE)))))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(titleLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 355, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(26, 26, 26)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(hashLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(hashField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(addButton)\n                    .addComponent(removeButton)\n                    .addComponent(saveBox))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 27, Short.MAX_VALUE)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(searchButton)\n                    .addComponent(errorField))\n                .addContainerGap())\n        );\n    }","id":78533,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        hashTable = new javax.swing.JTable();\n        hashField = new javax.swing.JTextField();\n        addButton = new javax.swing.JButton();\n        hashLabel = new javax.swing.JLabel();\n        searchButton = new javax.swing.JButton();\n        removeButton = new javax.swing.JButton();\n        jSeparator1 = new javax.swing.JSeparator();\n        titleLabel = new javax.swing.JLabel();\n        errorField = new javax.swing.JLabel();\n        saveBox = new javax.swing.JCheckBox();\n\n        hashTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n                \"MD5 Hashes\"\n            }\n        ) {\n            Class[] types = new Class [] {\n                java.lang.String.class\n            };\n            boolean[] canEdit = new boolean [] {\n                false\n            };\n\n            public Class getColumnClass(int columnIndex) {\n                return types [columnIndex];\n            }\n\n            public boolean isCellEditable(int rowIndex, int columnIndex) {\n                return canEdit [columnIndex];\n            }\n        });\n        jScrollPane1.setViewportView(hashTable);\n        hashTable.getColumnModel().getColumn(0).setHeaderValue(org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashTable.columnModel.title0\")); // NOI18N\n\n        hashField.setText(org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(addButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.addButton.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(hashLabel, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.hashLabel.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(searchButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.searchButton.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(removeButton, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.removeButton.text\")); // NOI18N\n\n        titleLabel.setFont(new java.awt.Font(\"Tahoma\", 1, 11)); // NOI18N\n        org.openide.awt.Mnemonics.setLocalizedText(titleLabel, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.titleLabel.text\")); // NOI18N\n\n        errorField.setForeground(new java.awt.Color(255, 0, 0));\n        org.openide.awt.Mnemonics.setLocalizedText(errorField, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.errorField.text\")); // NOI18N\n\n        org.openide.awt.Mnemonics.setLocalizedText(saveBox, org.openide.util.NbBundle.getMessage(HashDbSearchPanel.class, \"HashDbSearchPanel.saveBox.text\")); // NOI18N\n        saveBox.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                saveBoxActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jScrollPane1)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(hashLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(hashField))\n                    .addGroup(layout.createSequentialGroup()\n                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                            .addComponent(titleLabel)\n                            .addGroup(layout.createSequentialGroup()\n                                .addGap(61, 61, 61)\n                                .addComponent(addButton)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(removeButton)\n                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                                .addComponent(saveBox)))\n                        .addGap(0, 0, Short.MAX_VALUE))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addComponent(errorField)\n                        .addGap(18, 18, 18)\n                        .addComponent(searchButton))\n                    .addComponent(jSeparator1))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(titleLabel)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 171, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(18, 18, 18)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(hashLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(hashField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(addButton)\n                    .addComponent(removeButton)\n                    .addComponent(saveBox))\n                .addGap(18, 18, 18)\n                .addComponent(jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(searchButton)\n                    .addComponent(errorField))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n    }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Add the given text into the table of hashes.\n     */\n    void add() {\n        DefaultTableModel model = (DefaultTableModel) hashTable.getModel();\n        if(!hashField.getText().equals(\"\")) {\n            model.addRow(new String[] {hashField.getText()});\n            hashField.setText(\"\"); // wipe the field\n        }\n        hashField.requestFocus(); // select the field to type in\n    }","id":78534,"modified_method":"/**\n     * Add the given text into the table of hashes.\n     */\n    void add() {\n        errorField.setVisible(false);\n        DefaultTableModel model = (DefaultTableModel) hashTable.getModel();\n        String hash = hashField.getText();\n        if(!hash.equals(\"\")) {\n            if(hash.matches(\"[a-fA-F0-9]{32}\")) {\n                model.addRow(new String[] {hash});\n                hashField.setText(\"\"); // wipe the field\n            } else {\n                errorField.setText(\"Error: That is not a valid MD5 hash.\");\n                errorField.setVisible(true);\n            }\n        }\n        hashField.requestFocus(); // select the field to type in\n    }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"final void customInit() {\n        addButton.addActionListener(this);\n        removeButton.addActionListener(this);\n        errorField.setVisible(false);\n        hashField.requestFocus();\n        // Pressing enter adds the hash\n        hashField.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                if(e.getKeyChar() == KeyEvent.VK_ENTER) {\n                    addButton.doClick();\n                }\n            }\n        });\n        // Pressing delete removes the selected rows\n        hashTable.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                if(e.getKeyChar() == KeyEvent.VK_DELETE) {\n                    removeButton.doClick();\n                }\n            }\n        });\n    }","id":78535,"modified_method":"final void customInit() {\n        addButton.addActionListener(this);\n        removeButton.addActionListener(this);\n        errorField.setVisible(false);\n        hashField.requestFocus();\n        // Don't let the user input more characters than in an MD5 hash\n        hashField.setDocument(new PlainDocument () {\n            @Override\n            public void insertString(int offset, String str, AttributeSet a) throws BadLocationException {\n                if((this.getLength() + str.length()) <= 32) {\n                    super.insertString(offset, str, a);\n                }\n            }\n        });\n        // Pressing enter adds the hash\n        hashField.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                if(e.getKeyChar() == KeyEvent.VK_ENTER) {\n                    addButton.doClick();\n                }\n            }\n        });\n        // Pressing delete removes the selected rows\n        hashTable.addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                if(e.getKeyChar() == KeyEvent.VK_DELETE) {\n                    removeButton.doClick();\n                }\n            }\n        });\n    }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Given a string hash value, find all files with that hash.\n     * @param md5Hash   hash value to match files with\n     * @return a List of all FsContent with the given hash\n     */\n    static List<FsContent> findFilesByMd5(String md5Hash) {\n        return skCase.findFilesByMd5(md5Hash);\n    }","id":78536,"modified_method":"/**\n     * Given a string hash value, find all files with that hash.\n     * @param md5Hash   hash value to match files with\n     * @return a List of all FsContent with the given hash\n     */\n    static List<FsContent> findFilesByMd5(String md5Hash) {\n        final Case currentCase = Case.getCurrentCase();\n        final SleuthkitCase skCase = currentCase.getSleuthkitCase();\n        return skCase.findFilesByMd5(md5Hash);\n    }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Checks if the search feature is ready/enabled. Does so by checking\n     * if there are no Fs files in tsk_files that have and empty md5.\n     * @return true if the search feature is ready.\n     */\n    static boolean isReady() {\n        return skCase.allFilesMd5Hashed();\n    }","id":78537,"modified_method":"/**\n     * Checks if the search feature is ready/enabled. Does so by checking\n     * if there are no Fs files in tsk_files that have and empty md5.\n     * @return true if the search feature is ready.\n     */\n    static boolean isReady() {\n        final Case currentCase = Case.getCurrentCase();\n        final SleuthkitCase skCase = currentCase.getSleuthkitCase();\n        return skCase.allFilesMd5Hashed();\n    }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public HashSearchAction(String title, Node contentNode) {\r\n        super(title);\r\n        this.contentNode = contentNode;\r\n    }","id":78538,"modified_method":"public HashSearchAction(String title, Node contentNode) {\r\n        super(title);\r\n        this.contentNode = contentNode;\r\n        this.searcher = Lookup.getDefault().lookup(HashSearchProvider.class);\r\n        this.setEnabled(searcher.isReady());\r\n    }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\r\n    public void actionPerformed(ActionEvent e) {\r\n        HashSearchProvider searcher = Lookup.getDefault().lookup(HashSearchProvider.class);\r\n        searcher.search(contentNode);\r\n    }","id":78539,"modified_method":"@Override\r\n    public void actionPerformed(ActionEvent e) {\r\n        //HashSearchProvider searcher = Lookup.getDefault().lookup(HashSearchProvider.class);\r\n        searcher.search(contentNode);\r\n    }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n        public List<Action> visit(File f) {\n            List<Action> actions = new ArrayList<Action>();\n            actions.add(new NewWindowViewAction(\"View in New Window\", KeywordSearchFilterNode.this));\n            actions.add(new ExternalViewerAction(\"Open in External Viewer\", getOriginal()));\n            actions.add(null);\n            actions.add(new ExtractAction(\"Extract File\", getOriginal()));\n            actions.add(new HashSearchAction(\"Search for similar MD5\", getOriginal()));\n            return actions;\n        }","id":78540,"modified_method":"@Override\n        public List<Action> visit(File f) {\n            List<Action> actions = new ArrayList<Action>();\n            actions.add(new NewWindowViewAction(\"View in New Window\", KeywordSearchFilterNode.this));\n            actions.add(new ExternalViewerAction(\"Open in External Viewer\", getOriginal()));\n            actions.add(null);\n            actions.add(new ExtractAction(\"Extract File\", getOriginal()));\n            actions.add(new HashSearchAction(\"Search for files with the same MD5 hash\", getOriginal()));\n            return actions;\n        }","commit_id":"c50fd51747db73809bddf9fa565d328b947587c2","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n         * Starts the addImage process, but does not commit the results. \n         * \n         * @return\n         * @throws Exception \n         */\n        @Override\n        protected Integer doInBackground() throws Exception {\n            this.setProgress(0);\n\n            // Add a cleanup task to interupt the backgroud process if the\n            // wizard exits while the background process is running.\n            AddImageAction.CleanupTask cancelledWhileRunning = action.new CleanupTask() {\n\n                @Override\n                void cleanup() throws Exception {\n                    addImageTask.interrupt();\n                }\n            };\n\n            SleuthkitCase skCase = currentCase.getSleuthkitCase();\n            skCase.clearLookupDatabases();\n\n            if (lookupFilesCheckboxChecked) {\n                if (NSRLPath != null) {\n                    skCase.setNSRLDatabase(NSRLPath);\n                }\n\n                if (knownBadPath != null) {\n                    skCase.setKnownBadDatabase(knownBadPath);\n                }\n            }\n\n            //lock DB for writes in EWT thread\n            //wait until lock acquired in EWT\n            EventQueue.invokeAndWait(new Runnable() {\n                @Override\n                public void run() {\n                    SleuthkitCase.dbWriteLock();\n                }\n            });\n            try {\n                process = currentCase.makeAddImageProcess(Case.convertTimeZone(timeZone), noFatOrphans);\n                cancelledWhileRunning.enable();\n                process.run(imgPaths);\n            } catch (TskException ex) {\n                throw ex;\n            } finally {\n                // process is over, doesn't need to be dealt with if cancel happens\n                cancelledWhileRunning.disable();\n            }\n            this.setProgress(100);\n            return 0;\n        }","id":78541,"modified_method":"/**\n         * Starts the addImage process, but does not commit the results. \n         * \n         * @return\n         * @throws Exception \n         */\n        @Override\n        protected Integer doInBackground() throws Exception {\n            this.setProgress(0);\n\n            // Add a cleanup task to interupt the backgroud process if the\n            // wizard exits while the background process is running.\n            AddImageAction.CleanupTask cancelledWhileRunning = action.new CleanupTask() {\n\n                @Override\n                void cleanup() throws Exception {\n                    addImageTask.interrupt();\n                }\n            };\n\n            //lock DB for writes in EWT thread\n            //wait until lock acquired in EWT\n            EventQueue.invokeAndWait(new Runnable() {\n                @Override\n                public void run() {\n                    SleuthkitCase.dbWriteLock();\n                }\n            });\n            try {\n                process = currentCase.makeAddImageProcess(Case.convertTimeZone(timeZone), noFatOrphans);\n                cancelledWhileRunning.enable();\n                process.run(imgPaths);\n            } catch (TskException ex) {\n                throw ex;\n            } finally {\n                // process is over, doesn't need to be dealt with if cancel happens\n                cancelledWhileRunning.disable();\n            }\n            this.setProgress(100);\n            return 0;\n        }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Checks if Sleuth Kit can open the index for the database path.\n     * @return true if the index was found and opened successfully, else false\n     */\n    boolean indexExists() {\n        try {\n            return hasIndex(databasePath);\n        } catch (TskException ex) {\n            Log.get(this.getClass()).log(Level.WARNING, \"Error checking if index exists.\", ex);\n            return false;\n        }\n    }","id":78542,"modified_method":"/**\n     * Checks if Sleuth Kit can open the index for the database path.\n     * @return true if the index was found and opened successfully, else false\n     */\n    boolean indexExists() {\n        try {\n            return hasIndex(databasePaths.get(0)); // TODO: support multiple paths\n        } catch (TskException ex) {\n            Log.get(this.getClass()).log(Level.WARNING, \"Error checking if index exists.\", ex);\n            return false;\n        }\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Gets the database file.\n     * @return a File initialized with the database path\n     */\n    File databaseFile() {\n        return new File(databasePath);\n    }","id":78543,"modified_method":"/**\n     * Gets the database file.\n     * @return a File initialized with the database path\n     */\n    File databaseFile() {\n        return new File(databasePaths.get(0)); // TODO: support multiple paths\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Gets the index file\n     * @return a File initialized with an index path derived from the database\n     * path\n     */\n    File indexFile() {\n        return new File(toIndexPath(databasePath));\n    }","id":78544,"modified_method":"/**\n     * Gets the index file\n     * @return a File initialized with an index path derived from the database\n     * path\n     */\n    File indexFile() {\n        return new File(toIndexPath(databasePaths.get(0))); // TODO: support multiple paths\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Tries to index the database (overwrites any existing index)\n     * @throws TskException if an error occurs in the SleuthKit bindings \n     */\n    void createIndex() throws TskException {\n        SleuthkitJNI.createLookupIndex(databasePath);\n        //TODO: error checking\n    }","id":78545,"modified_method":"/**\n     * Tries to index the database (overwrites any existing index)\n     * @throws TskException if an error occurs in the SleuthKit bindings \n     */\n    void createIndex() throws TskException {\n        SleuthkitJNI.createLookupIndex(databasePaths.get(0), name); //TODO: fix for multiple paths\n        //TODO: error checking\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * notification from manager that brand new processing should be initiated.\n     * Service loads its configuration and performs initialization\n     * \n     * @param managerProxy handle to the manager to postMessage() to\n     */\n    @Override\n    public void init(IngestManagerProxy managerProxy) {\n        this.process = false;\n        this.managerProxy = managerProxy;\n        this.managerProxy.postMessage(IngestMessage.createMessage(++messageId, IngestMessage.MessageType.INFO, this, \"Started\"));\n        this.skCase = Case.getCurrentCase().getSleuthkitCase();\n        try {\n            HashDbSettings hashDbSettings = HashDbSettings.getHashDbSettings();\n\n            if ((nsrlDbPath = hashDbSettings.getNSRLDatabasePath()) != null && !nsrlDbPath.equals(\"\")) {\n                skCase.setNSRLDatabase(nsrlDbPath);\n                this.process = true;\n            } else {\n                this.managerProxy.postMessage(IngestMessage.createWarningMessage(++messageId, this, \"No NSRL database set\", \"Known file search will not be executed.\"));\n            }\n\n            if ((knownBadDbPath = hashDbSettings.getKnownBadDatabasePath()) != null && !knownBadDbPath.equals(\"\")) {\n                skCase.setKnownBadDatabase(knownBadDbPath);\n                this.process = true;\n            } else {\n                this.managerProxy.postMessage(IngestMessage.createWarningMessage(++messageId, this, \"No known bad database set\", \"Known bad file search will not be executed.\"));\n            }\n\n        } catch (TskException ex) {\n            logger.log(Level.WARNING, \"Setting NSRL and Known database failed\", ex);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, \"Error getting Hash DB settings\", ex);\n        }\n    }","id":78546,"modified_method":"/**\n     * notification from manager that brand new processing should be initiated.\n     * Service loads its configuration and performs initialization\n     * \n     * @param managerProxy handle to the manager to postMessage() to\n     */\n    @Override\n    public void init(IngestManagerProxy managerProxy) {\n        this.process = false;\n        this.managerProxy = managerProxy;\n        this.managerProxy.postMessage(IngestMessage.createMessage(++messageId, IngestMessage.MessageType.INFO, this, \"Started\"));\n        this.skCase = Case.getCurrentCase().getSleuthkitCase();\n        try {\n            HashDbXML hdbxml = HashDbXML.getCurrent();\n            NSRLDbs.clear();\n            notableDbs.clear();\n            skCase.clearLookupDatabases();\n            boolean nsrlsSet = false;\n            boolean notablesSet = false;\n            \n            for(HashDb db : hdbxml.getSets()) {\n                this.process = true;\n                if(db.getType().equals(DBType.NOTABLE) && db.getUseForIngest()) {\n                    notablesSet = true;\n                    skCase.addKnownBadDatabase(db.getDatabasePaths().get(0), db.getName()); // TODO: support multiple paths\n                } else if(db.getType().equals(DBType.NSRL) && db.getUseForIngest()) {\n                    nsrlsSet = true;\n                    skCase.addNSRLDatabase(db.getDatabasePaths().get(0), db.getName()); // TODO: support multiple paths\n                }\n            }\n\n            if (!nsrlsSet) {\n                this.managerProxy.postMessage(IngestMessage.createWarningMessage(++messageId, this, \"No NSRL database set\", \"Known file search will not be executed.\"));\n            }\n            if (!notablesSet) {\n                this.managerProxy.postMessage(IngestMessage.createWarningMessage(++messageId, this, \"No known bad database set\", \"Known bad file search will not be executed.\"));\n            }\n\n        } catch (TskException ex) {\n            logger.log(Level.WARNING, \"Setting NSRL and Known database failed\", ex);\n        }\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * notification from manager that there is no more content to process and all work is done.\n     * Service performs any clean-up, notifies viewers and may also write results to the black-board\n     */\n    @Override\n    public void complete() {\n        StringBuilder detailsSb = new StringBuilder();\n        //details\n        detailsSb.append(\"<table border='0' cellpadding='4' width='280'>\");\n        \n        detailsSb.append(\"<tr>\");\n        detailsSb.append(\"<th>Number of notable files found:<\/th>\");\n        detailsSb.append(\"<td>\").append(count).append(\"<\/td>\");\n        detailsSb.append(\"<\/tr>\");\n\n        detailsSb.append(\"<tr>\");\n        detailsSb.append(\"<th>Notable database used:<\/th>\");\n        detailsSb.append(\"<td>\").append(knownBadDbPath != null ? knownBadDbPath : \"\").append(\"<\/td>\");\n        detailsSb.append(\"<\/tr>\");\n        \n        detailsSb.append(\"<\/table>\");\n        managerProxy.postMessage(IngestMessage.createMessage(++messageId, IngestMessage.MessageType.INFO, this, \"Hash Ingest Complete\", detailsSb.toString()));\n    }","id":78547,"modified_method":"/**\n     * notification from manager that there is no more content to process and all work is done.\n     * Service performs any clean-up, notifies viewers and may also write results to the black-board\n     */\n    @Override\n    public void complete() {\n        StringBuilder detailsSb = new StringBuilder();\n        //details\n        detailsSb.append(\"<table border='0' cellpadding='4' width='280'>\");\n        \n        detailsSb.append(\"<tr>\");\n        detailsSb.append(\"<th>Number of notable files found:<\/th>\");\n        detailsSb.append(\"<td>\").append(count).append(\"<\/td>\");\n        detailsSb.append(\"<\/tr>\");\n\n        detailsSb.append(\"<tr>\");\n        detailsSb.append(\"<th>Notable databases used:<\/th>\");\n        detailsSb.append(\"<\/tr>\");\n        \n        for(HashDb db : notableDbs) {\n            detailsSb.append(\"<tr><th>\");\n            detailsSb.append(db.getName());\n            detailsSb.append(\"<\/th><td>\");\n            detailsSb.append(db.getDatabasePaths().get(0)); // TODO: support multiple database paths\n            detailsSb.append(\"<\/td><\/tr>\");\n        }\n        \n        detailsSb.append(\"<\/table>\");\n        managerProxy.postMessage(IngestMessage.createMessage(++messageId, IngestMessage.MessageType.INFO, this, \"Hash Ingest Complete\", detailsSb.toString()));\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Process the given FsContent object\n     * \n     * @param fsContent the object to be processed\n     * @return ProcessResult OK if file is unknown and should be processed further, otherwise STOP_COND if file is known\n     */\n    @Override\n    public ProcessResult process(FsContent fsContent) {\n        ProcessResult ret = ProcessResult.UNKNOWN;\n        process = true;\n        if(fsContent.getKnown().equals(TskData.FileKnown.BAD)) {\n            ret = ProcessResult.OK;\n            process = false;\n        }\n        if (process) {\n            String name = fsContent.getName();\n            try {\n                String md5Hash = Hash.calculateMd5(fsContent);\n                TskData.FileKnown status = skCase.lookupMd5(md5Hash);\n                boolean changed = skCase.setKnown(fsContent, status);\n                if (status.equals(TskData.FileKnown.BAD)) {\n                    count+=1;\n                    BlackboardArtifact badFile = fsContent.newArtifact(ARTIFACT_TYPE.TSK_HASHSET_HIT);\n                    BlackboardAttribute att2 = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_HASHSET_NAME.getTypeID(), MODULE_NAME, \"Known Bad\", knownBadDbPath);\n                    badFile.addAttribute(att2);\n                    BlackboardAttribute att3 = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_HASH_MD5.getTypeID(), MODULE_NAME, \"\", md5Hash);\n                    badFile.addAttribute(att3);\n                    StringBuilder detailsSb = new StringBuilder();\n                    //details\n                    detailsSb.append(\"<table border='0' cellpadding='4' width='280'>\");\n                    //hit\n                    detailsSb.append(\"<tr>\");\n                    detailsSb.append(\"<th>File Name<\/th>\");\n                    detailsSb.append(\"<td>\").append(name).append(\"<\/td>\");\n                    detailsSb.append(\"<\/tr>\");\n\n                    detailsSb.append(\"<tr>\");\n                    detailsSb.append(\"<th>MD5 Hash<\/th>\");\n                    detailsSb.append(\"<td>\").append(md5Hash).append(\"<\/td>\");\n                    detailsSb.append(\"<\/tr>\");\n\n                    detailsSb.append(\"<tr>\");\n                    detailsSb.append(\"<th>Hashset Name<\/th>\");\n                    detailsSb.append(\"<td>\").append(knownBadDbPath).append(\"<\/td>\");\n                    detailsSb.append(\"<\/tr>\");\n                    \n                    detailsSb.append(\"<\/table>\");\n\n                    managerProxy.postMessage(IngestMessage.createDataMessage(++messageId, this, \"Notable: \" + name, detailsSb.toString(), name+md5Hash, badFile));\n                    IngestManager.fireServiceDataEvent(new ServiceDataEvent(MODULE_NAME, ARTIFACT_TYPE.TSK_HASHSET_HIT, Collections.singletonList(badFile)));\n                    ret = ProcessResult.OK;\n                } else if (status.equals(TskData.FileKnown.KNOWN)) {\n                    ret = ProcessResult.COND_STOP;\n                }\n                else {\n                    ret = ProcessResult.OK;\n                }\n            } catch (TskException ex) {\n                // TODO: This shouldn't be at level INFO, but it needs to be to hide the popup\n                logger.log(Level.WARNING, \"Couldn't analyze file \" + name + \" - see sleuthkit log for details\", ex);\n                managerProxy.postMessage(IngestMessage.createErrorMessage(++messageId, this, \"Hash Lookup Error: \" + name,\n                        \"Error encountered while updating the hash values for \" + name + \".\"));\n                ret = ProcessResult.ERROR;\n            } catch (IOException ex) {\n                // TODO: This shouldn't be at level INFO, but it needs to be to hide the popup\n                logger.log(Level.WARNING, \"Error reading file \" + name, ex);\n                managerProxy.postMessage(IngestMessage.createErrorMessage(++messageId, this, \"Read Error: \" + name,\n                        \"Error encountered while calculating the hash value for \" + name + \".\"));\n                ret = ProcessResult.ERROR;\n            }\n        }\n        return ret;\n    }","id":78548,"modified_method":"/**\n     * Process the given FsContent object\n     * \n     * @param fsContent the object to be processed\n     * @return ProcessResult OK if file is unknown and should be processed further, otherwise STOP_COND if file is known\n     */\n    @Override\n    public ProcessResult process(FsContent fsContent) {\n        ProcessResult ret = ProcessResult.UNKNOWN;\n        process = true;\n        if(fsContent.getKnown().equals(TskData.FileKnown.BAD)) {\n            ret = ProcessResult.OK;\n            process = false;\n        }\n        if (process) {\n            String name = fsContent.getName();\n            try {\n                String md5Hash = Hash.calculateMd5(fsContent);\n                Map<String, TskData.FileKnown> results = skCase.lookupMd5(md5Hash);\n                for (Map.Entry<String, TskData.FileKnown> entry : results.entrySet()) {\n                    String hashSetName = entry.getKey();\n                    TskData.FileKnown status = entry.getValue();\n                    boolean changed = skCase.setKnown(fsContent, status);\n                    if (status.equals(TskData.FileKnown.BAD)) {\n                        count += 1;\n                        BlackboardArtifact badFile = fsContent.newArtifact(ARTIFACT_TYPE.TSK_HASHSET_HIT);\n                        BlackboardAttribute att2 = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_HASHSET_NAME.getTypeID(), MODULE_NAME, \"Known Bad\", hashSetName);\n                        badFile.addAttribute(att2);\n                        BlackboardAttribute att3 = new BlackboardAttribute(ATTRIBUTE_TYPE.TSK_HASH_MD5.getTypeID(), MODULE_NAME, \"\", md5Hash);\n                        badFile.addAttribute(att3);\n                        StringBuilder detailsSb = new StringBuilder();\n                        //details\n                        detailsSb.append(\"<table border='0' cellpadding='4' width='280'>\");\n                        //hit\n                        detailsSb.append(\"<tr>\");\n                        detailsSb.append(\"<th>File Name<\/th>\");\n                        detailsSb.append(\"<td>\").append(name).append(\"<\/td>\");\n                        detailsSb.append(\"<\/tr>\");\n\n                        detailsSb.append(\"<tr>\");\n                        detailsSb.append(\"<th>MD5 Hash<\/th>\");\n                        detailsSb.append(\"<td>\").append(md5Hash).append(\"<\/td>\");\n                        detailsSb.append(\"<\/tr>\");\n\n                        detailsSb.append(\"<tr>\");\n                        detailsSb.append(\"<th>Hashset Name<\/th>\");\n                        detailsSb.append(\"<td>\").append(hashSetName).append(\"<\/td>\");\n                        detailsSb.append(\"<\/tr>\");\n\n                        detailsSb.append(\"<\/table>\");\n\n                        managerProxy.postMessage(IngestMessage.createDataMessage(++messageId, this, \"Notable: \" + name, detailsSb.toString(), name + md5Hash, badFile));\n                        IngestManager.fireServiceDataEvent(new ServiceDataEvent(MODULE_NAME, ARTIFACT_TYPE.TSK_HASHSET_HIT, Collections.singletonList(badFile)));\n                        ret = ProcessResult.OK;\n                    } else if (status.equals(TskData.FileKnown.KNOWN)) {\n                        ret = ProcessResult.COND_STOP;\n                    } else {\n                        ret = ProcessResult.OK;\n                    }\n                }\n            } catch (TskException ex) {\n                // TODO: This shouldn't be at level INFO, but it needs to be to hide the popup\n                logger.log(Level.WARNING, \"Couldn't analyze file \" + name + \" - see sleuthkit log for details\", ex);\n                managerProxy.postMessage(IngestMessage.createErrorMessage(++messageId, this, \"Hash Lookup Error: \" + name,\n                        \"Error encountered while updating the hash values for \" + name + \".\"));\n                ret = ProcessResult.ERROR;\n            } catch (IOException ex) {\n                // TODO: This shouldn't be at level INFO, but it needs to be to hide the popup\n                logger.log(Level.WARNING, \"Error reading file \" + name, ex);\n                managerProxy.postMessage(IngestMessage.createErrorMessage(++messageId, this, \"Read Error: \" + name,\n                        \"Error encountered while calculating the hash value for \" + name + \".\"));\n                ret = ProcessResult.ERROR;\n            }\n        }\n        return ret;\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public javax.swing.JPanel getSimpleConfiguration() {\n        return new HashDbSimplePanel();\n    }","id":78549,"modified_method":"@Override\n    public javax.swing.JPanel getSimpleConfiguration() {\n        return HashDbSimplePanel.getDefault();\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void performAction() {\n        Log.noteAction(this.getClass());\n\n        // initialize panel with loaded settings\n        final HashDbMgmtPanel panel = HashDbMgmtPanel.getDefault();\n        final AdvancedConfigurationDialog dialog = new AdvancedConfigurationDialog();\n        dialog.addApplyButtonListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                if (panel.indexesExist()) {\n                    try {\n                        panel.saveSettings();\n                    } catch (IOException ex) {\n                        Log.get(HashDbMgmtAction.class).log(Level.WARNING, \"Couldn't save hash database settings.\", ex);\n                    }\n                    dialog.close();\n                } else {\n                    NotifyDescriptor d = new NotifyDescriptor.Message(\"All selected databases must have indexes.\", NotifyDescriptor.INFORMATION_MESSAGE);\n                    DialogDisplayer.getDefault().notify(d);\n                }\n            }\n        });\n        dialog.display(panel);\n    }","id":78550,"modified_method":"@Override\n    public void performAction() {\n        Log.noteAction(this.getClass());\n\n        // initialize panel with loaded settings\n        final HashDbMgmtPanel panel = HashDbMgmtPanel.getDefault();\n        final AdvancedConfigurationDialog dialog = new AdvancedConfigurationDialog();\n        dialog.addApplyButtonListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                if(panel.save()) {\n                    dialog.close();\n                } else {\n                    NotifyDescriptor d = new NotifyDescriptor.Message(\"Error saving settings\", NotifyDescriptor.INFORMATION_MESSAGE);\n                    DialogDisplayer.getDefault().notify(d);\n                }\n            }\n        });\n        dialog.display(panel);\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"void save(){\n        if (indexesExist()) {\n            try {\n                saveSettings();\n            } catch (IOException ex) {\n                Log.get(HashDbMgmtPanel.class).log(Level.WARNING, \"Couldn't save hash database settings.\", ex);\n            }\n        } else {\n            NotifyDescriptor d = new NotifyDescriptor.Message(\"All selected databases must have indexes.\", NotifyDescriptor.INFORMATION_MESSAGE);\n            DialogDisplayer.getDefault().notify(d);\n        }\n    }","id":78551,"modified_method":"/**\n     * Save the table settings\n     * @return whether save was successful\n     */\n    boolean save() {\n        notableTableModel.saveAll();\n        nsrlTableModel.saveAll();\n        return true;\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"static HashDbMgmtPanel getDefault() {\n        if (instance == null)\n            try {\n                instance = new HashDbMgmtPanel(HashDbSettings.getHashDbSettings());\n            } catch (IOException ex) {\n                Log.get(HashDbMgmtPanel.class).log(Level.WARNING, \"Couldn't get Hash DB settings\", ex);\n            }\n        return instance;\n    }","id":78552,"modified_method":"public static HashDbMgmtPanel getDefault() {\n        if(instance == null) {\n            instance = new HashDbMgmtPanel();\n        }\n        return instance;\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Initializes all the panel components\n     */\n    private void initComponents() {\n\n        NSRLPanel = new HashDbPanel(this.settings.getNSRLDatabase(), HashDbMgmtPanel.NSRL_NAME, HashDbMgmtPanel.NSRL_DESC);\n        knownBadPanel = new HashDbPanel(this.settings.getKnownBadDatabase(), HashDbMgmtPanel.KNOWN_BAD_NAME, HashDbMgmtPanel.KNOWN_BAD_DESC);\n\n        introText1 = new JLabel();\n        introText1.setText(INTRO_TEXT1);\n        introText1.setBorder(new EmptyBorder(10, 10, 5, 10));\n        introText1.setAlignmentX(Component.CENTER_ALIGNMENT);\n        introText1.setMaximumSize(NSRLPanel.getMaximumSize());\n\n        introText2 = new JLabel();\n        introText2.setText(INTRO_TEXT2);\n        introText2.setBorder(new EmptyBorder(0, 10, 0, 10));\n        introText2.setAlignmentX(Component.CENTER_ALIGNMENT);\n        introText2.setMaximumSize(NSRLPanel.getMaximumSize());\n\n        BoxLayout layout = new BoxLayout(this, BoxLayout.Y_AXIS);\n        this.setLayout(layout);\n        this.add(introText1);\n        this.add(introText2);\n        this.add(NSRLPanel);\n        this.add(knownBadPanel);\n        this.add(Box.createRigidArea(new Dimension(0, 10)));\n    }","id":78553,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        notableHashSetTable = new javax.swing.JTable();\n        addNSRLButton = new javax.swing.JButton();\n        removeNSRLButton = new javax.swing.JButton();\n        jScrollPane2 = new javax.swing.JScrollPane();\n        nsrlHashSetTable = new javax.swing.JTable();\n        addNotableButton = new javax.swing.JButton();\n        removeNotableButton = new javax.swing.JButton();\n\n        jScrollPane1.setViewportView(notableHashSetTable);\n\n        addNSRLButton.setText(org.openide.util.NbBundle.getMessage(HashDbMgmtPanel.class, \"HashDbMgmtPanel.addNSRLButton.text\")); // NOI18N\n        addNSRLButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addNSRLButtonActionPerformed(evt);\n            }\n        });\n\n        removeNSRLButton.setText(org.openide.util.NbBundle.getMessage(HashDbMgmtPanel.class, \"HashDbMgmtPanel.removeNSRLButton.text\")); // NOI18N\n        removeNSRLButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeNSRLButtonActionPerformed(evt);\n            }\n        });\n\n        nsrlHashSetTable.setModel(new javax.swing.table.DefaultTableModel(\n            new Object [][] {\n\n            },\n            new String [] {\n\n            }\n        ));\n        jScrollPane2.setViewportView(nsrlHashSetTable);\n\n        addNotableButton.setText(org.openide.util.NbBundle.getMessage(HashDbMgmtPanel.class, \"HashDbMgmtPanel.addNotableButton.text\")); // NOI18N\n        addNotableButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                addNotableButtonActionPerformed(evt);\n            }\n        });\n\n        removeNotableButton.setText(org.openide.util.NbBundle.getMessage(HashDbMgmtPanel.class, \"HashDbMgmtPanel.removeNotableButton.text\")); // NOI18N\n        removeNotableButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                removeNotableButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(addNSRLButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 235, Short.MAX_VALUE)\n                .addComponent(removeNSRLButton)\n                .addContainerGap())\n            .addComponent(jScrollPane1, 0, 0, Short.MAX_VALUE)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(addNotableButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 223, Short.MAX_VALUE)\n                .addComponent(removeNotableButton)\n                .addContainerGap())\n            .addComponent(jScrollPane2, 0, 0, Short.MAX_VALUE)\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 203, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(addNotableButton)\n                    .addComponent(removeNotableButton))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 186, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(addNSRLButton)\n                    .addComponent(removeNSRLButton))\n                .addContainerGap())\n        );\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * \n     * @param settings Settings to initialize the panel state from.\n     */\n    HashDbMgmtPanel(HashDbSettings settings) {\n        this.settings = settings;\n\n        this.setName(HASH_DATABASE_TITLE);\n        initComponents();\n    }","id":78554,"modified_method":"/** Creates new form HashDbMgmtPanel */\n    private HashDbMgmtPanel() {\n        notableTableModel = new HashSetTableModel();\n        nsrlTableModel = new HashSetTableModel();\n        initComponents();\n        customizeComponents();\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Checks if indexes exist for all defined databases\n     * @return true if Sleuth Kit can open the indexes of all databases\n     * than have been selected\n     */\n    boolean indexesExist() {\n        HashDb nsrl = this.NSRLPanel.db;\n        HashDb knownBad = this.knownBadPanel.db;\n\n        if (nsrl != null && !nsrl.indexExists()) {\n            return false;\n        }\n        if (knownBad != null && !knownBad.indexExists()) {\n            return false;\n        }\n        return true;\n    }","id":78555,"modified_method":"/**\n     * Checks if indexes exist for all defined databases\n     * @return true if Sleuth Kit can open the indexes of all databases\n     * than have been selected\n     */\n    boolean indexesExist() {\n        return notableTableModel.indexesExist() && nsrlTableModel.indexesExist();\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void customizeComponents() {\n\n\n        try {\n            HashDbSettings settings = HashDbSettings.getHashDbSettings();\n            boolean hasKnown = settings.getNSRLDatabase() != null;\n            if (hasKnown) {\n                knownValLabel.setText(\"Set\");\n            } else {\n                knownValLabel.setText(\"Not set\");\n            }\n            String notablePath = settings.getKnownBadDatabasePath();\n            if (notablePath == null || notablePath.equals(\"\"))\n                notableValLabel.setText(\"Not set\");\n            else {\n                StringTokenizer tok = new StringTokenizer(notablePath, File.separator);\n                String name = null;\n                while (tok.hasMoreElements())\n                    name = tok.nextToken();\n                \n                notableValLabel.setText(name);\n            }\n\n        } catch (IOException ex) {\n            Log.get(HashDbSimplePanel.class).log(Level.WARNING, \"Couldn't get Hash DB settings\", ex);\n        }\n    }","id":78556,"modified_method":"private void customizeComponents() {\n        notableHashTable.setModel(notableTableModel);\n        \n        notableHashTable.setTableHeader(null);\n        notableHashTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        //customize column witdhs\n        final int width1 = jScrollPane1.getPreferredSize().width;\n        TableColumn column1 = null;\n        for (int i = 0; i < notableHashTable.getColumnCount(); i++) {\n            column1 = notableHashTable.getColumnModel().getColumn(i);\n            if (i == 0) {\n                column1.setPreferredWidth(((int) (width1 * 0.15)));\n            } else {\n                column1.setPreferredWidth(((int) (width1 * 0.84)));\n            }\n        }\n        \n        nsrlHashTable.setModel(nsrlTableModel);\n        \n        nsrlHashTable.setTableHeader(null);\n        nsrlHashTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        //customize column witdhs\n        final int width2 = jScrollPane1.getPreferredSize().width;\n        TableColumn column2 = null;\n        for (int i = 0; i < nsrlHashTable.getColumnCount(); i++) {\n            column2 = nsrlHashTable.getColumnModel().getColumn(i);\n            if (i == 0) {\n                column2.setPreferredWidth(((int) (width2 * 0.15)));\n            } else {\n                column2.setPreferredWidth(((int) (width2 * 0.84)));\n            }\n        }\n        reloadLists();\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** Creates new form HashDbSimplePanel */\n    public HashDbSimplePanel() {\n        initComponents();\n        customizeComponents();\n    }","id":78557,"modified_method":"/** Creates new form HashDbSimplePanel */\n    private HashDbSimplePanel() {\n        notableTableModel = new HashTableModel();\n        nsrlTableModel = new HashTableModel();\n        initComponents();\n        customizeComponents();\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        knownLabel = new javax.swing.JLabel();\n        notableLabel = new javax.swing.JLabel();\n        knownValLabel = new javax.swing.JLabel();\n        notableValLabel = new javax.swing.JLabel();\n\n        knownLabel.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.knownLabel.text\")); // NOI18N\n\n        notableLabel.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.notableLabel.text\")); // NOI18N\n\n        knownValLabel.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.knownValLabel.text\")); // NOI18N\n\n        notableValLabel.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.notableValLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(knownLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(knownValLabel))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(notableLabel)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)\n                        .addComponent(notableValLabel)))\n                .addContainerGap(42, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(knownLabel)\n                    .addComponent(knownValLabel))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(notableValLabel)\n                    .addComponent(notableLabel))\n                .addContainerGap(18, Short.MAX_VALUE))\n        );\n    }","id":78558,"modified_method":"/** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jScrollPane1 = new javax.swing.JScrollPane();\n        notableHashTable = new javax.swing.JTable();\n        jScrollPane2 = new javax.swing.JScrollPane();\n        nsrlHashTable = new javax.swing.JTable();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n\n        jScrollPane1.setViewportView(notableHashTable);\n\n        jScrollPane2.setViewportView(nsrlHashTable);\n\n        jLabel1.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.jLabel1.text\")); // NOI18N\n\n        jLabel2.setText(org.openide.util.NbBundle.getMessage(HashDbSimplePanel.class, \"HashDbSimplePanel.jLabel2.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jLabel2)\n                .addContainerGap(154, Short.MAX_VALUE))\n            .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 274, Short.MAX_VALUE)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addComponent(jLabel1)\n                .addContainerGap(142, Short.MAX_VALUE))\n            .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 274, Short.MAX_VALUE)\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(jLabel2)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jLabel1)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 91, Short.MAX_VALUE))\n        );\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"static synchronized HashDbSimplePanel getDefault() {\n        if (instance == null) {\n            instance = new HashDbSimplePanel();\n        }\n\n        return instance;\n    }","id":78559,"modified_method":"public static HashDbSimplePanel getDefault() {\n        if(instance == null) {\n            instance = new HashDbSimplePanel();\n        }\n        return instance;\n    }","commit_id":"115146833084fc219bb84860214efe2062507ea5","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"public void refreshAndSave(final boolean forceSync) {\n    // Update property inspector\n    final UIDesignerToolWindowManager manager = UIDesignerToolWindowManager.getInstance(getProject());\n    manager.getPropertyInspector().synchWithTree(forceSync);\n\n    refresh();\n    saveToFile();\n    // TODO[yole]: install appropriate listeners so that the captions repaint themselves at correct time\n    myHorzCaptionPanel.repaint();\n    myVertCaptionPanel.repaint();\n  }","id":78560,"modified_method":"public void refreshAndSave(final boolean forceSync) {\n    // Update property inspector\n    final UIDesignerToolWindowManager manager = UIDesignerToolWindowManager.getInstance(getProject());\n    final PropertyInspector propertyInspector = manager.getPropertyInspector();\n    if (propertyInspector != null) {\n      propertyInspector.synchWithTree(forceSync);\n    }\n\n    refresh();\n    saveToFile();\n    // TODO[yole]: install appropriate listeners so that the captions repaint themselves at correct time\n    myHorzCaptionPanel.repaint();\n    myVertCaptionPanel.repaint();\n  }","commit_id":"0f19f7a98b42eb5f86450d5550116b0a17589232","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void refreshProperties() {\n    final Ref<Boolean> anythingModified = new Ref<Boolean>();\n    FormEditingUtil.iterate(myRootContainer, new FormEditingUtil.ComponentVisitor() {\n      public boolean visit(final IComponent component) {\n        final RadComponent radComponent = (RadComponent)component;\n        boolean componentModified = false;\n        for (IProperty prop : component.getModifiedProperties()) {\n          if (prop instanceof IntroStringProperty) {\n            IntroStringProperty strProp = (IntroStringProperty)prop;\n            componentModified = strProp.refreshValue(radComponent) || componentModified;\n          }\n        }\n\n        if (component instanceof RadContainer) {\n          componentModified = ((RadContainer)component).updateBorder() || componentModified;\n        }\n\n        if (component.getParentContainer() instanceof RadTabbedPane) {\n          componentModified = ((RadTabbedPane)component.getParentContainer()).refreshChildTitle(radComponent) || componentModified;\n        }\n        if (componentModified) {\n          anythingModified.set(Boolean.TRUE);\n        }\n\n        return true;\n      }\n    });\n    if (!anythingModified.isNull()) {\n      refresh();\n      final UIDesignerToolWindowManager twm = UIDesignerToolWindowManager.getInstance(getProject());\n      twm.getComponentTree().repaint();\n      twm.getPropertyInspector().synchWithTree(true);\n    }\n  }","id":78561,"modified_method":"private void refreshProperties() {\n    final Ref<Boolean> anythingModified = new Ref<Boolean>();\n    FormEditingUtil.iterate(myRootContainer, new FormEditingUtil.ComponentVisitor() {\n      public boolean visit(final IComponent component) {\n        final RadComponent radComponent = (RadComponent)component;\n        boolean componentModified = false;\n        for (IProperty prop : component.getModifiedProperties()) {\n          if (prop instanceof IntroStringProperty) {\n            IntroStringProperty strProp = (IntroStringProperty)prop;\n            componentModified = strProp.refreshValue(radComponent) || componentModified;\n          }\n        }\n\n        if (component instanceof RadContainer) {\n          componentModified = ((RadContainer)component).updateBorder() || componentModified;\n        }\n\n        if (component.getParentContainer() instanceof RadTabbedPane) {\n          componentModified = ((RadTabbedPane)component.getParentContainer()).refreshChildTitle(radComponent) || componentModified;\n        }\n        if (componentModified) {\n          anythingModified.set(Boolean.TRUE);\n        }\n\n        return true;\n      }\n    });\n    if (!anythingModified.isNull()) {\n      refresh();\n      final UIDesignerToolWindowManager twm = UIDesignerToolWindowManager.getInstance(getProject());\n      ComponentTree tree = twm.getComponentTree();\n      if (tree != null) tree.repaint();\n      PropertyInspector inspector = twm.getPropertyInspector();\n      if (inspector != null) inspector.synchWithTree(true);\n    }\n  }","commit_id":"41114970416bb29e046637211b3eb99459605660","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object getData(final String dataId) {\n    if (PlatformDataKeys.HELP_ID.is(dataId)) {\n      return ourHelpID;\n    }\n\n    // Standard Swing cut/copy/paste actions should work if user is editing something inside property inspector\n    final UIDesignerToolWindowManager manager = UIDesignerToolWindowManager.getInstance(getProject());\n    if (manager.getPropertyInspector().isEditing()) {\n      return null;\n    }\n\n    if (PlatformDataKeys.DELETE_ELEMENT_PROVIDER.is(dataId)) {\n      return myDeleteProvider;\n    }\n\n    if (PlatformDataKeys.COPY_PROVIDER.is(dataId) ||\n        PlatformDataKeys.CUT_PROVIDER.is(dataId) ||\n        PlatformDataKeys.PASTE_PROVIDER.is(dataId)) {\n      return myCutCopyPasteSupport;\n    }\n\n    return null;\n  }","id":78562,"modified_method":"public Object getData(final String dataId) {\n    if (PlatformDataKeys.HELP_ID.is(dataId)) {\n      return ourHelpID;\n    }\n\n    // Standard Swing cut/copy/paste actions should work if user is editing something inside property inspector\n    final UIDesignerToolWindowManager manager = UIDesignerToolWindowManager.getInstance(getProject());\n    final PropertyInspector inspector = manager.getPropertyInspector();\n    if (inspector != null && inspector.isEditing()) {\n      return null;\n    }\n\n    if (PlatformDataKeys.DELETE_ELEMENT_PROVIDER.is(dataId)) {\n      return myDeleteProvider;\n    }\n\n    if (PlatformDataKeys.COPY_PROVIDER.is(dataId) ||\n        PlatformDataKeys.CUT_PROVIDER.is(dataId) ||\n        PlatformDataKeys.PASTE_PROVIDER.is(dataId)) {\n      return myCutCopyPasteSupport;\n    }\n\n    return null;\n  }","commit_id":"d9cef2107f46b70285fbdff81e5166ae3e996c01","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(final AnActionEvent e) {\n      final UIDesignerToolWindowManager manager = UIDesignerToolWindowManager.getInstance(getProject());\n      e.getPresentation().setEnabled(!manager.getPropertyInspector().isEditing());\n    }","id":78563,"modified_method":"public void update(final AnActionEvent e) {\n      final UIDesignerToolWindowManager manager = UIDesignerToolWindowManager.getInstance(getProject());\n      PropertyInspector inspector = manager.getPropertyInspector();\n      e.getPresentation().setEnabled(inspector != null && !inspector.isEditing());\n    }","commit_id":"601084c302fe3080ba0d0cccf41d957506775146","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void analyze(@NotNull final Project project, @NotNull final AnalysisScope scope) {\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n    final List<LocalInspectionToolWrapper> lTools = new ArrayList<LocalInspectionToolWrapper>();\n    final InspectionManagerEx managerEx = (InspectionManagerEx)InspectionManager.getInstance(project);\n    final GlobalInspectionContextImpl context = managerEx.createNewGlobalContext(false);\n\n    final LinkedHashMap<PsiFile, List<HighlightInfo>> results = new LinkedHashMap<PsiFile, List<HighlightInfo>>();\n    ProgressManager.getInstance().run(new Task.Backgroundable(project, \"Inspect code...\", true) {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        scope.accept(new PsiElementVisitor() {\n          @Override\n          public void visitFile(PsiFile file) {\n            final VirtualFile virtualFile = file.getVirtualFile();\n            if (virtualFile == null) return;\n            for (final Tools tools : profile.getAllEnabledInspectionTools(project)) {\n              if (tools.getTool().getTool() instanceof CleanupLocalInspectionTool) {\n                final InspectionToolWrapper tool = tools.getEnabledTool(file);\n                if (tool instanceof LocalInspectionToolWrapper) {\n                  lTools.add((LocalInspectionToolWrapper)tool);\n                  tool.initialize(context);\n                }\n              }\n            }\n\n            if (!lTools.isEmpty()) {\n              final LocalInspectionsPass pass = new LocalInspectionsPass(file, PsiDocumentManager.getInstance(project).getDocument(file), 0,\n                                                                         file.getTextLength(), LocalInspectionsPass.EMPTY_PRIORITY_RANGE, true,\n                                                                         HighlightInfoProcessor.getEmpty());\n              Runnable runnable = new Runnable() {\n                public void run() {\n                  pass.doInspectInBatch(context, managerEx, lTools);\n                }\n              };\n              ApplicationManager.getApplication().runReadAction(runnable);\n              results.put(file, pass.getInfos());\n            }\n          }\n        });\n      }\n\n      @Override\n      public void onSuccess() {\n        if (!FileModificationService.getInstance().preparePsiElementsForWrite(results.keySet())) return;\n\n        final SequentialModalProgressTask progressTask = new SequentialModalProgressTask(project, \"Code Cleanup\", true);\n        progressTask.setMinIterationTime(200);\n        progressTask.setTask(new SequentialCleanupTask(project, results, progressTask));\n        CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n          @Override\n          public void run() {\n            CommandProcessor.getInstance().markCurrentCommandAsGlobal(project);\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              @Override\n              public void run() {\n                ProgressManager.getInstance().run(progressTask);\n              }\n            });\n          }\n        }, getTemplatePresentation().getText(), null);\n      }\n    });\n  }","id":78564,"modified_method":"@Override\n  protected void analyze(@NotNull final Project project, @NotNull final AnalysisScope scope) {\n    final InspectionProfile profile = myExternalProfile != null ? myExternalProfile : InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n    final List<LocalInspectionToolWrapper> lTools = new ArrayList<LocalInspectionToolWrapper>();\n    final InspectionManagerEx managerEx = (InspectionManagerEx)InspectionManager.getInstance(project);\n    final GlobalInspectionContextImpl context = managerEx.createNewGlobalContext(false);\n\n    final LinkedHashMap<PsiFile, List<HighlightInfo>> results = new LinkedHashMap<PsiFile, List<HighlightInfo>>();\n    ProgressManager.getInstance().run(new Task.Backgroundable(project, \"Inspect code...\", true) {\n      @Override\n      public void run(@NotNull ProgressIndicator indicator) {\n        scope.accept(new PsiElementVisitor() {\n          @Override\n          public void visitFile(PsiFile file) {\n            final VirtualFile virtualFile = file.getVirtualFile();\n            if (virtualFile == null) return;\n            for (final Tools tools : profile.getAllEnabledInspectionTools(project)) {\n              if (tools.getTool().getTool() instanceof CleanupLocalInspectionTool) {\n                final InspectionToolWrapper tool = tools.getEnabledTool(file);\n                if (tool instanceof LocalInspectionToolWrapper) {\n                  lTools.add((LocalInspectionToolWrapper)tool);\n                  tool.initialize(context);\n                }\n              }\n            }\n\n            if (!lTools.isEmpty()) {\n              final LocalInspectionsPass pass = new LocalInspectionsPass(file, PsiDocumentManager.getInstance(project).getDocument(file), 0,\n                                                                         file.getTextLength(), LocalInspectionsPass.EMPTY_PRIORITY_RANGE, true,\n                                                                         HighlightInfoProcessor.getEmpty());\n              Runnable runnable = new Runnable() {\n                public void run() {\n                  pass.doInspectInBatch(context, managerEx, lTools);\n                }\n              };\n              ApplicationManager.getApplication().runReadAction(runnable);\n              results.put(file, pass.getInfos());\n            }\n          }\n        });\n      }\n\n      @Override\n      public void onSuccess() {\n        if (!FileModificationService.getInstance().preparePsiElementsForWrite(results.keySet())) return;\n\n        final SequentialModalProgressTask progressTask = new SequentialModalProgressTask(project, \"Code Cleanup\", true);\n        progressTask.setMinIterationTime(200);\n        progressTask.setTask(new SequentialCleanupTask(project, results, progressTask));\n        CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n          @Override\n          public void run() {\n            CommandProcessor.getInstance().markCurrentCommandAsGlobal(project);\n            ApplicationManager.getApplication().runWriteAction(new Runnable() {\n              @Override\n              public void run() {\n                ProgressManager.getInstance().run(progressTask);\n              }\n            });\n          }\n        }, getTemplatePresentation().getText(), null);\n      }\n    });\n  }","commit_id":"838771a47c7cf41a2e22d51c7720a4213e80393a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected JComponent getAdditionalActionSettings(@NotNull final Project project, final BaseAnalysisActionDialog dialog) {\n    final AdditionalPanel panel = new AdditionalPanel();\n    final InspectionManagerEx manager = (InspectionManagerEx)InspectionManager.getInstance(project);\n    final JComboBox profiles = panel.myBrowseProfilesCombo.getComboBox();\n    profiles.setRenderer(new ListCellRendererWrapper() {\n      @Override\n      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        if (value instanceof Profile) {\n          final Profile profile = (Profile)value;\n          setText(profile.getName());\n          setIcon(profile.isLocal() ? AllIcons.General.Settings : AllIcons.General.ProjectSettings);\n        }\n      }\n    });\n    final InspectionProfileManager profileManager = InspectionProfileManager.getInstance();\n    final InspectionProjectProfileManager projectProfileManager = InspectionProjectProfileManager.getInstance(project);\n    reloadProfiles(profiles, profileManager, projectProfileManager, manager);\n    panel.myBrowseProfilesCombo.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final IDEInspectionToolsConfigurable errorConfigurable = new IDEInspectionToolsConfigurable(projectProfileManager, profileManager);\n        final MySingleConfigurableEditor editor = new MySingleConfigurableEditor(project, errorConfigurable, manager);\n        errorConfigurable.selectProfile(((Profile)profiles.getSelectedItem()).getName());\n        editor.show();\n        if (editor.isOK()) {\n          reloadProfiles(profiles, profileManager, projectProfileManager, manager);\n        }\n        else {\n          //if profile was disabled and cancel after apply was pressed\n          final InspectionProfile profile = (InspectionProfile)profiles.getSelectedItem();\n          final boolean canExecute = profile != null && profile.isExecutable(project);\n          dialog.setOKActionEnabled(canExecute);\n        }\n      }\n    });\n    profiles.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myExternalProfile = (InspectionProfile)profiles.getSelectedItem();\n        final boolean canExecute = myExternalProfile != null && myExternalProfile.isExecutable(project);\n        dialog.setOKActionEnabled(canExecute);\n        if (canExecute) {\n          manager.setProfile(myExternalProfile.getName());\n        }\n      }\n    });\n    final InspectionProfile profile = (InspectionProfile)profiles.getSelectedItem();\n    dialog.setOKActionEnabled(profile != null && profile.isExecutable(project));\n    return panel.myAdditionalPanel;\n  }","id":78565,"modified_method":"@Override\n  protected JComponent getAdditionalActionSettings(@NotNull final Project project, final BaseAnalysisActionDialog dialog) {\n    final AdditionalPanel panel = new AdditionalPanel();\n    final InspectionManagerEx manager = (InspectionManagerEx)InspectionManager.getInstance(project);\n    final JComboBox profiles = panel.myBrowseProfilesCombo.getComboBox();\n    profiles.setRenderer(new ListCellRendererWrapper() {\n      @Override\n      public void customize(JList list, Object value, int index, boolean selected, boolean hasFocus) {\n        if (value instanceof Profile) {\n          final Profile profile = (Profile)value;\n          setText(profile.getName());\n          setIcon(profile.isLocal() ? AllIcons.General.Settings : AllIcons.General.ProjectSettings);\n        }\n      }\n    });\n    final InspectionProfileManager profileManager = InspectionProfileManager.getInstance();\n    final InspectionProjectProfileManager projectProfileManager = InspectionProjectProfileManager.getInstance(project);\n    reloadProfiles(profiles, profileManager, projectProfileManager, manager);\n    panel.myBrowseProfilesCombo.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        final IDEInspectionToolsConfigurable errorConfigurable = createConfigurable(projectProfileManager, profileManager);\n        final MySingleConfigurableEditor editor = new MySingleConfigurableEditor(project, errorConfigurable, manager);\n        errorConfigurable.selectProfile(((Profile)profiles.getSelectedItem()).getName());\n        editor.show();\n        if (editor.isOK()) {\n          reloadProfiles(profiles, profileManager, projectProfileManager, manager);\n        }\n        else {\n          //if profile was disabled and cancel after apply was pressed\n          final InspectionProfile profile = (InspectionProfile)profiles.getSelectedItem();\n          final boolean canExecute = profile != null && profile.isExecutable(project);\n          dialog.setOKActionEnabled(canExecute);\n        }\n      }\n    });\n    profiles.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        myExternalProfile = (InspectionProfile)profiles.getSelectedItem();\n        final boolean canExecute = myExternalProfile != null && myExternalProfile.isExecutable(project);\n        dialog.setOKActionEnabled(canExecute);\n        if (canExecute) {\n          manager.setProfile(myExternalProfile.getName());\n        }\n      }\n    });\n    final InspectionProfile profile = (InspectionProfile)profiles.getSelectedItem();\n    dialog.setOKActionEnabled(profile != null && profile.isExecutable(project));\n    return panel.myAdditionalPanel;\n  }","commit_id":"838771a47c7cf41a2e22d51c7720a4213e80393a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void reset() {\n    myDeletedProfiles.clear();\n    myPanels.clear();\n    final DefaultComboBoxModel model = new DefaultComboBoxModel();\n    myProfiles.setModel(model);\n    for (Profile profile : getProfiles()) {\n      model.addElement(profile);\n      final String profileName = profile.getName();\n      final SingleInspectionProfilePanel panel = new SingleInspectionProfilePanel(myProjectProfileManager, profileName, ((InspectionProfileImpl)profile).getModifiableModel());\n      putProfile(profile, panel);\n      myPanel.add(profileName, panel);\n    }\n    final InspectionProfileImpl inspectionProfile = getCurrentProfile();\n    myProfiles.setSelectedItem(inspectionProfile);\n    myLayout.show(myPanel, inspectionProfile.getName());\n    myDeleteButton.setEnabled(isDeleteEnabled(inspectionProfile));\n    final SingleInspectionProfilePanel panel = getSelectedPanel();\n    if (panel != null) {\n      panel.setVisible(true);//make sure that UI was initialized\n      mySelectionAlarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);\n      SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          if (mySelectionAlarm != null) {\n            mySelectionAlarm.addRequest(new Runnable() {\n              @Override\n              public void run() {\n                panel.updateSelection();\n              }\n            }, 200);\n          }\n        }\n      });\n\n      myShareProfileCheckBox.setSelected(panel.isProfileShared());\n    }\n  }","id":78566,"modified_method":"@Override\n  public void reset() {\n    myDeletedProfiles.clear();\n    myPanels.clear();\n    final DefaultComboBoxModel model = new DefaultComboBoxModel();\n    myProfiles.setModel(model);\n    for (Profile profile : getProfiles()) {\n      model.addElement(profile);\n      final String profileName = profile.getName();\n      final SingleInspectionProfilePanel panel = createPanel((InspectionProfileImpl)profile, profileName, false);\n      putProfile(profile, panel);\n      myPanel.add(profileName, panel);\n    }\n    final InspectionProfileImpl inspectionProfile = getCurrentProfile();\n    myProfiles.setSelectedItem(inspectionProfile);\n    myLayout.show(myPanel, inspectionProfile.getName());\n    myDeleteButton.setEnabled(isDeleteEnabled(inspectionProfile));\n    final SingleInspectionProfilePanel panel = getSelectedPanel();\n    if (panel != null) {\n      panel.setVisible(true);//make sure that UI was initialized\n      mySelectionAlarm = new Alarm(Alarm.ThreadToUse.SWING_THREAD);\n      SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          if (mySelectionAlarm != null) {\n            mySelectionAlarm.addRequest(new Runnable() {\n              @Override\n              public void run() {\n                panel.updateSelection();\n              }\n            }, 200);\n          }\n        }\n      });\n\n      myShareProfileCheckBox.setSelected(panel.isProfileShared());\n    }\n  }","commit_id":"838771a47c7cf41a2e22d51c7720a4213e80393a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addProfile(InspectionProfileImpl model) {\n    final String modelName = model.getName();\n    final SingleInspectionProfilePanel panel = new SingleInspectionProfilePanel(myProjectProfileManager, modelName, model);\n    myPanel.add(modelName, panel);\n    if (!myPanels.containsKey(getProfilePrefix(model) + modelName)) {\n      //noinspection unchecked\n      ((DefaultComboBoxModel)myProfiles.getModel()).addElement(model);\n    }\n    putProfile(model, panel);\n    myProfiles.setSelectedItem(model);\n  }","id":78567,"modified_method":"private void addProfile(InspectionProfileImpl model) {\n    final String modelName = model.getName();\n    final SingleInspectionProfilePanel panel = createPanel(model, modelName, true);\n    myPanel.add(modelName, panel);\n    if (!myPanels.containsKey(getProfilePrefix(model) + modelName)) {\n      //noinspection unchecked\n      ((DefaultComboBoxModel)myProfiles.getModel()).addElement(model);\n    }\n    putProfile(model, panel);\n    myProfiles.setSelectedItem(model);\n  }","commit_id":"838771a47c7cf41a2e22d51c7720a4213e80393a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initDescriptors() {\n    final InspectionProfileImpl profile = mySelectedProfile;\n    if (profile == null) return;\n    myDescriptors.clear();\n    List<ScopeToolState> tools = profile.getDefaultStates(myProjectProfileManager.getProject());\n    for (ScopeToolState state : tools) {\n      final ArrayList<Descriptor> descriptors = new ArrayList<Descriptor>();\n      if (state.getLevel() == HighlightDisplayLevel.NON_SWITCHABLE_ERROR) {\n        continue;\n      }\n      Project project = myProjectProfileManager.getProject();\n      myDescriptors.put(new Descriptor(state, profile, project), descriptors);\n      InspectionToolWrapper toolWrapper = state.getTool();\n      final List<ScopeToolState> nonDefaultTools = profile.getNonDefaultTools(toolWrapper.getShortName(), project);\n      for (ScopeToolState nonDefaultToolState : nonDefaultTools) {\n        descriptors.add(new Descriptor(nonDefaultToolState, profile, project));\n      }\n    }\n  }","id":78568,"modified_method":"private void initDescriptors() {\n    final InspectionProfileImpl profile = mySelectedProfile;\n    if (profile == null) return;\n    myDescriptors.clear();\n    List<ScopeToolState> tools = profile.getDefaultStates(myProjectProfileManager.getProject());\n    for (ScopeToolState state : tools) {\n      final ArrayList<Descriptor> descriptors = new ArrayList<Descriptor>();\n      if (!accept(state.getTool().getTool())) continue;\n      Project project = myProjectProfileManager.getProject();\n      myDescriptors.put(new Descriptor(state, profile, project), descriptors);\n      InspectionToolWrapper toolWrapper = state.getTool();\n      final List<ScopeToolState> nonDefaultTools = profile.getNonDefaultTools(toolWrapper.getShortName(), project);\n      for (ScopeToolState nonDefaultToolState : nonDefaultTools) {\n        descriptors.add(new Descriptor(nonDefaultToolState, profile, project));\n      }\n    }\n  }","commit_id":"838771a47c7cf41a2e22d51c7720a4213e80393a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    final InspectionProjectProfileManager projectProfileManager = InspectionProjectProfileManager.getInstance(project);\n    final InspectionProfile inspectionProfile = projectProfileManager.getInspectionProfile(file);\n    EditInspectionToolsSettingsAction.editToolSettings(project, inspectionProfile, false, myId);\n  }","id":78569,"modified_method":"public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    InspectionProfileEntry tool = getTool(project, file);\n    if (tool == null) return;\n    final InspectionProjectProfileManager projectProfileManager = InspectionProjectProfileManager.getInstance(project);\n    final InspectionProfileImpl inspectionProfile = (InspectionProfileImpl)projectProfileManager.getInspectionProfile(file);\n    EditInspectionToolsSettingsAction.editToolSettings(project, inspectionProfile, false, tool.getShortName());\n  }","commit_id":"4daddcde1d47fef466129f50d0d851a475ff9cf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAvailable(Project project, Editor editor, PsiFile file) {\n    myId = getSuppressedId(editor, file);\n    if (myId != null) {\n      final InspectionProjectProfileManager projectProfileManager = InspectionProjectProfileManager.getInstance(project);\n      final InspectionProfile inspectionProfile = projectProfileManager.getInspectionProfile(file);\n      InspectionProfileEntry tool = inspectionProfile.getInspectionTool(myId);\n      if (tool == null) return false;\n      myDisplayName = tool.getDisplayName();\n    }\n    return myId != null;\n  }","id":78570,"modified_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    myId = getSuppressedId(editor, file);\n    if (myId != null) {\n      InspectionProfileEntry tool = getTool(project, file);\n      if (tool == null) return false;\n      myDisplayName = tool.getDisplayName();\n    }\n    return myId != null;\n  }","commit_id":"4daddcde1d47fef466129f50d0d851a475ff9cf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createBindings() {\r\n    fileFolderLabel = (XulLabel) document.getElementById(\"file-folder-name\");//$NON-NLS-1$ \r\n    aclDeck = (XulDeck) document.getElementById(\"acl-deck\");//$NON-NLS-1$ \r\n    // Permission Tab Binding\r\n    userRoleList = (XulListbox) document.getElementById(\"user-role-list\");//$NON-NLS-1$ \r\n    createCheckbox = (XulCheckbox) document.getElementById(\"create-checkbox\");//$NON-NLS-1$ \r\n    updateCheckbox = (XulCheckbox) document.getElementById(\"update-checkbox\");//$NON-NLS-1$ \r\n    readCheckbox = (XulCheckbox) document.getElementById(\"read-checkbox\");//$NON-NLS-1$ \r\n    deleteCheckbox = (XulCheckbox) document.getElementById(\"delete-checkbox\");//$NON-NLS-1$ \r\n\r\n    inheritParentPermissionCheckbox = (XulCheckbox) document.getElementById(\"inherit-from-parent-permission-checkbox\");//$NON-NLS-1$ \r\n    modifyCheckbox = (XulCheckbox) document.getElementById(\"modify-checkbox\");//$NON-NLS-1$ \r\n    manageAclsDialog = (XulDialog) document.getElementById(\"manage-acls-dialog\");//$NON-NLS-1$ \r\n    addAclButton = (XulButton) document.getElementById(\"add-acl-button\");//$NON-NLS-1$ \r\n    removeAclButton = (XulButton) document.getElementById(\"remove-acl-button\");//$NON-NLS-1$ \r\n\r\n    // Add/Remove Acl Binding\r\n    availableUserList = (XulListbox) document.getElementById(\"available-user-list\");//$NON-NLS-1$ \r\n    selectedUserList = (XulListbox) document.getElementById(\"selected-user-list\");//$NON-NLS-1$ \r\n    availableRoleList = (XulListbox) document.getElementById(\"available-role-list\");//$NON-NLS-1$ \r\n    selectedRoleList = (XulListbox) document.getElementById(\"selected-role-list\");//$NON-NLS-1$ \r\n\r\n    assignRoleButton = (XulButton) document.getElementById(\"assign-role\");//$NON-NLS-1$ \r\n    unassignRoleButton = (XulButton) document.getElementById(\"unassign-role\");//$NON-NLS-1$ \r\n    assignUserButton = (XulButton) document.getElementById(\"assign-user\");//$NON-NLS-1$ \r\n    unassignUserButton = (XulButton) document.getElementById(\"unassign-user\");//$NON-NLS-1$ \r\n\r\n    applyAclConfirmationDialog = (XulDialog) document.getElementById(\"apply-acl-confirmation-dialog\");//$NON-NLS-1$ \r\n    applyOnlyRadioButton = (XulRadio) document.getElementById(\"apply-only-radio-button\");//$NON-NLS-1$ \r\n    applyRecursiveRadioButton = (XulRadio) document.getElementById(\"apply-recursive-radio-button\");//$NON-NLS-1$ \r\n\r\n    // Binding the model user or role list to the ui user or role list\r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n    bf.createBinding(manageAclsModel, \"availableUserList\", availableUserList, \"elements\");//$NON-NLS-1$ //$NON-NLS-2$\r\n    bf.createBinding(manageAclsModel, \"selectedUserList\", selectedUserList, \"elements\");//$NON-NLS-1$ //$NON-NLS-2$\r\n    bf.createBinding(manageAclsModel, \"availableRoleList\", availableRoleList, \"elements\"); //$NON-NLS-1$ //$NON-NLS-2$\r\n    bf.createBinding(manageAclsModel, \"selectedRoleList\", selectedRoleList, \"elements\"); //$NON-NLS-1$ //$NON-NLS-2$\r\n    \r\n    // indicesToObjectsConverter convert the selected indices to the list of objects and vice versa\r\n    BindingConvertor<int[], List<UIRepositoryObjectAcl>> indicesToObjectsConverter = new BindingConvertor<int[], List<UIRepositoryObjectAcl>>() {\r\n\r\n      @Override\r\n      public int[] targetToSource(List<UIRepositoryObjectAcl> acls) {\r\n        if (acls != null) {\r\n          int i=0;\r\n          int[] retVal = new int[acls.size()];\r\n          for (UIRepositoryObjectAcl acl : acls) {\r\n            retVal[i++] = viewAclsModel.getAceIndex(acl.getAce());\r\n          }\r\n          return retVal;\r\n        }\r\n        return null;\r\n      }\r\n\r\n      @Override\r\n      public List<UIRepositoryObjectAcl> sourceToTarget(int[] indices) {\r\n        if (indices != null && indices.length > 0) {\r\n          List<UIRepositoryObjectAcl> retVal = new ArrayList<UIRepositoryObjectAcl>();\r\n          for (int i = 0; i < indices.length; i++) {\r\n            retVal.add(new UIRepositoryObjectAcl(viewAclsModel.getAceAtIndex(indices[i])));\r\n          }\r\n          return retVal;\r\n        }\r\n        return null;\r\n      }\r\n\r\n    };\r\n\r\n    // indexToAvalableUserConverter convert the selected indices to the list of objects and vice versa\r\n    BindingConvertor<int[], List<String>> indexToAvailableUserConverter = new BindingConvertor<int[], List<String>>() {\r\n\r\n      @Override\r\n      public List<String> sourceToTarget(int[] indices) {\r\n        List<String> userList = new ArrayList<String>();\r\n        for (int i = 0; i < indices.length; i++) {\r\n          userList.add(manageAclsModel.getAvailableUser(indices[i]));\r\n        }\r\n        return userList;\r\n      }\r\n\r\n      @Override\r\n      public int[] targetToSource(List<String> userList) {\r\n        int[] indices = new int[userList.size()];\r\n        int i = 0;\r\n        for (String user : userList) {\r\n          indices[i++] = manageAclsModel.getAvailableUserIndex(user);\r\n        }\r\n        return indices;\r\n      }\r\n\r\n    };\r\n\r\n    BindingConvertor<int[], List<String>> indexToAvailableRoleConverter = new BindingConvertor<int[], List<String>>() {\r\n\r\n      @Override\r\n      public List<String> sourceToTarget(int[] indices) {\r\n        List<String> roleList = new ArrayList<String>();\r\n        for (int i = 0; i < indices.length; i++) {\r\n          roleList.add(manageAclsModel.getAvailableRole(indices[i]));\r\n        }\r\n        return roleList;\r\n      }\r\n\r\n      @Override\r\n      public int[] targetToSource(List<String> roleList) {\r\n        int[] indices = new int[roleList.size()];\r\n        int i = 0;\r\n        for (String role : roleList) {\r\n          indices[i++] = manageAclsModel.getAvailableRoleIndex(role);\r\n        }\r\n        return indices;\r\n      }\r\n    };\r\n\r\n    BindingConvertor<int[], List<UIRepositoryObjectAcl>> indexToSelectedUserConverter = new BindingConvertor<int[], List<UIRepositoryObjectAcl>>() {\r\n\r\n      @Override\r\n      public List<UIRepositoryObjectAcl> sourceToTarget(int[] indices) {\r\n        List<UIRepositoryObjectAcl> userList = new ArrayList<UIRepositoryObjectAcl>();\r\n        for (int i = 0; i < indices.length; i++) {\r\n          userList.add(manageAclsModel.getSelectedUser(indices[i]));\r\n        }\r\n        return userList;\r\n      }\r\n\r\n      @Override\r\n      public int[] targetToSource(List<UIRepositoryObjectAcl> userList) {\r\n        int[] indices = new int[userList.size()];\r\n        int i = 0;\r\n        for (UIRepositoryObjectAcl user : userList) {\r\n          indices[i++] = manageAclsModel.getSelectedUserIndex(user);\r\n        }\r\n        return indices;\r\n      }\r\n\r\n    };\r\n\r\n    BindingConvertor<int[], List<UIRepositoryObjectAcl>> indexToSelectedRoleConverter = new BindingConvertor<int[], List<UIRepositoryObjectAcl>>() {\r\n\r\n      @Override\r\n      public List<UIRepositoryObjectAcl> sourceToTarget(int[] indices) {\r\n        List<UIRepositoryObjectAcl> roleList = new ArrayList<UIRepositoryObjectAcl>();\r\n        for (int i = 0; i < indices.length; i++) {\r\n          roleList.add(manageAclsModel.getSelectedRole(indices[i]));\r\n        }\r\n        return roleList;\r\n      }\r\n\r\n      @Override\r\n      public int[] targetToSource(List<UIRepositoryObjectAcl> roleList) {\r\n        int[] indices = new int[roleList.size()];\r\n        int i = 0;\r\n        for (UIRepositoryObjectAcl role : roleList) {\r\n          indices[i++] = manageAclsModel.getSelectedRoleIndex(role);\r\n        }\r\n        return indices;\r\n      }\r\n    };\r\n\r\n    // Binding between the selected incides of the lists to the mode list objects\r\n    bf.setBindingType(Binding.Type.BI_DIRECTIONAL);\r\n\r\n    bf.createBinding(availableUserList, \"selectedIndices\", manageAclsModel, \"selectedAvailableUsers\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        indexToAvailableUserConverter);\r\n    bf.createBinding(selectedUserList, \"selectedIndices\", manageAclsModel, \"selectedAssignedUsers\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        indexToSelectedUserConverter);\r\n    bf.createBinding(availableRoleList, \"selectedIndices\", manageAclsModel, \"selectedAvailableRoles\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        indexToAvailableRoleConverter);\r\n    bf.createBinding(selectedRoleList, \"selectedIndices\", manageAclsModel, \"selectedAssignedRoles\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        indexToSelectedRoleConverter);\r\n\r\n    // accumulatorButtonConverter determine whether to enable of disable the accumulator buttons\r\n    BindingConvertor<Integer, Boolean> accumulatorButtonConverter = new BindingConvertor<Integer, Boolean>() {\r\n\r\n      @Override\r\n      public Boolean sourceToTarget(Integer value) {\r\n        if (value != null && value >= 0) {\r\n          return true;\r\n        }\r\n        return false;\r\n      }\r\n\r\n      @Override\r\n      public Integer targetToSource(Boolean value) {\r\n        // TODO Auto-generated method stub\r\n        return null;\r\n      }\r\n    };\r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n    bf.createBinding(selectedUserList, \"selectedIndex\", manageAclsModel, \"userUnassignmentPossible\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        accumulatorButtonConverter);\r\n    bf\r\n        .createBinding(availableUserList, \"selectedIndex\", manageAclsModel, \"userAssignmentPossible\",//$NON-NLS-1$ //$NON-NLS-2$\r\n            accumulatorButtonConverter);\r\n    bf.createBinding(manageAclsModel, \"userUnassignmentPossible\", unassignUserButton, \"!disabled\");//$NON-NLS-1$ //$NON-NLS-2$\r\n    bf.createBinding(manageAclsModel, \"userAssignmentPossible\", assignUserButton, \"!disabled\");//$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n    bf.createBinding(selectedRoleList, \"selectedIndex\", manageAclsModel, \"roleUnassignmentPossible\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        accumulatorButtonConverter);\r\n    bf\r\n        .createBinding(availableRoleList, \"selectedIndex\", manageAclsModel, \"roleAssignmentPossible\",//$NON-NLS-1$ //$NON-NLS-2$\r\n            accumulatorButtonConverter);\r\n\r\n    bf.createBinding(manageAclsModel, \"roleUnassignmentPossible\", unassignRoleButton, \"!disabled\");//$NON-NLS-1$ //$NON-NLS-2$\r\n    bf.createBinding(manageAclsModel, \"roleAssignmentPossible\", assignRoleButton, \"!disabled\");//$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n\r\n    // Binding between the selected repository objects and the user role list for acls\r\n    securityBinding = bf.createBinding(getBrowseController(), \"repositoryObjects\", userRoleList, \"elements\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        new BindingConvertor<List<UIRepositoryObject>, List<UIRepositoryObjectAcl>>() {\r\n          @Override\r\n          public List<UIRepositoryObjectAcl> sourceToTarget(List<UIRepositoryObject> ro) {\r\n            if (ro == null) {\r\n              return null;\r\n            }\r\n            if (ro.size() <= 0) {\r\n              return null;\r\n            }\r\n            setSelectedRepositoryObject(ro);\r\n            viewAclsModel.setRemoveEnabled(false);\r\n            uncheckAllPermissionBox();\r\n            if (ro.get(0) instanceof UIRepositoryDirectory) {\r\n              UIRepositoryDirectory rd = (UIRepositoryDirectory) ro.get(0);\r\n              try {\r\n                rd.readAcls(viewAclsModel);\r\n                fileFolderLabel.setValue(rd.getName());\r\n                bf.setBindingType(Binding.Type.ONE_WAY);\r\n                bf.createBinding(viewAclsModel, \"acls\", userRoleList, \"elements\"); //$NON-NLS-1$ //$NON-NLS-2$\r\n              } catch (AccessDeniedException ade) {\r\n                messageBox.setTitle(messages.getString(\"Dialog.Error\"));//$NON-NLS-1$\r\n                messageBox.setAcceptLabel(messages.getString(\"Dialog.Ok\"));//$NON-NLS-1$\r\n                messageBox.setMessage(BaseMessages.getString(RepositoryExplorer.class,\r\n                    \"PermissionsController.UnableToGetAcls\", rd.getName(), ade.getLocalizedMessage()));//$NON-NLS-1$\r\n                \r\n                messageBox.open();\r\n              } catch (Exception e) {\r\n                messageBox.setTitle(messages.getString(\"Dialog.Error\"));//$NON-NLS-1$\r\n                messageBox.setAcceptLabel(messages.getString(\"Dialog.Ok\"));//$NON-NLS-1$\r\n                messageBox.setMessage(BaseMessages.getString(RepositoryExplorer.class,\r\n                    \"PermissionsController.UnableToGetAcls\", rd.getName(), e.getLocalizedMessage())); //$NON-NLS-1$\r\n                messageBox.open();\r\n              }\r\n\r\n            } else if (ro.get(0) instanceof UIRepositoryContent) {\r\n              UIRepositoryContent rc = (UIRepositoryContent) ro.get(0);\r\n              try {\r\n                fileFolderLabel.setValue(rc.getName());\r\n                rc.readAcls(viewAclsModel);\r\n                bf.setBindingType(Binding.Type.ONE_WAY);\r\n                bf.createBinding(viewAclsModel, \"acls\", userRoleList, \"elements\");//$NON-NLS-1$ //$NON-NLS-2$\r\n              } catch (AccessDeniedException ade) {\r\n                messageBox.setTitle(\"Error\");//$NON-NLS-1$\r\n                messageBox.setAcceptLabel(\"Ok\");//$NON-NLS-1$\r\n                messageBox.setMessage(BaseMessages.getString(RepositoryExplorer.class,\r\n                    \"PermissionsController.UnableToGetAcls\", rc.getName(), ade.getLocalizedMessage()));//$NON-NLS-1$\r\n                messageBox.open();\r\n              } catch (Exception e) {\r\n                messageBox.setTitle(\"Error\");//$NON-NLS-1$\r\n                messageBox.setAcceptLabel(\"Ok\");//$NON-NLS-1$\r\n                messageBox.setMessage(BaseMessages.getString(RepositoryExplorer.class,\r\n                    \"PermissionsController.UnableToGetAcls\", rc.getName(), e.getLocalizedMessage()));//$NON-NLS-1$\r\n                messageBox.open();\r\n              }\r\n            }\r\n            aclDeck.setSelectedIndex(ACL);\r\n            return viewAclsModel.getAcls();\r\n          }\r\n\r\n          @Override\r\n          public List<UIRepositoryObject> targetToSource(List<UIRepositoryObjectAcl> elements) {\r\n            return null;\r\n          }\r\n        });\r\n    \r\n    \r\n    \r\n    bf.setBindingType(Binding.Type.BI_DIRECTIONAL);\r\n\r\n    // Binding Add Remove button to the inherit check box. If the checkbox is checked that disable add remove\r\n    bf.createBinding(viewAclsModel, \"entriesInheriting\", inheritParentPermissionCheckbox, \"checked\"); //$NON-NLS-1$  //$NON-NLS-2$\r\n    // Binding the selected indices of acl list to the list of acl objects in the mode\r\n    bf.createBinding(userRoleList, \"selectedIndices\", viewAclsModel, \"selectedAclList\", indicesToObjectsConverter); //$NON-NLS-1$  //$NON-NLS-2$\r\n    \r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n    // Only enable add Acl button if the entries checkbox is unchecked\r\n    bf.createBinding(viewAclsModel, \"entriesInheriting\", addAclButton, \"disabled\");//$NON-NLS-1$  //$NON-NLS-2$ \r\n    // Only enable remove Acl button if the entries checkbox is unchecked and acl is selected from the list\r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", removeAclButton, \"!disabled\"); //$NON-NLS-1$  //$NON-NLS-2$ \r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", createCheckbox, \"!disabled\"); //$NON-NLS-1$  //$NON-NLS-2$\r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", updateCheckbox, \"!disabled\");//$NON-NLS-1$  //$NON-NLS-2$\r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", readCheckbox, \"!disabled\");//$NON-NLS-1$  //$NON-NLS-2$\r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", deleteCheckbox, \"!disabled\");//$NON-NLS-1$  //$NON-NLS-2$\r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", modifyCheckbox, \"!disabled\");//$NON-NLS-1$  //$NON-NLS-2$\r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n    // Binding when the user select from the list\r\n    bf.createBinding(userRoleList, \"selectedItem\", this, \"recipientChanged\"); //$NON-NLS-1$  //$NON-NLS-2$\r\n    // Binding the selected folder or folder to the ACL Deck\r\n    bf.createBinding(getBrowseController(), \"repositoryDirectories\", this, \"switchAclDeck\"); //$NON-NLS-1$  //$NON-NLS-2$\r\n    // Setting the default Deck to show no permission\r\n    aclDeck.setSelectedIndex(NO_ACL);\r\n    try {\r\n      if (securityBinding != null) {\r\n        securityBinding.fireSourceChanged();\r\n      }\r\n    } catch (Exception e) {\r\n      System.out.println(e.getMessage());\r\n      e.printStackTrace();\r\n    }\r\n  }","id":78571,"modified_method":"private void createBindings() {\r\n    fileFolderLabel = (XulLabel) document.getElementById(\"file-folder-name\");//$NON-NLS-1$ \r\n    aclDeck = (XulDeck) document.getElementById(\"acl-deck\");//$NON-NLS-1$ \r\n    // Permission Tab Binding\r\n    userRoleList = (XulListbox) document.getElementById(\"user-role-list\");//$NON-NLS-1$ \r\n    createCheckbox = (XulCheckbox) document.getElementById(\"create-checkbox\");//$NON-NLS-1$ \r\n    updateCheckbox = (XulCheckbox) document.getElementById(\"update-checkbox\");//$NON-NLS-1$ \r\n    readCheckbox = (XulCheckbox) document.getElementById(\"read-checkbox\");//$NON-NLS-1$ \r\n    deleteCheckbox = (XulCheckbox) document.getElementById(\"delete-checkbox\");//$NON-NLS-1$ \r\n\r\n    inheritParentPermissionCheckbox = (XulCheckbox) document.getElementById(\"inherit-from-parent-permission-checkbox\");//$NON-NLS-1$ \r\n    modifyCheckbox = (XulCheckbox) document.getElementById(\"modify-checkbox\");//$NON-NLS-1$ \r\n    manageAclsDialog = (XulDialog) document.getElementById(\"manage-acls-dialog\");//$NON-NLS-1$ \r\n    addAclButton = (XulButton) document.getElementById(\"add-acl-button\");//$NON-NLS-1$ \r\n    removeAclButton = (XulButton) document.getElementById(\"remove-acl-button\");//$NON-NLS-1$ \r\n\r\n    // Add/Remove Acl Binding\r\n    availableUserList = (XulListbox) document.getElementById(\"available-user-list\");//$NON-NLS-1$ \r\n    selectedUserList = (XulListbox) document.getElementById(\"selected-user-list\");//$NON-NLS-1$ \r\n    availableRoleList = (XulListbox) document.getElementById(\"available-role-list\");//$NON-NLS-1$ \r\n    selectedRoleList = (XulListbox) document.getElementById(\"selected-role-list\");//$NON-NLS-1$ \r\n\r\n    assignRoleButton = (XulButton) document.getElementById(\"assign-role\");//$NON-NLS-1$ \r\n    unassignRoleButton = (XulButton) document.getElementById(\"unassign-role\");//$NON-NLS-1$ \r\n    assignUserButton = (XulButton) document.getElementById(\"assign-user\");//$NON-NLS-1$ \r\n    unassignUserButton = (XulButton) document.getElementById(\"unassign-user\");//$NON-NLS-1$ \r\n\r\n    applyAclConfirmationDialog = (XulDialog) document.getElementById(\"apply-acl-confirmation-dialog\");//$NON-NLS-1$ \r\n    applyOnlyRadioButton = (XulRadio) document.getElementById(\"apply-only-radio-button\");//$NON-NLS-1$ \r\n    applyRecursiveRadioButton = (XulRadio) document.getElementById(\"apply-recursive-radio-button\");//$NON-NLS-1$ \r\n\r\n    // Binding the model user or role list to the ui user or role list\r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n    bf.createBinding(manageAclsModel, \"availableUserList\", availableUserList, \"elements\");//$NON-NLS-1$ //$NON-NLS-2$\r\n    bf.createBinding(manageAclsModel, \"selectedUserList\", selectedUserList, \"elements\");//$NON-NLS-1$ //$NON-NLS-2$\r\n    bf.createBinding(manageAclsModel, \"availableRoleList\", availableRoleList, \"elements\"); //$NON-NLS-1$ //$NON-NLS-2$\r\n    bf.createBinding(manageAclsModel, \"selectedRoleList\", selectedRoleList, \"elements\"); //$NON-NLS-1$ //$NON-NLS-2$\r\n    \r\n    // indicesToObjectsConverter convert the selected indices to the list of objects and vice versa\r\n    BindingConvertor<int[], List<UIRepositoryObjectAcl>> indicesToObjectsConverter = new BindingConvertor<int[], List<UIRepositoryObjectAcl>>() {\r\n\r\n      @Override\r\n      public int[] targetToSource(List<UIRepositoryObjectAcl> acls) {\r\n        if (acls != null) {\r\n          int i=0;\r\n          int[] retVal = new int[acls.size()];\r\n          for (UIRepositoryObjectAcl acl : acls) {\r\n            retVal[i++] = viewAclsModel.getAceIndex(acl.getAce());\r\n          }\r\n          return retVal;\r\n        }\r\n        return null;\r\n      }\r\n\r\n      @Override\r\n      public List<UIRepositoryObjectAcl> sourceToTarget(int[] indices) {\r\n        if (indices != null && indices.length > 0) {\r\n          List<UIRepositoryObjectAcl> retVal = new ArrayList<UIRepositoryObjectAcl>();\r\n          for (int i = 0; i < indices.length; i++) {\r\n            retVal.add(new UIRepositoryObjectAcl(viewAclsModel.getAceAtIndex(indices[i])));\r\n          }\r\n          return retVal;\r\n        }\r\n        return null;\r\n      }\r\n\r\n    };\r\n\r\n    // indexToAvalableUserConverter convert the selected indices to the list of objects and vice versa\r\n    BindingConvertor<int[], List<String>> indexToAvailableUserConverter = new BindingConvertor<int[], List<String>>() {\r\n\r\n      @Override\r\n      public List<String> sourceToTarget(int[] indices) {\r\n        List<String> userList = new ArrayList<String>();\r\n        for (int i = 0; i < indices.length; i++) {\r\n          userList.add(manageAclsModel.getAvailableUser(indices[i]));\r\n        }\r\n        return userList;\r\n      }\r\n\r\n      @Override\r\n      public int[] targetToSource(List<String> userList) {\r\n        int[] indices = new int[userList.size()];\r\n        int i = 0;\r\n        for (String user : userList) {\r\n          indices[i++] = manageAclsModel.getAvailableUserIndex(user);\r\n        }\r\n        return indices;\r\n      }\r\n\r\n    };\r\n\r\n    BindingConvertor<int[], List<String>> indexToAvailableRoleConverter = new BindingConvertor<int[], List<String>>() {\r\n\r\n      @Override\r\n      public List<String> sourceToTarget(int[] indices) {\r\n        List<String> roleList = new ArrayList<String>();\r\n        for (int i = 0; i < indices.length; i++) {\r\n          roleList.add(manageAclsModel.getAvailableRole(indices[i]));\r\n        }\r\n        return roleList;\r\n      }\r\n\r\n      @Override\r\n      public int[] targetToSource(List<String> roleList) {\r\n        int[] indices = new int[roleList.size()];\r\n        int i = 0;\r\n        for (String role : roleList) {\r\n          indices[i++] = manageAclsModel.getAvailableRoleIndex(role);\r\n        }\r\n        return indices;\r\n      }\r\n    };\r\n\r\n    BindingConvertor<int[], List<UIRepositoryObjectAcl>> indexToSelectedUserConverter = new BindingConvertor<int[], List<UIRepositoryObjectAcl>>() {\r\n\r\n      @Override\r\n      public List<UIRepositoryObjectAcl> sourceToTarget(int[] indices) {\r\n        List<UIRepositoryObjectAcl> userList = new ArrayList<UIRepositoryObjectAcl>();\r\n        for (int i = 0; i < indices.length; i++) {\r\n          userList.add(manageAclsModel.getSelectedUser(indices[i]));\r\n        }\r\n        return userList;\r\n      }\r\n\r\n      @Override\r\n      public int[] targetToSource(List<UIRepositoryObjectAcl> userList) {\r\n        int[] indices = new int[userList.size()];\r\n        int i = 0;\r\n        for (UIRepositoryObjectAcl user : userList) {\r\n          indices[i++] = manageAclsModel.getSelectedUserIndex(user);\r\n        }\r\n        return indices;\r\n      }\r\n\r\n    };\r\n\r\n    BindingConvertor<int[], List<UIRepositoryObjectAcl>> indexToSelectedRoleConverter = new BindingConvertor<int[], List<UIRepositoryObjectAcl>>() {\r\n\r\n      @Override\r\n      public List<UIRepositoryObjectAcl> sourceToTarget(int[] indices) {\r\n        List<UIRepositoryObjectAcl> roleList = new ArrayList<UIRepositoryObjectAcl>();\r\n        for (int i = 0; i < indices.length; i++) {\r\n          roleList.add(manageAclsModel.getSelectedRole(indices[i]));\r\n        }\r\n        return roleList;\r\n      }\r\n\r\n      @Override\r\n      public int[] targetToSource(List<UIRepositoryObjectAcl> roleList) {\r\n        int[] indices = new int[roleList.size()];\r\n        int i = 0;\r\n        for (UIRepositoryObjectAcl role : roleList) {\r\n          indices[i++] = manageAclsModel.getSelectedRoleIndex(role);\r\n        }\r\n        return indices;\r\n      }\r\n    };\r\n\r\n    // Binding between the selected incides of the lists to the mode list objects\r\n    bf.setBindingType(Binding.Type.BI_DIRECTIONAL);\r\n\r\n    bf.createBinding(availableUserList, \"selectedIndices\", manageAclsModel, \"selectedAvailableUsers\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        indexToAvailableUserConverter);\r\n    bf.createBinding(selectedUserList, \"selectedIndices\", manageAclsModel, \"selectedAssignedUsers\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        indexToSelectedUserConverter);\r\n    bf.createBinding(availableRoleList, \"selectedIndices\", manageAclsModel, \"selectedAvailableRoles\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        indexToAvailableRoleConverter);\r\n    bf.createBinding(selectedRoleList, \"selectedIndices\", manageAclsModel, \"selectedAssignedRoles\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        indexToSelectedRoleConverter);\r\n\r\n    // accumulatorButtonConverter determine whether to enable of disable the accumulator buttons\r\n    BindingConvertor<Integer, Boolean> accumulatorButtonConverter = new BindingConvertor<Integer, Boolean>() {\r\n\r\n      @Override\r\n      public Boolean sourceToTarget(Integer value) {\r\n        if (value != null && value >= 0) {\r\n          return true;\r\n        }\r\n        return false;\r\n      }\r\n\r\n      @Override\r\n      public Integer targetToSource(Boolean value) {\r\n        // TODO Auto-generated method stub\r\n        return null;\r\n      }\r\n    };\r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n    bf.createBinding(selectedUserList, \"selectedIndex\", manageAclsModel, \"userUnassignmentPossible\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        accumulatorButtonConverter);\r\n    bf\r\n        .createBinding(availableUserList, \"selectedIndex\", manageAclsModel, \"userAssignmentPossible\",//$NON-NLS-1$ //$NON-NLS-2$\r\n            accumulatorButtonConverter);\r\n    bf.createBinding(manageAclsModel, \"userUnassignmentPossible\", unassignUserButton, \"!disabled\");//$NON-NLS-1$ //$NON-NLS-2$\r\n    bf.createBinding(manageAclsModel, \"userAssignmentPossible\", assignUserButton, \"!disabled\");//$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n    bf.createBinding(selectedRoleList, \"selectedIndex\", manageAclsModel, \"roleUnassignmentPossible\",//$NON-NLS-1$ //$NON-NLS-2$\r\n        accumulatorButtonConverter);\r\n    bf\r\n        .createBinding(availableRoleList, \"selectedIndex\", manageAclsModel, \"roleAssignmentPossible\",//$NON-NLS-1$ //$NON-NLS-2$\r\n            accumulatorButtonConverter);\r\n\r\n    bf.createBinding(manageAclsModel, \"roleUnassignmentPossible\", unassignRoleButton, \"!disabled\");//$NON-NLS-1$ //$NON-NLS-2$\r\n    bf.createBinding(manageAclsModel, \"roleAssignmentPossible\", assignRoleButton, \"!disabled\");//$NON-NLS-1$ //$NON-NLS-2$\r\n\r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n\r\n    \r\n    BindingConvertor securityBindingConverter = new BindingConvertor<List<UIRepositoryObject>, List<UIRepositoryObjectAcl>>() {\r\n      @Override\r\n      public List<UIRepositoryObjectAcl> sourceToTarget(List<UIRepositoryObject> ro) {\r\n        if (ro == null) {\r\n          return null;\r\n        }\r\n        if (ro.size() <= 0) {\r\n          return null;\r\n        }\r\n        setSelectedRepositoryObject(ro);\r\n        viewAclsModel.setRemoveEnabled(false);\r\n        uncheckAllPermissionBox();\r\n        UIRepositoryObject repoObject = (UIRepositoryObject) ro.get(0);\r\n        try {\r\n          repoObject.readAcls(viewAclsModel);\r\n          fileFolderLabel.setValue(repoObject.getName());\r\n          bf.setBindingType(Binding.Type.ONE_WAY);\r\n          bf.createBinding(viewAclsModel, \"acls\", userRoleList, \"elements\"); //$NON-NLS-1$ //$NON-NLS-2$\r\n        } catch (AccessDeniedException ade) {\r\n          messageBox.setTitle(messages.getString(\"Dialog.Error\"));//$NON-NLS-1$\r\n          messageBox.setAcceptLabel(messages.getString(\"Dialog.Ok\"));//$NON-NLS-1$\r\n          messageBox.setMessage(BaseMessages.getString(RepositoryExplorer.class,\r\n              \"PermissionsController.UnableToGetAcls\", repoObject.getName(), ade.getLocalizedMessage()));//$NON-NLS-1$\r\n          \r\n          messageBox.open();\r\n        } catch (Exception e) {\r\n          messageBox.setTitle(messages.getString(\"Dialog.Error\"));//$NON-NLS-1$\r\n          messageBox.setAcceptLabel(messages.getString(\"Dialog.Ok\"));//$NON-NLS-1$\r\n          messageBox.setMessage(BaseMessages.getString(RepositoryExplorer.class,\r\n              \"PermissionsController.UnableToGetAcls\", repoObject.getName(), e.getLocalizedMessage())); //$NON-NLS-1$\r\n          messageBox.open();\r\n        }\r\n\r\n        aclDeck.setSelectedIndex(ACL);\r\n        return viewAclsModel.getAcls();\r\n      }\r\n\r\n      @Override\r\n      public List<UIRepositoryObject> targetToSource(List<UIRepositoryObjectAcl> elements) {\r\n        return null;\r\n      }\r\n    };\r\n    \r\n    // Binding between the selected repository objects and the user role list for acls\r\n    securityBinding = bf.createBinding(getBrowseController(), \"repositoryObjects\", userRoleList, \"elements\", securityBindingConverter);//$NON-NLS-1$ //$NON-NLS-2$\r\n    securityBinding = bf.createBinding(getBrowseController(), \"repositoryDirectories\", userRoleList, \"elements\", securityBindingConverter);//$NON-NLS-1$ //$NON-NLS-2$\r\n    \r\n    bf.setBindingType(Binding.Type.BI_DIRECTIONAL);\r\n\r\n    // Binding Add Remove button to the inherit check box. If the checkbox is checked that disable add remove\r\n    bf.createBinding(viewAclsModel, \"entriesInheriting\", inheritParentPermissionCheckbox, \"checked\"); //$NON-NLS-1$  //$NON-NLS-2$\r\n    // Binding the selected indices of acl list to the list of acl objects in the mode\r\n    bf.createBinding(userRoleList, \"selectedIndices\", viewAclsModel, \"selectedAclList\", indicesToObjectsConverter); //$NON-NLS-1$  //$NON-NLS-2$\r\n    \r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n    // Only enable add Acl button if the entries checkbox is unchecked\r\n    bf.createBinding(viewAclsModel, \"entriesInheriting\", addAclButton, \"disabled\");//$NON-NLS-1$  //$NON-NLS-2$ \r\n    // Only enable remove Acl button if the entries checkbox is unchecked and acl is selected from the list\r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", removeAclButton, \"!disabled\"); //$NON-NLS-1$  //$NON-NLS-2$ \r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", createCheckbox, \"!disabled\"); //$NON-NLS-1$  //$NON-NLS-2$\r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", updateCheckbox, \"!disabled\");//$NON-NLS-1$  //$NON-NLS-2$\r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", readCheckbox, \"!disabled\");//$NON-NLS-1$  //$NON-NLS-2$\r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", deleteCheckbox, \"!disabled\");//$NON-NLS-1$  //$NON-NLS-2$\r\n    bf.createBinding(viewAclsModel, \"removeEnabled\", modifyCheckbox, \"!disabled\");//$NON-NLS-1$  //$NON-NLS-2$\r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n    // Binding when the user select from the list\r\n    bf.createBinding(userRoleList, \"selectedItem\", this, \"recipientChanged\"); //$NON-NLS-1$  //$NON-NLS-2$\r\n    // Setting the default Deck to show no permission\r\n    aclDeck.setSelectedIndex(NO_ACL);\r\n    try {\r\n      if (securityBinding != null) {\r\n        securityBinding.fireSourceChanged();\r\n      }\r\n    } catch (Exception e) {\r\n      System.out.println(e.getMessage());\r\n      e.printStackTrace();\r\n    }\r\n  }","commit_id":"4553a4288cc26d4303597647f71b4ca2093376f2","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        //to test that the acknowledgement mechanism is working we better disable the wait for publish\n        //otherwise the operation is most likely acknowledged even if it doesn't support ack\n        return ImmutableSettings.builder()\n                .put(DiscoverySettings.PUBLISH_TIMEOUT, 0)\n                //make sure that enough concurrent reroutes can happen at the same time\n                //we have a minimum of 2 nodes, and a maximum of 10 shards, thus 5 should be enough\n                .put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES, 5)\n                .build();\n    }","id":78572,"modified_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        //to test that the acknowledgement mechanism is working we better disable the wait for publish\n        //otherwise the operation is most likely acknowledged even if it doesn't support ack\n        return ImmutableSettings.builder()\n                .put(super.nodeSettings(nodeOrdinal))\n                .put(DiscoverySettings.PUBLISH_TIMEOUT, 0)\n                //make sure that enough concurrent reroutes can happen at the same time\n                //we have a minimum of 2 nodes, and a maximum of 10 shards, thus 5 should be enough\n                .put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES, 5)\n                .build();\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        //to test that the acknowledgement mechanism is working we better disable the wait for publish\n        //otherwise the operation is most likely acknowledged even if it doesn't support ack\n        return ImmutableSettings.builder().put(DiscoverySettings.PUBLISH_TIMEOUT, 0).build();\n    }","id":78573,"modified_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        //to test that the acknowledgement mechanism is working we better disable the wait for publish\n        //otherwise the operation is most likely acknowledged even if it doesn't support ack\n        return ImmutableSettings.builder().put(super.nodeSettings(nodeOrdinal))\n                .put(DiscoverySettings.PUBLISH_TIMEOUT, 0).build();\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected synchronized Settings nodeSettings(int nodeOrdinal) {\n        if (nodeOrdinal == 0) { // at least one\n            return ImmutableSettings.builder().put(\"node.bench\", true).put(GroovyScriptEngineService.GROOVY_SCRIPT_SANDBOX_ENABLED, false).build();\n        } else {\n            if (benchNodes.containsKey(nodeOrdinal)) {\n                return ImmutableSettings.builder().put(\"node.bench\", benchNodes.get(nodeOrdinal)).put(GroovyScriptEngineService.GROOVY_SCRIPT_SANDBOX_ENABLED, false).build();\n            } else {\n                boolean b = randomBoolean();\n                benchNodes.put(nodeOrdinal, b);\n                return ImmutableSettings.builder().put(\"node.bench\", b).put(GroovyScriptEngineService.GROOVY_SCRIPT_SANDBOX_ENABLED, false).build();\n            }\n\n        }\n    }","id":78574,"modified_method":"protected synchronized Settings nodeSettings(int nodeOrdinal) {\n        if (nodeOrdinal == 0) { // at least one\n            return ImmutableSettings.builder().put(super.nodeSettings(nodeOrdinal))\n                    .put(\"node.bench\", true).put(GroovyScriptEngineService.GROOVY_SCRIPT_SANDBOX_ENABLED, false).build();\n        } else {\n            if (benchNodes.containsKey(nodeOrdinal)) {\n                return ImmutableSettings.builder().put(super.nodeSettings(nodeOrdinal))\n                        .put(\"node.bench\", benchNodes.get(nodeOrdinal)).put(GroovyScriptEngineService.GROOVY_SCRIPT_SANDBOX_ENABLED, false).build();\n            } else {\n                boolean b = randomBoolean();\n                benchNodes.put(nodeOrdinal, b);\n                return ImmutableSettings.builder().put(super.nodeSettings(nodeOrdinal))\n                        .put(\"node.bench\", b).put(GroovyScriptEngineService.GROOVY_SCRIPT_SANDBOX_ENABLED, false).build();\n            }\n        }\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected Settings nodeSettings(int nodeOrdinal) {\n        return ImmutableSettings.builder().put(\"node.bench\", false).build();\n    }","id":78575,"modified_method":"protected Settings nodeSettings(int nodeOrdinal) {\n        return ImmutableSettings.builder().put(super.nodeSettings(nodeOrdinal))\n                .put(\"node.bench\", false).build();\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        switch(nodeOrdinal) {\n        case 1:\n            return settingsBuilder().put(\"node.tag\", \"B\").build();\n        case 0:\n            return settingsBuilder().put(\"node.tag\", \"A\").build();\n        }\n        return super.nodeSettings(nodeOrdinal);\n    }","id":78576,"modified_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        switch(nodeOrdinal) {\n        case 1:\n            return settingsBuilder().put(super.nodeSettings(nodeOrdinal)).put(\"node.tag\", \"B\").build();\n        case 0:\n            return settingsBuilder().put(super.nodeSettings(nodeOrdinal)).put(\"node.tag\", \"A\").build();\n        }\n        return super.nodeSettings(nodeOrdinal);\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        return ImmutableSettings.builder()\n                .put(AssertingLocalTransport.ASSERTING_TRANSPORT_MIN_VERSION_KEY, Version.V_1_4_0).build();\n    }","id":78577,"modified_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        return ImmutableSettings.builder()\n                .put(super.nodeSettings(nodeOrdinal))\n                .put(AssertingLocalTransport.ASSERTING_TRANSPORT_MIN_VERSION_KEY, Version.V_1_4_0).build();\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Settings nodeSettings(int nodeOrdinal) {\n        //Set path so ScriptService will pick up the test scripts\n        return settingsBuilder().put(\"path.conf\", this.getResource(\"config\").getPath()).build();\n    }","id":78578,"modified_method":"@Override\n    public Settings nodeSettings(int nodeOrdinal) {\n        //Set path so ScriptService will pick up the test scripts\n        return settingsBuilder().put(super.nodeSettings(nodeOrdinal))\n                .put(\"path.conf\", this.getResource(\"config\").getPath()).build();\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        return builder().put(\"gateway.type\", \"local\").build();\n    }","id":78579,"modified_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        return builder().put(super.nodeSettings(nodeOrdinal)).put(\"gateway.type\", \"local\").build();\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        return ImmutableSettings.builder()\n                .put(\"threadpool.search.size\", 1)\n                .put(\"threadpool.search.queue_size\", 1)\n                .put(\"threadpool.index.size\", 1)\n                .put(\"threadpool.index.queue_size\", 1)\n                .put(\"threadpool.get.size\", 1)\n                .put(\"threadpool.get.queue_size\", 1)\n                .build();\n    }","id":78580,"modified_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        return ImmutableSettings.builder()\n                .put(super.nodeSettings(nodeOrdinal))\n                .put(\"threadpool.search.size\", 1)\n                .put(\"threadpool.search.queue_size\", 1)\n                .put(\"threadpool.index.size\", 1)\n                .put(\"threadpool.index.queue_size\", 1)\n                .put(\"threadpool.get.size\", 1)\n                .put(\"threadpool.get.queue_size\", 1)\n                .build();\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * to properly test the effect/functionality of shard_size, we need to force having 2 shards and also\n     * control the routing such that certain documents will end on each shard. Using \"djb\" routing hash + ignoring the\n     * doc type when hashing will ensure that docs with routing value \"1\" will end up in a different shard than docs with\n     * routing value \"2\".\n     */\n    @Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        return ImmutableSettings.builder()\n                .put(\"cluster.routing.operation.hash.type\", \"djb\")\n                .put(\"cluster.routing.operation.use_type\", \"false\")\n                .build();\n    }","id":78581,"modified_method":"/**\n     * to properly test the effect/functionality of shard_size, we need to force having 2 shards and also\n     * control the routing such that certain documents will end on each shard. Using \"djb\" routing hash + ignoring the\n     * doc type when hashing will ensure that docs with routing value \"1\" will end up in a different shard than docs with\n     * routing value \"2\".\n     */\n    @Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        return ImmutableSettings.builder()\n                .put(super.nodeSettings(nodeOrdinal))\n                .put(\"cluster.routing.operation.hash.type\", \"djb\")\n                .put(\"cluster.routing.operation.use_type\", \"false\")\n                .build();\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        // very frequent checks\n        return ImmutableSettings.builder().put(SearchService.KEEPALIVE_INTERVAL_KEY, TimeValue.timeValueMillis(1)).build();\n    }","id":78582,"modified_method":"@Override\n    protected Settings nodeSettings(int nodeOrdinal) {\n        // very frequent checks\n        return ImmutableSettings.builder().put(super.nodeSettings(nodeOrdinal))\n                .put(SearchService.KEEPALIVE_INTERVAL_KEY, TimeValue.timeValueMillis(1)).build();\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Settings nodeSettings(int nodeOrdinal) {\n        return settingsBuilder().put(\"path.conf\", this.getResource(\"config\").getPath()).build();\n    }","id":78583,"modified_method":"@Override\n    public Settings nodeSettings(int nodeOrdinal) {\n        return settingsBuilder().put(super.nodeSettings(nodeOrdinal))\n                .put(\"path.conf\", this.getResource(\"config\").getPath()).build();\n    }","commit_id":"88839ec5465b30baba34bd8cd1b7c9407aa97345","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public MBCategory updateCategory(\n\t\t\tlong categoryId, long parentCategoryId, String name,\n\t\t\tString description, String emailAddress, String inProtocol,\n\t\t\tString inServerName, int inServerPort, boolean inUseSSL,\n\t\t\tString inUserName, String inPassword, int inReadInterval,\n\t\t\tString outEmailAddress, boolean outCustom, String outServerName,\n\t\t\tint outServerPort, boolean outUseSSL, String outUserName,\n\t\t\tString outPassword, boolean mailingListActive,\n\t\t\tboolean mergeWithParentCategory, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Category\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tcategoryId);\n\n\t\tparentCategoryId = getParentCategoryId(category, parentCategoryId);\n\n\t\tvalidate(name);\n\n\t\tcategory.setModifiedDate(new Date());\n\t\tcategory.setParentCategoryId(parentCategoryId);\n\t\tcategory.setName(name);\n\t\tcategory.setDescription(description);\n\n\t\tmbCategoryPersistence.update(category, false);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = category.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Merge categories\n\n\t\tif (mergeWithParentCategory &&\n\t\t\t(categoryId != parentCategoryId) &&\n\t\t\t(parentCategoryId != MBCategoryImpl.DEFAULT_PARENT_CATEGORY_ID)) {\n\n\t\t\tmergeCategories(category, parentCategoryId);\n\t\t}\n\n\t\t// Mailing list\n\n\t\tMBMailingList mailingList = mbMailingListPersistence.fetchByCategoryId(\n\t\t\tcategory.getCategoryId());\n\n\t\tif (mailingList != null) {\n\t\t\tmbMailingListLocalService.updateMailingList(\n\t\t\t\tmailingList.getMailingListId(), emailAddress, inProtocol,\n\t\t\t\tinServerName, inServerPort, inUseSSL, inUserName, inPassword,\n\t\t\t\tinReadInterval, outEmailAddress, outCustom, outServerName,\n\t\t\t\toutServerPort, outUseSSL, outUserName, outPassword,\n\t\t\t\tmailingListActive);\n\t\t}\n\t\telse {\n\t\t\tmbMailingListLocalService.addMailingList(\n\t\t\t\tnull, category.getUserId(), category.getCategoryId(),\n\t\t\t\temailAddress, inProtocol, inServerName, inServerPort, inUseSSL,\n\t\t\t\tinUserName, inPassword, inReadInterval, outEmailAddress,\n\t\t\t\toutCustom, outServerName, outServerPort, outUseSSL, outUserName,\n\t\t\t\toutPassword, mailingListActive);\n\t\t}\n\n\t\treturn category;\n\t}","id":78584,"modified_method":"public MBCategory updateCategory(\n\t\t\tlong categoryId, long parentCategoryId, String name,\n\t\t\tString description, String emailAddress, String inProtocol,\n\t\t\tString inServerName, int inServerPort, boolean inUseSSL,\n\t\t\tString inUserName, String inPassword, int inReadInterval,\n\t\t\tString outEmailAddress, boolean outCustom, String outServerName,\n\t\t\tint outServerPort, boolean outUseSSL, String outUserName,\n\t\t\tString outPassword, boolean mailingListActive,\n\t\t\tboolean mergeWithParentCategory, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Category\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tcategoryId);\n\n\t\tparentCategoryId = getParentCategoryId(category, parentCategoryId);\n\n\t\tvalidate(name);\n\n\t\tcategory.setModifiedDate(new Date());\n\t\tcategory.setParentCategoryId(parentCategoryId);\n\t\tcategory.setName(name);\n\t\tcategory.setDescription(description);\n\n\t\tmbCategoryPersistence.update(category, false);\n\n\t\t// Merge categories\n\n\t\tif (mergeWithParentCategory &&\n\t\t\t(categoryId != parentCategoryId) &&\n\t\t\t(parentCategoryId != MBCategoryImpl.DEFAULT_PARENT_CATEGORY_ID)) {\n\n\t\t\tmergeCategories(category, parentCategoryId);\n\t\t}\n\n\t\t// Mailing list\n\n\t\tMBMailingList mailingList = mbMailingListPersistence.fetchByCategoryId(\n\t\t\tcategory.getCategoryId());\n\n\t\tif (mailingList != null) {\n\t\t\tmbMailingListLocalService.updateMailingList(\n\t\t\t\tmailingList.getMailingListId(), emailAddress, inProtocol,\n\t\t\t\tinServerName, inServerPort, inUseSSL, inUserName, inPassword,\n\t\t\t\tinReadInterval, outEmailAddress, outCustom, outServerName,\n\t\t\t\toutServerPort, outUseSSL, outUserName, outPassword,\n\t\t\t\tmailingListActive);\n\t\t}\n\t\telse {\n\t\t\tmbMailingListLocalService.addMailingList(\n\t\t\t\tnull, category.getUserId(), category.getCategoryId(),\n\t\t\t\temailAddress, inProtocol, inServerName, inServerPort, inUseSSL,\n\t\t\t\tinUserName, inPassword, inReadInterval, outEmailAddress,\n\t\t\t\toutCustom, outServerName, outServerPort, outUseSSL, outUserName,\n\t\t\t\toutPassword, mailingListActive);\n\t\t}\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = category.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\treturn category;\n\t}","commit_id":"d1fd2d226a484826e8ebf1149ac4c1d57729435a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBCategory addCategory(\n\t\t\tString uuid, long userId, long parentCategoryId,\n\t\t\tString name, String description, String emailAddress,\n\t\t\tString inProtocol, String inServerName, int inServerPort,\n\t\t\tboolean inUseSSL, String inUserName, String inPassword,\n\t\t\tint inReadInterval, String outEmailAddress, boolean outCustom,\n\t\t\tString outServerName, int outServerPort, boolean outUseSSL,\n\t\t\tString outUserName, String outPassword, boolean mailingListActive,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Category\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tparentCategoryId = getParentCategoryId(groupId, parentCategoryId);\n\t\tDate now = new Date();\n\n\t\tvalidate(name);\n\n\t\tlong categoryId = counterLocalService.increment();\n\n\t\tMBCategory category = mbCategoryPersistence.create(categoryId);\n\n\t\tcategory.setUuid(uuid);\n\t\tcategory.setGroupId(groupId);\n\t\tcategory.setCompanyId(user.getCompanyId());\n\t\tcategory.setUserId(user.getUserId());\n\t\tcategory.setUserName(user.getFullName());\n\t\tcategory.setCreateDate(now);\n\t\tcategory.setModifiedDate(now);\n\t\tcategory.setParentCategoryId(parentCategoryId);\n\t\tcategory.setName(name);\n\t\tcategory.setDescription(description);\n\n\t\tmbCategoryPersistence.update(category, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddCategoryResources(\n\t\t\t\tcategory, serviceContext.getAddCommunityPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddCategoryResources(\n\t\t\t\tcategory, serviceContext.getCommunityPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = category.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Mailing list\n\n\t\tmbMailingListLocalService.addMailingList(\n\t\t\tnull, userId, category.getCategoryId(), emailAddress, inProtocol,\n\t\t\tinServerName, inServerPort, inUseSSL, inUserName, inPassword,\n\t\t\tinReadInterval, outEmailAddress, outCustom, outServerName,\n\t\t\toutServerPort, outUseSSL, outUserName, outPassword,\n\t\t\tmailingListActive);\n\n\t\treturn category;\n\t}","id":78585,"modified_method":"public MBCategory addCategory(\n\t\t\tString uuid, long userId, long parentCategoryId,\n\t\t\tString name, String description, String emailAddress,\n\t\t\tString inProtocol, String inServerName, int inServerPort,\n\t\t\tboolean inUseSSL, String inUserName, String inPassword,\n\t\t\tint inReadInterval, String outEmailAddress, boolean outCustom,\n\t\t\tString outServerName, int outServerPort, boolean outUseSSL,\n\t\t\tString outUserName, String outPassword, boolean mailingListActive,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Category\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong groupId = serviceContext.getScopeGroupId();\n\t\tparentCategoryId = getParentCategoryId(groupId, parentCategoryId);\n\t\tDate now = new Date();\n\n\t\tvalidate(name);\n\n\t\tlong categoryId = counterLocalService.increment();\n\n\t\tMBCategory category = mbCategoryPersistence.create(categoryId);\n\n\t\tcategory.setUuid(uuid);\n\t\tcategory.setGroupId(groupId);\n\t\tcategory.setCompanyId(user.getCompanyId());\n\t\tcategory.setUserId(user.getUserId());\n\t\tcategory.setUserName(user.getFullName());\n\t\tcategory.setCreateDate(now);\n\t\tcategory.setModifiedDate(now);\n\t\tcategory.setParentCategoryId(parentCategoryId);\n\t\tcategory.setName(name);\n\t\tcategory.setDescription(description);\n\n\t\tmbCategoryPersistence.update(category, false);\n\n\t\t// Resources\n\n\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\taddCategoryResources(\n\t\t\t\tcategory, serviceContext.getAddCommunityPermissions(),\n\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t}\n\t\telse {\n\t\t\taddCategoryResources(\n\t\t\t\tcategory, serviceContext.getCommunityPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Mailing list\n\n\t\tmbMailingListLocalService.addMailingList(\n\t\t\tnull, userId, category.getCategoryId(), emailAddress, inProtocol,\n\t\t\tinServerName, inServerPort, inUseSSL, inUserName, inPassword,\n\t\t\tinReadInterval, outEmailAddress, outCustom, outServerName,\n\t\t\toutServerPort, outUseSSL, outUserName, outPassword,\n\t\t\tmailingListActive);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = category.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\treturn category;\n\t}","commit_id":"d1fd2d226a484826e8ebf1149ac4c1d57729435a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteCategory(MBCategory category)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Categories\n\n\t\tList<MBCategory> categories = mbCategoryPersistence.findByG_P(\n\t\t\tcategory.getGroupId(), category.getCategoryId());\n\n\t\tfor (MBCategory curCategory : categories) {\n\t\t\tdeleteCategory(curCategory);\n\t\t}\n\n\t\t// Indexer\n\n\t\ttry {\n\t\t\tIndexer.deleteMessages(\n\t\t\t\tcategory.getCompanyId(), category.getCategoryId());\n\t\t}\n\t\tcatch (SearchException se) {\n\t\t\t_log.error(\"Deleting index \" + category.getCategoryId(), se);\n\t\t}\n\n\t\t// Threads\n\n\t\tmbThreadLocalService.deleteThreads(category.getCategoryId());\n\n\t\t// Mailing list\n\n\t\ttry {\n\t\t\tmbMailingListLocalService.deleteCategoryMailingList(\n\t\t\t\tcategory.getCategoryId());\n\t\t}\n\t\tcatch (NoSuchMailingListException nsmle) {\n\t\t}\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tcategory.getCompanyId(), MBCategory.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, category.getCategoryId());\n\n\t\t// Category\n\n\t\tmbCategoryPersistence.remove(category);\n\t}","id":78586,"modified_method":"public void deleteCategory(MBCategory category)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Categories\n\n\t\tList<MBCategory> categories = mbCategoryPersistence.findByG_P(\n\t\t\tcategory.getGroupId(), category.getCategoryId());\n\n\t\tfor (MBCategory curCategory : categories) {\n\t\t\tdeleteCategory(curCategory);\n\t\t}\n\n\t\t// Indexer\n\n\t\ttry {\n\t\t\tIndexer.deleteMessages(\n\t\t\t\tcategory.getCompanyId(), category.getCategoryId());\n\t\t}\n\t\tcatch (SearchException se) {\n\t\t\t_log.error(\"Deleting index \" + category.getCategoryId(), se);\n\t\t}\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tMBCategory.class.getName(), category.getCategoryId());\n\n\t\t// Threads\n\n\t\tmbThreadLocalService.deleteThreads(category.getCategoryId());\n\n\t\t// Mailing list\n\n\t\ttry {\n\t\t\tmbMailingListLocalService.deleteCategoryMailingList(\n\t\t\t\tcategory.getCategoryId());\n\t\t}\n\t\tcatch (NoSuchMailingListException nsmle) {\n\t\t}\n\n\t\t// Resources\n\n\t\tresourceLocalService.deleteResource(\n\t\t\tcategory.getCompanyId(), MBCategory.class.getName(),\n\t\t\tResourceConstants.SCOPE_INDIVIDUAL, category.getCategoryId());\n\n\t\t// Category\n\n\t\tmbCategoryPersistence.remove(category);\n\t}","commit_id":"d1fd2d226a484826e8ebf1149ac4c1d57729435a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, String userName, long categoryId,\n\t\t\tlong threadId, long parentMessageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files, boolean anonymous,\n\t\t\tdouble priority, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tcategoryId);\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tlogAddMessage(messageId, stopWatch, 1);\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setGroupId(category.getGroupId());\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(now);\n\t\tmessage.setModifiedDate(now);\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageImpl.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageImpl.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(category.getGroupId());\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\n\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\t\t}\n\n\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\tif (anonymous) {\n\t\t\tthread.setLastPostByUserId(0);\n\t\t}\n\t\telse {\n\t\t\tthread.setLastPostByUserId(userId);\n\t\t}\n\n\t\tthread.setLastPostDate(now);\n\n\t\tif ((priority != MBThreadImpl.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 2);\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadImpl.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong groupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 3);\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 4);\n\n\t\t// Resources\n\n\t\tif (!category.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddCommunityPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getCommunityPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 5);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\t// Statistics\n\n\t\tif (!category.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId, now);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 6);\n\n\t\t// Category\n\n\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\tcategory.setLastPostDate(now);\n\n\t\tmbCategoryPersistence.update(category, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 7);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\tlogAddMessage(messageId, stopWatch, 8);\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser()) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\n\t\t\tif (parentMessage != null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessageId, activityType, StringPool.BLANK, receiverUserId);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 9);\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(category, message, serviceContext, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 10);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\t// Indexer\n\n\t\treIndex(message);\n\n\t\tlogAddMessage(messageId, stopWatch, 11);\n\n\t\treturn message;\n\t}","id":78587,"modified_method":"public MBMessage addMessage(\n\t\t\tString uuid, long userId, String userName, long categoryId,\n\t\t\tlong threadId, long parentMessageId, String subject, String body,\n\t\t\tList<ObjectValuePair<String, byte[]>> files, boolean anonymous,\n\t\t\tdouble priority, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\t// Message\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tuserName = user.isDefaultUser() ? userName : user.getFullName();\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tcategoryId);\n\t\tsubject = ModelHintsUtil.trimString(\n\t\t\tMBMessage.class.getName(), \"subject\", subject);\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences != null) {\n\t\t\tif (!MBUtil.isAllowAnonymousPosting(preferences)) {\n\t\t\t\tif (anonymous || user.isDefaultUser()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (user.isDefaultUser()) {\n\t\t\tanonymous = true;\n\t\t}\n\n\t\tDate now = new Date();\n\n\t\tvalidate(subject, body);\n\n\t\tlong messageId = counterLocalService.increment();\n\n\t\tlogAddMessage(messageId, stopWatch, 1);\n\n\t\tMBMessage message = mbMessagePersistence.create(messageId);\n\n\t\tmessage.setUuid(uuid);\n\t\tmessage.setGroupId(category.getGroupId());\n\t\tmessage.setCompanyId(user.getCompanyId());\n\t\tmessage.setUserId(user.getUserId());\n\t\tmessage.setUserName(userName);\n\t\tmessage.setCreateDate(now);\n\t\tmessage.setModifiedDate(now);\n\n\t\t// Thread\n\n\t\tMBMessage parentMessage = mbMessagePersistence.fetchByPrimaryKey(\n\t\t\tparentMessageId);\n\n\t\tif (parentMessage == null) {\n\t\t\tparentMessageId = MBMessageImpl.DEFAULT_PARENT_MESSAGE_ID;\n\t\t}\n\n\t\tMBThread thread = null;\n\n\t\tif (threadId > 0) {\n\t\t\tthread = mbThreadPersistence.fetchByPrimaryKey(threadId);\n\t\t}\n\n\t\tif ((thread == null) ||\n\t\t\t(parentMessageId == MBMessageImpl.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\tthreadId = counterLocalService.increment();\n\n\t\t\tthread = mbThreadPersistence.create(threadId);\n\n\t\t\tthread.setGroupId(category.getGroupId());\n\t\t\tthread.setCategoryId(categoryId);\n\t\t\tthread.setRootMessageId(messageId);\n\n\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\t\t}\n\n\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\tif (anonymous) {\n\t\t\tthread.setLastPostByUserId(0);\n\t\t}\n\t\telse {\n\t\t\tthread.setLastPostByUserId(userId);\n\t\t}\n\n\t\tthread.setLastPostDate(now);\n\n\t\tif ((priority != MBThreadImpl.PRIORITY_NOT_GIVEN) &&\n\t\t\t(thread.getPriority() != priority)) {\n\n\t\t\tthread.setPriority(priority);\n\n\t\t\tupdatePriorities(thread.getThreadId(), priority);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 2);\n\n\t\t// Message\n\n\t\tmessage.setCategoryId(categoryId);\n\t\tmessage.setThreadId(threadId);\n\t\tmessage.setParentMessageId(parentMessageId);\n\t\tmessage.setSubject(subject);\n\t\tmessage.setBody(body);\n\t\tmessage.setAttachments(!files.isEmpty());\n\t\tmessage.setAnonymous(anonymous);\n\n\t\tif (priority != MBThreadImpl.PRIORITY_NOT_GIVEN) {\n\t\t\tmessage.setPriority(priority);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (files.size() > 0) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong groupId = GroupConstants.DEFAULT_PARENT_GROUP_ID;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdlService.addDirectory(companyId, repositoryId, dirName);\n\n\t\t\tfor (int i = 0; i < files.size(); i++) {\n\t\t\t\tObjectValuePair<String, byte[]> ovp = files.get(i);\n\n\t\t\t\tString fileName = ovp.getKey();\n\t\t\t\tbyte[] bytes = ovp.getValue();\n\n\t\t\t\ttry {\n\t\t\t\t\tdlService.addFile(\n\t\t\t\t\t\tcompanyId, portletId, groupId, repositoryId,\n\t\t\t\t\t\tdirName + \"/\" + fileName, 0, StringPool.BLANK,\n\t\t\t\t\t\tmessage.getModifiedDate(), new ServiceContext(), bytes);\n\t\t\t\t}\n\t\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t\t_log.debug(dfe.getMessage());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 3);\n\n\t\t// Commit\n\n\t\tmbThreadPersistence.update(thread, false);\n\t\tmbMessagePersistence.update(message, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 4);\n\n\t\t// Resources\n\n\t\tif (!category.isDiscussion()) {\n\t\t\tif (user.isDefaultUser()) {\n\t\t\t\taddMessageResources(message, true, true);\n\t\t\t}\n\t\t\tif (serviceContext.getAddCommunityPermissions() ||\n\t\t\t\tserviceContext.getAddGuestPermissions()) {\n\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getAddCommunityPermissions(),\n\t\t\t\t\tserviceContext.getAddGuestPermissions());\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddMessageResources(\n\t\t\t\t\tmessage, serviceContext.getCommunityPermissions(),\n\t\t\t\t\tserviceContext.getGuestPermissions());\n\t\t\t}\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 5);\n\n\t\t// Statistics\n\n\t\tif (!category.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId, now);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 6);\n\n\t\t// Category\n\n\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\tcategory.setLastPostDate(now);\n\n\t\tmbCategoryPersistence.update(category, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 7);\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, message, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\tlogAddMessage(messageId, stopWatch, 8);\n\n\t\t// Expando\n\n\t\tExpandoBridge expandoBridge = message.getExpandoBridge();\n\n\t\texpandoBridge.setAttributes(serviceContext);\n\n\t\tlogAddMessage(messageId, stopWatch, 9);\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser()) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\n\t\t\tif (parentMessage != null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessageId, activityType, StringPool.BLANK, receiverUserId);\n\t\t}\n\n\t\tlogAddMessage(messageId, stopWatch, 10);\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(category, message, serviceContext, false);\n\n\t\tlogAddMessage(messageId, stopWatch, 11);\n\n\t\t// Testing roll back\n\n\t\t/*if (true) {\n\t\t\tthrow new SystemException(\"Testing roll back\");\n\t\t}*/\n\n\t\t// Indexer\n\n\t\treIndex(message);\n\n\t\tlogAddMessage(messageId, stopWatch, 12);\n\n\t\treturn message;\n\t}","commit_id":"d1fd2d226a484826e8ebf1149ac4c1d57729435a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteMessage(MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Indexer\n\n\t\ttry {\n\t\t\tIndexer.deleteMessage(\n\t\t\t\tmessage.getCompanyId(), message.getMessageId());\n\t\t}\n\t\tcatch (SearchException se) {\n\t\t\t_log.error(\"Deleting index \" + message.getMessageId(), se);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (message.isAttachments()) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Thread\n\n\t\tint count = mbMessagePersistence.countByThreadId(message.getThreadId());\n\n\t\t// Message flags\n\n\t\tif (message.isRoot()) {\n\t\t\tmbMessageFlagLocalService.deleteQuestionAndAnswerFlags(\n\t\t\t\tmessage.getThreadId());\n\t\t}\n\n\t\tif (count == 1) {\n\n\t\t\t// Attachments\n\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getThreadAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\t\tmessage.getCompanyId(), MBThread.class.getName(),\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Thread\n\n\t\t\tmbThreadPersistence.remove(message.getThreadId());\n\n\t\t\t// Category\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getCategoryId());\n\n\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\t\telse if (count > 1) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Message is a root message\n\n\t\t\tif (thread.getRootMessageId() == message.getMessageId()) {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\tif (childrenMessages.size() > 1) {\n\t\t\t\t\tthrow new RequiredMessageException(\n\t\t\t\t\t\tString.valueOf(message.getMessageId()));\n\t\t\t\t}\n\t\t\t\telse if (childrenMessages.size() == 1) {\n\t\t\t\t\tMBMessage childMessage = childrenMessages.get(0);\n\n\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\tMBMessageImpl.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\n\t\t\t\t\tthread.setRootMessageId(childMessage.getMessageId());\n\n\t\t\t\t\tmbThreadPersistence.update(thread, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Message is a child message\n\n\t\t\telse {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\t// Message has children messages\n\n\t\t\t\tif (childrenMessages.size() > 0) {\n\t\t\t\t\tIterator<MBMessage> itr = childrenMessages.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tMBMessage childMessage = itr.next();\n\n\t\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Thread\n\n\t\t\tthread.setMessageCount(count - 1);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\t// Category\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getCategoryId());\n\n\t\t\tcategory.setMessageCount(count - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.deleteActivities(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId());\n\t\t}\n\n\t\t// Message flags\n\n\t\tmbMessageFlagPersistence.removeByMessageId(message.getMessageId());\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tresourceLocalService.deleteResource(\n\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, message.getMessageId());\n\t\t}\n\n\t\t// Message\n\n\t\tmbMessagePersistence.remove(message);\n\t}","id":78588,"modified_method":"public void deleteMessage(MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Indexer\n\n\t\ttry {\n\t\t\tIndexer.deleteMessage(\n\t\t\t\tmessage.getCompanyId(), message.getMessageId());\n\t\t}\n\t\tcatch (SearchException se) {\n\t\t\t_log.error(\"Deleting index \" + message.getMessageId(), se);\n\t\t}\n\n\t\t// Attachments\n\n\t\tif (message.isAttachments()) {\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Thread\n\n\t\tint count = mbMessagePersistence.countByThreadId(message.getThreadId());\n\n\t\t// Message flags\n\n\t\tif (message.isRoot()) {\n\t\t\tmbMessageFlagLocalService.deleteQuestionAndAnswerFlags(\n\t\t\t\tmessage.getThreadId());\n\t\t}\n\n\t\tif (count == 1) {\n\n\t\t\t// Attachments\n\n\t\t\tlong companyId = message.getCompanyId();\n\t\t\tString portletId = CompanyConstants.SYSTEM_STRING;\n\t\t\tlong repositoryId = CompanyConstants.SYSTEM;\n\t\t\tString dirName = message.getThreadAttachmentsDir();\n\n\t\t\ttry {\n\t\t\t\tdlService.deleteDirectory(\n\t\t\t\t\tcompanyId, portletId, repositoryId, dirName);\n\t\t\t}\n\t\t\tcatch (NoSuchDirectoryException nsde) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(nsde.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Subscriptions\n\n\t\t\tsubscriptionLocalService.deleteSubscriptions(\n\t\t\t\tmessage.getCompanyId(), MBThread.class.getName(),\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Thread\n\n\t\t\tmbThreadPersistence.remove(message.getThreadId());\n\n\t\t\t// Category\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getCategoryId());\n\n\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\t\telse if (count > 1) {\n\t\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getThreadId());\n\n\t\t\t// Message is a root message\n\n\t\t\tif (thread.getRootMessageId() == message.getMessageId()) {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\tif (childrenMessages.size() > 1) {\n\t\t\t\t\tthrow new RequiredMessageException(\n\t\t\t\t\t\tString.valueOf(message.getMessageId()));\n\t\t\t\t}\n\t\t\t\telse if (childrenMessages.size() == 1) {\n\t\t\t\t\tMBMessage childMessage = childrenMessages.get(0);\n\n\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\tMBMessageImpl.DEFAULT_PARENT_MESSAGE_ID);\n\n\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\n\t\t\t\t\tthread.setRootMessageId(childMessage.getMessageId());\n\n\t\t\t\t\tmbThreadPersistence.update(thread, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Message is a child message\n\n\t\t\telse {\n\t\t\t\tList<MBMessage> childrenMessages =\n\t\t\t\t\tmbMessagePersistence.findByT_P(\n\t\t\t\t\t\tmessage.getThreadId(), message.getMessageId());\n\n\t\t\t\t// Message has children messages\n\n\t\t\t\tif (childrenMessages.size() > 0) {\n\t\t\t\t\tIterator<MBMessage> itr = childrenMessages.iterator();\n\n\t\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\t\tMBMessage childMessage = itr.next();\n\n\t\t\t\t\t\tchildMessage.setParentMessageId(\n\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tmbMessagePersistence.update(childMessage, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Thread\n\n\t\t\tthread.setMessageCount(count - 1);\n\n\t\t\tmbThreadPersistence.update(thread, false);\n\n\t\t\t// Category\n\n\t\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tmessage.getCategoryId());\n\n\t\t\tcategory.setMessageCount(count - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Expando\n\n\t\texpandoValueLocalService.deleteValues(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Social\n\n\t\tsocialActivityLocalService.deleteActivities(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tMBMessage.class.getName(), message.getMessageId());\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), message.getUserId());\n\t\t}\n\n\t\t// Message flags\n\n\t\tmbMessageFlagPersistence.removeByMessageId(message.getMessageId());\n\n\t\t// Resources\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tresourceLocalService.deleteResource(\n\t\t\t\tmessage.getCompanyId(), MBMessage.class.getName(),\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL, message.getMessageId());\n\t\t}\n\n\t\t// Message\n\n\t\tmbMessagePersistence.remove(message);\n\t}","commit_id":"d1fd2d226a484826e8ebf1149ac4c1d57729435a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\r\n\t * Checks if the current user should be granted the requested permission on the target object.\r\n\t * @param authentication The authentication object of the current user\r\n\t * @param targetDomainObject The target object the user is attempting to access\r\n\t * @param permission The permission requested on the target object (e.g. view, deploy)\r\n\t * @return boolean value - true if permission is granted, false otherwise.\r\n\t */\r\n\t@Override\r\n    public boolean hasPermission(final Authentication authentication, final Object targetDomainObject, \r\n    \t\tfinal Object permission) {\r\n\t\t\r\n\t\tif (StringUtils.isBlank(SPRING_SECURITY_PROFILE) \r\n\t\t\t\t|| SPRING_SECURITY_PROFILE.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_NON_SECURE)) {\r\n\t\t\t//security is off\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\tif (logger.isLoggable(Level.FINEST)) {\r\n\t\t\tlogger.finest(\"Starting \\\"hasPermission\\\" for user: \" + authentication.getName());\r\n\t\t\tlogger.finest(\"with roles: \" + getUserRolesString(authentication));\r\n\t\t\tlogger.finest(\"and with authGroups: \" + getUserAuthGroupsString(authentication));\r\n\t\t\tlogger.finest(\"requested permission: \" + permission.toString());\r\n\t\t\tlogger.finest(\"on target authGroups: \" + targetDomainObject.toString());\r\n\t\t}\t\t\r\n\t\t\r\n\t\tboolean permissionGranted = false;\r\n\t\tString permissionName, targetAuthGroups;\r\n\t\t\r\n    \tif (authentication == null || authentication instanceof AnonymousAuthenticationToken) {\r\n\t\t\tthrow new AccessDeniedException(\"Anonymous user is not supported\");\r\n    \t}\r\n    \t\r\n    \tif (!(authentication instanceof CustomAuthenticationToken)) {\r\n    \t\tthrow new AccessDeniedException(\"Authentication object type not supported\");\r\n    \t}\r\n\t\t\r\n\t\tif (permission != null && !(permission instanceof String)) {\r\n    \t\tthrow new AuthorizationServiceException(\"Failed to verify permissions, invalid permission object type: \"\r\n    \t\t\t\t+ permission.getClass().getName());\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpermissionName = (String) permission;\r\n    \tif (StringUtils.isBlank(permissionName)) {\r\n    \t\tthrow new AuthorizationServiceException(\"Failed to verify permissions, missing permission name\");\r\n    \t}\r\n    \t\r\n    \tif (!permissionName.equalsIgnoreCase(PERMISSION_TO_VIEW) \r\n    \t\t\t&& !permissionName.equalsIgnoreCase(PERMISSION_TO_DEPLOY)) {\r\n    \t\tthrow new AuthorizationServiceException(\"Unsupported permission name: \" + permissionName\r\n    \t\t\t\t+ \". valid permission names are: \" + PERMISSION_TO_VIEW + \", \" + PERMISSION_TO_DEPLOY);\r\n    \t}\r\n    \t\r\n    \tif (targetDomainObject != null && !(targetDomainObject instanceof String)) {\r\n    \t\tthrow new AuthorizationServiceException(\"Failed to verify permissions, invalid authorization groups object\"\r\n    \t\t\t\t+ \" type: \" + targetDomainObject.getClass().getName());\t\t\t\r\n\t\t}\r\n    \t\r\n    \tif (targetDomainObject == null) {\r\n    \t\ttargetAuthGroups = \"\";\r\n    \t} else {\r\n    \t\ttargetAuthGroups = ((String) targetDomainObject).trim();\t\r\n    \t}\r\n    \t\r\n\t\tif (hasRequiredRoles(authentication, permissionName) \r\n\t\t\t\t&& hasAuthGroupAccess((CustomAuthenticationToken) authentication, targetAuthGroups, permissionName)) {\r\n\t\t\tpermissionGranted = true;\r\n\t\t}\r\n\t\t\r\n     \treturn permissionGranted;\r\n    }","id":78589,"modified_method":"/**\r\n\t * Checks if the current user should be granted the requested permission on the target object.\r\n\t * @param authentication The authentication object of the current user\r\n\t * @param targetDomainObject The target object the user is attempting to access\r\n\t * @param permission The permission requested on the target object (e.g. view, deploy)\r\n\t * @return boolean value - true if permission is granted, false otherwise.\r\n\t */\r\n\t@Override\r\n    public boolean hasPermission(final Authentication authentication, final Object targetDomainObject, \r\n    \t\tfinal Object permission) {\r\n\t\t\r\n\t\tif (StringUtils.isBlank(SPRING_SECURITY_PROFILE) \r\n\t\t\t\t|| SPRING_SECURITY_PROFILE.equalsIgnoreCase(CloudifyConstants.SPRING_PROFILE_NON_SECURE)) {\r\n\t\t\t//security is off\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\t\r\n\t\tif (logger.isLoggable(Level.FINEST)) {\r\n\t\t\tlogger.finest(\"Starting \\\"hasPermission\\\" for user: \" + authentication.getName());\r\n\t\t\tlogger.finest(\"with roles: \" + getUserRolesString(authentication));\r\n\t\t\tlogger.finest(\"and with authGroups: \" + getUserAuthGroupsString(authentication));\r\n\t\t\tlogger.finest(\"requested permission: \" + permission.toString());\r\n\t\t\tlogger.finest(\"on target authGroups: \" + targetDomainObject.toString());\r\n\t\t}\t\t\r\n\t\t\r\n\t\tboolean permissionGranted = false;\r\n\t\tString permissionName, targetAuthGroups;\r\n\t\t\r\n    \tif (authentication == null || authentication instanceof AnonymousAuthenticationToken) {\r\n\t\t\tthrow new AccessDeniedException(\"Anonymous user is not supported\");\r\n    \t}\r\n    \t\r\n    \tif (!(authentication instanceof CustomAuthenticationToken)\r\n    \t\t\t&& !(authentication instanceof UsernamePasswordAuthenticationToken)) {\r\n    \t\tthrow new AccessDeniedException(\"Authentication object type not supported. \"\r\n    \t\t\t\t+ \"Verify your Spring configuration is valid.\");\r\n    \t}\r\n\t\t\r\n\t\tif (permission != null && !(permission instanceof String)) {\r\n    \t\tthrow new AuthorizationServiceException(\"Failed to verify permissions, invalid permission object type: \"\r\n    \t\t\t\t+ permission.getClass().getName());\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tpermissionName = (String) permission;\r\n    \tif (StringUtils.isBlank(permissionName)) {\r\n    \t\tthrow new AuthorizationServiceException(\"Failed to verify permissions, missing permission name\");\r\n    \t}\r\n    \t\r\n    \tif (!permissionName.equalsIgnoreCase(PERMISSION_TO_VIEW) \r\n    \t\t\t&& !permissionName.equalsIgnoreCase(PERMISSION_TO_DEPLOY)) {\r\n    \t\tthrow new AuthorizationServiceException(\"Unsupported permission name: \" + permissionName\r\n    \t\t\t\t+ \". valid permission names are: \" + PERMISSION_TO_VIEW + \", \" + PERMISSION_TO_DEPLOY);\r\n    \t}\r\n    \t\r\n    \tif (targetDomainObject != null && !(targetDomainObject instanceof String)) {\r\n    \t\tthrow new AuthorizationServiceException(\"Failed to verify permissions, invalid authorization groups object\"\r\n    \t\t\t\t+ \" type: \" + targetDomainObject.getClass().getName());\t\t\t\r\n\t\t}\r\n    \t\r\n    \tif (targetDomainObject == null) {\r\n    \t\ttargetAuthGroups = \"\";\r\n    \t} else {\r\n    \t\ttargetAuthGroups = ((String) targetDomainObject).trim();\t\r\n    \t}\r\n    \t\r\n\t\tif (hasRequiredRoles(authentication, permissionName) \r\n\t\t\t\t&& hasAuthGroupAccess(authentication, targetAuthGroups, permissionName)) {\r\n\t\t\tpermissionGranted = true;\r\n\t\t}\r\n\t\t\r\n     \treturn permissionGranted;\r\n    }","commit_id":"7acdbf2e61f0d734d22b5cbec27e11237ac0b6a0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n     * Returns the names of the roles (authorities) the user is granted.\r\n     * @param authentication The authentication object of the current user\r\n     * @return A Collection of roles (authorities) the user is granted.\r\n     */\r\n    private Collection<String> getUserRoles(final Authentication authentication) {\r\n    \tSet<String> userRoles = new HashSet<String>();\r\n\t\t\r\n\t\tfor (GrantedAuthority authority : authentication.getAuthorities()) {\r\n\t\t\tuserRoles.add(authority.getAuthority());\r\n\t\t}\r\n\t\t\r\n\t\treturn userRoles;\r\n    }","id":78590,"modified_method":"/**\r\n     * Returns the names of the roles (authorities) the user is granted.\r\n     * @param authentication The authentication object of the current user\r\n     * @return A Collection of roles (authorities) the user is granted.\r\n     */\r\n    private Collection<String> getUserRoles(final Authentication authentication) {\r\n    \tSet<String> userRoles = new HashSet<String>();\r\n\t\t\r\n    \tif (authentication == null || authentication instanceof AnonymousAuthenticationToken) {\r\n\t\t\tthrow new AccessDeniedException(\"Anonymous user is not supported\");\r\n    \t}\r\n\t\t\r\n    \tif (!(authentication instanceof CustomAuthenticationToken)\r\n    \t\t\t&& !(authentication instanceof UsernamePasswordAuthenticationToken)) {\r\n    \t\tthrow new AccessDeniedException(\"Authentication object type not supported. \"\r\n    \t\t\t\t+ \"Verify your Spring configuration is valid.\");\r\n    \t}\r\n\t\t\r\n\t\tfor (GrantedAuthority authority : authentication.getAuthorities()) {\r\n\t\t\tuserRoles.add(authority.getAuthority());\r\n\t\t}\r\n\t\t\r\n\t\treturn userRoles;\r\n    }","commit_id":"7acdbf2e61f0d734d22b5cbec27e11237ac0b6a0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n     * Returns the names of the authorization groups the user belongs to.\r\n     * @param authentication The authentication object of the current user\r\n     * @return A Collection of authorization groups names\r\n     */\r\n    private Collection<String> getUserAuthGroups(final Authentication authentication) {\r\n\r\n    \tif (authentication == null || authentication instanceof AnonymousAuthenticationToken) {\r\n\t\t\tthrow new AccessDeniedException(\"Anonymous user is not supported\");\r\n    \t}\r\n\t\t\r\n    \tif (!(authentication instanceof CustomAuthenticationToken)) {\r\n    \t\tthrow new AccessDeniedException(\"Authentication object type not supported\");\r\n    \t}\r\n\t\t\r\n\t\treturn ((CustomAuthenticationToken) authentication).getAuthGroups();\r\n    }","id":78591,"modified_method":"/**\r\n     * Returns the names of the authorization groups the user belongs to.\r\n     * @param authentication The authentication object of the current user\r\n     * @return A Collection of authorization groups names\r\n     */\r\n    private Collection<String> getUserAuthGroups(final Authentication authentication) {\r\n\r\n    \tif (authentication == null || authentication instanceof AnonymousAuthenticationToken) {\r\n\t\t\tthrow new AccessDeniedException(\"Anonymous user is not supported\");\r\n    \t}\r\n\t\t\r\n    \tif (!(authentication instanceof CustomAuthenticationToken)\r\n    \t\t\t&& !(authentication instanceof UsernamePasswordAuthenticationToken)) {\r\n    \t\tthrow new AccessDeniedException(\"Authentication object type not supported. \"\r\n    \t\t\t\t+ \"Verify your Spring configuration is valid.\");\r\n    \t}\r\n    \t\r\n    \tCollection<String> userAuthGroups = new ArrayList<String>();\r\n    \t\r\n    \tif (authentication instanceof CustomAuthenticationToken) {\r\n    \t\tuserAuthGroups = ((CustomAuthenticationToken) authentication).getAuthGroups();\r\n    \t}\r\n\t\t\r\n\t\treturn userAuthGroups;\r\n    }","commit_id":"7acdbf2e61f0d734d22b5cbec27e11237ac0b6a0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n     * Returns the names of the roles (authorities) the user is granted.\r\n     * @return A Collection of roles (authorities) the user is granted.\r\n     */\r\n    private Collection<String> getUserRoles() {\r\n    \tSet<String> userRoles = new HashSet<String>();\r\n    \t\r\n    \tAuthentication authentication = SecurityContextHolder.getContext().getAuthentication();\r\n    \t\r\n    \tif (authentication == null || authentication instanceof AnonymousAuthenticationToken) {\r\n\t\t\tthrow new AccessDeniedException(\"Anonymous user is not supported\");\r\n    \t}\r\n\t\t\r\n    \tif (!(authentication instanceof CustomAuthenticationToken)) {\r\n    \t\tthrow new AccessDeniedException(\"Authentication object type not supported\");\r\n    \t}\r\n\t\t\r\n\t\tfor (GrantedAuthority authority : authentication.getAuthorities()) {\r\n\t\t\tuserRoles.add(authority.getAuthority());\r\n\t\t}\r\n\t\t\r\n\t\treturn userRoles;\r\n    }","id":78592,"modified_method":"/**\r\n     * Returns the names of the roles (authorities) the user is granted.\r\n     * @return A Collection of roles (authorities) the user is granted.\r\n     */\r\n    private Collection<String> getUserRoles() {\r\n    \treturn getUserRoles(SecurityContextHolder.getContext().getAuthentication());\r\n    }","commit_id":"7acdbf2e61f0d734d22b5cbec27e11237ac0b6a0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n     * Returns the names of the authorization groups the user belongs to.\r\n     *  @param authentication The authentication object of the current user\r\n     * @return A String array of authorization groups names\r\n     */\r\n    public String getUserAuthGroupsString(final Authentication authentication) {\r\n    \tCollection<String> userAuthGroups = getUserAuthGroups(authentication);\r\n    \tStringBuilder builder = new StringBuilder();\r\n    \tfor (String authGroup : userAuthGroups) {\r\n    \t    builder.append(authGroup);\r\n    \t    builder.append(',');\r\n    \t}\r\n\t\treturn builder.substring(0, builder.toString().length() - 1);\r\n    }","id":78593,"modified_method":"/**\r\n     * Returns the names of the authorization groups the user belongs to.\r\n     *  @param authentication The authentication object of the current user\r\n     * @return A String array of authorization groups names\r\n     */\r\n    public String getUserAuthGroupsString(final Authentication authentication) {\r\n    \tCollection<String> userAuthGroups = getUserAuthGroups(authentication);\r\n    \treturn collectionToDelimitedString(userAuthGroups, \",\");\r\n    }","commit_id":"7acdbf2e61f0d734d22b5cbec27e11237ac0b6a0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n\t * Checks if the logged in user is allowed to access the target object, according to its authorization groups.\r\n\t * @param authentication CustomAuthenticationToken of the logged in user\r\n\t * @param targetAuthGroupsStr Comma delimited string of the target object's authorization groups.\r\n\t * @param permissionName permission requested (view, deploy, etc.)\r\n\t * @return true - access allowed, false - access denied.\r\n\t */\r\n\tprivate boolean hasAuthGroupAccess(final CustomAuthenticationToken authentication, \r\n\t\t\tfinal String targetAuthGroupsStr, final String permissionName) {\r\n\t\t\r\n\t\tboolean permissionGranted = false;\r\n\t\t\r\n    \tCollection<String> userAuthGroups = ((CustomAuthenticationToken) authentication).getAuthGroups();\r\n    \tCollection<String> targetAuthGroups = \r\n    \t\t\torg.cloudifysource.esc.util.StringUtils.splitAndTrimString(targetAuthGroupsStr, AUTH_GROUPS_DELIMITER);\r\n\t\t\r\n\t\tif (permissionName.equalsIgnoreCase(PERMISSION_TO_VIEW)) {\r\n\t\t\tif (hasPermissionToView(targetAuthGroups)) {\r\n\t\t\t\tpermissionGranted = true;\r\n\t\t\t\tlogger.log(Level.INFO, \"View permission granted for user \" + authentication.getName());\r\n\t\t\t} else {\r\n\t\t\t\tlogger.log(Level.WARNING, \"Insufficient permissions. User \" + authentication.getName() + \" is only \"\r\n\t\t\t\t\t\t+ \"permitted to view groups: \" + Arrays.toString(userAuthGroups.toArray(new String[0])));\r\n\t\t\t}\r\n\t\t} else if (permissionName.equalsIgnoreCase(PERMISSION_TO_DEPLOY)) {\r\n\t\t\tif (hasPermissionToDeploy(authentication, targetAuthGroups)) {\r\n\t\t\t\tpermissionGranted = true;\r\n\t\t\t\tlogger.log(Level.INFO, \"Deploy permission granted for user \" + authentication.getName());\r\n\t\t\t} else {\r\n\t\t\t\tlogger.log(Level.WARNING, \"Insufficient permissions. User \" + authentication.getName() + \" is only \"\r\n\t\t\t\t\t\t+ \"permitted to deploy for groups: \" + Arrays.toString(userAuthGroups.toArray(new String[0])));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn permissionGranted;\r\n\t}","id":78594,"modified_method":"/**\r\n\t * Checks if the logged in user is allowed to access the target object, according to its authorization groups.\r\n\t * @param authentication authentication object of the logged in user\r\n\t * @param targetAuthGroupsStr Comma delimited string of the target object's authorization groups.\r\n\t * @param permissionName permission requested (view, deploy, etc.)\r\n\t * @return true - access allowed, false - access denied.\r\n\t */\r\n\tprivate boolean hasAuthGroupAccess(final Authentication authentication, \r\n\t\t\tfinal String targetAuthGroupsStr, final String permissionName) {\r\n\t\t\r\n\t\tboolean permissionGranted = false;\r\n    \t\r\n    \tif (authentication instanceof UsernamePasswordAuthenticationToken) {\r\n    \t\treturn true;  //auth groups don't exist in this configuration, so don't deny access.\r\n    \t}\r\n    \t\r\n    \tCollection<String> userAuthGroups = ((CustomAuthenticationToken) authentication).getAuthGroups();\r\n    \tCollection<String> targetAuthGroups = \r\n    \t\t\torg.cloudifysource.esc.util.StringUtils.splitAndTrimString(targetAuthGroupsStr, AUTH_GROUPS_DELIMITER);\r\n\t\t\r\n\t\tif (permissionName.equalsIgnoreCase(PERMISSION_TO_VIEW)) {\r\n\t\t\tif (hasPermissionToView(targetAuthGroups)) {\r\n\t\t\t\tpermissionGranted = true;\r\n\t\t\t\tlogger.log(Level.INFO, \"View permission granted for user \" + authentication.getName());\r\n\t\t\t} else {\r\n\t\t\t\tlogger.log(Level.WARNING, \"Insufficient permissions. User \" + authentication.getName() + \" is only \"\r\n\t\t\t\t\t\t+ \"permitted to view groups: \" + Arrays.toString(userAuthGroups.toArray(new String[0])));\r\n\t\t\t}\r\n\t\t} else if (permissionName.equalsIgnoreCase(PERMISSION_TO_DEPLOY)) {\r\n\t\t\tif (hasPermissionToDeploy(authentication, targetAuthGroups)) {\r\n\t\t\t\tpermissionGranted = true;\r\n\t\t\t\tlogger.log(Level.INFO, \"Deploy permission granted for user \" + authentication.getName());\r\n\t\t\t} else {\r\n\t\t\t\tlogger.log(Level.WARNING, \"Insufficient permissions. User \" + authentication.getName() + \" is only \"\r\n\t\t\t\t\t\t+ \"permitted to deploy for groups: \" + Arrays.toString(userAuthGroups.toArray(new String[0])));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn permissionGranted;\r\n\t}","commit_id":"7acdbf2e61f0d734d22b5cbec27e11237ac0b6a0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n     * Returns the names of the roles (authorities) the user is granted.\r\n     * @param authentication The authentication object of the current user\r\n     * @return A String array of roles (authorities) names\r\n     */\r\n    public String getUserRolesString(final Authentication authentication) {\r\n    \t\r\n    \tif (authentication == null || authentication instanceof AnonymousAuthenticationToken) {\r\n\t\t\tthrow new AccessDeniedException(\"Anonymous user is not supported\");\r\n    \t}\r\n\t\t\r\n    \tif (!(authentication instanceof CustomAuthenticationToken)) {\r\n    \t\tthrow new AccessDeniedException(\"Authentication object type not supported\");\r\n    \t}\r\n    \t\t\r\n    \tCollection<String> userRoles = getUserRoles(authentication);\r\n    \tStringBuilder builder = new StringBuilder();\r\n    \tfor (String role : userRoles) {\r\n    \t    builder.append(role);\r\n    \t    builder.append(',');\r\n    \t}\r\n\t\treturn builder.substring(0, builder.toString().length() - 1);\r\n    }","id":78595,"modified_method":"/**\r\n     * Returns the names of the roles (authorities) the user is granted.\r\n     * @param authentication The authentication object of the current user\r\n     * @return A String array of roles (authorities) names\r\n     */\r\n    public String getUserRolesString(final Authentication authentication) {\r\n    \t\r\n    \tCollection<String> userRoles = getUserRoles(authentication);\r\n    \treturn collectionToDelimitedString(userRoles, \",\");\r\n    }","commit_id":"7acdbf2e61f0d734d22b5cbec27e11237ac0b6a0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n     * Returns the names of the authorization groups the user belongs to.\r\n     * @return A Collection of authorization groups the user belongs to.\r\n     */\r\n    private Collection<String> getUserAuthGroups() {\r\n    \tAuthentication authentication = SecurityContextHolder.getContext().getAuthentication();\r\n    \tif (authentication == null || authentication instanceof AnonymousAuthenticationToken) {\r\n\t\t\tthrow new AccessDeniedException(\"Anonymous user is not supported\");\r\n    \t}\r\n\t\t\r\n    \tif (!(authentication instanceof CustomAuthenticationToken)) {\r\n    \t\tthrow new AccessDeniedException(\"Authentication object type not supported\");\r\n    \t}\r\n\t\t\r\n\t\treturn ((CustomAuthenticationToken) authentication).getAuthGroups();\r\n    }","id":78596,"modified_method":"/**\r\n     * Returns the names of the authorization groups the user belongs to.\r\n     * @return A Collection of authorization groups the user belongs to.\r\n     */\r\n    private Collection<String> getUserAuthGroups() {\r\n    \treturn getUserAuthGroups(SecurityContextHolder.getContext().getAuthentication());\r\n    }","commit_id":"7acdbf2e61f0d734d22b5cbec27e11237ac0b6a0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n     * Returns the names of the roles (authorities) the user is granted.\r\n     * @return A String array of roles (authorities) names\r\n     */\r\n    public String getUserRolesString() {\r\n    \tCollection<String> userRoles = getUserRoles();\r\n    \tStringBuilder builder = new StringBuilder();\r\n    \tfor (String role : userRoles) {\r\n    \t    builder.append(role);\r\n    \t    builder.append(',');\r\n    \t}\r\n\t\treturn builder.substring(0, builder.toString().length() - 1);\r\n    }","id":78597,"modified_method":"/**\r\n     * Returns the names of the roles (authorities) the user is granted.\r\n     * @return A String array of roles (authorities) names\r\n     */\r\n    public String getUserRolesString() {\r\n    \tCollection<String> userRoles = getUserRoles();\r\n    \treturn collectionToDelimitedString(userRoles, \",\");\r\n    }","commit_id":"7acdbf2e61f0d734d22b5cbec27e11237ac0b6a0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\r\n     * Returns the names of the authorization groups the user belongs to.\r\n     * @return A String array of authorization groups names\r\n     */\r\n    public String getUserAuthGroupsString() {\r\n    \tCollection<String> userAuthGroups = getUserAuthGroups();\r\n    \tStringBuilder builder = new StringBuilder();\r\n    \tfor (String authGroup : userAuthGroups) {\r\n    \t    builder.append(authGroup);\r\n    \t    builder.append(',');\r\n    \t}\r\n\t\treturn builder.substring(0, builder.toString().length() - 1);\r\n    }","id":78598,"modified_method":"/**\r\n     * Returns the names of the authorization groups the user belongs to.\r\n     * @return A String array of authorization groups names\r\n     */\r\n    public String getUserAuthGroupsString() {\r\n    \tCollection<String> userAuthGroups = getUserAuthGroups();\r\n    \treturn collectionToDelimitedString(userAuthGroups, \",\");\r\n    }","commit_id":"7acdbf2e61f0d734d22b5cbec27e11237ac0b6a0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n     * Gets the {@link User} object representing the currently logged-in user, or null\n     * if the current user is anonymous.\n     * @since 1.172\n     */\n    public static @CheckForNull User current() {\n        Authentication a = Jenkins.getAuthentication();\n        if(a instanceof AnonymousAuthenticationToken)\n            return null;\n\n        // Since we already know this is a name, we can just call getOrCreate with the name directly.\n        String id = a.getName();\n        return getOrCreate(id, id, true);\n    }","id":78599,"modified_method":"/**\n     * Gets the {@link User} object representing the currently logged-in user, or null\n     * if the current user is anonymous.\n     * @since 1.172\n     */\n    public static @CheckForNull User current() {\n        return get(Jenkins.getAuthentication());\n    }","commit_id":"696a7f96202d591a4dccf0cb8f62a291c61bdab7","url":"https://github.com/kohsuke/hudson"},{"original_method":"public static void showActiveHint(final Range range, final Editor editor, final Point point, final LineStatusTracker tracker) {\n\n    final DefaultActionGroup group = new DefaultActionGroup();\n\n    final AnAction globalShowNextAction = ActionManager.getInstance().getAction(\"VcsShowNextChangeMarker\");\n    final AnAction globalShowPrevAction = ActionManager.getInstance().getAction(\"VcsShowPrevChangeMarker\");\n\n    final ShowPrevChangeMarkerAction localShowPrevAction = new ShowPrevChangeMarkerAction(tracker.getPrevRange(range), tracker, editor);\n    final ShowNextChangeMarkerAction localShowNextAction = new ShowNextChangeMarkerAction(tracker.getNextRange(range), tracker, editor);\n\n    final JComponent editorComponent = editor.getComponent();\n\n    localShowNextAction.registerCustomShortcutSet(localShowNextAction.getShortcutSet(), editorComponent);\n    localShowPrevAction.registerCustomShortcutSet(localShowPrevAction.getShortcutSet(), editorComponent);\n\n    group.add(localShowPrevAction);\n    group.add(localShowNextAction);\n\n    localShowNextAction.copyFrom(globalShowNextAction);\n    localShowPrevAction.copyFrom(globalShowPrevAction);\n\n    final RollbackLineStatusRangeAction rollback = new RollbackLineStatusRangeAction(tracker, range, editor);\n    EmptyAction.setupAction(rollback, IdeActions.SELECTED_CHANGES_ROLLBACK, editorComponent);\n    group.add(rollback);\n\n    group.add(new ShowLineStatusRangeDiffAction(tracker, range, editor));\n    group.add(new CopyLineStatusRangeAction(tracker, range));\n\n    final JComponent toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.FILEHISTORY_VIEW_TOOLBAR, group, true).getComponent();\n\n    final Color background = ((EditorEx)editor).getBackgroundColor();\n    final Color foreground = editor.getColorsScheme().getColor(EditorColors.CARET_COLOR);\n    toolbar.setBackground(background);\n\n    toolbar.setBorder(new ColoredSideBorder(foreground, foreground, (range.getType() != Range.INSERTED) ? null : foreground, foreground, 1));\n\n    final JPanel component = new JPanel(new BorderLayout());\n    component.setOpaque(false);\n\n    final JPanel toolbarPanel = new JPanel(new BorderLayout());\n    toolbarPanel.setOpaque(false);\n    toolbarPanel.add(toolbar, BorderLayout.WEST);\n    JPanel emptyPanel = new JPanel();\n    emptyPanel.setOpaque(false);\n    toolbarPanel.add(emptyPanel, BorderLayout.CENTER);\n    MouseAdapter listener = new MouseAdapter() {\n      @Override\n      public void mousePressed(MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n\n      public void mouseReleased(final MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n    };\n    emptyPanel.addMouseListener(listener);\n\n    component.add(toolbarPanel, BorderLayout.NORTH);\n\n    if (range.getType() != Range.INSERTED) {\n      final DocumentEx doc = (DocumentEx) tracker.getUpToDateDocument();\n      final EditorEx uEditor = (EditorEx)EditorFactory.getInstance().createViewer(doc, tracker.getProject());\n      final EditorHighlighter highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(tracker.getProject(), getFileName(tracker.getDocument()));\n      uEditor.setHighlighter(highlighter);\n\n      final EditorFragmentComponent editorFragmentComponent =\n        EditorFragmentComponent.createEditorFragmentComponent(uEditor, range.getUOffset1(), range.getUOffset2(), false, false);\n\n      component.add(editorFragmentComponent, BorderLayout.CENTER);\n\n      EditorFactory.getInstance().releaseEditor(uEditor);\n    }\n\n    final List<AnAction> actionList = ActionUtil.getActions(editorComponent);\n    final LightweightHint lightweightHint = new LightweightHint(component);\n    HintListener closeListener = new HintListener() {\n      public void hintHidden(final EventObject event) {\n        actionList.remove(rollback);\n        actionList.remove(localShowPrevAction);\n        actionList.remove(localShowNextAction);\n      }\n    };\n    lightweightHint.addHintListener(closeListener);\n\n    HintManagerImpl.getInstanceImpl().showEditorHint(lightweightHint, editor, point, HintManagerImpl.HIDE_BY_ANY_KEY | HintManagerImpl.HIDE_BY_TEXT_CHANGE |\n                                                                             HintManagerImpl.HIDE_BY_SCROLLING,\n                                                                             -1, false, new HintHint(editor, point));\n\n    if (!lightweightHint.isVisible()) {\n      closeListener.hintHidden(null);\n    }\n    \n  }","id":78600,"modified_method":"public static void showActiveHint(final Range range, final Editor editor, final Point point, final LineStatusTracker tracker) {\n\n    final DefaultActionGroup group = new DefaultActionGroup();\n\n    final AnAction globalShowNextAction = ActionManager.getInstance().getAction(\"VcsShowNextChangeMarker\");\n    final AnAction globalShowPrevAction = ActionManager.getInstance().getAction(\"VcsShowPrevChangeMarker\");\n\n    final ShowPrevChangeMarkerAction localShowPrevAction = new ShowPrevChangeMarkerAction(tracker.getPrevRange(range), tracker, editor);\n    final ShowNextChangeMarkerAction localShowNextAction = new ShowNextChangeMarkerAction(tracker.getNextRange(range), tracker, editor);\n\n    final JComponent editorComponent = editor.getComponent();\n\n    localShowNextAction.registerCustomShortcutSet(localShowNextAction.getShortcutSet(), editorComponent);\n    localShowPrevAction.registerCustomShortcutSet(localShowPrevAction.getShortcutSet(), editorComponent);\n\n    group.add(localShowPrevAction);\n    group.add(localShowNextAction);\n\n    localShowNextAction.copyFrom(globalShowNextAction);\n    localShowPrevAction.copyFrom(globalShowPrevAction);\n\n    final RollbackLineStatusRangeAction rollback = new RollbackLineStatusRangeAction(tracker, range, editor);\n    final ShowLineStatusRangeDiffAction showDiff = new ShowLineStatusRangeDiffAction(tracker, range, editor);\n    final CopyLineStatusRangeAction copyRange = new CopyLineStatusRangeAction(tracker, range);\n\n    group.add(rollback);\n    group.add(showDiff);\n    group.add(copyRange);\n\n    EmptyAction.setupAction(rollback, IdeActions.SELECTED_CHANGES_ROLLBACK, editorComponent);\n    EmptyAction.setupAction(showDiff, \"ChangesView.Diff\", editorComponent);\n    EmptyAction.setupAction(copyRange, IdeActions.ACTION_COPY, editorComponent);\n\n    final JComponent toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.FILEHISTORY_VIEW_TOOLBAR, group, true).getComponent();\n\n    final Color background = ((EditorEx)editor).getBackgroundColor();\n    final Color foreground = editor.getColorsScheme().getColor(EditorColors.CARET_COLOR);\n    toolbar.setBackground(background);\n\n    toolbar.setBorder(new ColoredSideBorder(foreground, foreground, (range.getType() != Range.INSERTED) ? null : foreground, foreground, 1));\n\n    final JPanel component = new JPanel(new BorderLayout());\n    component.setOpaque(false);\n\n    final JPanel toolbarPanel = new JPanel(new BorderLayout());\n    toolbarPanel.setOpaque(false);\n    toolbarPanel.add(toolbar, BorderLayout.WEST);\n    JPanel emptyPanel = new JPanel();\n    emptyPanel.setOpaque(false);\n    toolbarPanel.add(emptyPanel, BorderLayout.CENTER);\n    MouseAdapter listener = new MouseAdapter() {\n      @Override\n      public void mousePressed(MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n\n      public void mouseReleased(final MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n    };\n    emptyPanel.addMouseListener(listener);\n\n    component.add(toolbarPanel, BorderLayout.NORTH);\n\n    if (range.getType() != Range.INSERTED) {\n      final DocumentEx doc = (DocumentEx) tracker.getUpToDateDocument();\n      final EditorEx uEditor = (EditorEx)EditorFactory.getInstance().createViewer(doc, tracker.getProject());\n      final EditorHighlighter highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(tracker.getProject(), getFileName(tracker.getDocument()));\n      uEditor.setHighlighter(highlighter);\n\n      final EditorFragmentComponent editorFragmentComponent =\n        EditorFragmentComponent.createEditorFragmentComponent(uEditor, range.getUOffset1(), range.getUOffset2(), false, false);\n\n      component.add(editorFragmentComponent, BorderLayout.CENTER);\n\n      EditorFactory.getInstance().releaseEditor(uEditor);\n    }\n\n    final List<AnAction> actionList = ActionUtil.getActions(editorComponent);\n    final LightweightHint lightweightHint = new LightweightHint(component);\n    HintListener closeListener = new HintListener() {\n      public void hintHidden(final EventObject event) {\n        actionList.remove(rollback);\n        actionList.remove(showDiff);\n        actionList.remove(copyRange);\n        actionList.remove(localShowPrevAction);\n        actionList.remove(localShowNextAction);\n      }\n    };\n    lightweightHint.addHintListener(closeListener);\n\n    HintManagerImpl.getInstanceImpl().showEditorHint(lightweightHint, editor, point, HintManagerImpl.HIDE_BY_ANY_KEY | HintManagerImpl.HIDE_BY_TEXT_CHANGE |\n                                                                             HintManagerImpl.HIDE_BY_SCROLLING,\n                                                                             -1, false, new HintHint(editor, point));\n\n    if (!lightweightHint.isVisible()) {\n      closeListener.hintHidden(null);\n    }\n    \n  }","commit_id":"446098a35c6cac3a547d18748ad43416436d53aa","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void showActiveHint(final Range range, final Editor editor, final Point point, final LineStatusTracker tracker) {\n\n    final DefaultActionGroup group = new DefaultActionGroup();\n\n    final AnAction globalShowNextAction = ActionManager.getInstance().getAction(\"VcsShowNextChangeMarker\");\n    final AnAction globalShowPrevAction = ActionManager.getInstance().getAction(\"VcsShowPrevChangeMarker\");\n\n    final ShowPrevChangeMarkerAction localShowPrevAction = new ShowPrevChangeMarkerAction(tracker.getPrevRange(range), tracker, editor);\n    final ShowNextChangeMarkerAction localShowNextAction = new ShowNextChangeMarkerAction(tracker.getNextRange(range), tracker, editor);\n\n    final JComponent editorComponent = editor.getComponent();\n\n    localShowNextAction.registerCustomShortcutSet(localShowNextAction.getShortcutSet(), editorComponent);\n    localShowPrevAction.registerCustomShortcutSet(localShowPrevAction.getShortcutSet(), editorComponent);\n\n    group.add(localShowPrevAction);\n    group.add(localShowNextAction);\n\n    localShowNextAction.copyFrom(globalShowNextAction);\n    localShowPrevAction.copyFrom(globalShowPrevAction);\n\n    final RollbackLineStatusRangeAction rollback = new RollbackLineStatusRangeAction(tracker, range, editor);\n    final ShowLineStatusRangeDiffAction showDiff = new ShowLineStatusRangeDiffAction(tracker, range, editor);\n    final CopyLineStatusRangeAction copyRange = new CopyLineStatusRangeAction(tracker, range);\n\n    group.add(rollback);\n    group.add(showDiff);\n    group.add(copyRange);\n\n    EmptyAction.setupAction(rollback, IdeActions.SELECTED_CHANGES_ROLLBACK, editorComponent);\n    EmptyAction.setupAction(showDiff, \"ChangesView.Diff\", editorComponent);\n    EmptyAction.setupAction(copyRange, IdeActions.ACTION_COPY, editorComponent);\n\n    final JComponent toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.FILEHISTORY_VIEW_TOOLBAR, group, true).getComponent();\n\n    final Color background = ((EditorEx)editor).getBackgroundColor();\n    final Color foreground = editor.getColorsScheme().getColor(EditorColors.CARET_COLOR);\n    toolbar.setBackground(background);\n\n    toolbar.setBorder(new ColoredSideBorder(foreground, foreground, (range.getType() != Range.INSERTED) ? null : foreground, foreground, 1));\n\n    final JPanel component = new JPanel(new BorderLayout());\n    component.setOpaque(false);\n\n    final JPanel toolbarPanel = new JPanel(new BorderLayout());\n    toolbarPanel.setOpaque(false);\n    toolbarPanel.add(toolbar, BorderLayout.WEST);\n    JPanel emptyPanel = new JPanel();\n    emptyPanel.setOpaque(false);\n    toolbarPanel.add(emptyPanel, BorderLayout.CENTER);\n    MouseAdapter listener = new MouseAdapter() {\n      @Override\n      public void mousePressed(MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n\n      public void mouseReleased(final MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n    };\n    emptyPanel.addMouseListener(listener);\n\n    component.add(toolbarPanel, BorderLayout.NORTH);\n\n    if (range.getType() != Range.INSERTED) {\n      final DocumentEx doc = (DocumentEx) tracker.getVcsDocument();\n      final EditorEx uEditor = (EditorEx)EditorFactory.getInstance().createViewer(doc, tracker.getProject());\n      final EditorHighlighter highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(tracker.getProject(), getFileName(tracker.getDocument()));\n      uEditor.setHighlighter(highlighter);\n\n      final EditorFragmentComponent editorFragmentComponent =\n        EditorFragmentComponent.createEditorFragmentComponent(uEditor, range.getVcsLine1(), range.getVcsLine2(), false, false);\n\n      component.add(editorFragmentComponent, BorderLayout.CENTER);\n\n      EditorFactory.getInstance().releaseEditor(uEditor);\n    }\n\n    final List<AnAction> actionList = ActionUtil.getActions(editorComponent);\n    final LightweightHint lightweightHint = new LightweightHint(component);\n    HintListener closeListener = new HintListener() {\n      public void hintHidden(final EventObject event) {\n        actionList.remove(rollback);\n        actionList.remove(showDiff);\n        actionList.remove(copyRange);\n        actionList.remove(localShowPrevAction);\n        actionList.remove(localShowNextAction);\n      }\n    };\n    lightweightHint.addHintListener(closeListener);\n\n    HintManagerImpl.getInstanceImpl().showEditorHint(lightweightHint, editor, point, HintManagerImpl.HIDE_BY_ANY_KEY | HintManagerImpl.HIDE_BY_TEXT_CHANGE |\n                                                                             HintManagerImpl.HIDE_BY_SCROLLING,\n                                                                             -1, false, new HintHint(editor, point));\n\n    if (!lightweightHint.isVisible()) {\n      closeListener.hintHidden(null);\n    }\n    \n  }","id":78601,"modified_method":"public static void showActiveHint(final Range range, final Editor editor, final Point point, final LineStatusTracker tracker) {\n    final DefaultActionGroup group = new DefaultActionGroup();\n\n    final ShowPrevChangeMarkerAction localShowPrevAction = new ShowPrevChangeMarkerAction(tracker.getPrevRange(range), tracker, editor);\n    final ShowNextChangeMarkerAction localShowNextAction = new ShowNextChangeMarkerAction(tracker.getNextRange(range), tracker, editor);\n    final RollbackLineStatusRangeAction rollback = new RollbackLineStatusRangeAction(tracker, range, editor);\n    final ShowLineStatusRangeDiffAction showDiff = new ShowLineStatusRangeDiffAction(tracker, range, editor);\n    final CopyLineStatusRangeAction copyRange = new CopyLineStatusRangeAction(tracker, range);\n\n    group.add(localShowPrevAction);\n    group.add(localShowNextAction);\n    group.add(rollback);\n    group.add(showDiff);\n    group.add(copyRange);\n\n\n    final JComponent toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.FILEHISTORY_VIEW_TOOLBAR, group, true).getComponent();\n\n    final Color background = ((EditorEx)editor).getBackgroundColor();\n    final Color foreground = editor.getColorsScheme().getColor(EditorColors.CARET_COLOR);\n    toolbar.setBackground(background);\n\n    toolbar.setBorder(new ColoredSideBorder(foreground, foreground, (range.getType() != Range.INSERTED) ? null : foreground, foreground, 1));\n\n    final JPanel component = new JPanel(new BorderLayout());\n    component.setOpaque(false);\n\n    final JPanel toolbarPanel = new JPanel(new BorderLayout());\n    toolbarPanel.setOpaque(false);\n    toolbarPanel.add(toolbar, BorderLayout.WEST);\n    JPanel emptyPanel = new JPanel();\n    emptyPanel.setOpaque(false);\n    toolbarPanel.add(emptyPanel, BorderLayout.CENTER);\n    MouseAdapter listener = new MouseAdapter() {\n      @Override\n      public void mousePressed(MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n\n      @Override\n      public void mouseClicked(MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n\n      public void mouseReleased(final MouseEvent e) {\n        editor.getContentComponent().dispatchEvent(SwingUtilities.convertMouseEvent(e.getComponent(), e, editor.getContentComponent()));\n      }\n    };\n    emptyPanel.addMouseListener(listener);\n\n    component.add(toolbarPanel, BorderLayout.NORTH);\n\n\n    if (range.getType() != Range.INSERTED) {\n      final DocumentEx doc = (DocumentEx) tracker.getVcsDocument();\n      final EditorEx uEditor = (EditorEx)EditorFactory.getInstance().createViewer(doc, tracker.getProject());\n      final EditorHighlighter highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(tracker.getProject(), getFileName(tracker.getDocument()));\n      uEditor.setHighlighter(highlighter);\n\n      final EditorFragmentComponent editorFragmentComponent =\n        EditorFragmentComponent.createEditorFragmentComponent(uEditor, range.getVcsLine1(), range.getVcsLine2(), false, false);\n\n      component.add(editorFragmentComponent, BorderLayout.CENTER);\n\n      EditorFactory.getInstance().releaseEditor(uEditor);\n    }\n\n\n    final JComponent editorComponent = editor.getComponent();\n    EmptyAction.setupAction(localShowPrevAction, \"VcsShowPrevChangeMarker\", editorComponent);\n    EmptyAction.setupAction(localShowNextAction, \"VcsShowNextChangeMarker\", editorComponent);\n    EmptyAction.setupAction(rollback, IdeActions.SELECTED_CHANGES_ROLLBACK, editorComponent);\n    EmptyAction.setupAction(showDiff, \"ChangesView.Diff\", editorComponent);\n    EmptyAction.setupAction(copyRange, IdeActions.ACTION_COPY, editorComponent);\n\n\n    final List<AnAction> actionList = ActionUtil.getActions(editorComponent);\n    final LightweightHint lightweightHint = new LightweightHint(component);\n    HintListener closeListener = new HintListener() {\n      public void hintHidden(final EventObject event) {\n        actionList.remove(rollback);\n        actionList.remove(showDiff);\n        actionList.remove(copyRange);\n        actionList.remove(localShowPrevAction);\n        actionList.remove(localShowNextAction);\n      }\n    };\n    lightweightHint.addHintListener(closeListener);\n\n    HintManagerImpl.getInstanceImpl()\n      .showEditorHint(lightweightHint, editor, point,\n                      HintManagerImpl.HIDE_BY_ANY_KEY | HintManagerImpl.HIDE_BY_TEXT_CHANGE | HintManagerImpl.HIDE_BY_SCROLLING,\n                      -1, false, new HintHint(editor, point));\n\n    if (!lightweightHint.isVisible()) {\n      closeListener.hintHidden(null);\n    }\n    \n  }","commit_id":"262d68aeda8697590fa0abe4ee110d1c49db07d0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private AnAction[] fillToolBarActions(final DefaultActionGroup toolbarActions,\n                                        final Executor defaultExecutor,\n                                        final RunContentDescriptor myDescriptor) {\n//stop\n    final AnAction stopAction = createStopAction();\n    toolbarActions.add(stopAction);\n\n//close\n    final AnAction closeAction = createCloseAction(defaultExecutor, myDescriptor);\n    toolbarActions.add(closeAction);\n\n// run action\n    myRunAction = new DumbAwareAction(null, null, IconLoader.getIcon(\"/actions/execute.png\")) {\n      public void actionPerformed(final AnActionEvent e) {\n        runExecuteActionInner(true);\n      }\n\n      public void update(final AnActionEvent e) {\n        final EditorEx editor = getLanguageConsole().getConsoleEditor();\n        final Lookup lookup = LookupManager.getActiveLookup(editor);\n        e.getPresentation().setEnabled(!myProcessHandler.isProcessTerminated() &&\n                                       (lookup == null || !lookup.isCompletion()));\n      }\n    };\n    EmptyAction.setupAction(myRunAction, \"Console.Python.Execute\", null);\n    toolbarActions.add(myRunAction);\n\n// Help\n    toolbarActions.add(CommonActionsManager.getInstance().createHelpAction(\"interactive_console\"));\n\n// history actions\n    final PairProcessor<AnActionEvent, String> historyProcessor = new PairProcessor<AnActionEvent, String>() {\n      public boolean process(final AnActionEvent e, final String s) {\n        new WriteCommandAction(myProject, getLanguageConsole().getFile()) {\n          protected void run(final Result result) throws Throwable {\n            getLanguageConsole().getEditorDocument().setText(s == null? \"\" : s);\n          }\n        }.execute();\n        return true;\n      }\n    };\n    final AnAction historyNextAction = ConsoleHistoryModel.createHistoryAction(myHistory, true, historyProcessor);\n    final AnAction historyPrevAction = ConsoleHistoryModel.createHistoryAction(myHistory, false, historyProcessor);\n    historyNextAction.getTemplatePresentation().setVisible(false);\n    historyPrevAction.getTemplatePresentation().setVisible(false);\n    toolbarActions.add(historyNextAction);\n    toolbarActions.add(historyPrevAction);\n\n    return new AnAction[]{stopAction, closeAction, myRunAction, historyNextAction, historyPrevAction};\n  }","id":78602,"modified_method":"private AnAction[] fillToolBarActions(final DefaultActionGroup toolbarActions,\n                                        final Executor defaultExecutor,\n                                        final RunContentDescriptor myDescriptor) {\n//stop\n    final AnAction stopAction = createStopAction();\n    toolbarActions.add(stopAction);\n\n//close\n    final AnAction closeAction = createCloseAction(defaultExecutor, myDescriptor);\n    toolbarActions.add(closeAction);\n\n// run action\n    myRunAction = new DumbAwareAction(null, null, IconLoader.getIcon(\"/actions/execute.png\")) {\n      public void actionPerformed(final AnActionEvent e) {\n        runExecuteActionInner(true);\n      }\n\n      public void update(final AnActionEvent e) {\n        final EditorEx editor = getLanguageConsole().getConsoleEditor();\n        final Lookup lookup = LookupManager.getActiveLookup(editor);\n        e.getPresentation().setEnabled(!myProcessHandler.isProcessTerminated() &&\n                                       (lookup == null || !lookup.isCompletion()));\n      }\n    };\n    try {\n      // TODO[oleg] fix when Maia compatibility doesn't care\n      EmptyAction.setupAction(myRunAction, \"Console.Execute\", null);\n    }\n    catch (NullPointerException e) {\n        EmptyAction.setupAction(myRunAction, \"Python.Console.Execute\", null);    \n    }\n    toolbarActions.add(myRunAction);\n\n// Help\n    toolbarActions.add(CommonActionsManager.getInstance().createHelpAction(\"interactive_console\"));\n\n// history actions\n    final PairProcessor<AnActionEvent, String> historyProcessor = new PairProcessor<AnActionEvent, String>() {\n      public boolean process(final AnActionEvent e, final String s) {\n        new WriteCommandAction(myProject, getLanguageConsole().getFile()) {\n          protected void run(final Result result) throws Throwable {\n            getLanguageConsole().getEditorDocument().setText(s == null? \"\" : s);\n          }\n        }.execute();\n        return true;\n      }\n    };\n    final AnAction historyNextAction = ConsoleHistoryModel.createHistoryAction(myHistory, true, historyProcessor);\n    final AnAction historyPrevAction = ConsoleHistoryModel.createHistoryAction(myHistory, false, historyProcessor);\n    historyNextAction.getTemplatePresentation().setVisible(false);\n    historyPrevAction.getTemplatePresentation().setVisible(false);\n    toolbarActions.add(historyNextAction);\n    toolbarActions.add(historyPrevAction);\n\n    return new AnAction[]{stopAction, closeAction, myRunAction, historyNextAction, historyPrevAction};\n  }","commit_id":"bd1c70ae09f5aa8394ce4a9ff9e936c1af6b435e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void loadPackage(String packageName) {\n        // abort if we already loaded it\n        if(!loadedPackages.add(packageName))\n            return;\n        PackageSymbol ceylonPkg = reader.enterPackage(names.fromString(packageName));\n        ceylonPkg.complete();\n        /*\n         * Eventually this will go away as we get a hook from the typechecker to load on demand, but\n         * for now the typechecker requires at least ceylon.language to be loaded \n         */\n        for(Symbol m : ceylonPkg.members().getElements()){\n            convertToDeclaration(lookupClassSymbol(m.getQualifiedName().toString()), DeclarationType.VALUE);\n        }\n    }","id":78603,"modified_method":"void loadPackage(String packageName) {\n        // abort if we already loaded it\n        if(!loadedPackages.add(packageName))\n            return;\n        PackageSymbol ceylonPkg = reader.enterPackage(names.fromString(packageName));\n        ceylonPkg.complete();\n        /*\n         * Eventually this will go away as we get a hook from the typechecker to load on demand, but\n         * for now the typechecker requires at least ceylon.language to be loaded \n         */\n        for(Symbol m : ceylonPkg.members().getElements()){\n            if(!(m instanceof ClassSymbol))\n                return;\n            ClassSymbol enclosingClass = getEnclosing((ClassSymbol) m);\n            if(enclosingClass.classfile.getKind() != Kind.SOURCE)\n                convertToDeclaration(lookupClassSymbol(m.getQualifiedName().toString()), DeclarationType.VALUE);\n        }\n    }","commit_id":"9272c0f642596ac72ff3e8960544c6283ef60ba6","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public boolean loadPackage(Module module, String packageName, boolean loadDeclarations) {\n        synchronized(getLock()){\n            // abort if we already loaded it, but only record that we loaded it if we want\n            // to load the declarations, because merely calling complete() on the package\n            // is OK\n            packageName = Util.quoteJavaKeywords(packageName);\n            String cacheKey = cacheKeyByModule(module, packageName);\n            if(loadDeclarations){\n                if(!loadedPackages.add(cacheKey)){\n                    return true;\n                }\n            }else{\n                Boolean exists = packageExistence.get(cacheKey);\n                if(exists != null)\n                    return exists.booleanValue();\n            }\n            PackageSymbol ceylonPkg = packageName.equals(\"\") ? syms().unnamedPackage : reader.enterPackage(names.fromString(packageName));\n            if(loadDeclarations){\n                logVerbose(\"load package \"+packageName+\" full\");\n                ceylonPkg.complete();\n                /*\n                 * Eventually this will go away as we get a hook from the typechecker to load on demand, but\n                 * for now the typechecker requires at least ceylon.language to be loaded \n                 */\n                for(Symbol m : ceylonPkg.members().getElements()){\n                    // skip things that are not classes (perhaps package-info?)\n                    if(!(m instanceof ClassSymbol))\n                        continue;\n                    ClassSymbol enclosingClass = getEnclosing((ClassSymbol) m);\n\n                    if(enclosingClass == m\n                            && !Util.isLoadedFromSource(enclosingClass)){\n                        m.complete();\n                        // avoid anonymous and local classes\n                        if(isAnonymousOrLocal((ClassSymbol) m))\n                            continue;\n                        // avoid member classes\n                        if(((ClassSymbol)m).getNestingKind() != NestingKind.TOP_LEVEL)\n                            continue;\n                        // skip module and package descriptors\n                        if(isModuleOrPackageDescriptorName(m.name.toString()))\n                            continue;\n                        convertToDeclaration(module, lookupClassMirror(module, m.getQualifiedName().toString()), DeclarationType.VALUE);\n                    }\n                }\n                if(module.getNameAsString().equals(JAVA_BASE_MODULE_NAME)\n                        && packageName.equals(\"java.lang\"))\n                    loadJavaBaseArrays();\n                // a bit complicated, but couldn't find better. PackageSymbol.exists() seems to be set only by Enter which\n                // might be too late\n                return ceylonPkg.members().getElements().iterator().hasNext();\n            }else{\n                logVerbose(\"load package \"+packageName+\" light\");\n                try {\n                    // it is cheaper to verify that we have a class file somewhere than to complete the whole package\n                    // just to check for its existence\n                    Iterable<JavaFileObject> list = fileManager.list(PLATFORM_CLASS_PATH,\n                            packageName,\n                            EnumSet.of(JavaFileObject.Kind.CLASS),\n                            false);\n                    if(list.iterator().hasNext()){\n                        packageExistence.put(cacheKey, Boolean.TRUE);\n                        return true;\n                    }\n                    list = fileManager.list(CLASS_PATH,\n                            packageName,\n                            EnumSet.of(JavaFileObject.Kind.CLASS),\n                            false);\n                    if(list.iterator().hasNext()){\n                        packageExistence.put(cacheKey, Boolean.TRUE);\n                        return true;\n                    }else{\n                        packageExistence.put(cacheKey, Boolean.FALSE);\n                        return false;\n                    }\n                } catch (IOException e) {\n                    return false;\n                }\n            }\n        }\n    }","id":78604,"modified_method":"@Override\n    public boolean loadPackage(Module module, String packageName, boolean loadDeclarations) {\n        synchronized(getLock()){\n            // abort if we already loaded it, but only record that we loaded it if we want\n            // to load the declarations, because merely calling complete() on the package\n            // is OK\n            packageName = Util.quoteJavaKeywords(packageName);\n            String cacheKey = cacheKeyByModule(module, packageName);\n            if(loadDeclarations){\n                if(!loadedPackages.add(cacheKey)){\n                    return true;\n                }\n            }else{\n                Boolean exists = packageExistence.get(cacheKey);\n                if(exists != null)\n                    return exists.booleanValue();\n            }\n            PackageSymbol ceylonPkg = packageName.equals(\"\") ? syms().unnamedPackage : reader.enterPackage(names.fromString(packageName));\n            if(loadDeclarations){\n                logVerbose(\"load package \"+packageName+\" full\");\n                ceylonPkg.complete();\n                /*\n                 * Eventually this will go away as we get a hook from the typechecker to load on demand, but\n                 * for now the typechecker requires at least ceylon.language to be loaded \n                 */\n                for(Symbol m : ceylonPkg.members().getElements()){\n                    // skip things that are not classes (perhaps package-info?)\n                    if(!(m instanceof ClassSymbol))\n                        continue;\n                    ClassSymbol enclosingClass = getEnclosing((ClassSymbol) m);\n\n                    if(enclosingClass == m\n                            && !Util.isLoadedFromSource(enclosingClass)){\n                        m.complete();\n                        // avoid anonymous and local classes\n                        if(isAnonymousOrLocal((ClassSymbol) m))\n                            continue;\n                        // avoid member classes\n                        if(((ClassSymbol)m).getNestingKind() != NestingKind.TOP_LEVEL)\n                            continue;\n                        // skip module and package descriptors\n                        if(isModuleOrPackageDescriptorName(m.name.toString()))\n                            continue;\n                        ClassMirror classMirror = lookupClassMirror(module, m.getQualifiedName().toString());\n                        // Some languages like Scala generate classes like com.foo.package which we would\n                        // quote to com.foo.$package, which does not exist, so we'd get a null leading to an NPE\n                        // So ATM we just avoid it, presumably we don't support what it does anyways\n                        if(classMirror != null)\n                            convertToDeclaration(module, classMirror, DeclarationType.VALUE);\n                    }\n                }\n                if(module.getNameAsString().equals(JAVA_BASE_MODULE_NAME)\n                        && packageName.equals(\"java.lang\"))\n                    loadJavaBaseArrays();\n                // a bit complicated, but couldn't find better. PackageSymbol.exists() seems to be set only by Enter which\n                // might be too late\n                return ceylonPkg.members().getElements().iterator().hasNext();\n            }else{\n                logVerbose(\"load package \"+packageName+\" light\");\n                try {\n                    // it is cheaper to verify that we have a class file somewhere than to complete the whole package\n                    // just to check for its existence\n                    Iterable<JavaFileObject> list = fileManager.list(PLATFORM_CLASS_PATH,\n                            packageName,\n                            EnumSet.of(JavaFileObject.Kind.CLASS),\n                            false);\n                    if(list.iterator().hasNext()){\n                        packageExistence.put(cacheKey, Boolean.TRUE);\n                        return true;\n                    }\n                    list = fileManager.list(CLASS_PATH,\n                            packageName,\n                            EnumSet.of(JavaFileObject.Kind.CLASS),\n                            false);\n                    if(list.iterator().hasNext()){\n                        packageExistence.put(cacheKey, Boolean.TRUE);\n                        return true;\n                    }else{\n                        packageExistence.put(cacheKey, Boolean.FALSE);\n                        return false;\n                    }\n                } catch (IOException e) {\n                    return false;\n                }\n            }\n        }\n    }","commit_id":"6f4735ab9b229fce976a9b0cefd6ea3391b7f5c2","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"@Override\n    public Declaration getDirectMember(String name, List<ProducedType> signature) {\n        String pkgName = getQualifiedNameString();\n\n        // we need its package ready first\n        modelLoader.loadPackage(pkgName, false);\n\n        String className = getQualifiedName(pkgName, name);\n        ClassMirror classSymbol = modelLoader.lookupClassMirror(className);\n        // only get it from the classpath if we're not compiling it\n        if(classSymbol != null && !classSymbol.isLoadedFromSource()) {\n            Declaration d = modelLoader.convertToDeclaration(className, DeclarationType.VALUE);\n            if (d instanceof Class) {\n                if ( ((Class) d).isAbstraction()) {\n                    return lookupMember(compiledDeclarations, name, signature, false);\n                }\n            }\n            return d;\n        }\n        return getDirectMemberFromSource(name);\n    }","id":78605,"modified_method":"@Override\n    public Declaration getDirectMember(String name, List<ProducedType> signature) {\n        String pkgName = getQualifiedNameString();\n\n        // we need its package ready first\n        modelLoader.loadPackage(pkgName, false);\n\n        String className = getQualifiedName(pkgName, name);\n        \n        Declaration d = lookupMember(compiledDeclarations, name, signature, false);\n        if (d != null) {\n            return d;\n        }\n        \n        ClassMirror classSymbol = modelLoader.lookupClassMirror(className);\n        // only get it from the classpath if we're not compiling it\n        if(classSymbol != null && !classSymbol.isLoadedFromSource()) {\n            d = modelLoader.convertToDeclaration(className, DeclarationType.VALUE);\n            if (d instanceof Class) {\n                if ( ((Class) d).isAbstraction()) {\n                    return lookupMember(compiledDeclarations, name, signature, false);\n                }\n            }\n            return d;\n        }\n        return getDirectMemberFromSource(name);\n    }","commit_id":"7c45899479fb7880ebb2b036bc6b51ebadbb17a4","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private synchronized Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n\t{\n        Object[] outputRow = new Object[data.outputRowMeta.size()];\n        \n        Object[] lookupRow = new Object[data.lookupRowMeta.size()];\n\t\tObject[] returnRow = null;\n        \n\t\tLong technicalKey;\n\t\tLong valueVersion;\n\t\tDate valueDate    = null;\n\t\tDate valueDateFrom = null;\n\t\tDate valueDateTo   = null;\n\n        // Determine the lookup date (\"now\") if we have a field that carries said date.\r\n\t\t// If not, the system date is taken.\r\n\t\t//\n\t\tif (data.datefieldnr>=0)\n\t\t{\n\t\t\tdata.valueDateNow = rowMeta.getDate(row, data.datefieldnr);\n\t\t}\n\t\t\n        // Construct the \n\t\tfor (int i=0;i<meta.getKeyStream().length;i++)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlookupRow[i] = row[data.keynrs[i]];\n\t\t\t}\n\t\t\tcatch(Exception e) // TODO : remove exception??\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"DimensionLookup.Exception.ErrorDetectedInGettingKey\",i+\"\",data.keynrs[i]+\"/\"+rowMeta.size(),rowMeta.getString(row))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t}\n\t\t}\n\t\tif (data.datefieldnr>=0) valueDate = rowMeta.getDate(row, data.datefieldnr);\n\t\telse valueDate = data.valueDateNow;\n        lookupRow[meta.getKeyStream().length]=valueDate;  // ? >= date_from\n        lookupRow[meta.getKeyStream().length+1]=valueDate; // ? < date_to\n\t\t\n\t\tif (log.isDebug()) logDebug(Messages.getString(\"DimensionLookup.Log.LookupRow\")+data.lookupRowMeta.getString(lookupRow)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\n        // Do the lookup and see if we can find anything in the database.\n        // But before that, let's see if we can find anything in the cache\n        //\n        \n\t\tif (meta.getCacheSize()>=0)\n        {\n            returnRow=getFromCache(lookupRow, valueDate);\n        }\n        \n        if (returnRow==null)\n        {\n            data.db.setValues(data.lookupRowMeta, lookupRow, data.prepStatementLookup);\n            returnRow=data.db.getLookup(data.prepStatementLookup);\n            data.returnRowMeta = data.db.getReturnRowMeta();\n            \n            linesInput++;\n            \n            if (returnRow!=null && meta.getCacheSize()>=0)\n            {\n                addToCache(lookupRow, returnRow);\n            }\n        }\n\t\t\n\t\t/* Handle \"update = false\" first for performance reasons\n\t\t */\n\t\tif (!meta.isUpdate())\n\t\t{\n\t\t\tif (returnRow==null)\n\t\t\t{\n                returnRow=new Object[data.returnRowMeta.size()];\n                returnRow[0] = data.notFoundTk; \n\n                if (meta.getCacheSize()>=0) // need -oo to +oo as well...\n                {\n                    returnRow[returnRow.length-2] = data.min_date;\n                    returnRow[returnRow.length-1] = data.max_date;\n                }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We found the return values in row \"add\".\n\t\t\t\t// Throw away the version nr...\n\t\t\t\t// add.removeValue(1);\n\t\t\t\t\n\t\t\t\t// Rename the key field if needed.  Do it directly in the row...\n\t\t\t\t// if (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) add.getValue(0).setName(meta.getKeyRename());\n\t\t\t}\n\t\t}\n\t\telse  // Insert - update algorithm for slowly changing dimensions\n\t\t{\n\t\t\tif (returnRow==null) // The dimension entry was not found, we need to add it!\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.NoDimensionEntryFound\")+data.lookupRowMeta.getString(lookupRow)+\")\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t//logDetailed(\"Entry not found: add value!\");\n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = data.min_date;\n\t\t\t\tvalueDateTo   = data.max_date;\n\t\t\t\tvalueVersion  = new Long(1L);     // Versions always start at 1.\n\t\t\t\t\n\t\t\t\t// get a new value from the sequence choosen.\n\t\t\t\ttechnicalKey = null;\n\t\t\t\tswitch ( getTechKeyCreation() )\n\t\t\t\t{\n\t\t\t\t    case CREATION_METHOD_TABLEMAX:\n\t\t\t\t\t\t// What's the next value for the technical key?\n\t\t\t\t\t\ttechnicalKey=data.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), meta.getKeyField());\n                        break;\n\t\t\t\t    case CREATION_METHOD_AUTOINC:\n\t\t\t\t\t\ttechnicalKey=null; // Set to null to flag auto-increment usage\n\t\t\t\t\t\tbreak;\n\t\t\t\t    case CREATION_METHOD_SEQUENCE:\t\t\t\t\t\t\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t}\t               \n\n\t\t\t\t/*\n\t\t\t\t *   INSERT INTO table(version, datefrom, dateto, fieldlookup)\n\t\t\t\t *   VALUES(valueVersion, valueDateFrom, valueDateTo, row.fieldnrs)\n\t\t\t\t *   ;\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\ttechnicalKey = dimInsert(getInputRowMeta(), row, technicalKey, true, valueVersion, valueDateFrom, valueDateTo); \n\t\t\t\t\t\t\t\t\n\t\t\t\tlinesOutput++;\n\t\t\t\treturnRow = new Object[data.returnRowMeta.size()];\n                int returnIndex=0;\n                \n                returnRow[returnIndex] = technicalKey;\n                returnIndex++;\n                \n                // See if we need to store this record in the cache as well...\n                if (meta.getCacheSize()>=0)\n                {\n                    Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                    \n                    // put it in the cache...\n                    if (values!=null)\r\n                    {\r\n                    \taddToCache(lookupRow, values);\r\n                    }\n                }\n                \n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddedDimensionEntry\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n\t\t\t}\n\t\t\telse  // The entry was found: do we need to insert, update or both?\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.DimensionEntryFound\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n                \n\t\t\t\t// What's the key?  The first value of the return row\n\t\t\t\ttechnicalKey = data.returnRowMeta.getInteger(returnRow, 0);\n\t\t\t\tvalueVersion = data.returnRowMeta.getInteger(returnRow, 1); \n                \n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = meta.getMinDate();\n\t\t\t\tvalueDateTo   = meta.getMaxDate();\n\n\t\t\t\t// The other values, we compare with\n\t\t\t\tint cmp;\n\t\t\t\t\n\t\t\t\t// If everything is the same: don't do anything\n\t\t\t\t// If one of the fields is different: insert or update\n\t\t\t\t// If all changed fields have update = Y, update\n\t\t\t\t// If one of the changed fields has update = N, insert\n\n\t\t\t\tboolean insert=false;\n\t\t\t\tboolean identical=true;\n\t\t\t\tboolean punch=false;\n\t\t\t\t\n\t\t\t\tfor (int i=0;i<meta.getFieldStream().length;i++)\n\t\t\t\t{\n                    ValueMetaInterface v1  = data.outputRowMeta.getValueMeta(data.fieldnrs[i]);\n                    Object valueData1 = row[data.fieldnrs[i]]; \n                    ValueMetaInterface v2  = data.returnRowMeta.getValueMeta(i+2);\n                    Object valueData2 = returnRow[i+2];\n                        \n\t\t\t\t\tcmp = v1.compare(valueData1, v2, valueData2);\n\t\t\t\t\t  \n\t\t\t\t\t  // Not the same and update = 'N' --> insert\n\t\t\t\t\t  if (cmp!=0) identical=false;\n                      \n                      // Field flagged for insert: insert\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_INSERT)\n\t\t\t\t\t  { \n\t\t\t\t\t  \tinsert=true;\n\t\t\t\t\t  }\n                      \n                      // Field flagged for punchthrough\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_PUNCHTHROUGH) \n                      {\n                            punch=true;\n                      }\n\t\t\t\t\t  \n\t\t\t\t\t  logRowlevel(Messages.getString(\"DimensionLookup.Log.ComparingValues\",\"\"+v1,\"\"+v2,String.valueOf(cmp),String.valueOf(identical),String.valueOf(insert),String.valueOf(punch))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!insert)  // Just an update of row at key = valueKey\n\t\t\t\t{\n\t\t\t\t\tif (!identical)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.UpdateRowWithValues\")+row); //$NON-NLS-1$\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * UPDATE d_customer\n\t\t\t\t\t\t * SET    fieldlookup[] = row.getValue(fieldnrs)\n\t\t\t\t\t\t * WHERE  returnkey = dimkey\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdimUpdate(rowMeta, row, technicalKey);\n\t\t\t\t\t\tlinesUpdated++;\n                        \n                        // We need to capture this change in the cache as well...\n                        if (meta.getCacheSize()>=0)\n                        {\n                            Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                            addToCache(lookupRow, values);\n                        }\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.SkipLine\")); //$NON-NLS-1$\n\t\t\t\t\t\t// Don't do anything, everything is file in de dimension.\n\t\t\t\t\t\tlinesSkipped++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.InsertNewVersion\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\n\t\t\t\t\tvalueDateFrom = data.valueDateNow;\n\t\t\t\t\tvalueDateTo   = data.max_date; //$NON-NLS-1$\n\n\t\t\t\t\t// First try to use an AUTOINCREMENT field\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsAutoinc() && isAutoIncrement())\n\t\t\t\t\t{\n\t\t\t\t\t\ttechnicalKey=new Long(0L); // value to accept new key...\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Try to get the value by looking at a SEQUENCE (oracle mostly)\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsSequences() && meta.getSequenceName()!=null && meta.getSequenceName().length()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence2\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Use our own sequence here...\n\t\t\t\t\t{\n\t\t\t\t\t\t// What's the next value for the technical key?\n                        technicalKey = data.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), meta.getKeyField());\n\t\t\t\t\t}\n\n\t\t\t\t\tdimInsert( rowMeta, row, technicalKey, false, valueVersion, valueDateFrom, valueDateTo ); \n\t\t\t\t\tlinesOutput++;\n                    \n                    // We need to capture this change in the cache as well...\n                    if (meta.getCacheSize()>=0)\n                    {\n                        Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                        addToCache(lookupRow, values);\n                    }\n\t\t\t\t}\n\t\t\t\tif (punch) // On of the fields we have to punch through has changed!\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * This means we have to update all versions:\n\t\t\t\t\t * \n\t\t\t\t\t * UPDATE dim SET punchf1 = val1, punchf2 = val2, ...\n\t\t\t\t\t * WHERE  fieldlookup[] = ?\n\t\t\t\t\t * ;\n\t\t\t\t\t * \n\t\t\t\t\t * --> update ALL versions in the dimension table.\n\t\t\t\t\t */\n\t\t\t\t\tdimPunchThrough( rowMeta, row );\n\t\t\t\t\tlinesUpdated++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturnRow = new Object[data.returnRowMeta.size()];\n\t\t\t\treturnRow[0] = technicalKey;\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.TechnicalKey\")+technicalKey); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddValuesToRow\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n        \n        \n        // Copy the results to the output row...\n        //\n        // First copy the input row values to the output...\n        for (int i=0;i<rowMeta.size();i++) outputRow[i] = row[i];\n\n        int outputIndex = rowMeta.size();\n        int inputIndex = 0;\n        \n        // Then the technical key...\n        outputRow[outputIndex] = returnRow[inputIndex];\n        outputIndex++;\n        inputIndex++;\n        //skip the version        \n        inputIndex++;\n        \n        // Then get the \"extra fields\"...\n        // don't return date from-to fields, they can be returned when explicitely specified in lookup fields.\n        while (inputIndex<returnRow.length && outputIndex<outputRow.length)\n\t\t{\n\t\t\toutputRow[outputIndex] = returnRow[inputIndex];\n            outputIndex++;\n            inputIndex++;\n\t\t}\n\n        // Finaly, check the date range!\n        /*\n         * TODO: WTF is this??? \n         * [May be it makes sense to keep the return date from-to fields within min/max range, but even then the code below is wrong].\n\t\tValue date;\n\t\tif (data.datefieldnr>=0) date = row.getValue(data.datefieldnr);\n\t\telse\t\t\t\tdate = new Value(\"date\", new Date()); // system date //$NON-NLS-1$\n\t\t\n\t\tif (data.min_date.compare(date)>0) data.min_date.setValue( date.getDate() ); \n\t\tif (data.max_date.compare(date)<0) data.max_date.setValue( date.getDate() ); \n         */\n        \n        return outputRow;\n\t}","id":78606,"modified_method":"private synchronized Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n\t{\n        Object[] outputRow = new Object[data.outputRowMeta.size()];\n        \n        Object[] lookupRow = new Object[data.lookupRowMeta.size()];\n\t\tObject[] returnRow = null;\n        \n\t\tLong technicalKey;\n\t\tLong valueVersion;\n\t\tDate valueDate    = null;\n\t\tDate valueDateFrom = null;\n\t\tDate valueDateTo   = null;\n\n        // Determine the lookup date (\"now\") if we have a field that carries said date.\r\n\t\t// If not, the system date is taken.\r\n\t\t//\n\t\tif (data.datefieldnr>=0)\n\t\t{\n\t\t\tdata.valueDateNow = rowMeta.getDate(row, data.datefieldnr);\n\t\t}\n\t\t\n        // Construct the \n\t\tfor (int i=0;i<meta.getKeyStream().length;i++)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlookupRow[i] = row[data.keynrs[i]];\n\t\t\t}\n\t\t\tcatch(Exception e) // TODO : remove exception??\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"DimensionLookup.Exception.ErrorDetectedInGettingKey\",i+\"\",data.keynrs[i]+\"/\"+rowMeta.size(),rowMeta.getString(row))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t}\n\t\t}\n\t\tif (data.datefieldnr>=0) valueDate = rowMeta.getDate(row, data.datefieldnr);\n\t\telse valueDate = data.valueDateNow;\n        lookupRow[meta.getKeyStream().length]=valueDate;  // ? >= date_from\n        lookupRow[meta.getKeyStream().length+1]=valueDate; // ? < date_to\n\t\t\n\t\tif (log.isDebug()) logDebug(Messages.getString(\"DimensionLookup.Log.LookupRow\")+data.lookupRowMeta.getString(lookupRow)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\n        // Do the lookup and see if we can find anything in the database.\n        // But before that, let's see if we can find anything in the cache\n        //\n        \n\t\tif (meta.getCacheSize()>=0)\n        {\n            returnRow=getFromCache(lookupRow, valueDate);\n        }\n        \n        if (returnRow==null)\n        {\n            data.db.setValues(data.lookupRowMeta, lookupRow, data.prepStatementLookup);\n            returnRow=data.db.getLookup(data.prepStatementLookup);\n            data.returnRowMeta = data.db.getReturnRowMeta();\n            \n            linesInput++;\n            \n            if (returnRow!=null && meta.getCacheSize()>=0)\n            {\n                addToCache(lookupRow, returnRow);\n            }\n        }\n\t\t\n\t\t/* Handle \"update = false\" first for performance reasons\n\t\t */\n\t\tif (!meta.isUpdate())\n\t\t{\n\t\t\tif (returnRow==null)\n\t\t\t{\n                returnRow=new Object[data.returnRowMeta.size()];\n                returnRow[0] = data.notFoundTk; \n\n                if (meta.getCacheSize()>=0) // need -oo to +oo as well...\n                {\n                    returnRow[returnRow.length-2] = data.min_date;\n                    returnRow[returnRow.length-1] = data.max_date;\n                }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We found the return values in row \"add\".\n\t\t\t\t// Throw away the version nr...\n\t\t\t\t// add.removeValue(1);\n\t\t\t\t\n\t\t\t\t// Rename the key field if needed.  Do it directly in the row...\n\t\t\t\t// if (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) add.getValue(0).setName(meta.getKeyRename());\n\t\t\t}\n\t\t}\n\t\telse  // Insert - update algorithm for slowly changing dimensions\n\t\t{\n\t\t\tif (returnRow==null) // The dimension entry was not found, we need to add it!\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.NoDimensionEntryFound\")+data.lookupRowMeta.getString(lookupRow)+\")\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t//logDetailed(\"Entry not found: add value!\");\n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = data.min_date;\n\t\t\t\tvalueDateTo   = data.max_date;\n\t\t\t\tvalueVersion  = new Long(1L);     // Versions always start at 1.\n\t\t\t\t\n\t\t\t\t// get a new value from the sequence choosen.\n\t\t\t\ttechnicalKey = null;\n\t\t\t\tswitch ( getTechKeyCreation() )\n\t\t\t\t{\n\t\t\t\t    case CREATION_METHOD_TABLEMAX:\n\t\t\t\t\t\t// What's the next value for the technical key?\n\t\t\t\t\t\ttechnicalKey=data.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), meta.getKeyField());\n                        break;\n\t\t\t\t    case CREATION_METHOD_AUTOINC:\n\t\t\t\t\t\ttechnicalKey=null; // Set to null to flag auto-increment usage\n\t\t\t\t\t\tbreak;\n\t\t\t\t    case CREATION_METHOD_SEQUENCE:\t\t\t\t\t\t\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t}\t               \n\n\t\t\t\t/*\n\t\t\t\t *   INSERT INTO table(version, datefrom, dateto, fieldlookup)\n\t\t\t\t *   VALUES(valueVersion, valueDateFrom, valueDateTo, row.fieldnrs)\n\t\t\t\t *   ;\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\ttechnicalKey = dimInsert(getInputRowMeta(), row, technicalKey, true, valueVersion, valueDateFrom, valueDateTo); \n\t\t\t\t\t\t\t\t\n\t\t\t\tlinesOutput++;\n\t\t\t\treturnRow = new Object[data.returnRowMeta.size()];\n                int returnIndex=0;\n                \n                returnRow[returnIndex] = technicalKey;\n                returnIndex++;\n                \n                // See if we need to store this record in the cache as well...\n                if (meta.getCacheSize()>=0)\n                {\n                    Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                    \n                    // put it in the cache...\n                    if (values!=null)\r\n                    {\r\n                    \taddToCache(lookupRow, values);\r\n                    }\n                }\n                \n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddedDimensionEntry\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n\t\t\t}\n\t\t\telse  // The entry was found: do we need to insert, update or both?\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.DimensionEntryFound\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n                \n\t\t\t\t// What's the key?  The first value of the return row\n\t\t\t\ttechnicalKey = data.returnRowMeta.getInteger(returnRow, 0);\n\t\t\t\tvalueVersion = data.returnRowMeta.getInteger(returnRow, 1); \n                \n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = meta.getMinDate();\n\t\t\t\tvalueDateTo   = meta.getMaxDate();\n\n\t\t\t\t// The other values, we compare with\n\t\t\t\tint cmp;\n\t\t\t\t\n\t\t\t\t// If everything is the same: don't do anything\n\t\t\t\t// If one of the fields is different: insert or update\n\t\t\t\t// If all changed fields have update = Y, update\n\t\t\t\t// If one of the changed fields has update = N, insert\n\n\t\t\t\tboolean insert=false;\n\t\t\t\tboolean identical=true;\n\t\t\t\tboolean punch=false;\n\t\t\t\t\n\t\t\t\tfor (int i=0;i<meta.getFieldStream().length;i++)\n\t\t\t\t{\n                    ValueMetaInterface v1  = data.outputRowMeta.getValueMeta(data.fieldnrs[i]);\n                    Object valueData1 = row[data.fieldnrs[i]]; \n                    ValueMetaInterface v2  = data.returnRowMeta.getValueMeta(i+2);\n                    Object valueData2 = returnRow[i+2];\n                        \n\t\t\t\t\tcmp = v1.compare(valueData1, v2, valueData2);\n\t\t\t\t\t  \n\t\t\t\t\t  // Not the same and update = 'N' --> insert\n\t\t\t\t\t  if (cmp!=0) identical=false;\n                      \n                      // Field flagged for insert: insert\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_INSERT)\n\t\t\t\t\t  { \n\t\t\t\t\t  \tinsert=true;\n\t\t\t\t\t  }\n                      \n                      // Field flagged for punchthrough\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_PUNCHTHROUGH) \n                      {\n                            punch=true;\n                      }\n\t\t\t\t\t  \n\t\t\t\t\t  if (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.ComparingValues\",\"\"+v1,\"\"+v2,String.valueOf(cmp),String.valueOf(identical),String.valueOf(insert),String.valueOf(punch))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!insert)  // Just an update of row at key = valueKey\n\t\t\t\t{\n\t\t\t\t\tif (!identical)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.UpdateRowWithValues\")+row); //$NON-NLS-1$\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * UPDATE d_customer\n\t\t\t\t\t\t * SET    fieldlookup[] = row.getValue(fieldnrs)\n\t\t\t\t\t\t * WHERE  returnkey = dimkey\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdimUpdate(rowMeta, row, technicalKey);\n\t\t\t\t\t\tlinesUpdated++;\n                        \n                        // We need to capture this change in the cache as well...\n                        if (meta.getCacheSize()>=0)\n                        {\n                            Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                            addToCache(lookupRow, values);\n                        }\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.SkipLine\")); //$NON-NLS-1$\n\t\t\t\t\t\t// Don't do anything, everything is file in de dimension.\n\t\t\t\t\t\tlinesSkipped++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.InsertNewVersion\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\n\t\t\t\t\tvalueDateFrom = data.valueDateNow;\n\t\t\t\t\tvalueDateTo   = data.max_date; //$NON-NLS-1$\n\n\t\t\t\t\t// First try to use an AUTOINCREMENT field\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsAutoinc() && isAutoIncrement())\n\t\t\t\t\t{\n\t\t\t\t\t\ttechnicalKey=new Long(0L); // value to accept new key...\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Try to get the value by looking at a SEQUENCE (oracle mostly)\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsSequences() && meta.getSequenceName()!=null && meta.getSequenceName().length()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence2\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Use our own sequence here...\n\t\t\t\t\t{\n\t\t\t\t\t\t// What's the next value for the technical key?\n                        technicalKey = data.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), meta.getKeyField());\n\t\t\t\t\t}\n\n\t\t\t\t\tdimInsert( rowMeta, row, technicalKey, false, valueVersion, valueDateFrom, valueDateTo ); \n\t\t\t\t\tlinesOutput++;\n                    \n                    // We need to capture this change in the cache as well...\n                    if (meta.getCacheSize()>=0)\n                    {\n                        Object[] values = getCacheValues(rowMeta, row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                        addToCache(lookupRow, values);\n                    }\n\t\t\t\t}\n\t\t\t\tif (punch) // On of the fields we have to punch through has changed!\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * This means we have to update all versions:\n\t\t\t\t\t * \n\t\t\t\t\t * UPDATE dim SET punchf1 = val1, punchf2 = val2, ...\n\t\t\t\t\t * WHERE  fieldlookup[] = ?\n\t\t\t\t\t * ;\n\t\t\t\t\t * \n\t\t\t\t\t * --> update ALL versions in the dimension table.\n\t\t\t\t\t */\n\t\t\t\t\tdimPunchThrough( rowMeta, row );\n\t\t\t\t\tlinesUpdated++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\treturnRow = new Object[data.returnRowMeta.size()];\n\t\t\t\treturnRow[0] = technicalKey;\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.TechnicalKey\")+technicalKey); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddValuesToRow\")+data.returnRowMeta.getString(returnRow)); //$NON-NLS-1$\n        \n        \n        // Copy the results to the output row...\n        //\n        // First copy the input row values to the output...\n        for (int i=0;i<rowMeta.size();i++) outputRow[i] = row[i];\n\n        int outputIndex = rowMeta.size();\n        int inputIndex = 0;\n        \n        // Then the technical key...\n        outputRow[outputIndex] = returnRow[inputIndex];\n        outputIndex++;\n        inputIndex++;\n        //skip the version        \n        inputIndex++;\n        \n        // Then get the \"extra fields\"...\n        // don't return date from-to fields, they can be returned when explicitely specified in lookup fields.\n        while (inputIndex<returnRow.length && outputIndex<outputRow.length)\n\t\t{\n\t\t\toutputRow[outputIndex] = returnRow[inputIndex];\n            outputIndex++;\n            inputIndex++;\n\t\t}\n\n        // Finaly, check the date range!\n        /*\n         * TODO: WTF is this??? \n         * [May be it makes sense to keep the return date from-to fields within min/max range, but even then the code below is wrong].\n\t\tValue date;\n\t\tif (data.datefieldnr>=0) date = row.getValue(data.datefieldnr);\n\t\telse\t\t\t\tdate = new Value(\"date\", new Date()); // system date //$NON-NLS-1$\n\t\t\n\t\tif (data.min_date.compare(date)>0) data.min_date.setValue( date.getDate() ); \n\t\tif (data.max_date.compare(date)<0) data.max_date.setValue( date.getDate() ); \n         */\n        \n        return outputRow;\n\t}","commit_id":"1447924e69802e856c6d980f918fa52cd09c03bb","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tRow row = getRowFromXML();\r\n\t\tif (row==null) \r\n\t\t{\r\n\t\t    setOutputDone();  // signal end to receiver(s)\r\n\t\t    return false;     // This is the end of this step.\r\n\t\t}\r\n\t\t\r\n\t\tlogRowlevel(\"Read row: \"+row.toString());\r\n        \r\n        putRow(row);\r\n        \r\n        if (meta.getRowLimit()>0 && data.rownr>=meta.getRowLimit())  // limit has been reached: stop now.\r\n        {\r\n            setOutputDone();\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n\t}","id":78607,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\r\n\t{\r\n\t\tRow row = getRowFromXML();\r\n\t\tif (row==null) \r\n\t\t{\r\n\t\t    setOutputDone();  // signal end to receiver(s)\r\n\t\t    return false;     // This is the end of this step.\r\n\t\t}\r\n\t\t\r\n\t\tif (log.isRowLevel()) logRowlevel(\"Read row: \"+row.toString());\r\n        \r\n        putRow(row);\r\n        \r\n        if (meta.getRowLimit()>0 && data.rownr>=meta.getRowLimit())  // limit has been reached: stop now.\r\n        {\r\n            setOutputDone();\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n\t}","commit_id":"75ae359e2ffcbfae3216b5d0f52cdf7654ce2f90","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private synchronized void lookupValues(Row row) throws KettleException\n\t{\n\t\tRow lu = new Row();\n\t\tRow add;\t\t\n\t\tValue technicalKey;\n\t\tValue valueVersion;\n\t\tValue valueDate    = null;\n\t\tValue valueDateFrom = null;\n\t\tValue valueDateTo   = null;\n\t\t\n\t\tif (first)\n\t\t{\n\t\t\tfirst=false;\n\t\t\tdetermineTechKeyCreation();\n\t\t\tif (getCopy()==0) data.db.checkDimZero(meta.getSchemaName(), meta.getTableName(), meta.getKeyField(), meta.getVersionField(), meta.isAutoIncrement());\n\t\t\t\n\t\t\tdata.db.setDimLookup(meta.getSchemaName(),\n                                 meta.getTableName(), \n\t\t\t\t\t\t\t\t meta.getKeyLookup(), \n\t\t\t\t                 meta.getKeyField(), \n\t\t\t\t                 meta.getVersionField(), \n\t\t\t\t                 meta.getFieldLookup(), \n                                 meta.getFieldStream(),\n\t\t\t\t                 meta.getDateFrom(), \n\t\t\t\t                 meta.getDateTo(),\n                                 meta.getCacheSize()>=0\n\t\t\t\t                );\n\t\t\t\n\t\t\t// Lookup values\n\t\t\tdata.keynrs = new int[meta.getKeyStream().length];\n\t\t\tfor (int i=0;i<meta.getKeyStream().length;i++)\n\t\t\t{\n\t\t\t\t//logDetailed(\"Lookup values key[\"+i+\"] --> \"+key[i]+\", row==null?\"+(row==null));\n\t\t\t\tdata.keynrs[i]=row.searchValueIndex(meta.getKeyStream()[i]);\n\t\t\t\tif (data.keynrs[i]<0) // couldn't find field!\n\t\t\t\t{\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"DimensionLookup.Exception.KeyFieldNotFound\",meta.getKeyStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return values\n\t\t\tif (meta.isUpdate())\n\t\t\t{\n\t\t\t\tdata.fieldnrs = new int[meta.getFieldStream().length];\n\t\t\t\tfor (int i=0;meta.getFieldStream()!=null && i<meta.getFieldStream().length;i++)\n\t\t\t\t{\n\t\t\t\t\tdata.fieldnrs[i]=row.searchValueIndex(meta.getFieldStream()[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (meta.getDateField()!=null && meta.getDateField().length()>0)\n\t\t\t{ \n\t\t\t\tdata.datefieldnr = row.searchValueIndex(meta.getDateField());\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tdata.datefieldnr=-1;\n\t\t\t} \n\n\t\t\tdata.notFoundTk = new Value(meta.getKeyField(), (long)meta.getDatabaseMeta().getNotFoundTK(meta.isAutoIncrement()));\n\t\t\tif (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) data.notFoundTk.setName(meta.getKeyRename());\n\n\t\t\tif (meta.getDateField()!=null && data.datefieldnr>=0)\n\t\t\t{\n\t\t\t\tdata.valueDateNow = row.getValue(data.datefieldnr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCalendar cal=Calendar.getInstance();\n\t\t\t\tdata.valueDateNow = new Value(\"MIN\", new Date(cal.getTimeInMillis())); // System date... //$NON-NLS-1$\n\t\t\t}\n            \n            if (meta.getCacheSize()>=0)\n            {\n                data.keyMeta = new Row();\n                for (int i=0;i<data.keynrs.length;i++)\n                {\n                    Value key = new Value(row.getValue(data.keynrs[i]));\n                    data.keyMeta.addValue(key.Clone());\n                }\n                \n                data.cache = new ByteArrayHashIndex(meta.getCacheSize()>0 ? meta.getCacheSize() : 5000, data.keyMeta);\n            }\n\t\t}\n\n\t\tif (meta.getDateField()!=null && data.datefieldnr>=0)\n\t\t{\n\t\t\tdata.valueDateNow = row.getValue(data.datefieldnr);\n\t\t}\n\t\t\n\t\tfor (int i=0;i<meta.getKeyStream().length;i++)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlu.addValue( row.getValue(data.keynrs[i]) );\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"DimensionLookup.Exception.ErrorDetectedInGettingKey\",i+\"\",data.keynrs[i]+\"/\"+row.size(),row.toString())); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t}\n\t\t}\n\t\tif (data.datefieldnr>=0)\tvalueDate = row.getValue(data.datefieldnr);\n\t\telse valueDate = data.valueDateNow;\n\t\t\n\t\tif (log.isDebug()) logDebug(Messages.getString(\"DimensionLookup.Log.LookupRow\")+lu.toString()+\" valueDate=\"+valueDate.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\n        // Do the lookup and see if we can find anything in the database.\n        // But before that, let's see if we can find anything in the cache\n        //\n        add=null;\n        if (meta.getCacheSize()>=0)\n        {\n            add=getFromCache(lu, valueDate);\n        }\n        \n        if (add==null)\n        {\n            data.db.setDimValues(lu, valueDate );\n            add=data.db.getLookup();\n            linesInput++;\n            \n            if (add!=null && meta.getCacheSize()>=0)\n            {\n                addToCache(lu, add);\n            }\n        }\n\t\t\n\t\t/* Handle \"update = false\" first for performance reasons\n\t\t */\n\t\tif (!meta.isUpdate())\n\t\t{\n\t\t\tif (add==null)\n\t\t\t{\n\t\t\t\tadd=new Row();\n\t\t\t\tadd.addValue(data.notFoundTk);\n\t\t\t\tValue v;\n\t\t\t\tfor (int i=0;i<meta.getFieldStream().length;i++)\n\t\t\t\t{\n\t\t\t\t\tif (meta.getFieldStream()[i]!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (meta.getFieldStream()[i]!=null) // Rename the field?\n\t\t\t\t\t\t\t  v=new Value(meta.getFieldStream()[i], meta.getFieldUpdate()[i]);\n\t\t\t\t\t\telse  v=new Value(meta.getFieldLookup()[i], meta.getFieldUpdate()[i]); // Nope, take the default name\n\t\t\t\t\t\tv.setNull();\n\t\t\t\t\t\tadd.addValue(v);\n\t\t\t\t\t}\n\t\t\t\t}\n                if (meta.getCacheSize()>=0) // need -oo to +oo as well...\n                {\n                    add.addValue(data.min_date.Clone());\n                    add.addValue(data.min_date.Clone());\n                }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We found the return values in row \"add\".\n\t\t\t\t// Throw away the version nr...\n\t\t\t\tadd.removeValue(1);\n\t\t\t\t\n\t\t\t\t// Rename the key field if needed.  Do it directly in the row...\n\t\t\t\tif (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) add.getValue(0).setName(meta.getKeyRename());\n\t\t\t}\n\t\t}\n\t\telse  // Insert - update algorithm for slowly changing dimensions\n\t\t{\n\t\t\tif (add==null) // The dimension entry was not found, we need to add it!\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.NoDimensionEntryFound\")+lu+\")\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t//logDetailed(\"Entry not found: add value!\");\n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = new Value(\"MIN\", meta.getMinDate()); //$NON-NLS-1$\n\t\t\t\tvalueDateTo   = new Value(\"MAX\", meta.getMaxDate()); //$NON-NLS-1$\n\t\t\t\tvalueVersion = new Value(meta.getVersionField(), 1L);     // Versions start at 1.\n\t\t\t\t\n\t\t\t\t// get a new value from the sequence choosen.\n\t\t\t\tboolean autoinc=false;\n\t\t\t\ttechnicalKey = null;\n\t\t\t\tswitch ( getTechKeyCreation() )\n\t\t\t\t{\n\t\t\t\t    case CREATION_METHOD_TABLEMAX:\n\t\t\t\t\t\t// What's the next value for the technical key?\n\t\t\t\t\t\ttechnicalKey=new Value(meta.getKeyField(), 0L); // value to accept new key...\n\t\t\t\t\t\tdata.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), technicalKey);\n                        break;\n\t\t\t\t    case CREATION_METHOD_AUTOINC:\n\t\t\t\t\t\tautoinc=true;\n\t\t\t\t\t\ttechnicalKey=new Value(meta.getKeyField(), 0L); // value to accept new key...\n\t\t\t\t\t\tbreak;\n\t\t\t\t    case CREATION_METHOD_SEQUENCE:\t\t\t\t\t\t\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t}\t               \n\n\t\t\t\t/*\n\t\t\t\t *   INSERT INTO table(version, datefrom, dateto, fieldlookup)\n\t\t\t\t *   VALUES(valueVersion, valueDateFrom, valueDateTo, row.fieldnrs)\n\t\t\t\t *   ;\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\tdata.db.dimInsert(row, meta.getSchemaName(), meta.getTableName(), \n\t\t\t\t\t\t\t\t  true, \n\t\t\t\t\t\t\t\t  autoinc?null:meta.getKeyField(),   // In case of auto increment, don't insert the key, let the database do it.\n\t\t\t\t\t\t\t\t  autoinc, \n\t\t\t\t\t\t\t\t  technicalKey, \n\t\t\t\t\t\t\t\t  meta.getVersionField(), valueVersion, \n\t\t\t\t\t\t\t\t  meta.getDateFrom(), valueDateFrom, \n\t\t\t\t\t\t\t\t  meta.getDateTo(), valueDateTo, \n\t\t\t\t\t\t\t\t  meta.getFieldLookup(), data.fieldnrs,\n\t\t\t\t\t\t\t\t  meta.getKeyStream(), \n\t\t\t\t\t\t\t\t  meta.getKeyLookup(), data.keynrs\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\n\t\t\t\tlinesOutput++;\n\t\t\t\tadd=new Row();\n\t\t\t\tif (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) technicalKey.setName(meta.getKeyRename());\n\t\t\t\tadd.addValue(technicalKey);\n                \n                // See if we need to store this record in the cache as well...\n                if (meta.getCacheSize()>=0)\n                {\n                    Row values = getCacheValues(row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                    \n                    // put it in the cache...\n                    addToCache(lu, values);\n                }\n                \n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddedDimensionEntry\")+add.toString()); //$NON-NLS-1$\n\t\t\t}\n\t\t\telse  // The entry was found: do we need to insert, update or both?\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.DimensionEntryFound\")+add); //$NON-NLS-1$\n                \n\t\t\t\t// What's the key?  The first value of the return row\n\t\t\t\ttechnicalKey     = add.getValue(0);\n\t\t\t\tvalueVersion = add.getValue(1); \n                \n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = new Value(\"MIN\", meta.getMinDate()); //$NON-NLS-1$\n\t\t\t\tvalueDateTo   = new Value(\"MAX\", meta.getMaxDate()); //$NON-NLS-1$\n\n\t\t\t\t// The other values, we compare with\n\t\t\t\tint cmp;\n\t\t\t\t\n\t\t\t\t// If everything is the same: don't do anything\n\t\t\t\t// If one of the fields is different: insert or update\n\t\t\t\t// If all changed fields have update = Y, update\n\t\t\t\t// If one of the changed fields has update = N, insert\n\n\t\t\t\tboolean insert=false;\n\t\t\t\tboolean identical=true;\n\t\t\t\tboolean punch=false;\n\t\t\t\tValue v1, v2;\n\t\t\t\t\n\t\t\t\tfor (int i=0;i<meta.getFieldStream().length;i++)\n\t\t\t\t{\n\t\t\t\t\tv1  = row.getValue(data.fieldnrs[i]);\n\t\t\t\t\tv2  = add.getValue(i+2);\n\t\t\t\t\tcmp = v1.compare(v2);\n\t\t\t\t\t  \n\t\t\t\t\t  // Not the same and update = 'N' --> insert\n\t\t\t\t\t  if (cmp!=0) identical=false;\n                      \n                      // Field flagged for insert: insert\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_INSERT)\n\t\t\t\t\t  { \n\t\t\t\t\t  \tinsert=true;\n\t\t\t\t\t  }\n                      \n                      // Field flagged for punchthrough\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_PUNCHTHROUGH) \n                      {\n                            punch=true;\n                      }\n\t\t\t\t\t  \n\t\t\t\t\t  logRowlevel(Messages.getString(\"DimensionLookup.Log.ComparingValues\",\"\"+v1,\"\"+v2,String.valueOf(cmp),String.valueOf(identical),String.valueOf(insert),String.valueOf(punch))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!insert)  // Just an update of row at key = valueKey\n\t\t\t\t{\n\t\t\t\t\tif (!identical)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.UpdateRowWithValues\")+row); //$NON-NLS-1$\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * UPDATE d_customer\n\t\t\t\t\t\t * SET    fieldlookup[] = row.getValue(fieldnrs)\n\t\t\t\t\t\t * WHERE  returnkey = dimkey\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdata.db.dimUpdate(row, meta.getSchemaName(), meta.getTableName(), meta.getFieldLookup(), data.fieldnrs, meta.getKeyField(), technicalKey);\n\t\t\t\t\t\tlinesUpdated++;\n                        \n                        // We need to capture this change in the cache as well...\n                        if (meta.getCacheSize()>=0)\n                        {\n                            Row values = getCacheValues(row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                            addToCache(lu, values);\n                        }\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.SkipLine\")); //$NON-NLS-1$\n\t\t\t\t\t\t// Don't do anything, everything is file in de dimension.\n\t\t\t\t\t\tlinesSkipped++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.InsertNewVersion\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\n\t\t\t\t\tvalueDateFrom = data.valueDateNow;\n\t\t\t\t\tvalueDateTo   = new Value(\"MAX\", meta.getMaxDate()); //$NON-NLS-1$\n\n\t\t\t\t\tboolean autoinc=false;\t\t\t\t\t\n\t\t\t\t\t// First try to use an AUTOINCREMENT field\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsAutoinc() && meta.isAutoIncrement())\n\t\t\t\t\t{\n\t\t\t\t\t\tautoinc=true;\n\t\t\t\t\t\ttechnicalKey=new Value(meta.getKeyField(), 0.0); // value to accept new key...\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Try to get the value by looking at a SEQUENCE (oracle mostly)\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsSequences() && meta.getSequenceName()!=null && meta.getSequenceName().length()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence2\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Use our own sequence here...\n\t\t\t\t\t{\n\t\t\t\t\t\t// What's the next value for the technical key?\n\t\t\t\t\t\ttechnicalKey=new Value(meta.getKeyField(), 0L); // value to accept new key...\n\t\t\t\t\t\tdata.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), technicalKey);\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.db.dimInsert( row, meta.getSchemaName(), meta.getTableName(), \n\t\t\t\t\t\t\t\t\t   false,\n\t\t\t\t\t\t\t\t\t   meta.getKeyField(), autoinc, technicalKey, \n\t\t\t\t\t\t\t\t\t   meta.getVersionField(), valueVersion, \n\t\t\t\t\t\t\t\t\t   meta.getDateFrom(), valueDateFrom, \n\t\t\t\t\t\t\t\t\t   meta.getDateTo(), valueDateTo, \n\t\t\t\t\t\t\t\t\t   meta.getFieldLookup(), data.fieldnrs, \n\t\t\t\t\t\t\t\t\t   meta.getKeyStream(), meta.getKeyLookup(), data.keynrs\n\t\t\t\t\t\t         );\n\t\t\t\t\tlinesOutput++;\n                    \n                    // We need to capture this change in the cache as well...\n                    if (meta.getCacheSize()>=0)\n                    {\n                        Row values = getCacheValues(row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                        addToCache(lu, values);\n                    }\n\t\t\t\t}\n\t\t\t\tif (punch) // On of the fields we have to punch through has changed!\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * This means we have to update all versions:\n\t\t\t\t\t * \n\t\t\t\t\t * UPDATE dim SET punchf1 = val1, punchf2 = val2, ...\n\t\t\t\t\t * WHERE  fieldlookup[] = ?\n\t\t\t\t\t * ;\n\t\t\t\t\t * \n\t\t\t\t\t * --> update ALL versions in the dimension table.\n\t\t\t\t\t */\n\t\t\t\t\tdata.db.dimPunchThrough( row, meta.getSchemaName(), meta.getTableName(), meta.getFieldUpdate(), \n\t\t\t\t\t\t\t\t\t\t\t meta.getFieldLookup(), data.fieldnrs, \n\t\t\t\t\t\t\t\t\t\t\t meta.getKeyStream(), meta.getKeyLookup(), data.keynrs\n\t\t\t\t\t\t\t\t\t \t);\n\t\t\t\t\tlinesUpdated++;\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tadd=new Row();\n\t\t\t\tif (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) technicalKey.setName(meta.getKeyRename());\n\t\t\t\tadd.addValue(technicalKey);\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.TechnicalKey\")+technicalKey); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddValuesToRow\")+add); //$NON-NLS-1$\n        \n        int size = add.size();\n        if (meta.getCacheSize()>=0 && !meta.isUpdate()) // don't return date from-to fields.\n        {\n            size-=2; \n        }\n\t\tfor (int i=0;i<size;i++)\n\t\t{\n\t\t\trow.addValue( add.getValue(i) );\n\t\t}\n\n\t\t//\n\t\t// Finaly, check the date range!\n\t\tValue date;\n\t\tif (data.datefieldnr>=0) date = row.getValue(data.datefieldnr);\n\t\telse\t\t\t\tdate = new Value(\"date\", new Date()); // system date //$NON-NLS-1$\n\t\t\n\t\tif (data.min_date.compare(date)>0) data.min_date.setValue( date.getDate() ); \n\t\tif (data.max_date.compare(date)<0) data.max_date.setValue( date.getDate() ); \n\t}","id":78608,"modified_method":"private synchronized void lookupValues(Row row) throws KettleException\n\t{\n\t\tRow lu = new Row();\n\t\tRow add;\t\t\n\t\tValue technicalKey;\n\t\tValue valueVersion;\n\t\tValue valueDate    = null;\n\t\tValue valueDateFrom = null;\n\t\tValue valueDateTo   = null;\n\t\t\n\t\tif (first)\n\t\t{\n\t\t\tfirst=false;\n\t\t\tdetermineTechKeyCreation();\n\t\t\tif (getCopy()==0) data.db.checkDimZero(meta.getSchemaName(), meta.getTableName(), meta.getKeyField(), meta.getVersionField(), meta.isAutoIncrement());\n\t\t\t\n\t\t\tdata.db.setDimLookup(meta.getSchemaName(),\n                                 meta.getTableName(), \n\t\t\t\t\t\t\t\t meta.getKeyLookup(), \n\t\t\t\t                 meta.getKeyField(), \n\t\t\t\t                 meta.getVersionField(), \n\t\t\t\t                 meta.getFieldLookup(), \n                                 meta.getFieldStream(),\n\t\t\t\t                 meta.getDateFrom(), \n\t\t\t\t                 meta.getDateTo(),\n                                 meta.getCacheSize()>=0\n\t\t\t\t                );\n\t\t\t\n\t\t\t// Lookup values\n\t\t\tdata.keynrs = new int[meta.getKeyStream().length];\n\t\t\tfor (int i=0;i<meta.getKeyStream().length;i++)\n\t\t\t{\n\t\t\t\t//logDetailed(\"Lookup values key[\"+i+\"] --> \"+key[i]+\", row==null?\"+(row==null));\n\t\t\t\tdata.keynrs[i]=row.searchValueIndex(meta.getKeyStream()[i]);\n\t\t\t\tif (data.keynrs[i]<0) // couldn't find field!\n\t\t\t\t{\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"DimensionLookup.Exception.KeyFieldNotFound\",meta.getKeyStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Return values\n\t\t\tif (meta.isUpdate())\n\t\t\t{\n\t\t\t\tdata.fieldnrs = new int[meta.getFieldStream().length];\n\t\t\t\tfor (int i=0;meta.getFieldStream()!=null && i<meta.getFieldStream().length;i++)\n\t\t\t\t{\n          data.fieldnrs[i]=row.searchValueIndex(meta.getFieldStream()[i]);\n\t\t\t\t  if (data.fieldnrs[i]<0) // couldn't find field!\n          {\n            throw new KettleStepException(Messages.getString(\"DimensionLookup.Exception.KeyFieldNotFound\", meta.getFieldStream()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n          }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (meta.getDateField()!=null && meta.getDateField().length()>0)\n\t\t\t{ \n\t\t\t\tdata.datefieldnr = row.searchValueIndex(meta.getDateField());\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tdata.datefieldnr=-1;\n\t\t\t} \n\n\t\t\tdata.notFoundTk = new Value(meta.getKeyField(), (long)meta.getDatabaseMeta().getNotFoundTK(meta.isAutoIncrement()));\n\t\t\tif (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) data.notFoundTk.setName(meta.getKeyRename());\n\n\t\t\tif (meta.getDateField()!=null && data.datefieldnr>=0)\n\t\t\t{\n\t\t\t\tdata.valueDateNow = row.getValue(data.datefieldnr);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tCalendar cal=Calendar.getInstance();\n\t\t\t\tdata.valueDateNow = new Value(\"MIN\", new Date(cal.getTimeInMillis())); // System date... //$NON-NLS-1$\n\t\t\t}\n            \n            if (meta.getCacheSize()>=0)\n            {\n                data.keyMeta = new Row();\n                for (int i=0;i<data.keynrs.length;i++)\n                {\n                    Value key = new Value(row.getValue(data.keynrs[i]));\n                    data.keyMeta.addValue(key.Clone());\n                }\n                \n                data.cache = new ByteArrayHashIndex(meta.getCacheSize()>0 ? meta.getCacheSize() : 5000, data.keyMeta);\n            }\n\t\t}\n\n\t\tif (meta.getDateField()!=null && data.datefieldnr>=0)\n\t\t{\n\t\t\tdata.valueDateNow = row.getValue(data.datefieldnr);\n\t\t}\n\t\t\n\t\tfor (int i=0;i<meta.getKeyStream().length;i++)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tlu.addValue( row.getValue(data.keynrs[i]) );\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"DimensionLookup.Exception.ErrorDetectedInGettingKey\",i+\"\",data.keynrs[i]+\"/\"+row.size(),row.toString())); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$\n\t\t\t}\n\t\t}\n\t\tif (data.datefieldnr>=0)\tvalueDate = row.getValue(data.datefieldnr);\n\t\telse valueDate = data.valueDateNow;\n\t\t\n\t\tif (log.isDebug()) logDebug(Messages.getString(\"DimensionLookup.Log.LookupRow\")+lu.toString()+\" valueDate=\"+valueDate.toString()); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\n        // Do the lookup and see if we can find anything in the database.\n        // But before that, let's see if we can find anything in the cache\n        //\n        add=null;\n        if (meta.getCacheSize()>=0)\n        {\n            add=getFromCache(lu, valueDate);\n        }\n        \n        if (add==null)\n        {\n            data.db.setDimValues(lu, valueDate );\n            add=data.db.getLookup();\n            linesInput++;\n            \n            if (add!=null && meta.getCacheSize()>=0)\n            {\n                addToCache(lu, add);\n            }\n        }\n\t\t\n\t\t/* Handle \"update = false\" first for performance reasons\n\t\t */\n\t\tif (!meta.isUpdate())\n\t\t{\n\t\t\tif (add==null)\n\t\t\t{\n\t\t\t\tadd=new Row();\n\t\t\t\tadd.addValue(data.notFoundTk);\n\t\t\t\tValue v;\n\t\t\t\tfor (int i=0;i<meta.getFieldStream().length;i++)\n\t\t\t\t{\n\t\t\t\t\tif (meta.getFieldStream()[i]!=null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (meta.getFieldStream()[i]!=null) // Rename the field?\n\t\t\t\t\t\t\t  v=new Value(meta.getFieldStream()[i], meta.getFieldUpdate()[i]);\n\t\t\t\t\t\telse  v=new Value(meta.getFieldLookup()[i], meta.getFieldUpdate()[i]); // Nope, take the default name\n\t\t\t\t\t\tv.setNull();\n\t\t\t\t\t\tadd.addValue(v);\n\t\t\t\t\t}\n\t\t\t\t}\n                if (meta.getCacheSize()>=0) // need -oo to +oo as well...\n                {\n                    add.addValue(data.min_date.Clone());\n                    add.addValue(data.min_date.Clone());\n                }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We found the return values in row \"add\".\n\t\t\t\t// Throw away the version nr...\n\t\t\t\tadd.removeValue(1);\n\t\t\t\t\n\t\t\t\t// Rename the key field if needed.  Do it directly in the row...\n\t\t\t\tif (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) add.getValue(0).setName(meta.getKeyRename());\n\t\t\t}\n\t\t}\n\t\telse  // Insert - update algorithm for slowly changing dimensions\n\t\t{\n\t\t\tif (add==null) // The dimension entry was not found, we need to add it!\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.NoDimensionEntryFound\")+lu+\")\"); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t//logDetailed(\"Entry not found: add value!\");\n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = new Value(\"MIN\", meta.getMinDate()); //$NON-NLS-1$\n\t\t\t\tvalueDateTo   = new Value(\"MAX\", meta.getMaxDate()); //$NON-NLS-1$\n\t\t\t\tvalueVersion = new Value(meta.getVersionField(), 1L);     // Versions start at 1.\n\t\t\t\t\n\t\t\t\t// get a new value from the sequence choosen.\n\t\t\t\tboolean autoinc=false;\n\t\t\t\ttechnicalKey = null;\n\t\t\t\tswitch ( getTechKeyCreation() )\n\t\t\t\t{\n\t\t\t\t    case CREATION_METHOD_TABLEMAX:\n\t\t\t\t\t\t// What's the next value for the technical key?\n\t\t\t\t\t\ttechnicalKey=new Value(meta.getKeyField(), 0L); // value to accept new key...\n\t\t\t\t\t\tdata.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), technicalKey);\n                        break;\n\t\t\t\t    case CREATION_METHOD_AUTOINC:\n\t\t\t\t\t\tautoinc=true;\n\t\t\t\t\t\ttechnicalKey=new Value(meta.getKeyField(), 0L); // value to accept new key...\n\t\t\t\t\t\tbreak;\n\t\t\t\t    case CREATION_METHOD_SEQUENCE:\t\t\t\t\t\t\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\tbreak;\t\t\t\t\t\n\t\t\t\t}\t               \n\n\t\t\t\t/*\n\t\t\t\t *   INSERT INTO table(version, datefrom, dateto, fieldlookup)\n\t\t\t\t *   VALUES(valueVersion, valueDateFrom, valueDateTo, row.fieldnrs)\n\t\t\t\t *   ;\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\tdata.db.dimInsert(row, meta.getSchemaName(), meta.getTableName(), \n\t\t\t\t\t\t\t\t  true, \n\t\t\t\t\t\t\t\t  autoinc?null:meta.getKeyField(),   // In case of auto increment, don't insert the key, let the database do it.\n\t\t\t\t\t\t\t\t  autoinc, \n\t\t\t\t\t\t\t\t  technicalKey, \n\t\t\t\t\t\t\t\t  meta.getVersionField(), valueVersion, \n\t\t\t\t\t\t\t\t  meta.getDateFrom(), valueDateFrom, \n\t\t\t\t\t\t\t\t  meta.getDateTo(), valueDateTo, \n\t\t\t\t\t\t\t\t  meta.getFieldLookup(), data.fieldnrs,\n\t\t\t\t\t\t\t\t  meta.getKeyStream(), \n\t\t\t\t\t\t\t\t  meta.getKeyLookup(), data.keynrs\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\n\t\t\t\tlinesOutput++;\n\t\t\t\tadd=new Row();\n\t\t\t\tif (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) technicalKey.setName(meta.getKeyRename());\n\t\t\t\tadd.addValue(technicalKey);\n                \n                // See if we need to store this record in the cache as well...\n                if (meta.getCacheSize()>=0)\n                {\n                    Row values = getCacheValues(row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                    \n                    // put it in the cache...\n                    addToCache(lu, values);\n                }\n                \n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddedDimensionEntry\")+add.toString()); //$NON-NLS-1$\n\t\t\t}\n\t\t\telse  // The entry was found: do we need to insert, update or both?\n\t\t\t{\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.DimensionEntryFound\")+add); //$NON-NLS-1$\n                \n\t\t\t\t// What's the key?  The first value of the return row\n\t\t\t\ttechnicalKey     = add.getValue(0);\n\t\t\t\tvalueVersion = add.getValue(1); \n                \n\t\t\t\t// Date range: ]-oo,+oo[ \n\t\t\t\tvalueDateFrom = new Value(\"MIN\", meta.getMinDate()); //$NON-NLS-1$\n\t\t\t\tvalueDateTo   = new Value(\"MAX\", meta.getMaxDate()); //$NON-NLS-1$\n\n\t\t\t\t// The other values, we compare with\n\t\t\t\tint cmp;\n\t\t\t\t\n\t\t\t\t// If everything is the same: don't do anything\n\t\t\t\t// If one of the fields is different: insert or update\n\t\t\t\t// If all changed fields have update = Y, update\n\t\t\t\t// If one of the changed fields has update = N, insert\n\n\t\t\t\tboolean insert=false;\n\t\t\t\tboolean identical=true;\n\t\t\t\tboolean punch=false;\n\t\t\t\tValue v1, v2;\n\t\t\t\t\n\t\t\t\tfor (int i=0;i<meta.getFieldStream().length;i++)\n\t\t\t\t{\n\t\t\t\t\tv1  = row.getValue(data.fieldnrs[i]);\n\t\t\t\t\tv2  = add.getValue(i+2);\n\t\t\t\t\tcmp = v1.compare(v2);\n\t\t\t\t\t  \n\t\t\t\t\t  // Not the same and update = 'N' --> insert\n\t\t\t\t\t  if (cmp!=0) identical=false;\n                      \n                      // Field flagged for insert: insert\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_INSERT)\n\t\t\t\t\t  { \n\t\t\t\t\t  \tinsert=true;\n\t\t\t\t\t  }\n                      \n                      // Field flagged for punchthrough\n\t\t\t\t\t  if (cmp!=0 && meta.getFieldUpdate()[i]==DimensionLookupMeta.TYPE_UPDATE_DIM_PUNCHTHROUGH) \n                      {\n                            punch=true;\n                      }\n\t\t\t\t\t  \n\t\t\t\t\t  if (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.ComparingValues\",\"\"+v1,\"\"+v2,String.valueOf(cmp),String.valueOf(identical),String.valueOf(insert),String.valueOf(punch))); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$ //$NON-NLS-6$\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!insert)  // Just an update of row at key = valueKey\n\t\t\t\t{\n\t\t\t\t\tif (!identical)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.UpdateRowWithValues\")+row); //$NON-NLS-1$\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * UPDATE d_customer\n\t\t\t\t\t\t * SET    fieldlookup[] = row.getValue(fieldnrs)\n\t\t\t\t\t\t * WHERE  returnkey = dimkey\n\t\t\t\t\t\t */\n\t\t\t\t\t\tdata.db.dimUpdate(row, meta.getSchemaName(), meta.getTableName(), meta.getFieldLookup(), data.fieldnrs, meta.getKeyField(), technicalKey);\n\t\t\t\t\t\tlinesUpdated++;\n                        \n                        // We need to capture this change in the cache as well...\n                        if (meta.getCacheSize()>=0)\n                        {\n                            Row values = getCacheValues(row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                            addToCache(lu, values);\n                        }\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.SkipLine\")); //$NON-NLS-1$\n\t\t\t\t\t\t// Don't do anything, everything is file in de dimension.\n\t\t\t\t\t\tlinesSkipped++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.InsertNewVersion\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t\n\t\t\t\t\tvalueDateFrom = data.valueDateNow;\n\t\t\t\t\tvalueDateTo   = new Value(\"MAX\", meta.getMaxDate()); //$NON-NLS-1$\n\n\t\t\t\t\tboolean autoinc=false;\t\t\t\t\t\n\t\t\t\t\t// First try to use an AUTOINCREMENT field\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsAutoinc() && meta.isAutoIncrement())\n\t\t\t\t\t{\n\t\t\t\t\t\tautoinc=true;\n\t\t\t\t\t\ttechnicalKey=new Value(meta.getKeyField(), 0.0); // value to accept new key...\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Try to get the value by looking at a SEQUENCE (oracle mostly)\n\t\t\t\t\tif (meta.getDatabaseMeta().supportsSequences() && meta.getSequenceName()!=null && meta.getSequenceName().length()>0)\n\t\t\t\t\t{\n\t\t\t\t\t\ttechnicalKey=data.db.getNextSequenceValue(meta.getSchemaName(), meta.getSequenceName(), meta.getKeyField());\n\t\t\t\t\t\tif (technicalKey!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.FoundNextSequence2\")+technicalKey.toString()); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t// Use our own sequence here...\n\t\t\t\t\t{\n\t\t\t\t\t\t// What's the next value for the technical key?\n\t\t\t\t\t\ttechnicalKey=new Value(meta.getKeyField(), 0L); // value to accept new key...\n\t\t\t\t\t\tdata.db.getNextValue(getTransMeta().getCounters(), meta.getSchemaName(), meta.getTableName(), technicalKey);\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.db.dimInsert( row, meta.getSchemaName(), meta.getTableName(), \n\t\t\t\t\t\t\t\t\t   false,\n\t\t\t\t\t\t\t\t\t   meta.getKeyField(), autoinc, technicalKey, \n\t\t\t\t\t\t\t\t\t   meta.getVersionField(), valueVersion, \n\t\t\t\t\t\t\t\t\t   meta.getDateFrom(), valueDateFrom, \n\t\t\t\t\t\t\t\t\t   meta.getDateTo(), valueDateTo, \n\t\t\t\t\t\t\t\t\t   meta.getFieldLookup(), data.fieldnrs, \n\t\t\t\t\t\t\t\t\t   meta.getKeyStream(), meta.getKeyLookup(), data.keynrs\n\t\t\t\t\t\t         );\n\t\t\t\t\tlinesOutput++;\n                    \n                    // We need to capture this change in the cache as well...\n                    if (meta.getCacheSize()>=0)\n                    {\n                        Row values = getCacheValues(row, technicalKey, valueVersion, valueDateFrom, valueDateTo);\n                        addToCache(lu, values);\n                    }\n\t\t\t\t}\n\t\t\t\tif (punch) // On of the fields we have to punch through has changed!\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\t * This means we have to update all versions:\n\t\t\t\t\t * \n\t\t\t\t\t * UPDATE dim SET punchf1 = val1, punchf2 = val2, ...\n\t\t\t\t\t * WHERE  fieldlookup[] = ?\n\t\t\t\t\t * ;\n\t\t\t\t\t * \n\t\t\t\t\t * --> update ALL versions in the dimension table.\n\t\t\t\t\t */\n\t\t\t\t\tdata.db.dimPunchThrough( row, meta.getSchemaName(), meta.getTableName(), meta.getFieldUpdate(), \n\t\t\t\t\t\t\t\t\t\t\t meta.getFieldLookup(), data.fieldnrs, \n\t\t\t\t\t\t\t\t\t\t\t meta.getKeyStream(), meta.getKeyLookup(), data.keynrs\n\t\t\t\t\t\t\t\t\t \t);\n\t\t\t\t\tlinesUpdated++;\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tadd=new Row();\n\t\t\t\tif (meta.getKeyRename()!=null && meta.getKeyRename().length()>0) technicalKey.setName(meta.getKeyRename());\n\t\t\t\tadd.addValue(technicalKey);\n\t\t\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.TechnicalKey\")+technicalKey); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (log.isRowLevel()) logRowlevel(Messages.getString(\"DimensionLookup.Log.AddValuesToRow\")+add); //$NON-NLS-1$\n        \n        int size = add.size();\n        if (meta.getCacheSize()>=0 && !meta.isUpdate()) // don't return date from-to fields.\n        {\n            size-=2; \n        }\n\t\tfor (int i=0;i<size;i++)\n\t\t{\n\t\t\trow.addValue( add.getValue(i) );\n\t\t}\n\n\t\t//\n\t\t// Finaly, check the date range!\n\t\tValue date;\n\t\tif (data.datefieldnr>=0) date = row.getValue(data.datefieldnr);\n\t\telse\t\t\t\tdate = new Value(\"date\", new Date()); // system date //$NON-NLS-1$\n\t\t\n\t\tif (data.min_date.compare(date)>0) data.min_date.setValue( date.getDate() ); \n\t\tif (data.max_date.compare(date)<0) data.max_date.setValue( date.getDate() ); \n\t}","commit_id":"705caff4f59219c297850030f3e2da82dda41b1b","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(AddSequenceMeta)smi;\n\t\tdata=(AddSequenceData)sdi;\n\n\t\tRow r=null;\n\t\t\n\t\tr=getRow();       // Get row from input rowset & set row busy!\t\t\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\n        log.logRowlevel(toString(), Messages.getString(\"AddSequence.Log.ReadRow\")+linesRead+\" : \"+r); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\ttry\n\t\t{\n\t\t\taddSequence(r); // add new values to the row in rowset[0].\t\t\t\n\t\t\tputRow(r);       // copy row to output rowset(s);\n\t\t\t\n            log.logRowlevel(toString(), Messages.getString(\"AddSequence.Log.WriteRow\")+linesWritten+\" : \"+r); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tif ((linesRead>0) && (linesRead>0) && (linesRead%Const.ROWS_UPDATE)==0) logBasic(Messages.getString(\"AddSequence.Log.LineNumber\")+linesRead); //$NON-NLS-1$\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlogError(Messages.getString(\"AddSequence.Log.ErrorInStep\")+e.getMessage()); //$NON-NLS-1$\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\treturn false;\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","id":78609,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(AddSequenceMeta)smi;\n\t\tdata=(AddSequenceData)sdi;\n\n\t\tRow r=null;\n\t\t\n\t\tr=getRow();       // Get row from input rowset & set row busy!\t\t\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\n        if (log.isRowLevel()) log.logRowlevel(toString(), Messages.getString(\"AddSequence.Log.ReadRow\")+linesRead+\" : \"+r); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\ttry\n\t\t{\n\t\t\taddSequence(r); // add new values to the row in rowset[0].\t\t\t\n\t\t\tputRow(r);       // copy row to output rowset(s);\n\t\t\t\n            if (log.isRowLevel()) log.logRowlevel(toString(), Messages.getString(\"AddSequence.Log.WriteRow\")+linesWritten+\" : \"+r); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\tif ((linesRead>0) && (linesRead>0) && (linesRead%Const.ROWS_UPDATE)==0) logBasic(Messages.getString(\"AddSequence.Log.LineNumber\")+linesRead); //$NON-NLS-1$\n\t\t}\n\t\tcatch(KettleException e)\n\t\t{\n\t\t\tlogError(Messages.getString(\"AddSequence.Log.ErrorInStep\")+e.getMessage()); //$NON-NLS-1$\n\t\t\tsetErrors(1);\n\t\t\tstopAll();\n\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\treturn false;\n\t\t}\n\t\t\t\n\t\treturn true;\n\t}","commit_id":"4413a46ad662b6b9b2cea0485a5f84c5feba22c4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(CalculatorMeta)smi;\n\t\tdata=(CalculatorData)sdi;\n\n\t\tRow r=getRow();    // get row, set busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\n        log.logRowlevel(toString(), \"Read row #\"+linesRead+\" : \"+r);\n\n        calcFields(r);\t\t\n\t\tputRow(r);     // copy row to possible alternate rowset(s).\n\n        log.logRowlevel(toString(), \"Wrote row #\"+linesWritten+\" : \"+r);        \n\t\tif ((linesRead>0) && (linesRead%Const.ROWS_UPDATE)==0) logBasic(\"Linenr \"+linesRead);\n\n\t\treturn true;\n\t}","id":78610,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(CalculatorMeta)smi;\n\t\tdata=(CalculatorData)sdi;\n\n\t\tRow r=getRow();    // get row, set busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\n        if (log.isRowLevel()) log.logRowlevel(toString(), \"Read row #\"+linesRead+\" : \"+r);\n\n        calcFields(r);\t\t\n\t\tputRow(r);     // copy row to possible alternate rowset(s).\n\n        if (log.isRowLevel()) log.logRowlevel(toString(), \"Wrote row #\"+linesWritten+\" : \"+r);        \n\t\tif ((linesRead>0) && (linesRead%Const.ROWS_UPDATE)==0) logBasic(\"Linenr \"+linesRead);\n\n\t\treturn true;\n\t}","commit_id":"4413a46ad662b6b9b2cea0485a5f84c5feba22c4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void lookupValues(Row row)\n\t\tthrows KettleException\n\t{\n\t\tValue val_hash    = null;\n\t\tValue val_key     = null;\n\n\t\tif (first)\n\t\t{\n\t\t\tdetermineTechKeyCreation();\n\n\t\t\tfirst=false;\n\n\t\t\t// Lookup values\n\t\t\tdata.keynrs    = new int[meta.getKeyField().length];\n\t\t\tfor (int i=0;i<meta.getKeyField().length;i++)\n\t\t\t{\n\t\t\t\tdata.keynrs[i]=row.searchValueIndex(meta.getKeyField()[i]);\n\t\t\t\tif (data.keynrs[i]<0) // couldn't find field!\n\t\t\t\t{\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"CombinationLookup.Exception.FieldNotFound\",meta.getKeyField()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sort lookup values in reverse so we can delete from back to front!\n\t\t\tif (meta.replaceFields())\n\t\t\t{\n\t\t\t\tint x,y;\n\t\t\t\tint size=meta.getKeyField().length;\n\t\t\t\tint nr1, nr2;\n\n\t\t\t\tfor (x=0;x<size;x++)\n\t\t\t\t{\n\t\t\t\t\tfor (y=0;y<size-1;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tnr1 = data.keynrs[y];\n\t\t\t\t\t\tnr2 = data.keynrs[y+1];\n\n\t\t\t\t\t\tif (nr2>nr1) // reverse sort: swap values...\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nr_dummy             = data.keynrs[y];\n\t\t\t\t\t\t\tString key_dummy         = meta.getKeyField()[y];\n\t\t\t\t\t\t\tString keylookup_dummy   = meta.getKeyLookup()[y];\n\t\t\t\t\t\t\tdata.keynrs[y]           = data.keynrs[y+1];\n\t\t\t\t\t\t\tmeta.getKeyField()[y]    = meta.getKeyField()[y+1];\n\t\t\t\t\t\t\tmeta.getKeyLookup()[y]   = meta.getKeyLookup()[y+1];\n\t\t\t\t\t\t\tdata.keynrs[y+1]         = nr_dummy;\n\t\t\t\t\t\t\tmeta.getKeyField()[y+1]  = key_dummy;\n\t\t\t\t\t\t\tmeta.getKeyLookup()[y+1] = keylookup_dummy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdata.db.setCombiLookup(meta.getTablename(), meta.getKeyLookup(),\n\t\t\t\t\t\t\t\t   meta.getTechnicalKeyField(), meta.useHash(),\n\t\t\t\t\t\t\t\t   meta.getHashField() );\n\t\t}\n\n\t\tRow lu = new Row();\n\t\tfor (int i=0;i<meta.getKeyField().length;i++)\n\t\t{\n\t\t\tlu.addValue( row.getValue(data.keynrs[i]) ); // KEYi = ?\n\t\t}\n\n\t\tif (meta.useHash())\n\t\t{\n\t\t\tval_hash = new Value(meta.getHashField(), (long)lu.hashCode());\n\t\t\tlu.clear();\n\t\t\tlu.addValue(val_hash);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlu.clear();\n\t\t}\n\n\t\tfor (int i=0;i<meta.getKeyField().length;i++)\n\t\t{\n\t\t\tValue parval = row.getValue(data.keynrs[i]);\n\t\t\tlu.addValue( parval ); // KEYi = ?\n\t\t\tlu.addValue( parval ); // KEYi IS NULL or ? IS NULL\n\t\t}\n\n\t\t// Before doing the actual lookup in the database, see if it's not in the cache...\n\t\tval_key = lookupInCache(lu);\n\t\tif (val_key==null)\n\t\t{\n\t\t\tdata.db.setValuesLookup(lu);\n\t\t\tRow add=data.db.getLookup();\n\t\t\tlinesInput++;\n\n\t\t\tif (add==null) // The dimension entry was not found, we need to add it!\n\t\t\t{\n\t\t\t\t// First try to use an AUTOINCREMENT field\n\t\t\t\tboolean autoinc=false;\n\t\t\t\tswitch ( getTechKeyCreation() )\n\t\t\t\t{\n\t\t\t\t    case CREATION_METHOD_TABLEMAX:\n\t\t\t\t    \t//  Use our own counter: what's the next value for the technical key?\n\t\t\t\t        val_key=new Value(meta.getTechnicalKeyField(), 0.0); // value to accept new key...\n\t\t\t\t        data.db.getNextValue(getTransMeta().getCounters(), meta.getTablename(), val_key);\n                        break;\n\t\t\t\t    case CREATION_METHOD_AUTOINC:\n\t\t\t\t    \tautoinc=true;\n\t\t\t\t\t\tval_key=new Value(meta.getTechnicalKeyField(), 0.0); // value to accept new key...\n\t\t\t\t\t\tbreak;\n\t\t\t\t    case CREATION_METHOD_SEQUENCE:\n\t\t\t\t\t\tval_key=data.db.getNextSequenceValue(meta.getSequenceFrom(), meta.getTechnicalKeyField());\n\t\t\t\t\t\tif (val_key!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"CombinationLookup.Log.FoundNextSequenceValue\")+val_key.toString()); //$NON-NLS-1$\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tString tkFieldName = meta.getTechnicalKeyField();\n\t\t\t\tif (autoinc) tkFieldName=null;\n\n\t\t\t\tdata.db.combiInsert( row, meta.getTablename(), tkFieldName,\n\t\t\t                    autoinc,\n\t\t\t                    val_key,\n\t\t\t\t\t\t        meta.getKeyLookup(),\n\t\t\t\t\t\t        data.keynrs,\n\t\t\t\t\t\t        meta.useHash(),\n\t\t\t\t\t\t        meta.getHashField(),\n\t\t\t\t\t\t        val_hash\n\t\t\t\t\t\t\t   );\n\n\t\t\t\tlinesOutput++;\n\n\t\t\t\tlog.logRowlevel(toString(), Messages.getString(\"CombinationLookup.Log.AddedDimensionEntry\")+val_key); //$NON-NLS-1$\n\n\t\t\t\t// Also store it in our Hashtable...\n\t\t\t\tstoreInCache(lu, val_key);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tval_key = add.getValue(0); // Only one value possible here...\n\t\t\t\tstoreInCache(lu, val_key);\n\t\t\t}\n\t\t}\n\n\t\t// See if we need to replace the fields with the technical key\n\t\tif (meta.replaceFields())\n\t\t{\n\t\t\tfor (int i=0;i<data.keynrs.length;i++)\n\t\t\t{\n\t\t\t\trow.removeValue(data.keynrs[i]); // safe because reverse sorted on index nr.\n\t\t\t}\n\t\t}\n\n\t\t// Add the technical key...\n\t\trow.addValue( val_key );\n\t}","id":78611,"modified_method":"private void lookupValues(Row row)\n\t\tthrows KettleException\n\t{\n\t\tValue val_hash    = null;\n\t\tValue val_key     = null;\n\n\t\tif (first)\n\t\t{\n\t\t\tdetermineTechKeyCreation();\n\n\t\t\tfirst=false;\n\n\t\t\t// Lookup values\n\t\t\tdata.keynrs    = new int[meta.getKeyField().length];\n\t\t\tfor (int i=0;i<meta.getKeyField().length;i++)\n\t\t\t{\n\t\t\t\tdata.keynrs[i]=row.searchValueIndex(meta.getKeyField()[i]);\n\t\t\t\tif (data.keynrs[i]<0) // couldn't find field!\n\t\t\t\t{\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"CombinationLookup.Exception.FieldNotFound\",meta.getKeyField()[i])); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Sort lookup values in reverse so we can delete from back to front!\n\t\t\tif (meta.replaceFields())\n\t\t\t{\n\t\t\t\tint x,y;\n\t\t\t\tint size=meta.getKeyField().length;\n\t\t\t\tint nr1, nr2;\n\n\t\t\t\tfor (x=0;x<size;x++)\n\t\t\t\t{\n\t\t\t\t\tfor (y=0;y<size-1;y++)\n\t\t\t\t\t{\n\t\t\t\t\t\tnr1 = data.keynrs[y];\n\t\t\t\t\t\tnr2 = data.keynrs[y+1];\n\n\t\t\t\t\t\tif (nr2>nr1) // reverse sort: swap values...\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nr_dummy             = data.keynrs[y];\n\t\t\t\t\t\t\tString key_dummy         = meta.getKeyField()[y];\n\t\t\t\t\t\t\tString keylookup_dummy   = meta.getKeyLookup()[y];\n\t\t\t\t\t\t\tdata.keynrs[y]           = data.keynrs[y+1];\n\t\t\t\t\t\t\tmeta.getKeyField()[y]    = meta.getKeyField()[y+1];\n\t\t\t\t\t\t\tmeta.getKeyLookup()[y]   = meta.getKeyLookup()[y+1];\n\t\t\t\t\t\t\tdata.keynrs[y+1]         = nr_dummy;\n\t\t\t\t\t\t\tmeta.getKeyField()[y+1]  = key_dummy;\n\t\t\t\t\t\t\tmeta.getKeyLookup()[y+1] = keylookup_dummy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdata.db.setCombiLookup(meta.getTablename(), meta.getKeyLookup(),\n\t\t\t\t\t\t\t\t   meta.getTechnicalKeyField(), meta.useHash(),\n\t\t\t\t\t\t\t\t   meta.getHashField() );\n\t\t}\n\n\t\tRow lu = new Row();\n\t\tfor (int i=0;i<meta.getKeyField().length;i++)\n\t\t{\n\t\t\tlu.addValue( row.getValue(data.keynrs[i]) ); // KEYi = ?\n\t\t}\n\n\t\tif (meta.useHash())\n\t\t{\n\t\t\tval_hash = new Value(meta.getHashField(), (long)lu.hashCode());\n\t\t\tlu.clear();\n\t\t\tlu.addValue(val_hash);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlu.clear();\n\t\t}\n\n\t\tfor (int i=0;i<meta.getKeyField().length;i++)\n\t\t{\n\t\t\tValue parval = row.getValue(data.keynrs[i]);\n\t\t\tlu.addValue( parval ); // KEYi = ?\n\t\t\tlu.addValue( parval ); // KEYi IS NULL or ? IS NULL\n\t\t}\n\n\t\t// Before doing the actual lookup in the database, see if it's not in the cache...\n\t\tval_key = lookupInCache(lu);\n\t\tif (val_key==null)\n\t\t{\n\t\t\tdata.db.setValuesLookup(lu);\n\t\t\tRow add=data.db.getLookup();\n\t\t\tlinesInput++;\n\n\t\t\tif (add==null) // The dimension entry was not found, we need to add it!\n\t\t\t{\n\t\t\t\t// First try to use an AUTOINCREMENT field\n\t\t\t\tboolean autoinc=false;\n\t\t\t\tswitch ( getTechKeyCreation() )\n\t\t\t\t{\n\t\t\t\t    case CREATION_METHOD_TABLEMAX:\n\t\t\t\t    \t//  Use our own counter: what's the next value for the technical key?\n\t\t\t\t        val_key=new Value(meta.getTechnicalKeyField(), 0.0); // value to accept new key...\n\t\t\t\t        data.db.getNextValue(getTransMeta().getCounters(), meta.getTablename(), val_key);\n                        break;\n\t\t\t\t    case CREATION_METHOD_AUTOINC:\n\t\t\t\t    \tautoinc=true;\n\t\t\t\t\t\tval_key=new Value(meta.getTechnicalKeyField(), 0.0); // value to accept new key...\n\t\t\t\t\t\tbreak;\n\t\t\t\t    case CREATION_METHOD_SEQUENCE:\n\t\t\t\t\t\tval_key=data.db.getNextSequenceValue(meta.getSequenceFrom(), meta.getTechnicalKeyField());\n\t\t\t\t\t\tif (val_key!=null && log.isRowLevel()) logRowlevel(Messages.getString(\"CombinationLookup.Log.FoundNextSequenceValue\")+val_key.toString()); //$NON-NLS-1$\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tString tkFieldName = meta.getTechnicalKeyField();\n\t\t\t\tif (autoinc) tkFieldName=null;\n\n\t\t\t\tdata.db.combiInsert( row, meta.getTablename(), tkFieldName,\n\t\t\t                    autoinc,\n\t\t\t                    val_key,\n\t\t\t\t\t\t        meta.getKeyLookup(),\n\t\t\t\t\t\t        data.keynrs,\n\t\t\t\t\t\t        meta.useHash(),\n\t\t\t\t\t\t        meta.getHashField(),\n\t\t\t\t\t\t        val_hash\n\t\t\t\t\t\t\t   );\n\n\t\t\t\tlinesOutput++;\n\n                if (log.isRowLevel()) log.logRowlevel(toString(), Messages.getString(\"CombinationLookup.Log.AddedDimensionEntry\")+val_key); //$NON-NLS-1$\n\n\t\t\t\t// Also store it in our Hashtable...\n\t\t\t\tstoreInCache(lu, val_key);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tval_key = add.getValue(0); // Only one value possible here...\n\t\t\t\tstoreInCache(lu, val_key);\n\t\t\t}\n\t\t}\n\n\t\t// See if we need to replace the fields with the technical key\n\t\tif (meta.replaceFields())\n\t\t{\n\t\t\tfor (int i=0;i<data.keynrs.length;i++)\n\t\t\t{\n\t\t\t\trow.removeValue(data.keynrs[i]); // safe because reverse sorted on index nr.\n\t\t\t}\n\t\t}\n\n\t\t// Add the technical key...\n\t\trow.addValue( val_key );\n\t}","commit_id":"4413a46ad662b6b9b2cea0485a5f84c5feba22c4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n        meta=(RowGeneratorMeta)smi;\n        data=(RowGeneratorData)sdi;\n\n\t\tRow r=null;\n\t\tboolean retval=true;\n\t\t\n\t\tif (linesWritten<meta.getRowLimit())\n\t\t{\n\t\t\tr=new Row(data.constants); // Copy the data, otherwise it gets manipulated aferwards.\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tputRow(r);\n\n        log.logRowlevel(toString(), \"Wrote row #\"+linesWritten+\" : \"+r);\n\t\tif ((linesWritten>0) && (linesWritten%Const.ROWS_UPDATE)==0) logBasic(\"Linenr \"+linesWritten);\n\t\t\n\t\treturn retval;\n\t}","id":78612,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n        meta=(RowGeneratorMeta)smi;\n        data=(RowGeneratorData)sdi;\n\n\t\tRow r=null;\n\t\tboolean retval=true;\n\t\t\n\t\tif (linesWritten<meta.getRowLimit())\n\t\t{\n\t\t\tr=new Row(data.constants); // Copy the data, otherwise it gets manipulated aferwards.\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsetOutputDone();  // signal end to receiver(s)\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tputRow(r);\n\n        if (log.isRowLevel()) log.logRowlevel(toString(), \"Wrote row #\"+linesWritten+\" : \"+r);\n\t\tif ((linesWritten>0) && (linesWritten%Const.ROWS_UPDATE)==0) logBasic(\"Linenr \"+linesWritten);\n\t\t\n\t\treturn retval;\n\t}","commit_id":"4413a46ad662b6b9b2cea0485a5f84c5feba22c4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static final ArrayList convertLineToStrings(LogWriter log, String line, TextFileInputMeta inf) throws KettleException\n\t{\n\t\tArrayList strings = new ArrayList();\n\t\tint fieldnr;\n\t\tString pol; // piece of line\n\n\t\ttry\n\t\t{\n\t\t\tif (line == null) return null;\n\n\t\t\tif (inf.getFileType().equalsIgnoreCase(\"CSV\"))\n\t\t\t{\n\t\t\t\t// Split string in pieces, only for CSV!\n\n\t\t\t\tfieldnr = 0;\n\t\t\t\tint pos = 0;\n\t\t\t\tint length = line.length();\n\t\t\t\tboolean dencl = false;\n\n\t\t\t\twhile (pos < length)\n\t\t\t\t{\n\t\t\t\t\tint from = pos;\n\t\t\t\t\tint next;\n\t\t\t\t\tint len_encl = (inf.getEnclosure() == null ? 0 : inf.getEnclosure().length());\n\t\t\t\t\tint len_esc = (inf.getEscapeCharacter() == null ? 0 : inf.getEscapeCharacter().length());\n\n\t\t\t\t\tboolean encl_found;\n\t\t\t\t\tboolean contains_escaped_enclosures = false;\n\t\t\t\t\tboolean contains_escaped_separators = false;\n\n\t\t\t\t\t// Is the field beginning with an enclosure?\n\t\t\t\t\t// \"aa;aa\";123;\"aaa-aaa\";000;...\n\t\t\t\t\tif (len_encl > 0 && line.substring(from, from + len_encl).equalsIgnoreCase(inf.getEnclosure()))\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.logRowlevel(\"convert line to row\", \"encl substring=[\" + line.substring(from, from + len_encl) + \"]\");\n\t\t\t\t\t\tencl_found = true;\n\t\t\t\t\t\tint p = from + len_encl;\n\n\t\t\t\t\t\tboolean is_enclosure = len_encl > 0 && p + len_encl < length\n\t\t\t\t\t\t\t\t&& line.substring(p, p + len_encl).equalsIgnoreCase(inf.getEnclosure());\n\t\t\t\t\t\tboolean is_escape = len_esc > 0 && p + len_esc < length\n\t\t\t\t\t\t\t\t&& line.substring(p, p + len_esc).equalsIgnoreCase(inf.getEscapeCharacter());\n\n\t\t\t\t\t\tboolean enclosure_after = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Is it really an enclosure? See if it's not repeated twice or escaped!\n\t\t\t\t\t\tif ((is_enclosure || is_escape) && p < length - 1) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString strnext = line.substring(p + len_encl, p + 2 * len_encl);\n\t\t\t\t\t\t\tif (strnext.equalsIgnoreCase(inf.getEnclosure()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tenclosure_after = true;\n\t\t\t\t\t\t\t\tdencl = true;\n\n\t\t\t\t\t\t\t\t// Remember to replace them later on!\n\t\t\t\t\t\t\t\tif (is_escape) contains_escaped_enclosures = true; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Look for a closing enclosure!\n\t\t\t\t\t\twhile ((!is_enclosure || enclosure_after) && p < line.length())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\tenclosure_after = false;\n\t\t\t\t\t\t\tis_enclosure = len_encl > 0 && p + len_encl < length && line.substring(p, p + len_encl).equals(inf.getEnclosure());\n\t\t\t\t\t\t\tis_escape = len_esc > 0 && p + len_esc < length && line.substring(p, p + len_esc).equals(inf.getEscapeCharacter());\n\n\t\t\t\t\t\t\t// Is it really an enclosure? See if it's not repeated twice or escaped!\n\t\t\t\t\t\t\tif ((is_enclosure || is_escape) && p < length - 1) // Is\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString strnext = line.substring(p + len_encl, p + 2 * len_encl);\n\t\t\t\t\t\t\t\tif (strnext.equals(inf.getEnclosure()))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\t\tenclosure_after = true;\n\t\t\t\t\t\t\t\t\tdencl = true;\n\n\t\t\t\t\t\t\t\t\t// Remember to replace them later on!\n\t\t\t\t\t\t\t\t\tif (is_escape) contains_escaped_enclosures = true; // remember\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (p >= length) next = p;\n\t\t\t\t\t\telse next = p + len_encl;\n\n\t\t\t\t\t\tlog.logRowlevel(\"convert line to row\", \"End of enclosure @ position \" + p);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tencl_found = false;\n\t\t\t\t\t\tboolean found = false;\n\t\t\t\t\t\tint startpoint = from;\n\t\t\t\t\t\tint tries = 1;\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnext = line.indexOf(inf.getSeparator(), startpoint);\n\n\t\t\t\t\t\t\t// See if this position is preceded by an escape character.\n\t\t\t\t\t\t\tif (len_esc > 0 && next - len_esc > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString before = line.substring(next - len_esc, next);\n\n\t\t\t\t\t\t\t\tif (inf.getEscapeCharacter().equals(before))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// take the next separator, this one is escaped...\n\t\t\t\t\t\t\t\t\tstartpoint = next + 1; \n\t\t\t\t\t\t\t\t\ttries++;\n\t\t\t\t\t\t\t\t\tcontains_escaped_separators = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (!found && next >= 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (next == -1) next = length;\n\n\t\t\t\t\tif (encl_found)\n\t\t\t\t\t{\n\t\t\t\t\t\tpol = line.substring(from + len_encl, next - len_encl);\n\t\t\t\t\t\tlog.logRowlevel(\"convert line to row\", \"Enclosed field found: [\" + pol + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpol = line.substring(from, next);\n\t\t\t\t\t\tlog.logRowlevel(\"convert line to row\", \"Normal field found: [\" + pol + \"]\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dencl)\n\t\t\t\t\t{\n\t\t\t\t\t\tStringBuffer sbpol = new StringBuffer(pol);\n\t\t\t\t\t\tint idx = sbpol.indexOf(inf.getEnclosure() + inf.getEnclosure());\n\t\t\t\t\t\twhile (idx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsbpol.delete(idx, idx + inf.getEnclosure().length());\n\t\t\t\t\t\t\tidx = sbpol.indexOf(inf.getEnclosure() + inf.getEnclosure());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpol = sbpol.toString();\n\t\t\t\t\t}\n\n\t\t\t\t\t//\treplace the escaped enclosures with enclosures... \n\t\t\t\t\tif (contains_escaped_enclosures) \n\t\t\t\t\t{\n\t\t\t\t\t\tString replace = inf.getEscapeCharacter() + inf.getEnclosure();\n\t\t\t\t\t\tString replaceWith = inf.getEnclosure();\n\n\t\t\t\t\t\tpol = Const.replace(pol, replace, replaceWith);\n\t\t\t\t\t}\n\n\t\t\t\t\t//replace the escaped separators with separators... \n\t\t\t\t\tif (contains_escaped_separators) \n\t\t\t\t\t{\n\t\t\t\t\t\tString replace = inf.getEscapeCharacter() + inf.getSeparator();\n\t\t\t\t\t\tString replaceWith = inf.getSeparator();\n\n\t\t\t\t\t\tpol = Const.replace(pol, replace, replaceWith);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Now add pol to the strings found!\n\t\t\t\t\tstrings.add(pol);\n\n\t\t\t\t\tpos = next + 1;\n\t\t\t\t\tfieldnr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Fixed file format: Simply get the strings at the required positions...\n\t\t\t\tfor (int i = 0; i < inf.getInputFields().length; i++)\n\t\t\t\t{\n\t\t\t\t\tTextFileInputField field = inf.getInputFields()[i];\n\n\t\t\t\t\tint length = line.length();\n\n\t\t\t\t\tif (field.getPosition() + field.getLength() <= length)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrings.add(line.substring(field.getPosition(), field.getPosition() + field.getLength()));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (field.getPosition() < length)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrings.add(line.substring(field.getPosition()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrings.add(\"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Error converting line : \" + e.toString(), e);\n\t\t}\n\n\t\treturn strings;\n\t}","id":78613,"modified_method":"public static final ArrayList convertLineToStrings(LogWriter log, String line, TextFileInputMeta inf) throws KettleException\n\t{\n\t\tArrayList strings = new ArrayList();\n\t\tint fieldnr;\n\t\tString pol; // piece of line\n\n\t\ttry\n\t\t{\n\t\t\tif (line == null) return null;\n\n\t\t\tif (inf.getFileType().equalsIgnoreCase(\"CSV\"))\n\t\t\t{\n\t\t\t\t// Split string in pieces, only for CSV!\n\n\t\t\t\tfieldnr = 0;\n\t\t\t\tint pos = 0;\n\t\t\t\tint length = line.length();\n\t\t\t\tboolean dencl = false;\n\n\t\t\t\twhile (pos < length)\n\t\t\t\t{\n\t\t\t\t\tint from = pos;\n\t\t\t\t\tint next;\n\t\t\t\t\tint len_encl = (inf.getEnclosure() == null ? 0 : inf.getEnclosure().length());\n\t\t\t\t\tint len_esc = (inf.getEscapeCharacter() == null ? 0 : inf.getEscapeCharacter().length());\n\n\t\t\t\t\tboolean encl_found;\n\t\t\t\t\tboolean contains_escaped_enclosures = false;\n\t\t\t\t\tboolean contains_escaped_separators = false;\n\n\t\t\t\t\t// Is the field beginning with an enclosure?\n\t\t\t\t\t// \"aa;aa\";123;\"aaa-aaa\";000;...\n\t\t\t\t\tif (len_encl > 0 && line.substring(from, from + len_encl).equalsIgnoreCase(inf.getEnclosure()))\n\t\t\t\t\t{\n                        if (log.isRowLevel()) log.logRowlevel(\"convert line to row\", \"encl substring=[\" + line.substring(from, from + len_encl) + \"]\");\n\t\t\t\t\t\tencl_found = true;\n\t\t\t\t\t\tint p = from + len_encl;\n\n\t\t\t\t\t\tboolean is_enclosure = len_encl > 0 && p + len_encl < length\n\t\t\t\t\t\t\t\t&& line.substring(p, p + len_encl).equalsIgnoreCase(inf.getEnclosure());\n\t\t\t\t\t\tboolean is_escape = len_esc > 0 && p + len_esc < length\n\t\t\t\t\t\t\t\t&& line.substring(p, p + len_esc).equalsIgnoreCase(inf.getEscapeCharacter());\n\n\t\t\t\t\t\tboolean enclosure_after = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Is it really an enclosure? See if it's not repeated twice or escaped!\n\t\t\t\t\t\tif ((is_enclosure || is_escape) && p < length - 1) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tString strnext = line.substring(p + len_encl, p + 2 * len_encl);\n\t\t\t\t\t\t\tif (strnext.equalsIgnoreCase(inf.getEnclosure()))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\tenclosure_after = true;\n\t\t\t\t\t\t\t\tdencl = true;\n\n\t\t\t\t\t\t\t\t// Remember to replace them later on!\n\t\t\t\t\t\t\t\tif (is_escape) contains_escaped_enclosures = true; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Look for a closing enclosure!\n\t\t\t\t\t\twhile ((!is_enclosure || enclosure_after) && p < line.length())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\tenclosure_after = false;\n\t\t\t\t\t\t\tis_enclosure = len_encl > 0 && p + len_encl < length && line.substring(p, p + len_encl).equals(inf.getEnclosure());\n\t\t\t\t\t\t\tis_escape = len_esc > 0 && p + len_esc < length && line.substring(p, p + len_esc).equals(inf.getEscapeCharacter());\n\n\t\t\t\t\t\t\t// Is it really an enclosure? See if it's not repeated twice or escaped!\n\t\t\t\t\t\t\tif ((is_enclosure || is_escape) && p < length - 1) // Is\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString strnext = line.substring(p + len_encl, p + 2 * len_encl);\n\t\t\t\t\t\t\t\tif (strnext.equals(inf.getEnclosure()))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tp++;\n\t\t\t\t\t\t\t\t\tenclosure_after = true;\n\t\t\t\t\t\t\t\t\tdencl = true;\n\n\t\t\t\t\t\t\t\t\t// Remember to replace them later on!\n\t\t\t\t\t\t\t\t\tif (is_escape) contains_escaped_enclosures = true; // remember\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (p >= length) next = p;\n\t\t\t\t\t\telse next = p + len_encl;\n\n                        if (log.isRowLevel()) log.logRowlevel(\"convert line to row\", \"End of enclosure @ position \" + p);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tencl_found = false;\n\t\t\t\t\t\tboolean found = false;\n\t\t\t\t\t\tint startpoint = from;\n\t\t\t\t\t\tint tries = 1;\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tnext = line.indexOf(inf.getSeparator(), startpoint);\n\n\t\t\t\t\t\t\t// See if this position is preceded by an escape character.\n\t\t\t\t\t\t\tif (len_esc > 0 && next - len_esc > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tString before = line.substring(next - len_esc, next);\n\n\t\t\t\t\t\t\t\tif (inf.getEscapeCharacter().equals(before))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// take the next separator, this one is escaped...\n\t\t\t\t\t\t\t\t\tstartpoint = next + 1; \n\t\t\t\t\t\t\t\t\ttries++;\n\t\t\t\t\t\t\t\t\tcontains_escaped_separators = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (!found && next >= 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (next == -1) next = length;\n\n\t\t\t\t\tif (encl_found)\n\t\t\t\t\t{\n\t\t\t\t\t\tpol = line.substring(from + len_encl, next - len_encl);\n                        if (log.isRowLevel()) log.logRowlevel(\"convert line to row\", \"Enclosed field found: [\" + pol + \"]\");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpol = line.substring(from, next);\n                        if (log.isRowLevel()) log.logRowlevel(\"convert line to row\", \"Normal field found: [\" + pol + \"]\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (dencl)\n\t\t\t\t\t{\n\t\t\t\t\t\tStringBuffer sbpol = new StringBuffer(pol);\n\t\t\t\t\t\tint idx = sbpol.indexOf(inf.getEnclosure() + inf.getEnclosure());\n\t\t\t\t\t\twhile (idx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsbpol.delete(idx, idx + inf.getEnclosure().length());\n\t\t\t\t\t\t\tidx = sbpol.indexOf(inf.getEnclosure() + inf.getEnclosure());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpol = sbpol.toString();\n\t\t\t\t\t}\n\n\t\t\t\t\t//\treplace the escaped enclosures with enclosures... \n\t\t\t\t\tif (contains_escaped_enclosures) \n\t\t\t\t\t{\n\t\t\t\t\t\tString replace = inf.getEscapeCharacter() + inf.getEnclosure();\n\t\t\t\t\t\tString replaceWith = inf.getEnclosure();\n\n\t\t\t\t\t\tpol = Const.replace(pol, replace, replaceWith);\n\t\t\t\t\t}\n\n\t\t\t\t\t//replace the escaped separators with separators... \n\t\t\t\t\tif (contains_escaped_separators) \n\t\t\t\t\t{\n\t\t\t\t\t\tString replace = inf.getEscapeCharacter() + inf.getSeparator();\n\t\t\t\t\t\tString replaceWith = inf.getSeparator();\n\n\t\t\t\t\t\tpol = Const.replace(pol, replace, replaceWith);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Now add pol to the strings found!\n\t\t\t\t\tstrings.add(pol);\n\n\t\t\t\t\tpos = next + 1;\n\t\t\t\t\tfieldnr++;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Fixed file format: Simply get the strings at the required positions...\n\t\t\t\tfor (int i = 0; i < inf.getInputFields().length; i++)\n\t\t\t\t{\n\t\t\t\t\tTextFileInputField field = inf.getInputFields()[i];\n\n\t\t\t\t\tint length = line.length();\n\n\t\t\t\t\tif (field.getPosition() + field.getLength() <= length)\n\t\t\t\t\t{\n\t\t\t\t\t\tstrings.add(line.substring(field.getPosition(), field.getPosition() + field.getLength()));\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (field.getPosition() < length)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrings.add(line.substring(field.getPosition()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstrings.add(\"\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tthrow new KettleException(\"Error converting line : \" + e.toString(), e);\n\t\t}\n\n\t\treturn strings;\n\t}","commit_id":"4413a46ad662b6b9b2cea0485a5f84c5feba22c4","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      // check all models in model \n      List<SModel> modelsToCheck = new ArrayList<SModel>();\n      modelsToCheck.addAll(((List<SModel>) MapSequence.fromMap(_params).get(\"models\")));\n      for (SModel model : ((List<SModel>) MapSequence.fromMap(_params).get(\"models\"))) {\n        String name = SNodeOperations.getModelLongName(model);\n        boolean isStub = SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(model));\n        for (SModel innerModel : ListSequence.fromList(model.getModule().getOwnModelDescriptors())) {\n          if (SNodeOperations.getModelLongName(innerModel).startsWith(name + \".\")) {\n            if (isStub == SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(innerModel))) {\n              modelsToCheck.add(innerModel);\n            }\n          }\n        }\n      }\n      if (modelsToCheck.size() > 1) {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModels(modelsToCheck, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      } else {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModel(modelsToCheck.get(0), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User's action execute method failed. Action:\" + \"CheckModel\", t);\n    }\n  }","id":78614,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      // check all models in model \n      List<SModel> modelsToCheck = new ArrayList<SModel>();\n      if (((List<SModel>) MapSequence.fromMap(_params).get(\"models\")) != null) {\n        modelsToCheck.addAll(((List<SModel>) MapSequence.fromMap(_params).get(\"models\")));\n      }\n      if (((SModel) MapSequence.fromMap(_params).get(\"model\")) != null && !(modelsToCheck.contains(((SModel) MapSequence.fromMap(_params).get(\"model\"))))) {\n        modelsToCheck.add(((SModel) MapSequence.fromMap(_params).get(\"model\")));\n      }\n      if (modelsToCheck.isEmpty()) {\n        return;\n      }\n\n      for (SModel model : modelsToCheck.toArray(new SModel[modelsToCheck.size()])) {\n        String name = SNodeOperations.getModelLongName(model);\n        boolean isStub = SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(model));\n        for (SModel innerModel : ListSequence.fromList(model.getModule().getOwnModelDescriptors())) {\n          if (SNodeOperations.getModelLongName(innerModel).startsWith(name + \".\")) {\n            if (isStub == SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(innerModel))) {\n              modelsToCheck.add(innerModel);\n            }\n          }\n        }\n      }\n      if (modelsToCheck.size() > 1) {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModels(modelsToCheck, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      } else {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModel(modelsToCheck.get(0), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User's action execute method failed. Action:\" + \"CheckModel\", t);\n    }\n  }","commit_id":"e275cc9a9172b9bf5f0e3679d4b71fed9683e041","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        String whatToCheck = \"Model\";\n        if (((List<SModel>) MapSequence.fromMap(_params).get(\"models\")).size() > 1) {\n          whatToCheck = ((List<SModel>) MapSequence.fromMap(_params).get(\"models\")).size() + \" Models\";\n        }\n        event.getPresentation().setText(\"Check \" + whatToCheck);\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User's action doUpdate method failed. Action:\" + \"CheckModel\", t);\n      this.disable(event.getPresentation());\n    }\n  }","id":78615,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        List<SModel> modelsToCheck = new ArrayList<SModel>();\n        if (((List<SModel>) MapSequence.fromMap(_params).get(\"models\")) != null) {\n          modelsToCheck.addAll(((List<SModel>) MapSequence.fromMap(_params).get(\"models\")));\n        }\n        if (((SModel) MapSequence.fromMap(_params).get(\"model\")) != null && !(modelsToCheck.contains(((SModel) MapSequence.fromMap(_params).get(\"model\"))))) {\n          modelsToCheck.add(((SModel) MapSequence.fromMap(_params).get(\"model\")));\n        }\n\n        String whatToCheck = \"Model\";\n        if (modelsToCheck.size() > 1) {\n          whatToCheck = modelsToCheck.size() + \" Models\";\n        }\n\n        event.getPresentation().setText(\"Check \" + whatToCheck);\n        event.getPresentation().setEnabled(!(modelsToCheck.isEmpty()));\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User's action doUpdate method failed. Action:\" + \"CheckModel\", t);\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"e275cc9a9172b9bf5f0e3679d4b71fed9683e041","url":"https://github.com/JetBrains/MPS"},{"original_method":"public CheckModel_Action() {\n    super(\"Check Model\", \"Check model for unresolved references and typesystem rules\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","id":78616,"modified_method":"public CheckModel_Action() {\n    super(\"Check Model\", \"Check model for unresolved references and typesystem rules\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n    this.addPlace(null);\n  }","commit_id":"e275cc9a9172b9bf5f0e3679d4b71fed9683e041","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"model\", event.getData(MPSCommonDataKeys.MODEL));\n    if (MapSequence.fromMap(_params).get(\"model\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"models\", event.getData(MPSCommonDataKeys.MODELS));\n    if (MapSequence.fromMap(_params).get(\"models\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(PlatformDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"operationContext\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"operationContext\") == null) {\n      return false;\n    }\n    return true;\n  }","id":78617,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"model\", event.getData(MPSCommonDataKeys.CONTEXT_MODEL));\n    MapSequence.fromMap(_params).put(\"models\", event.getData(MPSCommonDataKeys.MODELS));\n    MapSequence.fromMap(_params).put(\"project\", event.getData(PlatformDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"operationContext\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"operationContext\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"e275cc9a9172b9bf5f0e3679d4b71fed9683e041","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        String whatToCheck = ((IModule) MapSequence.fromMap(_params).get(\"module\")).getClass().getSimpleName();\n        if (((List<IModule>) MapSequence.fromMap(_params).get(\"modules\")).size() > 1) {\n          whatToCheck = ((List<IModule>) MapSequence.fromMap(_params).get(\"modules\")).size() + \" Modules\";\n        }\n        event.getPresentation().setText(\"Check \" + whatToCheck);\n        event.getPresentation().setDescription(\"Check \" + whatToCheck.toLowerCase() + \" for structure and typesystem rules\");\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User's action doUpdate method failed. Action:\" + \"CheckModule\", t);\n      this.disable(event.getPresentation());\n    }\n  }","id":78618,"modified_method":"public void doUpdate(@NotNull AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      {\n        List<IModule> modulesToCheck = new ArrayList<IModule>();\n        if (((List<IModule>) MapSequence.fromMap(_params).get(\"modules\")) != null) {\n          modulesToCheck.addAll(((List<IModule>) MapSequence.fromMap(_params).get(\"modules\")));\n        }\n        if (((IModule) MapSequence.fromMap(_params).get(\"module\")) != null && !(modulesToCheck.contains(((IModule) MapSequence.fromMap(_params).get(\"module\"))))) {\n          modulesToCheck.add(((IModule) MapSequence.fromMap(_params).get(\"module\")));\n        }\n\n        String whatToCheck = \"Module\";\n\n        if (modulesToCheck.size() == 1) {\n          whatToCheck = modulesToCheck.get(0).getClass().getSimpleName();\n        } else if (modulesToCheck.size() > 1) {\n          whatToCheck = modulesToCheck.size() + \" Modules\";\n        }\n\n        event.getPresentation().setText(\"Check \" + whatToCheck);\n        event.getPresentation().setDescription(\"Check \" + whatToCheck.toLowerCase() + \" for structure and typesystem rules\");\n        event.getPresentation().setEnabled(!(modulesToCheck.isEmpty()));\n\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User's action doUpdate method failed. Action:\" + \"CheckModule\", t);\n      this.disable(event.getPresentation());\n    }\n  }","commit_id":"e275cc9a9172b9bf5f0e3679d4b71fed9683e041","url":"https://github.com/JetBrains/MPS"},{"original_method":"public CheckModule_Action() {\n    super(\"Check [Module]\", \"Check [module] for structure and typesystem rules\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","id":78619,"modified_method":"public CheckModule_Action() {\n    super(\"Check [Module]\", \"Check [module] for structure and typesystem rules\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n    this.addPlace(null);\n  }","commit_id":"e275cc9a9172b9bf5f0e3679d4b71fed9683e041","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      if (((List<IModule>) MapSequence.fromMap(_params).get(\"modules\")).size() > 1) {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModules(ListSequence.fromListWithValues(new ArrayList<SModule>(), (Iterable<IModule>) ((List<IModule>) MapSequence.fromMap(_params).get(\"modules\"))), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      } else {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModule(((IModule) MapSequence.fromMap(_params).get(\"module\")), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User's action execute method failed. Action:\" + \"CheckModule\", t);\n    }\n  }","id":78620,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<IModule> modulesToCheck = new ArrayList<IModule>();\n      if (((List<IModule>) MapSequence.fromMap(_params).get(\"modules\")) != null) {\n        modulesToCheck.addAll(((List<IModule>) MapSequence.fromMap(_params).get(\"modules\")));\n      }\n      if (((IModule) MapSequence.fromMap(_params).get(\"module\")) != null && !(modulesToCheck.contains(((IModule) MapSequence.fromMap(_params).get(\"module\"))))) {\n        modulesToCheck.add(((IModule) MapSequence.fromMap(_params).get(\"module\")));\n      }\n\n      if (modulesToCheck.isEmpty()) {\n        return;\n      }\n\n      if (modulesToCheck.size() > 1) {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModules(ListSequence.fromListWithValues(new ArrayList<SModule>(), (Iterable<IModule>) modulesToCheck), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      } else {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModule(modulesToCheck.get(0), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      }\n    } catch (Throwable t) {\n      LOG.error(\"User's action execute method failed. Action:\" + \"CheckModule\", t);\n    }\n  }","commit_id":"e275cc9a9172b9bf5f0e3679d4b71fed9683e041","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"module\", event.getData(MPSCommonDataKeys.MODULE));\n    if (MapSequence.fromMap(_params).get(\"module\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"modules\", event.getData(MPSDataKeys.MODULES));\n    if (MapSequence.fromMap(_params).get(\"modules\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(PlatformDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"operationContext\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"operationContext\") == null) {\n      return false;\n    }\n    return true;\n  }","id":78621,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"module\", event.getData(MPSCommonDataKeys.CONTEXT_MODULE));\n    MapSequence.fromMap(_params).put(\"modules\", event.getData(MPSDataKeys.MODULES));\n    MapSequence.fromMap(_params).put(\"project\", event.getData(PlatformDataKeys.PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"operationContext\", event.getData(MPSCommonDataKeys.OPERATION_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"operationContext\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"e275cc9a9172b9bf5f0e3679d4b71fed9683e041","url":"https://github.com/JetBrains/MPS"},{"original_method":"public CheckProject_Action() {\n    super(\"Check Project\", \"Check project for unresolved references and typesystem rules\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n  }","id":78622,"modified_method":"public CheckProject_Action() {\n    super(\"Check Project\", \"Check project for unresolved references and typesystem rules\", ICON);\n    this.setIsAlwaysVisible(false);\n    this.setExecuteOutsideCommand(true);\n    this.addPlace(null);\n  }","commit_id":"e275cc9a9172b9bf5f0e3679d4b71fed9683e041","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Results search(RuleQuery query, QueryOptions options) {\n\n    // Build main query (search based)\n    QueryBuilder qb;\n    if (query.getQueryText() != null && !query.getQueryText().isEmpty()) {\n      qb = QueryBuilders.multiMatchQuery(query.getQueryText(),\n        RuleField.NAME.key(),\n        RuleField.NAME.key()+\".search\",\n        RuleField.DESCRIPTION.key(),\n        RuleField.KEY.key(),\n        RuleField.LANGUAGE.key(),\n        RuleField.TAGS.key());\n    } else {\n      qb = QueryBuilders.matchAllQuery();\n    }\n\n    // Build main filter (match based)\n    BoolFilterBuilder fb = FilterBuilders.boolFilter();\n\n    this.addTermFilter(RuleField.LANGUAGE.key(), query.getLanguages(), fb);\n    this.addTermFilter(RuleField.REPOSITORY.key(), query.getRepositories(), fb);\n    this.addTermFilter(RuleField.SEVERITY.key(), query.getSeverities(), fb);\n    this.addTermFilter(RuleField.KEY.key(), query.getKey(), fb);\n\n\n    QueryBuilder mainQuery;\n\n    if((query.getLanguages() != null && !query.getLanguages().isEmpty()) ||\n      (query.getRepositories() != null && !query.getRepositories().isEmpty()) ||\n      (query.getSeverities() != null && !query.getSeverities().isEmpty()) ||\n      (query.getKey() != null && !query.getKey().isEmpty())) {\n\n      mainQuery = QueryBuilders.filteredQuery(qb, fb);\n    } else {\n      mainQuery = qb;\n    }\n\n    //Create ES query Object;\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(this.getIndexName())\n      .setQuery(mainQuery)\n      .addFields(options.getFieldsToReturn().toArray(new String[options.getFieldsToReturn().size()]));\n\n\n    SearchResponse esResult = esSearch.get();\n\n\n    Results results = new Results()\n      .setTotal((int) esResult.getHits().totalHits())\n      .setTime(esResult.getTookInMillis());\n\n    for (SearchHit esHit : esResult.getHits().getHits()) {\n      Hit hit = new Hit(esHit.score());\n      for (Map.Entry<String, SearchHitField> entry : esHit.fields().entrySet()) {\n        if (entry.getValue().getValues().size() > 1) {\n          hit.getFields().put(entry.getKey(), entry.getValue().getValues());\n        } else {\n          hit.getFields().put(entry.getKey(), entry.getValue().getValue());\n        }\n      }\n      results.getHits().add(hit);\n    }\n\n    return results;\n  }","id":78623,"modified_method":"public Results search(RuleQuery query, QueryOptions options) {\n\n    // Build main query (search based)\n    QueryBuilder qb;\n    if (query.getQueryText() != null && !query.getQueryText().isEmpty()) {\n      qb = QueryBuilders.multiMatchQuery(query.getQueryText(),\n        RuleField.NAME.key(),\n        RuleField.NAME.key()+\".search\",\n        RuleField.DESCRIPTION.key(),\n        RuleField.KEY.key(),\n        RuleField.LANGUAGE.key(),\n        RuleField.TAGS.key());\n    } else {\n      qb = QueryBuilders.matchAllQuery();\n    }\n\n    // Build main filter (match based)\n    BoolFilterBuilder fb = FilterBuilders.boolFilter();\n\n    this.addTermFilter(RuleField.LANGUAGE.key(), query.getLanguages(), fb);\n    this.addTermFilter(RuleField.REPOSITORY.key(), query.getRepositories(), fb);\n    this.addTermFilter(RuleField.SEVERITY.key(), query.getSeverities(), fb);\n    this.addTermFilter(RuleField.KEY.key(), query.getKey(), fb);\n\n\n    QueryBuilder mainQuery;\n\n    if((query.getLanguages() != null && !query.getLanguages().isEmpty()) ||\n      (query.getRepositories() != null && !query.getRepositories().isEmpty()) ||\n      (query.getSeverities() != null && !query.getSeverities().isEmpty()) ||\n      (query.getKey() != null && !query.getKey().isEmpty())) {\n\n      mainQuery = QueryBuilders.filteredQuery(qb, fb);\n    } else {\n      mainQuery = qb;\n    }\n\n    //GetFields to return (defaults to *)\n    Set<String> fields = new HashSet<String>();\n    fields.addAll(options.getFieldsToReturn());\n    fields.add(RuleField.KEY.key());\n\n    //Create ES query Object;\n    SearchRequestBuilder esSearch = getClient()\n      .prepareSearch(this.getIndexName())\n      .setQuery(mainQuery)\n      .addFields(fields.toArray(new String[fields.size()]));\n\n\n    SearchResponse esResult = esSearch.get();\n\n\n    Results results = new Results()\n      .setTotal((int) esResult.getHits().totalHits())\n      .setTime(esResult.getTookInMillis());\n\n    for (SearchHit esHit : esResult.getHits().getHits()) {\n      Hit hit = new Hit(esHit.score());\n      for (Map.Entry<String, SearchHitField> entry : esHit.fields().entrySet()) {\n        if (entry.getValue().getValues().size() > 1) {\n          hit.getFields().put(entry.getKey(), entry.getValue().getValues());\n        } else {\n          hit.getFields().put(entry.getKey(), entry.getValue().getValue());\n        }\n      }\n      results.getHits().add(hit);\n    }\n\n    return results;\n  }","commit_id":"d50cbc6b72ab364a2c8dc708c5e3473db7a471b0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n\tpublic void checkPortlet(Portlet portlet) throws PortalException {\n\t\tlong companyId = portlet.getCompanyId();\n\t\tString name = portlet.getPortletId();\n\n\t\tif (resourcePermissionLocalService.getResourcePermissionsCount(\n\t\t\t\tcompanyId, name, ResourceConstants.SCOPE_INDIVIDUAL, name) < 1) {\n\n\t\t\tresourceLocalService.addResources(\n\t\t\t\tcompanyId, 0, 0, name, name, true, false, false);\n\t\t}\n\n\t\tif (portlet.isSystem()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString[] roleNames = portlet.getRolesArray();\n\n\t\tif (roleNames.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tint scope = ResourceConstants.SCOPE_COMPANY;\n\t\tString primKey = String.valueOf(companyId);\n\t\tString actionId = ActionKeys.ADD_TO_PAGE;\n\n\t\tList<String> actionIds = ResourceActionsUtil.getPortletResourceActions(\n\t\t\tname);\n\n\t\tif (actionIds.contains(actionId)) {\n\t\t\tfor (String roleName : roleNames) {\n\t\t\t\tRole role = roleLocalService.getRole(companyId, roleName);\n\n\t\t\t\tresourcePermissionLocalService.addResourcePermission(\n\t\t\t\t\tcompanyId, name, scope, primKey, role.getRoleId(),\n\t\t\t\t\tactionId);\n\t\t\t}\n\t\t}\n\n\t\tupdatePortlet(\n\t\t\tcompanyId, portlet.getPortletId(), StringPool.BLANK,\n\t\t\tportlet.isActive());\n\t}","id":78624,"modified_method":"@Override\n\tpublic void checkPortlet(Portlet portlet) throws PortalException {\n\t\tlong companyId = portlet.getCompanyId();\n\t\tString name = portlet.getPortletId();\n\n\t\tint resourcePermissionsCount =\n\t\t\tresourcePermissionLocalService.getResourcePermissionsCount(\n\t\t\t\tcompanyId, name, ResourceConstants.SCOPE_INDIVIDUAL, name);\n\n\t\tif (resourcePermissionsCount == 0) {\n\t\t\tresourceLocalService.addResources(\n\t\t\t\tcompanyId, 0, 0, name, name, true, false, false);\n\t\t}\n\n\t\tif (portlet.isSystem()) {\n\t\t\treturn;\n\t\t}\n\n\t\tString[] roleNames = portlet.getRolesArray();\n\n\t\tif (roleNames.length == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tint scope = ResourceConstants.SCOPE_COMPANY;\n\t\tString primKey = String.valueOf(companyId);\n\t\tString actionId = ActionKeys.ADD_TO_PAGE;\n\n\t\tList<String> actionIds = ResourceActionsUtil.getPortletResourceActions(\n\t\t\tname);\n\n\t\tif (actionIds.contains(actionId)) {\n\t\t\tfor (String roleName : roleNames) {\n\t\t\t\tRole role = roleLocalService.getRole(companyId, roleName);\n\n\t\t\t\tresourcePermissionLocalService.addResourcePermission(\n\t\t\t\t\tcompanyId, name, scope, primKey, role.getRoleId(),\n\t\t\t\t\tactionId);\n\t\t\t}\n\t\t}\n\n\t\tupdatePortlet(\n\t\t\tcompanyId, portlet.getPortletId(), StringPool.BLANK,\n\t\t\tportlet.isActive());\n\t}","commit_id":"1a9b2b5bb5a509591efebf962b213bdea8a7c60e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tStringBundler sb = new StringBundler();\n\n\t\tsb.append(\"{companyid=\");\n\t\tsb.append(_companyId);\n\t\tsb.append(\", name=\");\n\t\tsb.append(_name);\n\t\tsb.append(\", scope=\");\n\t\tsb.append(_scope);\n\t\tsb.append(\", primKey=\");\n\t\tsb.append(_primKey);\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","id":78625,"modified_method":"@Override\n\tpublic String toString() {\n\t\tStringBundler sb = new StringBundler(9);\n\n\t\tsb.append(\"{companyid=\");\n\t\tsb.append(_companyId);\n\t\tsb.append(\", name=\");\n\t\tsb.append(_name);\n\t\tsb.append(\", primKey=\");\n\t\tsb.append(_primKey);\n\t\tsb.append(\", scope=\");\n\t\tsb.append(_scope);\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"1a9b2b5bb5a509591efebf962b213bdea8a7c60e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean contains(\n\t\t\tPermissionChecker permissionChecker, long groupId, Layout layout,\n\t\t\tString portletId, String actionId, boolean strict,\n\t\t\tboolean checkStagingPermission)\n\t\tthrows PortalException {\n\n\t\tString name = null;\n\t\tString resourcePermissionPrimKey = null;\n\n\t\tif (layout == null) {\n\t\t\tname = portletId;\n\t\t\tresourcePermissionPrimKey = portletId;\n\n\t\t\treturn permissionChecker.hasPermission(\n\t\t\t\tgroupId, name, resourcePermissionPrimKey, actionId);\n\t\t}\n\n\t\tif ((layout instanceof VirtualLayout) && layout.isTypeControlPanel()) {\n\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\tlayout = virtualLayout.getSourceLayout();\n\t\t}\n\n\t\tif (!actionId.equals(ActionKeys.VIEW) &&\n\t\t\t(layout instanceof VirtualLayout)) {\n\n\t\t\tif (actionId.equals(ActionKeys.ADD_TO_PAGE)) {\n\t\t\t\treturn hasAddToPagePermission(\n\t\t\t\t\tpermissionChecker, layout, portletId, actionId);\n\t\t\t}\n\n\t\t\treturn hasCustomizePermission(\n\t\t\t\tpermissionChecker, layout, portletId, actionId);\n\t\t}\n\n\t\tGroup group = layout.getGroup();\n\n\t\tif (!group.isLayoutSetPrototype() &&\n\t\t\tactionId.equals(ActionKeys.CONFIGURATION) &&\n\t\t\t!SitesUtil.isLayoutUpdateable(layout)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tgroupId = layout.getGroupId();\n\n\t\tString rootPortletId = PortletConstants.getRootPortletId(portletId);\n\n\t\tif (checkStagingPermission) {\n\t\t\tBoolean hasPermission = StagingPermissionUtil.hasPermission(\n\t\t\t\tpermissionChecker, groupId, rootPortletId, groupId,\n\t\t\t\trootPortletId, actionId);\n\n\t\t\tif (hasPermission != null) {\n\t\t\t\treturn hasPermission.booleanValue();\n\t\t\t}\n\t\t}\n\n\t\tif (group.isControlPanel() && actionId.equals(ActionKeys.VIEW)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tresourcePermissionPrimKey = getPrimaryKey(layout.getPlid(), portletId);\n\n\t\tboolean useDefaultPortletPermissions = false;\n\n\t\tif (ResourcePermissionLocalServiceUtil.getResourcePermissionsCount(\n\t\t\t\tpermissionChecker.getCompanyId(), rootPortletId,\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\tresourcePermissionPrimKey) == 0) {\n\n\t\t\tuseDefaultPortletPermissions = true;\n\t\t}\n\n\t\tif (useDefaultPortletPermissions) {\n\t\t\tresourcePermissionPrimKey = rootPortletId;\n\t\t}\n\n\t\tif (strict) {\n\t\t\treturn permissionChecker.hasPermission(\n\t\t\t\tgroupId, rootPortletId, resourcePermissionPrimKey, actionId);\n\t\t}\n\n\t\tif (hasConfigurePermission(\n\t\t\t\tpermissionChecker, layout, portletId, actionId) ||\n\t\t\thasCustomizePermission(\n\t\t\t\tpermissionChecker, layout, portletId, actionId)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tgroupId, rootPortletId, resourcePermissionPrimKey, actionId);\n\t}","id":78626,"modified_method":"@Override\n\tpublic boolean contains(\n\t\t\tPermissionChecker permissionChecker, long groupId, Layout layout,\n\t\t\tString portletId, String actionId, boolean strict,\n\t\t\tboolean checkStagingPermission)\n\t\tthrows PortalException {\n\n\t\tString name = null;\n\t\tString resourcePermissionPrimKey = null;\n\n\t\tif (layout == null) {\n\t\t\tname = portletId;\n\t\t\tresourcePermissionPrimKey = portletId;\n\n\t\t\treturn permissionChecker.hasPermission(\n\t\t\t\tgroupId, name, resourcePermissionPrimKey, actionId);\n\t\t}\n\n\t\tif ((layout instanceof VirtualLayout) && layout.isTypeControlPanel()) {\n\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\tlayout = virtualLayout.getSourceLayout();\n\t\t}\n\n\t\tif (!actionId.equals(ActionKeys.VIEW) &&\n\t\t\t(layout instanceof VirtualLayout)) {\n\n\t\t\tif (actionId.equals(ActionKeys.ADD_TO_PAGE)) {\n\t\t\t\treturn hasAddToPagePermission(\n\t\t\t\t\tpermissionChecker, layout, portletId, actionId);\n\t\t\t}\n\n\t\t\treturn hasCustomizePermission(\n\t\t\t\tpermissionChecker, layout, portletId, actionId);\n\t\t}\n\n\t\tGroup group = layout.getGroup();\n\n\t\tif (!group.isLayoutSetPrototype() &&\n\t\t\tactionId.equals(ActionKeys.CONFIGURATION) &&\n\t\t\t!SitesUtil.isLayoutUpdateable(layout)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tgroupId = layout.getGroupId();\n\n\t\tString rootPortletId = PortletConstants.getRootPortletId(portletId);\n\n\t\tif (checkStagingPermission) {\n\t\t\tBoolean hasPermission = StagingPermissionUtil.hasPermission(\n\t\t\t\tpermissionChecker, groupId, rootPortletId, groupId,\n\t\t\t\trootPortletId, actionId);\n\n\t\t\tif (hasPermission != null) {\n\t\t\t\treturn hasPermission.booleanValue();\n\t\t\t}\n\t\t}\n\n\t\tif (group.isControlPanel() && actionId.equals(ActionKeys.VIEW)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tresourcePermissionPrimKey = getPrimaryKey(layout.getPlid(), portletId);\n\n\t\tboolean useDefaultPortletPermissions = false;\n\t\t\n\t\tint count =\n\t\t\tResourcePermissionLocalServiceUtil.getResourcePermissionsCount(\n\t\t\t\tpermissionChecker.getCompanyId(), rootPortletId,\n\t\t\t\tResourceConstants.SCOPE_INDIVIDUAL,\n\t\t\t\tresourcePermissionPrimKey);\n\n\t\tif (count == 0) {\n\t\t\tuseDefaultPortletPermissions = true;\n\t\t}\n\n\t\tif (useDefaultPortletPermissions) {\n\t\t\tresourcePermissionPrimKey = rootPortletId;\n\t\t}\n\n\t\tif (strict) {\n\t\t\treturn permissionChecker.hasPermission(\n\t\t\t\tgroupId, rootPortletId, resourcePermissionPrimKey, actionId);\n\t\t}\n\n\t\tif (hasConfigurePermission(\n\t\t\t\tpermissionChecker, layout, portletId, actionId) ||\n\t\t\thasCustomizePermission(\n\t\t\t\tpermissionChecker, layout, portletId, actionId)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tgroupId, rootPortletId, resourcePermissionPrimKey, actionId);\n\t}","commit_id":"29dda21deb4e78d930da009c5370986621e1fc7e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Criteria createServiceCriteriaForNodeInCategory(int nodeId, RTCCategory category) {\n\t\tCriteriaBuilder builder = new CriteriaBuilder(OnmsMonitoredService.class)\n\t\t.alias(\"ipInterface\", \"ipInterface\")\n\t\t.alias(\"ipInterface.node\", \"node\")\n\t\t.eq(\"node.id\", nodeId); // Add an extra restriction on the node ID\n\n\t\tSet<Integer> nodes = RTCUtils.getNodeIdsForCategory(m_filterDao, category);\n\t\tif (nodes != null && nodes.size() > 0) {\n\t\t\tbuilder.in(\"node.id\", nodes);\n\t\t}\n\n\t\tList<String> services = category.getServiceCollection();\n\t\tif (services != null && services.size() > 0) {\n\t\t\tbuilder.alias(\"serviceType\", \"serviceType\")\n\t\t\t.in(\"serviceType.name\", category.getServiceCollection());\n\t\t}\n\n\t\treturn builder.toCriteria();\n\t}","id":78627,"modified_method":"private Criteria createServiceCriteriaForNodeInCategory(int nodeId, RTCCategory category) {\n\t\tCriteriaBuilder builder = new CriteriaBuilder(OnmsMonitoredService.class)\n\t\t.alias(\"ipInterface\", \"ipInterface\")\n\t\t.alias(\"ipInterface.node\", \"node\")\n\t\t.eq(\"node.id\", nodeId); // Add an extra restriction on the node ID\n\n\t\t/*\n\t\t * NOTE: This assumes that the category contains the current list of nodes.\n\t\t * This value is added as a side-effect of calling {@link #getNodes(RTCCategory)}.\n\t\t */\n\t\tCollection<Integer> nodes = category.getNodes();\n\t\tif (nodes != null && nodes.size() > 0) {\n\t\t\tbuilder.in(\"node.id\", nodes);\n\t\t}\n\n\t\tList<String> services = category.getServiceCollection();\n\t\tif (services != null && services.size() > 0) {\n\t\t\tbuilder.alias(\"serviceType\", \"serviceType\")\n\t\t\t.in(\"serviceType.name\", category.getServiceCollection());\n\t\t}\n\n\t\treturn builder.toCriteria();\n\t}","commit_id":"2973adac8a2882bc9e6cbbc2ea8bf8071a4c8f73","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n\tpublic Collection<Integer> getNodes(RTCCategory category) {\n\t\treturn RTCUtils.getNodeIdsForCategory(m_filterDao,  category);\n\t}","id":78628,"modified_method":"@Override\n\tpublic Collection<Integer> getNodes(RTCCategory category) {\n\t\t// Refresh the list of nodes contained inside the RTCCategory\n\t\tcategory.clearNodes();\n\t\tcategory.addAllNodes(RTCUtils.getNodeIdsForCategory(m_filterDao,  category));\n\t\treturn category.getNodes();\n\t}","commit_id":"2973adac8a2882bc9e6cbbc2ea8bf8071a4c8f73","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Update the categories for a node. This method will update the categories\n     * for all interfaces on a node.\n     *\n     * @param nodeid\n     *            the nodeid on which SNMP service was added\n     * @throws java.sql.SQLException\n     *             if the database read fails due to an SQL error\n     * @throws org.opennms.netmgt.filter.FilterParseException\n     *             if filtering the data against the category rule fails due to\n     *             the rule being incorrect\n     * @throws org.opennms.netmgt.rtc.RTCException\n     *             if the database read or filtering the data against the\n     *             category rule fails for some reason\n     */\n    public synchronized void rtcNodeRescan(int nodeid) throws SQLException, FilterParseException, RTCException {\n    \t\n    \tfor (Iterator<RTCCategory> it = m_categories.values().iterator(); it.hasNext();) {\n\t\t\tRTCCategory cat = it.next();\n\t\t\tcat.deleteNode(nodeid);\n\t\t}\n    \t\n    \tm_map.deleteNode(nodeid);\n    \t\n    \tpopulateNodesFromDB(\"ifsvc.nodeid = ?\", new Object[] { Long.valueOf(nodeid) });\n    \t\n    }","id":78629,"modified_method":"/**\n     * Update the categories for a node. This method will update the categories\n     * for all interfaces on a node.\n     *\n     * @param nodeid\n     *            the nodeid on which SNMP service was added\n     * @throws java.sql.SQLException\n     *             if the database read fails due to an SQL error\n     * @throws org.opennms.netmgt.filter.FilterParseException\n     *             if filtering the data against the category rule fails due to\n     *             the rule being incorrect\n     * @throws org.opennms.netmgt.rtc.RTCException\n     *             if the database read or filtering the data against the\n     *             category rule fails for some reason\n     */\n    public synchronized void rtcNodeRescan(int nodeid) throws SQLException, FilterParseException, RTCException {\n    \t\n    \tfor (RTCCategory cat : m_categories.values()) {\n\t\t\tcat.deleteNode(nodeid);\n\t\t}\n    \t\n    \tm_map.deleteNode(nodeid);\n    \t\n    \tpopulateNodesFromDB(\"ifsvc.nodeid = ?\", new Object[] { Long.valueOf(nodeid) });\n    \t\n    }","commit_id":"2973adac8a2882bc9e6cbbc2ea8bf8071a4c8f73","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Reparent an interface. This effectively means updating the nodelist of\n     * the categories and the map\n     *\n     * Use the ip/oldnodeid combination to get all nodes that will be affected -\n     * for each of these nodes, remove the old entry and add a new one with new\n     * keys to the map\n     *\n     * <em>Note:<\/em> Each of these nodes could belong to more than one\n     * category. However, category rule evaluation is done based ONLY on the IP -\n     * therefore changing the nodeID on the node should update the categories\n     * appropriately\n     *\n     * @param ip\n     *            the interface to reparent\n     * @param oldNodeId\n     *            the node that the IP belonged to earlier\n     * @param newNodeId\n     *            the node that the IP now belongs to\n     */\n    public synchronized void interfaceReparented(InetAddress ip, int oldNodeId, int newNodeId) {\n        // get all RTCNodes with the IP/old node ID\n    \tList<RTCNode> nodesList = m_map.getRTCNodes(oldNodeId, ip);\n        ListIterator<RTCNode> listIter = new LinkedList<RTCNode>(nodesList).listIterator();\n        while (listIter.hasNext()) {\n            RTCNode rtcN = listIter.next();\n\n            // remove the node with the old node id from the map\n            m_map.delete(rtcN);\n\n            // change the node ID on the RTCNode\n            rtcN.setNodeID(newNodeId);\n\n            // now add the node with the new node ID\n            m_map.add(rtcN);\n\n            // remove old node ID from the categories it belonged to\n            // and the new node ID\n            Iterator<String> catIter = rtcN.getCategories().listIterator();\n            while (catIter.hasNext()) {\n                String catlabel = catIter.next();\n\n                RTCCategory rtcCat = m_categories.get(catlabel);\n                rtcCat.deleteNode(oldNodeId);\n                rtcCat.addNode(newNodeId);\n            }\n\n        }\n    }","id":78630,"modified_method":"/**\n     * Reparent an interface. This effectively means updating the nodelist of\n     * the categories and the map\n     *\n     * Use the ip/oldnodeid combination to get all nodes that will be affected -\n     * for each of these nodes, remove the old entry and add a new one with new\n     * keys to the map\n     *\n     * <em>Note:<\/em> Each of these nodes could belong to more than one\n     * category. However, category rule evaluation is done based ONLY on the IP -\n     * therefore changing the nodeID on the node should update the categories\n     * appropriately\n     *\n     * @param ip\n     *            the interface to reparent\n     * @param oldNodeId\n     *            the node that the IP belonged to earlier\n     * @param newNodeId\n     *            the node that the IP now belongs to\n     */\n    public synchronized void interfaceReparented(InetAddress ip, int oldNodeId, int newNodeId) {\n        // get all RTCNodes with the IP/old node ID\n        for (RTCNode rtcN : m_map.getRTCNodes(oldNodeId, ip)) {\n\n            // remove the node with the old node id from the map\n            m_map.delete(rtcN);\n\n            // change the node ID on the RTCNode\n            rtcN.setNodeID(newNodeId);\n\n            // now add the node with the new node ID\n            m_map.add(rtcN);\n\n            // remove old node ID from the categories it belonged to\n            // and the new node ID\n            for (String catlabel : rtcN.getCategories()) {\n                RTCCategory rtcCat = m_categories.get(catlabel);\n                rtcCat.deleteNode(oldNodeId);\n                rtcCat.addNode(newNodeId);\n            }\n\n        }\n    }","commit_id":"2973adac8a2882bc9e6cbbc2ea8bf8071a4c8f73","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Remove node from the map and the categories on a 'serviceDeleted' event.\n     *\n     * @param nodeid\n     *            the nodeid on which service was deleted\n     * @param ip\n     *            the ip on which service was deleted\n     * @param svcName\n     *            the service that was deleted\n     */\n    public synchronized void serviceDeleted(int nodeid, InetAddress ip, String svcName) {\n        // create lookup key\n        RTCNodeKey key = new RTCNodeKey(nodeid, ip, svcName);\n\n        // lookup the node\n        RTCNode rtcN = m_map.getRTCNode(key);\n        if (rtcN == null) {\n            LOG.warn(\"Received a {} event for an unknown node: {}\", EventConstants.SERVICE_DELETED_EVENT_UEI, key.toString());\n\n            return;\n        }\n\n        //\n        // Go through from all the categories this node belongs to\n        // and delete the service\n        //\n        List<String> categories = rtcN.getCategories();\n        ListIterator<String> catIter = categories.listIterator();\n        while (catIter.hasNext()) {\n            String catlabel = (String) catIter.next();\n\n            RTCCategory cat = (RTCCategory) m_categories.get(catlabel);\n\n            // get nodes in this category\n            List<Integer> catNodes = cat.getNodes();\n\n            // check if the category contains this node\n            Long tmpNodeid = Long.valueOf(rtcN.getNodeID());\n            int nIndex = catNodes.indexOf(tmpNodeid);\n            if (nIndex != -1) {\n                // remove from the category if it is the only service left.\n                if (m_map.getServiceCount(nodeid, catlabel) == 1) {\n                    catNodes.remove(nIndex);\n                    LOG.info(\"Removing node from category: {}\", catlabel);\n                }\n\n                // let the node know that this category is out\n                catIter.remove();\n            }\n        }\n\n        // finally remove from map\n        \n        m_map.delete(rtcN);\n\n    }","id":78631,"modified_method":"/**\n     * Remove node from the map and the categories on a 'serviceDeleted' event.\n     *\n     * @param nodeid\n     *            the nodeid on which service was deleted\n     * @param ip\n     *            the ip on which service was deleted\n     * @param svcName\n     *            the service that was deleted\n     */\n    public synchronized void serviceDeleted(int nodeid, InetAddress ip, String svcName) {\n        // create lookup key\n        RTCNodeKey key = new RTCNodeKey(nodeid, ip, svcName);\n\n        // lookup the node\n        RTCNode rtcN = m_map.getRTCNode(key);\n        if (rtcN == null) {\n            LOG.warn(\"Received a {} event for an unknown node: {}\", EventConstants.SERVICE_DELETED_EVENT_UEI, key.toString());\n\n            return;\n        }\n\n        //\n        // Go through from all the categories this node belongs to\n        // and delete the service\n        //\n        List<String> categories = rtcN.getCategories();\n        ListIterator<String> catIter = categories.listIterator();\n        while (catIter.hasNext()) {\n            String catlabel = (String) catIter.next();\n\n            RTCCategory cat = (RTCCategory) m_categories.get(catlabel);\n\n            // get nodes in this category\n            List<Integer> catNodes = cat.getNodes();\n\n            // check if the category contains this node\n            int nIndex = catNodes.indexOf(rtcN.getNodeID());\n            if (nIndex != -1) {\n                // remove from the category if it is the only service left.\n                if (m_map.getServiceCount(nodeid, catlabel) == 1) {\n                    catNodes.remove(nIndex);\n                    LOG.info(\"Removing node from category: {}\", catlabel);\n                }\n\n                // let the node know that this category is out\n                catIter.remove();\n            }\n        }\n\n        // finally remove from map\n        \n        m_map.delete(rtcN);\n\n    }","commit_id":"2973adac8a2882bc9e6cbbc2ea8bf8071a4c8f73","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Set<PortletLifecycleState> getAllowedLifecycleStates(IPerson person, List<JsonEntityBean> categories) {\n        Set<PortletLifecycleState> states = new TreeSet<PortletLifecycleState>();\n        if (hasLifecyclePermission(person, PortletLifecycleState.MAINTENANCE, categories)) {\n            states.add(PortletLifecycleState.CREATED);\n            states.add(PortletLifecycleState.APPROVED);\n            states.add(PortletLifecycleState.EXPIRED);\n            states.add(PortletLifecycleState.PUBLISHED);\n            states.add(PortletLifecycleState.MAINTENANCE);\n        } else if (hasLifecyclePermission(person, PortletLifecycleState.EXPIRED, categories)) {\n            states.add(PortletLifecycleState.CREATED);\n            states.add(PortletLifecycleState.APPROVED);\n            states.add(PortletLifecycleState.EXPIRED);\n            states.add(PortletLifecycleState.PUBLISHED);\n        } else if (hasLifecyclePermission(person, PortletLifecycleState.PUBLISHED, categories)) {\n            states.add(PortletLifecycleState.CREATED);\n            states.add(PortletLifecycleState.APPROVED);\n            states.add(PortletLifecycleState.PUBLISHED);\n        } else if (hasLifecyclePermission(person, PortletLifecycleState.APPROVED, categories)) {\n            states.add(PortletLifecycleState.CREATED);\n            states.add(PortletLifecycleState.APPROVED);\n        } else if (hasLifecyclePermission(person, PortletLifecycleState.CREATED, categories)) {\n            states.add(PortletLifecycleState.CREATED);\n        }\n        return states;\n    }","id":78632,"modified_method":"public Set<PortletLifecycleState> getAllowedLifecycleStates(IPerson person, SortedSet<JsonEntityBean> categories) {\n        Set<PortletLifecycleState> states = new TreeSet<PortletLifecycleState>();\n        if (hasLifecyclePermission(person, PortletLifecycleState.MAINTENANCE, categories)) {\n            states.add(PortletLifecycleState.CREATED);\n            states.add(PortletLifecycleState.APPROVED);\n            states.add(PortletLifecycleState.EXPIRED);\n            states.add(PortletLifecycleState.PUBLISHED);\n            states.add(PortletLifecycleState.MAINTENANCE);\n        } else if (hasLifecyclePermission(person, PortletLifecycleState.EXPIRED, categories)) {\n            states.add(PortletLifecycleState.CREATED);\n            states.add(PortletLifecycleState.APPROVED);\n            states.add(PortletLifecycleState.EXPIRED);\n            states.add(PortletLifecycleState.PUBLISHED);\n        } else if (hasLifecyclePermission(person, PortletLifecycleState.PUBLISHED, categories)) {\n            states.add(PortletLifecycleState.CREATED);\n            states.add(PortletLifecycleState.APPROVED);\n            states.add(PortletLifecycleState.PUBLISHED);\n        } else if (hasLifecyclePermission(person, PortletLifecycleState.APPROVED, categories)) {\n            states.add(PortletLifecycleState.CREATED);\n            states.add(PortletLifecycleState.APPROVED);\n        } else if (hasLifecyclePermission(person, PortletLifecycleState.CREATED, categories)) {\n            states.add(PortletLifecycleState.CREATED);\n        }\n        return states;\n    }","commit_id":"69307a79381cf26e5183cd31500faa0df27986b2","url":"https://github.com/Jasig/uPortal"},{"original_method":"private void addSubscribePermissionsToForm(IPortletDefinition def, PortletDefinitionForm form) {\n        final String portletTargetId = PermissionHelper.permissionTargetIdForPortletDefinition(def);\n\n        /* We are concerned with PORTAL_SUBSCRIBE system */\n        final IPermissionManager pm = authorizationService.newPermissionManager(IPermission.PORTAL_SUBSCRIBE);\n        for (String activity : PORTLET_SUBSCRIBE_ACTIVITIES) {\n            /* Obtain the principals that have permission for the activity on this portlet */\n            final IAuthorizationPrincipal[] principals = pm.getAuthorizedPrincipals(activity, portletTargetId) ;\n\n            for (IAuthorizationPrincipal principal : principals) {\n                JsonEntityBean principalBean;\n\n                // first assume this is a group\n                IEntityGroup group = GroupService.findGroup(principal.getKey());\n                if (group != null) {\n                    // principal is a group\n                    principalBean = new JsonEntityBean(group, EntityEnum.GROUP);\n                } else {\n                    // not a group, so it must be a person\n                    IGroupMember member = authorizationService.getGroupMember(principal);\n                    principalBean = new JsonEntityBean(member, EntityEnum.PERSON);\n                    // set the name\n                    String name = groupListHelper.lookupEntityName(principalBean);\n                    principalBean.setName(name);\n                }\n\n                /* Make sure we capture the principal just once*/\n                if (!form.getGroups().contains(principalBean)) {\n                    form.addGroup(principalBean);\n                }\n\n                form.addPermission(principalBean.getTypeAndIdHash() + \"_\" + activity);\n            }\n        }\n    }","id":78633,"modified_method":"private void addSubscribePermissionsToForm(IPortletDefinition def, PortletDefinitionForm form) {\n        final String portletTargetId = PermissionHelper.permissionTargetIdForPortletDefinition(def);\n\n        /* We are concerned with PORTAL_SUBSCRIBE system */\n        final IPermissionManager pm = authorizationService.newPermissionManager(IPermission.PORTAL_SUBSCRIBE);\n        for (String activity : PORTLET_SUBSCRIBE_ACTIVITIES) {\n            /* Obtain the principals that have permission for the activity on this portlet */\n            final IAuthorizationPrincipal[] principals = pm.getAuthorizedPrincipals(activity, portletTargetId) ;\n\n            for (IAuthorizationPrincipal principal : principals) {\n                JsonEntityBean principalBean;\n\n                // first assume this is a group\n                IEntityGroup group = GroupService.findGroup(principal.getKey());\n                if (group != null) {\n                    // principal is a group\n                    principalBean = new JsonEntityBean(group, EntityEnum.GROUP);\n                } else {\n                    // not a group, so it must be a person\n                    IGroupMember member = authorizationService.getGroupMember(principal);\n                    principalBean = new JsonEntityBean(member, EntityEnum.PERSON);\n                    // set the name\n                    String name = groupListHelper.lookupEntityName(principalBean);\n                    principalBean.setName(name);\n                }\n\n                /* Make sure we capture the principal just once*/\n                if (!form.getPrincipals().contains(principalBean)) {\n                    form.addPrincipal(principalBean);\n                }\n\n                form.addPermission(principalBean.getTypeAndIdHash() + \"_\" + activity);\n            }\n        }\n    }","commit_id":"69307a79381cf26e5183cd31500faa0df27986b2","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Persist a new or edited PortletDefinition.\n     *\n     * @param form\n     * @param publisher\n     */\n    public PortletDefinitionForm savePortletRegistration(IPerson publisher,\n            PortletDefinitionForm form) throws Exception {\n\n        /* TODO:  Service-Layer Security Reboot (great need of refactoring with a community-approved plan in place) */\n\n        // User must have the selected lifecycle permission over AT LEAST ONE\n        // category in which this portlet resides.  (This is the same check that\n        // is made when the user enters the lifecycle-selection step in the wizard.)\n        if (!hasLifecyclePermission(publisher, form.getLifecycleState(), form.getCategories())) {\n            logger.warn(\"User '\" + publisher.getUserName() +\n                    \"' attempted to save the following portlet without the selected MANAGE permission:  \" + form);\n            throw new SecurityException(\"Not Authorized\");\n        }\n\n        if (!form.isNew()) {\n            // User must have the previous lifecycle permission\n            // in AT LEAST ONE previous category as well\n            IPortletDefinition def = this.portletDefinitionRegistry.getPortletDefinition(form.getId());\n            Set<PortletCategory> categories = portletCategoryRegistry.getParentCategories(def);\n            List<JsonEntityBean> categoryBeans = new ArrayList<JsonEntityBean>();\n            for (PortletCategory cat : categories) {\n                categoryBeans.add(new JsonEntityBean(cat));\n            }\n            if (!hasLifecyclePermission(publisher, def.getLifecycleState(), categoryBeans)) {\n                logger.warn(\"User '\" + publisher.getUserName() +\n                        \"' attempted to save the following portlet without the previous MANAGE permission:  \" + form);\n                throw new SecurityException(\"Not Authorized\");\n            }\n        }\n\n        if (form.isNew() || portletDefinitionRegistry.getPortletDefinition(form.getId()).getType().getId() != form.getTypeId()) {\n            // User must have access to the selected CPD if s/he selected it in this interaction\n            final int selectedTypeId = form.getTypeId();\n            final PortletPublishingDefinition cpd = portletPublishingDefinitionDao.getChannelPublishingDefinition(selectedTypeId);\n            final Map<IPortletType, PortletPublishingDefinition> allowableCpds = this.getAllowableChannelPublishingDefinitions(publisher);\n            if (!allowableCpds.containsValue(cpd)) {\n                logger.warn(\"User '\" + publisher.getUserName() +\n                        \"' attempted to administer the following portlet without the selected \" +\n                        IPermission.PORTLET_MANAGER_SELECT_PORTLET_TYPE + \" permission:  \" + form);\n                throw new SecurityException(\"Not Authorized\");\n            }\n        }\n\n        // create the group array from the form's group list -- only groups with permissions\n        final Set<IGroupMember> groupList = new HashSet<>(form.getGroups().size());\n        final Set<IGroupMember> subscribeList = new HashSet<>(form.getGroups().size());\n        final Set<IGroupMember> browseList = new HashSet<>(form.getGroups().size());\n        for (JsonEntityBean bean : form.getGroups()) {\n            final String subscribePerm = bean.getTypeAndIdHash() + \"_\" + IPermission.PORTLET_SUBSCRIBER_ACTIVITY;\n            final String browsePerm = bean.getTypeAndIdHash() + \"_\" + IPermission.PORTLET_BROWSE_ACTIVITY;\n            final EntityEnum entityEnum = bean.getEntityType();\n            final IGroupMember group = entityEnum.isGroup() ?\n                    (GroupService.findGroup(bean.getId())) :\n                    (GroupService.getGroupMember(bean.getId(), entityEnum.getClazz()));\n            if (form.getPermissions().contains(subscribePerm) || form.getPermissions().contains(browsePerm)) {\n                groupList.add(group);\n            }\n            if (form.getPermissions().contains(subscribePerm)) {\n                subscribeList.add(group);\n            }\n            if (form.getPermissions().contains(browsePerm)) {\n                browseList.add(group);\n            }\n        }\n        IGroupMember[] groupMembers = new IGroupMember[groupList.size()];\n        groupMembers = groupList.toArray(groupMembers);\n\n        // create the category array from the form's category list\n        PortletCategory[] categories = new PortletCategory[form.getCategories().size()];\n        for (ListIterator<JsonEntityBean> iter = form.getCategories().listIterator(); iter.hasNext();) {\n            String id = iter.next().getId();\n            String iCatID = id.startsWith(\"cat\") ? id.substring(3) : id;\n            categories[iter.previousIndex()] = portletCategoryRegistry.getPortletCategory(iCatID);\n        }\n\n        IPortletDefinition portletDef = null;\n        if (form.getId() == null) {\n            final String fname = form.getFname();\n            final String name = form.getName();\n            final String title = form.getTitle();\n            final String applicationId = form.getApplicationId();\n            final String portletName = form.getPortletName();\n            final boolean isFramework = form.isFramework();\n\n            final IPortletType type = portletTypeRegistry.getPortletType(form.getTypeId());\n            portletDef = portletDefinitionRegistry.createPortletDefinition(type, fname, name, title, applicationId, portletName, isFramework);\n        } else {\n            portletDef = portletDefinitionRegistry.getPortletDefinition(form.getId());\n        }\n        portletDef.setDescription(form.getDescription());\n        portletDef.setFName(form.getFname());\n        portletDef.setName(form.getName());\n        portletDef.setTimeout(form.getTimeout());\n        portletDef.setTitle(form.getTitle());\n        portletDef.getPortletDescriptorKey().setWebAppName(form.getApplicationId());\n        portletDef.getPortletDescriptorKey().setPortletName(form.getPortletName());\n        portletDef.getPortletDescriptorKey().setFrameworkPortlet(form.isFramework());\n\n        final IPortletType portletType = portletTypeRegistry.getPortletType(form.getTypeId());\n        if (portletType == null) {\n            throw new IllegalArgumentException(\"No IPortletType exists for ID \" + form.getTypeId());\n        }\n        portletDef.setType(portletType);\n\n        // Make parameters (NB:  these are different from preferences) in the\n        // portletDef reflect the state of the form, in case any have changed.\n        for (String key : form.getParameters().keySet()) {\n            String value = form.getParameters().get(key).getValue();\n            if (!StringUtils.isBlank(value)) {\n                portletDef.addParameter(key, value);\n            }\n        }\n        portletDef.addParameter(IPortletDefinition.EDITABLE_PARAM, Boolean.toString(form.isEditable()));\n        portletDef.addParameter(IPortletDefinition.CONFIGURABLE_PARAM, Boolean.toString(form.isConfigurable()));\n        portletDef.addParameter(IPortletDefinition.HAS_HELP_PARAM, Boolean.toString(form.isHasHelp()));\n        portletDef.addParameter(IPortletDefinition.HAS_ABOUT_PARAM, Boolean.toString(form.isHasAbout()));\n\n        // Now add portlet preferences\n        List<IPortletPreference> preferenceList = new ArrayList<IPortletPreference>();\n        for (String key : form.getPortletPreferences().keySet()) {\n            List<String> prefValues = form.getPortletPreferences().get(key).getValue();\n            if (prefValues != null && prefValues.size() > 0) {\n                String[] values = prefValues.toArray(new String[prefValues.size()]);\n                BooleanAttribute readOnly = form.getPortletPreferenceReadOnly().get(key);\n                preferenceList.add(new PortletPreferenceImpl(key, readOnly.getValue(), values));\n            }\n        }\n        portletDef.setPortletPreferences(preferenceList);\n\n        // Lastly update the PortletDefinition's lifecycle state & lifecycle-related metadata\n        updateLifecycleState(form, portletDef, publisher);\n\n        portletPublishingService.savePortletDefinition(portletDef, publisher, Arrays.asList(categories), Arrays.asList(groupMembers));\n        updatePermissions(portletDef, subscribeList, IPermission.PORTLET_SUBSCRIBER_ACTIVITY);\n        updatePermissions(portletDef, browseList, IPermission.PORTLET_BROWSE_ACTIVITY);\n\n        return this.createPortletDefinitionForm(publisher, portletDef.getPortletDefinitionId().getStringId());\n    }","id":78634,"modified_method":"/**\n     * Persist a new or edited PortletDefinition from a form, replacing existing values.\n     *\n     * @param publisher     {@code IPerson} that requires permission to save this definition\n     * @param form          form data to persist\n     * @return              new {@code PortletDefinitionForm} for this portlet ID\n     */\n    public PortletDefinitionForm savePortletRegistration(IPerson publisher,\n            PortletDefinitionForm form) throws Exception {\n\n        /* TODO:  Service-Layer Security Reboot (great need of refactoring with a community-approved plan in place) */\n\n        // User must have the selected lifecycle permission over AT LEAST ONE\n        // category in which this portlet resides.  (This is the same check that\n        // is made when the user enters the lifecycle-selection step in the wizard.)\n        if (!hasLifecyclePermission(publisher, form.getLifecycleState(), form.getCategories())) {\n            logger.warn(\"User '\" + publisher.getUserName() +\n                    \"' attempted to save the following portlet without the selected MANAGE permission:  \" + form);\n            throw new SecurityException(\"Not Authorized\");\n        }\n\n        if (!form.isNew()) {\n            // User must have the previous lifecycle permission\n            // in AT LEAST ONE previous category as well\n            IPortletDefinition def = this.portletDefinitionRegistry.getPortletDefinition(form.getId());\n            Set<PortletCategory> categories = portletCategoryRegistry.getParentCategories(def);\n            SortedSet<JsonEntityBean> categoryBeans = new TreeSet<>();\n            for (PortletCategory cat : categories) {\n                categoryBeans.add(new JsonEntityBean(cat));\n            }\n            if (!hasLifecyclePermission(publisher, def.getLifecycleState(), categoryBeans)) {\n                logger.warn(\"User '\" + publisher.getUserName() +\n                        \"' attempted to save the following portlet without the previous MANAGE permission:  \" + form);\n                throw new SecurityException(\"Not Authorized\");\n            }\n        }\n\n        if (form.isNew() || portletDefinitionRegistry.getPortletDefinition(form.getId()).getType().getId() != form.getTypeId()) {\n            // User must have access to the selected CPD if s/he selected it in this interaction\n            final int selectedTypeId = form.getTypeId();\n            final PortletPublishingDefinition cpd = portletPublishingDefinitionDao.getChannelPublishingDefinition(selectedTypeId);\n            final Map<IPortletType, PortletPublishingDefinition> allowableCpds = this.getAllowableChannelPublishingDefinitions(publisher);\n            if (!allowableCpds.containsValue(cpd)) {\n                logger.warn(\"User '\" + publisher.getUserName() +\n                        \"' attempted to administer the following portlet without the selected \" +\n                        IPermission.PORTLET_MANAGER_SELECT_PORTLET_TYPE + \" permission:  \" + form);\n                throw new SecurityException(\"Not Authorized\");\n            }\n        }\n\n        // create the principal array from the form's principal list -- only principals with permissions\n        final Set<IGroupMember> subscribePrincipalSet = new HashSet<>(form.getPrincipals().size());\n        final Set<IGroupMember> browsePrincipalSet = new HashSet<>(form.getPrincipals().size());\n        for (JsonEntityBean bean : form.getPrincipals()) {\n            final String subscribePerm = bean.getTypeAndIdHash() + \"_\" + IPermission.PORTLET_SUBSCRIBER_ACTIVITY;\n            final String browsePerm = bean.getTypeAndIdHash() + \"_\" + IPermission.PORTLET_BROWSE_ACTIVITY;\n            final EntityEnum entityEnum = bean.getEntityType();\n            final IGroupMember principal = entityEnum.isGroup() ?\n                    (GroupService.findGroup(bean.getId())) :\n                    (GroupService.getGroupMember(bean.getId(), entityEnum.getClazz()));\n            if (form.getPermissions().contains(subscribePerm)) {\n                subscribePrincipalSet.add(principal);\n            }\n            if (form.getPermissions().contains(browsePerm)) {\n                browsePrincipalSet.add(principal);\n            }\n        }\n\n        // create the category list from the form's category bean list\n        List<PortletCategory> categories = new ArrayList<>();\n        for (JsonEntityBean category : form.getCategories()) {\n            String id = category.getId();\n            String iCatID = id.startsWith(\"cat\") ? id.substring(3) : id;\n            categories.add(portletCategoryRegistry.getPortletCategory(iCatID));\n        }\n\n        IPortletDefinition portletDef;\n        if (form.getId() == null) {\n            final String fname = form.getFname();\n            final String name = form.getName();\n            final String title = form.getTitle();\n            final String applicationId = form.getApplicationId();\n            final String portletName = form.getPortletName();\n            final boolean isFramework = form.isFramework();\n\n            final IPortletType type = portletTypeRegistry.getPortletType(form.getTypeId());\n            portletDef = portletDefinitionRegistry.createPortletDefinition(type, fname, name, title, applicationId, portletName, isFramework);\n        } else {\n            portletDef = portletDefinitionRegistry.getPortletDefinition(form.getId());\n        }\n        portletDef.setDescription(form.getDescription());\n        portletDef.setFName(form.getFname());\n        portletDef.setName(form.getName());\n        portletDef.setTimeout(form.getTimeout());\n        portletDef.setTitle(form.getTitle());\n        portletDef.getPortletDescriptorKey().setWebAppName(form.getApplicationId());\n        portletDef.getPortletDescriptorKey().setPortletName(form.getPortletName());\n        portletDef.getPortletDescriptorKey().setFrameworkPortlet(form.isFramework());\n\n        final IPortletType portletType = portletTypeRegistry.getPortletType(form.getTypeId());\n        if (portletType == null) {\n            throw new IllegalArgumentException(\"No IPortletType exists for ID \" + form.getTypeId());\n        }\n        portletDef.setType(portletType);\n\n        // Make parameters (NB:  these are different from preferences) in the\n        // portletDef reflect the state of the form, in case any have changed.\n        for (String key : form.getParameters().keySet()) {\n            String value = form.getParameters().get(key).getValue();\n            if (!StringUtils.isBlank(value)) {\n                portletDef.addParameter(key, value);\n            }\n        }\n        portletDef.addParameter(IPortletDefinition.EDITABLE_PARAM, Boolean.toString(form.isEditable()));\n        portletDef.addParameter(IPortletDefinition.CONFIGURABLE_PARAM, Boolean.toString(form.isConfigurable()));\n        portletDef.addParameter(IPortletDefinition.HAS_HELP_PARAM, Boolean.toString(form.isHasHelp()));\n        portletDef.addParameter(IPortletDefinition.HAS_ABOUT_PARAM, Boolean.toString(form.isHasAbout()));\n\n        // Now add portlet preferences\n        List<IPortletPreference> preferenceList = new ArrayList<>();\n        for (String key : form.getPortletPreferences().keySet()) {\n            List<String> prefValues = form.getPortletPreferences().get(key).getValue();\n            if (prefValues != null && prefValues.size() > 0) {\n                String[] values = prefValues.toArray(new String[prefValues.size()]);\n                BooleanAttribute readOnly = form.getPortletPreferenceReadOnly().get(key);\n                preferenceList.add(new PortletPreferenceImpl(key, readOnly.getValue(), values));\n            }\n        }\n        portletDef.setPortletPreferences(preferenceList);\n\n        // Lastly update the PortletDefinition's lifecycle state & lifecycle-related metadata\n        updateLifecycleState(form, portletDef, publisher);\n\n        // The final parameter of IGroupMembers is used to set the initial SUBSCRIBE permission set\n        portletPublishingService.savePortletDefinition(portletDef, publisher, categories, new ArrayList<>(subscribePrincipalSet));\n        //updatePermissions(portletDef, subscribePrincipalSet, IPermission.PORTLET_SUBSCRIBER_ACTIVITY);\n        updatePermissions(portletDef, browsePrincipalSet, IPermission.PORTLET_BROWSE_ACTIVITY);\n\n        return this.createPortletDefinitionForm(publisher, portletDef.getPortletDefinitionId().getStringId());\n    }","commit_id":"69307a79381cf26e5183cd31500faa0df27986b2","url":"https://github.com/Jasig/uPortal"},{"original_method":"public boolean hasLifecyclePermission(IPerson person, PortletLifecycleState state, List<JsonEntityBean> categories) {\n        EntityIdentifier ei = person.getEntityIdentifier();\n        IAuthorizationPrincipal ap = authorizationService.newPrincipal(ei.getKey(), ei.getType());\n\n        final String activity;\n        switch (state) {\n            case APPROVED: {\n                activity = IPermission.PORTLET_MANAGER_APPROVED_ACTIVITY;\n                break;\n            }\n            case CREATED: {\n                activity = IPermission.PORTLET_MANAGER_CREATED_ACTIVITY;\n                break;\n            }\n            case PUBLISHED: {\n                activity = IPermission.PORTLET_MANAGER_ACTIVITY;\n                break;\n            }\n            case EXPIRED: {\n                activity = IPermission.PORTLET_MANAGER_EXPIRED_ACTIVITY;\n                break;\n            }\n            case MAINTENANCE: {\n                activity = IPermission.PORTLET_MANAGER_MAINTENANCE_ACTIVITY;\n                break;\n            }\n            default: {\n                throw new IllegalArgumentException(\"\");\n            }\n        }\n        if (ap.hasPermission(IPermission.PORTAL_PUBLISH, activity, IPermission.ALL_PORTLETS_TARGET)) {\n            logger.debug(\"Found permission for category ALL_PORTLETS and lifecycle state \" + state.toString());\n            return true;\n        }\n\n        for (JsonEntityBean category : categories) {\n            if (ap.canManage(state, category.getId())) {\n                logger.debug(\"Found permission for category \" + category.getName() + \" and lifecycle state \" + state.toString());\n                return true;\n            }\n        }\n        logger.debug(\"No permission for lifecycle state \" + state.toString());\n        return false;\n    }","id":78635,"modified_method":"public boolean hasLifecyclePermission(IPerson person, PortletLifecycleState state, SortedSet<JsonEntityBean> categories) {\n        EntityIdentifier ei = person.getEntityIdentifier();\n        IAuthorizationPrincipal ap = authorizationService.newPrincipal(ei.getKey(), ei.getType());\n\n        final String activity;\n        switch (state) {\n            case APPROVED: {\n                activity = IPermission.PORTLET_MANAGER_APPROVED_ACTIVITY;\n                break;\n            }\n            case CREATED: {\n                activity = IPermission.PORTLET_MANAGER_CREATED_ACTIVITY;\n                break;\n            }\n            case PUBLISHED: {\n                activity = IPermission.PORTLET_MANAGER_ACTIVITY;\n                break;\n            }\n            case EXPIRED: {\n                activity = IPermission.PORTLET_MANAGER_EXPIRED_ACTIVITY;\n                break;\n            }\n            case MAINTENANCE: {\n                activity = IPermission.PORTLET_MANAGER_MAINTENANCE_ACTIVITY;\n                break;\n            }\n            default: {\n                throw new IllegalArgumentException(\"\");\n            }\n        }\n        if (ap.hasPermission(IPermission.PORTAL_PUBLISH, activity, IPermission.ALL_PORTLETS_TARGET)) {\n            logger.debug(\"Found permission for category ALL_PORTLETS and lifecycle state \" + state.toString());\n            return true;\n        }\n\n        for (JsonEntityBean category : categories) {\n            if (ap.canManage(state, category.getId())) {\n                logger.debug(\"Found permission for category \" + category.getName() + \" and lifecycle state \" + state.toString());\n                return true;\n            }\n        }\n        logger.debug(\"No permission for lifecycle state \" + state.toString());\n        return false;\n    }","commit_id":"69307a79381cf26e5183cd31500faa0df27986b2","url":"https://github.com/Jasig/uPortal"},{"original_method":"private PortletDefinitionForm createNewPortletDefinitionForm() {\n        PortletDefinitionForm form = new PortletDefinitionForm();\n\n        // pre-populate with top-level category\n        final IEntityGroup portletCategoriesGroup = GroupService.getDistinguishedGroup(GroupService.PORTLET_CATEGORIES);\n        form.addCategory(new JsonEntityBean(portletCategoriesGroup, groupListHelper.getEntityType(portletCategoriesGroup)));\n\n        // pre-populate with top-level group\n        final IEntityGroup everyoneGroup = GroupService.getDistinguishedGroup(GroupService.EVERYONE);\n        JsonEntityBean everyoneBean = new JsonEntityBean(everyoneGroup, groupListHelper.getEntityType(everyoneGroup));\n        form.addGroup(everyoneBean);\n        for (String activity : PORTLET_SUBSCRIBE_ACTIVITIES) {\n            form.addPermission(everyoneBean.getTypeAndIdHash() + \"_\" + activity);\n        }\n        return form;\n    }","id":78636,"modified_method":"private PortletDefinitionForm createNewPortletDefinitionForm() {\n        PortletDefinitionForm form = new PortletDefinitionForm();\n\n        // pre-populate with top-level category\n        final IEntityGroup portletCategoriesGroup = GroupService.getDistinguishedGroup(GroupService.PORTLET_CATEGORIES);\n        form.addCategory(new JsonEntityBean(portletCategoriesGroup, groupListHelper.getEntityType(portletCategoriesGroup)));\n\n        // pre-populate with top-level group\n        final IEntityGroup everyoneGroup = GroupService.getDistinguishedGroup(GroupService.EVERYONE);\n        JsonEntityBean everyoneBean = new JsonEntityBean(everyoneGroup, groupListHelper.getEntityType(everyoneGroup));\n        form.addPrincipal(everyoneBean);\n        for (String activity : PORTLET_SUBSCRIBE_ACTIVITIES) {\n            form.addPermission(everyoneBean.getTypeAndIdHash() + \"_\" + activity);\n        }\n        return form;\n    }","commit_id":"69307a79381cf26e5183cd31500faa0df27986b2","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void addGroup(JsonEntityBean group) {\n        this.groups.add(group);\n    }","id":78637,"modified_method":"public void addPrincipal(JsonEntityBean principal) {\n        this.principals.add(principal);\n    }","commit_id":"69307a79381cf26e5183cd31500faa0df27986b2","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setCategories(List<JsonEntityBean> categories) {\n        this.categories = categories;\n    }","id":78638,"modified_method":"public void setCategories(SortedSet<JsonEntityBean> categories) {\n        this.categories.clear();\n        this.categories.addAll(categories);\n    }","commit_id":"69307a79381cf26e5183cd31500faa0df27986b2","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Construct a new PortletDefinitionForm from a PortletDefinition\n     *\n     * @param def\n     */\n    public PortletDefinitionForm(IPortletDefinition def) {\n        this.setId(def.getPortletDefinitionId().getStringId());\n        this.setFname(def.getFName());\n        this.setName(def.getName());\n        this.setDescription(def.getDescription());\n        this.setTitle(def.getTitle());\n        this.setTimeout(def.getTimeout());\n        this.setTypeId(def.getType().getId());\n        this.setApplicationId(def.getPortletDescriptorKey().getWebAppName());\n        this.setPortletName(def.getPortletDescriptorKey().getPortletName());\n        this.setFramework(def.getPortletDescriptorKey().isFrameworkPortlet());\n        if (def.getParameter(IPortletDefinition.EDITABLE_PARAM) != null) {\n            this.setEditable(Boolean.parseBoolean(def.getParameter(IPortletDefinition.EDITABLE_PARAM).getValue()));\n        }\n        if (def.getParameter(IPortletDefinition.CONFIGURABLE_PARAM) != null) {\n            this.setConfigurable(Boolean.parseBoolean(def.getParameter(IPortletDefinition.CONFIGURABLE_PARAM).getValue()));\n        }\n        if (def.getParameter(IPortletDefinition.HAS_HELP_PARAM) != null) {\n            this.setHasHelp(Boolean.parseBoolean(def.getParameter(IPortletDefinition.HAS_HELP_PARAM).getValue()));\n        }\n        if (def.getParameter(IPortletDefinition.HAS_ABOUT_PARAM) != null) {\n            this.setHasAbout(Boolean.parseBoolean(def.getParameter(IPortletDefinition.HAS_ABOUT_PARAM).getValue()));\n        }\n        this.setLifecycleState(def.getLifecycleState());\n\n        if (def.getLifecycleState().equals(PortletLifecycleState.APPROVED)) {\n            this.setPublishDateTime(def.getPublishDate());\n        }\n\n        if (def.getLifecycleState().equals(PortletLifecycleState.PUBLISHED)) {\n            this.setExpirationDateTime(def.getExpirationDate());\n        }\n\n        for (IPortletDefinitionParameter param : def.getParameters()) {\n            if (param.getName().startsWith(\"PORTLET.\")) {\n                this.portletPreferences.put(param.getName(),\n                        new StringListAttribute(new String[]{param.getValue()}));\n            } else {\n                this.parameters.put(param.getName(),\n                        new Attribute(param.getValue()));\n            }\n        }\n\n        for (IPortletPreference pref : def.getPortletPreferences()) {\n            List<Attribute> attributes = new ArrayList<>();\n            for (String value : pref.getValues()) {\n                attributes.add(new Attribute(value));\n            }\n            this.portletPreferences.put(pref.getName(), new StringListAttribute(pref.getValues()));\n            this.portletPreferenceReadOnly.put(pref.getName(), new BooleanAttribute(pref.isReadOnly()));\n        }\n\n    }","id":78639,"modified_method":"/**\n     * Construct a new PortletDefinitionForm from a PortletDefinition\n     *\n     * @param def\n     */\n    public PortletDefinitionForm(IPortletDefinition def) {\n        this.setId(def.getPortletDefinitionId().getStringId());\n        this.setFname(def.getFName());\n        this.setName(def.getName());\n        this.setDescription(def.getDescription());\n        this.setTitle(def.getTitle());\n        this.setTimeout(def.getTimeout());\n        this.setTypeId(def.getType().getId());\n        this.setApplicationId(def.getPortletDescriptorKey().getWebAppName());\n        this.setPortletName(def.getPortletDescriptorKey().getPortletName());\n        this.setFramework(def.getPortletDescriptorKey().isFrameworkPortlet());\n        if (def.getParameter(IPortletDefinition.EDITABLE_PARAM) != null) {\n            this.setEditable(Boolean.parseBoolean(def.getParameter(IPortletDefinition.EDITABLE_PARAM).getValue()));\n        }\n        if (def.getParameter(IPortletDefinition.CONFIGURABLE_PARAM) != null) {\n            this.setConfigurable(Boolean.parseBoolean(def.getParameter(IPortletDefinition.CONFIGURABLE_PARAM).getValue()));\n        }\n        if (def.getParameter(IPortletDefinition.HAS_HELP_PARAM) != null) {\n            this.setHasHelp(Boolean.parseBoolean(def.getParameter(IPortletDefinition.HAS_HELP_PARAM).getValue()));\n        }\n        if (def.getParameter(IPortletDefinition.HAS_ABOUT_PARAM) != null) {\n            this.setHasAbout(Boolean.parseBoolean(def.getParameter(IPortletDefinition.HAS_ABOUT_PARAM).getValue()));\n        }\n        this.setLifecycleState(def.getLifecycleState());\n\n        if (def.getLifecycleState().equals(PortletLifecycleState.APPROVED)) {\n            this.setPublishDateTime(def.getPublishDate());\n        }\n\n        if (def.getLifecycleState().equals(PortletLifecycleState.PUBLISHED)) {\n            this.setExpirationDateTime(def.getExpirationDate());\n        }\n\n        for (IPortletDefinitionParameter param : def.getParameters()) {\n            if (param.getName().startsWith(\"PORTLET.\")) {\n                this.portletPreferences.put(param.getName(),\n                        new StringListAttribute(new String[]{param.getValue()}));\n            } else {\n                this.parameters.put(param.getName(),\n                        new Attribute(param.getValue()));\n            }\n        }\n\n        for (IPortletPreference pref : def.getPortletPreferences()) {\n            this.portletPreferences.put(pref.getName(), new StringListAttribute(pref.getValues()));\n            this.portletPreferenceReadOnly.put(pref.getName(), new BooleanAttribute(pref.isReadOnly()));\n        }\n\n    }","commit_id":"69307a79381cf26e5183cd31500faa0df27986b2","url":"https://github.com/Jasig/uPortal"},{"original_method":"public List<JsonEntityBean> getCategories() {\n        return categories;\n    }","id":78640,"modified_method":"public SortedSet<JsonEntityBean> getCategories() {\n        return Collections.unmodifiableSortedSet(categories);\n    }","commit_id":"69307a79381cf26e5183cd31500faa0df27986b2","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * <p>mergeCategorySet<\/p>\n     *\n     * @param scannedNode a {@link org.opennms.netmgt.model.OnmsNode} object.\n     */\n    public void mergeCategorySet(OnmsNode scannedNode) {\n        if (!getCategories().equals(scannedNode.getCategories())) {\n            setCategories(scannedNode.getCategories());\n        }\n    }","id":78641,"modified_method":"/**\n     * <p>mergeCategorySet<\/p>\n     *\n     * @param scannedNode a {@link org.opennms.netmgt.model.OnmsNode} object.\n     */\n    public void mergeCategorySet(OnmsNode scannedNode) {\n        for (final OnmsCategory cat : scannedNode.getCategories()) {\n            addCategory(cat);\n        }\n    }","commit_id":"b1ec50f07b0e5f0eda95130db727cd4550e5d54f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public CollectionElementInvocationHandler(final Class<T> aClass,\n                                            @NotNull final XmlTag tag,\n                                            final DomInvocationHandler parent) {\n    super(aClass, tag, parent, tag.getName(), parent.getManager());\n  }","id":78642,"modified_method":"public CollectionElementInvocationHandler(final Class aClass,\n                                            @NotNull final XmlTag tag,\n                                            final DomInvocationHandler parent) {\n    super(aClass, tag, parent, tag.getName(), parent.getManager());\n  }","commit_id":"c9f10c26432706c12284f85c682e095ed9ac3a11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public T getRootElement() {\n    synchronized (PsiLock.LOCK) {\n      if (myRootValue == null) {\n        final XmlTag tag = getRootTag();\n        final DomRootInvocationHandler<T> handler = new DomRootInvocationHandler<T>(myRootElementClass, tag, this, myRootTagName);\n        myRootValue = (T)myManager.createDomElement(myRootElementClass, tag, handler);\n      }\n      return myRootValue;\n    }\n  }","id":78643,"modified_method":"@NotNull\n  public T getRootElement() {\n    synchronized (PsiLock.LOCK) {\n      if (myRootValue == null) {\n        final XmlTag tag = getRootTag();\n        final DomRootInvocationHandler handler = new DomRootInvocationHandler(myRootElementClass, tag, this, myRootTagName);\n        myRootValue = (T)myManager.createDomElement(myRootElementClass, tag, handler);\n      }\n      return myRootValue;\n    }\n  }","commit_id":"c9f10c26432706c12284f85c682e095ed9ac3a11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private XmlTag addEmptyTag(final String tagName, int index) throws IncorrectOperationException {\n    final XmlTag tag = getXmlTag();\n    final XmlTag[] subTags = tag.findSubTags(tagName);\n    if (subTags.length < index) {\n      index = subTags.length;\n    }\n    final boolean changing = myManager.setChanging(true);\n    try {\n      XmlTag newTag = createEmptyTag(tagName);\n      if (index == 0) {\n        return (XmlTag)tag.add(newTag);\n      }\n\n      return (XmlTag)tag.addAfter(newTag, subTags[index - 1]);\n    }\n    finally {\n      myManager.setChanging(changing);\n    }\n  }","id":78644,"modified_method":"private XmlTag addEmptyTag(final String tagName, int index) throws IncorrectOperationException {\n    final XmlTag tag = ensureTagExists();\n    final XmlTag[] subTags = tag.findSubTags(tagName);\n    if (subTags.length < index) {\n      index = subTags.length;\n    }\n    final boolean changing = myManager.setChanging(true);\n    try {\n      XmlTag newTag = createEmptyTag(tagName);\n      if (index == 0) {\n        return (XmlTag)tag.add(newTag);\n      }\n\n      return (XmlTag)tag.addAfter(newTag, subTags[index - 1]);\n    }\n    finally {\n      myManager.setChanging(changing);\n    }\n  }","commit_id":"c9f10c26432706c12284f85c682e095ed9ac3a11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DomRootInvocationHandler(final Class<T> aClass,\n                                  final XmlTag tag,\n                                  final DomFileElementImpl<T> fileElement,\n                                  @NotNull final String tagName\n  ) {\n    super(aClass, tag, null, tagName, fileElement.getManager());\n    myParent = fileElement;\n  }","id":78645,"modified_method":"public DomRootInvocationHandler(final Class aClass,\n                                  final XmlTag tag,\n                                  final DomFileElementImpl fileElement,\n                                  @NotNull final String tagName\n  ) {\n    super(aClass, tag, null, tagName, fileElement.getManager());\n    myParent = fileElement;\n  }","commit_id":"c9f10c26432706c12284f85c682e095ed9ac3a11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void undefine() throws IllegalAccessException, InstantiationException {\n    final DomInvocationHandler parent = getParentHandler();\n    parent.checkInitialized();\n    final XmlTag[] subTags = parent.getXmlTag().findSubTags(getTagName());\n    if (subTags.length <= myIndex) {\n      return;\n    }\n\n    final boolean changing = getManager().setChanging(true);\n    try {\n      XmlTag tag = getXmlTag();\n      assert tag != null;\n      if (subTags.length == myIndex + 1) {\n        cacheDomElement(null);\n        tag.delete();\n      } else {\n        cacheDomElement((XmlTag) tag.replace(createEmptyTag()));\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    } finally {\n      getManager().setChanging(changing);\n    }\n    fireUndefinedEvent();\n  }","id":78646,"modified_method":"public void undefine() throws IllegalAccessException, InstantiationException {\n    final DomInvocationHandler parent = getParentHandler();\n    final XmlTag parentTag = parent.getXmlTag();\n    if (parentTag == null) return;\n\n    parent.checkInitialized();\n    final XmlTag[] subTags = parentTag.findSubTags(getTagName());\n    if (subTags.length <= myIndex) {\n      return;\n    }\n\n    final boolean changing = getManager().setChanging(true);\n    try {\n      XmlTag tag = getXmlTag();\n      assert tag != null;\n      if (subTags.length == myIndex + 1) {\n        cacheDomElement(null);\n        tag.delete();\n      } else {\n        cacheDomElement((XmlTag) tag.replace(createEmptyTag()));\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    } finally {\n      getManager().setChanging(changing);\n    }\n    fireUndefinedEvent();\n  }","commit_id":"c9f10c26432706c12284f85c682e095ed9ac3a11","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void addSearchResultAtom(\n\t\tElement root, long groupId, String title, String link, Date updated,\n\t\tString summary, String[] tags, double ratings, double score) {\n\n\t\t// entry\n\n\t\tElement entry = OpenSearchUtil.addElement(\n\t\t\troot, \"entry\", OpenSearchUtil.DEFAULT_NAMESPACE);\n\n\t\t// groupId\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"groupId\", OpenSearchUtil.LIFERAY_NAMESPACE, groupId);\n\n\t\t// title\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"title\", OpenSearchUtil.DEFAULT_NAMESPACE, title);\n\n\t\t// link\n\n\t\tElement entryLink = OpenSearchUtil.addElement(\n\t\t\tentry, \"link\", OpenSearchUtil.DEFAULT_NAMESPACE);\n\n\t\tentryLink.addAttribute(\"href\", link);\n\n\t\t// id\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"id\", OpenSearchUtil.DEFAULT_NAMESPACE,\n\t\t\t\"urn:uuid:\" + PortalUUIDUtil.generate());\n\n\t\t// updated\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"updated\", OpenSearchUtil.DEFAULT_NAMESPACE, updated);\n\n\t\t// summary\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"summary\", OpenSearchUtil.DEFAULT_NAMESPACE, summary);\n\n\t\t// tags\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"tags\", OpenSearchUtil.DEFAULT_NAMESPACE,\n\t\t\tStringUtil.merge(tags));\n\n\t\t// ratings\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"ratings\", OpenSearchUtil.DEFAULT_NAMESPACE, ratings);\n\n\t\t// relevance:score\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"score\", OpenSearchUtil.RELEVANCE_NAMESPACE, score);\n\t}","id":78647,"modified_method":"protected void addSearchResultAtom(\n\t\tElement root, long groupId, String entryClassName, long entryClassPK,\n\t\tString title, String link, Date updated, String summary, String[] tags,\n\t\tdouble ratings, double score) {\n\n\t\t// entry\n\n\t\tElement entry = OpenSearchUtil.addElement(\n\t\t\troot, \"entry\", OpenSearchUtil.DEFAULT_NAMESPACE);\n\n\t\t// groupId\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"groupId\", OpenSearchUtil.LIFERAY_NAMESPACE, groupId);\n\n\t\t// entryClassName\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"entryClassName\", OpenSearchUtil.LIFERAY_NAMESPACE,\n\t\t\tentryClassName);\n\n\t\t// entryClassPK\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"entryClassPK\", OpenSearchUtil.LIFERAY_NAMESPACE,\n\t\t\tentryClassPK);\n\n\t\t// title\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"title\", OpenSearchUtil.DEFAULT_NAMESPACE, title);\n\n\t\t// link\n\n\t\tElement entryLink = OpenSearchUtil.addElement(\n\t\t\tentry, \"link\", OpenSearchUtil.DEFAULT_NAMESPACE);\n\n\t\tentryLink.addAttribute(\"href\", link);\n\n\t\t// id\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"id\", OpenSearchUtil.DEFAULT_NAMESPACE,\n\t\t\t\"urn:uuid:\" + PortalUUIDUtil.generate());\n\n\t\t// updated\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"updated\", OpenSearchUtil.DEFAULT_NAMESPACE, updated);\n\n\t\t// summary\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"summary\", OpenSearchUtil.DEFAULT_NAMESPACE, summary);\n\n\t\t// tags\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"tags\", OpenSearchUtil.DEFAULT_NAMESPACE,\n\t\t\tStringUtil.merge(tags));\n\n\t\t// ratings\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"ratings\", OpenSearchUtil.DEFAULT_NAMESPACE, ratings);\n\n\t\t// relevance:score\n\n\t\tOpenSearchUtil.addElement(\n\t\t\tentry, \"score\", OpenSearchUtil.RELEVANCE_NAMESPACE, score);\n\t}","commit_id":"64f0a104c454bb1002100c517b37cf1b0786b655","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addSearchResult(\n\t\tElement root, long groupId, String title, String link, Date updated,\n\t\tString summary, String[] tags, double ratings, double score,\n\t\tString format) {\n\n\t\tif (format.equals(\"rss\")) {\n\t\t\taddSearchResultRSS(\n\t\t\t\troot, groupId, title, link, updated, summary, tags, ratings,\n\t\t\t\tscore);\n\t\t}\n\t\telse {\n\t\t\taddSearchResultAtom(\n\t\t\t\troot, groupId, title, link, updated, summary, tags, ratings,\n\t\t\t\tscore);\n\t\t}\n\t}","id":78648,"modified_method":"protected void addSearchResult(\n\t\tElement root, long groupId, String entryClassName, long entryClassPK,\n\t\tString title, String link, Date updated, String summary, String[] tags,\n\t\tdouble ratings, double score, String format) {\n\n\t\tif (format.equals(\"rss\")) {\n\t\t\taddSearchResultRSS(\n\t\t\t\troot, groupId, entryClassName, entryClassPK, title, link,\n\t\t\t\tupdated, summary, tags, ratings, score);\n\t\t}\n\t\telse {\n\t\t\taddSearchResultAtom(\n\t\t\t\troot, groupId, entryClassName, entryClassPK, title, link,\n\t\t\t\tupdated, summary, tags, ratings, score);\n\t\t}\n\t}","commit_id":"64f0a104c454bb1002100c517b37cf1b0786b655","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addSearchResultRSS(\n\t\tElement root, long groupId, String title, String link, Date updated,\n\t\tString summary, String[] tags, double ratings, double score) {\n\n\t\t// item\n\n\t\tElement item = root.addElement(\"item\");\n\n\t\t// groupId\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"groupId\", OpenSearchUtil.LIFERAY_NAMESPACE, groupId);\n\n\t\t// title\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"title\", OpenSearchUtil.NO_NAMESPACE, title);\n\n\t\t// link\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"link\", OpenSearchUtil.NO_NAMESPACE, link);\n\n\t\t// summary\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"description\", OpenSearchUtil.NO_NAMESPACE, summary);\n\n\t\t// tags\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"tags\", OpenSearchUtil.NO_NAMESPACE, StringUtil.merge(tags));\n\n\t\t// ratings\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"ratings\", OpenSearchUtil.NO_NAMESPACE, ratings);\n\n\t\t// relevance:score\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"score\", OpenSearchUtil.RELEVANCE_NAMESPACE, score);\n\t}","id":78649,"modified_method":"protected void addSearchResultRSS(\n\t\tElement root, long groupId, String entryClassName, long entryClassPK,\n\t\tString title, String link, Date updated, String summary, String[] tags,\n\t\tdouble ratings, double score) {\n\n\t\t// item\n\n\t\tElement item = root.addElement(\"item\");\n\n\t\t// groupId\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"groupId\", OpenSearchUtil.LIFERAY_NAMESPACE, groupId);\n\n\t\t// entryClassName\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"entryClassName\", OpenSearchUtil.LIFERAY_NAMESPACE,\n\t\t\tentryClassName);\n\n\t\t// entryClassPK\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"entryClassPK\", OpenSearchUtil.LIFERAY_NAMESPACE,\n\t\t\tentryClassPK);\n\n\t\t// title\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"title\", OpenSearchUtil.NO_NAMESPACE, title);\n\n\t\t// link\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"link\", OpenSearchUtil.NO_NAMESPACE, link);\n\n\t\t// summary\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"description\", OpenSearchUtil.NO_NAMESPACE, summary);\n\n\t\t// tags\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"tags\", OpenSearchUtil.NO_NAMESPACE, StringUtil.merge(tags));\n\n\t\t// ratings\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"ratings\", OpenSearchUtil.NO_NAMESPACE, ratings);\n\n\t\t// relevance:score\n\n\t\tOpenSearchUtil.addElement(\n\t\t\titem, \"score\", OpenSearchUtil.RELEVANCE_NAMESPACE, score);\n\t}","commit_id":"64f0a104c454bb1002100c517b37cf1b0786b655","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addSearchResult(\n\t\tElement root, long groupId, String title, String link, Date updated,\n\t\tString summary, double score, String format) {\n\n\t\taddSearchResult(\n\t\t\troot, groupId, title, link, updated, summary, new String[0], 0,\n\t\t\tscore, format);\n\t}","id":78650,"modified_method":"protected void addSearchResult(\n\t\tElement root, long groupId, String entryClassName, long entryClassPK,\n\t\tString title, String link, Date updated, String summary, double score,\n\t\tString format) {\n\n\t\taddSearchResult(\n\t\t\troot, groupId, entryClassName, entryClassPK, title, link, updated,\n\t\t\tsummary, new String[0], 0, score, format);\n\t}","commit_id":"64f0a104c454bb1002100c517b37cf1b0786b655","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String search(\n\t\t\tHttpServletRequest request, long groupId, long userId,\n\t\t\tString keywords, int startPage, int itemsPerPage, String format)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tint start = (startPage * itemsPerPage) - itemsPerPage;\n\t\t\tint end = startPage * itemsPerPage;\n\n\t\t\tSearchContext searchContext = SearchContextFactory.getInstance(\n\t\t\t\trequest);\n\n\t\t\tsearchContext.setGroupIds(new long[] {groupId});\n\t\t\tsearchContext.setEnd(end);\n\t\t\tsearchContext.setKeywords(keywords);\n\t\t\tsearchContext.setScopeStrict(false);\n\t\t\tsearchContext.setStart(start);\n\t\t\tsearchContext.setUserId(userId);\n\n\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tthemeDisplay.getCompanyId(), getPortletId());\n\n\t\t\tIndexer indexer = portlet.getIndexerInstance();\n\n\t\t\tHits results = indexer.search(searchContext);\n\n\t\t\tString[] queryTerms = results.getQueryTerms();\n\n\t\t\tint total = results.getLength();\n\n\t\t\tObject[] values = addSearchResults(\n\t\t\t\tqueryTerms, keywords, startPage, itemsPerPage, total, start,\n\t\t\t\tgetTitle(keywords), getSearchPath(), format, themeDisplay);\n\n\t\t\tcom.liferay.portal.kernel.xml.Document doc =\n\t\t\t\t(com.liferay.portal.kernel.xml.Document)values[0];\n\t\t\tElement root = (Element)values[1];\n\n\t\t\tfor (int i = 0; i < results.getDocs().length; i++) {\n\t\t\t\tDocument result = results.doc(i);\n\n\t\t\t\tString portletId = result.get(Field.PORTLET_ID);\n\n\t\t\t\tString snippet = results.snippet(i);\n\n\t\t\t\tlong resultGroupId = GetterUtil.getLong(\n\t\t\t\t\tresult.get(Field.GROUP_ID));\n\n\t\t\t\tPortletURL portletURL = getPortletURL(\n\t\t\t\t\trequest, portletId, resultGroupId);\n\n\t\t\t\tSummary summary = getSummary(\n\t\t\t\t\tindexer, result, snippet, portletURL);\n\n\t\t\t\tString title = summary.getTitle();\n\t\t\t\tString url = getURL(\n\t\t\t\t\tthemeDisplay, resultGroupId, result, portletURL);\n\t\t\t\tDate modifedDate = result.getDate(Field.MODIFIED);\n\t\t\t\tString content = summary.getContent();\n\n\t\t\t\tString[] tags = new String[0];\n\n\t\t\t\tField assetTagNamesField = result.getFields().get(\n\t\t\t\t\tField.ASSET_TAG_NAMES);\n\n\t\t\t\tif (assetTagNamesField != null) {\n\t\t\t\t\ttags = assetTagNamesField.getValues();\n\t\t\t\t}\n\n\t\t\t\tdouble ratings = 0.0;\n\n\t\t\t\tString entryClassName = result.get(Field.ENTRY_CLASS_NAME);\n\t\t\t\tlong entryClassPK = GetterUtil.getLong(\n\t\t\t\t\tresult.get(Field.ENTRY_CLASS_PK));\n\n\t\t\t\tif ((Validator.isNotNull(entryClassName)) &&\n\t\t\t\t\t(entryClassPK > 0)) {\n\n\t\t\t\t\tRatingsStats stats = RatingsStatsLocalServiceUtil.getStats(\n\t\t\t\t\t\tentryClassName, entryClassPK);\n\n\t\t\t\t\tratings = stats.getTotalScore();\n\t\t\t\t}\n\n\t\t\t\tdouble score = results.score(i);\n\n\t\t\t\taddSearchResult(\n\t\t\t\t\troot, resultGroupId, title, url, modifedDate, content, tags,\n\t\t\t\t\tratings, score, format);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Return\\n\" + doc.asXML());\n\t\t\t}\n\n\t\t\treturn doc.asXML();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SearchException(e);\n\t\t}\n\t}","id":78651,"modified_method":"public String search(\n\t\t\tHttpServletRequest request, long groupId, long userId,\n\t\t\tString keywords, int startPage, int itemsPerPage, String format)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tint start = (startPage * itemsPerPage) - itemsPerPage;\n\t\t\tint end = startPage * itemsPerPage;\n\n\t\t\tSearchContext searchContext = SearchContextFactory.getInstance(\n\t\t\t\trequest);\n\n\t\t\tsearchContext.setGroupIds(new long[] {groupId});\n\t\t\tsearchContext.setEnd(end);\n\t\t\tsearchContext.setKeywords(keywords);\n\t\t\tsearchContext.setScopeStrict(false);\n\t\t\tsearchContext.setStart(start);\n\t\t\tsearchContext.setUserId(userId);\n\n\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tthemeDisplay.getCompanyId(), getPortletId());\n\n\t\t\tIndexer indexer = portlet.getIndexerInstance();\n\n\t\t\tHits results = indexer.search(searchContext);\n\n\t\t\tString[] queryTerms = results.getQueryTerms();\n\n\t\t\tint total = results.getLength();\n\n\t\t\tObject[] values = addSearchResults(\n\t\t\t\tqueryTerms, keywords, startPage, itemsPerPage, total, start,\n\t\t\t\tgetTitle(keywords), getSearchPath(), format, themeDisplay);\n\n\t\t\tcom.liferay.portal.kernel.xml.Document doc =\n\t\t\t\t(com.liferay.portal.kernel.xml.Document)values[0];\n\t\t\tElement root = (Element)values[1];\n\n\t\t\tfor (int i = 0; i < results.getDocs().length; i++) {\n\t\t\t\tDocument result = results.doc(i);\n\n\t\t\t\tString portletId = result.get(Field.PORTLET_ID);\n\n\t\t\t\tString snippet = results.snippet(i);\n\n\t\t\t\tlong resultGroupId = GetterUtil.getLong(\n\t\t\t\t\tresult.get(Field.GROUP_ID));\n\n\t\t\t\tPortletURL portletURL = getPortletURL(\n\t\t\t\t\trequest, portletId, resultGroupId);\n\n\t\t\t\tSummary summary = getSummary(\n\t\t\t\t\tindexer, result, snippet, portletURL);\n\n\t\t\t\tString title = summary.getTitle();\n\t\t\t\tString url = getURL(\n\t\t\t\t\tthemeDisplay, resultGroupId, result, portletURL);\n\t\t\t\tDate modifedDate = result.getDate(Field.MODIFIED);\n\t\t\t\tString content = summary.getContent();\n\n\t\t\t\tString[] tags = new String[0];\n\n\t\t\t\tField assetTagNamesField = result.getFields().get(\n\t\t\t\t\tField.ASSET_TAG_NAMES);\n\n\t\t\t\tif (assetTagNamesField != null) {\n\t\t\t\t\ttags = assetTagNamesField.getValues();\n\t\t\t\t}\n\n\t\t\t\tdouble ratings = 0.0;\n\n\t\t\t\tString entryClassName = result.get(Field.ENTRY_CLASS_NAME);\n\t\t\t\tlong entryClassPK = GetterUtil.getLong(\n\t\t\t\t\tresult.get(Field.ENTRY_CLASS_PK));\n\n\t\t\t\tif ((Validator.isNotNull(entryClassName)) &&\n\t\t\t\t\t(entryClassPK > 0)) {\n\n\t\t\t\t\tRatingsStats stats = RatingsStatsLocalServiceUtil.getStats(\n\t\t\t\t\t\tentryClassName, entryClassPK);\n\n\t\t\t\t\tratings = stats.getTotalScore();\n\t\t\t\t}\n\n\t\t\t\tdouble score = results.score(i);\n\n\t\t\t\taddSearchResult(\n\t\t\t\t\troot, resultGroupId, entryClassName, entryClassPK, title,\n\t\t\t\t\turl, modifedDate, content, tags, ratings, score, format);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Return\\n\" + doc.asXML());\n\t\t\t}\n\n\t\t\treturn doc.asXML();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SearchException(e);\n\t\t}\n\t}","commit_id":"64f0a104c454bb1002100c517b37cf1b0786b655","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getLayoutURL(ThemeDisplay themeDisplay, String articleId)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tList<JournalContentSearch> contentSearches =\n\t\t\tJournalContentSearchLocalServiceUtil.getArticleContentSearches(\n\t\t\t\tarticleId);\n\n\t\tfor (JournalContentSearch contentSearch : contentSearches) {\n\t\t\tif (LayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, contentSearch.getGroupId(),\n\t\t\t\t\tcontentSearch.isPrivateLayout(),\n\t\t\t\t\tcontentSearch.getLayoutId(), ActionKeys.VIEW)) {\n\n\t\t\t\tif (contentSearch.isPrivateLayout()) {\n\t\t\t\t\tif (!GroupLocalServiceUtil.hasUserGroup(\n\t\t\t\t\t\t\tthemeDisplay.getUserId(),\n\t\t\t\t\t\t\tcontentSearch.getGroupId())) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tLayout hitLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tcontentSearch.getGroupId(), contentSearch.isPrivateLayout(),\n\t\t\t\t\tcontentSearch.getLayoutId());\n\n\t\t\t\tString url = PortalUtil.getLayoutURL(hitLayout, themeDisplay);\n\n\t\t\t\turl = HttpUtil.setParameter(url, \"articleId\", articleId);\n\n\t\t\t\treturn url;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","id":78652,"modified_method":"protected String getLayoutURL(ThemeDisplay themeDisplay, String articleId)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tList<JournalContentSearch> contentSearches =\n\t\t\tJournalContentSearchLocalServiceUtil.getArticleContentSearches(\n\t\t\t\tarticleId);\n\n\t\tfor (JournalContentSearch contentSearch : contentSearches) {\n\t\t\tif (LayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, contentSearch.getGroupId(),\n\t\t\t\t\tcontentSearch.isPrivateLayout(),\n\t\t\t\t\tcontentSearch.getLayoutId(), ActionKeys.VIEW)) {\n\n\t\t\t\tif (contentSearch.isPrivateLayout()) {\n\t\t\t\t\tif (!GroupLocalServiceUtil.hasUserGroup(\n\t\t\t\t\t\t\tthemeDisplay.getUserId(),\n\t\t\t\t\t\t\tcontentSearch.getGroupId())) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tLayout hitLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tcontentSearch.getGroupId(), contentSearch.isPrivateLayout(),\n\t\t\t\t\tcontentSearch.getLayoutId());\n\n\t\t\t\treturn PortalUtil.getLayoutURL(hitLayout, themeDisplay);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"64f0a104c454bb1002100c517b37cf1b0786b655","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getURL(\n\t\t\tThemeDisplay themeDisplay, long groupId, Document result,\n\t\t\tPortletURL portletURL)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tLayout layout = themeDisplay.getLayout();\n\n\t\tString articleId = result.get(Field.ENTRY_CLASS_PK);\n\t\tString version = result.get(\"version\");\n\n\t\tList<Long> hitLayoutIds =\n\t\t\tJournalContentSearchLocalServiceUtil.getLayoutIds(\n\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(), articleId);\n\n\t\tfor (Long hitLayoutId : hitLayoutIds) {\n\t\t\tif (LayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout.getGroupId(),\n\t\t\t\t\tlayout.isPrivateLayout(), hitLayoutId, ActionKeys.VIEW)) {\n\n\t\t\t\tLayout hitLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\thitLayoutId.longValue());\n\n\t\t\t\tString url = PortalUtil.getLayoutURL(hitLayout, themeDisplay);\n\n\t\t\t\turl = HttpUtil.setParameter(url, \"articleId\", articleId);\n\n\t\t\t\treturn url;\n\t\t\t}\n\t\t}\n\n\t\tString layoutURL = getLayoutURL(themeDisplay, articleId);\n\n\t\tif (layoutURL != null) {\n\t\t\treturn layoutURL;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(themeDisplay.getPathMain());\n\t\tsb.append(\"/journal/view_article_content?groupId=\");\n\t\tsb.append(groupId);\n\t\tsb.append(\"&articleId=\");\n\t\tsb.append(articleId);\n\t\tsb.append(\"&version=\");\n\t\tsb.append(version);\n\n\t\treturn sb.toString();\n\t}","id":78653,"modified_method":"protected String getURL(\n\t\t\tThemeDisplay themeDisplay, long groupId, Document result,\n\t\t\tPortletURL portletURL)\n\t\tthrows Exception {\n\n\t\tPermissionChecker permissionChecker =\n\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\tLayout layout = themeDisplay.getLayout();\n\n\t\tString articleId = result.get(Field.ENTRY_CLASS_PK);\n\t\tString version = result.get(\"version\");\n\n\t\tList<Long> hitLayoutIds =\n\t\t\tJournalContentSearchLocalServiceUtil.getLayoutIds(\n\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(), articleId);\n\n\t\tfor (Long hitLayoutId : hitLayoutIds) {\n\t\t\tif (LayoutPermissionUtil.contains(\n\t\t\t\t\tpermissionChecker, layout.getGroupId(),\n\t\t\t\t\tlayout.isPrivateLayout(), hitLayoutId, ActionKeys.VIEW)) {\n\n\t\t\t\tLayout hitLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tlayout.getGroupId(), layout.isPrivateLayout(),\n\t\t\t\t\thitLayoutId.longValue());\n\n\t\t\t\treturn PortalUtil.getLayoutURL(hitLayout, themeDisplay);\n\t\t\t}\n\t\t}\n\n\t\tString layoutURL = getLayoutURL(themeDisplay, articleId);\n\n\t\tif (layoutURL != null) {\n\t\t\treturn layoutURL;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(7);\n\n\t\tsb.append(themeDisplay.getPathMain());\n\t\tsb.append(\"/journal/view_article_content?groupId=\");\n\t\tsb.append(groupId);\n\t\tsb.append(\"&articleId=\");\n\t\tsb.append(articleId);\n\t\tsb.append(\"&version=\");\n\t\tsb.append(version);\n\n\t\treturn sb.toString();\n\t}","commit_id":"64f0a104c454bb1002100c517b37cf1b0786b655","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/** {@inheritDoc} */\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final List<ResourceRoot> resourceRoots = DeploymentUtils.allResourceRoots(deploymentUnit);\n\n        if (!DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {\n            return;\n        }\n\n        final DeploymentUnit parent = deploymentUnit.getParent();\n        final DeploymentUnit topLevelDeployment = parent == null ? deploymentUnit : parent;\n        final VirtualFile toplevelRoot = topLevelDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final ExternalModuleService externalModuleService = topLevelDeployment.getAttachment(Attachments.EXTERNAL_MODULE_SERVICE);\n\n        final Map<VirtualFile, ResourceRoot> files = new HashMap<VirtualFile, ResourceRoot>();\n        for (ResourceRoot resourceRoot : resourceRoots) {\n            files.put(resourceRoot.getRoot(), resourceRoot);\n        }\n        final Deque<ResourceRoot> libResourceRoots = new ArrayDeque<ResourceRoot>();\n        // scan /lib entries for class-path items\n        for (ResourceRoot resourceRoot : resourceRoots) {\n            if (ModuleRootMarker.isModuleRoot(resourceRoot)) {\n                libResourceRoots.add(resourceRoot);\n            }\n        }\n        while (!libResourceRoots.isEmpty()) {\n            final ResourceRoot resourceRoot = libResourceRoots.pop();\n            final String[] items = getClassPathEntries(resourceRoot);\n            for (String item : items) {\n                final VirtualFile classPathFile = resourceRoot.getRoot().getParent().getChild(item);\n                if (!classPathFile.exists()) {\n                    throw new DeploymentUnitProcessingException(\"Class Path entry \" + item + \" in \" + resourceRoot.getRoot()\n                            + \"  not found. \");\n                }\n                if (isInside(classPathFile, toplevelRoot)) {\n                    if (!files.containsKey(classPathFile)) {\n                        throw new DeploymentUnitProcessingException(\"Class Path entry \" + item + \" in \"\n                                + resourceRoot.getRoot() + \"  does not point to a valid jar for a Class-Path reference.\");\n                    } else {\n                        final ResourceRoot target = files.get(classPathFile);\n\n                        if (SubDeploymentMarker.isSubDeployment(target)) {\n                            // for now we do not allow Class-Path references to subdeployments\n                            throw new DeploymentUnitProcessingException(\"Class Path entry \" + item + \" in \"\n                                    + resourceRoot.getRoot() + \"  may not point to a sub deployment.\");\n                        } else if (!ModuleRootMarker.isModuleRoot(target)) {\n                            // otherwise just add it to the lib dir\n                            ModuleRootMarker.mark(target);\n                            libResourceRoots.push(target);\n                            log.debugf(\"Resource %s added to logical lib directory due to Class-Path entry in %s\",\n                                    classPathFile, target.getRoot());\n                        }\n                        // otherwise it is already part of lib, so we leave it alone for now\n                    }\n                } else {\n                    // add the external module reference to the ear\n                    ModuleIdentifier moduleIdentifier = externalModuleService.addExternalModule(classPathFile);\n                    deploymentUnit.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, moduleIdentifier);\n                    log.debugf(\"Resource %s added as external jar %s\", classPathFile, resourceRoot.getRoot());\n                }\n            }\n        }\n    }","id":78654,"modified_method":"/** {@inheritDoc} */\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final List<ResourceRoot> resourceRoots = DeploymentUtils.allResourceRoots(deploymentUnit);\n\n        if (!DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {\n            return;\n        }\n\n        final DeploymentUnit parent = deploymentUnit.getParent();\n        final DeploymentUnit topLevelDeployment = parent == null ? deploymentUnit : parent;\n        final VirtualFile toplevelRoot = topLevelDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final ExternalModuleService externalModuleService = topLevelDeployment.getAttachment(Attachments.EXTERNAL_MODULE_SERVICE);\n\n        final Map<VirtualFile, ResourceRoot> files = new HashMap<VirtualFile, ResourceRoot>();\n        for (ResourceRoot resourceRoot : resourceRoots) {\n            files.put(resourceRoot.getRoot(), resourceRoot);\n        }\n        final Deque<ResourceRoot> libResourceRoots = new ArrayDeque<ResourceRoot>();\n        // scan /lib entries for class-path items\n        for (ResourceRoot resourceRoot : resourceRoots) {\n            if (ModuleRootMarker.isModuleRoot(resourceRoot) && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                libResourceRoots.add(resourceRoot);\n            }\n        }\n        while (!libResourceRoots.isEmpty()) {\n            final ResourceRoot resourceRoot = libResourceRoots.pop();\n            final String[] items = getClassPathEntries(resourceRoot);\n            for (String item : items) {\n                final VirtualFile classPathFile = resourceRoot.getRoot().getParent().getChild(item);\n                if (!classPathFile.exists()) {\n                    log.warnf(\"Class Path entry %s in %s not found. \", item, resourceRoot.getRoot());\n                }\n                else if (isInside(classPathFile, toplevelRoot)) {\n                    if (!files.containsKey(classPathFile)) {\n                        log.warnf(\"Class Path entry %s in %s does not point to a valid jar for a Class-Path reference.\",item,resourceRoot.getRoot());\n                    } else {\n                        final ResourceRoot target = files.get(classPathFile);\n\n                        if (SubDeploymentMarker.isSubDeployment(target)) {\n                            // for now we do not allow Class-Path references to subdeployments\n                            log.warnf(\"Class Path entry  in \"\n                                    + resourceRoot.getRoot() + \"  may not point to a sub deployment.\");\n                        } else if (!ModuleRootMarker.isModuleRoot(target)) {\n                            // otherwise just add it to the lib dir\n                            ModuleRootMarker.mark(target);\n                            libResourceRoots.push(target);\n                            log.debugf(\"Resource %s added to logical lib directory due to Class-Path entry in %s\",\n                                    classPathFile, target.getRoot());\n                        }\n                        // otherwise it is already part of lib, so we leave it alone for now\n                    }\n                } else if(item.startsWith(\"/\")) {\n                    ModuleIdentifier moduleIdentifier = externalModuleService.addExternalModule(item);\n                    deploymentUnit.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, moduleIdentifier);\n                    log.debugf(\"Resource %s added as external jar %s\", classPathFile, resourceRoot.getRoot());\n                } else {\n                    //this is a dep on another deployment\n                    deploymentUnit.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,ModuleIdentifier.create(ServiceModuleLoader.MODULE_PREFIX +  classPathFile.getName()));\n                }\n            }\n        }\n    }","commit_id":"4b8a7e68597a766f111d14fd9ec7acbf84c17036","url":"https://github.com/wildfly/wildfly"},{"original_method":"public ModuleIdentifier addExternalModule(VirtualFile externalModule) {\n        ModuleIdentifier identifier = ModuleIdentifier.create(EXTERNAL_MODULE_PREFIX + externalModule.getPathName());\n        ServiceName serviceName = ServiceModuleLoader.moduleSpecServiceName(identifier);\n        ServiceController<?> controller = serviceContainer.getService(serviceName);\n        if (controller == null) {\n            try {\n                ExternalModuleSpecService service = new ExternalModuleSpecService(identifier, externalModule.getPhysicalFile());\n                serviceContainer.addService(serviceName, service).setInitialMode(Mode.ON_DEMAND).install();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return identifier;\n    }","id":78655,"modified_method":"public ModuleIdentifier addExternalModule(String externalModule) {\n        ModuleIdentifier identifier = ModuleIdentifier.create(EXTERNAL_MODULE_PREFIX + externalModule);\n        ServiceName serviceName = ServiceModuleLoader.moduleSpecServiceName(identifier);\n        ServiceController<?> controller = serviceContainer.getService(serviceName);\n        if (controller == null) {\n            ExternalModuleSpecService service = new ExternalModuleSpecService(identifier, new File(externalModule));\n            serviceContainer.addService(serviceName, service).setInitialMode(Mode.ON_DEMAND).install();\n        }\n        return identifier;\n    }","commit_id":"4b8a7e68597a766f111d14fd9ec7acbf84c17036","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final List<ResourceRoot> resourceRoots = DeploymentUtils.allResourceRoots(deploymentUnit);\n\n        final DeploymentUnit parent = deploymentUnit.getParent();\n        final DeploymentUnit topLevelDeployment = parent == null ? deploymentUnit : parent;\n        final VirtualFile toplevelRoot = topLevelDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final VirtualFile deploymentDirRoot = toplevelRoot.getParent();\n        final ExternalModuleService externalModuleService = topLevelDeployment.getAttachment(Attachments.EXTERNAL_MODULE_SERVICE);\n        final List<AdditionalModuleSpecification> additionalModuleList = topLevelDeployment.getAttachment(Attachments.ADDITIONAL_MODULES);\n        final List<ResourceRoot> topLevelResourceRoots = topLevelDeployment.getAttachment(Attachments.RESOURCE_ROOTS);\n\n        // build a map of the additional module locations\n        final Map<VirtualFile, AdditionalModuleSpecification> additionalModules;\n        if (additionalModuleList == null) {\n            additionalModules = Collections.emptyMap();\n        } else {\n            additionalModules = new HashMap<VirtualFile, AdditionalModuleSpecification>();\n            for (AdditionalModuleSpecification module : additionalModuleList) {\n                for (ResourceRoot additionalModuleResourceRoot : module.getResourceRoots()) {\n                    additionalModules.put(additionalModuleResourceRoot.getRoot(), module);\n                }\n            }\n        }\n        // build a set of ear/lib jars. references to these classes can be ignored as they are already on the class-path\n        final Set<VirtualFile> earLibJars = new HashSet<VirtualFile>();\n        if (deploymentUnit.getParent() != null && topLevelResourceRoots != null) {\n            for (ResourceRoot resourceRoot : topLevelResourceRoots) {\n                if (ModuleRootMarker.isModuleRoot(resourceRoot) && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                    earLibJars.add(resourceRoot.getRoot());\n                }\n            }\n        }\n\n        for (ResourceRoot resourceRoot : resourceRoots) {\n            // if this is an ear/lib resource root it has already been handled\n            if (deploymentUnit.getParent() == null && ModuleRootMarker.isModuleRoot(resourceRoot)\n                    && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                continue;\n            }\n            // if this resource root represents an additional module then we need\n            // to add the class path entry to the additional module\n            final Attachable target;\n            if (additionalModules.containsKey(resourceRoot.getRoot())) {\n                target = additionalModules.get(resourceRoot.getRoot());\n            } else {\n                target = deploymentUnit;\n            }\n            final String[] items = getClassPathEntries(resourceRoot);\n            for (String item : items) {\n                final VirtualFile classPathFile = resourceRoot.getRoot().getParent().getChild(item);\n                if (isInside(classPathFile, toplevelRoot)) {\n                    if (earLibJars.contains(classPathFile)) {\n                        log.debugf(\"Class-Path entry %s in %s ignored, as target is in or referenced by /lib\", classPathFile,\n                                resourceRoot.getRoot());\n                        continue; // we already have access to ear/lib\n                    } else if(additionalModules.containsKey(classPathFile)) {\n                        target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, additionalModules.get(classPathFile)\n                                .getModuleIdentifier());\n                    } else {\n                        log.warn(\"Class Path entry \" + item + \" in \"\n                                + resourceRoot.getRoot() + \"  does not point to a valid jar for a Class-Path reference.\");\n                    }\n                } else if(!item.startsWith(\"/\") && classPathFile.getParent().isRoot()) {\n                    //this is a dep on another deployment\n                    target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,ModuleIdentifier.create(ServiceModuleLoader.MODULE_PREFIX + classPathFile.getName()));\n                } else if(item.startsWith(\"/\")) {\n                    ModuleIdentifier moduleIdentifier = externalModuleService.addExternalModule(classPathFile);\n                    target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, moduleIdentifier);\n                    log.debugf(\"Resource %s added as external jar %s\", classPathFile, resourceRoot.getRoot());\n                } else {\n                    log.warn(\"Class Path entry \" + item + \" in \"\n                                + resourceRoot.getRoot() + \"  does not point to a valid jar for a Class-Path reference.\");\n                }\n            }\n        }\n    }","id":78656,"modified_method":"/** {@inheritDoc} */\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final List<ResourceRoot> resourceRoots = DeploymentUtils.allResourceRoots(deploymentUnit);\n\n        final DeploymentUnit parent = deploymentUnit.getParent();\n        final DeploymentUnit topLevelDeployment = parent == null ? deploymentUnit : parent;\n        final VirtualFile topLevelRoot = topLevelDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final ExternalModuleService externalModuleService = topLevelDeployment.getAttachment(Attachments.EXTERNAL_MODULE_SERVICE);\n        final List<AdditionalModuleSpecification> additionalModuleList = topLevelDeployment.getAttachment(Attachments.ADDITIONAL_MODULES);\n        final List<ResourceRoot> topLevelResourceRoots = topLevelDeployment.getAttachment(Attachments.RESOURCE_ROOTS);\n\n        // build a map of the additional module locations\n        final Map<VirtualFile, AdditionalModuleSpecification> additionalModules;\n        if (additionalModuleList == null) {\n            additionalModules = Collections.emptyMap();\n        } else {\n            additionalModules = new HashMap<VirtualFile, AdditionalModuleSpecification>();\n            for (AdditionalModuleSpecification module : additionalModuleList) {\n                for (ResourceRoot additionalModuleResourceRoot : module.getResourceRoots()) {\n                    additionalModules.put(additionalModuleResourceRoot.getRoot(), module);\n                }\n            }\n        }\n        // build a set of ear/lib jars. references to these classes can be ignored as they are already on the class-path\n        final Set<VirtualFile> earLibJars = new HashSet<VirtualFile>();\n        if (deploymentUnit.getParent() != null && topLevelResourceRoots != null) {\n            for (ResourceRoot resourceRoot : topLevelResourceRoots) {\n                if (ModuleRootMarker.isModuleRoot(resourceRoot) && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                    earLibJars.add(resourceRoot.getRoot());\n                }\n            }\n        }\n\n        for (ResourceRoot resourceRoot : resourceRoots) {\n            // if this is an ear/lib resource root it has already been handled\n            if (deploymentUnit.getParent() == null && ModuleRootMarker.isModuleRoot(resourceRoot)\n                    && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                continue;\n            }\n            // if this resource root represents an additional module then we need\n            // to add the class path entry to the additional module\n            final Attachable target;\n            if (additionalModules.containsKey(resourceRoot.getRoot())) {\n                target = additionalModules.get(resourceRoot.getRoot());\n            } else {\n                target = deploymentUnit;\n            }\n            final String[] items = getClassPathEntries(resourceRoot);\n            for (String item : items) {\n                final VirtualFile classPathFile = resourceRoot.getRoot().getParent().getChild(item);\n                if (isInside(classPathFile, topLevelRoot)) {\n                    if (earLibJars.contains(classPathFile)) {\n                        log.debugf(\"Class-Path entry %s in %s ignored, as target is in or referenced by /lib\", classPathFile,\n                                resourceRoot.getRoot());\n                        continue; // we already have access to ear/lib\n                    } else if(additionalModules.containsKey(classPathFile)) {\n                        target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, additionalModules.get(classPathFile)\n                                .getModuleIdentifier());\n                    } else {\n                        log.warn(\"Class Path entry \" + item + \" in \"\n                                + resourceRoot.getRoot() + \"  does not point to a valid jar for a Class-Path reference.\");\n                    }\n                }  else if(item.startsWith(\"/\")) {\n                    ModuleIdentifier moduleIdentifier = externalModuleService.addExternalModule(item);\n                    target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, moduleIdentifier);\n                    log.debugf(\"Resource %s added as external jar %s\", classPathFile, resourceRoot.getRoot());\n                } else {\n                    //this is a dep on another deployment\n                    target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,ModuleIdentifier.create(ServiceModuleLoader.MODULE_PREFIX + classPathFile.getName()));\n                }\n            }\n        }\n    }","commit_id":"4b8a7e68597a766f111d14fd9ec7acbf84c17036","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        BeansXmlParser parser = new BeansXmlParser();\n\n        Set<BeanArchiveMetadata> beanArchiveMetadata = new HashSet<BeanArchiveMetadata>();\n        ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        AttachmentList<ResourceRoot> structure = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        if (deploymentRoot == null) {\n            return;\n        }\n\n        ResourceRoot classesRoot = null;\n\n        if (structure != null) {\n            for (ResourceRoot resourceRoot : structure) {\n                if (ModuleRootMarker.isModuleRoot(resourceRoot)) {\n                    if (resourceRoot.getRootName().equals(\"classes\")) {\n                        // hack for dealing with war modules\n                        classesRoot = resourceRoot;\n                    } else {\n                        VirtualFile beansXml = resourceRoot.getRoot().getChild(META_INF_BEANS_XML);\n                        if (beansXml.exists() && beansXml.isFile()) {\n                            log.debugf(\"Found beans.xml: %s\", beansXml.toString());\n                            beanArchiveMetadata.add(new BeanArchiveMetadata(beansXml, resourceRoot, parseBeansXml(beansXml,\n                                    parser), false));\n                        }\n                    }\n                }\n            }\n        }\n\n        if (DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            // look for WEB-INF/beans.xml\n            final VirtualFile rootBeansXml = deploymentRoot.getRoot().getChild(WEB_INF_BEANS_XML);\n            if (rootBeansXml.exists() && rootBeansXml.isFile()) {\n                log.debugf(\"Found beans.xml: %s\", rootBeansXml);\n                beanArchiveMetadata.add(new BeanArchiveMetadata(rootBeansXml, classesRoot, parseBeansXml(rootBeansXml, parser),true));\n            }\n        } else if (!DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {\n            final VirtualFile rootBeansXml = deploymentRoot.getRoot().getChild(META_INF_BEANS_XML);\n            if (rootBeansXml.exists() && rootBeansXml.isFile()) {\n                log.debugf(\"Found beans.xml: %s\", rootBeansXml.toString());\n                beanArchiveMetadata.add(new BeanArchiveMetadata(rootBeansXml, deploymentRoot,parseBeansXml(rootBeansXml, parser), true));\n            }\n        }\n\n        if (!beanArchiveMetadata.isEmpty()) {\n            WeldDeploymentMetadata deploymentMetadata = new WeldDeploymentMetadata(beanArchiveMetadata);\n            deploymentUnit.putAttachment(WeldDeploymentMetadata.ATTACHMENT_KEY, deploymentMetadata);\n            // mark the deployment as requiring CDI integration\n            WeldDeploymentMarker.mark(deploymentUnit);\n            if (deploymentUnit.getParent() != null) {\n                WeldDeploymentMarker.mark(deploymentUnit.getParent());\n            }\n        }\n    }","id":78657,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        BeansXmlParser parser = new BeansXmlParser();\n\n        Set<BeanArchiveMetadata> beanArchiveMetadata = new HashSet<BeanArchiveMetadata>();\n        ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        AttachmentList<ResourceRoot> structure = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        if (deploymentRoot == null) {\n            return;\n        }\n\n        ResourceRoot classesRoot = null;\n\n        if (structure != null) {\n            for (ResourceRoot resourceRoot : structure) {\n                if (ModuleRootMarker.isModuleRoot(resourceRoot) && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                    if (resourceRoot.getRootName().equals(\"classes\")) {\n                        // hack for dealing with war modules\n                        classesRoot = resourceRoot;\n                    } else {\n                        VirtualFile beansXml = resourceRoot.getRoot().getChild(META_INF_BEANS_XML);\n                        if (beansXml.exists() && beansXml.isFile()) {\n                            log.debugf(\"Found beans.xml: %s\", beansXml.toString());\n                            beanArchiveMetadata.add(new BeanArchiveMetadata(beansXml, resourceRoot, parseBeansXml(beansXml,\n                                    parser), false));\n                        }\n                    }\n                }\n            }\n        }\n\n        if (DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            // look for WEB-INF/beans.xml\n            final VirtualFile rootBeansXml = deploymentRoot.getRoot().getChild(WEB_INF_BEANS_XML);\n            if (rootBeansXml.exists() && rootBeansXml.isFile()) {\n                log.debugf(\"Found beans.xml: %s\", rootBeansXml);\n                beanArchiveMetadata.add(new BeanArchiveMetadata(rootBeansXml, classesRoot, parseBeansXml(rootBeansXml, parser),true));\n            }\n        } else if (!DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {\n            final VirtualFile rootBeansXml = deploymentRoot.getRoot().getChild(META_INF_BEANS_XML);\n            if (rootBeansXml.exists() && rootBeansXml.isFile()) {\n                log.debugf(\"Found beans.xml: %s\", rootBeansXml.toString());\n                beanArchiveMetadata.add(new BeanArchiveMetadata(rootBeansXml, deploymentRoot,parseBeansXml(rootBeansXml, parser), true));\n            }\n        }\n\n        if (!beanArchiveMetadata.isEmpty()) {\n            WeldDeploymentMetadata deploymentMetadata = new WeldDeploymentMetadata(beanArchiveMetadata);\n            deploymentUnit.putAttachment(WeldDeploymentMetadata.ATTACHMENT_KEY, deploymentMetadata);\n            // mark the deployment as requiring CDI integration\n            WeldDeploymentMarker.mark(deploymentUnit);\n            if (deploymentUnit.getParent() != null) {\n                WeldDeploymentMarker.mark(deploymentUnit.getParent());\n            }\n        }\n    }","commit_id":"e1f7ec738ff6619028e65f89736d8e78c14437e6","url":"https://github.com/wildfly/wildfly"},{"original_method":"public synchronized void deploy()  throws DuplicateDeploymentNameException, IOException, ExecutionException, InterruptedException  {\n        DeploymentPlanBuilder builder = manager.newDeploymentPlan();\n        for (AbstractDeployment deployment : deployments) {\n            builder = deployment.addDeployment(manager, builder);\n        }\n        manager.execute(builder.build()).get();\n\n        for (AbstractDeployment deployment : deployments) {\n            deployment.deployed = true;\n        }\n    }","id":78658,"modified_method":"public synchronized void deploy()  throws DuplicateDeploymentNameException, IOException, ExecutionException, InterruptedException  {\n        DeploymentPlanBuilder builder = manager.newDeploymentPlan();\n        for (AbstractDeployment deployment : deployments) {\n            builder = deployment.addDeployment(manager, builder);\n        }\n        try {\n            manager.execute(builder.build()).get();\n        } finally {\n            for (AbstractDeployment deployment : deployments) {\n                deployment.deployed = true;\n            }\n        }\n    }","commit_id":"e1f7ec738ff6619028e65f89736d8e78c14437e6","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final List<ResourceRoot> resourceRoots = DeploymentUtils.allResourceRoots(deploymentUnit);\n\n        final DeploymentUnit parent = deploymentUnit.getParent();\n        final DeploymentUnit topLevelDeployment = parent == null ? deploymentUnit : parent;\n        final VirtualFile topLevelRoot = topLevelDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final ExternalModuleService externalModuleService = topLevelDeployment.getAttachment(Attachments.EXTERNAL_MODULE_SERVICE);\n        final List<AdditionalModuleSpecification> additionalModuleList = topLevelDeployment.getAttachment(Attachments.ADDITIONAL_MODULES);\n        final List<ResourceRoot> topLevelResourceRoots = topLevelDeployment.getAttachment(Attachments.RESOURCE_ROOTS);\n        final List<DeploymentUnit> subDeployments;\n        if(deploymentUnit.getParent() == null) {\n            subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n        } else {\n            subDeployments = deploymentUnit.getParent().getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n        }\n        final Map<VirtualFile,ModuleIdentifier> subDeploymentModules = new HashMap<VirtualFile,ModuleIdentifier>();\n        for(DeploymentUnit deployment : subDeployments) {\n            final ResourceRoot root = deployment.getAttachment(Attachments.DEPLOYMENT_ROOT);\n            final ModuleIdentifier identifier = deployment.getAttachment(Attachments.MODULE_IDENTIFIER);\n            if(root == null || identifier == null) {\n                continue;\n            }\n            subDeploymentModules.put(root.getRoot(),identifier);\n        }\n\n        // build a map of the additional module locations\n        final Map<VirtualFile, AdditionalModuleSpecification> additionalModules;\n        if (additionalModuleList == null) {\n            additionalModules = Collections.emptyMap();\n        } else {\n            additionalModules = new HashMap<VirtualFile, AdditionalModuleSpecification>();\n            for (AdditionalModuleSpecification module : additionalModuleList) {\n                for (ResourceRoot additionalModuleResourceRoot : module.getResourceRoots()) {\n                    additionalModules.put(additionalModuleResourceRoot.getRoot(), module);\n                }\n            }\n        }\n        // build a set of ear/lib jars. references to these classes can be ignored as they are already on the class-path\n        final Set<VirtualFile> earLibJars = new HashSet<VirtualFile>();\n        if (deploymentUnit.getParent() != null && topLevelResourceRoots != null) {\n            for (ResourceRoot resourceRoot : topLevelResourceRoots) {\n                if (ModuleRootMarker.isModuleRoot(resourceRoot) && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                    earLibJars.add(resourceRoot.getRoot());\n                }\n            }\n        }\n\n        for (ResourceRoot resourceRoot : resourceRoots) {\n            // if this is an ear/lib resource root it has already been handled\n            if (deploymentUnit.getParent() == null && ModuleRootMarker.isModuleRoot(resourceRoot)\n                    && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                continue;\n            }\n            // if this resource root represents an additional module then we need\n            // to add the class path entry to the additional module\n            final Attachable target;\n            if (additionalModules.containsKey(resourceRoot.getRoot())) {\n                target = additionalModules.get(resourceRoot.getRoot());\n            } else {\n                target = deploymentUnit;\n            }\n            final String[] items = getClassPathEntries(resourceRoot);\n            for (String item : items) {\n                final VirtualFile classPathFile = resourceRoot.getRoot().getParent().getChild(item);\n                if (isInside(classPathFile, topLevelRoot)) {\n                    if (earLibJars.contains(classPathFile)) {\n                        log.debugf(\"Class-Path entry %s in %s ignored, as target is in or referenced by /lib\", classPathFile,\n                                resourceRoot.getRoot());\n                        continue; // we already have access to ear/lib\n                    } else if (additionalModules.containsKey(classPathFile)) {\n                        target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, additionalModules.get(classPathFile)\n                                .getModuleIdentifier());\n                    } else if (subDeploymentModules.containsKey(classPathFile)) {\n                        target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, subDeploymentModules.get(classPathFile));\n                    } else {\n                        log.warn(\"Class Path entry \" + item + \" in \"\n                                + resourceRoot.getRoot() + \"  does not point to a valid jar for a Class-Path reference.\");\n                    }\n                }  else if(item.startsWith(\"/\")) {\n                    ModuleIdentifier moduleIdentifier = externalModuleService.addExternalModule(item);\n                    target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, moduleIdentifier);\n                    log.debugf(\"Resource %s added as external jar %s\", classPathFile, resourceRoot.getRoot());\n                } else {\n                    //this is a dep on another deployment\n                    target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,ModuleIdentifier.create(ServiceModuleLoader.MODULE_PREFIX + classPathFile.getName()));\n                }\n            }\n        }\n    }","id":78659,"modified_method":"/** {@inheritDoc} */\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final List<ResourceRoot> resourceRoots = DeploymentUtils.allResourceRoots(deploymentUnit);\n\n        final DeploymentUnit parent = deploymentUnit.getParent();\n        final DeploymentUnit topLevelDeployment = parent == null ? deploymentUnit : parent;\n        final VirtualFile topLevelRoot = topLevelDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        final ExternalModuleService externalModuleService = topLevelDeployment.getAttachment(Attachments.EXTERNAL_MODULE_SERVICE);\n        final List<AdditionalModuleSpecification> additionalModuleList = topLevelDeployment.getAttachment(Attachments.ADDITIONAL_MODULES);\n        final List<ResourceRoot> topLevelResourceRoots = topLevelDeployment.getAttachment(Attachments.RESOURCE_ROOTS);\n        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        final List<DeploymentUnit> subDeployments;\n        if(deploymentUnit.getParent() == null) {\n            subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n        } else {\n            subDeployments = deploymentUnit.getParent().getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n        }\n        final Map<VirtualFile,ModuleIdentifier> subDeploymentModules = new HashMap<VirtualFile,ModuleIdentifier>();\n        for(DeploymentUnit deployment : subDeployments) {\n            final ResourceRoot root = deployment.getAttachment(Attachments.DEPLOYMENT_ROOT);\n            final ModuleIdentifier identifier = deployment.getAttachment(Attachments.MODULE_IDENTIFIER);\n            if(root == null || identifier == null) {\n                continue;\n            }\n            subDeploymentModules.put(root.getRoot(),identifier);\n        }\n\n        // build a map of the additional module locations\n        final Map<VirtualFile, AdditionalModuleSpecification> additionalModules;\n        if (additionalModuleList == null) {\n            additionalModules = Collections.emptyMap();\n        } else {\n            additionalModules = new HashMap<VirtualFile, AdditionalModuleSpecification>();\n            for (AdditionalModuleSpecification module : additionalModuleList) {\n                for (ResourceRoot additionalModuleResourceRoot : module.getResourceRoots()) {\n                    additionalModules.put(additionalModuleResourceRoot.getRoot(), module);\n                }\n            }\n        }\n        // build a set of ear/lib jars. references to these classes can be ignored as they are already on the class-path\n        final Set<VirtualFile> earLibJars = new HashSet<VirtualFile>();\n        if (deploymentUnit.getParent() != null && topLevelResourceRoots != null) {\n            for (ResourceRoot resourceRoot : topLevelResourceRoots) {\n                if (ModuleRootMarker.isModuleRoot(resourceRoot) && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                    earLibJars.add(resourceRoot.getRoot());\n                }\n            }\n        }\n\n        for (ResourceRoot resourceRoot : resourceRoots) {\n            // if this is an ear/lib resource root it has already been handled\n            if (deploymentUnit.getParent() == null && ModuleRootMarker.isModuleRoot(resourceRoot)\n                    && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                continue;\n            }\n            if(SubDeploymentMarker.isSubDeployment(resourceRoot) && resourceRoot != deploymentRoot) {\n                continue;\n            }\n            // if this resource root represents an additional module then we need\n            // to add the class path entry to the additional module\n            final Attachable target;\n            if (additionalModules.containsKey(resourceRoot.getRoot())) {\n                target = additionalModules.get(resourceRoot.getRoot());\n            } else {\n                target = deploymentUnit;\n            }\n            final String[] items = getClassPathEntries(resourceRoot);\n            for (String item : items) {\n                final VirtualFile classPathFile = resourceRoot.getRoot().getParent().getChild(item);\n                if (isInside(classPathFile, topLevelRoot)) {\n                    if (earLibJars.contains(classPathFile)) {\n                        log.debugf(\"Class-Path entry %s in %s ignored, as target is in or referenced by /lib\", classPathFile,\n                                resourceRoot.getRoot());\n                        continue; // we already have access to ear/lib\n                    } else if (additionalModules.containsKey(classPathFile)) {\n                        target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, additionalModules.get(classPathFile)\n                                .getModuleIdentifier());\n                    } else if (subDeploymentModules.containsKey(classPathFile)) {\n                        target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, subDeploymentModules.get(classPathFile));\n                    } else {\n                        log.warn(\"Class Path entry \" + item + \" in \"\n                                + resourceRoot.getRoot() + \"  does not point to a valid jar for a Class-Path reference.\");\n                    }\n                }  else if(item.startsWith(\"/\")) {\n                    ModuleIdentifier moduleIdentifier = externalModuleService.addExternalModule(item);\n                    target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, moduleIdentifier);\n                    log.debugf(\"Resource %s added as external jar %s\", classPathFile, resourceRoot.getRoot());\n                } else {\n                    //this is a dep on another deployment\n                    target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES,ModuleIdentifier.create(ServiceModuleLoader.MODULE_PREFIX + classPathFile.getName()));\n                }\n            }\n        }\n    }","commit_id":"e1f7ec738ff6619028e65f89736d8e78c14437e6","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n            return;\n        }\n        // we only start weld on top level deployments\n        if (deploymentUnit.getParent() != null) {\n            return;\n        }\n\n        log.info(\"Starting Services for CDI deployment: \" + phaseContext.getDeploymentUnit().getName());\n\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n\n        final Set<BeanDeploymentModule> beanDeploymentModules = new HashSet<BeanDeploymentModule>();\n        final Set<BeanDeploymentModule> globalBeanDeploymentModules = new HashSet<BeanDeploymentModule>();\n        final Set<BeanDeploymentArchiveImpl> beanDeploymentArchives = new HashSet<BeanDeploymentArchiveImpl>();\n\n        // the root module only has access to itself. For most deployments this will be the only module\n        // for ear deployments this represents the ear/lib directory.\n        // ejb jar sub deployments have access to the root module and other ejb jars.\n        // war deployments have access to the root level and all ejb jars\n        final BeanDeploymentModule rootBeanDeploymentModule = deploymentUnit.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n\n        globalBeanDeploymentModules.add(rootBeanDeploymentModule);\n        beanDeploymentArchives.addAll(rootBeanDeploymentModule.getBeanDeploymentArchives());\n        final List<DeploymentUnit> subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n\n        final Set<ClassLoader> subDeploymentLoaders = new HashSet<ClassLoader>();\n\n        for (DeploymentUnit subDeployment : subDeployments) {\n            final Module subDeploymentModule = subDeployment.getAttachment(Attachments.MODULE);\n            if(module != null) {\n                subDeploymentLoaders.add(subDeploymentModule.getClassLoader());\n            }\n\n            final BeanDeploymentModule bdm = subDeployment.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n            if(bdm == null) {\n                continue;\n            }\n            // add the modules bdas to the global set of bdas\n            beanDeploymentArchives.addAll(bdm.getBeanDeploymentArchives());\n            if (bdm != null) {\n                beanDeploymentModules.add(bdm);\n                if (!PrivateSubDeploymentMarker.isPrivate(subDeployment)) {\n                    globalBeanDeploymentModules.add(bdm);\n                }\n            }\n        }\n\n        for (BeanDeploymentModule bdm : beanDeploymentModules) {\n            if (bdm == rootBeanDeploymentModule) {\n                continue; // the root module only has access to itself\n            }\n            // otherwise add all globally accessible modules to the module\n            // this will include the root module and ejb jars\n            bdm.addBeanDeploymentModules(globalBeanDeploymentModules);\n        }\n\n        final List<Metadata<Extension>> extensions = deploymentUnit.getAttachmentList(WeldAttachments.PORTABLE_EXTENSIONS);\n\n        final WeldDeployment deployment = new WeldDeployment(beanDeploymentArchives, extensions, module, subDeploymentLoaders);\n\n        final WeldContainer weldContainer = new WeldContainer(deployment, Environments.EE_INJECT);\n        //hook up validation service\n        //TODO: we need to change weld so this is a per-BDA service\n        final ValidatorFactory factory = deploymentUnit.getAttachment(BeanValidationAttachments.VALIDATOR_FACTORY);\n        weldContainer.addWeldService(ValidationServices.class,new WeldValidationServices(factory));\n\n        final EjbInjectionServices ejbInjectionServices = new WeldEjbInjectionServices(deploymentUnit.getServiceRegistry(),eeModuleDescription);\n        weldContainer.addWeldService(EjbInjectionServices.class,ejbInjectionServices);\n\n        weldContainer.addWeldService(EjbServices.class,new WeldEjbServices(deploymentUnit.getServiceRegistry()));\n\n\n        final JpaInjectionServices rootJpaInjectionServices = new WeldJpaInjectionServices(deploymentUnit,deploymentUnit.getServiceRegistry());\n        weldContainer.addWeldService(JpaInjectionServices.class,rootJpaInjectionServices);\n\n        final WeldService weldService = new WeldService(weldContainer);\n        final ServiceName weldServiceName = deploymentUnit.getServiceName().append(WeldService.SERVICE_NAME);\n        // add the weld service\n        final ServiceBuilder<WeldContainer> weldServiceBuilder = serviceTarget.addService(weldServiceName, weldService);\n\n        weldServiceBuilder.addDependencies(TCCLSingletonService.SERVICE_NAME);\n\n        installResourceInjectionService(serviceTarget, deploymentUnit, weldService, weldServiceBuilder);\n        installSecurityService(serviceTarget, deploymentUnit, weldService, weldServiceBuilder);\n        installTransactionService(serviceTarget, deploymentUnit, weldService, weldServiceBuilder);\n\n        weldServiceBuilder.install();\n\n    }","id":78660,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n            return;\n        }\n        // we only start weld on top level deployments\n        if (deploymentUnit.getParent() != null) {\n            return;\n        }\n\n        log.info(\"Starting Services for CDI deployment: \" + phaseContext.getDeploymentUnit().getName());\n\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final Set<BeanDeploymentModule> beanDeploymentModules = new HashSet<BeanDeploymentModule>();\n        final Set<BeanDeploymentArchiveImpl> beanDeploymentArchives = new HashSet<BeanDeploymentArchiveImpl>();\n        final Map<ModuleIdentifier,BeanDeploymentModule> bdmsByIdentifier = new HashMap<ModuleIdentifier,BeanDeploymentModule>();\n        final Map<ModuleIdentifier,ModuleSpecification> moduleSpecByIdentifier = new HashMap<ModuleIdentifier,ModuleSpecification>();\n\n        // the root module only has access to itself. For most deployments this will be the only module\n        // for ear deployments this represents the ear/lib directory.\n        // war and jar deployment visibility will depend on the dependencies that\n        // exist in the application, and mirror inter module dependencies\n        final BeanDeploymentModule rootBeanDeploymentModule = deploymentUnit.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n\n        bdmsByIdentifier.put(module.getIdentifier(), rootBeanDeploymentModule);\n        moduleSpecByIdentifier.put(module.getIdentifier(),moduleSpecification);\n\n        beanDeploymentArchives.addAll(rootBeanDeploymentModule.getBeanDeploymentArchives());\n        final List<DeploymentUnit> subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n\n        final Set<ClassLoader> subDeploymentLoaders = new HashSet<ClassLoader>();\n\n        for (DeploymentUnit subDeployment : subDeployments) {\n            final Module subDeploymentModule = subDeployment.getAttachment(Attachments.MODULE);\n            if(subDeploymentModule == null) {\n                continue;\n            }\n            subDeploymentLoaders.add(subDeploymentModule.getClassLoader());\n\n            final ModuleSpecification subDeploymentModuleSpec = subDeployment.getAttachment(Attachments.MODULE_SPECIFICATION);\n            final BeanDeploymentModule bdm = subDeployment.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n            if(bdm == null) {\n                continue;\n            }\n            // add the modules bdas to the global set of bdas\n            beanDeploymentArchives.addAll(bdm.getBeanDeploymentArchives());\n            beanDeploymentModules.add(bdm);\n            bdmsByIdentifier.put(subDeploymentModule.getIdentifier(),bdm);\n            moduleSpecByIdentifier.put(subDeploymentModule.getIdentifier(),subDeploymentModuleSpec);\n        }\n\n        for (Map.Entry<ModuleIdentifier, BeanDeploymentModule> entry : bdmsByIdentifier.entrySet()) {\n            final ModuleSpecification bdmSpec = moduleSpecByIdentifier.get(entry.getKey());\n            final BeanDeploymentModule bdm = entry.getValue();\n            if (bdm == rootBeanDeploymentModule) {\n                continue; // the root module only has access to itself\n            }\n            for(ModuleDependency dependency : bdmSpec.getDependencies()) {\n                BeanDeploymentModule other = bdmsByIdentifier.get(dependency.getIdentifier());\n                if(other != null && other != bdm) {\n                    bdm.addBeanDeploymentModule(other);\n                }\n            }\n        }\n\n        final List<Metadata<Extension>> extensions = deploymentUnit.getAttachmentList(WeldAttachments.PORTABLE_EXTENSIONS);\n\n        final WeldDeployment deployment = new WeldDeployment(beanDeploymentArchives, extensions, module, subDeploymentLoaders);\n\n        final WeldContainer weldContainer = new WeldContainer(deployment, Environments.EE_INJECT);\n        //hook up validation service\n        //TODO: we need to change weld so this is a per-BDA service\n        final ValidatorFactory factory = deploymentUnit.getAttachment(BeanValidationAttachments.VALIDATOR_FACTORY);\n        weldContainer.addWeldService(ValidationServices.class,new WeldValidationServices(factory));\n\n        final EjbInjectionServices ejbInjectionServices = new WeldEjbInjectionServices(deploymentUnit.getServiceRegistry(),eeModuleDescription);\n        weldContainer.addWeldService(EjbInjectionServices.class,ejbInjectionServices);\n\n        weldContainer.addWeldService(EjbServices.class,new WeldEjbServices(deploymentUnit.getServiceRegistry()));\n\n\n        final JpaInjectionServices rootJpaInjectionServices = new WeldJpaInjectionServices(deploymentUnit,deploymentUnit.getServiceRegistry());\n        weldContainer.addWeldService(JpaInjectionServices.class,rootJpaInjectionServices);\n\n        final WeldService weldService = new WeldService(weldContainer);\n        final ServiceName weldServiceName = deploymentUnit.getServiceName().append(WeldService.SERVICE_NAME);\n        // add the weld service\n        final ServiceBuilder<WeldContainer> weldServiceBuilder = serviceTarget.addService(weldServiceName, weldService);\n\n        weldServiceBuilder.addDependencies(TCCLSingletonService.SERVICE_NAME);\n\n        installResourceInjectionService(serviceTarget, deploymentUnit, weldService, weldServiceBuilder);\n        installSecurityService(serviceTarget, deploymentUnit, weldService, weldServiceBuilder);\n        installTransactionService(serviceTarget, deploymentUnit, weldService, weldServiceBuilder);\n\n        weldServiceBuilder.install();\n\n    }","commit_id":"e1f7ec738ff6619028e65f89736d8e78c14437e6","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public Cancellable execute(OperationContext context, ModelNode operation, ResultHandler resultHandler) {\n        if(context instanceof BootOperationContext) {\n            final BootOperationContext updateContext = (BootOperationContext) context;\n            logger.info(\"Activating EE subsystem\");\n            updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR_DEPLOYMENT_INIT, new EarInitializationProcessor());\n            updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR_APP_XML_PARSE, new EarMetaDataParsingProcessor());\n            updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR_JBOSS_APP_XML_PARSE, new JBossAppMetaDataParsingProcessor());\n            updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR, new EarStructureProcessor());\n            updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EAR_LIB_CLASS_PATH, new EarLibManifestClassPathProcessor());\n\n            updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_BEAN_LIEFCYCLE_ANNOTATION, new LifecycleAnnotationParsingProcessor());\n            updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_BEAN_INTERCEPTOR_ANNOTATION, new InterceptorAnnotationParsingProcessor());\n            updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_BEAN_RESOURCE_INJECTION_ANNOTATION, new ResourceInjectionAnnotationParsingProcessor());\n\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_MODULE_CONTEXT, new ModuleContextProcessor());\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_APP_CONTEXT, new ApplicationContextProcessor());\n\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EE_COMPONENT_CLASSLOAD, new ComponentClassLoadingProcessor());\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EE_COMPONENT_LIFECYCLES, new LifecycleInstallProcessor());\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EE_COMPONENT_INTERCEPTORS, new InterceptorInstallProcessor());\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EE_COMPONENT_INJECTIONS, new ResourceInjectionInstallProcessor());\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EE_COMPONENT, new ComponentInstallProcessor());\n        }\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n\n        context.getSubModel().setEmptyObject();\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","id":78661,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public Cancellable execute(OperationContext context, ModelNode operation, ResultHandler resultHandler) {\n        if(context instanceof BootOperationContext) {\n            final BootOperationContext updateContext = (BootOperationContext) context;\n            logger.info(\"Activating EE subsystem\");\n            updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR_DEPLOYMENT_INIT, new EarInitializationProcessor());\n            updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR_APP_XML_PARSE, new EarMetaDataParsingProcessor());\n            updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR_JBOSS_APP_XML_PARSE, new JBossAppMetaDataParsingProcessor());\n            updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EAR, new EarStructureProcessor());\n            updateContext.addDeploymentProcessor(Phase.STRUCTURE, Phase.STRUCTURE_EJB_JAR_IN_EAR, new EjbJarDeploymentProcessor());\n            updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_EAR_LIB_CLASS_PATH, new EarLibManifestClassPathProcessor());\n\n            updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_BEAN_LIEFCYCLE_ANNOTATION, new LifecycleAnnotationParsingProcessor());\n            updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_BEAN_INTERCEPTOR_ANNOTATION, new InterceptorAnnotationParsingProcessor());\n            updateContext.addDeploymentProcessor(Phase.PARSE, Phase.PARSE_BEAN_RESOURCE_INJECTION_ANNOTATION, new ResourceInjectionAnnotationParsingProcessor());\n\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_MODULE_CONTEXT, new ModuleContextProcessor());\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_APP_CONTEXT, new ApplicationContextProcessor());\n\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EE_COMPONENT_CLASSLOAD, new ComponentClassLoadingProcessor());\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EE_COMPONENT_LIFECYCLES, new LifecycleInstallProcessor());\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EE_COMPONENT_INTERCEPTORS, new InterceptorInstallProcessor());\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EE_COMPONENT_INJECTIONS, new ResourceInjectionInstallProcessor());\n            updateContext.addDeploymentProcessor(Phase.INSTALL, Phase.INSTALL_EE_COMPONENT, new ComponentInstallProcessor());\n        }\n\n        final ModelNode compensatingOperation = new ModelNode();\n        compensatingOperation.get(OP).set(REMOVE);\n        compensatingOperation.get(OP_ADDR).set(operation.require(OP_ADDR));\n\n        context.getSubModel().setEmptyObject();\n\n        resultHandler.handleResultComplete(compensatingOperation);\n\n        return Cancellable.NULL;\n    }","commit_id":"c26caa7bd7271151d2876e4245f77392ceed7fb0","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (!DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {\n            return;\n        }\n        // TODO: deal with application clients, we need the manifest information\n        List<ResourceRoot> potentialSubDeployments = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        for (ResourceRoot resourceRoot : potentialSubDeployments) {\n            if (ModuleRootMarker.isModuleRoot(resourceRoot)) {\n                // module roots cannot be ejb jars\n                continue;\n            }\n            VirtualFile ejbJarFile = resourceRoot.getRoot().getChild(\"META-INF/ejb-jar.xml\");\n            if (ejbJarFile.exists()) {\n                SubDeploymentMarker.mark(resourceRoot);\n            } else {\n                final Index index = resourceRoot.getAttachment(Attachments.ANNOTATION_INDEX);\n                if (index != null) {\n                    if(!index.getAnnotations(STATEFULL).isEmpty() ||\n                            !index.getAnnotations(STATELESS).isEmpty() ||\n                            !index.getAnnotations(MESSAGE_DRIVEN).isEmpty() ||\n                            !index.getAnnotations(SINGLETON).isEmpty() ||\n                            !index.getAnnotations(MANAGED_BEAN_ANNOTATION_NAME).isEmpty()) {\n                        //this is an EJB deployment\n                        //TODO: we need to mark EJB sub deployments so the sub deployers know they are EJB deployments\n                        SubDeploymentMarker.mark(resourceRoot);\n                    }\n                }\n            }\n        }\n    }","id":78662,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (!DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {\n            return;\n        }\n        // TODO: deal with application clients, we need the manifest information\n        List<ResourceRoot> potentialSubDeployments = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        for (ResourceRoot resourceRoot : potentialSubDeployments) {\n            if (ModuleRootMarker.isModuleRoot(resourceRoot)) {\n                // module roots cannot be ejb jars\n                continue;\n            }\n            VirtualFile ejbJarFile = resourceRoot.getRoot().getChild(\"META-INF/ejb-jar.xml\");\n            if (ejbJarFile.exists()) {\n                SubDeploymentMarker.mark(resourceRoot);\n                ModuleRootMarker.mark(resourceRoot);\n            } else {\n                final Index index = resourceRoot.getAttachment(Attachments.ANNOTATION_INDEX);\n                if (index != null) {\n                    if(!index.getAnnotations(STATEFULL).isEmpty() ||\n                            !index.getAnnotations(STATELESS).isEmpty() ||\n                            !index.getAnnotations(MESSAGE_DRIVEN).isEmpty() ||\n                            !index.getAnnotations(SINGLETON).isEmpty() ||\n                            !index.getAnnotations(MANAGED_BEAN_ANNOTATION_NAME).isEmpty()) {\n                        //this is an EJB deployment\n                        //TODO: we need to mark EJB sub deployments so the sub deployers know they are EJB deployments\n                        SubDeploymentMarker.mark(resourceRoot);\n                        ModuleRootMarker.mark(resourceRoot);\n                    }\n                }\n            }\n        }\n    }","commit_id":"c26caa7bd7271151d2876e4245f77392ceed7fb0","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ServiceName createModuleService(DeploymentPhaseContext phaseContext, final DeploymentUnit deploymentUnit,\n            final List<ResourceRoot> resourceRoots, final ModuleSpecification moduleSpecification,\n            final ModuleIdentifier moduleIdentifier) throws DeploymentUnitProcessingException {\n        final ModuleSpec.Builder specBuilder = ModuleSpec.build(moduleIdentifier);\n        final List<ModuleDependency> dependencies = moduleSpecification.getDependencies();\n\n        for (ResourceRoot resourceRoot : resourceRoots) {\n            addResourceRoot(specBuilder, resourceRoot);\n        }\n        final boolean childFirst;\n        if (moduleSpecification.getChildFirst() == null) {\n            childFirst = false;\n        } else {\n            childFirst = moduleSpecification.getChildFirst();\n        }\n\n        if (childFirst) {\n            specBuilder.addDependency(DependencySpec.createLocalDependencySpec());\n        }\n        if (dependencies != null)\n            for (ModuleDependency dependency : dependencies) {\n                final List<FilterSpecification> importFilters = dependency.getImportFilters();\n                final List<FilterSpecification> exportFilters = dependency.getExportFilters();\n                final PathFilter importFilter;\n                final PathFilter exportFilter;\n                final MultiplePathFilterBuilder importBuilder = PathFilters.multiplePathFilterBuilder(true);\n                for (FilterSpecification filter : importFilters) {\n                    importBuilder.addFilter(filter.getPathFilter(), filter.isInclude());\n                }\n                if (dependency.isImportServices()) {\n                    importBuilder.addFilter(PathFilters.getMetaInfServicesFilter(), true);\n                }\n                importBuilder.addFilter(PathFilters.getMetaInfSubdirectoriesFilter(), false);\n                importBuilder.addFilter(PathFilters.getMetaInfFilter(), false);\n                importFilter = importBuilder.create();\n                if (exportFilters.isEmpty()) {\n                    exportFilter = PathFilters.acceptAll();\n                } else {\n                    final MultiplePathFilterBuilder exportBuilder = PathFilters\n                            .multiplePathFilterBuilder(dependency.isExport());\n                    for (FilterSpecification filter : exportFilters) {\n                        exportBuilder.addFilter(filter.getPathFilter(), filter.isInclude());\n                    }\n                    exportFilter = exportBuilder.create();\n                }\n                DependencySpec depSpec = DependencySpec.createModuleDependencySpec(importFilter, exportFilter, dependency\n                        .getModuleLoader(), dependency.getIdentifier(), dependency.isOptional());\n                specBuilder.addDependency(depSpec);\n\n                final String depName = dependency.getIdentifier().getName();\n                if (depName.startsWith(ServiceModuleLoader.MODULE_PREFIX)) {\n                    phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, ServiceModuleLoader\n                            .moduleSpecServiceName(dependency.getIdentifier()));\n                }\n            }\n        if (!childFirst) {\n            specBuilder.addDependency(DependencySpec.createLocalDependencySpec());\n        }\n        final ModuleSpec moduleSpec = specBuilder.create();\n        final ServiceName moduleSpecServiceName = ServiceModuleLoader.moduleSpecServiceName(moduleIdentifier);\n        final ValueService<ModuleSpec> moduleSpecService = new ValueService<ModuleSpec>(new ImmediateValue<ModuleSpec>(\n                moduleSpec));\n        phaseContext.getServiceTarget().addService(moduleSpecServiceName, moduleSpecService).addDependencies(\n                deploymentUnit.getServiceName()).addDependencies(phaseContext.getPhaseServiceName()).setInitialMode(\n                Mode.ON_DEMAND).install();\n        return ModuleLoadService.install(phaseContext.getServiceTarget(), moduleIdentifier, dependencies);\n    }","id":78663,"modified_method":"private ServiceName createModuleService(DeploymentPhaseContext phaseContext, final DeploymentUnit deploymentUnit,\n            final List<ResourceRoot> resourceRoots, final ModuleSpecification moduleSpecification,\n            final ModuleIdentifier moduleIdentifier) throws DeploymentUnitProcessingException {\n        final ModuleSpec.Builder specBuilder = ModuleSpec.build(moduleIdentifier);\n        final List<ModuleDependency> dependencies = moduleSpecification.getDependencies();\n\n        for (ResourceRoot resourceRoot : resourceRoots) {\n            addResourceRoot(specBuilder, resourceRoot);\n        }\n        final boolean childFirst;\n        if (moduleSpecification.getChildFirst() == null) {\n            childFirst = false;\n        } else {\n            childFirst = moduleSpecification.getChildFirst();\n        }\n\n        if (childFirst) {\n            specBuilder.addDependency(DependencySpec.createLocalDependencySpec());\n        }\n        if (dependencies != null)\n            for (ModuleDependency dependency : dependencies) {\n                final List<FilterSpecification> importFilters = dependency.getImportFilters();\n                final List<FilterSpecification> exportFilters = dependency.getExportFilters();\n                final PathFilter importFilter;\n                final PathFilter exportFilter;\n                final MultiplePathFilterBuilder importBuilder = PathFilters.multiplePathFilterBuilder(true);\n                for (FilterSpecification filter : importFilters) {\n                    importBuilder.addFilter(filter.getPathFilter(), filter.isInclude());\n                }\n                if (dependency.isImportServices()) {\n                    importBuilder.addFilter(PathFilters.getMetaInfServicesFilter(), true);\n                }\n                importBuilder.addFilter(PathFilters.getMetaInfSubdirectoriesFilter(), false);\n                importBuilder.addFilter(PathFilters.getMetaInfFilter(), false);\n                importFilter = importBuilder.create();\n                if (exportFilters.isEmpty()) {\n                    if (dependency.isExport()) {\n                        exportFilter = PathFilters.acceptAll();\n                    } else {\n                        exportFilter = PathFilters.rejectAll();\n                    }\n                } else {\n                    final MultiplePathFilterBuilder exportBuilder = PathFilters\n                            .multiplePathFilterBuilder(dependency.isExport());\n                    for (FilterSpecification filter : exportFilters) {\n                        exportBuilder.addFilter(filter.getPathFilter(), filter.isInclude());\n                    }\n                    exportFilter = exportBuilder.create();\n                }\n                DependencySpec depSpec = DependencySpec.createModuleDependencySpec(importFilter, exportFilter, dependency\n                        .getModuleLoader(), dependency.getIdentifier(), dependency.isOptional());\n                specBuilder.addDependency(depSpec);\n\n                final String depName = dependency.getIdentifier().getName();\n                if (depName.startsWith(ServiceModuleLoader.MODULE_PREFIX)) {\n                    phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, ServiceModuleLoader\n                            .moduleSpecServiceName(dependency.getIdentifier()));\n                }\n            }\n        if (!childFirst) {\n            specBuilder.addDependency(DependencySpec.createLocalDependencySpec());\n        }\n        final ModuleSpec moduleSpec = specBuilder.create();\n        final ServiceName moduleSpecServiceName = ServiceModuleLoader.moduleSpecServiceName(moduleIdentifier);\n        final ValueService<ModuleSpec> moduleSpecService = new ValueService<ModuleSpec>(new ImmediateValue<ModuleSpec>(\n                moduleSpec));\n        phaseContext.getServiceTarget().addService(moduleSpecServiceName, moduleSpecService).addDependencies(\n                deploymentUnit.getServiceName()).addDependencies(phaseContext.getPhaseServiceName()).setInitialMode(\n                Mode.ON_DEMAND).install();\n        return ModuleLoadService.install(phaseContext.getServiceTarget(), moduleIdentifier, dependencies);\n    }","commit_id":"c26caa7bd7271151d2876e4245f77392ceed7fb0","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (deploymentUnit.getAttachment(MARKER) != null) {\n            return;\n        }\n        deploymentUnit.putAttachment(MARKER, true);\n\n        // Don't create a ModuleSpec for OSGi deployments\n        if (deploymentUnit.hasAttachment(Attachments.OSGI_MANIFEST)) {\n            return;\n        }\n\n        final ResourceRoot mainRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        final List<ResourceRoot> additionalRoots = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        if (mainRoot == null) {\n            return;\n        }\n        List<ResourceRoot> resourceRoots = new ArrayList<ResourceRoot>();\n        // Add internal resource roots\n        if (ModuleRootMarker.isModuleRoot(mainRoot)) {\n            resourceRoots.add(mainRoot);\n        }\n        if (additionalRoots != null)\n            for (ResourceRoot additionalRoot : additionalRoots) {\n                if (ModuleRootMarker.isModuleRoot(additionalRoot)) {\n                    resourceRoots.add(additionalRoot);\n                }\n            }\n\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final ModuleIdentifier moduleIdentifier = deploymentUnit.getAttachment(Attachments.MODULE_IDENTIFIER);\n        if (moduleIdentifier == null) {\n            throw new DeploymentUnitProcessingException(\"No Module Identifier attached to deployment \"\n                    + deploymentUnit.getName());\n        }\n\n        // create the module servce and set it to attach to the deployment in the next phase\n        ServiceName moduleServiceName = createModuleService(phaseContext, deploymentUnit, resourceRoots, moduleSpecification,\n                moduleIdentifier);\n        phaseContext.addDeploymentDependency(moduleServiceName, Attachments.MODULE);\n\n        final List<AdditionalModuleSpecification> additionalModules = deploymentUnit.getAttachment(Attachments.ADDITIONAL_MODULES);\n        if (additionalModules == null) {\n            return;\n        }\n        for (AdditionalModuleSpecification module : additionalModules) {\n\n            ServiceName additionalModuleServiceName = createModuleService(phaseContext, deploymentUnit, module\n                    .getResourceRoots(), module, module.getModuleIdentifier());\n            phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, additionalModuleServiceName);\n        }\n    }","id":78664,"modified_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (deploymentUnit.getAttachment(MARKER) != null) {\n            return;\n        }\n        deploymentUnit.putAttachment(MARKER, true);\n\n        // Don't create a ModuleSpec for OSGi deployments\n        if (deploymentUnit.hasAttachment(Attachments.OSGI_MANIFEST)) {\n            return;\n        }\n\n        final ResourceRoot mainRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        final List<ResourceRoot> additionalRoots = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        if (mainRoot == null) {\n            return;\n        }\n        List<ResourceRoot> resourceRoots = new ArrayList<ResourceRoot>();\n        // Add internal resource roots\n        if (ModuleRootMarker.isModuleRoot(mainRoot)) {\n            resourceRoots.add(mainRoot);\n        }\n        if (additionalRoots != null)\n            for (ResourceRoot additionalRoot : additionalRoots) {\n                if (ModuleRootMarker.isModuleRoot(additionalRoot) && !SubDeploymentMarker.isSubDeployment(additionalRoot)) {\n                    resourceRoots.add(additionalRoot);\n                }\n            }\n\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final ModuleIdentifier moduleIdentifier = deploymentUnit.getAttachment(Attachments.MODULE_IDENTIFIER);\n        if (moduleIdentifier == null) {\n            throw new DeploymentUnitProcessingException(\"No Module Identifier attached to deployment \"\n                    + deploymentUnit.getName());\n        }\n\n        // create the module servce and set it to attach to the deployment in the next phase\n        ServiceName moduleServiceName = createModuleService(phaseContext, deploymentUnit, resourceRoots, moduleSpecification,\n                moduleIdentifier);\n        phaseContext.addDeploymentDependency(moduleServiceName, Attachments.MODULE);\n\n        final List<AdditionalModuleSpecification> additionalModules = deploymentUnit.getAttachment(Attachments.ADDITIONAL_MODULES);\n        if (additionalModules == null) {\n            return;\n        }\n        for (AdditionalModuleSpecification module : additionalModules) {\n\n            ServiceName additionalModuleServiceName = createModuleService(phaseContext, deploymentUnit, module\n                    .getResourceRoots(), module, module.getModuleIdentifier());\n            phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, additionalModuleServiceName);\n        }\n    }","commit_id":"c26caa7bd7271151d2876e4245f77392ceed7fb0","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (deploymentUnit.getParent() == null) {\n            return;\n        }\n\n        final List<ResourceRoot> resourceRoots = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        for(ResourceRoot resourceRoot : resourceRoots) {\n            final VirtualFile rootFile = resourceRoot.getRoot();\n            if (!SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                final VirtualFile sarDescriptor = rootFile.getChild(ServiceDeploymentParsingProcessor.SERVICE_DESCRIPTOR_PATH);\n                if(sarDescriptor.exists()) {\n                    SubDeploymentMarker.mark(resourceRoot);\n                }\n            }\n        }\n    }","id":78665,"modified_method":"public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (deploymentUnit.getParent() == null) {\n            return;\n        }\n\n        final List<ResourceRoot> resourceRoots = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        if (resourceRoots != null) {\n            for (ResourceRoot resourceRoot : resourceRoots) {\n                final VirtualFile rootFile = resourceRoot.getRoot();\n                if (!SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                    final VirtualFile sarDescriptor = rootFile\n                            .getChild(ServiceDeploymentParsingProcessor.SERVICE_DESCRIPTOR_PATH);\n                    if (sarDescriptor.exists()) {\n                        SubDeploymentMarker.mark(resourceRoot);\n                    }\n                }\n            }\n        }\n    }","commit_id":"c26caa7bd7271151d2876e4245f77392ceed7fb0","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public synchronized void start(final StartContext context) throws StartException {\n        final ServiceContainer container = context.getController().getServiceContainer();\n        final TrackingServiceTarget serviceTarget = new TrackingServiceTarget(container.subTarget());\n        serviceTarget.addDependency(context.getController().getName());\n        final Bootstrap.Configuration configuration = this.configuration;\n        final ServerEnvironment serverEnvironment = configuration.getServerEnvironment();\n\n        final int threads = (int) (Runtime.getRuntime().availableProcessors() * 1.5f);\n        final ExecutorService executor = new ThreadPoolExecutor(threads, threads, Long.MAX_VALUE, TimeUnit.NANOSECONDS, new LinkedBlockingQueue<Runnable>());\n        container.setExecutor(executor);\n\n        final ExtensibleConfigurationPersister persister = configuration.getConfigurationPersister();\n\n        final ServerControllerImpl serverController = new ServerControllerImpl(container, serverEnvironment, persister, injectedDeploymentRepository.getValue());\n        serverController.init();\n\n        final List<ModelNode> updates;\n        try {\n            updates = persister.load();\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n\n        log.info(\"Activating core services\");\n\n        final AtomicInteger count = new AtomicInteger(1);\n        final ResultHandler resultHandler = new ResultHandler() {\n            @Override\n            public void handleResultFragment(final String[] location, final ModelNode result) {\n            }\n\n            @Override\n            public void handleResultComplete(final ModelNode compensatingOperation) {\n                if (count.decrementAndGet() == 0) {\n                    // some action\n                }\n            }\n\n            @Override\n            public void handleFailed(final ModelNode failureDescription) {\n                if (count.decrementAndGet() == 0) {\n                    // some action\n                }\n            }\n\n            @Override\n            public void handleCancellation() {\n                if (count.decrementAndGet() == 0) {\n                    // some action\n                }\n            }\n        };\n        for (ModelNode update : updates) {\n            count.incrementAndGet();\n            serverController.execute(update, resultHandler);\n        }\n        if (count.decrementAndGet() == 0) {\n            // some action?\n        }\n\n        final EnumMap<Phase, SortedSet<RegisteredProcessor>> deployers = serverController.finishBoot();\n\n        final File[] extDirs = serverEnvironment.getJavaExtDirs();\n        final File[] newExtDirs = Arrays.copyOf(extDirs, extDirs.length + 1);\n        newExtDirs[extDirs.length] = new File(serverEnvironment.getServerBaseDir(), \"lib/ext\");\n        serviceTarget.addService(org.jboss.as.server.deployment.Services.JBOSS_DEPLOYMENT_EXTENSION_INDEX,\n                new ExtensionIndexService(newExtDirs)).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n\n        // Activate  module loader\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_SERVICE_MODULE_LOADER, new DeploymentUnitProcessor() {\n            @Override\n            public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n                phaseContext.getDeploymentUnit().putAttachment(Attachments.SERVICE_MODULE_LOADER, injectedModuleLoader.getValue());\n                phaseContext.getDeploymentUnit().putAttachment(Attachments.EXTERNAL_MODULE_SERVICE, injectedExternalModuleServie.getValue());\n            }\n\n            @Override\n            public void undeploy(DeploymentUnit context) {\n                context.removeAttachment(Attachments.SERVICE_MODULE_LOADER);\n            }\n        }));\n\n        // Activate core processors for jar deployment\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MOUNT, new DeploymentRootMountProcessor()));\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MANIFEST, new ManifestAttachmentProcessor()));\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_SUB_DEPLOYMENT, new SubDeploymentProcessor()));\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MODULE_IDENTIFIERS, new ModuleIdentifierProcessor()));\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_ANNOTATION_INDEX, new AnnotationIndexProcessor()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_STRUCTURE_DESCRIPTOR, new DeploymentStructureDescriptorParser()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_COMPOSITE_ANNOTATION_INDEX, new CompositeIndexProcessor()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_ADDITIONAL_MODULES, new AdditionalModuleProcessor()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_CLASS_PATH, new ManifestClassPathProcessor()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_EXTENSION_LIST, new ManifestExtensionListProcessor()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_SERVICE_LOADER_DEPLOYMENT, new ServiceLoaderProcessor()));\n        deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_MODULE, new ModuleDependencyProcessor()));\n        deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_SAR_MODULE, new ServiceActivatorDependencyProcessor()));\n        deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_CLASS_PATH, new ModuleClassPathProcessor()));\n        deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_EXTENSION_LIST, new ModuleExtensionListProcessor()));\n        deployers.get(Phase.CONFIGURE_MODULE).add(new RegisteredProcessor(Phase.CONFIGURE_MODULE_SPEC, new ModuleSpecProcessor()));\n        deployers.get(Phase.INSTALL).add(new RegisteredProcessor(Phase.INSTALL_REFLECTION_INDEX, new InstallReflectionIndexProcessor()));\n        deployers.get(Phase.INSTALL).add(new RegisteredProcessor(Phase.INSTALL_SERVICE_ACTIVATOR, new ServiceActivatorProcessor()));\n\n        // All deployers are registered\n\n        final EnumMap<Phase, List<DeploymentUnitProcessor>> finalDeployers = new EnumMap<Phase, List<DeploymentUnitProcessor>>(Phase.class);\n        for (Map.Entry<Phase, SortedSet<RegisteredProcessor>> entry : deployers.entrySet()) {\n            final SortedSet<RegisteredProcessor> processorSet = entry.getValue();\n            final List<DeploymentUnitProcessor> list = new ArrayList<DeploymentUnitProcessor>(processorSet.size());\n            for (RegisteredProcessor processor : processorSet) {\n                list.add(processor.getProcessor());\n            }\n            finalDeployers.put(entry.getKey(), list);\n        }\n\n        DeployerChainsService.addService(serviceTarget, finalDeployers);\n\n        this.serverController = serverController;\n        bootServices = serviceTarget.getSet();\n    }","id":78666,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public synchronized void start(final StartContext context) throws StartException {\n        final ServiceContainer container = context.getController().getServiceContainer();\n        final TrackingServiceTarget serviceTarget = new TrackingServiceTarget(container.subTarget());\n        serviceTarget.addDependency(context.getController().getName());\n        final Bootstrap.Configuration configuration = this.configuration;\n        final ServerEnvironment serverEnvironment = configuration.getServerEnvironment();\n\n        final int threads = (int) (Runtime.getRuntime().availableProcessors() * 1.5f);\n        final ExecutorService executor = new ThreadPoolExecutor(threads, threads, Long.MAX_VALUE, TimeUnit.NANOSECONDS, new LinkedBlockingQueue<Runnable>());\n        container.setExecutor(executor);\n\n        final ExtensibleConfigurationPersister persister = configuration.getConfigurationPersister();\n\n        final ServerControllerImpl serverController = new ServerControllerImpl(container, serverEnvironment, persister, injectedDeploymentRepository.getValue());\n        serverController.init();\n\n        final List<ModelNode> updates;\n        try {\n            updates = persister.load();\n        } catch (Exception e) {\n            throw new StartException(e);\n        }\n\n        log.info(\"Activating core services\");\n\n        final AtomicInteger count = new AtomicInteger(1);\n        final ResultHandler resultHandler = new ResultHandler() {\n            @Override\n            public void handleResultFragment(final String[] location, final ModelNode result) {\n            }\n\n            @Override\n            public void handleResultComplete(final ModelNode compensatingOperation) {\n                if (count.decrementAndGet() == 0) {\n                    // some action\n                }\n            }\n\n            @Override\n            public void handleFailed(final ModelNode failureDescription) {\n                if (count.decrementAndGet() == 0) {\n                    // some action\n                }\n            }\n\n            @Override\n            public void handleCancellation() {\n                if (count.decrementAndGet() == 0) {\n                    // some action\n                }\n            }\n        };\n        for (ModelNode update : updates) {\n            count.incrementAndGet();\n            serverController.execute(update, resultHandler);\n        }\n        if (count.decrementAndGet() == 0) {\n            // some action?\n        }\n\n        final EnumMap<Phase, SortedSet<RegisteredProcessor>> deployers = serverController.finishBoot();\n\n        final File[] extDirs = serverEnvironment.getJavaExtDirs();\n        final File[] newExtDirs = Arrays.copyOf(extDirs, extDirs.length + 1);\n        newExtDirs[extDirs.length] = new File(serverEnvironment.getServerBaseDir(), \"lib/ext\");\n        serviceTarget.addService(org.jboss.as.server.deployment.Services.JBOSS_DEPLOYMENT_EXTENSION_INDEX,\n                new ExtensionIndexService(newExtDirs)).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n\n        // Activate  module loader\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_SERVICE_MODULE_LOADER, new DeploymentUnitProcessor() {\n            @Override\n            public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n                phaseContext.getDeploymentUnit().putAttachment(Attachments.SERVICE_MODULE_LOADER, injectedModuleLoader.getValue());\n                phaseContext.getDeploymentUnit().putAttachment(Attachments.EXTERNAL_MODULE_SERVICE, injectedExternalModuleServie.getValue());\n            }\n\n            @Override\n            public void undeploy(DeploymentUnit context) {\n                context.removeAttachment(Attachments.SERVICE_MODULE_LOADER);\n            }\n        }));\n\n        // Activate core processors for jar deployment\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MOUNT, new DeploymentRootMountProcessor()));\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MANIFEST, new ManifestAttachmentProcessor()));\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_SUB_DEPLOYMENT, new SubDeploymentProcessor()));\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_MODULE_IDENTIFIERS, new ModuleIdentifierProcessor()));\n        deployers.get(Phase.STRUCTURE).add(new RegisteredProcessor(Phase.STRUCTURE_ANNOTATION_INDEX, new AnnotationIndexProcessor()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_STRUCTURE_DESCRIPTOR, new DeploymentStructureDescriptorParser()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_COMPOSITE_ANNOTATION_INDEX, new CompositeIndexProcessor()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_ADDITIONAL_MODULES, new AdditionalModuleProcessor()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_CLASS_PATH, new ManifestClassPathProcessor()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_EXTENSION_LIST, new ManifestExtensionListProcessor()));\n        deployers.get(Phase.PARSE).add(new RegisteredProcessor(Phase.PARSE_SERVICE_LOADER_DEPLOYMENT, new ServiceLoaderProcessor()));\n        deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_MODULE, new ModuleDependencyProcessor()));\n        deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_SAR_MODULE, new ServiceActivatorDependencyProcessor()));\n        deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_CLASS_PATH, new ModuleClassPathProcessor()));\n        deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_EXTENSION_LIST, new ModuleExtensionListProcessor()));\n        deployers.get(Phase.DEPENDENCIES).add(new RegisteredProcessor(Phase.DEPENDENCIES_SUB_DEPLOYMENTS, new SubDeploymentDependencyProcessor()));\n        deployers.get(Phase.CONFIGURE_MODULE).add(new RegisteredProcessor(Phase.CONFIGURE_MODULE_SPEC, new ModuleSpecProcessor()));\n        deployers.get(Phase.INSTALL).add(new RegisteredProcessor(Phase.INSTALL_REFLECTION_INDEX, new InstallReflectionIndexProcessor()));\n        deployers.get(Phase.INSTALL).add(new RegisteredProcessor(Phase.INSTALL_SERVICE_ACTIVATOR, new ServiceActivatorProcessor()));\n\n        // All deployers are registered\n\n        final EnumMap<Phase, List<DeploymentUnitProcessor>> finalDeployers = new EnumMap<Phase, List<DeploymentUnitProcessor>>(Phase.class);\n        for (Map.Entry<Phase, SortedSet<RegisteredProcessor>> entry : deployers.entrySet()) {\n            final SortedSet<RegisteredProcessor> processorSet = entry.getValue();\n            final List<DeploymentUnitProcessor> list = new ArrayList<DeploymentUnitProcessor>(processorSet.size());\n            for (RegisteredProcessor processor : processorSet) {\n                list.add(processor.getProcessor());\n            }\n            finalDeployers.put(entry.getKey(), list);\n        }\n\n        DeployerChainsService.addService(serviceTarget, finalDeployers);\n\n        this.serverController = serverController;\n        bootServices = serviceTarget.getSet();\n    }","commit_id":"c26caa7bd7271151d2876e4245f77392ceed7fb0","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return; // Skip non web deployments\n        }\n\n        final ResourceRoot deploymentResourceRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        final VirtualFile deploymentRoot = deploymentResourceRoot.getRoot();\n        if(deploymentRoot == null) {\n            return;\n        }\n\n        // set the child first behavoiur\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        if (moduleSpecification == null) {\n            return;\n        }\n        if (moduleSpecification.getChildFirst() == null) {\n            // if this has not been overriden by jboss-structure.xml\n            moduleSpecification.setChildFirst(true);\n        }\n\n        // we do not want to index the resource root, only WEB-INF/classes and WEB-INF/lib\n        deploymentResourceRoot.putAttachment(Attachments.INDEX_RESOURCE_ROOT, false);\n        // Make sure the root does not end up in the module\n        ModuleRootMarker.mark(deploymentResourceRoot, false);\n\n        // TODO: This needs to be ported to add additional resource roots the standard way\n        final MountHandle mountHandle = deploymentResourceRoot.getMountHandle();\n        try {\n\n            // add standard resource roots, this should eventually replace ClassPathEntry\n            final List<ResourceRoot> resourceRoots = createResourceRoots(deploymentRoot, mountHandle);\n            for (ResourceRoot root : resourceRoots) {\n                deploymentUnit.addToAttachmentList(Attachments.RESOURCE_ROOTS, root);\n            }\n\n        } catch(Exception e) {\n            throw new DeploymentUnitProcessingException(e);\n        }\n        // Add the war metadata\n        final WarMetaData warMetaData = new WarMetaData();\n        warMetaData.setSharedWebMetaData(sharedWebMetaData);\n        deploymentUnit.putAttachment(WarMetaData.ATTACHMENT_KEY, warMetaData);\n        // Add the shared TLDs metadata\n        final TldsMetaData tldsMetaData = new TldsMetaData();\n        tldsMetaData.setSharedTlds(sharedTldsMetaData);\n        deploymentUnit.putAttachment(TldsMetaData.ATTACHMENT_KEY, tldsMetaData);\n    }","id":78667,"modified_method":"/** {@inheritDoc} */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (!DeploymentTypeMarker.isType(DeploymentType.WAR, deploymentUnit)) {\n            return; // Skip non web deployments\n        }\n\n        final ResourceRoot deploymentResourceRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        final VirtualFile deploymentRoot = deploymentResourceRoot.getRoot();\n        if(deploymentRoot == null) {\n            return;\n        }\n\n        // set the child first behavoiur\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        if (moduleSpecification == null) {\n            return;\n        }\n        if (moduleSpecification.getChildFirst() == null) {\n            // if this has not been overriden by jboss-structure.xml\n            moduleSpecification.setChildFirst(true);\n        }\n\n        // other sub deployments should not have access to classes in the war module\n        PrivateSubDeploymentMarker.mark(deploymentUnit);\n\n        // we do not want to index the resource root, only WEB-INF/classes and WEB-INF/lib\n        deploymentResourceRoot.putAttachment(Attachments.INDEX_RESOURCE_ROOT, false);\n        // Make sure the root does not end up in the module\n        ModuleRootMarker.mark(deploymentResourceRoot, false);\n\n        // TODO: This needs to be ported to add additional resource roots the standard way\n        final MountHandle mountHandle = deploymentResourceRoot.getMountHandle();\n        try {\n\n            // add standard resource roots, this should eventually replace ClassPathEntry\n            final List<ResourceRoot> resourceRoots = createResourceRoots(deploymentRoot, mountHandle);\n            for (ResourceRoot root : resourceRoots) {\n                deploymentUnit.addToAttachmentList(Attachments.RESOURCE_ROOTS, root);\n            }\n\n        } catch(Exception e) {\n            throw new DeploymentUnitProcessingException(e);\n        }\n        // Add the war metadata\n        final WarMetaData warMetaData = new WarMetaData();\n        warMetaData.setSharedWebMetaData(sharedWebMetaData);\n        deploymentUnit.putAttachment(WarMetaData.ATTACHMENT_KEY, warMetaData);\n        // Add the shared TLDs metadata\n        final TldsMetaData tldsMetaData = new TldsMetaData();\n        tldsMetaData.setSharedTlds(sharedTldsMetaData);\n        deploymentUnit.putAttachment(TldsMetaData.ATTACHMENT_KEY, tldsMetaData);\n    }","commit_id":"c26caa7bd7271151d2876e4245f77392ceed7fb0","url":"https://github.com/wildfly/wildfly"},{"original_method":"private String urlEncode(Object obj, ServletRequest request) {\n        try {\n            return URLEncoder.encode(obj.toString(),request.getCharacterEncoding());\n        } catch (UnsupportedEncodingException ex) {\n            throw new ControllerExecutionException(\"Error creating URL, cannot URLEncode to the client's character encoding: \"+ ex.getMessage(),ex);\n        }\n    }","id":78668,"modified_method":"private String urlEncode(Object obj, ServletRequest request) {\n        try {\n            String charset = request.getCharacterEncoding();\n            \n            return URLEncoder.encode(obj.toString(), (charset != null) ? charset : GrailsWebUtil.DEFAULT_ENCODING );\n        } catch (UnsupportedEncodingException ex) {\n            throw new ControllerExecutionException(\"Error creating URL, cannot URLEncode to the client's character encoding: \"+ ex.getMessage(),ex);\n        }\n    }","commit_id":"b8a9676b31dec04d2dcecf7236e7bdd1de99f0b4","url":"https://github.com/grails/grails-core"},{"original_method":"private static Charset getDefaultCharset()\n\t{\n\t\tString charsetName = null;\n\n\t\tApplication application = Application.get();\n\t\tif (application != null)\n\t\t{\n\t\t\tcharsetName = application.getRequestCycleSettings().getResponseRequestEncoding();\n\t\t}\n\t\tif (Strings.isEmpty(charsetName))\n\t\t{\n\t\t\tcharsetName = \"UTF-8\";\n\t\t}\n\t\treturn Charset.forName(charsetName);\n\t}","id":78669,"modified_method":"private static Charset getDefaultCharset()\n\t{\n\t\tString charsetName = null;\n\n\t\tif (Application.exists())\n\t\t{\n\t\t\tcharsetName = Application.get().getRequestCycleSettings().getResponseRequestEncoding();\n\t\t}\n\t\tif (Strings.isEmpty(charsetName))\n\t\t{\n\t\t\tcharsetName = \"UTF-8\";\n\t\t}\n\t\treturn Charset.forName(charsetName);\n\t}","commit_id":"b663a176d09ccd44e4482de2494c66a8eaebc2a1","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @param request\n\t * @return the request's charset\n\t */\n\tpublic static Charset getCharset(HttpServletRequest request)\n\t{\n\t\tString charsetName = null;\n\t\tif (request != null)\n\t\t{\n\t\t\tcharsetName = request.getCharacterEncoding();\n\t\t}\n\t\tif (Strings.isEmpty(charsetName))\n\t\t{\n\t\t\tApplication application = Application.get();\n\t\t\tif (application != null)\n\t\t\t{\n\t\t\t\tcharsetName = application.getRequestCycleSettings().getResponseRequestEncoding();\n\t\t\t}\n\t\t}\n\t\tif (Strings.isEmpty(charsetName))\n\t\t{\n\t\t\tcharsetName = \"UTF-8\";\n\t\t}\n\t\treturn Charset.forName(charsetName);\n\t}","id":78670,"modified_method":"/**\n\t * @param request\n\t *      the http servlet request to extract the charset from\n\t * @return the request's charset\n\t */\n\tpublic static Charset getCharset(HttpServletRequest request)\n\t{\n\t\tCharset charset = null;\n\t\tif (request != null)\n\t\t{\n\t\t\tString charsetName = request.getCharacterEncoding();\n\t\t\tcharset = Charset.forName(charsetName);\n\t\t}\n\t\tif (charset == null)\n\t\t{\n\t\t\tcharset = getDefaultCharset();\n\t\t}\n\t\treturn charset;\n\t}","commit_id":"b663a176d09ccd44e4482de2494c66a8eaebc2a1","url":"https://github.com/apache/wicket"},{"original_method":"private void informPluginsOfConfigChange() {\n        LOG.info(\"Informing plug-ins of configuration change..\");\n        for (Iterator i = pluginList.iterator(); i.hasNext();) {\n            GrailsPlugin plugin = (GrailsPlugin) i.next();\n            plugin.notifyOfEvent(GrailsPlugin.EVENT_ON_CONFIG_CHANGE, application.getConfig());\n        }\n    }","id":78671,"modified_method":"private void informPluginsOfConfigChange() {\n        LOG.info(\"Informing plug-ins of configuration change...\");\n        for (Iterator i = pluginList.iterator(); i.hasNext();) {\n            GrailsPlugin plugin = (GrailsPlugin) i.next();\n            plugin.notifyOfEvent(GrailsPlugin.EVENT_ON_CONFIG_CHANGE, application.getConfig());\n        }\n    }","commit_id":"976471dac6cca376cc111241d687f6ab5da4fa6b","url":"https://github.com/grails/grails-core"},{"original_method":"private String urlEncode(Object obj, ServletRequest request) {\n        try {\n            return URLEncoder.encode(obj.toString(),request.getCharacterEncoding());\n        } catch (UnsupportedEncodingException ex) {\n            throw new ControllerExecutionException(\"Error creating URL, cannot URLEncode to the client's character encoding: \"+ ex.getMessage(),ex);\n        }\n    }","id":78672,"modified_method":"private String urlEncode(Object obj, ServletRequest request) {\n        try {\n            String charset = request.getCharacterEncoding();\n            return URLEncoder.encode(obj.toString(), (charset != null) ? charset : GrailsWebUtil.DEFAULT_ENCODING );\n        } catch (UnsupportedEncodingException ex) {\n            throw new ControllerExecutionException(\"Error creating URL, cannot URLEncode to the client's character encoding: \"+ ex.getMessage(),ex);\n        }\n    }","commit_id":"976471dac6cca376cc111241d687f6ab5da4fa6b","url":"https://github.com/grails/grails-core"},{"original_method":"public static GrailsWebRequest bindMockWebRequest() {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        GrailsWebRequest webRequest = new GrailsWebRequest(\n                                                request,\n                                                new MockHttpServletResponse(),\n                                                new MockServletContext()\n                                            );\n        request.setAttribute(GrailsApplicationAttributes.WEB_REQUEST, webRequest);\n        RequestContextHolder.setRequestAttributes(webRequest);\n        return webRequest;\n    }","id":78673,"modified_method":"public static GrailsWebRequest bindMockWebRequest() {\n        HttpServletRequest request = GrailsWebUtil.makeMockRequest();\n        GrailsWebRequest webRequest = new GrailsWebRequest(\n                                                request,\n                                                new MockHttpServletResponse(),\n                                                new MockServletContext()\n                                            );\n        request.setAttribute(GrailsApplicationAttributes.WEB_REQUEST, webRequest);\n        RequestContextHolder.setRequestAttributes(webRequest);\n        return webRequest;\n    }","commit_id":"976471dac6cca376cc111241d687f6ab5da4fa6b","url":"https://github.com/grails/grails-core"},{"original_method":"public static GrailsWebRequest bindMockWebRequest(GrailsWebApplicationContext ctx) {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        GrailsWebRequest webRequest = new GrailsWebRequest(\n                                                request,\n                                                new MockHttpServletResponse(),\n                                                ctx.getServletContext()\n                                            );\n        request.setAttribute(GrailsApplicationAttributes.WEB_REQUEST, webRequest);\n        String[] paramListenerBeans = ctx.getBeanNamesForType(ParameterCreationListener.class);\n        for (int i = 0; i < paramListenerBeans.length; i++) {\n            ParameterCreationListener creationListenerBean = (ParameterCreationListener)ctx.getBean(paramListenerBeans[i]);\n            webRequest.addParameterListener(creationListenerBean);\n        }\n        RequestContextHolder.setRequestAttributes(webRequest);\n        return webRequest;\n    }","id":78674,"modified_method":"public static GrailsWebRequest bindMockWebRequest(GrailsWebApplicationContext ctx) {\n        HttpServletRequest request = GrailsWebUtil.makeMockRequest();\n        GrailsWebRequest webRequest = new GrailsWebRequest(\n                                                request,\n                                                new MockHttpServletResponse(),\n                                                ctx.getServletContext()\n                                            );\n        request.setAttribute(GrailsApplicationAttributes.WEB_REQUEST, webRequest);\n        String[] paramListenerBeans = ctx.getBeanNamesForType(ParameterCreationListener.class);\n        for (int i = 0; i < paramListenerBeans.length; i++) {\n            ParameterCreationListener creationListenerBean = (ParameterCreationListener)ctx.getBean(paramListenerBeans[i]);\n            webRequest.addParameterListener(creationListenerBean);\n        }\n        RequestContextHolder.setRequestAttributes(webRequest);\n        return webRequest;\n    }","commit_id":"976471dac6cca376cc111241d687f6ab5da4fa6b","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Merge the parameters from the saved query parameter string (if any), and\n     * the parameters already present on this request (if any), such that the\n     * parameter values from the query string show up first if there are\n     * duplicate parameter names.\n     */\n    private void mergeParameters() {\n\n        if ((queryParamString == null) || (queryParamString.length() < 1))\n            return;\n\n        HashMap<String, String[]> queryParameters = new HashMap<>();\n\n        // Parse the query string from the dispatch target\n        Parameters paramParser = new Parameters();\n        MessageBytes queryMB = MessageBytes.newInstance();\n        queryMB.setString(queryParamString);\n        paramParser.setQuery(queryMB);\n        paramParser.setQueryStringEncoding(getCharacterEncoding());\n        paramParser.handleQueryParameters();\n\n        // Copy the original parameters\n        queryParameters.putAll(parameters);\n\n        // Insert the additional parameters from the dispatch target\n        Enumeration<String> dispParamNames = paramParser.getParameterNames();\n        while (dispParamNames.hasMoreElements()) {\n            String dispParamName = dispParamNames.nextElement();\n            String[] dispParamValues = paramParser.getParameterValues(dispParamName);\n            String[] originalValues = queryParameters.get(dispParamName);\n            if (originalValues == null) {\n                queryParameters.put(dispParamName, dispParamValues);\n                continue;\n            }\n            queryParameters.put(dispParamName, mergeValues(dispParamValues, originalValues));\n        }\n\n        parameters = queryParameters;\n    }","id":78675,"modified_method":"/**\n     * Merge the parameters from the saved query parameter string (if any), and\n     * the parameters already present on this request (if any), such that the\n     * parameter values from the query string show up first if there are\n     * duplicate parameter names.\n     */\n    private void mergeParameters() {\n\n        if ((queryParamString == null) || (queryParamString.length() < 1))\n            return;\n\n        HashMap<String, String[]> queryParameters = new HashMap<>();\n\n        // Parse the query string from the dispatch target\n        Parameters paramParser = new Parameters();\n        MessageBytes queryMB = MessageBytes.newInstance();\n        queryMB.setString(queryParamString);\n\n        String encoding = getCharacterEncoding();\n        // No need to process null value, as ISO-8859-1 is the default encoding\n        // in MessageBytes.toBytes().\n        if (encoding != null) {\n            try {\n                queryMB.setCharset(B2CConverter.getCharset(encoding));\n            } catch (UnsupportedEncodingException ignored) {\n                // Fall-back to ISO-8859-1\n            }\n        }\n\n        paramParser.setQuery(queryMB);\n        paramParser.setQueryStringEncoding(encoding);\n        paramParser.handleQueryParameters();\n\n        // Copy the original parameters\n        queryParameters.putAll(parameters);\n\n        // Insert the additional parameters from the dispatch target\n        Enumeration<String> dispParamNames = paramParser.getParameterNames();\n        while (dispParamNames.hasMoreElements()) {\n            String dispParamName = dispParamNames.nextElement();\n            String[] dispParamValues = paramParser.getParameterValues(dispParamName);\n            String[] originalValues = queryParameters.get(dispParamName);\n            if (originalValues == null) {\n                queryParameters.put(dispParamName, dispParamValues);\n                continue;\n            }\n            queryParameters.put(dispParamName, mergeValues(dispParamValues, originalValues));\n        }\n\n        parameters = queryParameters;\n    }","commit_id":"40045f250ee6dbcb237f66abba42ce74ada7fb65","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                throws ServletException, IOException {\n            req.getRequestDispatcher(target).forward(req, resp);\n        }","id":78676,"modified_method":"@Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                throws ServletException, IOException {\n            req.setCharacterEncoding(\"UTF-8\");\n            req.getRequestDispatcher(target).forward(req, resp);\n        }","commit_id":"40045f250ee6dbcb237f66abba42ce74ada7fb65","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                throws ServletException, IOException {\n            resp.setContentType(\"text/plain\");\n            resp.setCharacterEncoding(\"UTF-8\");\n            PrintWriter w = resp.getWriter();\n            Map<String,String[]> actual = req.getParameterMap();\n\n            boolean ok = true;\n            for (Entry<String,String[]> entry : actual.entrySet()) {\n                String[] expectedValue = expected.get(entry.getKey());\n                if (expectedValue == null ||\n                        expectedValue.length != entry.getValue().length) {\n                    ok = false;\n                    break;\n                }\n                for (int i = 0; i < expectedValue.length; i++) {\n                    if (!expectedValue[i].equals(entry.getValue()[i])) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (!ok) {\n                    break;\n                }\n            }\n\n            if (ok) {\n                w.print(\"OK\");\n                return;\n            }\n            boolean firstParam = true;\n            for (Entry<String,String[]> param : actual.entrySet()) {\n                if (firstParam) {\n                    firstParam = false;\n                } else {\n                    w.print(';');\n                }\n                w.print(param.getKey());\n                w.print(':');\n                boolean firstValue = true;\n                for (String value : param.getValue()) {\n                    if (firstValue) {\n                        firstValue = false;\n                    } else {\n                        w.print(',');\n                    }\n                    w.print('(');\n                    w.print(value);\n                    w.print(')');\n                }\n            }\n        }","id":78677,"modified_method":"@Override\n        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n                throws ServletException, IOException {\n            req.setCharacterEncoding(\"UTF-8\");\n            resp.setContentType(\"text/plain\");\n            resp.setCharacterEncoding(\"UTF-8\");\n            PrintWriter w = resp.getWriter();\n            Map<String,String[]> actual = req.getParameterMap();\n\n            boolean ok = true;\n            for (Entry<String,String[]> entry : actual.entrySet()) {\n                String[] expectedValue = expected.get(entry.getKey());\n                if (expectedValue == null ||\n                        expectedValue.length != entry.getValue().length) {\n                    ok = false;\n                    break;\n                }\n                for (int i = 0; i < expectedValue.length; i++) {\n                    if (!expectedValue[i].equals(entry.getValue()[i])) {\n                        ok = false;\n                        break;\n                    }\n                }\n                if (!ok) {\n                    break;\n                }\n            }\n\n            if (ok) {\n                w.print(\"OK\");\n                return;\n            }\n            boolean firstParam = true;\n            for (Entry<String,String[]> param : actual.entrySet()) {\n                if (firstParam) {\n                    firstParam = false;\n                } else {\n                    w.print(';');\n                }\n                w.print(param.getKey());\n                w.print(':');\n                boolean firstValue = true;\n                for (String value : param.getValue()) {\n                    if (firstValue) {\n                        firstValue = false;\n                    } else {\n                        w.print(',');\n                    }\n                    w.print('(');\n                    w.print(value);\n                    w.print(')');\n                }\n            }\n        }","commit_id":"40045f250ee6dbcb237f66abba42ce74ada7fb65","url":"https://github.com/apache/tomcat"},{"original_method":"public Object invoke(Object target, String methodName, Object[] arguments) {\n        if(arguments.length == 0)\n            throw new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n\n        Map argMap = arguments[0] instanceof Map ? (Map)arguments[0] : Collections.EMPTY_MAP;\n        if(argMap.size() == 0){\n            throw new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n        }\n\n\n        Object actionRef = argMap.get(ARGUMENT_ACTION);\n        String controllerName = argMap.containsKey(ARGUMENT_CONTROLLER) ? argMap.get(ARGUMENT_CONTROLLER).toString() : null;\n\n        Object id = argMap.get(ARGUMENT_ID);\n        Object uri = argMap.get(ARGUMENT_URI);\n        String url = argMap.containsKey(ARGUMENT_URL) ? argMap.get(ARGUMENT_URL).toString() : null;\n        Map params = (Map)argMap.get(ARGUMENT_PARAMS);\n        if(params==null)params = new HashMap();\n        Errors errors = (Errors)argMap.get(ARGUMENT_ERRORS);\n        GroovyObject controller = (GroovyObject)target;\n\n        // if there are errors add it to the list of errors\n        Errors controllerErrors = (Errors)controller.getProperty( ControllerDynamicMethods.ERRORS_PROPERTY );\n        if(controllerErrors != null) {\n            controllerErrors.addAllErrors(errors);\n        }\n        else {\n            controller.setProperty( ControllerDynamicMethods.ERRORS_PROPERTY, errors);\n        }\n\n        String actualUri;\n        GrailsWebRequest webRequest = (GrailsWebRequest)RequestContextHolder.currentRequestAttributes();\n        \n        GrailsApplicationAttributes attrs = webRequest.getAttributes();\n        HttpServletRequest request = webRequest.getCurrentRequest();\n        HttpServletResponse response = webRequest.getCurrentResponse();\n\n        if(uri != null) {\n            actualUri = attrs.getApplicationUri(request) + uri.toString();\n        }\n        else if(url != null) {\n            actualUri = url;\n        }\n        else {            \n            String actionName = establishActionName(actionRef, target, webRequest);\n            controllerName = controllerName != null ? controllerName : webRequest.getControllerName();\n\n            if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Dynamic method [redirect] looking up URL mapping for controller [\"+controllerName+\"] and action [\"+actionName+\"] and params [\"+params+\"] with [\"+urlMappingsHolder+\"]\");\n            }\n\n\n\n            try {\n                if( id != null ) params.put( ARGUMENT_ID, id );\n\n                UrlCreator urlMapping = urlMappingsHolder.getReverseMapping( controllerName, actionName, params );\n                if( LOG.isDebugEnabled() && urlMapping == null ) {\n                    LOG.debug( \"Dynamic method [redirect] no URL mapping found for params [\" + params + \"]\" );\n                }\n\n                String action = actionName != null ? actionName : webRequest.getActionName();\n                actualUri = attrs.getApplicationUri(request) +\n                            urlMapping.createURL( controllerName, action, params, request.getCharacterEncoding() );\n\n                if( LOG.isDebugEnabled() ) {\n                    LOG.debug( \"Dynamic method [redirect] mapped to URL [\" + actualUri + \"]\" );\n                }\n\n            } finally {\n                if( id != null ) params.remove( ARGUMENT_ID );\n            }\n\n        }\n\n        return redirectResponse(actualUri, response);\n    }","id":78678,"modified_method":"public Object invoke(Object target, String methodName, Object[] arguments) {\n        if(arguments.length == 0)\n            throw new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n\n        Map argMap = arguments[0] instanceof Map ? (Map)arguments[0] : Collections.EMPTY_MAP;\n        if(argMap.size() == 0){\n            throw new MissingMethodException(METHOD_SIGNATURE,target.getClass(),arguments);\n        }\n\n\n        Object actionRef = argMap.get(ARGUMENT_ACTION);\n        String controllerName = argMap.containsKey(ARGUMENT_CONTROLLER) ? argMap.get(ARGUMENT_CONTROLLER).toString() : null;\n\n        Object id = argMap.get(ARGUMENT_ID);\n        Object uri = argMap.get(ARGUMENT_URI);\n        String url = argMap.containsKey(ARGUMENT_URL) ? argMap.get(ARGUMENT_URL).toString() : null;\n        Map params = (Map)argMap.get(ARGUMENT_PARAMS);\n        if(params==null)params = new HashMap();\n        Errors errors = (Errors)argMap.get(ARGUMENT_ERRORS);\n        GroovyObject controller = (GroovyObject)target;\n\n        // if there are errors add it to the list of errors\n        Errors controllerErrors = (Errors)controller.getProperty( ControllerDynamicMethods.ERRORS_PROPERTY );\n        if(controllerErrors != null) {\n            controllerErrors.addAllErrors(errors);\n        }\n        else {\n            controller.setProperty( ControllerDynamicMethods.ERRORS_PROPERTY, errors);\n        }\n\n        String actualUri;\n        GrailsWebRequest webRequest = (GrailsWebRequest)RequestContextHolder.currentRequestAttributes();\n        \n        GrailsApplicationAttributes attrs = webRequest.getAttributes();\n        HttpServletRequest request = webRequest.getCurrentRequest();\n        HttpServletResponse response = webRequest.getCurrentResponse();\n\n        if(uri != null) {\n            actualUri = attrs.getApplicationUri(request) + uri.toString();\n        }\n        else if(url != null) {\n            actualUri = url;\n        }\n        else {            \n            String actionName = establishActionName(actionRef, target, webRequest);\n            controllerName = controllerName != null ? controllerName : webRequest.getControllerName();\n\n            if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Dynamic method [redirect] looking up URL mapping for controller [\"+controllerName+\"] and action [\"+actionName+\"] and params [\"+params+\"] with [\"+urlMappingsHolder+\"]\");\n            }\n\n\n\n            try {\n                if( id != null ) params.put( ARGUMENT_ID, id );\n\n                UrlCreator urlMapping = urlMappingsHolder.getReverseMapping( controllerName, actionName, params );\n                if( LOG.isDebugEnabled() && urlMapping == null ) {\n                    LOG.debug( \"Dynamic method [redirect] no URL mapping found for params [\" + params + \"]\" );\n                }\n\n                // The reverse mapping process requires a character\n                // encoding. We take the one from the request, but if\n                // that is null, then we default to 'UTF-8'.\n                String encoding = request.getCharacterEncoding();\n                if (encoding == null) {\n                \tencoding = \"UTF-8\";\n                }\n\n                String action = actionName != null ? actionName : webRequest.getActionName();\n                actualUri = attrs.getApplicationUri(request) +\n                            urlMapping.createURL( controllerName, action, params, encoding );\n\n                if( LOG.isDebugEnabled() ) {\n                    LOG.debug( \"Dynamic method [redirect] mapped to URL [\" + actualUri + \"]\" );\n                }\n\n            } finally {\n                if( id != null ) params.remove( ARGUMENT_ID );\n            }\n\n        }\n\n        return redirectResponse(actualUri, response);\n    }","commit_id":"c067da4b59d8d9601b91d7c9f047e7b239f3723e","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    public BinaryNamingScheme withVariantDimension(String dimension) {\n        List<String> newDimensions = new ArrayList<String>(dimensions.size() + 1);\n        newDimensions.addAll(dimensions);\n        newDimensions.add(dimension);\n        return new DefaultBinaryNamingScheme(parentName, roleName, newDimensions, null);\n    }","id":78679,"modified_method":"@Override\n    public BinaryNamingScheme withVariantDimension(String dimension) {\n        List<String> newDimensions = new ArrayList<String>(dimensions.size() + 1);\n        newDimensions.addAll(dimensions);\n        newDimensions.add(dimension);\n        return new DefaultBinaryNamingScheme(parentName, binaryType, role, main, newDimensions, null);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"public String getBinaryName() {\n        return makeName(dimensionPrefix, roleName);\n    }","id":78680,"modified_method":"public String getBinaryName() {\n        return makeName(dimensionPrefix, binaryType);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public BinaryNamingScheme withRole(String role) {\n        return new DefaultBinaryNamingScheme(parentName, role, dimensions, null);\n    }","id":78681,"modified_method":"@Override\n    public BinaryNamingScheme withRole(String role, boolean isMain) {\n        return new DefaultBinaryNamingScheme(parentName, binaryType, role, isMain, dimensions, outputType);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"public String getOutputDirectoryBase() {\n        StringBuilder builder = new StringBuilder();\n        if (outputType != null) {\n            builder.append(outputType);\n            builder.append('/');\n        }\n        builder.append(makeName(parentName, roleName));\n        if (dimensionPrefix.length() > 0) {\n            builder.append('/');\n            builder.append(dimensionPrefix);\n        }\n        return builder.toString();\n    }","id":78682,"modified_method":"public String getOutputDirectoryBase() {\n        StringBuilder builder = new StringBuilder();\n        if (outputType != null) {\n            builder.append(outputType);\n            builder.append('/');\n        }\n        builder.append(makeName(parentName));\n        if (!main) {\n            if (role != null) {\n                builder.append('/');\n                builder.append(makeName(role));\n            } else if (binaryType != null) {\n                builder.append('/');\n                builder.append(makeName(binaryType));\n            }\n        }\n        for (String dimension : dimensions) {\n            builder.append('/');\n            builder.append(makeName(dimension));\n        }\n        return builder.toString();\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"public String getTaskName(@Nullable String verb, @Nullable String target) {\n        return makeName(verb, dimensionPrefix, parentName, roleName, target);\n    }","id":78683,"modified_method":"public String getTaskName(@Nullable String verb, @Nullable String target) {\n        return makeName(verb, dimensionPrefix, parentName, binaryType, target);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public BinaryNamingScheme withOutputType(String type) {\n        return new DefaultBinaryNamingScheme(parentName, roleName, dimensions, type);\n    }","id":78684,"modified_method":"@Override\n    public BinaryNamingScheme withOutputType(String type) {\n        return new DefaultBinaryNamingScheme(parentName, binaryType, role, main, dimensions, type);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public BinaryNamingScheme withComponentName(String componentName) {\n        return new DefaultBinaryNamingScheme(componentName, roleName, dimensions, null);\n    }","id":78685,"modified_method":"@Override\n    public BinaryNamingScheme withComponentName(String componentName) {\n        return new DefaultBinaryNamingScheme(componentName, binaryType, role, main, dimensions, null);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"public static BinaryNamingScheme component(String componentName) {\n        return new DefaultBinaryNamingScheme(componentName, null, Collections.<String>emptyList(), null);\n    }","id":78686,"modified_method":"public static BinaryNamingScheme component(String componentName) {\n        return new DefaultBinaryNamingScheme(componentName, null, null, false, Collections.<String>emptyList(), null);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"public String getDescription() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(GUtil.toWords(roleName));\n        builder.append(\" '\");\n        builder.append(parentName);\n        for (String dimension : dimensions) {\n            builder.append(':');\n            builder.append(dimension);\n        }\n        builder.append(':');\n        appendUncapitalized(builder, roleName);\n        builder.append(\"'\");\n        return builder.toString();\n    }","id":78687,"modified_method":"public String getDescription() {\n        StringBuilder builder = new StringBuilder();\n        builder.append(GUtil.toWords(binaryType));\n        builder.append(\" '\");\n        builder.append(parentName);\n        for (String dimension : dimensions) {\n            builder.append(':');\n            builder.append(dimension);\n        }\n        builder.append(':');\n        appendUncapitalized(builder, binaryType);\n        builder.append(\"'\");\n        return builder.toString();\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultBinaryNamingScheme(String parentName, String roleName, List<String> dimensions, String outputType) {\n        this.parentName = parentName;\n        this.roleName = roleName;\n        this.dimensions = dimensions;\n        this.outputType = outputType;\n        this.dimensionPrefix = createPrefix(dimensions);\n    }","id":78688,"modified_method":"DefaultBinaryNamingScheme(String parentName, @Nullable String binaryType, @Nullable String role, boolean main, List<String> dimensions, @Nullable String outputType) {\n        this.parentName = parentName;\n        this.binaryType = binaryType;\n        this.role = role;\n        this.main = main;\n        this.dimensions = dimensions;\n        this.outputType = outputType;\n        this.dimensionPrefix = createPrefix(dimensions);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private String buildBinaryName(JvmLibrarySpec jvmLibrary, List<JavaPlatform> selectedPlatforms, JavaPlatform platform) {\n            BinaryNamingScheme namingScheme = DefaultBinaryNamingScheme.component(jvmLibrary.getName()).withRole(\"jar\");\n            namingScheme = namingScheme.withVariantDimension(platform, selectedPlatforms);\n            return namingScheme.getBinaryName();\n        }","id":78689,"modified_method":"private String buildBinaryName(JvmLibrarySpec jvmLibrary, List<JavaPlatform> selectedPlatforms, JavaPlatform platform) {\n            BinaryNamingScheme namingScheme = DefaultBinaryNamingScheme.component(jvmLibrary.getName())\n                    .withBinaryType(\"Jar\")\n                    .withRole(\"jar\", true)\n                    .withVariantDimension(platform, selectedPlatforms);\n            return namingScheme.getBinaryName();\n        }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"public static void createNativeBinaries(\n        NativeComponentSpec component,\n        ModelMap<NativeBinarySpec> binaries,\n        NativeDependencyResolver resolver,\n        BinaryNamingScheme namingScheme,\n        NativePlatform platform,\n        BuildType buildType,\n        Flavor flavor\n    ) {\n        if (component instanceof NativeLibrarySpec) {\n            createNativeBinary(SharedLibraryBinarySpec.class, binaries, resolver, namingScheme.withRole(\"SharedLibrary\"), platform, buildType, flavor);\n            createNativeBinary(StaticLibraryBinarySpec.class, binaries, resolver, namingScheme.withRole(\"StaticLibrary\"), platform, buildType, flavor);\n        } else {\n            createNativeBinary(NativeExecutableBinarySpec.class, binaries, resolver, namingScheme.withRole(\"Executable\"), platform, buildType, flavor);\n        }\n    }","id":78690,"modified_method":"public static void createNativeBinaries(\n        NativeComponentSpec component,\n        ModelMap<NativeBinarySpec> binaries,\n        NativeDependencyResolver resolver,\n        BinaryNamingScheme namingScheme,\n        NativePlatform platform,\n        BuildType buildType,\n        Flavor flavor\n    ) {\n        if (component instanceof NativeLibrarySpec) {\n            createNativeBinary(SharedLibraryBinarySpec.class, binaries, resolver, namingScheme.withBinaryType(\"SharedLibrary\").withRole(\"shared\", false), platform, buildType, flavor);\n            createNativeBinary(StaticLibraryBinarySpec.class, binaries, resolver, namingScheme.withBinaryType(\"StaticLibrary\").withRole(\"static\", false), platform, buildType, flavor);\n        } else {\n            createNativeBinary(NativeExecutableBinarySpec.class, binaries, resolver, namingScheme.withBinaryType(\"Executable\").withRole(\"executable\", true), platform, buildType, flavor);\n        }\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private static File sharedLibraryFileFor(NativeBinarySpecInternal nativeBinary, File buildDir) {\n        return binaryOutputFileFor(nativeBinary, buildDir, sharedLibraryNameFor(nativeBinary));\n    }","id":78691,"modified_method":"private static File sharedLibraryFileFor(NativeBinarySpecInternal nativeBinary, File buildDir) {\n        return new File(nativeBinary.getNamingScheme().withOutputType(\"libs\").getOutputDirectory(buildDir), sharedLibraryNameFor(nativeBinary));\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private static File installationDirFor(NativeBinarySpecInternal nativeBinary, File buildDir) {\n        return outputDirectoryFor(nativeBinary, buildDir, \"install\");\n    }","id":78692,"modified_method":"public static File installationDirFor(NativeBinarySpecInternal nativeBinary, File buildDir) {\n        return nativeBinary.getNamingScheme().withOutputType(\"install\").getOutputDirectory(buildDir);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private static File sharedLibraryLinkFileFor(NativeBinarySpecInternal nativeBinary, File buildDir) {\n        return binaryOutputFileFor(nativeBinary, buildDir, sharedLibraryLinkFileNameFor(nativeBinary));\n    }","id":78693,"modified_method":"private static File sharedLibraryLinkFileFor(NativeBinarySpecInternal nativeBinary, File buildDir) {\n        return new File(nativeBinary.getNamingScheme().withOutputType(\"libs\").getOutputDirectory(buildDir), sharedLibraryLinkFileNameFor(nativeBinary));\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private static File executableFileFor(NativeBinarySpecInternal nativeBinary, File buildDir) {\n        return binaryOutputFileFor(nativeBinary, buildDir, executableNameFor(nativeBinary));\n    }","id":78694,"modified_method":"public static File executableFileFor(NativeBinarySpecInternal nativeBinary, File buildDir) {\n        return new File(nativeBinary.getNamingScheme().withOutputType(\"exe\").getOutputDirectory(buildDir), executableNameFor(nativeBinary));\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private static File staticLibraryFileFor(NativeBinarySpecInternal nativeBinary, File buildDir) {\n        return binaryOutputFileFor(nativeBinary, buildDir, staticLibraryNameFor(nativeBinary));\n    }","id":78695,"modified_method":"private static File staticLibraryFileFor(NativeBinarySpecInternal nativeBinary, File buildDir) {\n        return new File(nativeBinary.getNamingScheme().withOutputType(\"libs\").getOutputDirectory(buildDir), staticLibraryNameFor(nativeBinary));\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private static String executableNameFor(NativeTestSuiteBinarySpecInternal testBinary) {\n        String baseName = testBinary.getComponent().getBaseName();\n        return testBinary.getPlatformToolProvider().getExecutableName(baseName);\n    }","id":78696,"modified_method":"private static File executableFileFor(NativeTestSuiteBinarySpecInternal testBinary, File buildDir) {\n        return NativeBinaryRules.executableFileFor(testBinary, buildDir);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private static File executableFileFor(NativeTestSuiteBinarySpecInternal testBinary, File buildDir, BinaryNamingScheme namingScheme) {\n        return new File(binariesDir(buildDir, namingScheme), executableNameFor(testBinary));\n    }","id":78697,"modified_method":"private static File installDir(NativeTestSuiteBinarySpecInternal testBinary, File buildDir) {\n        return NativeBinaryRules.installationDirFor(testBinary, buildDir);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private static void createNativeTestSuiteBinary(NativeTestSuiteSpec testSuite,\n                                                   Class<? extends NativeTestSuiteBinarySpec> testSuiteBinaryClass,\n                                                   String typeString, final NativeBinarySpec testedBinary,\n                                                   final File buildDir, ServiceRegistry serviceRegistry) {\n\n        final BinaryNamingScheme namingScheme = namingSchemeFor(testSuite, (NativeBinarySpecInternal) testedBinary, typeString);\n        final NativeDependencyResolver resolver = serviceRegistry.get(NativeDependencyResolver.class);\n\n        testSuite.getBinaries().create(namingScheme.getBinaryName(), testSuiteBinaryClass, new Action<NativeTestSuiteBinarySpec>() {\n            @Override\n            public void execute(NativeTestSuiteBinarySpec binary) {\n                NativeTestSuiteBinarySpecInternal testBinary = (NativeTestSuiteBinarySpecInternal) binary;\n                testBinary.setTestedBinary((NativeBinarySpecInternal) testedBinary);\n                testBinary.setNamingScheme(namingScheme);\n                testBinary.setResolver(resolver);\n                testBinary.setToolChain(testedBinary.getToolChain());\n                testBinary.getExecutable().setToolChain(testedBinary.getToolChain());\n                testBinary.getExecutable().setFile(executableFileFor(testBinary, buildDir, namingScheme));\n                testBinary.getInstallation().setDirectory(installDir(buildDir, namingScheme));\n            }\n        });\n    }","id":78698,"modified_method":"private static void createNativeTestSuiteBinary(NativeTestSuiteSpec testSuite,\n                                                   Class<? extends NativeTestSuiteBinarySpec> testSuiteBinaryClass,\n                                                   String typeString, final NativeBinarySpec testedBinary,\n                                                   final File buildDir, ServiceRegistry serviceRegistry) {\n\n        final BinaryNamingScheme namingScheme = namingSchemeFor(testSuite, (NativeBinarySpecInternal) testedBinary, typeString);\n        final NativeDependencyResolver resolver = serviceRegistry.get(NativeDependencyResolver.class);\n\n        testSuite.getBinaries().create(namingScheme.getBinaryName(), testSuiteBinaryClass, new Action<NativeTestSuiteBinarySpec>() {\n            @Override\n            public void execute(NativeTestSuiteBinarySpec binary) {\n                NativeTestSuiteBinarySpecInternal testBinary = (NativeTestSuiteBinarySpecInternal) binary;\n                testBinary.setTestedBinary((NativeBinarySpecInternal) testedBinary);\n                testBinary.setNamingScheme(namingScheme);\n                testBinary.setResolver(resolver);\n                testBinary.setToolChain(testedBinary.getToolChain());\n                testBinary.getExecutable().setToolChain(testedBinary.getToolChain());\n                testBinary.getExecutable().setFile(executableFileFor(testBinary, buildDir));\n                testBinary.getInstallation().setDirectory(installDir(testBinary, buildDir));\n            }\n        });\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private static BinaryNamingScheme namingSchemeFor(NativeTestSuiteSpec testSuite, NativeBinarySpecInternal testedBinary, String typeString) {\n        return testedBinary.getNamingScheme()\n            .withComponentName(testSuite.getBaseName())\n            .withRole(typeString);\n    }","id":78699,"modified_method":"private static BinaryNamingScheme namingSchemeFor(NativeTestSuiteSpec testSuite, NativeBinarySpecInternal testedBinary, String typeString) {\n        return testedBinary.getNamingScheme()\n            .withComponentName(testSuite.getBaseName())\n            .withBinaryType(typeString)\n            .withRole(\"executable\", true);\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"private <T extends NativeLibraryBinary> String getName(Class<T> type, PrebuiltLibrary library, NativePlatform platform, BuildType buildType, Flavor flavor) {\n        BinaryNamingScheme namingScheme = DefaultBinaryNamingScheme.component(library.getName())\n                .withRole(type.getSimpleName())\n                .withVariantDimension(platform.getName())\n                .withVariantDimension(buildType.getName())\n                .withVariantDimension(flavor.getName());\n        return namingScheme.getBinaryName();\n    }","id":78700,"modified_method":"private <T extends NativeLibraryBinary> String getName(Class<T> type, PrebuiltLibrary library, NativePlatform platform, BuildType buildType, Flavor flavor) {\n        BinaryNamingScheme namingScheme = DefaultBinaryNamingScheme.component(library.getName())\n                .withBinaryType(type.getSimpleName())\n                .withVariantDimension(platform.getName())\n                .withVariantDimension(buildType.getName())\n                .withVariantDimension(flavor.getName());\n        return namingScheme.getBinaryName();\n    }","commit_id":"14433a0f44688b4c38e7d64baadb789f700d3219","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public KVMStoragePool createStoragePool(String name, String host, int port,\n                                            String path, String userInfo, StoragePoolType type) {\n        StoragePool sp = null;\n        Connect conn = null;\n        try {\n            conn = LibvirtConnection.getConnection();\n        } catch (LibvirtException e) {\n            throw new CloudRuntimeException(e.toString());\n        }\n\n        try {\n            sp = conn.storagePoolLookupByUUIDString(name);\n            if (sp != null && sp.isActive() == 0) {\n                sp.undefine();\n                sp = null;\n                s_logger.debug(\"Found existing defined storage pool \" + name + \". It wasn't running, so we undefined it.\");\n            }\n            if (sp != null) {\n                s_logger.debug(\"Found existing defined storage pool \" + name + \", using it.\");\n            }\n        } catch (LibvirtException e) {\n            sp = null;\n            s_logger.debug(\"createStoragePool didn't find existing running pool: \" + e + \", need to create it\");\n        }\n\n        // libvirt strips trailing slashes off of path, we will too in order to match\n        // existing paths\n        if (path.endsWith(\"/\")) {\n            path = path.substring(0, path.length() - 1);\n        }\n\n        if (sp == null) {\n            // see if any existing pool by another name is using our storage path.\n            // if anyone is, undefine the pool so we can define it as requested.\n            // This should be safe since a pool in use can't be removed, and no\n            // volumes are affected by unregistering the pool with libvirt.\n            s_logger.debug(\"Didn't find an existing storage pool \" + name \n                            + \" by UUID, checking for pools with duplicate paths\");\n\n            try {\n                String[] poolnames = conn.listStoragePools();\n                for (String poolname : poolnames) {\n                    s_logger.debug(\"Checking path of existing pool \" + poolname \n                                    + \" against pool we want to create\");\n                    StoragePool p = conn.storagePoolLookupByName(poolname);\n                    LibvirtStoragePoolDef pdef = getStoragePoolDef(conn, p);\n\n                    if (pdef.getTargetPath().equals(path)) {\n                        s_logger.debug(\"Storage pool utilizing path '\" + path + \"' already exists as pool \"\n                                       + poolname + \", undefining so we can re-define with correct name \" + name);\n                        if (p.isPersistent() == 1) {\n                            p.destroy();\n                            p.undefine();\n                        } else {\n                            p.destroy();\n                        }\n                    }\n                }\n            } catch (LibvirtException e) {\n                s_logger.error(\"Failure in attempting to see if an existing storage pool might \" \n                               + \"be using the path of the pool to be created:\" + e);\n            }\n\n            s_logger.debug(\"Attempting to create storage pool \" + name);\n\n            if (type == StoragePoolType.NetworkFilesystem) {\n                sp = createNfsStoragePool(conn, name, host, path);\n            } else if (type == StoragePoolType.SharedMountPoint\n                    || type == StoragePoolType.Filesystem) {\n                sp = createSharedStoragePool(conn, name, host, path);\n            } else if (type == StoragePoolType.RBD) {\n                sp = createRBDStoragePool(conn, name, host, port, userInfo, path);\n            } else if (type == StoragePoolType.CLVM) {\n                sp = createCLVMStoragePool(conn, name, host, path);\n            }\n        }\n\n        try {\n            if (sp.isActive() == 0) {\n                s_logger.debug(\"attempting to activate pool \" + name);\n                sp.create(0);\n            }\n\n            LibvirtStoragePoolDef spd = getStoragePoolDef(conn, sp);\n            LibvirtStoragePool pool = new LibvirtStoragePool(name,\n                    sp.getName(), type, this, sp);\n\n            if (pool.getType() != StoragePoolType.RBD) {\n                pool.setLocalPath(spd.getTargetPath());\n            } else {\n                pool.setLocalPath(\"\");\n            }\n\n            pool.setCapacity(sp.getInfo().capacity);\n            pool.setUsed(sp.getInfo().allocation);\n            pool.setAvailable(sp.getInfo().available);\n  \n            return pool;\n        } catch (LibvirtException e) {\n            String error = e.toString();\n            if (error.contains(\"Storage source conflict\")) {\n                throw new CloudRuntimeException(\"A pool matching this location already exists in libvirt, \"\n                                  + \" but has a different UUID/Name. Cannot create new pool without first \" \n                                  + \" removing it. Check for inactive pools via 'virsh pool-list --all'. \" \n                                  + error);\n            } else {\n                throw new CloudRuntimeException(error);\n            }\n        }\n    }","id":78701,"modified_method":"@Override\n    public KVMStoragePool createStoragePool(String name, String host, int port,\n                                            String path, String userInfo, StoragePoolType type) {\n        StoragePool sp = null;\n        Connect conn = null;\n        try {\n            conn = LibvirtConnection.getConnection();\n        } catch (LibvirtException e) {\n            throw new CloudRuntimeException(e.toString());\n        }\n\n        try {\n            sp = conn.storagePoolLookupByUUIDString(name);\n            if (sp != null && sp.isActive() == 0) {\n                sp.undefine();\n                sp = null;\n                s_logger.debug(\"Found existing defined storage pool \" + name + \". It wasn't running, so we undefined it.\");\n            }\n            if (sp != null) {\n                s_logger.debug(\"Found existing defined storage pool \" + name + \", using it.\");\n            }\n        } catch (LibvirtException e) {\n            sp = null;\n            s_logger.debug(\"createStoragePool didn't find existing running pool: \" + e + \", need to create it\");\n        }\n\n        // libvirt strips trailing slashes off of path, we will too in order to match\n        // existing paths\n        if (path.endsWith(\"/\")) {\n            path = path.substring(0, path.length() - 1);\n        }\n\n        if (sp == null) {\n            // see if any existing pool by another name is using our storage path.\n            // if anyone is, undefine the pool so we can define it as requested.\n            // This should be safe since a pool in use can't be removed, and no\n            // volumes are affected by unregistering the pool with libvirt.\n            s_logger.debug(\"Didn't find an existing storage pool \" + name \n                            + \" by UUID, checking for pools with duplicate paths\");\n\n            try {\n                String[] poolnames = conn.listStoragePools();\n                for (String poolname : poolnames) {\n                    s_logger.debug(\"Checking path of existing pool \" + poolname \n                                    + \" against pool we want to create\");\n                    StoragePool p = conn.storagePoolLookupByName(poolname);\n                    LibvirtStoragePoolDef pdef = getStoragePoolDef(conn, p);\n\n                    String targetPath = pdef.getTargetPath();\n                    if (targetPath != null && targetPath.equals(path)) {\n                        s_logger.debug(\"Storage pool utilizing path '\" + path + \"' already exists as pool \"\n                                       + poolname + \", undefining so we can re-define with correct name \" + name);\n                        if (p.isPersistent() == 1) {\n                            p.destroy();\n                            p.undefine();\n                        } else {\n                            p.destroy();\n                        }\n                    }\n                }\n            } catch (LibvirtException e) {\n                s_logger.error(\"Failure in attempting to see if an existing storage pool might \" \n                               + \"be using the path of the pool to be created:\" + e);\n            }\n\n            s_logger.debug(\"Attempting to create storage pool \" + name);\n\n            if (type == StoragePoolType.NetworkFilesystem) {\n                sp = createNfsStoragePool(conn, name, host, path);\n            } else if (type == StoragePoolType.SharedMountPoint\n                    || type == StoragePoolType.Filesystem) {\n                sp = createSharedStoragePool(conn, name, host, path);\n            } else if (type == StoragePoolType.RBD) {\n                sp = createRBDStoragePool(conn, name, host, port, userInfo, path);\n            } else if (type == StoragePoolType.CLVM) {\n                sp = createCLVMStoragePool(conn, name, host, path);\n            }\n        }\n\n        try {\n            if (sp.isActive() == 0) {\n                s_logger.debug(\"attempting to activate pool \" + name);\n                sp.create(0);\n            }\n\n            LibvirtStoragePoolDef spd = getStoragePoolDef(conn, sp);\n            LibvirtStoragePool pool = new LibvirtStoragePool(name,\n                    sp.getName(), type, this, sp);\n\n            if (pool.getType() != StoragePoolType.RBD) {\n                pool.setLocalPath(spd.getTargetPath());\n            } else {\n                pool.setLocalPath(\"\");\n            }\n\n            pool.setCapacity(sp.getInfo().capacity);\n            pool.setUsed(sp.getInfo().allocation);\n            pool.setAvailable(sp.getInfo().available);\n  \n            return pool;\n        } catch (LibvirtException e) {\n            String error = e.toString();\n            if (error.contains(\"Storage source conflict\")) {\n                throw new CloudRuntimeException(\"A pool matching this location already exists in libvirt, \"\n                                  + \" but has a different UUID/Name. Cannot create new pool without first \" \n                                  + \" removing it. Check for inactive pools via 'virsh pool-list --all'. \" \n                                  + error);\n            } else {\n                throw new CloudRuntimeException(error);\n            }\n        }\n    }","commit_id":"738067077a184aa355005b53979be6c397920f82","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public KVMStoragePool createStoragePool(String name, String host, int port,\n                                            String path, String userInfo, StoragePoolType type) {\n        StoragePool sp = null;\n        Connect conn = null;\n        try {\n            conn = LibvirtConnection.getConnection();\n        } catch (LibvirtException e) {\n            throw new CloudRuntimeException(e.toString());\n        }\n\n        try {\n            sp = conn.storagePoolLookupByUUIDString(name);\n            if (sp != null && sp.isActive() == 0) {\n                sp.undefine();\n                sp = null;\n                s_logger.debug(\"Found existing defined storage pool \" + name + \". It wasn't running, so we undefined it.\");\n            }\n            if (sp != null) {\n                s_logger.debug(\"Found existing defined storage pool \" + name + \", using it.\");\n            }\n        } catch (LibvirtException e) {\n            sp = null;\n            s_logger.debug(\"createStoragePool didn't find existing running pool: \" + e + \", need to create it\");\n        }\n\n        // libvirt strips trailing slashes off of path, we will too in order to match\n        // existing paths\n        if (path.endsWith(\"/\")) {\n            path = path.substring(0, path.length() - 1);\n        }\n\n        if (sp == null) {\n            // see if any existing pool by another name is using our storage path.\n            // if anyone is, undefine the pool so we can define it as requested.\n            // This should be safe since a pool in use can't be removed, and no\n            // volumes are affected by unregistering the pool with libvirt.\n            s_logger.debug(\"Didn't find an existing storage pool \" + name \n                            + \" by UUID, checking for pools with duplicate paths\");\n\n            try {\n                String[] poolnames = conn.listStoragePools();\n                for (String poolname : poolnames) {\n                    s_logger.debug(\"Checking path of existing pool \" + poolname \n                                    + \" against pool we want to create\");\n                    StoragePool p = conn.storagePoolLookupByName(poolname);\n                    LibvirtStoragePoolDef pdef = getStoragePoolDef(conn, p);\n\n                    if (pdef.getTargetPath().equals(path)) {\n                        s_logger.debug(\"Storage pool utilizing path '\" + path + \"' already exists as pool \"\n                                       + poolname + \", undefining so we can re-define with correct name \" + name);\n                        if (p.isPersistent() == 1) {\n                            p.destroy();\n                            p.undefine();\n                        } else {\n                            p.destroy();\n                        }\n                    }\n                }\n            } catch (LibvirtException e) {\n                s_logger.error(\"Failure in attempting to see if an existing storage pool might \" \n                               + \"be using the path of the pool to be created:\" + e);\n            }\n\n            s_logger.debug(\"Attempting to create storage pool \" + name);\n\n            if (type == StoragePoolType.NetworkFilesystem) {\n                sp = createNfsStoragePool(conn, name, host, path);\n            } else if (type == StoragePoolType.SharedMountPoint\n                    || type == StoragePoolType.Filesystem) {\n                sp = createSharedStoragePool(conn, name, host, path);\n            } else if (type == StoragePoolType.RBD) {\n                sp = createRBDStoragePool(conn, name, host, port, userInfo, path);\n            } else if (type == StoragePoolType.CLVM) {\n                sp = createCLVMStoragePool(conn, name, host, path);\n            }\n        }\n\n        try {\n            if (sp.isActive() == 0) {\n                s_logger.debug(\"attempting to activate pool \" + name);\n                sp.create(0);\n            }\n\n            LibvirtStoragePoolDef spd = getStoragePoolDef(conn, sp);\n            LibvirtStoragePool pool = new LibvirtStoragePool(name,\n                    sp.getName(), type, this, sp);\n\n            if (pool.getType() != StoragePoolType.RBD) {\n                pool.setLocalPath(spd.getTargetPath());\n            } else {\n                pool.setLocalPath(\"\");\n            }\n\n            pool.setCapacity(sp.getInfo().capacity);\n            pool.setUsed(sp.getInfo().allocation);\n            pool.setAvailable(sp.getInfo().available);\n  \n            return pool;\n        } catch (LibvirtException e) {\n            String error = e.toString();\n            if (error.contains(\"Storage source conflict\")) {\n                throw new CloudRuntimeException(\"A pool matching this location already exists in libvirt, \"\n                                  + \" but has a different UUID/Name. Cannot create new pool without first \" \n                                  + \" removing it. Check for inactive pools via 'virsh pool-list --all'. \" \n                                  + error);\n            } else {\n                throw new CloudRuntimeException(error);\n            }\n        }\n    }","id":78702,"modified_method":"@Override\n    public KVMStoragePool createStoragePool(String name, String host, int port,\n                                            String path, String userInfo, StoragePoolType type) {\n        StoragePool sp = null;\n        Connect conn = null;\n        try {\n            conn = LibvirtConnection.getConnection();\n        } catch (LibvirtException e) {\n            throw new CloudRuntimeException(e.toString());\n        }\n\n        try {\n            sp = conn.storagePoolLookupByUUIDString(name);\n            if (sp != null && sp.isActive() == 0) {\n                sp.undefine();\n                sp = null;\n                s_logger.debug(\"Found existing defined storage pool \" + name + \". It wasn't running, so we undefined it.\");\n            }\n            if (sp != null) {\n                s_logger.debug(\"Found existing defined storage pool \" + name + \", using it.\");\n            }\n        } catch (LibvirtException e) {\n            sp = null;\n            s_logger.debug(\"createStoragePool didn't find existing running pool: \" + e + \", need to create it\");\n        }\n\n        // libvirt strips trailing slashes off of path, we will too in order to match\n        // existing paths\n        if (path.endsWith(\"/\")) {\n            path = path.substring(0, path.length() - 1);\n        }\n\n        if (sp == null) {\n            // see if any existing pool by another name is using our storage path.\n            // if anyone is, undefine the pool so we can define it as requested.\n            // This should be safe since a pool in use can't be removed, and no\n            // volumes are affected by unregistering the pool with libvirt.\n            s_logger.debug(\"Didn't find an existing storage pool \" + name \n                            + \" by UUID, checking for pools with duplicate paths\");\n\n            try {\n                String[] poolnames = conn.listStoragePools();\n                for (String poolname : poolnames) {\n                    s_logger.debug(\"Checking path of existing pool \" + poolname \n                                    + \" against pool we want to create\");\n                    StoragePool p = conn.storagePoolLookupByName(poolname);\n                    LibvirtStoragePoolDef pdef = getStoragePoolDef(conn, p);\n\n                    String targetPath = pdef.getTargetPath();\n                    if (targetPath != null && targetPath.equals(path)) {\n                        s_logger.debug(\"Storage pool utilizing path '\" + path + \"' already exists as pool \"\n                                       + poolname + \", undefining so we can re-define with correct name \" + name);\n                        if (p.isPersistent() == 1) {\n                            p.destroy();\n                            p.undefine();\n                        } else {\n                            p.destroy();\n                        }\n                    }\n                }\n            } catch (LibvirtException e) {\n                s_logger.error(\"Failure in attempting to see if an existing storage pool might \" \n                               + \"be using the path of the pool to be created:\" + e);\n            }\n\n            s_logger.debug(\"Attempting to create storage pool \" + name);\n\n            if (type == StoragePoolType.NetworkFilesystem) {\n                sp = createNfsStoragePool(conn, name, host, path);\n            } else if (type == StoragePoolType.SharedMountPoint\n                    || type == StoragePoolType.Filesystem) {\n                sp = createSharedStoragePool(conn, name, host, path);\n            } else if (type == StoragePoolType.RBD) {\n                sp = createRBDStoragePool(conn, name, host, port, userInfo, path);\n            } else if (type == StoragePoolType.CLVM) {\n                sp = createCLVMStoragePool(conn, name, host, path);\n            }\n        }\n\n        try {\n            if (sp.isActive() == 0) {\n                s_logger.debug(\"attempting to activate pool \" + name);\n                sp.create(0);\n            }\n\n            LibvirtStoragePoolDef spd = getStoragePoolDef(conn, sp);\n            LibvirtStoragePool pool = new LibvirtStoragePool(name,\n                    sp.getName(), type, this, sp);\n\n            if (pool.getType() != StoragePoolType.RBD) {\n                pool.setLocalPath(spd.getTargetPath());\n            } else {\n                pool.setLocalPath(\"\");\n            }\n\n            pool.setCapacity(sp.getInfo().capacity);\n            pool.setUsed(sp.getInfo().allocation);\n            pool.setAvailable(sp.getInfo().available);\n  \n            return pool;\n        } catch (LibvirtException e) {\n            String error = e.toString();\n            if (error.contains(\"Storage source conflict\")) {\n                throw new CloudRuntimeException(\"A pool matching this location already exists in libvirt, \"\n                                  + \" but has a different UUID/Name. Cannot create new pool without first \" \n                                  + \" removing it. Check for inactive pools via 'virsh pool-list --all'. \" \n                                  + error);\n            } else {\n                throw new CloudRuntimeException(error);\n            }\n        }\n    }","commit_id":"68a428f84dea9c051456882d6762f419c40d90db","url":"https://github.com/apache/cloudstack"},{"original_method":"static boolean processResources(@NotNull Module module,\n                                  @NotNull MavenProject mavenProject,\n                                  ResourceProcessor processor) {\n    for (MavenResource resource : mavenProject.getResources()) {\n      if (resource.isFiltered()) {\n        VirtualFile resDir = LocalFileSystem.getInstance().findFileByPath(resource.getDirectory());\n        if (resDir == null) continue;\n\n        List<Pattern> includes = MavenResourceCompiler.collectPatterns(resource.getIncludes(), \"**/*\");\n        List<Pattern> excludes = MavenResourceCompiler.collectPatterns(resource.getExcludes(), null);\n        String targetPath = FileUtil.toSystemIndependentName(resource.getTargetPath());\n\n        if (processResources(module.getProject(), resDir, resDir, includes, excludes, targetPath, processor)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":78703,"modified_method":"static boolean processResources(@NotNull Module module,\n                                  @NotNull MavenProject mavenProject,\n                                  ResourceProcessor processor) {\n    for (MavenResource resource : mavenProject.getResources()) {\n      if (resource.isFiltered()) {\n        VirtualFile resDir = LocalFileSystem.getInstance().findFileByPath(resource.getDirectory());\n        if (resDir == null) continue;\n\n        List<Pattern> includes = MavenResourceCompiler.collectPatterns(resource.getIncludes(), \"**/*\");\n        List<Pattern> excludes = MavenResourceCompiler.collectPatterns(resource.getExcludes(), null);\n        final String resourceTargetPath = resource.getTargetPath();\n        if (resourceTargetPath != null) {\n          String targetPath = FileUtil.toSystemIndependentName(resourceTargetPath);\n\n          if (processResources(module.getProject(), resDir, resDir, includes, excludes, targetPath, processor)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }","commit_id":"3656e61075e70b16e6e96cfdb6673eb296595c2c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Build the default transformation description.\n     *\n     * @param discardPolicy the discard policy to use\n     * @param inherited whether the definition is inherited\n     * @param registry the attribute transformation rules for the resource\n     * @param discardedOperations the discarded operations\n     * @return the transformation description\n     */\n    protected TransformationDescription buildDefault(final DiscardPolicy discardPolicy, boolean inherited, final AttributeTransformationDescriptionBuilderImpl.AttributeTransformationDescriptionBuilderRegistry registry, List<String> discardedOperations) {\n        // Build attribute rules\n        final Map<String, AttributeTransformationDescription> attributes = registry.buildAttributes();\n        // Create operation transformers\n        final Map<String, OperationTransformer> operations = buildOperationTransformers(registry);\n        // Process children\n        final List<TransformationDescription> children = buildChildren();\n\n        // TODO override more global operations?\n        if(! operations.containsKey(ModelDescriptionConstants.WRITE_ATTRIBUTE_OPERATION)) {\n            operations.put(ModelDescriptionConstants.WRITE_ATTRIBUTE_OPERATION, OperationTransformationRules.createWriteOperation(attributes));\n        }\n        if(! operations.containsKey(ModelDescriptionConstants.UNDEFINE_ATTRIBUTE_OPERATION)) {\n            operations.put(ModelDescriptionConstants.UNDEFINE_ATTRIBUTE_OPERATION, OperationTransformationRules.createUndefinedOperation(attributes));\n        }\n        // Create the description\n        return new TransformingDescription(pathElement, pathAddressTransformer, discardPolicy, inherited, resourceTransformer, attributes, operations, children, discardedOperations);\n    }","id":78704,"modified_method":"/**\n     * Build the default transformation description.\n     *\n     * @param discardPolicy the discard policy to use\n     * @param inherited whether the definition is inherited\n     * @param registry the attribute transformation rules for the resource\n     * @param discardedOperations the discarded operations\n     * @return the transformation description\n     */\n    protected TransformationDescription buildDefault(final DiscardPolicy discardPolicy, boolean inherited, final AttributeTransformationDescriptionBuilderImpl.AttributeTransformationDescriptionBuilderRegistry registry, List<String> discardedOperations) {\n        // Build attribute rules\n        final Map<String, AttributeTransformationDescription> attributes = registry.buildAttributes();\n        // Create operation transformers\n        final Map<String, OperationTransformer> operations = buildOperationTransformers(registry);\n        // Process children\n        final List<TransformationDescription> children = buildChildren();\n\n        if (discardPolicy == DiscardPolicy.NEVER) {\n            // TODO override more global operations?\n            if(! operations.containsKey(ModelDescriptionConstants.WRITE_ATTRIBUTE_OPERATION)) {\n                operations.put(ModelDescriptionConstants.WRITE_ATTRIBUTE_OPERATION, OperationTransformationRules.createWriteOperation(attributes));\n            }\n            if(! operations.containsKey(ModelDescriptionConstants.UNDEFINE_ATTRIBUTE_OPERATION)) {\n                operations.put(ModelDescriptionConstants.UNDEFINE_ATTRIBUTE_OPERATION, OperationTransformationRules.createUndefinedOperation(attributes));\n            }\n        }\n        // Create the description\n        return new TransformingDescription(pathElement, pathAddressTransformer, discardPolicy, inherited, resourceTransformer, attributes, operations, children, discardedOperations);\n    }","commit_id":"36db0d8f2567dbad1be546a4c0c77c963c51f76c","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected OperationTransformer createTransformer(final TransformationRule first) {\n        return new OperationTransformer() {\n            @Override\n            public TransformedOperation transformOperation(final TransformationContext ctx, final PathAddress address, final ModelNode operation) throws OperationFailedException {\n\n                final DiscardPolicy.DiscardType type = discardPolicy.discard(operation, address, ctx);\n                if(type == DiscardPolicy.DiscardType.SILENT) {\n                    return OperationTransformer.DISCARD.transformOperation(ctx, address, operation);\n                } // TODO handle other cases\n\n                final Iterator<TransformationRule> iterator = Collections.<TransformationRule>emptyList().iterator();\n                final TransformationRule.ChainedOperationContext context = new TransformationRule.ChainedOperationContext(ctx) {\n\n                    @Override\n                    void invokeNext(OperationTransformer.TransformedOperation transformedOperation) throws OperationFailedException {\n                        recordTransformedOperation(transformedOperation);\n                        if(iterator.hasNext()) {\n                            final TransformationRule next = iterator.next();\n                            // TODO hmm, do we need to change the address?\n                            next.transformOperation(transformedOperation.getTransformedOperation(), address, this);\n                        } else {\n                            if (newName != null) {\n                                transformedOperation.getTransformedOperation().get(OP).set(newName);\n                            }\n                            final TransformationContext ctx = getContext();\n                            recordTransformedOperation(transformer.transformOperation(ctx, address, transformedOperation.getTransformedOperation()));\n                        }\n                    }\n                };\n                operation.get(ModelDescriptionConstants.OP_ADDR).set(address.toModelNode());\n                // Kick off the chain\n                first.transformOperation(operation, address, context);\n                // Create the composite operation result\n                return context.createOp();\n            }\n        };\n    }","id":78705,"modified_method":"protected OperationTransformer createTransformer(final TransformationRule first) {\n        return new OperationTransformer() {\n            @Override\n            public TransformedOperation transformOperation(final TransformationContext ctx, final PathAddress address, final ModelNode operation) throws OperationFailedException {\n\n                if(discardPolicy == DiscardPolicy.SILENT) {\n                    return OperationTransformer.DISCARD.transformOperation(ctx, address, operation);\n                } // TODO handle other cases\n\n                final Iterator<TransformationRule> iterator = Collections.<TransformationRule>emptyList().iterator();\n                final TransformationRule.ChainedOperationContext context = new TransformationRule.ChainedOperationContext(ctx) {\n\n                    @Override\n                    void invokeNext(OperationTransformer.TransformedOperation transformedOperation) throws OperationFailedException {\n                        recordTransformedOperation(transformedOperation);\n                        if(iterator.hasNext()) {\n                            final TransformationRule next = iterator.next();\n                            // TODO hmm, do we need to change the address?\n                            next.transformOperation(transformedOperation.getTransformedOperation(), address, this);\n                        } else {\n                            if (newName != null) {\n                                transformedOperation.getTransformedOperation().get(OP).set(newName);\n                            }\n                            final TransformationContext ctx = getContext();\n                            recordTransformedOperation(transformer.transformOperation(ctx, address, transformedOperation.getTransformedOperation()));\n                        }\n                    }\n                };\n                operation.get(ModelDescriptionConstants.OP_ADDR).set(address.toModelNode());\n                // Kick off the chain\n                first.transformOperation(operation, address, context);\n                // Create the composite operation result\n                return context.createOp();\n            }\n        };\n    }","commit_id":"36db0d8f2567dbad1be546a4c0c77c963c51f76c","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void assertTransformed(final ModelNode original, final TransformedOperation transformed) {\n        Assert.assertNotNull(transformed);\n        final ModelNode operation = transformed.getTransformedOperation();\n        Assert.assertNotNull(operation);\n        Assert.assertEquals(operation.get(ModelDescriptionConstants.OP).asString(), ModelDescriptionConstants.READ_RESOURCE_OPERATION);\n        Assert.assertTrue(original.get(ModelDescriptionConstants.OP_ADDR).equals(operation.get(ModelDescriptionConstants.OP_ADDR)));\n        Assert.assertTrue(transformed.rejectOperation(success()));\n        Assert.assertNotNull(transformed.getFailureDescription());\n    }","id":78706,"modified_method":"protected void assertRejected(final ModelNode original, final TransformedOperation transformed) {\n        Assert.assertNotNull(transformed);\n        final ModelNode operation = transformed.getTransformedOperation();\n        Assert.assertNotNull(operation);\n        Assert.assertEquals(READ_RESOURCE_OPERATION, ModelDescriptionConstants.READ_RESOURCE_OPERATION);\n        Assert.assertTrue(original.get(ModelDescriptionConstants.OP_ADDR).equals(operation.get(ModelDescriptionConstants.OP_ADDR)));\n        Assert.assertTrue(transformed.rejectOperation(success()));\n        Assert.assertNotNull(transformed.getFailureDescription());\n    }","commit_id":"36db0d8f2567dbad1be546a4c0c77c963c51f76c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testRejectResource() throws Exception {\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n        builder.rejectChildResource(DISCARDED_WILDCARD);\n        builder.rejectChildResource(DISCARDED_SPECIFIC);\n        TransformationDescription.Tools.register(builder.build(), transformersSubRegistration);\n\n        //Make sure the resource has none of the discarded children\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertEquals(1, model.keys().size());\n        Assert.assertEquals(\"test\", model.get(\"subs\").asString());\n\n        //Sanity check that the subsystem works\n        ModelNode op = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        TransformedOperation transformed = transformOperation(op);\n        Assert.assertEquals(op, transformed.getTransformedOperation());\n        Assert.assertFalse(transformed.rejectOperation(success()));\n\n        //Check that the op gets rejected for the wildcard entry\n        op = Util.createAddOperation(PathAddress.pathAddress(PATH, DISCARDED_WILDCARD_ENTRY));\n        transformed = transformOperation(op);\n        assertTransformed(op, transformed);\n\n        //Check that the op gets rejected for the specific entry\n        op = Util.createAddOperation(PathAddress.pathAddress(PATH, DISCARDED_SPECIFIC));\n        transformed = transformOperation(op);\n        assertTransformed(op, transformed);\n\n        //Check that the op gets rejected for the wildcard entry child\n        op = Util.createAddOperation(PathAddress.pathAddress(PATH, DISCARDED_WILDCARD_ENTRY, DISCARDED_CHILD));\n        transformed = transformOperation(op);\n        assertTransformed(op, transformed);\n\n        //Check that the op gets rejected for the specific entry child\n        op = Util.createAddOperation(PathAddress.pathAddress(PATH, DISCARDED_SPECIFIC, DISCARDED_CHILD));\n        transformed = transformOperation(op);\n        assertTransformed(op, transformed);\n    }","id":78707,"modified_method":"@Test\n    public void testRejectResource() throws Exception {\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n        builder.rejectChildResource(DISCARDED_WILDCARD);\n        builder.rejectChildResource(DISCARDED_SPECIFIC);\n        TransformationDescription.Tools.register(builder.build(), transformersSubRegistration);\n\n        //Make sure the resource has none of the discarded children\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertEquals(1, model.keys().size());\n        Assert.assertEquals(\"test\", model.get(\"subs\").asString());\n\n        //Sanity check that the subsystem works\n        sanityTestNonDiscardedResource();\n\n        //Check that the op gets rejected for the wildcard entry\n        rejectResourceOperationsTest(PathAddress.pathAddress(PATH, DISCARDED_WILDCARD_ENTRY));\n\n        //Check that the op gets rejected for the specific entry\n        rejectResourceOperationsTest(PathAddress.pathAddress(PATH, DISCARDED_SPECIFIC));\n\n        //Check that the op gets rejected for the wildcard entry child\n        rejectResourceOperationsTest(PathAddress.pathAddress(PATH, DISCARDED_WILDCARD_ENTRY, DISCARDED_CHILD));\n\n        //Check that the op gets rejected for the specific entry child\n        rejectResourceOperationsTest(PathAddress.pathAddress(PATH, DISCARDED_SPECIFIC, DISCARDED_CHILD));\n    }","commit_id":"36db0d8f2567dbad1be546a4c0c77c963c51f76c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDiscardResource() throws Exception {\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n        builder.discardChildResource(DISCARDED_WILDCARD);\n        builder.discardChildResource(DISCARDED_SPECIFIC);\n        TransformationDescription.Tools.register(builder.build(), transformersSubRegistration);\n\n        //Make sure the resource has none of the discarded children\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertEquals(1, model.keys().size());\n        Assert.assertEquals(\"test\", model.get(\"subs\").asString());\n\n        //Sanity check that the subsystem works\n        ModelNode op = Util.createAddOperation(PathAddress.pathAddress(PATH));\n        TransformedOperation transformed = transformOperation(op);\n        Assert.assertEquals(op, transformed.getTransformedOperation());\n        Assert.assertFalse(transformed.rejectOperation(success()));\n        Assert.assertNull(transformed.getFailureDescription());\n\n        //Check that the op gets discarded for the wildcard entry\n        op = Util.createAddOperation(PathAddress.pathAddress(PATH, DISCARDED_WILDCARD_ENTRY));\n        transformed = transformOperation(op);\n        Assert.assertNull(transformed.getTransformedOperation());\n        Assert.assertFalse(transformed.rejectOperation(success()));\n        Assert.assertNull(transformed.getFailureDescription());\n\n        //Check that the op gets discarded for the specific entry\n        op = Util.createAddOperation(PathAddress.pathAddress(PATH, DISCARDED_SPECIFIC));\n        transformed = transformOperation(op);\n        Assert.assertNull(transformed.getTransformedOperation());\n        Assert.assertFalse(transformed.rejectOperation(success()));\n        Assert.assertNull(transformed.getFailureDescription());\n\n        //Check that the op gets discarded for the wildcard entry child\n        op = Util.createAddOperation(PathAddress.pathAddress(PATH, DISCARDED_WILDCARD_ENTRY, DISCARDED_CHILD));\n        transformed = transformOperation(op);\n        Assert.assertNull(transformed.getTransformedOperation());\n        Assert.assertFalse(transformed.rejectOperation(success()));\n        Assert.assertNull(transformed.getFailureDescription());\n\n        //Check that the op gets discarded for the specific entry child\n        op = Util.createAddOperation(PathAddress.pathAddress(PATH, DISCARDED_SPECIFIC, DISCARDED_CHILD));\n        transformed = transformOperation(op);\n        Assert.assertNull(transformed.getTransformedOperation());\n        Assert.assertFalse(transformed.rejectOperation(success()));\n        Assert.assertNull(transformed.getFailureDescription());\n    }","id":78708,"modified_method":"@Test\n    public void testDiscardResource() throws Exception {\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createInstance(PATH);\n        builder.discardChildResource(DISCARDED_WILDCARD);\n        builder.discardChildResource(DISCARDED_SPECIFIC);\n        TransformationDescription.Tools.register(builder.build(), transformersSubRegistration);\n\n        //Make sure the resource has none of the discarded children\n        final Resource resource = transformResource();\n        Assert.assertNotNull(resource);\n        final Resource toto = resource.getChild(PATH);\n        Assert.assertNotNull(toto);\n        final ModelNode model = toto.getModel();\n        Assert.assertEquals(1, model.keys().size());\n        Assert.assertEquals(\"test\", model.get(\"subs\").asString());\n\n        //Sanity check that the subsystem works\n        sanityTestNonDiscardedResource();\n\n        //Check that the op gets discarded for the wildcard entry\n        discardResourceOperationsTest(PathAddress.pathAddress(PATH, DISCARDED_WILDCARD_ENTRY));\n\n        //Check that the op gets discarded for the specific entry\n        discardResourceOperationsTest(PathAddress.pathAddress(PATH, DISCARDED_SPECIFIC));\n\n        //Check that the op gets discarded for the wildcard entry child\n        discardResourceOperationsTest(PathAddress.pathAddress(PATH, DISCARDED_WILDCARD_ENTRY, DISCARDED_CHILD));\n\n        //Check that the op gets discarded for the specific entry child\n        discardResourceOperationsTest(PathAddress.pathAddress(PATH, DISCARDED_SPECIFIC, DISCARDED_CHILD));\n    }","commit_id":"36db0d8f2567dbad1be546a4c0c77c963c51f76c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public TransformationDescription build() {\n        final AttributeTransformationDescriptionBuilderImpl.AttributeTransformationDescriptionBuilderRegistry empty = new AttributeTransformationDescriptionBuilderImpl.AttributeTransformationDescriptionBuilderRegistry();\n        return buildDefault(DiscardPolicy.REJECT, true, empty);\n    }","id":78709,"modified_method":"@Override\n    public TransformationDescription build() {\n        final AttributeTransformationDescriptionBuilderImpl.AttributeTransformationDescriptionBuilderRegistry empty = new AttributeTransformationDescriptionBuilderImpl.AttributeTransformationDescriptionBuilderRegistry();\n        return buildDefault(DiscardPolicy.REJECT_AND_WARN, true, empty);\n    }","commit_id":"36db0d8f2567dbad1be546a4c0c77c963c51f76c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public OperationTransformer.TransformedOperation transformOperation(final TransformationContext ctx, final PathAddress address, final ModelNode operation) throws OperationFailedException {\n        // See whether the operation should be rejected or not\n        final DiscardPolicy.DiscardType type = discardPolicy.discard(operation, address, ctx);\n        switch (type) {\n            case REJECT_AND_WARN:\n                // Execute a read-resource operation to determine whether this operation should be rejected\n                return new TransformedOperation(operation, new OperationRejectionPolicy() {\n                    @Override\n                    public boolean rejectOperation(ModelNode preparedResult) {\n                        return true;\n                    }\n\n                    @Override\n                    public String getFailureDescription() {\n                        return ControllerMessages.MESSAGES.rejectResourceOperationTransformation(address, operation);\n                    }\n                }, OperationResultTransformer.ORIGINAL_RESULT);\n            case DISCARD_AND_WARN:\n            case SILENT:\n                return OperationTransformer.DISCARD.transformOperation(ctx, address, operation);\n        }\n        final Iterator<TransformationRule> iterator = rules.iterator();\n        final TransformationRule.ChainedOperationContext context = new TransformationRule.ChainedOperationContext(ctx) {\n\n            @Override\n            void invokeNext(OperationTransformer.TransformedOperation transformedOperation) throws OperationFailedException {\n                recordTransformedOperation(transformedOperation);\n                if(iterator.hasNext()) {\n                    final TransformationRule next = iterator.next();\n                    // TODO hmm, do we need to change the address?\n                    next.transformOperation(transformedOperation.getTransformedOperation(), address, this);\n                }\n            }\n        };\n        // Kick off the chain\n        final TransformationRule first = new AttributeTransformationRule(attributeTransformations);\n        first.transformOperation(operation, address, context);\n        // Create the composite operation result\n        return context.createOp();\n    }","id":78710,"modified_method":"@Override\n    public OperationTransformer.TransformedOperation transformOperation(final TransformationContext ctx, final PathAddress address, final ModelNode operation) throws OperationFailedException {\n        // See whether the operation should be rejected or not\n        switch (discardPolicy) {\n            case REJECT_AND_WARN:\n                // Execute a read-resource operation to determine whether this operation should be rejected\n                return new TransformedOperation(operation, new OperationRejectionPolicy() {\n                    @Override\n                    public boolean rejectOperation(ModelNode preparedResult) {\n                        return true;\n                    }\n\n                    @Override\n                    public String getFailureDescription() {\n                        return ControllerMessages.MESSAGES.rejectResourceOperationTransformation(address, operation);\n                    }\n                }, OperationResultTransformer.ORIGINAL_RESULT);\n            case DISCARD_AND_WARN:\n            case SILENT:\n                return OperationTransformer.DISCARD.transformOperation(ctx, address, operation);\n        }\n        final Iterator<TransformationRule> iterator = rules.iterator();\n        final TransformationRule.ChainedOperationContext context = new TransformationRule.ChainedOperationContext(ctx) {\n\n            @Override\n            void invokeNext(OperationTransformer.TransformedOperation transformedOperation) throws OperationFailedException {\n                recordTransformedOperation(transformedOperation);\n                if(iterator.hasNext()) {\n                    final TransformationRule next = iterator.next();\n                    // TODO hmm, do we need to change the address?\n                    next.transformOperation(transformedOperation.getTransformedOperation(), address, this);\n                }\n            }\n        };\n        // Kick off the chain\n        final TransformationRule first = new AttributeTransformationRule(attributeTransformations);\n        first.transformOperation(operation, address, context);\n        // Create the composite operation result\n        return context.createOp();\n    }","commit_id":"36db0d8f2567dbad1be546a4c0c77c963c51f76c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void transformResource(final ResourceTransformationContext ctx, final PathAddress address, final Resource original) throws OperationFailedException {\n        final ModelNode originalModel = TransformationRule.cloneAndProtect(original.getModel());\n        // See whether the model can be discarded\n        final DiscardPolicy.DiscardType type = discardPolicy.discard(originalModel, address, ctx);\n        switch (type) {\n            case DISCARD_AND_WARN:\n            case REJECT_AND_WARN:\n                ctx.getLogger().logRejectedResourceWarning(address, null);\n                return;\n            case SILENT:\n                ResourceTransformer.DISCARD.transformResource(ctx, address, original);\n                return;\n        }\n        final Iterator<TransformationRule> iterator = rules.iterator();\n        final TransformationRule.ChainedResourceContext context = new TransformationRule.ChainedResourceContext(ctx) {\n            @Override\n            void invokeNext(final Resource resource) throws OperationFailedException {\n                if(iterator.hasNext()) {\n                    final TransformationRule next = iterator.next();\n                    next.transformResource(resource, address, this);\n                } else {\n                    resourceTransformer.transformResource(ctx, address, resource);\n                }\n            }\n        };\n        // Kick off the chain\n        final TransformationRule rule = new AttributeTransformationRule(attributeTransformations);\n        rule.transformResource(original, address, context);\n    }","id":78711,"modified_method":"@Override\n    public void transformResource(final ResourceTransformationContext ctx, final PathAddress address, final Resource original) throws OperationFailedException {\n        final ModelNode originalModel = TransformationRule.cloneAndProtect(original.getModel());\n        // See whether the model can be discarded\n        switch (discardPolicy) {\n            case DISCARD_AND_WARN:\n            case REJECT_AND_WARN:\n                ctx.getLogger().logRejectedResourceWarning(address, null);\n                return;\n            case SILENT:\n                ResourceTransformer.DISCARD.transformResource(ctx, address, original);\n                return;\n        }\n        final Iterator<TransformationRule> iterator = rules.iterator();\n        final TransformationRule.ChainedResourceContext context = new TransformationRule.ChainedResourceContext(ctx) {\n            @Override\n            void invokeNext(final Resource resource) throws OperationFailedException {\n                if(iterator.hasNext()) {\n                    final TransformationRule next = iterator.next();\n                    next.transformResource(resource, address, this);\n                } else {\n                    resourceTransformer.transformResource(ctx, address, resource);\n                }\n            }\n        };\n        // Kick off the chain\n        final TransformationRule rule = new AttributeTransformationRule(attributeTransformations);\n        rule.transformResource(original, address, context);\n    }","commit_id":"36db0d8f2567dbad1be546a4c0c77c963c51f76c","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n  @Nullable\n  protected PsiMethod findOrCreateSetUpMethod(PsiClass clazz) throws IncorrectOperationException {\n    final PsiManager manager = clazz.getManager();\n    final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n\n    final PsiMethod patternMethod = factory.createMethodFromText(\"protected void setUp() throws Exception {\\nsuper.setUp();\\n}\", null);\n\n    final PsiClass baseClass = clazz.getSuperClass();\n    if (baseClass != null) {\n      final PsiMethod baseMethod = baseClass.findMethodBySignature(patternMethod, false);\n      if (baseMethod != null && baseMethod.hasModifierProperty(PsiModifier.PUBLIC)) {\n        PsiUtil.setModifierProperty(patternMethod, PsiModifier.PROTECTED, false);\n        PsiUtil.setModifierProperty(patternMethod, PsiModifier.PUBLIC, true);\n      }\n    }\n\n    PsiMethod inClass = clazz.findMethodBySignature(patternMethod, false);\n    if (inClass == null) {\n      return (PsiMethod)clazz.add(patternMethod);\n    }\n    else if (inClass.getBody() == null) {\n      return (PsiMethod)inClass.replace(patternMethod);\n    }\n    return inClass;\n  }","id":78712,"modified_method":"@Override\n  @Nullable\n  protected PsiMethod findOrCreateSetUpMethod(PsiClass clazz) throws IncorrectOperationException {\n    final PsiManager manager = clazz.getManager();\n    final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n\n    final PsiMethod patternMethod = factory.createMethodFromText(\"protected void setUp() throws Exception {\\nsuper.setUp();\\n}\", null);\n\n    final PsiClass baseClass = clazz.getSuperClass();\n    if (baseClass != null) {\n      final PsiMethod baseMethod = baseClass.findMethodBySignature(patternMethod, false);\n      if (baseMethod != null && baseMethod.hasModifierProperty(PsiModifier.PUBLIC)) {\n        PsiUtil.setModifierProperty(patternMethod, PsiModifier.PROTECTED, false);\n        PsiUtil.setModifierProperty(patternMethod, PsiModifier.PUBLIC, true);\n      }\n    }\n\n    PsiMethod inClass = clazz.findMethodBySignature(patternMethod, false);\n    if (inClass == null) {\n      PsiMethod testMethod = JUnitUtil.findFirstTestMethod(clazz);\n      if (testMethod != null) {\n        return (PsiMethod)clazz.addBefore(patternMethod, testMethod);\n      }\n      return (PsiMethod)clazz.add(patternMethod);\n    }\n    else if (inClass.getBody() == null) {\n      return (PsiMethod)inClass.replace(patternMethod);\n    }\n    return inClass;\n  }","commit_id":"cd5b299bf4e0d344a9dc1b8acd5eace1f0814c44","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  protected PsiMethod findOrCreateSetUpMethod(PsiClass clazz) throws IncorrectOperationException {\n    PsiMethod method = findSetUpMethod(clazz);\n    if (method != null) return method;\n\n    PsiManager manager = clazz.getManager();\n    PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n\n    method = factory.createMethodFromText(\"@org.junit.Before public void setUp() throws Exception {\\n}\", null);\n    method = (PsiMethod)clazz.add(method);\n    JavaCodeStyleManager.getInstance(manager.getProject()).shortenClassReferences(method);\n\n    return method;\n  }","id":78713,"modified_method":"@Override\n  @Nullable\n  protected PsiMethod findOrCreateSetUpMethod(PsiClass clazz) throws IncorrectOperationException {\n    PsiMethod method = findSetUpMethod(clazz);\n    if (method != null) return method;\n\n    PsiManager manager = clazz.getManager();\n    PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n\n    method = factory.createMethodFromText(\"@org.junit.Before public void setUp() throws Exception {\\n}\", null);\n    final PsiMethod testMethod = JUnitUtil.findFirstTestMethod(clazz);\n    if (testMethod != null) {\n      method = (PsiMethod)clazz.addBefore(method, testMethod);\n    } else {\n      method = (PsiMethod)clazz.add(method);\n    }\n    JavaCodeStyleManager.getInstance(manager.getProject()).shortenClassReferences(method);\n\n    return method;\n  }","commit_id":"cd5b299bf4e0d344a9dc1b8acd5eace1f0814c44","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected PsiMethod findOrCreateSetUpMethod(PsiClass clazz) throws IncorrectOperationException {\n    PsiMethod method = findSetUpMethod(clazz);\n    if (method != null) return method;\n\n    final PsiManager manager = clazz.getManager();\n    final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n    PsiMethod patternMethod =\n      factory.createMethodFromText(\"@org.testng.annotations.BeforeMethod\\n protected void setUp() throws Exception {}\", null);\n\n    final PsiClass superClass = clazz.getSuperClass();\n    if (superClass != null) {\n      final PsiMethod[] methods = superClass.findMethodsBySignature(patternMethod, false);\n      if (methods.length > 0) {\n        final PsiModifierList modifierList = methods[0].getModifierList();\n        if (!modifierList.hasModifierProperty(PsiModifier.PRIVATE)) { //do not override private method\n          @NonNls String pattern = \"@org.testng.annotations.BeforeMethod\\n\";\n          if (modifierList.hasModifierProperty(PsiModifier.PROTECTED)) {\n            pattern += \"protected \";\n          }\n          else if (modifierList.hasModifierProperty(PsiModifier.PUBLIC)) {\n            pattern += \"public \";\n          }\n          patternMethod = factory.createMethodFromText(pattern + \"void setUp() throws Exception {\\nsuper.setUp();\\n}\", null);\n        }\n      }\n    }\n\n    final PsiMethod[] psiMethods = clazz.getMethods();\n    PsiMethod inClass = null;\n    for (PsiMethod psiMethod : psiMethods) {\n      if (AnnotationUtil.isAnnotated(psiMethod, BeforeMethod.class.getName(), false)) {\n        inClass = psiMethod;\n        break;\n      }\n    }\n    if (inClass == null) {\n      final PsiMethod psiMethod = (PsiMethod)clazz.add(patternMethod);\n      JavaCodeStyleManager.getInstance(clazz.getProject()).shortenClassReferences(clazz);\n      return psiMethod;\n    }\n    else if (inClass.getBody() == null) {\n      return (PsiMethod)inClass.replace(patternMethod);\n    }\n    return inClass;\n  }","id":78714,"modified_method":"@Override\n  protected PsiMethod findOrCreateSetUpMethod(PsiClass clazz) throws IncorrectOperationException {\n    PsiMethod method = findSetUpMethod(clazz);\n    if (method != null) return method;\n\n    final PsiManager manager = clazz.getManager();\n    final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n    PsiMethod patternMethod =\n      factory.createMethodFromText(\"@org.testng.annotations.BeforeMethod\\n protected void setUp() throws Exception {}\", null);\n\n    final PsiClass superClass = clazz.getSuperClass();\n    if (superClass != null) {\n      final PsiMethod[] methods = superClass.findMethodsBySignature(patternMethod, false);\n      if (methods.length > 0) {\n        final PsiModifierList modifierList = methods[0].getModifierList();\n        if (!modifierList.hasModifierProperty(PsiModifier.PRIVATE)) { //do not override private method\n          @NonNls String pattern = \"@org.testng.annotations.BeforeMethod\\n\";\n          if (modifierList.hasModifierProperty(PsiModifier.PROTECTED)) {\n            pattern += \"protected \";\n          }\n          else if (modifierList.hasModifierProperty(PsiModifier.PUBLIC)) {\n            pattern += \"public \";\n          }\n          patternMethod = factory.createMethodFromText(pattern + \"void setUp() throws Exception {\\nsuper.setUp();\\n}\", null);\n        }\n      }\n    }\n\n    final PsiMethod[] psiMethods = clazz.getMethods();\n    PsiMethod inClass = null;\n    PsiMethod testMethod = null;\n    for (PsiMethod psiMethod : psiMethods) {\n      if (inClass == null && AnnotationUtil.isAnnotated(psiMethod, BeforeMethod.class.getName(), false)) {\n        inClass = psiMethod;\n      }\n      if (testMethod == null && AnnotationUtil.isAnnotated(psiMethod, Test.class.getName(), false) && !psiMethod.hasModifierProperty(PsiModifier.PRIVATE)) {\n        testMethod = psiMethod;\n      }\n    }\n    if (inClass == null) {\n      final PsiMethod psiMethod;\n      if (testMethod != null) {\n        psiMethod = (PsiMethod)clazz.addBefore(patternMethod, testMethod);\n      } else {\n        psiMethod = (PsiMethod)clazz.add(patternMethod);\n      }\n      JavaCodeStyleManager.getInstance(clazz.getProject()).shortenClassReferences(clazz);\n      return psiMethod;\n    }\n    else if (inClass.getBody() == null) {\n      return (PsiMethod)inClass.replace(patternMethod);\n    }\n    return inClass;\n  }","commit_id":"cd5b299bf4e0d344a9dc1b8acd5eace1f0814c44","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isAnnotatedAsTestOnly(@Nullable PsiMethod m) {\n    if (m == null) return false;\n    return AnnotationUtil.isAnnotated(m, AnnotationUtil.TEST_ONLY, false);\n  }","id":78715,"modified_method":"private static boolean isAnnotatedAsTestOnly(@Nullable PsiMethod m) {\n    if (m == null) return false;\n    return AnnotationUtil.isAnnotated(m, AnnotationUtil.TEST_ONLY, false) ||\n           AnnotationUtil.isAnnotated(m, \"com.google.common.annotations.VisibleForTesting\", false);\n  }","commit_id":"b81a5ff17f46481deddc6dc3a026afc81f66a016","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void annotateOnOverrideImplement(PsiMethod method, PsiClass targetClass, PsiMethod overridden, boolean insertOverride) {\n    if (insertOverride && canInsertOverride(overridden, targetClass)) {\n      AddAnnotationPsiFix.addPhysicalAnnotation(Override.class.getName(), PsiNameValuePair.EMPTY_ARRAY, method.getModifierList());\n    }\n    final Module module = ModuleUtilCore.findModuleForPsiElement(targetClass);\n    final GlobalSearchScope moduleScope = module != null ? GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module) : null;\n    final Project project = targetClass.getProject();\n    final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n    for (OverrideImplementsAnnotationsHandler each : Extensions.getExtensions(OverrideImplementsAnnotationsHandler.EP_NAME)) {\n      for (String annotation : each.getAnnotations(project)) {\n        if (moduleScope != null && facade.findClass(annotation, moduleScope) == null) continue;\n        if (AnnotationUtil.isAnnotated(overridden, annotation, false, false)) {\n          AddAnnotationPsiFix.removePhysicalAnnotations(method, each.annotationsToRemove(project, annotation));\n          AddAnnotationPsiFix.addPhysicalAnnotation(annotation, PsiNameValuePair.EMPTY_ARRAY, method.getModifierList());\n        }\n      }\n    }\n  }","id":78716,"modified_method":"public static void annotateOnOverrideImplement(PsiMethod method, PsiClass targetClass, PsiMethod overridden, boolean insertOverride) {\n    if (insertOverride && canInsertOverride(overridden, targetClass)) {\n      AddAnnotationPsiFix.addPhysicalAnnotation(Override.class.getName(), PsiNameValuePair.EMPTY_ARRAY, method.getModifierList());\n    }\n    final Module module = ModuleUtilCore.findModuleForPsiElement(targetClass);\n    final GlobalSearchScope moduleScope = module != null ? GlobalSearchScope.moduleWithDependenciesAndLibrariesScope(module) : null;\n    final Project project = targetClass.getProject();\n    final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n    for (OverrideImplementsAnnotationsHandler each : Extensions.getExtensions(OverrideImplementsAnnotationsHandler.EP_NAME)) {\n      for (String annotation : each.getAnnotations(project)) {\n        if (moduleScope != null && facade.findClass(annotation, moduleScope) == null) continue;\n        if (AnnotationUtil.isAnnotated(overridden, annotation, false, false) && !AnnotationUtil.isAnnotated(method, annotation, false, false)) {\n          AddAnnotationPsiFix.removePhysicalAnnotations(method, each.annotationsToRemove(project, annotation));\n          AddAnnotationPsiFix.addPhysicalAnnotation(annotation, PsiNameValuePair.EMPTY_ARRAY, method.getModifierList());\n        }\n      }\n    }\n  }","commit_id":"22d5c2f4359a6384de645cb86ab2241754ba20b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void messageReceived(I2NPMessageReader reader, I2NPMessage message, long msToReceive) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Message received from \" + _remoteIdentity.getHash().toBase64());\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream(32*1024);\n            message.writeBytes(baos);\n            int size = baos.size();\n            // this is called by the I2NPMessageReader's thread, so it delays the reading from this peer only\n            //_log.debug(\"Delaying inbound for size \" + size);\n            //BandwidthLimiter.getInstance().delayInbound(_remoteIdentity, size);\n            _transport.messageReceived(message, _remoteIdentity, null, msToReceive, size);\n        } catch (DataFormatException dfe) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"How did we read a message that is poorly formatted...\", dfe);\n        } catch (IOException ioe) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"How did we read a message that can't be written to memory...\", ioe);\n        } \n\n        if (slicesTooLong()) {\n            if (_log.shouldLog(Log.ERROR)) {\n                long sliceTime = _context.clock().now()-_lastSliceRun;\n                _log.error(\"onReceive: Slices are taking too long (\" + sliceTime \n                           + \"ms) - perhaps the remote side is disconnected or hung?  peer = \" \n                           + _remoteIdentity.getHash().toBase64());\n            }\n            closeConnection();\n        }   \n    }","id":78717,"modified_method":"public void messageReceived(I2NPMessageReader reader, I2NPMessage message, long msToReceive) {\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Message received from \" + _remoteIdentity.getHash().toBase64());\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream(32*1024);\n            message.writeBytes(baos);\n            int size = baos.size();\n            // this is called by the I2NPMessageReader's thread, so it delays the reading from this peer only\n            //_log.debug(\"Delaying inbound for size \" + size);\n            //BandwidthLimiter.getInstance().delayInbound(_remoteIdentity, size);\n            _transport.messageReceived(message, _remoteIdentity, null, msToReceive, size);\n        } catch (DataFormatException dfe) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"How did we read a message that is poorly formatted...\", dfe);\n        } catch (IOException ioe) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"How did we read a message that can't be written to memory...\", ioe);\n        } \n    }","commit_id":"4c82970319d81822585b7a51b0a09a1141277647","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void addMessage(OutNetMessage msg) {\n        msg.timestamp(\"TCPConnection.addMessage\");\n        int totalPending = 0;\n        boolean fail = false;\n        long beforeAdd = _context.clock().now();\n        StringBuffer pending = new StringBuffer(64);\n        synchronized (_toBeSent) {\n            for (int i = 0; i < _toBeSent.size(); i++) {\n                OutNetMessage cur = (OutNetMessage)_toBeSent.get(i);\n                if (cur.getExpiration() < beforeAdd) {\n                    fail = true;\n                    break;\n                }\n            }\n            if (!fail) {\n                _toBeSent.add(msg);\n            }\n            totalPending = _toBeSent.size();\n            pending.append(totalPending).append(\": \");\n            if (fail) {\n                for (int i = 0; i < totalPending; i++) {\n                    OutNetMessage cur = (OutNetMessage)_toBeSent.get(i);\n                    pending.append(cur.getMessageSize()).append(\" byte \");\n                    pending.append(cur.getMessageType()).append(\" message added\");\n                    pending.append(\" added \").append(cur.getLifetime()).append(\" ms ago, \");\n                }\n            }\n            \n            // the ConnectionRunner.processSlice does a wait() until we have messages\n            _toBeSent.notifyAll();\n        }\n        long afterAdd = _context.clock().now();\n\n        _context.statManager().addRateData(\"tcp.queueSize\", totalPending-1, 0);\n\n        if (fail) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"messages expired on the queue to \" + _remoteIdentity.getHash().toBase64() + \": \" + pending.toString());\n\n            // do we really want to give them a comm error because they're so.damn.slow reading their stream?\n            _context.profileManager().commErrorOccurred(_remoteIdentity.getHash());\n            \n            msg.timestamp(\"TCPConnection.addMessage saw an expired queued message\");\n            _transport.afterSend(msg, false);\n            // should we really be closing a connection if they're that slow?  \n            // yeah, i think we should.\n            closeConnection();\n            return;\n        }\n\t\n        long diff = afterAdd - beforeAdd;\n        if (diff > 500) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Lock contention adding a message: \" + diff + \"ms to \" \n                          + _remoteIdentity.getHash().toBase64() + \": \" + totalPending);\n        }\n\n        msg.timestamp(\"TCPConnection.addMessage after toBeSent.add and notify\");\n\n        if (_log.shouldLog(Log.DEBUG))\n            _log.debug(\"Add message with toBeSent.size = \" + totalPending + \" to \" + _remoteIdentity.getHash().toBase64());\n        if (totalPending <= 0) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"WTF, total pending after adding \" + msg.getMessage().getClass().getName() + \" <= 0! \" + msg);\n        }\n\n        if (slicesTooLong()) {\n            msg.timestamp(\"TCPTransport.addMessage noticed slices were taking too long\");\n            \n            if (_log.shouldLog(Log.ERROR)) {\n                long sliceTime = _context.clock().now()-_lastSliceRun;\n                _log.error(\"onAdd: Slices are taking too long (\" + sliceTime \n                           + \"ms) - perhaps the remote side is disconnected or hung? remote=\" \n                           + _remoteIdentity.getHash().toBase64() + \" pending: \" + pending.toString());\n            }\n            closeConnection();\n        }\n    }","id":78718,"modified_method":"public void addMessage(OutNetMessage msg) {\n        msg.timestamp(\"TCPConnection.addMessage\");\n        int totalPending = 0;\n        boolean fail = false;\n        long beforeAdd = _context.clock().now();\n        StringBuffer pending = new StringBuffer(64);\n        List removed = null;\n        synchronized (_toBeSent) {\n            for (int i = 0; i < _toBeSent.size(); i++) {\n                OutNetMessage cur = (OutNetMessage)_toBeSent.get(i);\n                if (cur.getExpiration() < beforeAdd) {\n                    if (cur.getLifetime() > MIN_MESSAGE_LIFETIME_FOR_PENALTY) {\n                        fail = true;\n                        break;\n                    } else {\n                        // yeah, it expired, so drop it, but it wasn't our\n                        // fault (since it was almost expired when we got it\n                        if (removed == null)\n                            removed = new ArrayList(2);\n                        removed.add(cur);\n                        _toBeSent.remove(i);\n                        i--;\n                    }\n                }\n            }\n            if (!fail) {\n                _toBeSent.add(msg);\n            }\n            totalPending = _toBeSent.size();\n            pending.append(totalPending).append(\": \");\n            if (fail) {\n                for (int i = 0; i < totalPending; i++) {\n                    OutNetMessage cur = (OutNetMessage)_toBeSent.get(i);\n                    pending.append(cur.getMessageSize()).append(\" byte \");\n                    pending.append(cur.getMessageType()).append(\" message added\");\n                    pending.append(\" added \").append(cur.getLifetime()).append(\" ms ago, \");\n                }\n            }\n            \n            // the ConnectionRunner.getNext does a wait() until we have messages\n            _toBeSent.notifyAll();\n        }\n        long afterAdd = _context.clock().now();\n\n        _context.statManager().addRateData(\"tcp.queueSize\", totalPending-1, 0);\n\n        if (removed != null) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"messages expired on the queue to \" + _remoteIdentity.getHash().toBase64() \n                          + \" but they weren't that old: \" + removed.size());\n            for (int i = 0; i < removed.size(); i++) {\n                OutNetMessage cur = (OutNetMessage)removed.get(i);\n                msg.timestamp(\"TCPConnection.addMessage expired but not our fault\");\n                _transport.afterSend(cur, false);\n            }\n        }\n        \n        if (fail) {\n            if (_log.shouldLog(Log.ERROR))\n                _log.error(\"messages expired on the queue to \" + _remoteIdentity.getHash().toBase64() + \": \" + pending.toString());\n\n            // do we really want to give them a comm error because they're so.damn.slow reading their stream?\n            _context.profileManager().commErrorOccurred(_remoteIdentity.getHash());\n            \n            msg.timestamp(\"TCPConnection.addMessage saw an expired queued message\");\n            _transport.afterSend(msg, false);\n            // should we really be closing a connection if they're that slow?  \n            // yeah, i think we should.\n            closeConnection();\n        } else {\n\n            long diff = afterAdd - beforeAdd;\n            if (diff > 500) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Lock contention adding a message: \" + diff + \"ms to \" \n                              + _remoteIdentity.getHash().toBase64() + \": \" + totalPending);\n            }\n\n            msg.timestamp(\"TCPConnection.addMessage after toBeSent.add and notify\");\n\n            if (_log.shouldLog(Log.DEBUG))\n                _log.debug(\"Add message with toBeSent.size = \" + totalPending + \" to \" + _remoteIdentity.getHash().toBase64());\n            if (totalPending <= 0) {\n                if (_log.shouldLog(Log.ERROR))\n                    _log.error(\"WTF, total pending after adding \" + msg.getMessage().getClass().getName() + \" <= 0! \" + msg);\n            }\n        }\n    }","commit_id":"4c82970319d81822585b7a51b0a09a1141277647","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public TCPConnection(RouterContext context, Socket s, boolean locallyInitiated) {\n        _context = context;\n        _log = context.logManager().getLog(TCPConnection.class);\n        _context.statManager().createRateStat(\"tcp.queueSize\", \"How many messages were already in the queue when a new message was added?\", \n                                              \"TCP Transport\", new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _id = ++_idCounter;\n        _weInitiated = locallyInitiated;\n        _closed = false;\n        _socket = s;\n        _created = -1;\n        _toBeSent = new ArrayList();\n        try {\n            _in = _socket.getInputStream();\n            _out = _socket.getOutputStream();\n        } catch (IOException ioe) {\n            _log.error(\"Error getting streams for the connection\", ioe);\n        }\n        _builder = new DHSessionKeyBuilder();\n        _extraBytes = null;\n        _lastSliceRun = -1;\n\n        // sun keeps the socket's InetAddress around after its been closed, but kaffe (and the rest of classpath)\n        // doesn't, so we've got to check & cache it here if we want to log it later.  (kaffe et al are acting per\n        // spec, btw)\n        _remoteHost = s.getInetAddress() + \"\";\n        _remotePort = s.getPort();\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Connected with peer: \" + _remoteHost + \":\" + _remotePort);\n    }","id":78719,"modified_method":"public TCPConnection(RouterContext context, Socket s, boolean locallyInitiated) throws IOException {\n        _context = context;\n        _log = context.logManager().getLog(TCPConnection.class);\n        _context.statManager().createRateStat(\"tcp.queueSize\", \"How many messages were already in the queue when a new message was added?\", \n                                              \"TCP Transport\", new long[] { 60*1000l, 60*60*1000l, 24*60*60*1000l });\n        _id = ++_idCounter;\n        _weInitiated = locallyInitiated;\n        _closed = false;\n        _socket = s;\n        _created = -1;\n        _toBeSent = new ArrayList();\n        try {\n            _in = _socket.getInputStream();\n            _out = _socket.getOutputStream();\n        } catch (IOException ioe) {\n            _log.error(\"Error getting streams for the connection\", ioe);\n        }\n        _builder = new DHSessionKeyBuilder();\n        _extraBytes = null;\n\n        // sun keeps the socket's InetAddress around after its been closed, but kaffe (and the rest of classpath)\n        // doesn't, so we've got to check & cache it here if we want to log it later.  (kaffe et al are acting per\n        // spec, btw)\n        try {\n            _remoteHost = s.getInetAddress() + \"\";\n            _remotePort = s.getPort();\n        } catch (NullPointerException npe) {\n            throw new IOException(\"kaffe is being picky since the socket closed too fast...\");\n        }\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Connected with peer: \" + _remoteHost + \":\" + _remotePort);\n    }","commit_id":"4c82970319d81822585b7a51b0a09a1141277647","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public void run() {\n            _running = true;\n            while (_running) {\n                long startSlice = _context.clock().now();\n                _lastSliceRun = startSlice;\n                boolean processOk = processSlice();\n                if (!processOk) {\n                    closeConnection();\n                    return;\n                }\n                long endSlice = _context.clock().now();\n            }\n        }","id":78720,"modified_method":"public void run() {\n            _running = true;\n            while (_running) {\n                OutNetMessage nextMessage = getNext();\n                if (nextMessage != null) {\n                    boolean sent = doSend(nextMessage);\n                    if (!sent) {\n                        _running = false;\n                    }\n                }\n            }\n            \n            closeConnection();\n        }","commit_id":"4c82970319d81822585b7a51b0a09a1141277647","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Create a new connection based on the SYN packet we received.\n     *\n     * @param synPacket SYN packet to process\n     * @return created Connection with the packet's data already delivered to\n     *         it, or null if the syn's streamId was already taken\n     */\n    public Connection receiveConnection(Packet synPacket) {\n        Connection con = new Connection(_context, this, _schedulerChooser, _outboundQueue, _conPacketHandler, new ConnectionOptions(_defaultOptions));\n        _tcbShare.updateOptsFromShare(con);\n        con.setInbound();\n        long receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n        boolean reject = false;\n        int active = 0;\n        int total = 0;\n\n            // just for the stat\n            //total = _connectionByInboundId.size();\n            //for (Iterator iter = _connectionByInboundId.values().iterator(); iter.hasNext(); ) {\n            //    if ( ((Connection)iter.next()).getIsConnected() )\n            //        active++;\n            //}\n            if (locked_tooManyStreams()) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Refusing connection since we have exceeded our max of \" \n                              + _maxConcurrentStreams + \" connections\");\n                reject = true;\n            } else if (shouldRejectConnection(synPacket)) {\n                // this may not be right if more than one is enabled\n                String why;\n                if (_defaultOptions.isAccessListEnabled())\n                    why = \"not whitelisted: \";\n                else if (_defaultOptions.isBlacklistEnabled())\n                    why = \"blacklisted: \";\n                else\n                    why = \"throttled: \";\n                _log.error(\"Refusing connection since peer is \" + why +\n                           (synPacket.getOptionalFrom() == null ? \"null from\" : synPacket.getOptionalFrom().calculateHash().toBase64()));\n                reject = true;\n            } else { \n                while (true) {\n                    Connection oldCon = _connectionByInboundId.putIfAbsent(Long.valueOf(receiveId), con);\n                    if (oldCon == null) {\n                        break;\n                    } else { \n                        // receiveId already taken, try another\n                        receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n                    }\n                }\n            }\n        \n        _context.statManager().addRateData(\"stream.receiveActive\", active, total);\n        \n        if (reject) {\n            PacketLocal reply = new PacketLocal(_context, synPacket.getOptionalFrom());\n            reply.setFlag(Packet.FLAG_RESET);\n            reply.setFlag(Packet.FLAG_SIGNATURE_INCLUDED);\n            reply.setAckThrough(synPacket.getSequenceNum());\n            reply.setSendStreamId(synPacket.getReceiveStreamId());\n            reply.setReceiveStreamId(0);\n            reply.setOptionalFrom(_session.getMyDestination());\n            // this just sends the packet - no retries or whatnot\n            _outboundQueue.enqueue(reply);\n            return null;\n        }\n        \n        con.setReceiveStreamId(receiveId);\n        try {\n            // This validates the packet, and sets the con's SendStreamID and RemotePeer\n            con.getPacketHandler().receivePacket(synPacket, con);\n        } catch (I2PException ie) {\n            _connectionByInboundId.remove(Long.valueOf(receiveId));\n            return null;\n        }\n        \n        _context.statManager().addRateData(\"stream.connectionReceived\", 1, 0);\n        return con;\n    }","id":78721,"modified_method":"/**\n     * Create a new connection based on the SYN packet we received.\n     *\n     * @param synPacket SYN packet to process\n     * @return created Connection with the packet's data already delivered to\n     *         it, or null if the syn's streamId was already taken\n     */\n    public Connection receiveConnection(Packet synPacket) {\n        Connection con = new Connection(_context, this, _schedulerChooser, _outboundQueue, _conPacketHandler, new ConnectionOptions(_defaultOptions));\n        _tcbShare.updateOptsFromShare(con);\n        con.setInbound();\n        long receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n        boolean reject = false;\n        int active = 0;\n        int total = 0;\n\n            // just for the stat\n            //total = _connectionByInboundId.size();\n            //for (Iterator iter = _connectionByInboundId.values().iterator(); iter.hasNext(); ) {\n            //    if ( ((Connection)iter.next()).getIsConnected() )\n            //        active++;\n            //}\n            if (locked_tooManyStreams()) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"Refusing connection since we have exceeded our max of \" \n                              + _maxConcurrentStreams + \" connections\");\n                reject = true;\n            } else {\n                // this may not be right if more than one is enabled\n                String why = shouldRejectConnection(synPacket);\n                if (why != null) {\n                    _log.logAlways(Log.WARN, \"Refusing connection since peer is \" + why +\n                           (synPacket.getOptionalFrom() == null ? \"\" : \": \" + synPacket.getOptionalFrom().calculateHash().toBase64()));\n                    reject = true;\n                } else { \n                    while (true) {\n                        Connection oldCon = _connectionByInboundId.putIfAbsent(Long.valueOf(receiveId), con);\n                        if (oldCon == null) {\n                            break;\n                        } else { \n                            // receiveId already taken, try another\n                            receiveId = _context.random().nextLong(Packet.MAX_STREAM_ID-1)+1;\n                        }\n                    }\n                }\n            }\n        \n        _context.statManager().addRateData(\"stream.receiveActive\", active, total);\n        \n        if (reject) {\n            PacketLocal reply = new PacketLocal(_context, synPacket.getOptionalFrom());\n            reply.setFlag(Packet.FLAG_RESET);\n            reply.setFlag(Packet.FLAG_SIGNATURE_INCLUDED);\n            reply.setAckThrough(synPacket.getSequenceNum());\n            reply.setSendStreamId(synPacket.getReceiveStreamId());\n            reply.setReceiveStreamId(0);\n            reply.setOptionalFrom(_session.getMyDestination());\n            // this just sends the packet - no retries or whatnot\n            _outboundQueue.enqueue(reply);\n            return null;\n        }\n        \n        con.setReceiveStreamId(receiveId);\n        try {\n            // This validates the packet, and sets the con's SendStreamID and RemotePeer\n            con.getPacketHandler().receivePacket(synPacket, con);\n        } catch (I2PException ie) {\n            _connectionByInboundId.remove(Long.valueOf(receiveId));\n            return null;\n        }\n        \n        _context.statManager().addRateData(\"stream.connectionReceived\", 1, 0);\n        return con;\n    }","commit_id":"3f8df84a4a308144c739504d892e46fe0bbc49e5","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private boolean shouldRejectConnection(Packet syn) {\n        // unfortunately we don't have access to the router client manager here,\n        // so we can't whitelist local access\n        Destination from = syn.getOptionalFrom();\n        if (from == null)\n            return true;\n        Hash h = from.calculateHash();\n        boolean throttled = false;\n        // always call all 3 to increment all counters\n        if (_minuteThrottler != null && _minuteThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledMinute\", 1, 0);\n            throttled = true;\n        }\n        if (_hourThrottler != null && _hourThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledHour\", 1, 0);\n            throttled = true;\n        }\n        if (_dayThrottler != null && _dayThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledDay\", 1, 0);\n            throttled = true;\n        }\n        if (throttled)\n            return true;\n        // if the sig is absent or bad it will be caught later (in CPH)\n        if (_defaultOptions.isAccessListEnabled())\n            return !_defaultOptions.getAccessList().contains(h);\n        if (_defaultOptions.isBlacklistEnabled())\n            return _defaultOptions.getBlacklist().contains(h);\n        return false;\n    }","id":78722,"modified_method":"/**\n     *  @return reason string or null if not rejected\n     */\n    private String shouldRejectConnection(Packet syn) {\n        // unfortunately we don't have access to the router client manager here,\n        // so we can't whitelist local access\n        Destination from = syn.getOptionalFrom();\n        if (from == null)\n            return \"null\";\n        Hash h = from.calculateHash();\n        String throttled = null;\n        // always call all 3 to increment all counters\n        if (_minuteThrottler != null && _minuteThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledMinute\", 1, 0);\n            throttled = \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerMinute() +\n                        \" or total limit of \" + _defaultOptions.getMaxTotalConnsPerMinute() +\n                        \" per minute\";\n        }\n        if (_hourThrottler != null && _hourThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledHour\", 1, 0);\n            throttled = \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerHour() +\n                        \" or total limit of \" + _defaultOptions.getMaxTotalConnsPerHour() +\n                        \" per hour\";\n        }\n        if (_dayThrottler != null && _dayThrottler.shouldThrottle(h)) {\n            _context.statManager().addRateData(\"stream.con.throttledDay\", 1, 0);\n            throttled = \"throttled by per-peer limit of \" + _defaultOptions.getMaxConnsPerDay() +\n                        \" or total limit of \" + _defaultOptions.getMaxTotalConnsPerDay() +\n                        \" per day\";\n        }\n        if (throttled != null)\n            return throttled;\n        // if the sig is absent or bad it will be caught later (in CPH)\n        if (_defaultOptions.isAccessListEnabled() &&\n            !_defaultOptions.getAccessList().contains(h))\n            return \"not whitelisted\";\n        if (_defaultOptions.isBlacklistEnabled() &&\n            _defaultOptions.getBlacklist().contains(h))\n            return \"blacklisted\";\n        return null;\n    }","commit_id":"3f8df84a4a308144c739504d892e46fe0bbc49e5","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"public String toString() {\n        StringBuffer s = new StringBuffer(128);\n        s.append(\"Dest: \");\n        s.append(this.dest.toBase64());\n        s.append(\"\\nContains: \");\n        s.append(this.dest);\n        s.append(\"\\nPrivate Key: \");\n        s.append(this.privKey);\n        s.append(\"\\nSigining Private Key: \");\n        s.append(this.signingPrivKey);\n        s.append(\"\\n\");\n        return s.toString();\n    }","id":78723,"modified_method":"public String toString() {\n        StringBuffer s = new StringBuffer(128);\n        s.append(\"Dest: \");\n        s.append(this.dest != null ? this.dest.toBase64() : \"null\");\n        s.append(\"\\nContains: \");\n        s.append(this.dest);\n        s.append(\"\\nPrivate Key: \");\n        s.append(this.privKey);\n        s.append(\"\\nSigining Private Key: \");\n        s.append(this.signingPrivKey);\n        s.append(\"\\n\");\n        return s.toString();\n    }","commit_id":"fbe7e42f46b08fc1d4d8cf15676d0779c986e5d3","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n   * @param module Module to get content root\n   * @return VirtualFile corresponding to content root\n   */\n  @NotNull\n  public static String[] getModuleRootUrls(@NotNull final Module module) {\n    VirtualFile[] roots = ModuleRootManager.getInstance(module).getSourceRoots();\n    if (roots.length == 0) {\n      roots = new VirtualFile[]{(module.getModuleFile().getParent())};\n    }\n    String[] urls = new String[roots.length];\n    int i = 0;\n    for (VirtualFile root : roots) {\n      urls[i++] = root.getUrl();\n    }\n    return urls;\n  }","id":78724,"modified_method":"/**\n   * @param module Module to get content root\n   * @return VirtualFile corresponding to content root\n   */\n  @NotNull\n  public static String[] getModuleRootUrls(@NotNull final Module module) {\n    VirtualFile[] roots = ModuleRootManager.getInstance(module).getSourceRoots();\n    if (roots.length == 0) {\n      VirtualFile moduleFile = module.getModuleFile();\n      if (moduleFile != null) {\n        roots = new VirtualFile[]{(moduleFile.getParent())};\n      }\n    }\n    String[] urls = new String[roots.length];\n    int i = 0;\n    for (VirtualFile root : roots) {\n      urls[i++] = root.getUrl();\n    }\n    return urls;\n  }","commit_id":"b1a36faa7bbd45c338e9cf4db609a8a3c420b9c6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void initFacet() {\n        StartupManager.getInstance(getModule().getProject()).runWhenProjectIsInitialized(new Runnable() {\n            @Override\n            public void run() {\n                ModelAccess.instance().runWriteAction(new Runnable() {\n                    @Override\n                    public void run() {\n                        IFile imlFile = FileSystem.getInstance().getFileByPath(getModule().getModuleFilePath());\n                        SolutionDescriptor dsd = new SolutionDescriptor();\n                        dsd.setUUID(UUID.randomUUID().toString());\n                        dsd.setNamespace(getModule().getName());\n                        dsd.getUsedLanguages().add(BootstrapLanguages.BASE_LANGUAGE);\n\n                        // model root\n                        IFile models = imlFile.getParent().getDescendant(\"models\");\n                        ModelRoot modelRoot = new ModelRoot();\n                        modelRoot.setPath(models.getPath());\n                        dsd.getModelRoots().add(modelRoot);\n\n                        Project project = ProjectHelper.toMPSProject(getModule().getProject());\n                        mySolution = Solution.newInstance(new ModulesMiner.ModuleHandle(imlFile, dsd), project);\n\n                        MessagesViewTool.log(getModule().getProject(), MessageKind.INFORMATION, \"module loaded: \" + mySolution.getModuleFqName());\n                    }\n                });\n\n            }\n        });\n    }","id":78725,"modified_method":"@Override\n    public void initFacet() {\n        StartupManager.getInstance(getModule().getProject()).runWhenProjectIsInitialized(new Runnable() {\n            @Override\n            public void run() {\n                ModelAccess.instance().runWriteAction(new Runnable() {\n                    @Override\n                    public void run() {\n                        SolutionDescriptor solutionDescriptor = getConfiguration().getState().myDescriptor;\n\n                        IFile imlFile = FileSystem.getInstance().getFileByPath(getModule().getModuleFilePath());\n                        IFile models = imlFile.getParent().getDescendant(\"models\");\n\n                        Project project = ProjectHelper.toMPSProject(getModule().getProject());\n                        mySolution = Solution.newInstance(new ModulesMiner.ModuleHandle(imlFile, solutionDescriptor), project);\n\n                        MessagesViewTool.log(getModule().getProject(), MessageKind.INFORMATION, \"module loaded: \" + mySolution.getModuleFqName());\n                    }\n                });\n\n            }\n        });\n    }","commit_id":"0d99d6877bccef4ff1efd52516a70274e4064e8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void setConfigurationDefaults() {\n        if (configurationBean.getGeneratorOutputPath() == null) {\n            configurationBean.setGeneratorOutputPath(myMpsFacet.getModule().getModuleFile().getParent().getPath() + File.separator + SOURCE_GEN);\n            configurationBean.setUseModuleSourceFolder(false);\n        }\n    }","id":78726,"modified_method":"private void setConfigurationDefaults() {\n        if (configurationBean.getGeneratorOutputPath() == null) {\n            VirtualFile moduleFile = myMpsFacet.getModule().getModuleFile();\n            if (moduleFile != null) {\n                VirtualFile moduleFolder = moduleFile.getParent();\n                if (moduleFolder != null) {\n                    configurationBean.setGeneratorOutputPath(moduleFolder.getPath() + File.separator + SOURCE_GEN);\n                    configurationBean.setUseModuleSourceFolder(false);\n                }\n            }\n        }\n        if (configurationBean.getNamespace() == null || configurationBean.getNamespace().isEmpty()) {\n            configurationBean.setNamespace(myMpsFacet.getModule().getName());\n        }\n    }","commit_id":"0d99d6877bccef4ff1efd52516a70274e4064e8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void getData(MPSConfigurationBean data) {\n        //To change body of created methods use File | Settings | File Templates.\n    }","id":78727,"modified_method":"public void getData(MPSConfigurationBean data) {\n        data.setModelRootPaths(getModelRootPaths());\n    }","commit_id":"0d99d6877bccef4ff1efd52516a70274e4064e8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addModelRoots(VirtualFile[] files) {\n        ContentEntryEditor lastEditor = null;\n        for (VirtualFile file : files) {\n            ContentEntryEditor contentEntryEditor = new ModelSourceContentEntryEditor(file.getUrl(), myParentDisposable);\n            contentEntryEditor.initUI();\n//            contentEntryEditor.addContentEntryEditorListener(myContentEntryEditorListener);\n//            registerDisposable(new Disposable() {\n//              public void dispose() {\n//                contentEntryEditor.removeContentEntryEditorListener(myContentEntryEditorListener);\n//              }\n//            });\n//            myEntryToEditorMap.put(contentEntry, contentEntryEditor);\n            Border border = BorderFactory.createEmptyBorder(2, 2, 0, 2);\n            final JComponent component = contentEntryEditor.getComponent();\n            final Border componentBorder = component.getBorder();\n            if (componentBorder != null) {\n                border = BorderFactory.createCompoundBorder(border, componentBorder);\n            }\n            component.setBorder(border);\n            myModelRootsPanel.add(component);\n            lastEditor = contentEntryEditor;\n        }\n        if (lastEditor != null) {\n            lastEditor.setSelected(true);\n        }\n        myModelRootsPanel.revalidate();\n        myModelRootsPanel.repaint();\n    }","id":78728,"modified_method":"private void addModelRoots(VirtualFile[] files) {\n        ContentEntryEditor lastEditor = null;\n        for (VirtualFile file : files) {\n            lastEditor = addModelRoot(file.getUrl());\n        }\n        selectModelRoot(lastEditor);\n        myModelRootsPanel.revalidate();\n        myModelRootsPanel.repaint();\n    }","commit_id":"0d99d6877bccef4ff1efd52516a70274e4064e8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public AddModelRootAction() {\n            super(MPSBundle.message(\"facet.sources.tab.add.model.root.action\"), MPSBundle.message(\"facet.sources.tab.add.model.root.description\"), MPSIcons.ADD_MODEL_ROOT_ICON);\n            myDescriptor = new FileChooserDescriptor(false, true, true, false, true, true) {\n                public void validateSelectedFiles(VirtualFile[] files) throws Exception {\n                    validateContentEntriesCandidates(files);\n                }\n            };\n            myDescriptor.putUserData(LangDataKeys.MODULE_CONTEXT, myContext.getModule());\n            myDescriptor.setTitle(MPSBundle.message(\"facet.sources.tab.add.model.root.directory.title\"));\n            myDescriptor.setDescription(MPSBundle.message(\"facet.sources.tab.add.model.root.directory.description\"));\n            myDescriptor.putUserData(FileChooserKeys.DELETE_ACTION_AVAILABLE, false);\n        }","id":78729,"modified_method":"public AddModelRootAction() {\n            super(MPSBundle.message(\"facet.sources.tab.add.model.root.action\"), MPSBundle.message(\"facet.sources.tab.add.model.root.description\"), MPSIcons.ADD_MODEL_ROOT_ICON);\n            myDescriptor = new FileChooserDescriptor(false, true, false, false, false, true) {\n                public void validateSelectedFiles(VirtualFile[] files) throws Exception {\n                    validateContentEntriesCandidates(files);\n                }\n            };\n            myDescriptor.putUserData(LangDataKeys.MODULE_CONTEXT, myContext.getModule());\n            myDescriptor.setTitle(MPSBundle.message(\"facet.sources.tab.add.model.root.directory.title\"));\n            myDescriptor.setDescription(MPSBundle.message(\"facet.sources.tab.add.model.root.directory.description\"));\n            myDescriptor.putUserData(FileChooserKeys.DELETE_ACTION_AVAILABLE, false);\n            VirtualFile moduleFile = myContext.getModule().getModuleFile();\n            if (moduleFile != null) {\n                myLastSelectedDir = moduleFile.getParent();\n            }\n        }","commit_id":"0d99d6877bccef4ff1efd52516a70274e4064e8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void setData(MPSConfigurationBean data) {\n        //To change body of created methods use File | Settings | File Templates.\n    }","id":78730,"modified_method":"public void setData(MPSConfigurationBean data) {\n        for (String modelRootPath : data.getModelRootPaths()) {\n            addModelRoot(VirtualFileManager.constructUrl(LocalFileSystem.PROTOCOL, modelRootPath));\n        }\n    }","commit_id":"0d99d6877bccef4ff1efd52516a70274e4064e8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void createUIComponents() {\n        myRootPanel = new JPanel();\n        myRootPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4), IdeBorderFactory.createTitledBorder(MPSBundle.message(\"facet.sources.tab.model.roots.title\"))));\n\n        DefaultActionGroup group = new DefaultActionGroup();\n        AddModelRootAction action = new AddModelRootAction();\n        action.registerCustomShortcutSet(KeyEvent.VK_M, KeyEvent.ALT_DOWN_MASK, myRootPanel);\n        group.add(action);\n\n        myModelRootsPanel = new ScrollablePanel(new VerticalStackLayout());\n        myModelRootsPanel.setBackground(BACKGROUND_COLOR);\n        JScrollPane myScrollPane = ScrollPaneFactory.createScrollPane(myModelRootsPanel);\n        myToolbarPanel = new ToolbarPanel(myScrollPane, group);\n        myToolbarPanel.setBorder(null);\n    }","id":78731,"modified_method":"private void createUIComponents() {\n        myRootPanel = new JPanel();\n        myRootPanel.setBorder(BorderFactory.createCompoundBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4), IdeBorderFactory.createTitledBorder(MPSBundle.message(\"facet.sources.tab.model.roots.title\"))));\n\n        DefaultActionGroup group = new DefaultActionGroup();\n        AddModelRootAction action = new AddModelRootAction();\n        action.registerCustomShortcutSet(KeyEvent.VK_M, KeyEvent.ALT_DOWN_MASK, myRootPanel);\n        group.add(action);\n\n        myModelRootsPanel = new ScrollablePanel(new VerticalStackLayout());\n        myModelRootsPanel.setBackground(BACKGROUND_COLOR);\n        JScrollPane myScrollPane = ScrollPaneFactory.createScrollPane(myModelRootsPanel);\n        myToolbarPanel = new ToolbarPanel(myScrollPane, group);\n        myToolbarPanel.setBorder(null);\n\n        myModelRootEditors = new ArrayList<ModelRootContentEntryEditor>();\n        myModelRootEditorListener = new ModelRootContentEntryEditorListener();\n    }","commit_id":"0d99d6877bccef4ff1efd52516a70274e4064e8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isModified(MPSConfigurationBean data) {\n        return false;  //To change body of created methods use File | Settings | File Templates.\n    }","id":78732,"modified_method":"public boolean isModified(MPSConfigurationBean data) {\n        return !Arrays.equals(getModelRootPaths(), data.getModelRootPaths());\n    }","commit_id":"0d99d6877bccef4ff1efd52516a70274e4064e8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void validateContentEntriesCandidates(VirtualFile[] files) {\n        }","id":78733,"modified_method":"private void validateContentEntriesCandidates(VirtualFile[] files) throws Exception {\n            for (VirtualFile file : files) {\n                String protocol = VirtualFileManager.extractProtocol(file.getUrl());\n                if (!LocalFileSystem.PROTOCOL.equals(protocol)) {\n                    throw new Exception(MPSBundle.message(\"facet.sources.tab.add.unsupported.vfs.protocol\", file.getPresentableUrl(), protocol));\n                }\n                for (ModelRootContentEntryEditor modelRootEditor : myModelRootEditors) {\n                    ContentEntry contentEntry = modelRootEditor.getContentEntry();\n                    if (contentEntry == null) {\n                        continue;\n                    }\n                    VirtualFile modelRootFile = contentEntry.getFile();\n                    if (modelRootFile == null) {\n                        continue;\n                    }\n                    if (modelRootFile.equals(file)) {\n                        throw new Exception(MPSBundle.message(\"facet.sources.tab.add.already.exists.root\", file.getPresentableUrl()));\n                    }\n                    if (VfsUtil.isAncestor(modelRootFile, file, true)) {\n                        // intersection not allowed\n                        throw new Exception(\n                                MPSBundle.message(\"facet.sources.tab.add.content.intersect.error\", file.getPresentableUrl(),\n                                        modelRootFile.getPresentableUrl()));\n                    }\n                    if (VfsUtil.isAncestor(file, modelRootFile, true)) {\n                        // intersection not allowed\n                        throw new Exception(\n                                MPSBundle.message(\"facet.sources.tab.add.content.dominate.error\", file.getPresentableUrl(),\n                                        modelRootFile.getPresentableUrl()));\n                    }\n                }\n            }\n// TODO: check similar conditions for other mudule's MPS facets\n//            ModulesProvider modulesProvider = myContext.getModulesProvider();\n//            Module[] modules = modulesProvider.getModules();\n//            for (Module module : modules) {\n//                if (module == myContext.getModule()) {\n//                    continue;\n//                }\n//                FacetModel facetModel = modulesProvider.getFacetModel(module);\n//                MPSFacet mpsFacet = facetModel.getFacetByType(MPSFacetType.ID);\n//                if (mpsFacet == null) {\n//                    continue;\n//                }\n//                mpsFacet.getConfiguration().getState().\n//            }\n        }","commit_id":"0d99d6877bccef4ff1efd52516a70274e4064e8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initUI(ExecutionResult executionResult) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      return;\n    }\n\n\n    myUi.removeContent(myUi.findContent(DebuggerContentInfo.CONSOLE_CONTENT), true);\n\n    Content console = null;\n    if (myConsole instanceof ExecutionConsoleEx) {\n      ((ExecutionConsoleEx)myConsole).buildUi(myUi);\n      console = myUi.findContent(DebuggerContentInfo.CONSOLE_CONTENT);\n      if (console == null) {\n        LOG.debug(\"Reuse console created with non-debug runner\");\n      }\n    }\n    if (console == null) {\n      console = myUi.createContent(DebuggerContentInfo.CONSOLE_CONTENT, myConsole.getComponent(),\n                                           XDebuggerBundle.message(\"debugger.session.tab.console.content.name\"),\n                                           AllIcons.Debugger.Console, myConsole.getPreferredFocusableComponent());\n\n      console.setCloseable(false);\n      myUi.addContent(console, 1, PlaceInGrid.bottom, false);\n    }\n    attachNotificationTo(console);\n\n    if (myConsole != null) {\n      Disposer.register(this, myConsole);\n    }\n\n    final DefaultActionGroup consoleActions = new DefaultActionGroup();\n    if (myConsole instanceof ConsoleView) {\n      AnAction[] actions = ((ConsoleView)myConsole).createConsoleActions();\n      for (AnAction goAction : actions) {\n        consoleActions.add(goAction);\n      }\n    }\n    console.setActions(consoleActions, ActionPlaces.DEBUGGER_TOOLBAR, myConsole.getPreferredFocusableComponent());\n\n//    myDebugUIEnvironment.initLogs(myRunContentDescriptor, myManager);\n\n    DefaultActionGroup leftToolbar = new DefaultActionGroup();\n\n    if (executionResult instanceof DefaultExecutionResult) {\n      final AnAction[] actions = ((DefaultExecutionResult)executionResult).getRestartActions();\n        leftToolbar.addAll(actions);\n        if (actions.length > 0) {\n          leftToolbar.addSeparator();\n        }\n    }\n    final AnAction[] profileActions = executionResult.getActions();\n    leftToolbar.addAll(profileActions);\n\n    leftToolbar.add(getCustomizedActionGroup(XDebuggerActions.TOOL_WINDOW_LEFT_TOOLBAR_GROUP));\n    if (executionResult instanceof DefaultExecutionResult) {\n      AnAction[] actions = ((DefaultExecutionResult)executionResult).getAdditionalStopActions();\n      for (AnAction action : actions) {\n        leftToolbar.add(action, new Constraints(Anchor.AFTER, IdeActions.ACTION_STOP_PROGRAM));\n      }\n    }\n\n    leftToolbar.addSeparator();\n    addAction(leftToolbar, DebuggerActions.EXPORT_THREADS);\n    addAction(leftToolbar, DebuggerActions.DUMP_THREADS);\n    leftToolbar.addSeparator();\n\n    leftToolbar.add(myUi.getOptions().getLayoutActions());\n\n    final AnAction[] commonSettings = myUi.getOptions().getSettingsActionsList();\n    final AnAction commonSettingsList = myUi.getOptions().getSettingsActions();\n\n    final DefaultActionGroup settings = new DefaultActionGroup(\"DebuggerSettings\", true) {\n      @Override\n      public void update(AnActionEvent e) {\n        e.getPresentation().setText(ActionsBundle.message(\"group.XDebugger.settings.text\"));\n        e.getPresentation().setIcon(commonSettingsList.getTemplatePresentation().getIcon());\n      }\n\n      @Override\n      public boolean isDumbAware() {\n        return true;\n      }\n    };\n    for (AnAction each : commonSettings) {\n      settings.add(each);\n    }\n    if (commonSettings.length > 0) {\n      settings.addSeparator();\n    }\n    settings.add(new WatchLastMethodReturnValueAction());\n    settings.add(new AutoVarsSwitchAction());\n    settings.addSeparator();\n    addActionToGroup(settings, XDebuggerActions.INLINE_DEBUGGER);\n    addActionToGroup(settings, XDebuggerActions.AUTO_TOOLTIP);\n    addActionToGroup(settings, XDebuggerActions.AUTO_TOOLTIP_ON_SELECTION);\n\n    leftToolbar.add(settings);\n\n    leftToolbar.addSeparator();\n\n    addActionToGroup(leftToolbar, PinToolwindowTabAction.ACTION_NAME);\n\n    myDebugUIEnvironment.initActions(myRunContentDescriptor, leftToolbar);\n\n    myUi.getOptions().setLeftToolbar(leftToolbar, ActionPlaces.DEBUGGER_TOOLBAR);\n  }","id":78734,"modified_method":"private void initUI(ExecutionResult executionResult) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      return;\n    }\n\n\n    myUi.removeContent(myUi.findContent(DebuggerContentInfo.CONSOLE_CONTENT), true);\n\n    Content console = null;\n    if (myConsole instanceof ExecutionConsoleEx) {\n      ((ExecutionConsoleEx)myConsole).buildUi(myUi);\n      console = myUi.findContent(DebuggerContentInfo.CONSOLE_CONTENT);\n      if (console == null) {\n        LOG.debug(\"Reuse console created with non-debug runner\");\n      }\n    }\n    if (console == null) {\n      console = myUi.createContent(DebuggerContentInfo.CONSOLE_CONTENT, myConsole.getComponent(),\n                                           XDebuggerBundle.message(\"debugger.session.tab.console.content.name\"),\n                                           AllIcons.Debugger.Console, myConsole.getPreferredFocusableComponent());\n\n      console.setCloseable(false);\n      myUi.addContent(console, 1, PlaceInGrid.bottom, false);\n    }\n    attachNotificationTo(console);\n\n    if (myConsole != null) {\n      Disposer.register(this, myConsole);\n    }\n\n    final DefaultActionGroup consoleActions = new DefaultActionGroup();\n    if (myConsole instanceof ConsoleView) {\n      AnAction[] actions = ((ConsoleView)myConsole).createConsoleActions();\n      for (AnAction goAction : actions) {\n        consoleActions.add(goAction);\n      }\n    }\n    console.setActions(consoleActions, ActionPlaces.DEBUGGER_TOOLBAR, myConsole.getPreferredFocusableComponent());\n\n//    myDebugUIEnvironment.initLogs(myRunContentDescriptor, myManager);\n\n    DefaultActionGroup leftToolbar = new DefaultActionGroup();\n\n    if (executionResult instanceof DefaultExecutionResult) {\n      final AnAction[] actions = ((DefaultExecutionResult)executionResult).getRestartActions();\n        leftToolbar.addAll(actions);\n        if (actions.length > 0) {\n          leftToolbar.addSeparator();\n        }\n    }\n    final AnAction[] profileActions = executionResult.getActions();\n    leftToolbar.addAll(profileActions);\n\n    leftToolbar.add(getCustomizedActionGroup(XDebuggerActions.TOOL_WINDOW_LEFT_TOOLBAR_GROUP));\n    if (executionResult instanceof DefaultExecutionResult) {\n      AnAction[] actions = ((DefaultExecutionResult)executionResult).getAdditionalStopActions();\n      for (AnAction action : actions) {\n        leftToolbar.add(action, new Constraints(Anchor.AFTER, IdeActions.ACTION_STOP_PROGRAM));\n      }\n    }\n\n    leftToolbar.addSeparator();\n    //addAction(leftToolbar, DebuggerActions.EXPORT_THREADS);\n    addAction(leftToolbar, DebuggerActions.DUMP_THREADS);\n    leftToolbar.addSeparator();\n\n    leftToolbar.add(myUi.getOptions().getLayoutActions());\n\n    final AnAction[] commonSettings = myUi.getOptions().getSettingsActionsList();\n    final AnAction commonSettingsList = myUi.getOptions().getSettingsActions();\n\n    final DefaultActionGroup settings = new DefaultActionGroup(\"DebuggerSettings\", true) {\n      @Override\n      public void update(AnActionEvent e) {\n        e.getPresentation().setText(ActionsBundle.message(\"group.XDebugger.settings.text\"));\n        e.getPresentation().setIcon(commonSettingsList.getTemplatePresentation().getIcon());\n      }\n\n      @Override\n      public boolean isDumbAware() {\n        return true;\n      }\n    };\n    for (AnAction each : commonSettings) {\n      settings.add(each);\n    }\n    if (commonSettings.length > 0) {\n      settings.addSeparator();\n    }\n    settings.add(new WatchLastMethodReturnValueAction());\n    settings.add(new AutoVarsSwitchAction());\n    settings.addSeparator();\n    addActionToGroup(settings, XDebuggerActions.INLINE_DEBUGGER);\n    addActionToGroup(settings, XDebuggerActions.AUTO_TOOLTIP);\n    addActionToGroup(settings, XDebuggerActions.AUTO_TOOLTIP_ON_SELECTION);\n\n    leftToolbar.add(settings);\n\n    leftToolbar.addSeparator();\n\n    addActionToGroup(leftToolbar, PinToolwindowTabAction.ACTION_NAME);\n\n    myDebugUIEnvironment.initActions(myRunContentDescriptor, leftToolbar);\n\n    myUi.getOptions().setLeftToolbar(leftToolbar, ActionPlaces.DEBUGGER_TOOLBAR);\n  }","commit_id":"8be81b3c3af9647fc9d2408ce3bf5e87b0fddb16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    Project project = CommonDataKeys.PROJECT.getData(e.getDataContext());\n    if (project == null) {\n      return;\n    }\n    DebuggerContextImpl context = (DebuggerManagerEx.getInstanceEx(project)).getContext();\n\n    if(context.getDebuggerSession() != null) {\n      String destinationDirectory = \"\";\n      final VirtualFile baseDir = project.getBaseDir();\n      if (baseDir != null) destinationDirectory = baseDir.getPresentableUrl();\n\n      ExportDialog dialog = new ExportDialog(context.getDebugProcess(), destinationDirectory);\n      if (dialog.showAndGet()) {\n        try {\n          File file = new File(dialog.getFilePath());\n          BufferedWriter writer = new BufferedWriter(new FileWriter(file));\n          try {\n            String text = StringUtil.convertLineSeparators(dialog.getTextToSave(), SystemProperties.getLineSeparator());\n            writer.write(text);\n          }\n          finally {\n            writer.close();\n          }\n        }\n        catch (IOException ex) {\n          Messages\n            .showMessageDialog(project, ex.getMessage(), ActionsBundle.actionText(DebuggerActions.EXPORT_THREADS), Messages.getErrorIcon());\n        }\n      }\n    }\n  }","id":78735,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = CommonDataKeys.PROJECT.getData(e.getDataContext());\n    if (project == null) {\n      return;\n    }\n    DebuggerContextImpl context = (DebuggerManagerEx.getInstanceEx(project)).getContext();\n\n    final DebuggerSession session = context.getDebuggerSession();\n    if(session != null && session.isAttached()) {\n      final DebugProcessImpl process = context.getDebugProcess();\n      if (process != null) {\n        process.getManagerThread().invoke(new DebuggerCommandImpl() {\n          protected void action() throws Exception {\n            final List<ThreadState> threads = ThreadDumpAction.buildThreadStates(process.getVirtualMachineProxy());\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                ExportToTextFileAction.export(project, ThreadDumpPanel.createToFileExporter(project, threads));\n              }\n            }, ModalityState.NON_MODAL);\n          }\n        });\n      }\n    }\n  }","commit_id":"8be81b3c3af9647fc9d2408ce3bf5e87b0fddb16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void registerAdditionalActions(@NotNull DefaultActionGroup leftToolbar, @NotNull DefaultActionGroup topToolbar, @NotNull DefaultActionGroup settings) {\n    Constraints beforeRunner = new Constraints(Anchor.BEFORE, \"Runner.Layout\");\n    leftToolbar.add(Separator.getInstance(), beforeRunner);\n    leftToolbar.add(ActionManager.getInstance().getAction(DebuggerActions.EXPORT_THREADS), beforeRunner);\n    leftToolbar.add(ActionManager.getInstance().getAction(DebuggerActions.DUMP_THREADS), beforeRunner);\n    leftToolbar.add(Separator.getInstance(), beforeRunner);\n\n    settings.addAction(new AutoVarsSwitchAction(), Constraints.FIRST);\n    settings.addAction(new WatchLastMethodReturnValueAction(), Constraints.FIRST);\n  }","id":78736,"modified_method":"@Override\n  public void registerAdditionalActions(@NotNull DefaultActionGroup leftToolbar, @NotNull DefaultActionGroup topToolbar, @NotNull DefaultActionGroup settings) {\n    Constraints beforeRunner = new Constraints(Anchor.BEFORE, \"Runner.Layout\");\n    leftToolbar.add(Separator.getInstance(), beforeRunner);\n    //leftToolbar.add(ActionManager.getInstance().getAction(DebuggerActions.EXPORT_THREADS), beforeRunner);\n    leftToolbar.add(ActionManager.getInstance().getAction(DebuggerActions.DUMP_THREADS), beforeRunner);\n    leftToolbar.add(Separator.getInstance(), beforeRunner);\n\n    settings.addAction(new AutoVarsSwitchAction(), Constraints.FIRST);\n    settings.addAction(new WatchLastMethodReturnValueAction(), Constraints.FIRST);\n  }","commit_id":"8be81b3c3af9647fc9d2408ce3bf5e87b0fddb16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<ThreadState> buildThreadStates(VirtualMachineProxyImpl vmProxy) {\n    final List<ThreadReference> threads = vmProxy.getVirtualMachine().allThreads();\n    final List<ThreadState> result = new ArrayList<ThreadState>();\n    final Map<String, ThreadState> nameToThreadMap = new HashMap<String, ThreadState>();\n    final Map<String, String> waitingMap = new HashMap<String, String>(); // key 'waits_for' value\n    for (ThreadReference threadReference : threads) {\n      final StringBuilder buffer = new StringBuilder();\n      boolean hasEmptyStack = true;\n      final int threadStatus = threadReference.status();\n      if (threadStatus == ThreadReference.THREAD_STATUS_ZOMBIE) {\n        continue;\n      }\n      final String threadName = threadName(threadReference);\n      final ThreadState threadState = new ThreadState(threadName, threadStatusToState(threadStatus));\n      nameToThreadMap.put(threadName, threadState);\n      result.add(threadState);\n      threadState.setJavaThreadState(threadStatusToJavaThreadState(threadStatus));\n\n      buffer.append(\"\\\"\").append(threadName).append(\"\\\"\");\n      ReferenceType referenceType = threadReference.referenceType();\n      if (referenceType != null) {\n        //noinspection HardCodedStringLiteral\n        Field daemon = referenceType.fieldByName(\"daemon\");\n        if (daemon != null) {\n          Value value = threadReference.getValue(daemon);\n          if (value instanceof BooleanValue && ((BooleanValue)value).booleanValue()) {\n            buffer.append(\" \").append(DebuggerBundle.message(\"threads.export.attribute.label.daemon\"));\n            threadState.setDaemon(true);\n          }\n        }\n\n        //noinspection HardCodedStringLiteral\n        Field priority = referenceType.fieldByName(\"priority\");\n        if (priority != null) {\n          Value value = threadReference.getValue(priority);\n          if (value instanceof IntegerValue) {\n            buffer.append(\" \").append(DebuggerBundle.message(\"threads.export.attribute.label.priority\", ((IntegerValue)value).intValue()));\n          }\n        }\n\n        Field tid = referenceType.fieldByName(\"tid\");\n        if (tid != null) {\n          Value value = threadReference.getValue(tid);\n          if (value instanceof LongValue) {\n            buffer.append(\" \").append(DebuggerBundle.message(\"threads.export.attribute.label.tid\", Long.toHexString(((LongValue)value).longValue())));\n            buffer.append(\" nid=NA\");\n          }\n        }\n      }\n      //ThreadGroupReference groupReference = threadReference.threadGroup();\n      //if (groupReference != null) {\n      //  buffer.append(\", \").append(DebuggerBundle.message(\"threads.export.attribute.label.group\", groupReference.name()));\n      //}\n      final String state = threadState.getState();\n      if (state != null) {\n        buffer.append(\" \").append(state);\n      }\n\n      buffer.append(\"\\n  java.lang.Thread.State: \").append(threadState.getJavaThreadState());\n      \n      try {\n        if (vmProxy.canGetOwnedMonitorInfo() && vmProxy.canGetMonitorInfo()) {\n          List<ObjectReference> list = threadReference.ownedMonitors();\n          for (ObjectReference reference : list) {\n            if (!vmProxy.canGetMonitorFrameInfo()) { // java 5 and earlier\n              buffer.append(\"\\n\\t \").append(renderLockedObject(reference));\n            }\n            final List<ThreadReference> waiting = reference.waitingThreads();\n            for (ThreadReference thread : waiting) {\n              final String waitingThreadName = threadName(thread);\n              waitingMap.put(waitingThreadName, threadName);\n              buffer.append(\"\\n\\t \").append(DebuggerBundle.message(\"threads.export.attribute.label.blocks.thread\", waitingThreadName));\n            }\n          }\n        }\n\n        ObjectReference waitedMonitor = vmProxy.canGetCurrentContendedMonitor() ? threadReference.currentContendedMonitor() : null;\n        if (waitedMonitor != null) {\n          if (vmProxy.canGetMonitorInfo()) {\n            ThreadReference waitedMonitorOwner = waitedMonitor.owningThread();\n            if (waitedMonitorOwner != null) {\n              final String monitorOwningThreadName = threadName(waitedMonitorOwner);\n              waitingMap.put(threadName, monitorOwningThreadName);\n              buffer.append(\"\\n\\t \")\n                .append(DebuggerBundle.message(\"threads.export.attribute.label.waiting.for.thread\", monitorOwningThreadName, renderObject(waitedMonitor)));\n            }\n          }\n        }\n\n        final List<StackFrame> frames = threadReference.frames();\n        hasEmptyStack = frames.size() == 0;\n\n        final TIntObjectHashMap<List<ObjectReference>> lockedAt = new TIntObjectHashMap<List<ObjectReference>>();\n        if (vmProxy.canGetMonitorFrameInfo()) {\n          for (MonitorInfo info : threadReference.ownedMonitorsAndFrames()) {\n            final int stackDepth = info.stackDepth();\n            List<ObjectReference> monitors;\n            if ((monitors = lockedAt.get(stackDepth)) == null) {\n              lockedAt.put(stackDepth, monitors = new SmartList<ObjectReference>());\n            }\n            monitors.add(info.monitor());\n          }\n        }\n\n        for (int i = 0, framesSize = frames.size(); i < framesSize; i++) {\n          final StackFrame stackFrame = frames.get(i);\n          try {\n            final Location location = stackFrame.location();\n            buffer.append(\"\\n\\t  \").append(renderLocation(location));\n\n            final List<ObjectReference> monitors = lockedAt.get(i);\n            if (monitors != null) {\n              for (ObjectReference monitor : monitors) {\n                buffer.append(\"\\n\\t  - \").append(renderLockedObject(monitor));\n              }\n            }\n          }\n          catch (InvalidStackFrameException e) {\n            buffer.append(\"\\n\\t  Invalid stack frame: \").append(e.getMessage());\n          }\n        }\n      }\n      catch (IncompatibleThreadStateException e) {\n        buffer.append(\"\\n\\t \").append(DebuggerBundle.message(\"threads.export.attribute.error.incompatible.state\"));\n      }\n      threadState.setStackTrace(buffer.toString(), hasEmptyStack);\n      ThreadDumpParser.inferThreadStateDetail(threadState);\n    }\n\n    for (String waiting : waitingMap.keySet()) {\n      final ThreadState waitingThread = nameToThreadMap.get(waiting);\n      final ThreadState awaitedThread = nameToThreadMap.get(waitingMap.get(waiting));\n      awaitedThread.addWaitingThread(waitingThread);\n    }\n\n    // detect simple deadlocks\n    for (ThreadState thread : result) {\n      for (ThreadState awaitingThread : thread.getAwaitingThreads()) {\n        if (awaitingThread.isAwaitedBy(thread)) {\n          thread.addDeadlockedThread(awaitingThread);\n          awaitingThread.addDeadlockedThread(thread);\n        }\n      }\n    }\n\n    ThreadDumpParser.sortThreads(result);\n    return result;\n  }","id":78737,"modified_method":"static List<ThreadState> buildThreadStates(VirtualMachineProxyImpl vmProxy) {\n    final List<ThreadReference> threads = vmProxy.getVirtualMachine().allThreads();\n    final List<ThreadState> result = new ArrayList<ThreadState>();\n    final Map<String, ThreadState> nameToThreadMap = new HashMap<String, ThreadState>();\n    final Map<String, String> waitingMap = new HashMap<String, String>(); // key 'waits_for' value\n    for (ThreadReference threadReference : threads) {\n      final StringBuilder buffer = new StringBuilder();\n      boolean hasEmptyStack = true;\n      final int threadStatus = threadReference.status();\n      if (threadStatus == ThreadReference.THREAD_STATUS_ZOMBIE) {\n        continue;\n      }\n      final String threadName = threadName(threadReference);\n      final ThreadState threadState = new ThreadState(threadName, threadStatusToState(threadStatus));\n      nameToThreadMap.put(threadName, threadState);\n      result.add(threadState);\n      threadState.setJavaThreadState(threadStatusToJavaThreadState(threadStatus));\n\n      buffer.append(\"\\\"\").append(threadName).append(\"\\\"\");\n      ReferenceType referenceType = threadReference.referenceType();\n      if (referenceType != null) {\n        //noinspection HardCodedStringLiteral\n        Field daemon = referenceType.fieldByName(\"daemon\");\n        if (daemon != null) {\n          Value value = threadReference.getValue(daemon);\n          if (value instanceof BooleanValue && ((BooleanValue)value).booleanValue()) {\n            buffer.append(\" \").append(DebuggerBundle.message(\"threads.export.attribute.label.daemon\"));\n            threadState.setDaemon(true);\n          }\n        }\n\n        //noinspection HardCodedStringLiteral\n        Field priority = referenceType.fieldByName(\"priority\");\n        if (priority != null) {\n          Value value = threadReference.getValue(priority);\n          if (value instanceof IntegerValue) {\n            buffer.append(\" \").append(DebuggerBundle.message(\"threads.export.attribute.label.priority\", ((IntegerValue)value).intValue()));\n          }\n        }\n\n        Field tid = referenceType.fieldByName(\"tid\");\n        if (tid != null) {\n          Value value = threadReference.getValue(tid);\n          if (value instanceof LongValue) {\n            buffer.append(\" \").append(DebuggerBundle.message(\"threads.export.attribute.label.tid\", Long.toHexString(((LongValue)value).longValue())));\n            buffer.append(\" nid=NA\");\n          }\n        }\n      }\n      //ThreadGroupReference groupReference = threadReference.threadGroup();\n      //if (groupReference != null) {\n      //  buffer.append(\", \").append(DebuggerBundle.message(\"threads.export.attribute.label.group\", groupReference.name()));\n      //}\n      final String state = threadState.getState();\n      if (state != null) {\n        buffer.append(\" \").append(state);\n      }\n\n      buffer.append(\"\\n  java.lang.Thread.State: \").append(threadState.getJavaThreadState());\n      \n      try {\n        if (vmProxy.canGetOwnedMonitorInfo() && vmProxy.canGetMonitorInfo()) {\n          List<ObjectReference> list = threadReference.ownedMonitors();\n          for (ObjectReference reference : list) {\n            if (!vmProxy.canGetMonitorFrameInfo()) { // java 5 and earlier\n              buffer.append(\"\\n\\t \").append(renderLockedObject(reference));\n            }\n            final List<ThreadReference> waiting = reference.waitingThreads();\n            for (ThreadReference thread : waiting) {\n              final String waitingThreadName = threadName(thread);\n              waitingMap.put(waitingThreadName, threadName);\n              buffer.append(\"\\n\\t \").append(DebuggerBundle.message(\"threads.export.attribute.label.blocks.thread\", waitingThreadName));\n            }\n          }\n        }\n\n        ObjectReference waitedMonitor = vmProxy.canGetCurrentContendedMonitor() ? threadReference.currentContendedMonitor() : null;\n        if (waitedMonitor != null) {\n          if (vmProxy.canGetMonitorInfo()) {\n            ThreadReference waitedMonitorOwner = waitedMonitor.owningThread();\n            if (waitedMonitorOwner != null) {\n              final String monitorOwningThreadName = threadName(waitedMonitorOwner);\n              waitingMap.put(threadName, monitorOwningThreadName);\n              buffer.append(\"\\n\\t \")\n                .append(DebuggerBundle.message(\"threads.export.attribute.label.waiting.for.thread\", monitorOwningThreadName, renderObject(waitedMonitor)));\n            }\n          }\n        }\n\n        final List<StackFrame> frames = threadReference.frames();\n        hasEmptyStack = frames.size() == 0;\n\n        final TIntObjectHashMap<List<ObjectReference>> lockedAt = new TIntObjectHashMap<List<ObjectReference>>();\n        if (vmProxy.canGetMonitorFrameInfo()) {\n          for (MonitorInfo info : threadReference.ownedMonitorsAndFrames()) {\n            final int stackDepth = info.stackDepth();\n            List<ObjectReference> monitors;\n            if ((monitors = lockedAt.get(stackDepth)) == null) {\n              lockedAt.put(stackDepth, monitors = new SmartList<ObjectReference>());\n            }\n            monitors.add(info.monitor());\n          }\n        }\n\n        for (int i = 0, framesSize = frames.size(); i < framesSize; i++) {\n          final StackFrame stackFrame = frames.get(i);\n          try {\n            final Location location = stackFrame.location();\n            buffer.append(\"\\n\\t  \").append(renderLocation(location));\n\n            final List<ObjectReference> monitors = lockedAt.get(i);\n            if (monitors != null) {\n              for (ObjectReference monitor : monitors) {\n                buffer.append(\"\\n\\t  - \").append(renderLockedObject(monitor));\n              }\n            }\n          }\n          catch (InvalidStackFrameException e) {\n            buffer.append(\"\\n\\t  Invalid stack frame: \").append(e.getMessage());\n          }\n        }\n      }\n      catch (IncompatibleThreadStateException e) {\n        buffer.append(\"\\n\\t \").append(DebuggerBundle.message(\"threads.export.attribute.error.incompatible.state\"));\n      }\n      threadState.setStackTrace(buffer.toString(), hasEmptyStack);\n      ThreadDumpParser.inferThreadStateDetail(threadState);\n    }\n\n    for (String waiting : waitingMap.keySet()) {\n      final ThreadState waitingThread = nameToThreadMap.get(waiting);\n      final ThreadState awaitedThread = nameToThreadMap.get(waitingMap.get(waiting));\n      awaitedThread.addWaitingThread(waitingThread);\n    }\n\n    // detect simple deadlocks\n    for (ThreadState thread : result) {\n      for (ThreadState awaitingThread : thread.getAwaitingThreads()) {\n        if (awaitingThread.isAwaitedBy(thread)) {\n          thread.addDeadlockedThread(awaitingThread);\n          awaitingThread.addDeadlockedThread(thread);\n        }\n      }\n    }\n\n    ThreadDumpParser.sortThreads(result);\n    return result;\n  }","commit_id":"8be81b3c3af9647fc9d2408ce3bf5e87b0fddb16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ThreadDumpPanel(final Project project, final ConsoleView consoleView, final DefaultActionGroup toolbarActions, final List<ThreadState> threadDump) {\n    super(new BorderLayout());\n    myThreadDump = threadDump;\n\n    myFilterField = new SearchTextField();\n    myFilterField.addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        updateThreadList();\n      }\n    });\n\n    myFilterPanel = new JPanel(new BorderLayout());\n    myFilterPanel.add(new JLabel(\"Filter:\"), BorderLayout.WEST);\n    myFilterPanel.add(myFilterField);\n    myFilterPanel.setVisible(false);\n\n    myThreadList = new JBList(new DefaultListModel());\n    myThreadList.setCellRenderer(new ThreadListCellRenderer());\n    myThreadList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myThreadList.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(final ListSelectionEvent e) {\n        int index = myThreadList.getSelectedIndex();\n        if (index >= 0) {\n          ThreadState selection = (ThreadState)myThreadList.getModel().getElementAt(index);\n          AnalyzeStacktraceUtil.printStacktrace(consoleView, selection.getStackTrace());\n        }\n        else {\n          AnalyzeStacktraceUtil.printStacktrace(consoleView, \"\");\n        }\n        myThreadList.repaint();\n      }\n    });\n\n    FilterAction filterAction = new FilterAction();\n    filterAction.registerCustomShortcutSet(ActionManager.getInstance().getAction(IdeActions.ACTION_FIND).getShortcutSet(), myThreadList);\n    toolbarActions.add(filterAction);\n    toolbarActions.add(new CopyToClipboardAction(threadDump, project));\n    toolbarActions.add(new SortThreadsAction());\n    add(ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, toolbarActions, false).getComponent(), BorderLayout.WEST);\n\n    JPanel leftPanel = new JPanel(new BorderLayout());\n    leftPanel.add(myFilterPanel, BorderLayout.NORTH);\n    leftPanel.add(ScrollPaneFactory.createScrollPane(myThreadList, SideBorder.LEFT | SideBorder.RIGHT), BorderLayout.CENTER);\n\n    final Splitter splitter = new Splitter(false, 0.3f);\n    splitter.setFirstComponent(leftPanel);\n    splitter.setSecondComponent(consoleView.getComponent());\n    add(splitter, BorderLayout.CENTER);\n\n    new ListSpeedSearch(myThreadList).setComparator(new SpeedSearchComparator(false, true));\n\n    updateThreadList();\n\n    final Editor editor = CommonDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext(consoleView.getPreferredFocusableComponent()));\n    if (editor != null) {\n      editor.getDocument().addDocumentListener(new com.intellij.openapi.editor.event.DocumentAdapter() {\n        @Override\n        public void documentChanged(com.intellij.openapi.editor.event.DocumentEvent e) {\n          String filter = myFilterField.getText();\n          if (StringUtil.isNotEmpty(filter)) {\n            highlightOccurrences(filter, project, editor);\n          }\n        }\n      }, consoleView);\n    }\n  }","id":78738,"modified_method":"public ThreadDumpPanel(final Project project, final ConsoleView consoleView, final DefaultActionGroup toolbarActions, final List<ThreadState> threadDump) {\n    super(new BorderLayout());\n    myThreadDump = threadDump;\n\n    myFilterField = new SearchTextField();\n    myFilterField.addDocumentListener(new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        updateThreadList();\n      }\n    });\n\n    myFilterPanel = new JPanel(new BorderLayout());\n    myFilterPanel.add(new JLabel(\"Filter:\"), BorderLayout.WEST);\n    myFilterPanel.add(myFilterField);\n    myFilterPanel.setVisible(false);\n\n    myThreadList = new JBList(new DefaultListModel());\n    myThreadList.setCellRenderer(new ThreadListCellRenderer());\n    myThreadList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myThreadList.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(final ListSelectionEvent e) {\n        int index = myThreadList.getSelectedIndex();\n        if (index >= 0) {\n          ThreadState selection = (ThreadState)myThreadList.getModel().getElementAt(index);\n          AnalyzeStacktraceUtil.printStacktrace(consoleView, selection.getStackTrace());\n        }\n        else {\n          AnalyzeStacktraceUtil.printStacktrace(consoleView, \"\");\n        }\n        myThreadList.repaint();\n      }\n    });\n\n    myExporterToTextFile = createToFileExporter(project, myThreadDump);\n\n    FilterAction filterAction = new FilterAction();\n    filterAction.registerCustomShortcutSet(ActionManager.getInstance().getAction(IdeActions.ACTION_FIND).getShortcutSet(), myThreadList);\n    toolbarActions.add(filterAction);\n    toolbarActions.add(new CopyToClipboardAction(threadDump, project));\n    toolbarActions.add(new SortThreadsAction());\n    toolbarActions.add(ActionManager.getInstance().getAction(IdeActions.ACTION_EXPORT_TO_TEXT_FILE));\n    add(ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, toolbarActions, false).getComponent(), BorderLayout.WEST);\n\n    JPanel leftPanel = new JPanel(new BorderLayout());\n    leftPanel.add(myFilterPanel, BorderLayout.NORTH);\n    leftPanel.add(ScrollPaneFactory.createScrollPane(myThreadList, SideBorder.LEFT | SideBorder.RIGHT), BorderLayout.CENTER);\n\n    final Splitter splitter = new Splitter(false, 0.3f);\n    splitter.setFirstComponent(leftPanel);\n    splitter.setSecondComponent(consoleView.getComponent());\n    add(splitter, BorderLayout.CENTER);\n\n    new ListSpeedSearch(myThreadList).setComparator(new SpeedSearchComparator(false, true));\n\n    updateThreadList();\n\n    final Editor editor = CommonDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext(consoleView.getPreferredFocusableComponent()));\n    if (editor != null) {\n      editor.getDocument().addDocumentListener(new com.intellij.openapi.editor.event.DocumentAdapter() {\n        @Override\n        public void documentChanged(com.intellij.openapi.editor.event.DocumentEvent e) {\n          String filter = myFilterField.getText();\n          if (StringUtil.isNotEmpty(filter)) {\n            highlightOccurrences(filter, project, editor);\n          }\n        }\n      }, consoleView);\n    }\n  }","commit_id":"8be81b3c3af9647fc9d2408ce3bf5e87b0fddb16","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void update(AnActionEvent event){\n    Presentation presentation = event.getPresentation();\n    Project project = PlatformDataKeys.PROJECT.getData(event.getDataContext());\n    if (project == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n    DebuggerSession debuggerSession = (DebuggerManagerEx.getInstanceEx(project)).getContext().getDebuggerSession();\n    presentation.setEnabled(debuggerSession != null);\n  }","id":78739,"modified_method":"public void update(AnActionEvent event){\n    Presentation presentation = event.getPresentation();\n    Project project = PlatformDataKeys.PROJECT.getData(event.getDataContext());\n    if (project == null) {\n      presentation.setEnabled(false);\n      return;\n    }\n    DebuggerSession debuggerSession = (DebuggerManagerEx.getInstanceEx(project)).getContext().getDebuggerSession();\n    presentation.setEnabled(debuggerSession != null && debuggerSession.isAttached());\n  }","commit_id":"741d5004aa16293981de2a5e174fc8c3bb2c2a44","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    if (project == null) {\n      return;\n    }\n    DebuggerContextImpl context = (DebuggerManagerEx.getInstanceEx(project)).getContext();\n\n    if(context.getDebuggerSession() != null) {\n      final DebugProcessImpl process = context.getDebugProcess();\n      process.getManagerThread().invoke(new DebuggerCommandImpl() {\n        protected void action() throws Exception {\n          final VirtualMachineProxyImpl vm = process.getVirtualMachineProxy();\n          vm.suspend();\n          try {\n            final List<ThreadState> threads = buildThreadStates(vm);\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                final DebuggerSessionTab sessionTab = DebuggerPanelsManager.getInstance(project).getSessionTab();\n                if (sessionTab != null) {\n                  sessionTab.addThreadDump(threads);\n                }\n              }\n            }, ModalityState.NON_MODAL);\n          }\n          finally {\n            vm.resume();\n          }\n        }\n      });\n    }\n  }","id":78740,"modified_method":"public void actionPerformed(AnActionEvent e) {\n    final Project project = PlatformDataKeys.PROJECT.getData(e.getDataContext());\n    if (project == null) {\n      return;\n    }\n    DebuggerContextImpl context = (DebuggerManagerEx.getInstanceEx(project)).getContext();\n\n    final DebuggerSession session = context.getDebuggerSession();\n    if(session != null && session.isAttached()) {\n      final DebugProcessImpl process = context.getDebugProcess();\n      process.getManagerThread().invoke(new DebuggerCommandImpl() {\n        protected void action() throws Exception {\n          final VirtualMachineProxyImpl vm = process.getVirtualMachineProxy();\n          vm.suspend();\n          try {\n            final List<ThreadState> threads = buildThreadStates(vm);\n            ApplicationManager.getApplication().invokeLater(new Runnable() {\n              public void run() {\n                final DebuggerSessionTab sessionTab = DebuggerPanelsManager.getInstance(project).getSessionTab();\n                if (sessionTab != null) {\n                  sessionTab.addThreadDump(threads);\n                }\n              }\n            }, ModalityState.NON_MODAL);\n          }\n          finally {\n            vm.resume();\n          }\n        }\n      });\n    }\n  }","commit_id":"741d5004aa16293981de2a5e174fc8c3bb2c2a44","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public SourcePosition getSourcePosition(final Project project, final DebuggerContextImpl context) {\n    if (context.getFrameProxy() == null) return null;\n    final ReferenceType type = myField.declaringType();\n    final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n    final String fieldName = myField.name();\n    if (fieldName.startsWith(OUTER_LOCAL_VAR_FIELD_PREFIX)) {\n      // this field actually mirrors a local variable in the outer class\n      String varName = fieldName.substring(fieldName.lastIndexOf('$') + 1);\n      PsiElement element = PositionUtil.getContextElement(context);\n      if (element == null) {\n        return null;\n      }\n      PsiClass aClass = PsiTreeUtil.getParentOfType(element, PsiClass.class, false);\n      if (aClass == null) {\n        return null;\n      }\n      aClass = (PsiClass) aClass.getNavigationElement();\n      PsiVariable psiVariable = facade.getResolveHelper().resolveReferencedVariable(varName, aClass);\n      if (psiVariable == null) {\n        return null;\n      }\n      return SourcePosition.createFromOffset(psiVariable.getContainingFile(), psiVariable.getTextOffset());\n    }\n    else {\n      PsiClass aClass = facade.findClass(type.name().replace('$', '.'), context.getDebuggerSession().getSearchScope());\n      if (aClass == null) {\n        // trying to search, assuming declaring class is an anonymous class\n        try {\n          final List<Location> locations = type.allLineLocations();\n          if (!locations.isEmpty()) {\n            // important: use the last location to be sure the position will be within the anonymous class\n            final Location lastLocation = locations.get(locations.size() - 1);\n            final SourcePosition position = context.getDebugProcess().getPositionManager().getSourcePosition(lastLocation);\n            if (position != null) {\n              aClass = JVMNameUtil.getClassAt(position);\n            }\n          }\n        }\n        catch (AbsentInformationException ignored) {\n        }\n        catch (ClassNotPreparedException ignored) {\n        }\n      }\n\n      if (aClass != null) {\n        aClass = (PsiClass) aClass.getNavigationElement();\n        for (PsiField field : aClass.getFields()) {\n          if (fieldName.equals(field.getName())) {\n            return SourcePosition.createFromOffset(field.getContainingFile(), field.getTextOffset());\n          }\n        }\n      }\n      return null;\n    }\n  }","id":78741,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public SourcePosition getSourcePosition(final Project project, final DebuggerContextImpl context) {\n    if (context.getFrameProxy() == null) {\n      return null;\n    }\n    final ReferenceType type = myField.declaringType();\n    final JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n    final String fieldName = myField.name();\n    if (fieldName.startsWith(OUTER_LOCAL_VAR_FIELD_PREFIX)) {\n      // this field actually mirrors a local variable in the outer class\n      String varName = fieldName.substring(fieldName.lastIndexOf('$') + 1);\n      PsiElement element = PositionUtil.getContextElement(context);\n      if (element == null) {\n        return null;\n      }\n      PsiClass aClass = PsiTreeUtil.getParentOfType(element, PsiClass.class, false);\n      if (aClass == null) {\n        return null;\n      }\n      aClass = (PsiClass) aClass.getNavigationElement();\n      PsiVariable psiVariable = facade.getResolveHelper().resolveReferencedVariable(varName, aClass);\n      if (psiVariable == null) {\n        return null;\n      }\n      return SourcePosition.createFromOffset(psiVariable.getContainingFile(), psiVariable.getTextOffset());\n    }\n    else {\n      final DebuggerSession session = context.getDebuggerSession();\n      final GlobalSearchScope scope = session != null? session.getSearchScope() : GlobalSearchScope.allScope(myProject);\n      PsiClass aClass = facade.findClass(type.name().replace('$', '.'), scope);\n      if (aClass == null) {\n        // trying to search, assuming declaring class is an anonymous class\n        try {\n          final List<Location> locations = type.allLineLocations();\n          if (!locations.isEmpty()) {\n            // important: use the last location to be sure the position will be within the anonymous class\n            final Location lastLocation = locations.get(locations.size() - 1);\n            final SourcePosition position = context.getDebugProcess().getPositionManager().getSourcePosition(lastLocation);\n            if (position != null) {\n              aClass = JVMNameUtil.getClassAt(position);\n            }\n          }\n        }\n        catch (AbsentInformationException ignored) {\n        }\n        catch (ClassNotPreparedException ignored) {\n        }\n      }\n\n      if (aClass != null) {\n        aClass = (PsiClass) aClass.getNavigationElement();\n        for (PsiField field : aClass.getFields()) {\n          if (fieldName.equals(field.getName())) {\n            return SourcePosition.createFromOffset(field.getContainingFile(), field.getTextOffset());\n          }\n        }\n      }\n      return null;\n    }\n  }","commit_id":"4fcb92813bd0efc1ef8df76921d435128b3b14ca","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isEnabled(@NotNull final Project project, final AnActionEvent event) {\n    DebuggerSession debuggerSession = (DebuggerManagerEx.getInstanceEx(project)).getContext().getDebuggerSession();\n    return debuggerSession != null && debuggerSession.isPaused();\n  }","id":78742,"modified_method":"public boolean isEnabled(@NotNull final Project project, final AnActionEvent event) {\n    DebuggerSession debuggerSession = (DebuggerManagerEx.getInstanceEx(project)).getContext().getDebuggerSession();\n    return debuggerSession == null || debuggerSession.isPaused();\n  }","commit_id":"753211f8827866ca79657cb58c01e5e2dd85b04c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void perform(@NotNull final Project project, final AnActionEvent event) {\n    (DebuggerManagerEx.getInstanceEx(project)).getContext().getDebuggerSession().resume();\n  }","id":78743,"modified_method":"public void perform(@NotNull final Project project, final AnActionEvent event) {\n    final DebuggerSession session = (DebuggerManagerEx.getInstanceEx(project)).getContext().getDebuggerSession();\n    if (session != null && session.isPaused()) {\n      session.resume();\n    } else {\n      new ChooseDebugConfigurationAction().actionPerformed(event);\n    }\n  }","commit_id":"753211f8827866ca79657cb58c01e5e2dd85b04c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/** Truncate a block file */\n  private long truncateBlockFile() throws IOException {\n    synchronized (fds) {\n      for (ReplicaInfo b : FsDatasetTestUtil.getReplicas(fds, bpid)) {\n        File f = b.getBlockFile();\n        File mf = b.getMetaFile();\n        // Truncate a block file that has a corresponding metadata file\n        if (f.exists() && f.length() != 0 && mf.exists()) {\n          FileOutputStream s = new FileOutputStream(f);\n          FileChannel channel = s.getChannel();\n          channel.truncate(0);\n          LOG.info(\"Truncated block file \" + f.getAbsolutePath());\n          return b.getBlockId();\n        }\n      }\n    }\n    return 0;\n  }","id":78744,"modified_method":"/** Truncate a block file */\n  private long truncateBlockFile() throws IOException {\n    synchronized (fds) {\n      for (ReplicaInfo b : FsDatasetTestUtil.getReplicas(fds, bpid)) {\n        File f = b.getBlockFile();\n        File mf = b.getMetaFile();\n        // Truncate a block file that has a corresponding metadata file\n        if (f.exists() && f.length() != 0 && mf.exists()) {\n          FileOutputStream s = null;\n          FileChannel channel = null;\n          try {\n            s = new FileOutputStream(f);\n            channel = s.getChannel();\n            channel.truncate(0);\n            LOG.info(\"Truncated block file \" + f.getAbsolutePath());\n            return b.getBlockId();\n          } finally {\n            IOUtils.cleanup(LOG, channel, s);\n          }\n        }\n      }\n    }\n    return 0;\n  }","commit_id":"8a9eff39195d5fbce3f9eb435b8e9b85cc97a6b1","url":"https://github.com/apache/hadoop"},{"original_method":"public void copyObject(String sourceBucket, String sourceObject, String destinationBucket, String destinationObject) throws IOException {\n\t\tFile oldObjectFile = new File (WalrusInfo.getWalrusInfo().getStorageDir() + FILE_SEPARATOR + sourceBucket + FILE_SEPARATOR + sourceObject);\n\t\tFile newObjectFile = new File (WalrusInfo.getWalrusInfo().getStorageDir() + FILE_SEPARATOR + destinationBucket + FILE_SEPARATOR + destinationObject);\n\t\tif(!oldObjectFile.equals(newObjectFile)) {\t\n\t\t\t\n\t\t\tFileInputStream fileInputStream = new FileInputStream(oldObjectFile);\n\t\t\tFileChannel fileIn = fileInputStream.getChannel();\n\t\t\tFileOutputStream fileOutputStream = new FileOutputStream(newObjectFile);\n\t\t\tFileChannel fileOut = fileOutputStream.getChannel();\n\t\t\ttry {\n\t\t\t\tfileIn.transferTo(0, fileIn.size(), fileOut);\n\t\t\t} catch (IOException ex) {\n\t\t\t\t LOG.error( ex );\n\t\t\t     Logs.extreme( ).error( ex, ex );\n\t\t\t     throw ex;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif(fileIn != null) \n\t\t\t\t\t\tfileIn.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tfileInputStream.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif(fileOut != null) \n\t\t\t\t\t\tfileOut.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tfileOutputStream.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":78745,"modified_method":"public void copyObject(String sourceBucket, String sourceObject, String destinationBucket, String destinationObject) throws IOException {\n\t\tFile oldObjectFile = new File (WalrusInfo.getWalrusInfo().getStorageDir() + FILE_SEPARATOR + sourceBucket + FILE_SEPARATOR + sourceObject);\n\t\tFile newObjectFile = new File (WalrusInfo.getWalrusInfo().getStorageDir() + FILE_SEPARATOR + destinationBucket + FILE_SEPARATOR + destinationObject);\n\t\tif(!oldObjectFile.equals(newObjectFile)) {\t\n\t\t\tFileInputStream fileInputStream = null;\n\t\t\tFileChannel fileIn = null;\n\t\t\tFileOutputStream fileOutputStream = null;\n\t\t\tFileChannel fileOut = null;\n\t\t\ttry {\n\t\t\t\tfileInputStream = new FileInputStream(oldObjectFile);\n\t\t\t\tfileIn = fileInputStream.getChannel();\n\t\t\t\tfileOutputStream = new FileOutputStream(newObjectFile);\n\t\t\t\tfileOut = fileOutputStream.getChannel();\n\t\t\t\tfileIn.transferTo(0, fileIn.size(), fileOut);\n\t\t\t} catch (IOException ex) {\n\t\t\t\t LOG.error( ex );\n\t\t\t     Logs.extreme( ).error( ex, ex );\n\t\t\t     throw ex;\n\t\t\t}  finally {\n\t\t\t\ttry {\n\t\t\t\t\tif(fileIn != null) \n\t\t\t\t\t\tfileIn.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif( fileInputStream != null)\n\t\t\t\t\t\tfileInputStream.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif(fileOut != null) \n\t\t\t\t\t\tfileOut.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif(fileOutputStream != null)\n\t\t\t\t\t\tfileOutputStream.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"2353d032c485f258f4623047e400b8886025be88","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public MappedByteBuffer map() {\n    MappedByteBuffer buf;\n    try {\n      RandomAccessFile raf = new RandomAccessFile(myFile, RW);\n      final FileChannel channel = raf.getChannel();\n      buf = null;\n      try {\n        buf = channel.map(FileChannel.MapMode.READ_WRITE, myPosition, myLength);\n      }\n      catch (IOException e) {\n        throw new RuntimeException(\"Mapping failed: \" + myFile.getAbsolutePath() + \", position=\" + myPosition + \", length=\" + myLength, e);\n      }\n      finally {\n        channel.close();\n        raf.close();\n      }\n    }\n    catch (IOException e) {\n      buf = null;\n    }\n\n    if (buf == null) {\n      throw new RuntimeException(\"Mapping failed: \" + myFile.getAbsolutePath() + \", position=\" + myPosition + \", length=\" + myLength);\n    }\n\n    return buf;\n  }","id":78746,"modified_method":"public MappedByteBuffer map() {\n    MappedByteBuffer buf;\n    try {\n      buf = null;\n      RandomAccessFile raf = null;\n      FileChannel channel = null;\n      try {\n        raf = new RandomAccessFile(myFile, RW);\n        channel = raf.getChannel();\n        buf = channel.map(FileChannel.MapMode.READ_WRITE, myPosition, myLength);\n      }\n      catch (IOException e) {\n        throw new RuntimeException(\"Mapping failed: \" + myFile.getAbsolutePath() + \", position=\" + myPosition + \", length=\" + myLength, e);\n      }\n      finally {\n        if (channel != null) {\n          channel.close();\n        }\n        if (raf != null) {\n          raf.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      buf = null;\n    }\n\n    if (buf == null) {\n      throw new RuntimeException(\"Mapping failed: \" + myFile.getAbsolutePath() + \", position=\" + myPosition + \", length=\" + myLength);\n    }\n\n    return buf;\n  }","commit_id":"db062787961f5c14f9016be5fe2aa3c790ce0144","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void copyObject(String sourceBucket, String sourceObject, String destinationBucket, String destinationObject) throws IOException {\n\t\tFile oldObjectFile = new File (WalrusInfo.getWalrusInfo().getStorageDir() + FILE_SEPARATOR + sourceBucket + FILE_SEPARATOR + sourceObject);\n\t\tFile newObjectFile = new File (WalrusInfo.getWalrusInfo().getStorageDir() + FILE_SEPARATOR + destinationBucket + FILE_SEPARATOR + destinationObject);\n\t\tif(!oldObjectFile.equals(newObjectFile)) {\t\n\t\t\t\n\t\t\tFileInputStream fileInputStream = new FileInputStream(oldObjectFile);\n\t\t\tFileChannel fileIn = fileInputStream.getChannel();\n\t\t\tFileOutputStream fileOutputStream = new FileOutputStream(newObjectFile);\n\t\t\tFileChannel fileOut = fileOutputStream.getChannel();\n\t\t\ttry {\n\t\t\t\tfileIn.transferTo(0, fileIn.size(), fileOut);\n\t\t\t} catch (IOException ex) {\n\t\t\t\t LOG.error( ex );\n\t\t\t     Logs.extreme( ).error( ex, ex );\n\t\t\t     throw ex;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif(fileIn != null) \n\t\t\t\t\t\tfileIn.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tfileInputStream.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif(fileOut != null) \n\t\t\t\t\t\tfileOut.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tfileOutputStream.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":78747,"modified_method":"public void copyObject(String sourceBucket, String sourceObject, String destinationBucket, String destinationObject) throws IOException {\n\t\tFile oldObjectFile = new File (WalrusInfo.getWalrusInfo().getStorageDir() + FILE_SEPARATOR + sourceBucket + FILE_SEPARATOR + sourceObject);\n\t\tFile newObjectFile = new File (WalrusInfo.getWalrusInfo().getStorageDir() + FILE_SEPARATOR + destinationBucket + FILE_SEPARATOR + destinationObject);\n\t\tif(!oldObjectFile.equals(newObjectFile)) {\t\n\t\t\tFileInputStream fileInputStream = null;\n\t\t\tFileChannel fileIn = null;\n\t\t\tFileOutputStream fileOutputStream = null;\n\t\t\tFileChannel fileOut = null;\n\t\t\ttry {\n\t\t\t\tfileInputStream = new FileInputStream(oldObjectFile);\n\t\t\t\tfileIn = fileInputStream.getChannel();\n\t\t\t\tfileOutputStream = new FileOutputStream(newObjectFile);\n\t\t\t\tfileOut = fileOutputStream.getChannel();\n\t\t\t\tfileIn.transferTo(0, fileIn.size(), fileOut);\n\t\t\t} catch (IOException ex) {\n\t\t\t\t LOG.error( ex );\n\t\t\t     Logs.extreme( ).error( ex, ex );\n\t\t\t     throw ex;\n\t\t\t}  finally {\n\t\t\t\ttry {\n\t\t\t\t\tif(fileIn != null) \n\t\t\t\t\t\tfileIn.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif( fileInputStream != null)\n\t\t\t\t\t\tfileInputStream.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif(fileOut != null) \n\t\t\t\t\t\tfileOut.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif(fileOutputStream != null)\n\t\t\t\t\t\tfileOutputStream.close();\n\t\t\t\t} catch(IOException e) {\n\t\t\t\t\tLOG.error( e );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"d96c813eaf7b8b2844cf448a86a242e0604daa53","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n    public void log(String st) {\n        final byte[] stringBytes = st.getBytes(CHAR_SET);\n\n        try {\n            final FileOutputStream fileOutputStream = new FileOutputStream(f, true);\n            final FileChannel channel = fileOutputStream.getChannel();\n\n            int index = buffer.arrayOffset();\n\n            while (index < stringBytes.length) {\n                final int remainder = stringBytes.length - index;\n                final int length = getRemainderAvailable(remainder);\n\n                buffer.put(stringBytes, index, length);\n\n                buffer.flip();\n\n\n                channel.write(buffer);\n\n                if (buffer.hasRemaining()) {\n                    buffer.compact();\n                } else {\n                    buffer.clear();\n                }\n\n                index += length;\n               \n            }\n            synchronized (NEWLINE) {\n                channel.write(NEWLINE);\n                NEWLINE.rewind();\n            }\n\n         \n            channel.close();\n            fileOutputStream.close();\n            \n        } catch (BufferOverflowException ioe) {\n            LOG.error(possibleCause+ioe.getMessage(), ioe);\n        } catch (IOException ioe) {\n            LOG.error(ioe.getMessage(), ioe);\n        }\n    }","id":78748,"modified_method":"@Override\n    public void log(String st) {\n        final byte[] stringBytes = st.getBytes(CHAR_SET);\n     \n      FileOutputStream fileOutputStream =null;\n      FileChannel channel =null;\n       \n               \n        try {\n            \n            fileOutputStream = new FileOutputStream(f, true);\n            channel = fileOutputStream.getChannel();\n            \n            int index = buffer.arrayOffset();\n\n            while (index < stringBytes.length) {\n                final int remainder = stringBytes.length - index;\n                final int length = getRemainderAvailable(remainder);\n\n                buffer.put(stringBytes, index, length);\n\n                buffer.flip();\n\n\n                channel.write(buffer);\n\n                if (buffer.hasRemaining()) {\n                    buffer.compact();\n                } else {\n                    buffer.clear();\n                }\n\n                index += length;\n               \n            }\n            synchronized (NEWLINE) {\n                channel.write(NEWLINE);\n                NEWLINE.rewind();\n            }\n    \n            \n        } catch (BufferOverflowException ioe) {\n            LOG.error(possibleCause+ioe.getMessage(), ioe);\n        } catch (IOException ioe) {\n            LOG.error(ioe.getMessage(), ioe);\n        } finally {\n            buffer.clear();\n           \n            try{\n                if(channel!=null){ \n                   channel.close();\n                 }\n                if(fileOutputStream!=null){\n                  fileOutputStream.close();\n                }\n            }catch(IOException ioe) {\n              LOG.error(ioe.getMessage(), ioe);\n            }\n        }\n       \n    }","commit_id":"3b9888b96159b1362f20659247860d674be7f832","url":"https://github.com/rackerlabs/repose"},{"original_method":"/**\n     * @param file\n     */\n    public DirectNIOBuffer(File file) throws IOException\n    {\n        super(READONLY,NON_VOLATILE);\n        FileInputStream fis = new FileInputStream(file);\n        FileChannel fc = fis.getChannel();\n        _buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, file.length());\n        setGetIndex(0);\n        setPutIndex((int)file.length());\n        _access=IMMUTABLE;\n    }","id":78749,"modified_method":"/**\n     * @param file\n     */\n    public DirectNIOBuffer(File file) throws IOException\n    {\n        super(READONLY,NON_VOLATILE);\n        FileInputStream fis = null;\n        FileChannel fc = null;\n        try\n        {\n            fis = new FileInputStream(file);\n            fc = fis.getChannel();\n            _buf = fc.map(FileChannel.MapMode.READ_ONLY, 0, file.length());\n            setGetIndex(0);\n            setPutIndex((int)file.length());\n            _access=IMMUTABLE;\n        }\n        finally\n        {\n            if (fc != null) try {fc.close();} catch (IOException e){LOG.ignore(e);}\n            IO.close(fis);\n        }\n    }","commit_id":"10845bfd284b5a1c86598a937d04825872e505c4","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public ModuleVersionDescriptor getDependency(DependencyDescriptor dd) {\n        ResolveData resolveData = IvyContextualiser.getIvyContext().getResolveData();\n        try {\n            ResolvedModuleRevision revision = resolver.getDependency(dd, resolveData);\n            if (revision == null) {\n                LOGGER.debug(\"Performed resolved of module '{}' in repository '{}': not found\", dd.getDependencyRevisionId(), getName());\n                return null;\n            }\n            LOGGER.debug(\"Performed resolved of module '{}' in repository '{}': found\", dd.getDependencyRevisionId(), getName());\n            return new DefaultModuleVersionDescriptor(revision.getDescriptor(), isChanging(revision));\n        } catch (ParseException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }","id":78750,"modified_method":"public void getDependency(DependencyDescriptor dependencyDescriptor, BuildableModuleVersionDescriptor result) {\n        ResolveData resolveData = IvyContextualiser.getIvyContext().getResolveData();\n        try {\n            ResolvedModuleRevision revision = resolver.getDependency(dependencyDescriptor, resolveData);\n            if (revision == null) {\n                LOGGER.debug(\"Performed resolved of module '{}' in repository '{}': not found\", dependencyDescriptor.getDependencyRevisionId(), getName());\n                result.missing();\n            } else {\n                LOGGER.debug(\"Performed resolved of module '{}' in repository '{}': found\", dependencyDescriptor.getDependencyRevisionId(), getName());\n                result.resolved(revision.getDescriptor(), isChanging(revision));\n            }\n        } catch (ParseException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionDescriptor getDependency(final DependencyDescriptor dd) throws ModuleVersionResolveException {\n        return cacheLockingManager.longRunningOperation(String.format(\"Resolve %s using repository %s\", dd, getId()), new Factory<ModuleVersionDescriptor>() {\n            public ModuleVersionDescriptor create() {\n                return repository.getDependency(dd);\n            }\n        });\n    }","id":78751,"modified_method":"public void getDependency(final DependencyDescriptor dependencyDescriptor, final BuildableModuleVersionDescriptor result) {\n        cacheLockingManager.longRunningOperation(String.format(\"Resolve %s using repository %s\", dependencyDescriptor, getId()), new Runnable() {\n            public void run() {\n                repository.getDependency(dependencyDescriptor, result);\n            }\n        });\n    }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"public void download(Artifact artifact, BuildableArtifactResolveResult result) {\n        if (isLocal()) {\n            delegate.download(artifact, result);\n            return;\n        }\n\n        ArtifactAtRepositoryKey resolutionCacheIndexKey = new ArtifactAtRepositoryKey(delegate, artifact.getId());\n\n        // Look in the cache for this resolver\n        CachedExternalResource cached = artifactAtRepositoryCachedResolutionIndex.lookup(resolutionCacheIndexKey);\n\n        if (cached != null) {\n            ArtifactIdentifier artifactIdentifier = createArtifactIdentifier(artifact);\n            long age = timeProvider.getCurrentTime() - cached.getCachedAt();\n            if (cached.isMissing()) {\n                if (!cachePolicy.mustRefreshArtifact(artifactIdentifier, null, age)) {\n                    LOGGER.debug(\"Detected non-existence of artifact '{}' in resolver cache\", artifact.getId());\n                    result.notFound(artifact);\n                    return;\n                }\n            } else {\n                File cachedArtifactFile = cached.getCachedFile();\n                if (!cachePolicy.mustRefreshArtifact(artifactIdentifier, cachedArtifactFile, age)) {\n                    LOGGER.debug(\"Found artifact '{}' in resolver cache: {}\", artifact.getId(), cachedArtifactFile);\n                    result.resolved(cachedArtifactFile, cached.getExternalResourceMetaData());\n                    return;\n                }\n            }\n        }\n\n        delegate.download(artifact, result);\n        LOGGER.debug(\"Downloaded artifact '{}' from resolver: {}\", artifact.getId(), delegate);\n\n        if (result.getFailure() instanceof ArtifactNotFoundException) {\n            artifactAtRepositoryCachedResolutionIndex.storeMissing(resolutionCacheIndexKey);\n        } else {\n            artifactAtRepositoryCachedResolutionIndex.store(resolutionCacheIndexKey, result.getFile(), result.getExternalResourceMetaData());\n        }\n    }","id":78752,"modified_method":"public void download(Artifact artifact, BuildableArtifactResolveResult result) {\n        ArtifactAtRepositoryKey resolutionCacheIndexKey = new ArtifactAtRepositoryKey(delegate, artifact.getId());\n\n        // Look in the cache for this resolver\n        CachedExternalResource cached = artifactAtRepositoryCachedResolutionIndex.lookup(resolutionCacheIndexKey);\n\n        if (cached != null) {\n            ArtifactIdentifier artifactIdentifier = createArtifactIdentifier(artifact);\n            long age = timeProvider.getCurrentTime() - cached.getCachedAt();\n            if (cached.isMissing()) {\n                if (!cachePolicy.mustRefreshArtifact(artifactIdentifier, null, age)) {\n                    LOGGER.debug(\"Detected non-existence of artifact '{}' in resolver cache\", artifact.getId());\n                    result.notFound(artifact);\n                    return;\n                }\n            } else {\n                File cachedArtifactFile = cached.getCachedFile();\n                if (!cachePolicy.mustRefreshArtifact(artifactIdentifier, cachedArtifactFile, age)) {\n                    LOGGER.debug(\"Found artifact '{}' in resolver cache: {}\", artifact.getId(), cachedArtifactFile);\n                    result.resolved(cachedArtifactFile, cached.getExternalResourceMetaData());\n                    return;\n                }\n            }\n        }\n\n        delegate.download(artifact, result);\n        LOGGER.debug(\"Downloaded artifact '{}' from resolver: {}\", artifact.getId(), delegate);\n\n        if (result.getFailure() instanceof ArtifactNotFoundException) {\n            artifactAtRepositoryCachedResolutionIndex.storeMissing(resolutionCacheIndexKey);\n        } else {\n            artifactAtRepositoryCachedResolutionIndex.store(resolutionCacheIndexKey, result.getFile(), result.getExternalResourceMetaData());\n        }\n    }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"public CachedModuleLookup lookupModuleInCache(ModuleVersionRepository repository, DependencyDescriptor resolvedDependencyDescriptor) {\n        ModuleRevisionId resolvedModuleVersionId = resolvedDependencyDescriptor.getDependencyRevisionId();\n        ModuleVersionIdentifier moduleVersionIdentifier = createModuleVersionIdentifier(resolvedModuleVersionId);\n        ModuleDescriptorCache.CachedModuleDescriptor cachedModuleDescriptor = moduleDescriptorCache.getCachedModuleDescriptor(repository, resolvedModuleVersionId);\n        if (cachedModuleDescriptor == null) {\n            return notFound();\n        }\n        if (cachedModuleDescriptor.isMissing()) {\n            if (cachePolicy.mustRefreshModule(moduleVersionIdentifier, null, resolvedModuleVersionId, cachedModuleDescriptor.getAgeMillis())) {\n                LOGGER.debug(\"Cached meta-data for missing module is expired: will perform fresh resolve of '{}' in '{}'\", resolvedModuleVersionId, repository.getName());\n                return notFound();\n            }\n            LOGGER.debug(\"Detected non-existence of module '{}' in resolver cache '{}'\", resolvedModuleVersionId, repository.getName());\n            return found(null);\n        }\n        if (cachedModuleDescriptor.isChangingModule() || resolvedDependencyDescriptor.isChanging()) {\n            if (cachePolicy.mustRefreshChangingModule(moduleVersionIdentifier, cachedModuleDescriptor.getModuleVersion(), cachedModuleDescriptor.getAgeMillis())) {\n                expireArtifactsForChangingModule(repository, cachedModuleDescriptor.getModuleDescriptor());\n                LOGGER.debug(\"Cached meta-data for changing module is expired: will perform fresh resolve of '{}' in '{}'\", resolvedModuleVersionId, repository.getName());\n                return notFound();\n            }\n            LOGGER.debug(\"Found cached version of changing module '{}' in '{}'\", resolvedModuleVersionId, repository.getName());\n        } else {\n            if (cachePolicy.mustRefreshModule(moduleVersionIdentifier, cachedModuleDescriptor.getModuleVersion(), null, cachedModuleDescriptor.getAgeMillis())) {\n                LOGGER.debug(\"Cached meta-data for module must be refreshed: will perform fresh resolve of '{}' in '{}'\", resolvedModuleVersionId, repository.getName());\n                return notFound();\n            }\n        }\n\n        LOGGER.debug(\"Using cached module metadata for module '{}' in '{}'\", resolvedModuleVersionId, repository.getName());\n        // TODO:DAZ Could provide artifact metadata and file here from artifactFileStore (it's not needed currently)\n        ModuleVersionDescriptor cachedModule = new DefaultModuleVersionDescriptor(cachedModuleDescriptor.getModuleDescriptor(), cachedModuleDescriptor.isChangingModule());\n        return found(cachedModule);\n    }","id":78753,"modified_method":"public void lookupModuleInCache(ModuleVersionRepository repository, DependencyDescriptor resolvedDependencyDescriptor, BuildableModuleVersionDescriptor result) {\n        ModuleRevisionId resolvedModuleVersionId = resolvedDependencyDescriptor.getDependencyRevisionId();\n        ModuleVersionIdentifier moduleVersionIdentifier = createModuleVersionIdentifier(resolvedModuleVersionId);\n        ModuleDescriptorCache.CachedModuleDescriptor cachedModuleDescriptor = moduleDescriptorCache.getCachedModuleDescriptor(repository, resolvedModuleVersionId);\n        if (cachedModuleDescriptor == null) {\n            return;\n        }\n        if (cachedModuleDescriptor.isMissing()) {\n            if (cachePolicy.mustRefreshModule(moduleVersionIdentifier, null, resolvedModuleVersionId, cachedModuleDescriptor.getAgeMillis())) {\n                LOGGER.debug(\"Cached meta-data for missing module is expired: will perform fresh resolve of '{}' in '{}'\", resolvedModuleVersionId, repository.getName());\n                return;\n            }\n            LOGGER.debug(\"Detected non-existence of module '{}' in resolver cache '{}'\", resolvedModuleVersionId, repository.getName());\n            result.missing();\n            return;\n        }\n        if (cachedModuleDescriptor.isChangingModule() || resolvedDependencyDescriptor.isChanging()) {\n            if (cachePolicy.mustRefreshChangingModule(moduleVersionIdentifier, cachedModuleDescriptor.getModuleVersion(), cachedModuleDescriptor.getAgeMillis())) {\n                expireArtifactsForChangingModule(repository, cachedModuleDescriptor.getModuleDescriptor());\n                LOGGER.debug(\"Cached meta-data for changing module is expired: will perform fresh resolve of '{}' in '{}'\", resolvedModuleVersionId, repository.getName());\n                return;\n            }\n            LOGGER.debug(\"Found cached version of changing module '{}' in '{}'\", resolvedModuleVersionId, repository.getName());\n        } else {\n            if (cachePolicy.mustRefreshModule(moduleVersionIdentifier, cachedModuleDescriptor.getModuleVersion(), null, cachedModuleDescriptor.getAgeMillis())) {\n                LOGGER.debug(\"Cached meta-data for module must be refreshed: will perform fresh resolve of '{}' in '{}'\", resolvedModuleVersionId, repository.getName());\n                return;\n            }\n        }\n\n        LOGGER.debug(\"Using cached module metadata for module '{}' in '{}'\", resolvedModuleVersionId, repository.getName());\n        // TODO:DAZ Could provide artifact metadata and file here from artifactFileStore (it's not needed currently)\n        result.resolved(cachedModuleDescriptor.getModuleDescriptor(), cachedModuleDescriptor.isChangingModule());\n    }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionDescriptor getLocalDependency(DependencyDescriptor dd) throws ModuleVersionResolveException {\n        throw new UnsupportedOperationException();\n    }","id":78754,"modified_method":"public void getLocalDependency(DependencyDescriptor dependencyDescriptor, BuildableModuleVersionDescriptor result) {\n        throw new UnsupportedOperationException();\n    }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionDescriptor resolveModule(DependencyDescriptor resolvedDependencyDescriptor, DependencyDescriptor requestedDependencyDescriptor) {\n        ModuleVersionDescriptor module = delegate.getDependency(ForceChangeDependencyDescriptor.forceChangingFlag(resolvedDependencyDescriptor, true));\n\n        if (module == null) {\n            moduleDescriptorCache.cacheModuleDescriptor(delegate, resolvedDependencyDescriptor.getDependencyRevisionId(), null, requestedDependencyDescriptor.isChanging());\n        } else {\n            moduleResolutionCache.cacheModuleResolution(delegate, requestedDependencyDescriptor.getDependencyRevisionId(), module.getId());\n            moduleDescriptorCache.cacheModuleDescriptor(delegate, module.getId(), module.getDescriptor(), isChangingDependency(requestedDependencyDescriptor, module));\n        }\n        return module;\n    }","id":78755,"modified_method":"public void resolveModule(DependencyDescriptor resolvedDependencyDescriptor, DependencyDescriptor requestedDependencyDescriptor, BuildableModuleVersionDescriptor result) {\n        delegate.getDependency(ForceChangeDependencyDescriptor.forceChangingFlag(resolvedDependencyDescriptor, true), result);\n        if (result.getState() == BuildableModuleVersionDescriptor.State.Missing) {\n            moduleDescriptorCache.cacheModuleDescriptor(delegate, resolvedDependencyDescriptor.getDependencyRevisionId(), null, requestedDependencyDescriptor.isChanging());\n        } else if (result.getState() == BuildableModuleVersionDescriptor.State.Resolved) {\n            moduleResolutionCache.cacheModuleResolution(delegate, requestedDependencyDescriptor.getDependencyRevisionId(), result.getId());\n            moduleDescriptorCache.cacheModuleDescriptor(delegate, result.getId(), result.getDescriptor(), isChangingDependency(requestedDependencyDescriptor, result));\n        }\n    }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionDescriptor getDependency(DependencyDescriptor dd) {\n        if (isLocal()) {\n            final ModuleVersionDescriptor module = delegate.getDependency(dd);\n            if (module != null) {\n                moduleDescriptorCache.cacheModuleDescriptor(delegate, module.getId(), module.getDescriptor(), true);\n                moduleResolutionCache.cacheModuleResolution(delegate, dd.getDependencyRevisionId(), module.getId());\n            }\n            return module;\n        }\n        return findModule(dd);\n    }","id":78756,"modified_method":"public void getDependency(DependencyDescriptor dependencyDescriptor, BuildableModuleVersionDescriptor result) {\n        DependencyDescriptor resolvedDependencyDescriptor = maybeUseCachedDynamicVersion(delegate, dependencyDescriptor);\n        lookupModuleInCache(delegate, resolvedDependencyDescriptor, result);\n        if (result.getState() != BuildableModuleVersionDescriptor.State.Unknown) {\n            return;\n        }\n        resolveModule(resolvedDependencyDescriptor, dependencyDescriptor, result);\n    }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionDescriptor getLocalDependency(DependencyDescriptor dd) throws ModuleVersionResolveException {\n        throw new UnsupportedOperationException();\n    }","id":78757,"modified_method":"public void getLocalDependency(DependencyDescriptor dependencyDescriptor, BuildableModuleVersionDescriptor result) {\n        throw new UnsupportedOperationException();\n    }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionDescriptor getDependency(DependencyDescriptor dd) throws ModuleVersionResolveException {\n        return delegate.getDependency(dd);\n    }","id":78758,"modified_method":"public void getDependency(DependencyDescriptor dependencyDescriptor, BuildableModuleVersionDescriptor result) {\n        delegate.getDependency(dependencyDescriptor, result);\n    }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionDescriptor getDependency(DependencyDescriptor dd) {\n            throw new ModuleVersionResolveException(\"No cached version available for offline mode\");\n        }","id":78759,"modified_method":"public void getDependency(DependencyDescriptor dependencyDescriptor, BuildableModuleVersionDescriptor result) {\n            result.failed(new ModuleVersionResolveException(\"No cached version available for offline mode\"));\n        }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"private ModuleResolution findLatestModule(DependencyDescriptor dependencyDescriptor, Collection<Throwable> failures) {\n        boolean isStaticVersion = !settings.getVersionMatcher().isDynamic(dependencyDescriptor.getDependencyRevisionId());\n        \n        ModuleResolution best = null;\n        for (ModuleVersionRepository repository : moduleVersionRepositories) {\n            try {\n                ModuleVersionDescriptor module = repository.getDependency(dependencyDescriptor);\n                if (module != null) {\n                    ModuleResolution moduleResolution = new ModuleResolution(repository, module);\n                    if (isStaticVersion && !moduleResolution.isGeneratedModuleDescriptor()) {\n                        return moduleResolution;\n                    }\n                    best = chooseBest(best, moduleResolution);\n                }\n            } catch (Throwable e) {\n                failures.add(e);\n            }\n        }\n\n        return best;\n    }","id":78760,"modified_method":"private ModuleResolution findLatestModule(DependencyDescriptor dependencyDescriptor, Collection<Throwable> failures) {\n        boolean isStaticVersion = !settings.getVersionMatcher().isDynamic(dependencyDescriptor.getDependencyRevisionId());\n        \n        ModuleResolution best = null;\n        for (ModuleVersionRepository repository : moduleVersionRepositories) {\n            BuildableModuleVersionDescriptor module = new DefaultBuildableModuleVersionDescriptor();\n            try {\n                repository.getDependency(dependencyDescriptor, module);\n            } catch (Throwable e) {\n                failures.add(e);\n            }\n            switch (module.getState()) {\n                case Missing:\n                case Unknown:\n                    break;\n                case Resolved:\n                    ModuleResolution moduleResolution = new ModuleResolution(repository, module);\n                    if (isStaticVersion && !moduleResolution.isGeneratedModuleDescriptor()) {\n                        return moduleResolution;\n                    }\n                    best = chooseBest(best, moduleResolution);\n                    break;\n                case Failed:\n                    failures.add(module.getFailure());\n                    break;\n                default:\n                    throw new IllegalStateException(\"Unexpected state for resolution: \" + module.getState());\n            }\n        }\n\n        return best;\n    }","commit_id":"bf10a557e5b9c7eda20794667877ed6bb4ce0958","url":"https://github.com/gradle/gradle"},{"original_method":"private RelationshipRecord readRecord( ByteBuffer buffer, long id )\n    {\n        RelationshipRecord record;\n\n        long inUseByte = buffer.get();\n\n        boolean inUse = (inUseByte & 0x1) == Record.IN_USE.intValue();\n        if ( inUse )\n        {\n            long firstNode = LegacyStore.getUnsignedInt( buffer );\n            long firstNodeMod = (inUseByte & 0xEL) << 31;\n\n            long secondNode = LegacyStore.getUnsignedInt( buffer );\n\n            // [ xxx,    ][    ,    ][    ,    ][    ,    ] second node high order bits,     0x70000000\n            // [    ,xxx ][    ,    ][    ,    ][    ,    ] first prev rel high order bits,  0xE000000\n            // [    ,   x][xx  ,    ][    ,    ][    ,    ] first next rel high order bits,  0x1C00000\n            // [    ,    ][  xx,x   ][    ,    ][    ,    ] second prev rel high order bits, 0x380000\n            // [    ,    ][    , xxx][    ,    ][    ,    ] second next rel high order bits, 0x70000\n            // [    ,    ][    ,    ][xxxx,xxxx][xxxx,xxxx] type\n            long typeInt = buffer.getInt();\n            long secondNodeMod = (typeInt & 0x70000000L) << 4;\n            int type = (int) (typeInt & 0xFFFF);\n\n            record = new RelationshipRecord( id,\n                    LegacyStore.longFromIntAndMod( firstNode, firstNodeMod ),\n                    LegacyStore.longFromIntAndMod( secondNode, secondNodeMod ), type );\n            record.setInUse( inUse );\n\n            long firstPrevRel = LegacyStore.getUnsignedInt( buffer );\n            long firstPrevRelMod = (typeInt & 0xE000000L) << 7;\n            record.setFirstPrevRel( LegacyStore.longFromIntAndMod( firstPrevRel, firstPrevRelMod ) );\n\n            long firstNextRel = LegacyStore.getUnsignedInt( buffer );\n            long firstNextRelMod = (typeInt & 0x1C00000L) << 10;\n            record.setFirstNextRel( LegacyStore.longFromIntAndMod( firstNextRel, firstNextRelMod ) );\n\n            long secondPrevRel = LegacyStore.getUnsignedInt( buffer );\n            long secondPrevRelMod = (typeInt & 0x380000L) << 13;\n            record.setSecondPrevRel( LegacyStore.longFromIntAndMod( secondPrevRel, secondPrevRelMod ) );\n\n            long secondNextRel = LegacyStore.getUnsignedInt( buffer );\n            long secondNextRelMod = (typeInt & 0x70000L) << 16;\n            record.setSecondNextRel( LegacyStore.longFromIntAndMod( secondNextRel, secondNextRelMod ) );\n\n            long nextProp = LegacyStore.getUnsignedInt( buffer );\n            long nextPropMod = (inUseByte & 0xF0L) << 28;\n\n            record.setNextProp( LegacyStore.longFromIntAndMod( nextProp, nextPropMod ) );\n        }\n        else\n        {\n            record = new RelationshipRecord( id, -1, -1, -1 );\n            record.setInUse( false );\n        }\n        return record;\n    }","id":78761,"modified_method":"private void readRecord( ByteBuffer buffer, long id, ReusableRelationship rel)\n    {\n        long inUseByte = buffer.get();\n\n        boolean inUse = (inUseByte & 0x1) == Record.IN_USE.intValue();\n        if ( inUse )\n        {\n            long firstNode = LegacyStore.getUnsignedInt( buffer );\n            long firstNodeMod = (inUseByte & 0xEL) << 31;\n\n            long secondNode = LegacyStore.getUnsignedInt( buffer );\n\n            // [ xxx,    ][    ,    ][    ,    ][    ,    ] second node high order bits,     0x70000000\n            // [    ,xxx ][    ,    ][    ,    ][    ,    ] first prev rel high order bits,  0xE000000\n            // [    ,   x][xx  ,    ][    ,    ][    ,    ] first next rel high order bits,  0x1C00000\n            // [    ,    ][  xx,x   ][    ,    ][    ,    ] second prev rel high order bits, 0x380000\n            // [    ,    ][    , xxx][    ,    ][    ,    ] second next rel high order bits, 0x70000\n            // [    ,    ][    ,    ][xxxx,xxxx][xxxx,xxxx] type\n            long typeInt = buffer.getInt();\n            long secondNodeMod = (typeInt & 0x70000000L) << 4;\n            int type = (int) (typeInt & 0xFFFF);\n\n            firstNode = LegacyStore.longFromIntAndMod( firstNode, firstNodeMod );\n            secondNode = LegacyStore.longFromIntAndMod( secondNode, secondNodeMod );\n\n            long firstPrevRel = LegacyStore.getUnsignedInt( buffer );\n            long firstPrevRelMod = (typeInt & 0xE000000L) << 7;\n            firstPrevRel =  LegacyStore.longFromIntAndMod( firstPrevRel, firstPrevRelMod );\n\n            long firstNextRel = LegacyStore.getUnsignedInt( buffer );\n            long firstNextRelMod = (typeInt & 0x1C00000L) << 10;\n            firstNextRel = LegacyStore.longFromIntAndMod( firstNextRel, firstNextRelMod );\n\n            long secondPrevRel = LegacyStore.getUnsignedInt( buffer );\n            long secondPrevRelMod = (typeInt & 0x380000L) << 13;\n            secondPrevRel = LegacyStore.longFromIntAndMod( secondPrevRel, secondPrevRelMod );\n\n            long secondNextRel = LegacyStore.getUnsignedInt( buffer );\n            long secondNextRelMod = (typeInt & 0x70000L) << 16;\n            secondNextRel = LegacyStore.longFromIntAndMod( secondNextRel, secondNextRelMod );\n\n            long nextProp = LegacyStore.getUnsignedInt( buffer );\n            long nextPropMod = (inUseByte & 0xF0L) << 28;\n            nextProp = LegacyStore.longFromIntAndMod( nextProp, nextPropMod );\n\n            rel.reset( id, true, firstNode, secondNode, type,\n                       firstPrevRel, firstNextRel, secondNextRel, secondPrevRel, nextProp );\n        }\n        else\n        {\n            rel.reset( id, false, -1, -1, -1, -1, -1, -1, -1, -1 );\n        }\n    }","commit_id":"cc949930503e250479d2f08aedaeb919b143f7b8","url":"https://github.com/neo4j/neo4j"},{"original_method":"public boolean isComplete()\n    {\n        for(ChainEntry entry = head; entry != null; entry = entry.next)\n            if(entry.isLast) return true;\n        return false;\n    }","id":78762,"modified_method":"public boolean isComplete()\n    {\n        return missing == 0;\n    }","commit_id":"cc949930503e250479d2f08aedaeb919b143f7b8","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int size()\n    {\n        return chainIndex.size();\n    }","id":78763,"modified_method":"public int size()\n    {\n        return records.size();\n    }","commit_id":"cc949930503e250479d2f08aedaeb919b143f7b8","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void append( RelationshipRecord record, long prevRel, long nextRel )\n    {\n        boolean isFirst = prevRel == Record.NO_PREV_RELATIONSHIP.intValue();\n        boolean isLast = nextRel == Record.NO_NEXT_RELATIONSHIP.intValue();\n\n        ChainEntry entry = new ChainEntry( record, isLast, chainIndex.get( nextRel ) );\n        chainIndex.put( record.getId(), entry );\n\n        if(isFirst)\n        {\n            head = entry;\n        }\n        else\n        {\n            ChainEntry prevInChain = chainIndex.get( prevRel );\n            if(prevInChain != null)\n            {\n                prevInChain.next = entry;\n\n            }\n        }\n    }","id":78764,"modified_method":"public void append( RelationshipRecord record, long prevRel, long nextRel )\n    {\n        if( records.containsKey( prevRel ))\n        {\n            missing--;\n        }\n        else if( !(prevRel == Record.NO_PREV_RELATIONSHIP.intValue()) )\n        {\n            missing++;\n        }\n\n        if( records.containsKey( nextRel ))\n        {\n            missing--;\n        }\n        else if( !(nextRel == Record.NO_NEXT_RELATIONSHIP.intValue()) )\n        {\n            missing++;\n        }\n\n        records.put( record.getId(), record );\n    }","commit_id":"cc949930503e250479d2f08aedaeb919b143f7b8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldHandleArbitraryOrdering() throws Exception\n    {\n        // Given\n        RelChainBuilder chain = new RelChainBuilder( 1l );\n\n        // When\n        chain.append( new RelationshipRecord( 4l ), 3l, Record.NO_NEXT_RELATIONSHIP.intValue() );\n        chain.append( new RelationshipRecord( 3l ), 2l, 4l );\n        chain.append( new RelationshipRecord( 2l ), Record.NO_PREV_RELATIONSHIP.intValue(), 3l );\n\n        // Then\n        assertTrue( chain.isComplete() );\n        assertThat( chain.size(), equalTo(3));\n    }","id":78765,"modified_method":"@Test\n    public void shouldHandleArbitraryOrdering() throws Exception\n    {\n        // Given\n        RelChainBuilder chain = new RelChainBuilder( 1l );\n\n        // When\n        chain.append( new RelationshipRecord( 2l ), 1l, 3l );\n        chain.append( new RelationshipRecord( 4l ), 3l, Record.NO_NEXT_RELATIONSHIP.intValue() );\n        chain.append( new RelationshipRecord( 3l ), 2l, 4l );\n        chain.append( new RelationshipRecord( 1l ), Record.NO_PREV_RELATIONSHIP.intValue(), 2l );\n\n        // Then\n        assertTrue( chain.isComplete() );\n        assertThat( chain.size(), equalTo(4));\n    }","commit_id":"cc949930503e250479d2f08aedaeb919b143f7b8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Map<Integer, Relationships> splitUp( long nodeId, RelChainBuilder records )\n    {\n        Map<Integer, Relationships> result = new HashMap<>();\n        for ( RelationshipRecord record : records )\n        {\n            Integer type = record.getType();\n            Relationships relationships = result.get( type );\n            if ( relationships == null )\n            {\n                relationships = new Relationships( nodeId );\n                result.put( type, relationships );\n            }\n            relationships.add( record );\n        }\n        return result;\n    }","id":78766,"modified_method":"private Map<Integer, Relationships> splitUp( final long nodeId, RelChainBuilder records )\n    {\n        final Map<Integer, Relationships> result = new HashMap<>();\n        records.accept( new Visitor<RelationshipRecord, RuntimeException>()\n        {\n            @Override\n            public boolean visit( RelationshipRecord record ) throws RuntimeException\n            {\n                Integer type = record.getType();\n                Relationships relationships = result.get( type );\n                if ( relationships == null )\n                {\n                    relationships = new Relationships( nodeId );\n                    result.put( type, relationships );\n                }\n                relationships.add( record );\n                return false;\n            }\n        } );\n        return result;\n    }","commit_id":"cc949930503e250479d2f08aedaeb919b143f7b8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void migrateNormalNode( NodeStore nodeStore, RelationshipStore relationshipStore,\n                                    RelChainBuilder relationships ) throws IOException\n    {\n        /* Add node record\n         * Add/update all relationship records */\n        nodeStore.forceUpdateRecord( nodeReader.readNodeStore( relationships.nodeId() ) );\n        int i = 0;\n        for ( RelationshipRecord record : relationships )\n        {\n            if ( i == 0 )\n            {\n                setDegree( relationships.nodeId(), record, relationships.size() );\n            }\n            applyChangesToRecord( relationships.nodeId(), record, relationshipStore );\n            relationshipStore.forceUpdateRecord( record );\n            i++;\n        }\n    }","id":78767,"modified_method":"private void migrateNormalNode( NodeStore nodeStore,\n                                    final RelationshipStore relationshipStore,\n                                    final RelChainBuilder relationships ) throws IOException\n    {\n        /* Add node record\n         * Add/update all relationship records */\n        nodeStore.forceUpdateRecord( nodeReader.readNodeStore( relationships.nodeId() ) );\n\n        relationships.accept( new Visitor<RelationshipRecord, RuntimeException>() {\n\n            private int i = 0;\n\n            @Override\n            public boolean visit( RelationshipRecord record ) throws RuntimeException\n            {\n                if ( i == 0 )\n                {\n                    setDegree( relationships.nodeId(), record, relationships.size() );\n                }\n                applyChangesToRecord( relationships.nodeId(), record, relationshipStore );\n                relationshipStore.forceUpdateRecord( record );\n                i++;\n                return false;\n            }\n        });\n    }","commit_id":"cc949930503e250479d2f08aedaeb919b143f7b8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void reportProgress( long id )\n        {\n            int newPercent = totalEntities == 0 ? 100 : (int) ((id+1) * 100 / totalEntities);\n            if ( newPercent > percentComplete )\n            {\n                percentComplete = newPercent;\n                progressMonitor.percentComplete( percentComplete );\n            }\n        }","id":78768,"modified_method":"private void reportProgress( long id )\n        {\n            int newPercent = totalEntities == 0 ? 100 : (int) (id * 100 / (totalEntities));\n            while( newPercent > percentComplete )\n            {\n                percentComplete++;\n                progressMonitor.percentComplete( percentComplete );\n            }\n        }","commit_id":"cc949930503e250479d2f08aedaeb919b143f7b8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void migrateNodesAndRelationships() throws IOException\n        {\n            /* For each node\n             *   load the full relationship chain into memory\n             *   if ( more than THRESHOLD relationships )\n             *      store in dense node way\n             *   else\n             *      store in normal way\n             *\n             * Keep ids */\n\n            final NodeStore nodeStore = neoStore.getNodeStore();\n            final RelationshipStore relationshipStore = neoStore.getRelationshipStore();\n            final RelationshipGroupStore relGroupStore = neoStore.getRelationshipGroupStore();\n            final LegacyNodeStoreReader nodeReader = legacyStore.getNodeStoreReader();\n            final LegacyRelationshipStoreReader relReader = legacyStore.getRelStoreReader();\n            nodeStore.setHighId( nodeReader.getMaxId() );\n            relationshipStore.setHighId( relReader.getMaxId() );\n\n            final ArrayBlockingQueue<RelChainBuilder> chainsToWrite = new ArrayBlockingQueue<>( 24 );\n            final AtomicReference<Throwable> writerException = new AtomicReference<>();\n\n            Thread writerThread = new RelationshipWriter( chainsToWrite, neoStore.getDenseNodeThreshold(), nodeStore,\n                    relationshipStore, relGroupStore, nodeReader, writerException );\n            writerThread.start();\n\n            try\n            {\n\n                final Map<Long, RelChainBuilder> relChains = new HashMap<>();\n                relReader.accept( new LegacyRelationshipStoreReader.Visitor()\n                {\n                    @Override\n                    public void visit( long id, RelationshipRecord record )\n                    {\n                        reportProgress( id );\n                        if ( record.inUse() )\n                        {\n                            appendToRelChain( record.getFirstNode(), record.getFirstPrevRel(),\n                                    record.getFirstNextRel(), record );\n                            appendToRelChain( record.getSecondNode(), record.getSecondPrevRel(),\n                                    record.getSecondNextRel(), record );\n                        }\n                    }\n\n                    private void appendToRelChain( long nodeId, long prevRel, long nextRel, RelationshipRecord record )\n                    {\n                        RelChainBuilder chain = relChains.get( nodeId );\n                        if ( chain == null )\n                        {\n                            chain = new RelChainBuilder( nodeId );\n                            relChains.put( nodeId, chain );\n                        }\n\n                        chain.append( record, prevRel, nextRel );\n\n                        if ( chain.isComplete() )\n                        {\n                            assertNoWriterException( writerException );\n                            try\n                            {\n                                chainsToWrite.put( relChains.remove( nodeId ) );\n                            }\n                            catch ( InterruptedException e )\n                            {\n                                Thread.interrupted();\n                                throw new RuntimeException( \"Interrupted while reading relationships.\", e );\n                            }\n                        }\n                    }\n                } );\n\n                try\n                {\n                    chainsToWrite.put( new RelChainBuilder( -1 ) );\n                    writerThread.join();\n                    assertNoWriterException( writerException );\n                }\n                catch ( InterruptedException e )\n                {\n                    throw new RuntimeException( \"Interrupted.\", e);\n                }\n\n                legacyStore.copyNodeStoreIdFile( neoStore );\n                legacyStore.copyRelationshipStoreIdFile( neoStore );\n\n                // Migrate nodes with no relationships\n                nodeReader.accept(new LegacyNodeStoreReader.Visitor()\n                {\n                    @Override\n                    public void visit( NodeRecord record )\n                    {\n                        if(record.inUse() && record.getNextRel() == Record.NO_NEXT_RELATIONSHIP.intValue())\n                        {\n                            nodeStore.forceUpdateRecord( record );\n                        }\n                    }\n                });\n            }\n            finally\n            {\n                nodeReader.close();\n                relReader.close();\n            }\n        }","id":78769,"modified_method":"private void migrateNodesAndRelationships() throws IOException\n        {\n             /* For each node\n             *   load the full relationship chain into memory\n             *   if ( more than THRESHOLD relationships )\n             *      store in dense node way\n             *   else\n             *      store in normal way\n             *\n             * Keep ids */\n\n            final NodeStore nodeStore = neoStore.getNodeStore();\n            final RelationshipStore relationshipStore = neoStore.getRelationshipStore();\n            final RelationshipGroupStore relGroupStore = neoStore.getRelationshipGroupStore();\n            final LegacyNodeStoreReader nodeReader = legacyStore.getNodeStoreReader();\n            final LegacyRelationshipStoreReader relReader = legacyStore.getRelStoreReader();\n            nodeStore.setHighId( nodeReader.getMaxId() );\n            relationshipStore.setHighId( relReader.getMaxId() );\n\n            final ArrayBlockingQueue<RelChainBuilder> chainsToWrite = new ArrayBlockingQueue<>( 1024 );\n            final AtomicReference<Throwable> writerException = new AtomicReference<>();\n\n            Thread writerThread = new RelationshipWriter( chainsToWrite, neoStore.getDenseNodeThreshold(), nodeStore,\n                    relationshipStore, relGroupStore, nodeReader, writerException );\n            writerThread.start();\n\n            try\n            {\n                // Determined through testing to be a reasonable weigh-off between risk/benefit\n                final int maxSimultaneousNodes = (int) (120 * (Runtime.getRuntime().totalMemory() / (1024 * 1024)));\n                final AtomicBoolean morePassesRequired = new AtomicBoolean(false);\n                final AtomicLong firstRelationshipRequiringANewPass = new AtomicLong(0l);\n                final PrimitiveLongObjectMap<RelChainBuilder> relChains = Primitive.longObjectMap();\n                long numberOfPasses = 1;\n                do\n                {\n                    percentComplete = 0;\n                    if(morePassesRequired.get())\n                    {\n                        if(numberOfPasses == 1)\n                        {\n                            System.out.println(\"\\nNote: Was not able to do single-pass upgrade due to highly \" +\n                                    \"dispersed relationships across the store. Will need to perform multi-pass upgrade.\\n\" +\n                                    \"Note: Dotted line shows progress for each pass, the X in the dotted line shows total progress.\\n\");\n                        }\n                        else\n                        {\n                            System.out.println( \" [MultiPass Upgrade] Finished pass #\" + (numberOfPasses-1) );\n                        }\n                        numberOfPasses++;\n                    }\n\n                    relReader.accept( firstRelationshipRequiringANewPass.get(),\n                            new Visitor<ReusableRelationship, RuntimeException>()\n                    {\n                        private final boolean isMultiPass = morePassesRequired.getAndSet( false );\n\n                        @Override\n                        public boolean visit( ReusableRelationship rel )\n                        {\n                            reportProgress( rel.id() );\n                            if ( rel.inUse() )\n                            {\n                                if(appendToRelChain( rel.getFirstNode(), rel.getFirstPrevRel(),\n                                        rel.getFirstNextRel(), rel ))\n                                {\n                                    return true;\n                                }\n\n                                if(appendToRelChain( rel.getSecondNode(), rel.getSecondPrevRel(),\n                                        rel.getSecondNextRel(), rel ))\n                                {\n                                    return true;\n                                }\n                            }\n                            return false;\n                        }\n\n                        private boolean appendToRelChain( long nodeId, long prevRel, long nextRel,\n                                                       ReusableRelationship rel )\n                        {\n                            RelChainBuilder chain = relChains.get( nodeId );\n\n                            if ( chain == null )\n                            {\n                                if ( morePassesRequired.get() || (isMultiPass && nodeStore.inUse( nodeId )) )\n                                {\n                                    // Handled in a previous pass, ignore.\n                                    return false;\n                                }\n\n                                if ( relChains.size() >= maxSimultaneousNodes )\n                                {\n                                    morePassesRequired.set( true );\n                                    firstRelationshipRequiringANewPass.set( rel.id() );\n                                    System.out.print( \"X\" );\n                                    return false;\n                                }\n\n                                chain = new RelChainBuilder( nodeId );\n                                relChains.put( nodeId, chain );\n                            }\n\n                            chain.append( rel.createRecord(), prevRel, nextRel );\n\n                            if ( chain.isComplete() )\n                            {\n                                assertNoWriterException( writerException );\n                                try\n                                {\n                                    RelChainBuilder remove = relChains.remove( nodeId );\n                                    chainsToWrite.put( remove );\n                                }\n                                catch ( InterruptedException e )\n                                {\n                                    Thread.interrupted();\n                                    throw new RuntimeException( \"Interrupted while reading relationships.\", e );\n                                }\n                            }\n\n                            return false;\n                        }\n                    } );\n\n                } while(morePassesRequired.get());\n\n                try\n                {\n                    chainsToWrite.put( new RelChainBuilder( -1 ) );\n                    writerThread.join();\n                    assertNoWriterException( writerException );\n                }\n                catch ( InterruptedException e )\n                {\n                    throw new RuntimeException( \"Interrupted.\", e);\n                }\n\n                legacyStore.copyNodeStoreIdFile( neoStore );\n                legacyStore.copyRelationshipStoreIdFile( neoStore );\n\n                // Migrate nodes with no relationships\n                nodeReader.accept(new LegacyNodeStoreReader.Visitor()\n                {\n                    @Override\n                    public void visit( NodeRecord record )\n                    {\n                        if(record.inUse() && record.getNextRel() == Record.NO_NEXT_RELATIONSHIP.intValue())\n                        {\n                            nodeStore.forceUpdateRecord( record );\n                        }\n                    }\n                });\n            }\n            finally\n            {\n                nodeReader.close();\n                relReader.close();\n            }\n        }","commit_id":"cc949930503e250479d2f08aedaeb919b143f7b8","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void setBoxingState(TypedDeclaration declaration, TypedDeclaration refinedDeclaration) {\n        ProducedType type = declaration.getType();\n        if(type == null){\n            // an error must have already been reported\n            return;\n        }\n        // inherit underlying type constraints\n        if(refinedDeclaration != declaration && type.getUnderlyingType() == null)\n            type.setUnderlyingType(refinedDeclaration.getType().getUnderlyingType());\n        \n        // abort if our boxing state has already been set\n        if(declaration.getUnboxed() != null)\n            return;\n        \n        // functional parameter return values are always boxed\n        if(declaration instanceof FunctionalParameter){\n            declaration.setUnboxed(false);\n            return;\n        }\n        \n        if(refinedDeclaration != declaration){\n            // make sure refined declarations have already been set\n            if(refinedDeclaration.getUnboxed() == null)\n                setBoxingState(refinedDeclaration, refinedDeclaration);\n            // inherit\n            declaration.setUnboxed(refinedDeclaration.getUnboxed());\n        }else if((isCeylonBasicType(type) || Decl.isUnboxedVoid(declaration))\n           && !(refinedDeclaration.getTypeDeclaration() instanceof TypeParameter)\n           && !(refinedDeclaration.getContainer() instanceof FunctionalParameter)\n           && !(refinedDeclaration instanceof Functional && Decl.isMpl((Functional)refinedDeclaration))){\n            declaration.setUnboxed(true);\n        }else\n            declaration.setUnboxed(false);\n    }","id":78770,"modified_method":"private void setBoxingState(TypedDeclaration declaration, TypedDeclaration refinedDeclaration) {\n        ProducedType type = declaration.getType();\n        if(type == null){\n            // an error must have already been reported\n            return;\n        }\n        // inherit underlying type constraints\n        if(refinedDeclaration != declaration && type.getUnderlyingType() == null)\n            type.setUnderlyingType(refinedDeclaration.getType().getUnderlyingType());\n        \n        // abort if our boxing state has already been set\n        if(declaration.getUnboxed() != null)\n            return;\n        \n        // functional parameter return values are always boxed\n        if(declaration instanceof FunctionalParameter){\n            declaration.setUnboxed(false);\n            return;\n        }\n        \n        if(refinedDeclaration != declaration){\n            // make sure refined declarations have already been set\n            if(refinedDeclaration.getUnboxed() == null)\n                setBoxingState(refinedDeclaration, refinedDeclaration);\n            // inherit\n            declaration.setUnboxed(refinedDeclaration.getUnboxed());\n        } else if (declaration instanceof Method\n                && CodegenUtil.isVoid(declaration.getType())\n                && Strategy.useBoxedVoid((Method)declaration)\n                && !(refinedDeclaration.getTypeDeclaration() instanceof TypeParameter)\n                && !(refinedDeclaration.getContainer() instanceof FunctionalParameter)\n                && !(refinedDeclaration instanceof Functional && Decl.isMpl((Functional)refinedDeclaration))){\n            declaration.setUnboxed(false);\n        } else if((isCeylonBasicType(type) || Decl.isUnboxedVoid(declaration))\n           && !(refinedDeclaration.getTypeDeclaration() instanceof TypeParameter)\n           && !(refinedDeclaration.getContainer() instanceof FunctionalParameter)\n           && !(refinedDeclaration instanceof Functional && Decl.isMpl((Functional)refinedDeclaration))){\n            declaration.setUnboxed(true);\n        } else {\n            declaration.setUnboxed(false);\n        }\n    }","commit_id":"6ef6b17dfcfe0a3f4e610ab02fd5410e2a1b8cf1","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void setBoxingState(TypedDeclaration declaration, TypedDeclaration refinedDeclaration) {\n        if(declaration.getType() == null){\n            // an error must have already been reported\n            return;\n        }\n        if((transformer.isCeylonBasicType(declaration.getType()) \n            || transformer.isCeylonArray(declaration.getType()))\n           && !(refinedDeclaration.getTypeDeclaration() instanceof TypeParameter)){\n            // propagate to decl if needed\n            if(refinedDeclaration != declaration)\n                declaration.setUnboxed(refinedDeclaration.getUnboxed());\n            else\n                declaration.setUnboxed(true);\n        }\n    }","id":78771,"modified_method":"private void setBoxingState(TypedDeclaration declaration, TypedDeclaration refinedDeclaration) {\n        if(declaration.getType() == null){\n            // an error must have already been reported\n            return;\n        }\n        // abort if our boxing state has already been set\n        if(declaration.getUnboxed() != null)\n            return;\n        if((transformer.isCeylonBasicType(declaration.getType()) \n            || transformer.isCeylonArray(declaration.getType()))\n           && !(refinedDeclaration.getTypeDeclaration() instanceof TypeParameter)){\n            // propagate to decl if needed\n            if(refinedDeclaration != declaration){\n                // make sure refined declarations have already been set\n                if(refinedDeclaration.getUnboxed() == null)\n                    setBoxingState(refinedDeclaration, refinedDeclaration);\n                // inherit\n                declaration.setUnboxed(refinedDeclaration.getUnboxed());\n            }else\n                declaration.setUnboxed(true);\n        }else\n            declaration.setUnboxed(false);\n    }","commit_id":"79d7cdbcfe7dc8d034caad5c0bc5b5edaa194535","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCExpression build() {\n        boolean prevFnCall = gen().expressionGen().isWithinInvocation();\n        gen().expressionGen().setWithinInvocation(true);\n        try {\n            JCExpression invocation = makeInvocation();\n            invocation = gen().boxUnboxIfNecessary(invocation, !unboxed, \n                    returnType, boxingStrategy);\n            return invocation;\n        } finally {\n            gen().expressionGen().setWithinInvocation(prevFnCall);\n        }\n    }","id":78772,"modified_method":"public JCExpression build() {\n        boolean prevFnCall = gen().expressionGen().isWithinInvocation();\n        gen().expressionGen().setWithinInvocation(true);\n        try {\n            JCExpression invocation = makeInvocation();\n            invocation = gen().expressionGen().applyErasureAndBoxing(invocation, returnType, \n                    !unboxed, boxingStrategy, returnType);\n            return invocation;\n        } finally {\n            gen().expressionGen().setWithinInvocation(prevFnCall);\n        }\n    }","commit_id":"a7dfb0d5d378cf9efef987cde8ed15e9330166fe","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected JCExpression transformInvocation(JCExpression primaryExpr, String selector) {\n        JCExpression actualPrimExpr = null;\n        if (primary instanceof Tree.QualifiedTypeExpression\n                && ((Tree.QualifiedTypeExpression)primary).getPrimary() instanceof Tree.BaseTypeExpression) {\n            actualPrimExpr = gen().makeSelect(primaryExpr, \"this\");\n        } else {\n            actualPrimExpr = primaryExpr;\n        }\n        if (vars != null && !vars.isEmpty() \n                && primaryExpr != null \n                && selector != null) {\n            // Prepare the first argument holding the primary for the call\n            JCExpression callVarExpr = gen().makeUnquotedIdent(callVarName);\n            ProducedType type = ((Tree.QualifiedMemberOrTypeExpression)primary).getTarget().getQualifyingType();\n            JCVariableDecl callVar = gen().makeVar(callVarName, gen().makeJavaType(type, AbstractTransformer.NO_PRIMITIVES), actualPrimExpr);\n            vars.prepend(callVar);\n            actualPrimExpr = callVarExpr;\n        }\n        \n        JCExpression resultExpr;\n        if (primary instanceof Tree.BaseTypeExpression) {\n            ProducedType classType = (ProducedType)((Tree.BaseTypeExpression)primary).getTarget();\n            resultExpr = gen().make().NewClass(null, null, gen().makeJavaType(classType, AbstractTransformer.CLASS_NEW), args.toList(), null);\n        } else if (primary instanceof Tree.QualifiedTypeExpression) {\n            resultExpr = gen().make().NewClass(actualPrimExpr, null, gen().makeQuotedIdent(selector), args.toList(), null);\n        } else {\n            Declaration decl = ((Tree.StaticMemberOrTypeExpression)primary).getDeclaration();\n            if (decl instanceof FunctionalParameter) {\n                if (primaryExpr != null) {\n                    actualPrimExpr = gen().makeQualIdent(primaryExpr, decl.getName());\n                } else {\n                    actualPrimExpr = gen().makeQuotedIdent(decl.getName());\n                }\n                selector = \"call\";\n            }\n            resultExpr = gen().make().Apply(typeArgs, gen().makeQuotedQualIdent(actualPrimExpr, selector), args.toList());\n        }\n\n        if (vars != null && !vars.isEmpty()) {\n            if (gen().isVoid(returnType)) {\n                // void methods get wrapped like (let $arg$1=expr, $arg$0=expr in call($arg$0, $arg$1); null)\n                return gen().make().LetExpr(vars.toList(), List.<JCStatement>of(gen().make().Exec(resultExpr)), gen().makeNull());\n            } else {\n                // all other methods like (let $arg$1=expr, $arg$0=expr in call($arg$0, $arg$1))\n                return gen().make().LetExpr(vars.toList(), resultExpr);\n            }\n        } else {\n            return resultExpr;\n        }\n    }","id":78773,"modified_method":"protected JCExpression transformInvocation(JCExpression primaryExpr, String selector) {\n        JCExpression actualPrimExpr = null;\n        if (primary instanceof Tree.QualifiedTypeExpression\n                && ((Tree.QualifiedTypeExpression)primary).getPrimary() instanceof Tree.BaseTypeExpression) {\n            actualPrimExpr = gen().makeSelect(primaryExpr, \"this\");\n        } else {\n            actualPrimExpr = primaryExpr;\n        }\n        if (vars != null && !vars.isEmpty() \n                && primaryExpr != null \n                && selector != null) {\n            // Prepare the first argument holding the primary for the call\n            JCExpression callVarExpr = gen().makeUnquotedIdent(callVarName);\n            ProducedType type = ((Tree.QualifiedMemberOrTypeExpression)primary).getTarget().getQualifyingType();\n            JCVariableDecl callVar = gen().makeVar(callVarName, gen().makeJavaType(type, AbstractTransformer.NO_PRIMITIVES), actualPrimExpr);\n            vars.prepend(callVar);\n            actualPrimExpr = callVarExpr;\n        }\n        \n        JCExpression resultExpr;\n        if (primary instanceof Tree.BaseTypeExpression) {\n            ProducedType classType = (ProducedType)((Tree.BaseTypeExpression)primary).getTarget();\n            resultExpr = gen().make().NewClass(null, null, gen().makeJavaType(classType, AbstractTransformer.CLASS_NEW), args.toList(), null);\n        } else if (primary instanceof Tree.QualifiedTypeExpression) {\n            resultExpr = gen().make().NewClass(actualPrimExpr, null, gen().makeQuotedIdent(selector), args.toList(), null);\n        } else {\n            if (primaryDeclaration instanceof FunctionalParameter) {\n                if (primaryExpr != null) {\n                    actualPrimExpr = gen().makeQualIdent(primaryExpr, primaryDeclaration.getName());\n                } else {\n                    actualPrimExpr = gen().makeQuotedIdent(primaryDeclaration.getName());\n                }\n                selector = \"call\";\n            }\n            resultExpr = gen().make().Apply(typeArgs, gen().makeQuotedQualIdent(actualPrimExpr, selector), args.toList());\n        }\n\n        if (vars != null && !vars.isEmpty()) {\n            if (gen().isVoid(returnType)) {\n                // void methods get wrapped like (let $arg$1=expr, $arg$0=expr in call($arg$0, $arg$1); null)\n                return gen().make().LetExpr(vars.toList(), List.<JCStatement>of(gen().make().Exec(resultExpr)), gen().makeNull());\n            } else {\n                // all other methods like (let $arg$1=expr, $arg$0=expr in call($arg$0, $arg$1))\n                return gen().make().LetExpr(vars.toList(), resultExpr);\n            }\n        } else {\n            return resultExpr;\n        }\n    }","commit_id":"a7dfb0d5d378cf9efef987cde8ed15e9330166fe","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public static InvocationBuilder invocation(AbstractTransformer gen, \n            final Tree.InvocationExpression invocation) {\n        \n        Tree.Primary primary = invocation.getPrimary();\n        Declaration primaryDeclaration = ((Tree.MemberOrTypeExpression)primary).getDeclaration();\n        InvocationBuilder builder;\n        if (invocation.getPositionalArgumentList() != null) {\n            final Tree.PositionalArgumentList positional = invocation.getPositionalArgumentList();\n            java.util.List<ParameterList> paramLists = ((Functional)primaryDeclaration).getParameterLists();\n            builder = new PositionalInvocationBuilder(gen, \n                    primary, primaryDeclaration,\n                    invocation.getTypeModel(),\n                    invocation,\n                    paramLists.get(0)) {\n                \n                @Override\n                protected Expression getExpression(int argIndex) {\n                    return positional.getPositionalArguments().get(argIndex).getExpression();\n                }\n                @Override\n                protected JCExpression getTransformedExpression(int argIndex, boolean isRaw, java.util.List<ProducedType> typeArgumentModels) {\n                    return gen().expressionGen().transformArg(\n                            getExpression(argIndex), \n                            getParameter(argIndex), isRaw, typeArgumentModels);\n                }\n                @Override\n                protected Parameter getParameter(int argIndex) {\n                    return positional.getPositionalArguments().get(argIndex).getParameter();\n                }\n                @Override\n                protected int getNumArguments() {\n                    return positional.getPositionalArguments().size();\n                }\n                @Override\n                protected boolean dontBoxSequence() {\n                    return positional.getEllipsis() != null;\n                }\n                \n            };\n        } else if (invocation.getNamedArgumentList() != null) {\n            builder = new InvocationBuilder(gen, \n                    primary, \n                    primaryDeclaration, \n                    invocation.getTypeModel(),\n                    invocation) {\n                protected boolean containsParameter(java.util.List<Tree.NamedArgument> namedArguments, Parameter param) {\n                    for (Tree.NamedArgument namedArg : namedArguments) {\n                        Parameter declaredParam = namedArg.getParameter();\n                        if (param == declaredParam) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n                @Override\n                protected void compute() {\n                    java.util.List<ProducedType> typeArgumentModels = getTypeArguments();\n                    boolean isRaw = typeArgs.isEmpty();\n                    \n                    if (getPrimaryDeclaration() != null) {\n                        java.util.List<ParameterList> paramLists = ((Functional)getPrimaryDeclaration()).getParameterLists();\n                        java.util.List<Tree.NamedArgument> namedArguments = invocation.getNamedArgumentList().getNamedArguments();\n                        java.util.List<Parameter> declaredParams = paramLists.get(0).getParameters();\n                        Parameter lastDeclared = declaredParams.size() > 0 ? declaredParams.get(declaredParams.size() - 1) : null;\n                        boolean boundSequenced = false;\n                        String varBaseName = gen().aliasName(\"arg\");\n                        callVarName = varBaseName + \"$callable$\";\n                        \n                        int numDeclared = declaredParams.size();\n                        int numDeclaredFixed = (lastDeclared != null && lastDeclared.isSequenced()) ? numDeclared - 1 : numDeclared;\n                        int numPassed = namedArguments.size();\n                        int idx = 0;\n                        for (Tree.NamedArgument namedArg : namedArguments) {\n                            gen().at(namedArg);\n                            Tree.Expression expr = ((Tree.SpecifiedArgument)namedArg).getSpecifierExpression().getExpression();\n                            Parameter declaredParam = namedArg.getParameter();\n                            int index;\n                            BoxingStrategy boxType;\n                            ProducedType type;\n                            if (declaredParam != null) {\n                                if (declaredParam.isSequenced()) {\n                                    boundSequenced = true;\n                                }\n                                index = declaredParams.indexOf(declaredParam);\n                                boxType = Util.getBoxingStrategy(declaredParam);\n                                type = gen().getTypeForParameter(declaredParam, isRaw, typeArgumentModels);\n                            } else {\n                                // Arguments of overloaded methods don't have a reference to parameter\n                                index = idx++;\n                                boxType = BoxingStrategy.UNBOXED;\n                                type = expr.getTypeModel();\n                            }\n                            String varName = varBaseName + \"$\" + index;\n                            // if we can't pick up on the type from the declaration, revert to the type of the expression\n                            if(gen().isTypeParameter(gen().simplifyType(type)))\n                                type = expr.getTypeModel();\n                            \n                            JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n                            JCExpression argExpr = gen().expressionGen().transformExpression(expr, boxType, type);\n                            JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                            vars.append(varDecl);\n                        }\n                        \n                        if (!Decl.isOverloaded(getPrimaryDeclaration()) && numPassed < numDeclaredFixed) {\n                            boolean needsThis = false;\n                            if (Decl.withinClassOrInterface(getPrimaryDeclaration())) {\n                                // first append $this\n                                ProducedType thisType = gen().getThisType(getPrimaryDeclaration());\n                                vars.append(gen().makeVar(varBaseName + \"$this$\", gen().makeJavaType(thisType, AbstractTransformer.NO_PRIMITIVES), gen().makeUnquotedIdent(callVarName)));\n                                needsThis = true;\n                            }\n                            // append any arguments for defaulted parameters\n                            for (int ii = 0; ii < numDeclaredFixed; ii++) {\n                                Parameter param = declaredParams.get(ii);\n                                if (containsParameter(namedArguments, param)) {\n                                    continue;\n                                }\n                                String varName = varBaseName + \"$\" + ii;\n                                String methodName = Util.getDefaultedParamMethodName(getPrimaryDeclaration(), param);\n                                List<JCExpression> arglist = makeThisVarRefArgumentList(varBaseName, ii, needsThis);\n                                JCExpression argExpr;\n                                if (!param.isSequenced()) {\n                                    Declaration container = param.getDeclaration().getRefinedDeclaration();\n                                    if (!container.isToplevel()) {\n                                        container = (Declaration)container.getContainer();\n                                    }\n                                    String className = Util.getCompanionClassName(container.getName());\n                                    argExpr = gen().at(node).Apply(null, gen().makeQuotedQualIdent(gen().makeQuotedFQIdent(container.getQualifiedNameString()), className, methodName), arglist);\n                                } else {\n                                    argExpr = gen().makeEmpty();\n                                }\n                                BoxingStrategy boxType = Util.getBoxingStrategy(param);\n                                ProducedType type = gen().getTypeForParameter(param, isRaw, typeArgumentModels);\n                                JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n                                JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                                vars.append(varDecl);\n                            }\n                        }\n                        \n                        Tree.SequencedArgument sequencedArgument = invocation.getNamedArgumentList().getSequencedArgument();\n                        if (sequencedArgument != null) {\n                            gen().at(sequencedArgument);\n                            String varName = varBaseName + \"$\" + numDeclaredFixed;\n                            JCExpression typeExpr = gen().makeJavaType(lastDeclared.getType(), AbstractTransformer.WANT_RAW_TYPE);\n                            JCExpression argExpr = gen().makeSequenceRaw(sequencedArgument.getExpressionList().getExpressions());\n                            JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                            vars.append(varDecl);\n                        } else if (lastDeclared != null \n                                && lastDeclared.isSequenced() \n                                && !boundSequenced) {\n                            String varName = varBaseName + \"$\" + numDeclaredFixed;\n                            JCExpression typeExpr = gen().makeJavaType(lastDeclared.getType(), AbstractTransformer.WANT_RAW_TYPE);\n                            JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, gen().makeEmpty());\n                            vars.append(varDecl);\n                        }\n                        \n                        if (!Decl.isOverloaded(getPrimaryDeclaration())) {\n                            args.appendList(makeVarRefArgumentList(varBaseName, numDeclared));\n                        } else {\n                            // For overloaded methods (and therefore Java interop) we just pass the arguments we have\n                            args.appendList(makeVarRefArgumentList(varBaseName, numPassed));\n                        }\n                    }\n                }\n            };\n        } else {\n            throw new RuntimeException(\"Illegal State\");\n        }\n        builder.setBoxingStrategy(BoxingStrategy.INDIFFERENT);\n        builder.setUnboxed(invocation.getUnboxed());\n        builder.compute();\n        return builder;\n    }","id":78774,"modified_method":"public static InvocationBuilder invocation(AbstractTransformer gen, \n            final Tree.InvocationExpression invocation) {\n        \n        Tree.Primary primary = invocation.getPrimary();\n        Declaration primaryDeclaration = ((Tree.MemberOrTypeExpression)primary).getDeclaration();\n        InvocationBuilder builder;\n        if (invocation.getPositionalArgumentList() != null) {\n            final Tree.PositionalArgumentList positional = invocation.getPositionalArgumentList();\n            java.util.List<ParameterList> paramLists = ((Functional)primaryDeclaration).getParameterLists();\n            builder = new PositionalInvocationBuilder(gen, \n                    primary, primaryDeclaration,\n                    invocation.getTypeModel(),\n                    invocation,\n                    paramLists.get(0)) {\n                \n                @Override\n                protected Expression getExpression(int argIndex) {\n                    return positional.getPositionalArguments().get(argIndex).getExpression();\n                }\n                @Override\n                protected JCExpression getTransformedExpression(int argIndex, boolean isRaw, java.util.List<ProducedType> typeArgumentModels) {\n                    return gen().expressionGen().transformArg(\n                            getExpression(argIndex), \n                            getParameter(argIndex), isRaw, typeArgumentModels);\n                }\n                @Override\n                protected Parameter getParameter(int argIndex) {\n                    return positional.getPositionalArguments().get(argIndex).getParameter();\n                }\n                @Override\n                protected int getNumArguments() {\n                    return positional.getPositionalArguments().size();\n                }\n                @Override\n                protected boolean dontBoxSequence() {\n                    return positional.getEllipsis() != null;\n                }\n                \n            };\n        } else if (invocation.getNamedArgumentList() != null) {\n            builder = new InvocationBuilder(gen, \n                    primary, \n                    primaryDeclaration, \n                    invocation.getTypeModel(),\n                    invocation) {\n                protected boolean containsParameter(java.util.List<Tree.NamedArgument> namedArguments, Parameter param) {\n                    for (Tree.NamedArgument namedArg : namedArguments) {\n                        Parameter declaredParam = namedArg.getParameter();\n                        if (param == declaredParam) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n                @Override\n                protected void compute() {\n                    java.util.List<ProducedType> typeArgumentModels = getTypeArguments();\n                    boolean isRaw = typeArgs.isEmpty();\n                    \n                    if (getPrimaryDeclaration() != null) {\n                        java.util.List<ParameterList> paramLists = ((Functional)getPrimaryDeclaration()).getParameterLists();\n                        java.util.List<Tree.NamedArgument> namedArguments = invocation.getNamedArgumentList().getNamedArguments();\n                        java.util.List<Parameter> declaredParams = paramLists.get(0).getParameters();\n                        Parameter lastDeclared = declaredParams.size() > 0 ? declaredParams.get(declaredParams.size() - 1) : null;\n                        boolean boundSequenced = false;\n                        String varBaseName = gen().aliasName(\"arg\");\n                        callVarName = varBaseName + \"$callable$\";\n                        \n                        int numDeclared = declaredParams.size();\n                        int numDeclaredFixed = (lastDeclared != null && lastDeclared.isSequenced()) ? numDeclared - 1 : numDeclared;\n                        int numPassed = namedArguments.size();\n                        int idx = 0;\n                        for (Tree.NamedArgument namedArg : namedArguments) {\n                            gen().at(namedArg);\n                            Tree.Expression expr = ((Tree.SpecifiedArgument)namedArg).getSpecifierExpression().getExpression();\n                            Parameter declaredParam = namedArg.getParameter();\n                            int index;\n                            BoxingStrategy boxType;\n                            ProducedType type;\n                            if (declaredParam != null) {\n                                if (declaredParam.isSequenced()) {\n                                    boundSequenced = true;\n                                }\n                                index = declaredParams.indexOf(declaredParam);\n                                boxType = Util.getBoxingStrategy(declaredParam);\n                                type = gen().getTypeForParameter(declaredParam, isRaw, typeArgumentModels);\n                            } else {\n                                // Arguments of overloaded methods don't have a reference to parameter\n                                index = idx++;\n                                boxType = BoxingStrategy.UNBOXED;\n                                type = expr.getTypeModel();\n                            }\n                            String varName = varBaseName + \"$\" + index;\n                            // if we can't pick up on the type from the declaration, revert to the type of the expression\n                            if(gen().isTypeParameter(gen().simplifyType(type)))\n                                type = expr.getTypeModel();\n                            \n                            JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n                            JCExpression argExpr = gen().expressionGen().transformExpression(expr, boxType, type);\n                            JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                            vars.append(varDecl);\n                        }\n                        \n                        if (!Decl.isOverloaded(getPrimaryDeclaration()) && numPassed < numDeclaredFixed) {\n                            boolean needsThis = false;\n                            if (Decl.withinClassOrInterface(getPrimaryDeclaration())) {\n                                // first append $this\n                                ProducedType thisType = gen().getThisType(getPrimaryDeclaration());\n                                vars.append(gen().makeVar(varBaseName + \"$this$\", gen().makeJavaType(thisType, AbstractTransformer.NO_PRIMITIVES), gen().makeUnquotedIdent(callVarName)));\n                                needsThis = true;\n                            }\n                            // append any arguments for defaulted parameters\n                            for (int ii = 0; ii < numDeclaredFixed; ii++) {\n                                Parameter param = declaredParams.get(ii);\n                                if (containsParameter(namedArguments, param)) {\n                                    continue;\n                                }\n                                String varName = varBaseName + \"$\" + ii;\n                                String methodName = Util.getDefaultedParamMethodName(getPrimaryDeclaration(), param);\n                                List<JCExpression> arglist = makeThisVarRefArgumentList(varBaseName, ii, needsThis);\n                                JCExpression argExpr;\n                                if (!param.isSequenced()) {\n                                    Declaration container = param.getDeclaration().getRefinedDeclaration();\n                                    if (!container.isToplevel()) {\n                                        container = (Declaration)container.getContainer();\n                                    }\n                                    String className = Util.getCompanionClassName(container.getName());\n                                    argExpr = gen().at(node).Apply(null, gen().makeQuotedQualIdent(gen().makeQuotedFQIdent(container.getQualifiedNameString()), className, methodName), arglist);\n                                } else {\n                                    argExpr = gen().makeEmpty();\n                                }\n                                BoxingStrategy boxType = Util.getBoxingStrategy(param);\n                                ProducedType type = gen().getTypeForParameter(param, isRaw, typeArgumentModels);\n                                JCExpression typeExpr = gen().makeJavaType(type, (boxType == BoxingStrategy.BOXED) ? AbstractTransformer.TYPE_ARGUMENT : 0);\n                                JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                                vars.append(varDecl);\n                            }\n                        }\n                        \n                        Tree.SequencedArgument sequencedArgument = invocation.getNamedArgumentList().getSequencedArgument();\n                        if (sequencedArgument != null) {\n                            gen().at(sequencedArgument);\n                            String varName = varBaseName + \"$\" + numDeclaredFixed;\n                            JCExpression typeExpr = gen().makeJavaType(lastDeclared.getType(), AbstractTransformer.WANT_RAW_TYPE);\n                            JCExpression argExpr = gen().makeSequenceRaw(sequencedArgument.getExpressionList().getExpressions());\n                            JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, argExpr);\n                            vars.append(varDecl);\n                        } else if (lastDeclared != null \n                                && lastDeclared.isSequenced() \n                                && !boundSequenced) {\n                            String varName = varBaseName + \"$\" + numDeclaredFixed;\n                            JCExpression typeExpr = gen().makeJavaType(lastDeclared.getType(), AbstractTransformer.WANT_RAW_TYPE);\n                            JCVariableDecl varDecl = gen().makeVar(varName, typeExpr, gen().makeEmpty());\n                            vars.append(varDecl);\n                        }\n                        \n                        if (!Decl.isOverloaded(getPrimaryDeclaration())) {\n                            args.appendList(makeVarRefArgumentList(varBaseName, numDeclared));\n                        } else {\n                            // For overloaded methods (and therefore Java interop) we just pass the arguments we have\n                            args.appendList(makeVarRefArgumentList(varBaseName, numPassed));\n                        }\n                    }\n                }\n            };\n        } else {\n            throw new RuntimeException(\"Illegal State\");\n        }\n        if (primaryDeclaration instanceof FunctionalParameter) {\n            // Callables always have boxed return type\n            builder.setBoxingStrategy(invocation.getUnboxed() ? BoxingStrategy.UNBOXED : BoxingStrategy.BOXED);\n            builder.setUnboxed(false);\n        } else {\n            builder.setBoxingStrategy(BoxingStrategy.INDIFFERENT);\n            builder.setUnboxed(invocation.getUnboxed());\n        }\n        builder.compute();\n        return builder;\n    }","commit_id":"a7dfb0d5d378cf9efef987cde8ed15e9330166fe","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected JComponent typeComponent() {\n    JComponent component = myTypeSelector.getComponent();\n    JPanel panel = new JPanel(new BorderLayout());\n    panel.add(new JLabel(\"Type: \"), BorderLayout.WEST);\n    panel.add(component, BorderLayout.CENTER);\n    return panel;\n  }","id":78775,"modified_method":"@Nullable\n  protected JComponent typeComponent() {\n    JComponent component = myTypeSelector.getComponent();\n    if (component instanceof JLabel) return null;\n    LOG.assertTrue(component instanceof JComboBox);\n    InplaceCombosUtil.appendActions((JComboBox)component, myProject);\n    JPanel panel = new JPanel(new BorderLayout());\n    JLabel label = new JLabel(\"Type: \");\n    label.setLabelFor(component);\n    label.setDisplayedMnemonic('T');\n    panel.add(label, BorderLayout.WEST);\n    panel.add(component, BorderLayout.CENTER);\n    return panel;\n  }","commit_id":"3b360d4f34d5f2ba4f8149d42be5ec7e575f48e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InplaceIntroduceConstantPopup(Project project,\n                                       Editor editor,\n                                       PsiClass parentClass,\n                                       PsiExpression expr,\n                                       PsiLocalVariable localVariable,\n                                       PsiExpression[] occurrences,\n                                       TypeSelectorManagerImpl typeSelectorManager,\n                                       PsiElement anchorElement,\n                                       PsiElement anchorElementIfAll, OccurenceManager occurenceManager) {\n    super(project, editor, expr, localVariable, occurrences, typeSelectorManager, IntroduceConstantHandler.REFACTORING_NAME);\n    myParentClass = parentClass;\n    myTypeSelectorManager = typeSelectorManager;\n    myAnchorElement = anchorElement;\n    myAnchorElementIfAll = anchorElementIfAll;\n    for (int i = 0, occurrencesLength = occurrences.length; i < occurrencesLength; i++) {\n      PsiExpression occurrence = occurrences[i];\n      PsiElement parent = occurrence.getParent();\n      if (parent == myAnchorElement) {\n        myAnchorIdx = i;\n      }\n      if (parent == myAnchorElementIfAll) {\n        myAnchorIdxIfAll = i;\n      }\n    }\n    myOccurenceManager = occurenceManager;\n\n    myInitializerText = getExprText(expr, localVariable);\n\n\n    myWholePanel = new JPanel(new GridBagLayout());\n    GridBagConstraints gc =\n      new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0);\n\n    gc.gridwidth = 1;\n    gc.gridy = 1;\n    myWholePanel.add(createLeftPanel(), gc);\n\n    gc.gridx = 1;\n    gc.insets.left = 6;\n    myWholePanel.add(createRightPanel(), gc);\n\n    gc.gridy = 2;\n    gc.gridx = 0;\n    gc.gridwidth = 2;\n    myWholePanel.add(typeComponent(), gc);\n  }","id":78776,"modified_method":"public InplaceIntroduceConstantPopup(Project project,\n                                       Editor editor,\n                                       PsiClass parentClass,\n                                       PsiExpression expr,\n                                       PsiLocalVariable localVariable,\n                                       PsiExpression[] occurrences,\n                                       TypeSelectorManagerImpl typeSelectorManager,\n                                       PsiElement anchorElement,\n                                       PsiElement anchorElementIfAll, OccurenceManager occurenceManager) {\n    super(project, editor, expr, localVariable, occurrences, typeSelectorManager, IntroduceConstantHandler.REFACTORING_NAME);\n    myParentClass = parentClass;\n    myTypeSelectorManager = typeSelectorManager;\n    myAnchorElement = anchorElement;\n    myAnchorElementIfAll = anchorElementIfAll;\n    for (int i = 0, occurrencesLength = occurrences.length; i < occurrencesLength; i++) {\n      PsiExpression occurrence = occurrences[i];\n      PsiElement parent = occurrence.getParent();\n      if (parent == myAnchorElement) {\n        myAnchorIdx = i;\n      }\n      if (parent == myAnchorElementIfAll) {\n        myAnchorIdxIfAll = i;\n      }\n    }\n    myOccurenceManager = occurenceManager;\n\n    myInitializerText = getExprText(expr, localVariable);\n\n\n    myWholePanel = new JPanel(new GridBagLayout());\n    GridBagConstraints gc =\n      new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0);\n\n    gc.gridwidth = 1;\n    gc.gridy = 1;\n    myWholePanel.add(createLeftPanel(), gc);\n\n    gc.gridx = 1;\n    gc.insets.left = 6;\n    myWholePanel.add(createRightPanel(), gc);\n\n    gc.gridy = 2;\n    gc.gridx = 0;\n    gc.gridwidth = 2;\n    JComponent typeChooser = typeComponent();\n    if (typeChooser != null) {\n      myWholePanel.add(typeChooser, gc);\n    }\n  }","commit_id":"3b360d4f34d5f2ba4f8149d42be5ec7e575f48e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InplaceIntroduceFieldPopup(PsiLocalVariable localVariable,\n                                    PsiClass parentClass,\n                                    boolean aStatic,\n                                    boolean currentMethodConstructor, PsiExpression[] occurrences,\n                                    PsiExpression initializerExpression,\n                                    TypeSelectorManagerImpl typeSelectorManager,\n                                    Editor editor,\n                                    final boolean allowInitInMethod,\n                                    boolean allowInitInMethodIfAll, final PsiElement anchorElement,\n                                    final PsiElement anchorElementIfAll,\n                                    final OccurenceManager occurenceManager, Project project) {\n    super(project, editor, initializerExpression, localVariable, occurrences, typeSelectorManager,\n          IntroduceFieldHandler.REFACTORING_NAME);\n    myParentClass = parentClass;\n    myStatic = aStatic;\n    myAnchorElement = anchorElement;\n    myAnchorElementIfAll = anchorElementIfAll;\n    for (int i = 0, occurrencesLength = occurrences.length; i < occurrencesLength; i++) {\n      PsiExpression occurrence = occurrences[i];\n      PsiElement parent = occurrence.getParent();\n      if (parent == myAnchorElement) {\n        myAnchorIdx = i;\n      }\n      if (parent == anchorElementIfAll) {\n        myAnchorIdxIfAll = i;\n      }\n    }\n    myOccurenceManager = occurenceManager;\n    myProject = myLocalVariable != null ? myLocalVariable.getProject() : initializerExpression.getProject();\n    myEditor = editor;\n\n    myIntroduceFieldPanel =\n      new IntroduceFieldPopupPanel(parentClass, initializerExpression, localVariable, currentMethodConstructor, localVariable != null, aStatic,\n                               myOccurrences, allowInitInMethod, allowInitInMethodIfAll, typeSelectorManager);\n\n    myWholePanel = new JPanel(new GridBagLayout());\n    myWholePanel.setBorder(null);\n\n    GridBagConstraints gc =\n      new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL,\n                             new Insets(0,0,0,0), 0, 0);\n\n\n    gc.gridy++;\n    gc.insets.top = 5;\n\n    myWholePanel.add(myIntroduceFieldPanel.createCenterPanel(), gc);\n    gc.gridy++ ;\n    myWholePanel.add(typeComponent(), gc);\n    myIntroduceFieldPanel.initializeControls(initializerExpression, ourLastInitializerPlace);\n\n\n  }","id":78777,"modified_method":"public InplaceIntroduceFieldPopup(PsiLocalVariable localVariable,\n                                    PsiClass parentClass,\n                                    boolean aStatic,\n                                    boolean currentMethodConstructor, PsiExpression[] occurrences,\n                                    PsiExpression initializerExpression,\n                                    TypeSelectorManagerImpl typeSelectorManager,\n                                    Editor editor,\n                                    final boolean allowInitInMethod,\n                                    boolean allowInitInMethodIfAll, final PsiElement anchorElement,\n                                    final PsiElement anchorElementIfAll,\n                                    final OccurenceManager occurenceManager, Project project) {\n    super(project, editor, initializerExpression, localVariable, occurrences, typeSelectorManager,\n          IntroduceFieldHandler.REFACTORING_NAME);\n    myParentClass = parentClass;\n    myStatic = aStatic;\n    myAnchorElement = anchorElement;\n    myAnchorElementIfAll = anchorElementIfAll;\n    for (int i = 0, occurrencesLength = occurrences.length; i < occurrencesLength; i++) {\n      PsiExpression occurrence = occurrences[i];\n      PsiElement parent = occurrence.getParent();\n      if (parent == myAnchorElement) {\n        myAnchorIdx = i;\n      }\n      if (parent == anchorElementIfAll) {\n        myAnchorIdxIfAll = i;\n      }\n    }\n    myOccurenceManager = occurenceManager;\n    myProject = myLocalVariable != null ? myLocalVariable.getProject() : initializerExpression.getProject();\n    myEditor = editor;\n\n    myIntroduceFieldPanel =\n      new IntroduceFieldPopupPanel(parentClass, initializerExpression, localVariable, currentMethodConstructor, localVariable != null, aStatic,\n                               myOccurrences, allowInitInMethod, allowInitInMethodIfAll, typeSelectorManager);\n\n    myWholePanel = new JPanel(new GridBagLayout());\n    myWholePanel.setBorder(null);\n\n    GridBagConstraints gc =\n      new GridBagConstraints(0, 0, 1, 1, 1, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL,\n                             new Insets(0,0,0,0), 0, 0);\n\n\n    gc.gridy++;\n    gc.insets.top = 5;\n\n    myWholePanel.add(myIntroduceFieldPanel.createCenterPanel(), gc);\n    gc.gridy++ ;\n    JComponent typeChooser = typeComponent();\n    if (typeChooser != null) {\n      myWholePanel.add(typeChooser, gc);\n    }\n    myIntroduceFieldPanel.initializeControls(initializerExpression, ourLastInitializerPlace);\n\n\n  }","commit_id":"3b360d4f34d5f2ba4f8149d42be5ec7e575f48e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"InplaceIntroduceParameterPopup(final Project project,\n                                 final Editor editor,\n                                 final List<UsageInfo> classMemberRefs,\n                                 final TypeSelectorManagerImpl typeSelectorManager,\n                                 final PsiExpression expr,\n                                 final PsiLocalVariable localVar,\n                                 final PsiMethod method,\n                                 final PsiMethod methodToSearchFor,\n                                 final PsiExpression[] occurrences,\n                                 final TIntArrayList parametersToRemove,\n                                 final boolean mustBeFinal) {\n    super(project, editor, expr, localVar, occurrences, typeSelectorManager, IntroduceParameterHandler.REFACTORING_NAME\n    );\n    myMethod = method;\n    myMethodToSearchFor = methodToSearchFor;\n    myMustBeFinal = mustBeFinal;\n\n    myWholePanel = new JPanel(new GridBagLayout());\n    myWholePanel.setBorder(null);\n\n    myPanel = new InplaceIntroduceParameterUI(project, localVar, expr, method, parametersToRemove, typeSelectorManager,\n                                              myEditor, myOccurrences, classMemberRefs, myMustBeFinal) {\n      @Override\n      protected PsiParameter getParameter() {\n        return InplaceIntroduceParameterPopup.this.getParameter();\n      }\n\n      @Override\n      protected void updateControls(JCheckBox[] removeParamsCb) {\n        super.updateControls(removeParamsCb);\n        if (myParameterIndex < 0) return;\n        restartInplaceIntroduceTemplate();\n      }\n    };\n    myPanel.append2MainPanel(myWholePanel);\n    myWholePanel.add(typeComponent(), new GridBagConstraints(0, GridBagConstraints.RELATIVE, 2, 1, 1, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL,\n                                                                           new Insets(0,0,0,0), 0,0));\n  }","id":78778,"modified_method":"InplaceIntroduceParameterPopup(final Project project,\n                                 final Editor editor,\n                                 final List<UsageInfo> classMemberRefs,\n                                 final TypeSelectorManagerImpl typeSelectorManager,\n                                 final PsiExpression expr,\n                                 final PsiLocalVariable localVar,\n                                 final PsiMethod method,\n                                 final PsiMethod methodToSearchFor,\n                                 final PsiExpression[] occurrences,\n                                 final TIntArrayList parametersToRemove,\n                                 final boolean mustBeFinal) {\n    super(project, editor, expr, localVar, occurrences, typeSelectorManager, IntroduceParameterHandler.REFACTORING_NAME\n    );\n    myMethod = method;\n    myMethodToSearchFor = methodToSearchFor;\n    myMustBeFinal = mustBeFinal;\n\n    myWholePanel = new JPanel(new GridBagLayout());\n    myWholePanel.setBorder(null);\n\n    myPanel = new InplaceIntroduceParameterUI(project, localVar, expr, method, parametersToRemove, typeSelectorManager,\n                                              myEditor, myOccurrences, classMemberRefs, myMustBeFinal) {\n      @Override\n      protected PsiParameter getParameter() {\n        return InplaceIntroduceParameterPopup.this.getParameter();\n      }\n\n      @Override\n      protected void updateControls(JCheckBox[] removeParamsCb) {\n        super.updateControls(removeParamsCb);\n        if (myParameterIndex < 0) return;\n        restartInplaceIntroduceTemplate();\n      }\n    };\n    myPanel.append2MainPanel(myWholePanel);\n    JComponent typeChooser = typeComponent();\n    if (typeChooser != null) {\n      myWholePanel.add(typeChooser, new GridBagConstraints(0, GridBagConstraints.RELATIVE, 2, 1, 1, 0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL,\n                                                                             new Insets(0,0,0,0), 0,0));\n    }\n  }","commit_id":"3b360d4f34d5f2ba4f8149d42be5ec7e575f48e2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    private List<FsContent> runQuery(){\n        ResultSet rs = null;\n        List<FsContent> list = new ArrayList<FsContent>();\n        try {\n            rs = skCase.runQuery(createQuery());\n            for(FsContent c : skCase.resultSetToFsContents(rs)){\n                if(c.isFile()){\n                    list.add(c);\n                }\n            }\n        } catch (SQLException ex) {\n            logger.log(Level.WARNING, \"Couldn't get search results\", ex);\n        }\n        finally {\n            if (rs != null) {\n                try {\n                    skCase.closeRunQuery(rs);\n                } catch (SQLException ex) {\n                    logger.log(Level.SEVERE, \"Error closing result set after executing fscontents query for file search results\", ex);\n                }\n            }\n        }\n        return list;\n        \n    }","id":78779,"modified_method":"private List<FsContent> runQuery(){\n        ResultSet rs = null;\n        List<FsContent> list = new ArrayList<FsContent>();\n        try {\n            List<FsContent> res = skCase.findFilesWhere(createQuery());\n            for(FsContent c : res){\n                if(c.isFile()){\n                    list.add(c);\n                }\n            }\n        } catch (TskCoreException ex) {\n            logger.log(Level.WARNING, \"Couldn't get search results\", ex);\n        }\n\n        return list;\n        \n    }","commit_id":"e480c4802ea4759bf8ed48eed3e49341fa3efcf3","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private String createQuery(){\n        String query = \"select * from tsk_files where known <> 1 and (0\";\n        for(String s : filter.getFilter()){\n            query += \" or name like '%\" + s + \"'\";\n        }\n        query += ')';\n        //query += \" limit \" + MAX_OBJECTS;\n        return query;\n    }","id":78780,"modified_method":"private String createQuery(){\n        String query = \"known <> 1 AND (0\";\n        for(String s : filter.getFilter()){\n            query += \" OR name LIKE '%\" + s + \"'\";\n        }\n        query += ')';\n        //query += \" LIMIT \" + MAX_OBJECTS;\n        return query;\n    }","commit_id":"e480c4802ea4759bf8ed48eed3e49341fa3efcf3","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    private List<FsContent> runFsQuery() {\n        List<FsContent> list = new ArrayList<FsContent>();\n        ResultSet rs = null;\n        try {\n            rs = skCase.runQuery(createQuery());\n            for (FsContent c : skCase.resultSetToFsContents(rs)) {\n                if (c.isFile()) {\n                    list.add(c);\n                }\n            }\n\n        } catch (SQLException ex) {\n            logger.log(Level.WARNING, \"Couldn't get search results\", ex);\n        } finally {\n            if (rs != null) {\n                try {\n                    skCase.closeRunQuery(rs);\n                } catch (SQLException ex) {\n                    logger.log(Level.WARNING, \"Error closing result set after getting recent files results\", ex);\n                }\n            }\n        }\n        return list;\n\n    }","id":78781,"modified_method":"private List<FsContent> runFsQuery() {\n        List<FsContent> ret = new ArrayList<FsContent>();\n        try {\n            List<FsContent> found = skCase.findFilesWhere(createQuery());\n            for (FsContent c : found) {\n                if (c.isFile()) {\n                    ret.add(c);\n                }\n            }\n\n        } catch (TskCoreException ex) {\n            logger.log(Level.WARNING, \"Couldn't get search results\", ex);\n        } \n        return ret;\n\n    }","commit_id":"de1e0421aa1b1e988a51264090a056051852a365","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private String createQuery() {\n        String query = \"select * from tsk_files where known <> 1 and (\";\n        long lowerLimit = prevDay.getTimeInMillis() / 1000;\n        prevDay.add(Calendar.DATE, 1);\n        prevDay.add(Calendar.MILLISECOND, -1);\n        long upperLimit = prevDay.getTimeInMillis() / 1000;\n        query += \"(crtime between \" + lowerLimit + \" and \" + upperLimit + \") or \";\n        query += \"(ctime between \" + lowerLimit + \" and \" + upperLimit + \") or \";\n        //query += \"(atime between \" + lowerLimit + \" and \" + upperLimit + \") or \";\n        query += \"(mtime between \" + lowerLimit + \" and \" + upperLimit + \"))\";\n        //query += \" limit \" + MAX_OBJECTS;\n        return query;\n    }","id":78782,"modified_method":"private String createQuery() {\n        String query = \"known <> 1 AND (\";\n        long lowerLimit = prevDay.getTimeInMillis() / 1000;\n        prevDay.add(Calendar.DATE, 1);\n        prevDay.add(Calendar.MILLISECOND, -1);\n        long upperLimit = prevDay.getTimeInMillis() / 1000;\n        query += \"(crtime BETWEEN \" + lowerLimit + \" AND \" + upperLimit + \") OR \";\n        query += \"(ctime BETWEEN \" + lowerLimit + \" AND \" + upperLimit + \") OR \";\n        //query += \"(atime BETWEEN \" + lowerLimit + \" AND \" + upperLimit + \") OR \";\n        query += \"(mtime BETWEEN \" + lowerLimit + \" AND \" + upperLimit + \"))\";\n        //query += \" LIMIT \" + MAX_OBJECTS;\n        return query;\n    }","commit_id":"de1e0421aa1b1e988a51264090a056051852a365","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private String createQuery(){\n        String query = \"select * from tsk_files where known <> 1 and (0\";\n        for(String s : filter.getFilter()){\n            query += \" or name like '%\" + s + \"'\";\n        }\n        query += ')';\n        //query += \" limit \" + MAX_OBJECTS;\n        return query;\n    }","id":78783,"modified_method":"private String createQuery(){\n        String query = \"known <> 1 AND (0\";\n        for(String s : filter.getFilter()){\n            query += \" OR name LIKE '%\" + s + \"'\";\n        }\n        query += ')';\n        //query += \" LIMIT \" + MAX_OBJECTS;\n        return query;\n    }","commit_id":"df48a2c1ef9c3deb8105527fd46e3cb01e9b2833","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    private List<FsContent> runQuery(){\n        ResultSet rs = null;\n        List<FsContent> list = new ArrayList<FsContent>();\n        try {\n            rs = skCase.runQuery(createQuery());\n            for(FsContent c : skCase.resultSetToFsContents(rs)){\n                if(c.isFile()){\n                    list.add(c);\n                }\n            }\n        } catch (SQLException ex) {\n            logger.log(Level.WARNING, \"Couldn't get search results\", ex);\n        }\n        finally {\n            if (rs != null) {\n                try {\n                    skCase.closeRunQuery(rs);\n                } catch (SQLException ex) {\n                    logger.log(Level.SEVERE, \"Error closing result set after executing fscontents query for file search results\", ex);\n                }\n            }\n        }\n        return list;\n        \n    }","id":78784,"modified_method":"private List<FsContent> runQuery(){\n        ResultSet rs = null;\n        List<FsContent> list = new ArrayList<FsContent>();\n        try {\n            List<FsContent> res = skCase.findFilesWhere(createQuery());\n            for(FsContent c : res){\n                if(c.isFile()){\n                    list.add(c);\n                }\n            }\n        } catch (TskCoreException ex) {\n            logger.log(Level.WARNING, \"Couldn't get search results\", ex);\n        }\n\n        return list;\n        \n    }","commit_id":"df48a2c1ef9c3deb8105527fd46e3cb01e9b2833","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    protected Node createNodeForKey(Content key){\n        return key.accept(new ContentVisitor.Default<AbstractNode>(){\n            \n            @Override\n            public FileNode visit(File f){\n                return new FileNode(f, false);\n            }\n\n            @Override\n            protected AbstractNode defaultVisit(Content di) {\n                throw new UnsupportedOperationException(\"Not supported for this type of Displayable Item: \" + di.toString());\n            }\n            \n        });\n    }","id":78785,"modified_method":"@Override\n    protected Node createNodeForKey(Content key) {\n        return key.accept(new ContentVisitor.Default<AbstractNode>() {\n            @Override\n            public FileNode visit(File f) {\n                return new FileNode(f, false);\n            }\n\n            @Override\n            public DerivedFileNode visit(DerivedFile df) {\n                return new DerivedFileNode(df);\n            }\n\n            @Override\n            protected AbstractNode defaultVisit(Content di) {\n                throw new UnsupportedOperationException(\"Not supported for this type of Displayable Item: \" + di.toString());\n            }\n        });\n    }","commit_id":"6c28e7a2e30f5d3bcdf9a2d11be72a230defd052","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    private List<FsContent> runQuery(){\n        ResultSet rs = null;\n        List<FsContent> list = new ArrayList<FsContent>();\n        try {\n            rs = skCase.runQuery(createQuery());\n            for(FsContent c : skCase.resultSetToFsContents(rs)){\n                if(c.isFile()){\n                    list.add(c);\n                }\n            }\n        } catch (SQLException ex) {\n            logger.log(Level.WARNING, \"Couldn't get search results\", ex);\n        }\n        finally {\n            if (rs != null) {\n                try {\n                    skCase.closeRunQuery(rs);\n                } catch (SQLException ex) {\n                    logger.log(Level.SEVERE, \"Error closing result set after executing fscontents query for file search results\", ex);\n                }\n            }\n        }\n        return list;\n        \n    }","id":78786,"modified_method":"private List<FsContent> runQuery() {\n        ResultSet rs = null;\n        List<FsContent> ret = new ArrayList<FsContent>();\n        try {\n            List<FsContent> found = skCase.findFilesWhere(createQuery());\n            for (FsContent c : found) {\n                if (c.isFile()) {\n                    ret.add(c);\n                }\n            }\n        } catch (TskCoreException ex) {\n            logger.log(Level.WARNING, \"Couldn't get search results\", ex);\n        } \n        return ret;\n\n    }","commit_id":"6c28e7a2e30f5d3bcdf9a2d11be72a230defd052","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private String createQuery(){\n        String query = \"select * from tsk_files where known <> 1 and (0\";\n        for(String s : filter.getFilter()){\n            query += \" or name like '%\" + s + \"'\";\n        }\n        query += ')';\n        //query += \" limit \" + MAX_OBJECTS;\n        return query;\n    }","id":78787,"modified_method":"private String createQuery() {\n        String query = \"known <> 1 and (0\";\n        for (String s : filter.getFilter()) {\n            query += \" OR name LIKE '%\" + s + \"'\";\n        }\n        query += ')';\n        //query += \" LIMIT \" + MAX_OBJECTS;\n        return query;\n    }","commit_id":"6c28e7a2e30f5d3bcdf9a2d11be72a230defd052","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private static String cacheFromJava(String javaCipherSuite) {\n        String openSslCipherSuite = toOpenSslUncached(javaCipherSuite);\n        if (openSslCipherSuite == null) {\n            return null;\n        }\n\n        // Cache the mapping.\n        j2o.putIfAbsent(javaCipherSuite, openSslCipherSuite);\n\n        // Cache the reverse mapping after stripping the protocol prefix (TLS_ or SSL_)\n        final String javaCipherSuiteSuffix = javaCipherSuite.substring(4);\n        Map<String, String> p2j = new HashMap<>(4);\n        p2j.put(\"\", javaCipherSuiteSuffix);\n        p2j.put(\"SSL\", \"SSL_\" + javaCipherSuiteSuffix);\n        p2j.put(\"TLS\", \"TLS_\" + javaCipherSuiteSuffix);\n        o2j.put(openSslCipherSuite, p2j);\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(sm.getString(\"converter.mapping\", javaCipherSuite, openSslCipherSuite));\n        }\n\n        return openSslCipherSuite;\n    }","id":78788,"modified_method":"private static String cacheFromJava(String javaCipherSuite) {\n        String openSslCipherSuite = toOpenSslUncached(javaCipherSuite);\n        if (openSslCipherSuite == null) {\n            return null;\n        }\n\n        // Cache the mapping.\n        j2o.putIfAbsent(javaCipherSuite, openSslCipherSuite);\n\n        // Cache the reverse mapping after stripping the protocol prefix (TLS_ or SSL_)\n        final String javaCipherSuiteSuffix = javaCipherSuite.substring(4);\n        Map<String, String> p2j = new HashMap<>(4);\n        p2j.put(\"\", javaCipherSuiteSuffix);\n        p2j.put(\"SSL\", \"SSL_\" + javaCipherSuiteSuffix);\n        p2j.put(\"TLS\", \"TLS_\" + javaCipherSuiteSuffix);\n        o2j.put(openSslCipherSuite, p2j);\n\n        /* TODO the log looks broken...\n        if (logger.isDebugEnabled()) {\n            logger.debug(sm.getString(\"converter.mapping\", javaCipherSuite, openSslCipherSuite));\n        }\n        */\n\n        return openSslCipherSuite;\n    }","commit_id":"881618f787926b84bc7b1913ebc52bede4c5a305","url":"https://github.com/apache/tomcat"},{"original_method":"private static Map<String, String> cacheFromOpenSsl(String openSslCipherSuite) {\n        String javaCipherSuiteSuffix = toJavaUncached(openSslCipherSuite);\n        if (javaCipherSuiteSuffix == null) {\n            return null;\n        }\n\n        final String javaCipherSuiteSsl = \"SSL_\" + javaCipherSuiteSuffix;\n        final String javaCipherSuiteTls = \"TLS_\" + javaCipherSuiteSuffix;\n\n        // Cache the mapping.\n        Map<String, String> p2j = new HashMap<>(4);\n        p2j.put(\"\", javaCipherSuiteSuffix);\n        p2j.put(\"SSL\", javaCipherSuiteSsl);\n        p2j.put(\"TLS\", javaCipherSuiteTls);\n        Map<String, String> p2jCurrent = o2j.putIfAbsent(openSslCipherSuite, p2j);\n        if (p2jCurrent != null) {\n            p2j = p2jCurrent;\n        }\n\n        // Cache the reverse mapping after adding the protocol prefix (TLS_ or SSL_)\n        j2o.putIfAbsent(javaCipherSuiteTls, openSslCipherSuite);\n        j2o.putIfAbsent(javaCipherSuiteSsl, openSslCipherSuite);\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(sm.getString(\"converter.mapping\", javaCipherSuiteTls, openSslCipherSuite));\n            logger.debug(sm.getString(\"converter.mapping\", javaCipherSuiteSsl, openSslCipherSuite));\n        }\n\n        return p2j;\n    }","id":78789,"modified_method":"private static Map<String, String> cacheFromOpenSsl(String openSslCipherSuite) {\n        String javaCipherSuiteSuffix = toJavaUncached(openSslCipherSuite);\n        if (javaCipherSuiteSuffix == null) {\n            return null;\n        }\n\n        final String javaCipherSuiteSsl = \"SSL_\" + javaCipherSuiteSuffix;\n        final String javaCipherSuiteTls = \"TLS_\" + javaCipherSuiteSuffix;\n\n        // Cache the mapping.\n        Map<String, String> p2j = new HashMap<>(4);\n        p2j.put(\"\", javaCipherSuiteSuffix);\n        p2j.put(\"SSL\", javaCipherSuiteSsl);\n        p2j.put(\"TLS\", javaCipherSuiteTls);\n        Map<String, String> p2jCurrent = o2j.putIfAbsent(openSslCipherSuite, p2j);\n        if (p2jCurrent != null) {\n            p2j = p2jCurrent;\n        }\n\n        // Cache the reverse mapping after adding the protocol prefix (TLS_ or SSL_)\n        j2o.putIfAbsent(javaCipherSuiteTls, openSslCipherSuite);\n        j2o.putIfAbsent(javaCipherSuiteSsl, openSslCipherSuite);\n\n        /* TODO the log looks broken...\n        if (logger.isDebugEnabled()) {\n            logger.debug(sm.getString(\"converter.mapping\", javaCipherSuiteTls, openSslCipherSuite));\n            logger.debug(sm.getString(\"converter.mapping\", javaCipherSuiteSsl, openSslCipherSuite));\n        }\n        */\n\n        return p2j;\n    }","commit_id":"881618f787926b84bc7b1913ebc52bede4c5a305","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Setup the SSL_CTX\n     *\n     * @param kms Must contain a KeyManager of the type\n     * {@code OpenSSLKeyManager}\n     * @param tms\n     * @param sr Is not used for this implementation.\n     */\n    @Override\n    public synchronized void init(KeyManager[] kms, TrustManager[] tms, SecureRandom sr) {\n        if (initialized) {\n            log.warn(sm.getString(\"openssl.doubleInit\"));\n            return;\n        }\n        try {\n            boolean legacyRenegSupported = false;\n            try {\n                legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                if (legacyRenegSupported)\n                    if (sslHostConfig.getInsecureRenegotiation()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                    }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!legacyRenegSupported) {\n                // OpenSSL does not support unsafe legacy renegotiation.\n                log.warn(netSm.getString(\"endpoint.warn.noInsecureReneg\",\n                                      SSL.versionString()));\n            }\n            // Use server's preference order for ciphers (rather than\n            // client's)\n            boolean orderCiphersSupported = false;\n            try {\n                orderCiphersSupported = SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                if (orderCiphersSupported) {\n                    if (sslHostConfig.getHonorCipherOrder()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!orderCiphersSupported) {\n                // OpenSSL does not support ciphers ordering.\n                log.warn(netSm.getString(\"endpoint.warn.noHonorCipherOrder\",\n                                      SSL.versionString()));\n            }\n\n            // Disable compression if requested\n            boolean disableCompressionSupported = false;\n            try {\n                disableCompressionSupported = SSL.hasOp(SSL.SSL_OP_NO_COMPRESSION);\n                if (disableCompressionSupported) {\n                    if (sslHostConfig.getDisableCompression()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!disableCompressionSupported) {\n                // OpenSSL does not support ciphers ordering.\n                log.warn(netSm.getString(\"endpoint.warn.noDisableCompression\",\n                                      SSL.versionString()));\n            }\n\n            // Disable TLS Session Tickets (RFC4507) to protect perfect forward secrecy\n            boolean disableSessionTicketsSupported = false;\n            try {\n                disableSessionTicketsSupported = SSL.hasOp(SSL.SSL_OP_NO_TICKET);\n                if (disableSessionTicketsSupported) {\n                    if (sslHostConfig.getDisableSessionTickets()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_NO_TICKET);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_TICKET);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!disableSessionTicketsSupported) {\n                // OpenSSL is too old to support TLS Session Tickets.\n                log.warn(netSm.getString(\"endpoint.warn.noDisableSessionTickets\",\n                                      SSL.versionString()));\n            }\n\n            // Set session cache size, if specified\n            if (sslHostConfig.getSessionCacheSize() > 0) {\n                SSLContext.setSessionCacheSize(ctx, sslHostConfig.getSessionCacheSize());\n            } else {\n                // Get the default session cache size using SSLContext.setSessionCacheSize()\n                long sessionCacheSize = SSLContext.setSessionCacheSize(ctx, 20480);\n                // Revert the session cache size to the default value.\n                SSLContext.setSessionCacheSize(ctx, sessionCacheSize);\n            }\n\n            // Set session timeout, if specified\n            if (sslHostConfig.getSessionTimeout() > 0) {\n                SSLContext.setSessionCacheTimeout(ctx, sslHostConfig.getSessionTimeout());\n            } else {\n                // Get the default session timeout using SSLContext.setSessionCacheTimeout()\n                long sessionTimeout = SSLContext.setSessionCacheTimeout(ctx, 300);\n                // Revert the session timeout to the default value.\n                SSLContext.setSessionCacheTimeout(ctx, sessionTimeout);\n            }\n\n            // List the ciphers that the client is permitted to negotiate\n            String ciphers = sslHostConfig.getCiphers();\n            if (!(\"ALL\".equals(ciphers)) && ciphers.indexOf(':') == -1) {\n                StringTokenizer tok = new StringTokenizer(ciphers, \",\");\n                this.ciphers = new ArrayList<>();\n                while (tok.hasMoreTokens()) {\n                    String token = tok.nextToken().trim();\n                    if (!\"\".equals(token)) {\n                        this.ciphers.add(token);\n                    }\n                }\n                ciphers = CipherSuiteConverter.toOpenSsl(ciphers);\n            } else {\n                this.ciphers = OpenSSLCipherConfigurationParser.parseExpression(ciphers);\n            }\n            SSLContext.setCipherSuite(ctx, ciphers);\n            // Load Server key and certificate\n            SSLContext.setCertificate(ctx,\n                    SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()),\n                    SSLHostConfig.adjustRelativePath(certificate.getCertificateKeyFile()),\n                    certificate.getCertificateKeyPassword(), SSL.SSL_AIDX_RSA);\n            // Support Client Certificates\n            SSLContext.setCACertificate(ctx,\n                    SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile()),\n                    SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath()));\n            // Set revocation\n            SSLContext.setCARevocation(ctx,\n                    SSLHostConfig.adjustRelativePath(\n                            sslHostConfig.getCertificateRevocationListFile()),\n                    SSLHostConfig.adjustRelativePath(\n                            sslHostConfig.getCertificateRevocationListPath()));\n            // Client certificate verification\n            int value = 0;\n            switch (sslHostConfig.getCertificateVerification()) {\n            case NONE:\n                value = SSL.SSL_CVERIFY_NONE;\n                break;\n            case OPTIONAL:\n                value = SSL.SSL_CVERIFY_OPTIONAL;\n                break;\n            case OPTIONAL_NO_CA:\n                value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA;\n                break;\n            case REQUIRED:\n                value = SSL.SSL_CVERIFY_REQUIRE;\n                break;\n            }\n            SSLContext.setVerify(ctx, value, sslHostConfig.getCertificateVerificationDepth());\n\n            if (tms != null) {\n                final X509TrustManager manager = chooseTrustManager(tms);\n                SSLContext.setCertVerifyCallback(ctx, new CertificateVerifier() {\n                    @Override\n                    public boolean verify(long ssl, byte[][] chain, String auth) {\n                        X509Certificate[] peerCerts = certificates(chain);\n                        try {\n                            manager.checkClientTrusted(peerCerts, auth);\n                            return true;\n                        } catch (Exception e) {\n                            log.debug(sm.getString(\"openssl.certificateVerificationFailed\"), e);\n                        }\n                        return false;\n                    }\n                });\n            }\n\n            if (negotiableProtocols != null && negotiableProtocols.size() > 0) {\n                ArrayList<String> protocols = new ArrayList<>();\n                protocols.addAll(negotiableProtocols);\n                protocols.add(\"http/1.1\");\n                String[] protocolsArray = protocols.toArray(new String[0]);\n                SSLContext.setAlpnProtos(ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);\n                SSLContext.setNpnProtos(ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);\n            }\n\n            sessionContext = new OpenSSLServerSessionContext(ctx);\n            sslHostConfig.setOpenSslContext(Long.valueOf(ctx));\n            initialized = true;\n        } catch (Exception e) {\n            log.warn(sm.getString(\"openssl.errorSSLCtxInit\"), e);\n            destroyPools();\n        }\n    }","id":78790,"modified_method":"/**\n     * Setup the SSL_CTX\n     *\n     * @param kms Must contain a KeyManager of the type\n     * {@code OpenSSLKeyManager}\n     * @param tms\n     * @param sr Is not used for this implementation.\n     */\n    @Override\n    public synchronized void init(KeyManager[] kms, TrustManager[] tms, SecureRandom sr) {\n        if (initialized) {\n            log.warn(sm.getString(\"openssl.doubleInit\"));\n            return;\n        }\n        try {\n            boolean legacyRenegSupported = false;\n            try {\n                legacyRenegSupported = SSL.hasOp(SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                if (legacyRenegSupported)\n                    if (sslHostConfig.getInsecureRenegotiation()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);\n                    }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!legacyRenegSupported) {\n                // OpenSSL does not support unsafe legacy renegotiation.\n                log.warn(netSm.getString(\"endpoint.warn.noInsecureReneg\",\n                                      SSL.versionString()));\n            }\n            // Use server's preference order for ciphers (rather than\n            // client's)\n            boolean orderCiphersSupported = false;\n            try {\n                orderCiphersSupported = SSL.hasOp(SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                if (orderCiphersSupported) {\n                    if (sslHostConfig.getHonorCipherOrder()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_CIPHER_SERVER_PREFERENCE);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!orderCiphersSupported) {\n                // OpenSSL does not support ciphers ordering.\n                log.warn(netSm.getString(\"endpoint.warn.noHonorCipherOrder\",\n                                      SSL.versionString()));\n            }\n\n            // Disable compression if requested\n            boolean disableCompressionSupported = false;\n            try {\n                disableCompressionSupported = SSL.hasOp(SSL.SSL_OP_NO_COMPRESSION);\n                if (disableCompressionSupported) {\n                    if (sslHostConfig.getDisableCompression()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_COMPRESSION);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!disableCompressionSupported) {\n                // OpenSSL does not support ciphers ordering.\n                log.warn(netSm.getString(\"endpoint.warn.noDisableCompression\",\n                                      SSL.versionString()));\n            }\n\n            // Disable TLS Session Tickets (RFC4507) to protect perfect forward secrecy\n            boolean disableSessionTicketsSupported = false;\n            try {\n                disableSessionTicketsSupported = SSL.hasOp(SSL.SSL_OP_NO_TICKET);\n                if (disableSessionTicketsSupported) {\n                    if (sslHostConfig.getDisableSessionTickets()) {\n                        SSLContext.setOptions(ctx, SSL.SSL_OP_NO_TICKET);\n                    } else {\n                        SSLContext.clearOptions(ctx, SSL.SSL_OP_NO_TICKET);\n                    }\n                }\n            } catch (UnsatisfiedLinkError e) {\n                // Ignore\n            }\n            if (!disableSessionTicketsSupported) {\n                // OpenSSL is too old to support TLS Session Tickets.\n                log.warn(netSm.getString(\"endpoint.warn.noDisableSessionTickets\",\n                                      SSL.versionString()));\n            }\n\n            // Set session cache size, if specified\n            if (sslHostConfig.getSessionCacheSize() > 0) {\n                SSLContext.setSessionCacheSize(ctx, sslHostConfig.getSessionCacheSize());\n            } else {\n                // Get the default session cache size using SSLContext.setSessionCacheSize()\n                long sessionCacheSize = SSLContext.setSessionCacheSize(ctx, 20480);\n                // Revert the session cache size to the default value.\n                SSLContext.setSessionCacheSize(ctx, sessionCacheSize);\n            }\n\n            // Set session timeout, if specified\n            if (sslHostConfig.getSessionTimeout() > 0) {\n                SSLContext.setSessionCacheTimeout(ctx, sslHostConfig.getSessionTimeout());\n            } else {\n                // Get the default session timeout using SSLContext.setSessionCacheTimeout()\n                long sessionTimeout = SSLContext.setSessionCacheTimeout(ctx, 300);\n                // Revert the session timeout to the default value.\n                SSLContext.setSessionCacheTimeout(ctx, sessionTimeout);\n            }\n\n            // List the ciphers that the client is permitted to negotiate\n            String ciphers = sslHostConfig.getCiphers();\n            if (!(\"ALL\".equals(ciphers)) && ciphers.indexOf(':') == -1) {\n                StringTokenizer tok = new StringTokenizer(ciphers, \",\");\n                this.ciphers = new ArrayList<>();\n                while (tok.hasMoreTokens()) {\n                    String token = tok.nextToken().trim();\n                    if (!\"\".equals(token)) {\n                        this.ciphers.add(token);\n                    }\n                }\n                ciphers = CipherSuiteConverter.toOpenSsl(ciphers);\n            } else {\n                this.ciphers = OpenSSLCipherConfigurationParser.parseExpression(ciphers);\n            }\n            SSLContext.setCipherSuite(ctx, ciphers);\n            // Load Server key and certificate\n            if (certificate.getCertificateFile() != null) {\n            \t\n            \tSSLContext.setCertificate(ctx,\n                        SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()),\n                        SSLHostConfig.adjustRelativePath(certificate.getCertificateKeyFile()),\n                        certificate.getCertificateKeyPassword(), SSL.SSL_AIDX_RSA);\n            \t\n                // Support Client Certificates\n                \n                SSLContext.setCACertificate(ctx,\n                        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificateFile()),\n                        SSLHostConfig.adjustRelativePath(sslHostConfig.getCaCertificatePath()));\n                // Set revocation\n                SSLContext.setCARevocation(ctx,\n                        SSLHostConfig.adjustRelativePath(\n                                sslHostConfig.getCertificateRevocationListFile()),\n                        SSLHostConfig.adjustRelativePath(\n                                sslHostConfig.getCertificateRevocationListPath()));\n            } else {\n                /* Try use keystore */\n                X509KeyManager keyManager = getJSSEKeyManager(sslHostConfig);\n                String alias = getJSSEAlias(sslHostConfig, keyManager);\n                X509Certificate certificate = keyManager.getCertificateChain(alias)[0];\n                PrivateKey key = keyManager.getPrivateKey(alias);\n                StringBuilder sb = new StringBuilder(BEGIN_KEY);\n                sb.append(Base64.getMimeEncoder(64, new byte[] {'\\n'}).encodeToString(key.getEncoded()));       \n                sb.append(END_KEY);\n                SSLContext.setCertificateRaw(ctx, certificate.getEncoded(), sb.toString().getBytes(StandardCharsets.US_ASCII), SSL.SSL_AIDX_RSA);\n                \n            }\n            // Client certificate verification\n            int value = 0;\n            switch (sslHostConfig.getCertificateVerification()) {\n            case NONE:\n                value = SSL.SSL_CVERIFY_NONE;\n                break;\n            case OPTIONAL:\n                value = SSL.SSL_CVERIFY_OPTIONAL;\n                break;\n            case OPTIONAL_NO_CA:\n                value = SSL.SSL_CVERIFY_OPTIONAL_NO_CA;\n                break;\n            case REQUIRED:\n                value = SSL.SSL_CVERIFY_REQUIRE;\n                break;\n            }\n            SSLContext.setVerify(ctx, value, sslHostConfig.getCertificateVerificationDepth());\n\n            if (tms != null) {\n                final X509TrustManager manager = chooseTrustManager(tms);\n                SSLContext.setCertVerifyCallback(ctx, new CertificateVerifier() {\n                    @Override\n                    public boolean verify(long ssl, byte[][] chain, String auth) {\n                        X509Certificate[] peerCerts = certificates(chain);\n                        try {\n                            manager.checkClientTrusted(peerCerts, auth);\n                            return true;\n                        } catch (Exception e) {\n                            log.debug(sm.getString(\"openssl.certificateVerificationFailed\"), e);\n                        }\n                        return false;\n                    }\n                });\n            }\n\n            if (negotiableProtocols != null && negotiableProtocols.size() > 0) {\n                ArrayList<String> protocols = new ArrayList<>();\n                protocols.addAll(negotiableProtocols);\n                protocols.add(\"http/1.1\");\n                String[] protocolsArray = protocols.toArray(new String[0]);\n                SSLContext.setAlpnProtos(ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);\n                SSLContext.setNpnProtos(ctx, protocolsArray, SSL.SSL_SELECTOR_FAILURE_NO_ADVERTISE);\n            }\n\n            sessionContext = new OpenSSLServerSessionContext(ctx);\n            sslHostConfig.setOpenSslContext(Long.valueOf(ctx));\n            initialized = true;\n        } catch (Exception e) {\n            log.warn(sm.getString(\"openssl.errorSSLCtxInit\"), e);\n            destroyPools();\n        }\n    }","commit_id":"881618f787926b84bc7b1913ebc52bede4c5a305","url":"https://github.com/apache/tomcat"},{"original_method":"public OpenSSLContext(SSLHostConfig sslHostConfig, SSLHostConfigCertificate certificate, List<String> negotiableProtocols)\n            throws SSLException {\n        this.sslHostConfig = sslHostConfig;\n        this.certificate = certificate;\n        aprPool = Pool.create(0);\n        boolean success = false;\n        try {\n            if (SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()) == null) {\n                // This is required\n                throw new Exception(netSm.getString(\"endpoint.apr.noSslCertFile\"));\n            }\n\n            // SSL protocol\n            int value = SSL.SSL_PROTOCOL_NONE;\n            if (sslHostConfig.getProtocols().size() == 0) {\n                value = SSL.SSL_PROTOCOL_ALL;\n            } else {\n                for (String protocol : sslHostConfig.getProtocols()) {\n                    if (Constants.SSL_PROTO_SSLv2Hello.equalsIgnoreCase(protocol)) {\n                        // NO-OP. OpenSSL always supports SSLv2Hello\n                    } else if (Constants.SSL_PROTO_SSLv2.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_SSLV2;\n                    } else if (Constants.SSL_PROTO_SSLv3.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_SSLV3;\n                    } else if (Constants.SSL_PROTO_TLSv1.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_TLSV1;\n                    } else if (Constants.SSL_PROTO_TLSv1_1.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_TLSV1_1;\n                    } else if (Constants.SSL_PROTO_TLSv1_2.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_TLSV1_2;\n                    } else if (Constants.SSL_PROTO_ALL.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_ALL;\n                    } else {\n                        // Protocol not recognized, fail to start as it is safer than\n                        // continuing with the default which might enable more than the\n                        // is required\n                        throw new Exception(netSm.getString(\n                                \"endpoint.apr.invalidSslProtocol\", protocol));\n                    }\n                }\n            }\n\n            // Create SSL Context\n            try {\n                ctx = SSLContext.make(aprPool, value, SSL.SSL_MODE_SERVER);\n            } catch (Exception e) {\n                // If the sslEngine is disabled on the AprLifecycleListener\n                // there will be an Exception here but there is no way to check\n                // the AprLifecycleListener settings from here\n                throw new Exception(\n                        netSm.getString(\"endpoint.apr.failSslContextMake\"), e);\n            }\n\n            this.negotiableProtocols = negotiableProtocols;\n\n            success = true;\n        } catch(Exception e) {\n            throw new SSLException(sm.getString(\"openssl.errorSSLCtxInit\"), e);\n        } finally {\n            if (!success) {\n                destroyPools();\n            }\n        }\n    }","id":78791,"modified_method":"public OpenSSLContext(SSLHostConfig sslHostConfig, SSLHostConfigCertificate certificate, List<String> negotiableProtocols)\n            throws SSLException {\n        this.sslHostConfig = sslHostConfig;\n        this.certificate = certificate;\n        aprPool = Pool.create(0);\n        boolean success = false;\n        try {\n            if (SSLHostConfig.adjustRelativePath(certificate.getCertificateFile()) == null) {\n                // This is required\n                // throw new Exception(netSm.getString(\"endpoint.apr.noSslCertFile\"));\n            }\n\n            // SSL protocol\n            int value = SSL.SSL_PROTOCOL_NONE;\n            if (sslHostConfig.getProtocols().size() == 0) {\n                value = SSL.SSL_PROTOCOL_ALL;\n            } else {\n                for (String protocol : sslHostConfig.getProtocols()) {\n                    if (Constants.SSL_PROTO_SSLv2Hello.equalsIgnoreCase(protocol)) {\n                        // NO-OP. OpenSSL always supports SSLv2Hello\n                    } else if (Constants.SSL_PROTO_SSLv2.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_SSLV2;\n                    } else if (Constants.SSL_PROTO_SSLv3.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_SSLV3;\n                    } else if (Constants.SSL_PROTO_TLSv1.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_TLSV1;\n                    } else if (Constants.SSL_PROTO_TLSv1_1.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_TLSV1_1;\n                    } else if (Constants.SSL_PROTO_TLSv1_2.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_TLSV1_2;\n                    } else if (Constants.SSL_PROTO_ALL.equalsIgnoreCase(protocol)) {\n                        value |= SSL.SSL_PROTOCOL_ALL;\n                    } else {\n                        // Protocol not recognized, fail to start as it is safer than\n                        // continuing with the default which might enable more than the\n                        // is required\n                        throw new Exception(netSm.getString(\n                                \"endpoint.apr.invalidSslProtocol\", protocol));\n                    }\n                }\n            }\n\n            // Create SSL Context\n            try {\n                ctx = SSLContext.make(aprPool, value, SSL.SSL_MODE_SERVER);\n            } catch (Exception e) {\n                // If the sslEngine is disabled on the AprLifecycleListener\n                // there will be an Exception here but there is no way to check\n                // the AprLifecycleListener settings from here\n                throw new Exception(\n                        netSm.getString(\"endpoint.apr.failSslContextMake\"), e);\n            }\n\n            this.negotiableProtocols = negotiableProtocols;\n\n            success = true;\n        } catch(Exception e) {\n            throw new SSLException(sm.getString(\"openssl.errorSSLCtxInit\"), e);\n        } finally {\n            if (!success) {\n                destroyPools();\n            }\n        }\n    }","commit_id":"881618f787926b84bc7b1913ebc52bede4c5a305","url":"https://github.com/apache/tomcat"},{"original_method":"OpenSSLKeyManager(String certChainFile, String keyFile) {\n        if (certChainFile == null) {\n            throw new IllegalArgumentException(sm.getString(\"keyManager.nullCertificateChain\"));\n        }\n        if (keyFile == null) {\n            throw new IllegalArgumentException(sm.getString(\"keyManager.nullPrivateKey\"));\n        }\n        this.certificateChain = new File(certChainFile);\n        this.privateKey = new File(keyFile);\n    }","id":78792,"modified_method":"OpenSSLKeyManager(String certChainFile, String keyFile) {\n        if (certChainFile == null) {\n            return;\n        }\n        if (keyFile == null) {\n            return;\n        }\n        this.certificateChain = new File(certChainFile);\n        this.privateKey = new File(keyFile);\n    }","commit_id":"881618f787926b84bc7b1913ebc52bede4c5a305","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Check that a WSSecurityEngineResult corresponding to a signature or encryption uses the same \n     * signing/encrypting credential as one of the tokens.\n     * @param signatureResult a WSSecurityEngineResult corresponding to a signature or encryption\n     * @param tokenResult A list of WSSecurityEngineResults corresponding to tokens\n     * @return \n     */\n    private boolean checkSignatureOrEncryptionResult(\n        WSSecurityEngineResult result,\n        List<WSSecurityEngineResult> tokenResult\n    ) {\n        // See what was used to sign/encrypt this result\n        X509Certificate cert = \n            (X509Certificate)result.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        byte[] secret = (byte[])result.get(WSSecurityEngineResult.TAG_SECRET);\n        \n        // Now see if the same credential exists in the tokenResult list\n        for (WSSecurityEngineResult token : tokenResult) {\n            Integer actInt = (Integer)token.get(WSSecurityEngineResult.TAG_ACTION);\n            BinarySecurity binarySecurity = \n                (BinarySecurity)token.get(WSSecurityEngineResult.TAG_BINARY_SECURITY_TOKEN);\n            PublicKey publicKey = \n                (PublicKey)token.get(WSSecurityEngineResult.TAG_PUBLIC_KEY);\n            if (binarySecurity instanceof X509Security\n                || binarySecurity instanceof PKIPathSecurity) {\n                X509Certificate foundCert = \n                    (X509Certificate)token.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n                if (foundCert.equals(cert)) {\n                    return true;\n                }\n            } else if (actInt.intValue() == WSConstants.ST_SIGNED\n                || actInt.intValue() == WSConstants.ST_UNSIGNED) {\n                AssertionWrapper assertionWrapper = \n                    (AssertionWrapper)token.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n                SAMLKeyInfo samlKeyInfo = assertionWrapper.getSubjectKeyInfo();\n                if (samlKeyInfo != null) {\n                    X509Certificate[] subjectCerts = samlKeyInfo.getCerts();\n                    byte[] subjectSecretKey = samlKeyInfo.getSecret();\n                    if (cert != null && subjectCerts != null && cert.equals(subjectCerts[0])) {\n                        return true;\n                    }\n                    if (subjectSecretKey != null && Arrays.equals(subjectSecretKey, secret)) {\n                        return true;\n                    }\n                }\n            } else if (publicKey != null) {\n                PublicKey foundPublicKey = \n                    (PublicKey)token.get(WSSecurityEngineResult.TAG_PUBLIC_KEY);\n                if (publicKey.equals(foundPublicKey)) {\n                    return true;\n                }\n            } else {\n                byte[] foundSecret = (byte[])token.get(WSSecurityEngineResult.TAG_SECRET);\n                byte[] derivedKey = \n                    (byte[])token.get(WSSecurityEngineResult.TAG_ENCRYPTED_EPHEMERAL_KEY);\n                if ((foundSecret != null && Arrays.equals(foundSecret, secret))\n                    || (derivedKey != null && Arrays.equals(derivedKey, secret))) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }","id":78793,"modified_method":"/**\n     * Check that a WSSecurityEngineResult corresponding to a signature or encryption uses the same \n     * signing/encrypting credential as one of the tokens.\n     * @param signatureResult a WSSecurityEngineResult corresponding to a signature or encryption\n     * @param tokenResult A list of WSSecurityEngineResults corresponding to tokens\n     * @return \n     */\n    private boolean checkSignatureOrEncryptionResult(\n        WSSecurityEngineResult result,\n        List<WSSecurityEngineResult> tokenResult\n    ) {\n        // See what was used to sign/encrypt this result\n        X509Certificate cert = \n            (X509Certificate)result.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n        byte[] secret = (byte[])result.get(WSSecurityEngineResult.TAG_SECRET);\n        PublicKey publicKey = \n            (PublicKey)result.get(WSSecurityEngineResult.TAG_PUBLIC_KEY);\n        \n        // Now see if the same credential exists in the tokenResult list\n        for (WSSecurityEngineResult token : tokenResult) {\n            Integer actInt = (Integer)token.get(WSSecurityEngineResult.TAG_ACTION);\n            BinarySecurity binarySecurity = \n                (BinarySecurity)token.get(WSSecurityEngineResult.TAG_BINARY_SECURITY_TOKEN);\n            if (binarySecurity instanceof X509Security\n                || binarySecurity instanceof PKIPathSecurity) {\n                X509Certificate foundCert = \n                    (X509Certificate)token.get(WSSecurityEngineResult.TAG_X509_CERTIFICATE);\n                if (foundCert.equals(cert)) {\n                    return true;\n                }\n            } else if (actInt.intValue() == WSConstants.ST_SIGNED\n                || actInt.intValue() == WSConstants.ST_UNSIGNED) {\n                AssertionWrapper assertionWrapper = \n                    (AssertionWrapper)token.get(WSSecurityEngineResult.TAG_SAML_ASSERTION);\n                SAMLKeyInfo samlKeyInfo = assertionWrapper.getSubjectKeyInfo();\n                if (samlKeyInfo != null) {\n                    X509Certificate[] subjectCerts = samlKeyInfo.getCerts();\n                    byte[] subjectSecretKey = samlKeyInfo.getSecret();\n                    PublicKey subjectPublicKey = samlKeyInfo.getPublicKey();\n                    if ((cert != null && subjectCerts != null && cert.equals(subjectCerts[0]))\n                        || (subjectSecretKey != null && Arrays.equals(subjectSecretKey, secret))\n                        || (subjectPublicKey != null && subjectPublicKey.equals(publicKey))) {\n                        return true;\n                    }\n                }\n            } else if (publicKey != null) {\n                PublicKey foundPublicKey = \n                    (PublicKey)token.get(WSSecurityEngineResult.TAG_PUBLIC_KEY);\n                if (publicKey.equals(foundPublicKey)) {\n                    return true;\n                }\n            } else {\n                byte[] foundSecret = (byte[])token.get(WSSecurityEngineResult.TAG_SECRET);\n                byte[] derivedKey = \n                    (byte[])token.get(WSSecurityEngineResult.TAG_ENCRYPTED_EPHEMERAL_KEY);\n                if ((foundSecret != null && Arrays.equals(foundSecret, secret))\n                    || (derivedKey != null && Arrays.equals(derivedKey, secret))) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }","commit_id":"95acb465f110e299c03247feb12640ac5b0fa61a","url":"https://github.com/apache/cxf"},{"original_method":"protected KeyInfoBean createKeyInfo() throws Exception {\n        Crypto crypto = \n            CryptoFactory.getInstance(\"org/apache/cxf/systest/ws/wssec10/client/alice.properties\");\n        CryptoType cryptoType = new CryptoType(CryptoType.TYPE.ALIAS);\n        cryptoType.setAlias(\"alice\");\n        X509Certificate[] certs = crypto.getX509Certificates(cryptoType);\n        \n        KeyInfoBean keyInfo = new KeyInfoBean();\n        keyInfo.setCertificate(certs[0]);\n        keyInfo.setCertIdentifer(CERT_IDENTIFIER.X509_CERT);\n        \n        return keyInfo;\n    }","id":78794,"modified_method":"protected KeyInfoBean createKeyInfo() throws Exception {\n        Crypto crypto = \n            CryptoFactory.getInstance(\"org/apache/cxf/systest/ws/wssec10/client/alice.properties\");\n        CryptoType cryptoType = new CryptoType(CryptoType.TYPE.ALIAS);\n        cryptoType.setAlias(\"alice\");\n        X509Certificate[] certs = crypto.getX509Certificates(cryptoType);\n        \n        KeyInfoBean keyInfo = new KeyInfoBean();\n        keyInfo.setCertIdentifer(keyInfoIdentifier);\n        if (keyInfoIdentifier == CERT_IDENTIFIER.X509_CERT) {\n            keyInfo.setCertificate(certs[0]);\n        } else if (keyInfoIdentifier == CERT_IDENTIFIER.KEY_VALUE) {\n            keyInfo.setPublicKey(certs[0].getPublicKey());\n        }\n        \n        return keyInfo;\n    }","commit_id":"95acb465f110e299c03247feb12640ac5b0fa61a","url":"https://github.com/apache/cxf"},{"original_method":"@Override\r\n  protected boolean run() {\r\n    final IO io = IO.get(args[0]);\r\n    if(!io.exists()) return error(FILEWHICH, io);\r\n\r\n    final String name = io.name();\r\n    final String dbname = io.dbname();\r\n\r\n    final DirParser p = new DirParser(io, context.prop, path(args[1]));\r\n    try {\r\n      final MemData d = new MemBuilder(p, context.prop).build(dbname);\r\n      final Data data = context.data;\r\n      data.insert(data.meta.size, -1, d);\r\n      data.flush();\r\n    } catch(final IOException ex) {\r\n      Main.debug(ex);\r\n      final String msg = ex.getMessage();\r\n      return error(msg != null ? msg : name);\r\n    }\r\n\r\n    context.update();\r\n    return info(PATHADDED, name, perf);\r\n  }","id":78795,"modified_method":"@Override\r\n  protected boolean run() {\r\n    final IO io = IO.get(args[0]);\r\n    if(!io.exists()) return error(FILEWHICH, io);\r\n\r\n    final String name = io.name();\r\n    final String db = io.dbname();\r\n\r\n    final DirParser p = new DirParser(io, context.prop, path(args[1]));\r\n    try {\r\n      final Data data = context.data;\r\n      data.insert(data.meta.size, -1, MemBuilder.build(p, context.prop, db));\r\n      data.flush();\r\n    } catch(final IOException ex) {\r\n      Main.debug(ex);\r\n      final String msg = ex.getMessage();\r\n      return error(msg != null ? msg : name);\r\n    }\r\n\r\n    context.update();\r\n    return info(PATHADDED, name, perf);\r\n  }","commit_id":"c71b8dcc05b72749d4efe092f1144f65243643b2","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Document parse(final InputSource is) throws IOException {\n    final SAXSource source = new SAXSource(parser, is);\n    final String id = is.getSystemId();\n    final MemBuilder mb = new MemBuilder(new SAXWrapper(source, \"\"), ctx.prop);\n    return new BXDoc(new DBNode(mb.build(id == null ? \"\" : id), 0));\n  }","id":78796,"modified_method":"@Override\n  public Document parse(final InputSource is) throws IOException {\n    final String id = is.getSystemId();\n    final SAXWrapper p = new SAXWrapper(new SAXSource(parser, is), \"\");\n    final Data data = MemBuilder.build(p, ctx.prop, id == null ? \"\" : id);\n    return new BXDoc(new DBNode(data, 0));\n  }","commit_id":"c71b8dcc05b72749d4efe092f1144f65243643b2","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void parse() throws IOException {\r\n    builder.startElem(CSV, atts);\r\n\r\n    boolean quoted = false;\r\n    boolean nl = true;\r\n    final TokenBuilder tb = new TokenBuilder();\r\n\r\n    final BufferInput bi = new BufferInput(file.path());\r\n    bi.encoding(encoding);\r\n\r\n    int r = 0;\r\n    int c = 0;\r\n    int ch = 0;\r\n    while(true) {\r\n      if(ch == 0) ch = bi.readChar();\r\n      if(ch == 0) break;\r\n\r\n      if(quoted) {\r\n        if(ch == '\"') {\r\n          ch = bi.readChar();\r\n          if(ch != '\"') {\r\n            quoted = false;\r\n            continue;\r\n          }\r\n        }\r\n        if(ch != 0x0D) tb.addUTF(ch);\r\n      } else {\r\n        // separator\r\n        if(ch == separator) {\r\n          if(nl) {\r\n            record(r++);\r\n            nl = false;\r\n          }\r\n          field(tb, c++);\r\n        } else if(ch == 0x0A) {\r\n          field(tb, c++);\r\n          builder.endElem(RECORD);\r\n          c = 0;\r\n          nl = true;\r\n        } else if(ch == '\"') {\r\n          quoted = true;\r\n        } else if(ch != 0x0D) {\r\n          tb.addUTF(ch);\r\n        }\r\n      }\r\n      ch = 0;\r\n    }\r\n    bi.close();\r\n\r\n    if(!nl) builder.endElem(RECORD);\r\n    builder.endElem(CSV);\r\n  }","id":78797,"modified_method":"@Override\r\n  public void parse() throws IOException {\r\n    builder.startElem(CSV, atts);\r\n\r\n    boolean quoted = false;\r\n    boolean nl = true;\r\n    final TokenBuilder tb = new TokenBuilder();\r\n\r\n    final BufferInput bi = new BufferInput(file.path());\r\n    bi.encoding(encoding);\r\n\r\n    int r = 0;\r\n    int c = 0;\r\n    int ch = 0;\r\n    while(true) {\r\n      if(ch == 0) ch = bi.readChar();\r\n      if(ch == 0) break;\r\n\r\n      if(quoted) {\r\n        if(ch == '\"') {\r\n          ch = bi.readChar();\r\n          if(ch != '\"') {\r\n            quoted = false;\r\n            continue;\r\n          }\r\n        }\r\n        if(ch != 0x0D) tb.addUTF(ch);\r\n      } else {\r\n        // separator\r\n        if(ch == separator) {\r\n          if(nl) {\r\n            record(r++);\r\n            nl = false;\r\n          }\r\n          field(tb, c++);\r\n        } else if(ch == 0x0A) {\r\n          field(tb, c++);\r\n          if(!nl) {\r\n            builder.endElem(RECORD);\r\n            nl = true;\r\n          }\r\n          c = 0;\r\n        } else if(ch == '\"') {\r\n          quoted = true;\r\n        } else if(ch != 0x0D) {\r\n          tb.addUTF(ch);\r\n        }\r\n      }\r\n      ch = 0;\r\n    }\r\n    bi.close();\r\n\r\n    if(!nl) builder.endElem(RECORD);\r\n    builder.endElem(CSV);\r\n  }","commit_id":"c71b8dcc05b72749d4efe092f1144f65243643b2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Creates a main-memory database for the specified parser.\n   * @param p xml parser\n   * @param ctx database context\n   * @return database instance\n   * @throws IOException I/O exception\n   */\n  public static synchronized Data xml(final Parser p, final Context ctx)\n      throws IOException {\n    return new MemBuilder(p, ctx.prop).build();\n  }","id":78798,"modified_method":"/**\n   * Creates a main-memory database for the specified parser.\n   * @param p xml parser\n   * @param ctx database context\n   * @return database instance\n   * @throws IOException I/O exception\n   */\n  public static synchronized Data xml(final Parser p, final Context ctx)\n      throws IOException {\n    return MemBuilder.build(p, ctx.prop);\n  }","commit_id":"c71b8dcc05b72749d4efe092f1144f65243643b2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Creates a database instance from the specified parser.\n   * @param p xml parser\n   * @param db name of the database\n   * @param ctx database context\n   * @return database instance\n   * @throws IOException I/O exception\n   */\n  public static synchronized Data xml(final Parser p, final String db,\n      final Context ctx) throws IOException {\n\n    if(ctx.prop.is(Prop.MAINMEM)) return new MemBuilder(p, ctx.prop).build(db);\n    if(ctx.pinned(db)) throw new IOException(Main.info(DBLOCKED, db));\n\n    final Builder builder = new DiskBuilder(p, ctx.prop);\n    try {\n      final Data data = builder.build(db);\n      if(data.meta.txtindex) data.setIndex(IndexType.TXT,\n        new ValueBuilder(data, true).build());\n      if(data.meta.atvindex) data.setIndex(IndexType.ATV,\n        new ValueBuilder(data, false).build());\n      if(data.meta.ftxindex) data.setIndex(IndexType.FTX,\n        FTBuilder.get(data, data.meta.wildcards).build());\n      data.close();\n    } catch(final IOException ex) {\n      try {\n        builder.close();\n      } catch(final IOException exx) {\n        Main.debug(exx);\n      }\n      throw ex;\n    }\n    return Open.open(ctx, db);\n  }","id":78799,"modified_method":"/**\n   * Creates a database instance from the specified parser.\n   * @param p xml parser\n   * @param db name of the database\n   * @param ctx database context\n   * @return database instance\n   * @throws IOException I/O exception\n   */\n  public static synchronized Data xml(final Parser p, final String db,\n      final Context ctx) throws IOException {\n\n    if(ctx.prop.is(Prop.MAINMEM)) return MemBuilder.build(p, ctx.prop, db);\n    if(ctx.pinned(db)) throw new IOException(Main.info(DBLOCKED, db));\n\n    final Builder builder = new DiskBuilder(p, ctx.prop);\n    try {\n      final Data data = builder.build(db);\n      if(data.meta.txtindex) data.setIndex(IndexType.TXT,\n        new ValueBuilder(data, true).build());\n      if(data.meta.atvindex) data.setIndex(IndexType.ATV,\n        new ValueBuilder(data, false).build());\n      if(data.meta.ftxindex) data.setIndex(IndexType.FTX,\n        FTBuilder.get(data, data.meta.wildcards).build());\n      data.close();\n    } catch(final IOException ex) {\n      try {\n        builder.close();\n      } catch(final IOException exx) {\n        Main.debug(exx);\n      }\n      throw ex;\n    }\n    return Open.open(ctx, db);\n  }","commit_id":"c71b8dcc05b72749d4efe092f1144f65243643b2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Initializes the thesaurus.\r\n   * @return success flag\r\n   * @throws QueryException query exception\r\n   */\r\n  private boolean init() throws QueryException {\r\n    try {\r\n      final Data data = new MemBuilder(\r\n          Parser.fileParser(file, ctx.prop, \"\"), ctx.prop).build();\r\n      final Nodes result = nodes(\"//*:entry\", new Nodes(0, data));\r\n      for(int n = 0; n < result.size(); n++) {\r\n        build(new Nodes(result.nodes[n], data));\r\n      }\r\n    } catch(final IOException ex) {\r\n      Err.or(NOTHES, file);\r\n    }\r\n    return true;\r\n  }","id":78800,"modified_method":"/**\r\n   * Initializes the thesaurus.\r\n   * @return success flag\r\n   * @throws QueryException query exception\r\n   */\r\n  private boolean init() throws QueryException {\r\n    try {\r\n      final Data data = MemBuilder.build(\r\n          Parser.fileParser(file, ctx.prop, \"\"), ctx.prop);\r\n      final Nodes result = nodes(\"//*:entry\", new Nodes(0, data));\r\n      for(int n = 0; n < result.size(); n++) {\r\n        build(new Nodes(result.nodes[n], data));\r\n      }\r\n    } catch(final IOException ex) {\r\n      Err.or(NOTHES, file);\r\n    }\r\n    return true;\r\n  }","commit_id":"c71b8dcc05b72749d4efe092f1144f65243643b2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks if the document is well-formed and returns the corresponding main\n   * memory database.\n   * @param f the {@link BufferedFileChannel} to read the xml document from\n   * @param prop the database properties to use\n   * @return the main-memory database or {@code null} if the document is\n   *         not well-formed\n   * @throws IOException if any error occurs\n   */\n  public Data parse(final BufferedFileChannel f, final Prop prop)\n      throws IOException {\n\n    if(f.size() > Integer.MAX_VALUE)\n     throw new IOException(\"Input file too big.\");\n\n    try {\n      final byte[] data = f.get(new byte[(int) f.size()]);\n      final Parser p = Parser.fileParser(new IOContent(data), prop, \"\");\n      return new MemBuilder(p, prop).build();\n    } catch(final IOException ex) {\n      // XML parsing exception...\n      return null;\n    }\n  }","id":78801,"modified_method":"/**\n   * Checks if the document is well-formed and returns the corresponding main\n   * memory database.\n   * @param f the {@link BufferedFileChannel} to read the xml document from\n   * @param prop the database properties to use\n   * @return the main-memory database or {@code null} if the document is\n   *         not well-formed\n   * @throws IOException if any error occurs\n   */\n  public Data parse(final BufferedFileChannel f, final Prop prop)\n      throws IOException {\n\n    if(f.size() > Integer.MAX_VALUE)\n     throw new IOException(\"Input file too big.\");\n\n    try {\n      final byte[] data = f.get(new byte[(int) f.size()]);\n      final Parser p = Parser.fileParser(new IOContent(data), prop, \"\");\n      return MemBuilder.build(p, prop);\n    } catch(final IOException ex) {\n      // XML parsing exception...\n      return null;\n    }\n  }","commit_id":"c71b8dcc05b72749d4efe092f1144f65243643b2","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Deletes a file node.\n   * @param path of file to delete\n   * @param dir is directory\n   * @throws QueryException on failure\n   * @return zero on success, -1 on failure\n   */\n  private int delete(final String path, final boolean dir)\n      throws QueryException {\n    Nodes n = xquery(pn2xp(path, dir));\n    if(n.size() == 0) return -1;\n    else {\n      data.delete(n.nodes[0]);\n      refresh();\n    }\n    return 0;\n  }","id":78802,"modified_method":"/**\n   * Deletes a file node.\n   * @param path of file to delete\n   * @param dir is directory\n   * @param cont delete only content of file\n   * @return zero on success, -1 on failure\n   */\n  private int delete(final String path, final boolean dir, final boolean cont) {\n    try {\n      final StringBuilder qb = new StringBuilder();\n      qb.append(pn2xp(path, dir));\n      if(!dir && cont) qb.append(\"/content\");\n      Nodes n = xquery(qb.toString());\n      if(n.size() == 0) return -1;\n      else {\n        data.delete(n.nodes[0]);\n        refresh();\n      }\n    } catch(QueryException e) {\n      e.printStackTrace();\n      return -1;\n    }\n    return 0;\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Refreshes the data reference and GUI.\n   */\n  private void refresh() {\n    data.meta.update();\n    data.flush();\n    gui.notify.update();\n  }","id":78803,"modified_method":"/**\n   * Refreshes the data reference and GUI.\n   */\n  private void refresh() {\n    data.meta.update();\n    data.flush();\n    if (wgui) gui.notify.update();\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public int destroy() {\n    try {\n      data.close();\n      return 0;\n    } catch(IOException e) {\n      e.printStackTrace();\n      return -1;\n    }\n  }","id":78804,"modified_method":"@Override\n  public int destroy() {\n    try {\n      if (wgui) gui.dispose();\n      data.close();\n      return 0;\n    } catch(IOException e) {\n      e.printStackTrace();\n      return -1;\n    }\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Insert MemData at given path position.\n   * @param path at which to insert (content or file)\n   * @param md memory data insert to insert\n   * @return pre value of newly inserted node\n   * @throws QueryException in case of failure\n   */\n  private int insert(final String path, final MemData md) \n    throws QueryException {\n    int ppre = parentPre(path);\n    if(ppre == -1) return -1;\n    int npre = ppre + data.size(ppre, data.kind(ppre));\n    data.insert(npre, ppre, md);\n    refresh();\n    return npre;\n  }","id":78805,"modified_method":"/**\n   * Insert MemData at given pre position and refresh GUI.\n   * @param pre value at which to insert (content or file)\n   * @param md memory data insert to insert\n   * @return pre value of newly inserted node\n   */\n  private int insert(final int pre, final MemData md) {\n    int npre = pre + data.size(pre, data.kind(pre));\n    data.insert(npre, pre, md);\n    refresh();\n    return npre;\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * \n   * @param mountPoint mount point of DeepFUSE\n   * @param backingStore backing storage root path\n   * @param dbName of the database to open/create\n   */\n  public DeepBase(final String mountPoint, final String backingStore,\n      final String dbName) {\n    mountpoint = mountPoint;\n    dbname = dbName;\n    backingstore = backingStore;\n  \n    final BaseXWin win = new BaseXWin(new String[] {});\n    init();\n  \n    while(win.gui == null)\n      Performance.sleep(100);\n    gui = win.gui;\n    gui.context.data(data);\n    gui.notify.init();\n  }","id":78806,"modified_method":"/**\n   * Constructor.\n   * \n   * @param mountPoint mount point of DeepFUSE\n   * @param backingStore backing storage root path\n   * @param dbName of the database to open/create\n   * @param guitoggle whether BaseXWin is wanted or not\n   */\n  public DeepBase(final String mountPoint, final String backingStore,\n      final String dbName, final boolean guitoggle) {\n    mountpoint = mountPoint;\n    dbname = dbName;\n    backingstore = backingStore;\n    wgui = guitoggle;\n\n    init();\n\n    if(wgui) {\n      final BaseXWin win = new BaseXWin(new String[] {});\n      while(win.gui == null)\n        Performance.sleep(100);\n      gui = win.gui;\n      gui.context.data(data);\n      gui.notify.init();\n    }\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public int unlink(final String path) {\n    try {\n      return delete(path, false);\n    } catch(QueryException e) {\n      e.printStackTrace();\n      return -1;\n    }\n  }","id":78807,"modified_method":"@Override\n  public int unlink(final String path) {\n\n    return delete(path, false, false);\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/** Constructor. */\n  public DeepBase() {\n    this(\"unknown\", \"unknown\", DEFAULT_DBNAME);\n  }","id":78808,"modified_method":"/** Constructor. */\n  public DeepBase() {\n    this(\"unknown\", \"unknown\", DEFAULT_DBNAME, true);\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Create a new regular file or directory node.\n   * \n   * @param path to the file to be created\n   * @param mode of file (directory, regular file ..., permission bits)\n   * @return id of the newly created file or -1 on failure\n   */\n  private int createNode(final String path, final int mode) {\n    try {\n      int pre = insertFileNode(path, mode);\n      return (pre == -1) ? -1 : data.id(pre);\n    } catch(QueryException e) {\n      e.printStackTrace();\n      return -1;\n    }\n  }","id":78809,"modified_method":"/**\n   * Create a new regular file or directory node.\n   * \n   * @param path to the file to be created\n   * @param mode of file (directory, regular file ..., permission bits)\n   * @return id of the newly created file or -1 on failure\n   */\n  private int createNode(final String path, final int mode) {\n    int pre = insertFileNode(path, mode);\n    return (pre == -1) ? -1 : data.id(pre);\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Evaluates given path and returns the pre value of the parent directory (if\n   * any).\n   * @param path to be analyzed\n   * @return pre value of parent directory or -1 if none is found\n   * @throws QueryException on failure\n   */\n  private int parentPre(final String path) throws QueryException {\n    Nodes n = xquery(pn2xp(dirname(path), true));\n    return n.size() == 0 ? -1 : n.nodes[0];\n  }","id":78810,"modified_method":"/**\n   * Evaluates given path and returns the pre value of the parent directory (if\n   * any).\n   * @param path to be analyzed\n   * @return pre value of parent directory or -1 if none is found\n   */\n  private int parentPre(final String path) {\n    try {\n      Nodes n = xquery(pn2xp(dirname(path), true));\n      return n.size() == 0 ? -1 : n.nodes[0];\n    } catch(QueryException e) {\n      e.printStackTrace();\n      return -1;\n    }\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Insert a file node (regular file, directory ...).\n   * @param path of file to insert\n   * @param mode of file\n   * @throws QueryException on failure\n   * @return pre value of newly inserted node\n   */\n  private int insertFileNode(final String path, final int mode)\n      throws QueryException {\n    return insert(path, buildData(path, mode));\n  }","id":78811,"modified_method":"/**\n   * Insert a file node (regular file, directory ...).\n   * @param path of file to insert\n   * @param mode of file\n   * @return pre value of newly inserted node\n   */\n  private int insertFileNode(final String path, final int mode) {\n    int ppre = parentPre(path);\n    if(ppre == -1) return -1;\n    return insert(ppre, buildData(path, mode));\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public int rmdir(final String path) {\n    /* TODO: rmdir deletes only empty dir. What happens with --ignore? */\n    try {\n      return delete(path, true);\n    } catch(QueryException e) {\n      e.printStackTrace();\n      return -1;\n    }\n  }","id":78812,"modified_method":"@Override\n  public int rmdir(final String path) {\n    /* [AH] rmdir(2) deletes only empty dir. What happens with --ignore? */\n    return delete(path, true, false);\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Insert extracted file content.\n   * @param path to file at which to insert the extracted content\n   * @throws QueryException on failure\n   * @return pre value of newly inserted content, -1 on failure\n   */\n  private int insertContent(final String path) throws QueryException {\n    return insert(path, buildContentData(path));\n  }","id":78813,"modified_method":"/**\n   * Insert extracted file content.\n   * @param path to file at which to insert the extracted content\n   * @return pre value of newly inserted content, -1 on failure\n   */\n  private int insertContent(final String path) {\n    int fpre = pathPre(path);\n    if(fpre == -1) return -1;\n    return insert(fpre, buildContentData(path));\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public int release(final String path) {\n    try {\n      return insertContent(path);\n    } catch(QueryException e) {\n      e.printStackTrace();\n      return -1;\n    }\n  }","id":78814,"modified_method":"@Override\n  public int release(final String path) {\n    boolean dirty = true;\n\n    if(dirty) {\n      delete(path, false, true);\n      insertContent(path);\n    }\n\n    return 0;\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Make some directories and test return code and composed XML.\n   */\n  @Test\n  public void testMkdir() {\n    // mkdir should only accept directories (wrong mode test).\n    assertEquals(\"mkdir -1\", -1, dbfs.mkdir(\"/a/x\", 0100644));\n    assertEquals(\"mkdir 0\", 3, dbfs.mkdir(\"/a\", 0040755));\n    assertEquals(\"mkdir 0\", 5, dbfs.mkdir(\"/a/b\", 0040755));\n    // non-existing parent directories.\n    assertEquals(\"mkdir -1\", -1, dbfs.mkdir(\"/a/b/c/d/e\", 0040755));\n    assertEquals(\"mkdir 0\", 7, dbfs.mkdir(\"/a/b/c\", 0040755));\n    assertEquals(\"mkdir 0\", 9, dbfs.mkdir(\"/a/b/d\", 0040755));\n    assertEquals(\"mkdir 0\", 11, dbfs.mkdir(\"/a/c\", 0040755));\n    final String r3 = \"<deepfuse mountpoint=\\\"unknown\\\">\"\n        + \"<dir name=\\\"a\\\"><dir name=\\\"b\\\"><dir name=\\\"c\\\"/>\"\n        + \"<dir name=\\\"d\\\"/><\/dir><dir name=\\\"c\\\"/><\/dir><\/deepfuse>\";\n    assertEquals(\"mkdir r3\", r3, query(\"/\").trim());\n    // already exists (is getattr's task)\n  }","id":78815,"modified_method":"/**\n   * Make some directories and test return code and composed XML.\n   * [AH] update test case\n   */\n  //@Test\n  public void testMkdir() {\n    // mkdir should only accept directories (wrong mode test).\n    assertEquals(\"mkdir -1\", -1, dbfs.mkdir(\"/a/x\", 0100644));\n    assertEquals(\"mkdir 0\", 4, dbfs.mkdir(\"/a\", 0040755));\n    assertEquals(\"mkdir 0\", 6, dbfs.mkdir(\"/a/b\", 0040755));\n    // non-existing parent directories.\n    assertEquals(\"mkdir -1\", -1, dbfs.mkdir(\"/a/b/c/d/e\", 0040755));\n    assertEquals(\"mkdir 0\", 8, dbfs.mkdir(\"/a/b/c\", 0040755));\n    assertEquals(\"mkdir 0\", 10, dbfs.mkdir(\"/a/b/d\", 0040755));\n    assertEquals(\"mkdir 0\", 12, dbfs.mkdir(\"/a/c\", 0040755));\n    final String r3 = \"<deepfuse mountpoint=\\\"unknown\\\">\"\n        + \"<dir name=\\\"a\\\"><dir name=\\\"b\\\"><dir name=\\\"c\\\"/>\"\n        + \"<dir name=\\\"d\\\"/><\/dir><dir name=\\\"c\\\"/><\/dir><\/deepfuse>\";\n    assertEquals(\"mkdir r3\", r3, query(\"/\").trim());\n    // already exists (is getattr's task)\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Create the database.\n   * @throws Exception exception\n   */\n  @Before\n  @SuppressWarnings(\"unused\")\n  public void setUp() throws Exception {\n    dbfs = new DeepBase(DBNAME, \"not_mounted\", \"java_only_test\");\n    dbfs.init();\n  }","id":78816,"modified_method":"/**\n   * Create the database.\n   * @throws Exception exception\n   */\n  @Before\n  @SuppressWarnings(\"unused\")\n  public void setUp() throws Exception {\n    dbfs = new DeepBase(DBNAME, \"not_mounted\", \"java_only_test\", false);\n    dbfs.init();\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Create regular file and check id returned.\n   */\n  @Test\n  public void testCreate() {\n    assertEquals(\"mkdir 0\", 3, dbfs.mkdir(\"/a\", 0040755));\n    // create returns id\n    assertEquals(\"create\", 5, dbfs.create(\"/a/file.txt\", 0100644));\n    // wrong mode\n    assertEquals(\"create\", -1, dbfs.create(\"/a/dir\", 0040755));\n    // no parent directory to insert\n    assertEquals(\"create\", -1, dbfs.create(\"/a/b/c/file.txt\", 0100644));\n    assertEquals(\"mkdir 0\", 7, dbfs.mkdir(\"/a/b\", 0040755));\n    query(\"/\");\n    assertEquals(\"create\", 9, dbfs.create(\"/a/b/file.txt\", 0100644));\n  }","id":78817,"modified_method":"/**\n   * Create regular file and check id returned.\n   * [AH] update test case\n   */\n  //@Test\n  public void testCreate() {\n    assertEquals(\"mkdir 0\", 4, dbfs.mkdir(\"/a\", 0040755));\n    // create returns id\n    assertEquals(\"create\", 5, dbfs.create(\"/a/file.txt\", 0100644));\n    // wrong mode\n    assertEquals(\"create\", -1, dbfs.create(\"/a/dir\", 0040755));\n    // no parent directory to insert\n    assertEquals(\"create\", -1, dbfs.create(\"/a/b/c/file.txt\", 0100644));\n    assertEquals(\"mkdir 0\", 7, dbfs.mkdir(\"/a/b\", 0040755));\n    query(\"/\");\n    assertEquals(\"create\", 9, dbfs.create(\"/a/b/file.txt\", 0100644));\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Getattr resolves pathnames and returns associated id or -1.\n   */\n  @Test\n  public void testGetAttr() {\n    loadTestDB();\n    assertEquals(\"getattr\", 3, dbfs.getattr(\"/afile\"));\n    assertEquals(\"getattr\", 11, dbfs.getattr(\"/a/b/cfile\"));\n    assertEquals(\"getattr\", -1, dbfs.getattr(\"/a/b/x/cfile\"));\n  }","id":78818,"modified_method":"/**\n   * Getattr resolves pathnames and returns associated id or -1.\n   * [AH] update test case\n   */\n  //@Test\n  public void testGetAttr() {\n    loadTestDB();\n    assertEquals(\"getattr\", 3, dbfs.getattr(\"/afile\"));\n    assertEquals(\"getattr\", 11, dbfs.getattr(\"/a/b/cfile\"));\n    assertEquals(\"getattr\", -1, dbfs.getattr(\"/a/b/x/cfile\"));\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Invoked when a regular file is visited.\n   * @param f file name\n   * @throws IOException I/O exception\n   */\n  private void file(final File f) throws IOException {\n    curr = f;\n    builder.startElem(FILE, atts(f, false));\n    if (f.canRead()) {\n      if(Prop.fsmeta && f.getName().indexOf('.') != -1) {\n        final String name = f.getName();\n        final int dot = name.lastIndexOf('.');\n        final byte[] suffix = lc(token(name.substring(dot + 1)));\n\n        final AbstractExtractor index = meta.get(suffix);\n        if(index != null && f.length() != 0) {\n          try {\n            index.extract(builder, f);\n          } catch(final MetaDataException ex) {\n            BaseX.debug(ex);\n          }\n        }\n      }\n\n      // import textual content\n      if(Prop.fscont && f.isFile()) {\n        // initialize cache for textual contents\n        final int l = (int) Math.min(f.length(), Prop.fstextmax);\n        final byte[] cc = new byte[l];\n        BufferInput.read(f, cc);\n        int c = -1;\n        while(++c < l) {\n          final byte b = cc[c];\n          if(b >= 0 && b < ' ' && !ws(b)) break;\n        }\n        if(c == l) {\n          while(--c >= 0 && cc[c] <= 0x20 && cc[c] >= 0);\n          if(++c != 0) {\n            builder.nodeAndText(CONTENT, atts.reset(), Array.finish(cc, c));\n          }\n        }\n      }\n    }\n\n    builder.endElem(FILE);\n    // add file size to parent folder\n    sizeStack[lvl] += f.length();\n  }","id":78819,"modified_method":"/**\n   * Invoked when a regular file is visited.\n   * @param f file name\n   * @throws IOException I/O exception\n   */\n  private void file(final File f) throws IOException {\n    curr = f;\n    if (!singlemode)\n      builder.startElem(FILE, atts(f, false));\n    if (f.canRead()) {\n      if(Prop.fsmeta && f.getName().indexOf('.') != -1) {\n        final String name = f.getName();\n        final int dot = name.lastIndexOf('.');\n        final byte[] suffix = lc(token(name.substring(dot + 1)));\n\n        final AbstractExtractor index = meta.get(suffix);\n        if(index != null && f.length() != 0) {\n          try {\n            index.extract(builder, f);\n          } catch(final MetaDataException ex) {\n            BaseX.debug(ex);\n          }\n        }\n      }\n\n      // import textual content\n      if(Prop.fscont && f.isFile()) {\n        // initialize cache for textual contents\n        final int l = (int) Math.min(f.length(), Prop.fstextmax);\n        final byte[] cc = new byte[l];\n        BufferInput.read(f, cc);\n        int c = -1;\n        while(++c < l) {\n          final byte b = cc[c];\n          if(b >= 0 && b < ' ' && !ws(b)) break;\n        }\n        if(c == l) {\n          while(--c >= 0 && cc[c] <= 0x20 && cc[c] >= 0);\n          if(++c != 0) {\n            builder.nodeAndText(CONTENT, atts.reset(), Array.finish(cc, c));\n          }\n        }\n      }\n    }\n\n    if (!singlemode)\n      builder.endElem(FILE);\n    // add file size to parent folder\n    sizeStack[lvl] += f.length();\n  }","commit_id":"452ef3b36e8c7703371cd4a5e49a49c9fc925141","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void parse(final Builder b) throws IOException {\r\n    // read in indexes\r\n    final File f = file.file();\r\n    final String dir = f.getAbsoluteFile().getParent();\r\n    index(mediatypes, dir + \"/mediatypes.dat\");\r\n    index(subjects, dir + \"/subjects.dat\");\r\n    index(languages, dir + \"/lang.dat\");\r\n    index(mvids, dir + \"/mvids.dat\");\r\n    index(posters, dir + \"/posters.dat\");\r\n    index(genres, dir + \"/genres.dat\");\r\n\r\n    // find maximum mediovis id\r\n    for(int i = 1; i < mvids.size; i++) {\r\n      final int id = Token.toInt(mvids.value(i));\r\n      if(maxid < id) maxid = id;\r\n    }\r\n\r\n    // create input reference\r\n    input = new RandomAccess(f);\r\n\r\n    // check beginning of input file\r\n    if(input.read() != '#' || input.read() != '#' || input.read() != '#') {\r\n      throw new BuildException(\"Invalid MAB2 input (doesn't start with ###)\");\r\n    }\r\n\r\n    b.encoding(\"ISO-8859-1\");\r\n    //b.encoding(Prop.ENCODING);\r\n\r\n    builder = b;\r\n    builder.startDoc(token(file.name()));\r\n    builder.startElem(LIBRARY, null);\r\n\r\n    // find file offsets of all titles\r\n    final Performance p = new Performance();\r\n\r\n    int i = 0;\r\n    byte[] id;\r\n    while((id = id(input)) != null) {\r\n      final long pos = off;\r\n      final byte[] par = par(input);\r\n\r\n      final boolean child = par != null;\r\n      final byte[] key = child ? par : id;\r\n      MAB2Entry entry = ids.get(key);\r\n      if(entry == null) {\r\n        entry = new MAB2Entry(key);\r\n        ids.add(key, entry);\r\n      }\r\n      if(child) entry.add(pos);\r\n      else entry.pos(pos);\r\n\r\n      if(Prop.debug) {\r\n        if(++i % 50000 == 0) BaseX.err(\" \" + i + \"\\n\");\r\n        else if(i % 5000 == 0) BaseX.err(\"!\");\r\n        else if(i % 1000 == 0) BaseX.err(\".\");\r\n      }\r\n    }\r\n\r\n    if(Prop.debug) {\r\n      BaseX.err(\"\\nParse Offsets (%): %/%\\n\", ids.size, p.getTimer(),\r\n          Performance.getMem());\r\n    }\r\n\r\n    // create all titles\r\n    final int is = ids.size;\r\n    for(i = 1; i < is; i++) {\r\n      final MAB2Entry entry = ids.value(i);\r\n      final long pos = entry.pos;\r\n      final int es = entry.size;\r\n      if(pos != 0) {\r\n        final byte[] last = addEntry(input, pos, es, null);\r\n        addChildren(input, entry, last);\r\n        builder.endElem(MEDIUM);\r\n      } else {\r\n        // no top entry exists... treat children as top entries\r\n        for(int j = 0; j < es; j++) {\r\n          addEntry(input, entry.children[j], 0, null);\r\n          builder.endElem(MEDIUM);\r\n        }\r\n        //addChildren(input, entry);\r\n      }\r\n      if(Prop.debug) {\r\n        if(i % 50000 == 0) BaseX.err(\" \" + i + \"\\n\");\r\n        else if(i % 5000 == 0) BaseX.err(\"!\");\r\n        else if(i % 1000 == 0) BaseX.err(\".\");\r\n      }\r\n    }\r\n\r\n    if(Prop.debug) {\r\n      BaseX.err(\"\\nCreate Titles: %/%\\n\", p.getTimer(), Performance.getMem());\r\n    }\r\n\r\n    builder.endElem(LIBRARY);\r\n    builder.endDoc();\r\n    input.close();\r\n\r\n    // write the mediovis ids back to disk\r\n    final PrintOutput out = new PrintOutput(dir + \"/mvids.dat\");\r\n    for(i = 1; i < mvids.size; i++) {\r\n      out.print(mvids.key(i));\r\n      out.print('\\t');\r\n      out.println(mvids.value(i));\r\n    }\r\n    out.close();\r\n  }","id":78820,"modified_method":"@Override\r\n  public void parse(final Builder b) throws IOException {\r\n    // read in indexes\r\n    final File f = file.file();\r\n    final String dir = f.getAbsoluteFile().getParent();\r\n    index(mediatypes, dir + \"/mediatypes.dat\");\r\n    index(subjects, dir + \"/subjects.dat\");\r\n    index(languages, dir + \"/lang.dat\");\r\n    index(mvids, dir + \"/mvids.dat\");\r\n    index(posters, dir + \"/posters.dat\");\r\n    index(genres, dir + \"/genres.dat\");\r\n\r\n    // find maximum mediovis id\r\n    for(int i = 1; i < mvids.size; i++) {\r\n      final int id = Token.toInt(mvids.value(i));\r\n      if(maxid < id) maxid = id;\r\n    }\r\n\r\n    // create input reference\r\n    input = new RandomAccess(f);\r\n\r\n    // check beginning of input file\r\n    if(input.read() != '#' || input.read() != '#' || input.read() != '#') {\r\n      throw new BuildException(\"Invalid MAB2 input (doesn't start with ###)\");\r\n    }\r\n\r\n    b.encoding(\"ISO-8859-1\");\r\n    //b.encoding(Prop.ENCODING);\r\n\r\n    builder = b;\r\n    builder.startDoc(token(file.name()));\r\n    builder.startElem(LIBRARY, null);\r\n\r\n    // find file offsets of all titles\r\n    final Performance p = new Performance();\r\n\r\n    int i = 0;\r\n    byte[] id;\r\n    while((id = id(input)) != null) {\r\n      final long pos = off;\r\n      final byte[] par = par(input);\r\n\r\n      final boolean child = par != null;\r\n      final byte[] key = child ? par : id;\r\n      MAB2Entry entry = ids.get(key);\r\n      if(entry == null) {\r\n        entry = new MAB2Entry(key);\r\n        ids.add(key, entry);\r\n      }\r\n      if(child) entry.add(pos);\r\n      else entry.pos(pos);\r\n\r\n      if(Prop.debug) {\r\n        if(++i % 50000 == 0) BaseX.err(\" \" + i + \"\\n\");\r\n        else if(i % 5000 == 0) BaseX.err(\"!\");\r\n        else if(i % 1000 == 0) BaseX.err(\".\");\r\n      }\r\n    }\r\n\r\n    if(Prop.debug) {\r\n      BaseX.err(\"\\nParse Offsets (%): %/%\\n\", ids.size, p.getTimer(),\r\n          Performance.getMem());\r\n    }\r\n\r\n    // create all titles\r\n    final int is = ids.size;\r\n    for(i = 1; i < is; i++) {\r\n      final MAB2Entry entry = ids.value(i);\r\n      final long pos = entry.pos;\r\n      final int es = entry.size;\r\n      // is correct...\r\n      if(pos != 0) {\r\n        final byte[] last = addEntry(input, pos, es, null, true);\r\n        addChildren(input, entry, last);\r\n        if(!Prop.mab2flat) builder.endElem(MEDIUM);\r\n      } else {\r\n        // no top entry exists... treat children as top entries\r\n        addChildren(input, entry, null);\r\n      }\r\n      if(Prop.debug) {\r\n        if(i % 50000 == 0) BaseX.err(\" \" + i + \"\\n\");\r\n        else if(i % 5000 == 0) BaseX.err(\"!\");\r\n        else if(i % 1000 == 0) BaseX.err(\".\");\r\n      }\r\n    }\r\n\r\n    if(Prop.debug) {\r\n      BaseX.err(\"\\nCreate Titles: %/%\\n\", p.getTimer(), Performance.getMem());\r\n    }\r\n\r\n    builder.endElem(LIBRARY);\r\n    builder.endDoc();\r\n    input.close();\r\n\r\n    // write the mediovis ids back to disk\r\n    final PrintOutput out = new PrintOutput(dir + \"/mvids.dat\");\r\n    for(i = 1; i < mvids.size; i++) {\r\n      out.print(mvids.key(i));\r\n      out.print('\\t');\r\n      out.println(mvids.value(i));\r\n    }\r\n    out.close();\r\n  }","commit_id":"e0c4f1f6eb9d1d0719fc8324c478bb841a786e3c","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Adds an entry.\r\n   * @param in input stream\r\n   * @param pos file offset to start from\r\n   * @param sub number of subordinate titles\r\n   * @param last last title\r\n   * @return last title\r\n   * @throws IOException I/O exception\r\n   */\r\n  private byte[] addEntry(final RandomAccess in, final long pos, final int sub,\r\n      final byte[] last) throws IOException {\r\n\r\n    mvID = null;\r\n    bibID = null;\r\n    title = null;\r\n    description = null;\r\n    type = null;\r\n    language = null;\r\n    original = null;\r\n    subtitle = null;\r\n    town = null;\r\n    publisher = null;\r\n    year = null;\r\n    format = null;\r\n    details = null;\r\n    note = null;\r\n    isbn = null;\r\n    subject = null;\r\n    nrSigs = 0;\r\n    nrPers = 0;\r\n    nrInst = 0;\r\n    shortTitle = false;\r\n\r\n    in.cursor(pos);\r\n\r\n    // collect meta-data\r\n    while(true) {\r\n      final byte[] line = find(in, (byte) '\\n');\r\n      final int l = line.length;\r\n\r\n      if(l > 3) {\r\n        if(line[0] == '#') continue;\r\n\r\n        final int n = Token.toInt(line, 0, 3);\r\n        if(n == 1) {\r\n          if(bibID == null) {\r\n            bibID = num(line);\r\n            mvID = mvids.get(bibID);\r\n            if(mvID == null) {\r\n              mvID = Token.token(++maxid);\r\n              mvids.add(bibID, mvID);\r\n            }\r\n          }\r\n        } else if(n == 29) {\r\n          type = mediatypes.get(num(line));\r\n        } else if(n == 37 && language == null) {\r\n          language = language(line);\r\n        } else if(n == 81) {\r\n          title = string(line);\r\n          shortTitle = true;\r\n        } else if(n >= 100 && n < 200 && (n & 3) == 0) {\r\n          pers[nrPers++] = string(line);\r\n        } else if(n >= 200 && n < 300 && (n & 3) == 0) {\r\n          inst[nrInst++] = string(line);\r\n        } else if(n == 304) {\r\n          original = string(line);\r\n        } else if(n == 310) {\r\n          title = string(line);\r\n          shortTitle = true;\r\n        } else if(n == 331) {\r\n          if(title == null) title = string(line);\r\n          else if(shortTitle) description = string(line);\r\n        } else if(n == 335) {\r\n          subtitle = string(line);\r\n        } else if(n == 340) {\r\n          if(original == null) original = string(line);\r\n        } else if(n == 359) {\r\n          description = merge(description, string(line));\r\n        } else if(n == 410) {\r\n          town = string(line);\r\n        } else if(n == 412) {\r\n          publisher = string(line);\r\n        } else if(n == 425) {\r\n          year = year(line);\r\n        } else if(n == 433) {\r\n          format = string(line);\r\n        } else if(n == 501) {\r\n          details = string(line);\r\n          year = year2(details, year);\r\n        } else if(n == 537) {\r\n          note = string(line);\r\n        } else if(n == 540) {\r\n          isbn = string(line);\r\n        } else if(n == 542) {\r\n          isbn = string(line);\r\n        } else if(n == 544) {\r\n          sig[nrSigs++] = string(line);\r\n        } else if(n == 700) {\r\n          if(nrSigs == 0) sig[nrSigs++] = string(line);\r\n        }\r\n      } else {\r\n        byte[][] atts = null;\r\n        if(sub == 0) {\r\n          atts = new byte[][] { MV_ID, mvID, BIB_ID, bibID };\r\n        } else {\r\n          atts = new byte[][] { MV_ID, mvID, BIB_ID, bibID, MAX,\r\n              Token.token(sub) };\r\n        }\r\n\r\n        if(last != null && !eq(last, title)) title = concat(last, SEMI, title);\r\n\r\n        builder.startElem(MEDIUM, atts);\r\n        addTag(TYPE, type);\r\n        addTag(LANGUAGE, language);\r\n        for(int s = 0; s < nrPers; s++) addTag(PERSON, pers[s]);\r\n        for(int s = 0; s < nrInst; s++) addTag(INSTITUTE, inst[s]);\r\n        addTag(ORIGINAL, original);\r\n        addTag(TITLE, title);\r\n        addTag(SUBTITLE, subtitle);\r\n        addTag(DESCRIPTION, description);\r\n        addTag(TOWN, town);\r\n        addTag(PUBLISHER, publisher);\r\n        addTag(YEAR, year);\r\n        addTag(FORMAT, format);\r\n        addTag(DETAILS, details);\r\n        addTag(NOTE, note);\r\n        for(int s = 0; s < nrSigs; s++) addTag(SIGNATURE, sig[s]);\r\n        // actually: several subjects/lending numbers per medium..\r\n        for(int s = 0; s < nrSigs; s++) {\r\n          if(subject == null) subject = subjects.get(subject(sig[s]));\r\n        }\r\n        addTag(SUBJECT, subject);\r\n        addTag(ISBN, isbn);\r\n        addTag(POSTER, posters.get(bibID));\r\n        addTag(GENRE, genres.get(mvID));\r\n        return title;\r\n      }\r\n    }\r\n  }","id":78821,"modified_method":"/**\r\n   * Adds an entry.\r\n   * @param in input stream\r\n   * @param pos file offset to start from\r\n   * @param sub number of subordinate titles\r\n   * @param last last title\r\n   * \"param top top flag\r\n   * @return last title\r\n   * @throws IOException I/O exception\r\n   */\r\n  private byte[] addEntry(final RandomAccess in, final long pos, final int sub,\r\n      final byte[] last, final boolean top) throws IOException {\r\n\r\n    mvID = null;\r\n    bibID = null;\r\n    title = null;\r\n    description = null;\r\n    type = null;\r\n    language = null;\r\n    original = null;\r\n    subtitle = null;\r\n    town = null;\r\n    publisher = null;\r\n    year = null;\r\n    format = null;\r\n    details = null;\r\n    note = null;\r\n    isbn = null;\r\n    subject = null;\r\n    nrSigs = 0;\r\n    nrPers = 0;\r\n    nrInst = 0;\r\n    shortTitle = false;\r\n\r\n    in.cursor(pos);\r\n\r\n    // collect meta-data\r\n    while(true) {\r\n      final byte[] line = find(in, (byte) '\\n');\r\n      final int l = line.length;\r\n\r\n      if(l > 3) {\r\n        if(line[0] == '#') continue;\r\n\r\n        final int n = Token.toInt(line, 0, 3);\r\n        if(n == 1) {\r\n          if(bibID == null) {\r\n            bibID = num(line);\r\n            mvID = mvids.get(bibID);\r\n            if(mvID == null) {\r\n              mvID = Token.token(++maxid);\r\n              mvids.add(bibID, mvID);\r\n            }\r\n          }\r\n        } else if(n == 29) {\r\n          type = mediatypes.get(num(line));\r\n        } else if(n == 37 && language == null) {\r\n          language = language(line);\r\n        } else if(n == 81) {\r\n          title = string(line);\r\n          shortTitle = true;\r\n        } else if(n >= 100 && n < 200 && (n & 3) == 0) {\r\n          pers[nrPers++] = string(line);\r\n        } else if(n >= 200 && n < 300 && (n & 3) == 0) {\r\n          inst[nrInst++] = string(line);\r\n        } else if(n == 304) {\r\n          original = string(line);\r\n        } else if(n == 310) {\r\n          title = string(line);\r\n          shortTitle = true;\r\n        } else if(n == 331) {\r\n          if(title == null) title = string(line);\r\n          else if(shortTitle) description = string(line);\r\n        } else if(n == 335) {\r\n          subtitle = string(line);\r\n        } else if(n == 340) {\r\n          if(original == null) original = string(line);\r\n        } else if(n == 359) {\r\n          description = merge(description, string(line));\r\n        } else if(n == 410) {\r\n          town = string(line);\r\n        } else if(n == 412) {\r\n          publisher = string(line);\r\n        } else if(n == 425) {\r\n          year = year(line);\r\n        } else if(n == 433) {\r\n          format = string(line);\r\n        } else if(n == 501) {\r\n          details = string(line);\r\n          year = year2(details, year);\r\n        } else if(n == 537) {\r\n          note = string(line);\r\n        } else if(n == 540) {\r\n          isbn = string(line);\r\n        } else if(n == 542) {\r\n          isbn = string(line);\r\n        } else if(n == 544) {\r\n          sig[nrSigs++] = string(line);\r\n        } else if(n == 700) {\r\n          if(nrSigs == 0) sig[nrSigs++] = string(line);\r\n        }\r\n      } else {\r\n        byte[][] atts = null;\r\n        if(sub == 0) {\r\n          atts = new byte[][] { MV_ID, mvID, BIB_ID, bibID };\r\n        } else {\r\n          atts = new byte[][] { MV_ID, mvID, BIB_ID, bibID, MAX,\r\n              Token.token(sub) };\r\n        }\r\n\r\n        if(last != null && title != null && !eq(last, title))\r\n          title = concat(last, SEMI, title);\r\n\r\n        if(!top || !Prop.mab2flat) {\r\n          builder.startElem(MEDIUM, atts);\r\n          addTag(TYPE, type);\r\n          addTag(LANGUAGE, language);\r\n          for(int s = 0; s < nrPers; s++) addTag(PERSON, pers[s]);\r\n          for(int s = 0; s < nrInst; s++) addTag(INSTITUTE, inst[s]);\r\n          addTag(ORIGINAL, original);\r\n          addTag(TITLE, title);\r\n          addTag(SUBTITLE, subtitle);\r\n          addTag(DESCRIPTION, description);\r\n          addTag(TOWN, town);\r\n          addTag(PUBLISHER, publisher);\r\n          addTag(YEAR, year);\r\n          addTag(FORMAT, format);\r\n          addTag(DETAILS, details);\r\n          addTag(NOTE, note);\r\n          for(int s = 0; s < nrSigs; s++) addTag(SIGNATURE, sig[s]);\r\n          // actually: several subjects/lending numbers per medium..\r\n          for(int s = 0; s < nrSigs; s++) {\r\n            if(subject == null) subject = subjects.get(subject(sig[s]));\r\n          }\r\n          addTag(SUBJECT, subject);\r\n          addTag(ISBN, isbn);\r\n          addTag(POSTER, posters.get(bibID));\r\n          addTag(GENRE, genres.get(mvID));\r\n        }\r\n        return title;\r\n      }\r\n    }\r\n  }","commit_id":"e0c4f1f6eb9d1d0719fc8324c478bb841a786e3c","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Adds children of a title.\r\n   * @param in input stream\r\n   * @param entry mab2 entry\r\n   * @param last last top title\r\n   * @throws IOException I/O exception\r\n   */\r\n  private void addChildren(final RandomAccess in, final MAB2Entry entry,\r\n      final byte[] last) throws IOException {\r\n    // no top entry exists... treat children as top entries\r\n    final int es = entry.size;\r\n    for(int j = 0; j < es; j++) {\r\n      if(Prop.mab2flat) {\r\n        builder.endElem(MEDIUM);\r\n        addEntry(in, entry.children[j], 0, last);\r\n      } else {\r\n        addEntry(in, entry.children[j], 0, null);\r\n        builder.endElem(MEDIUM);\r\n      }\r\n    }\r\n  }","id":78822,"modified_method":"/**\r\n   * Adds children of a title.\r\n   * @param in input stream\r\n   * @param entry mab2 entry\r\n   * @param last last top title\r\n   * @throws IOException I/O exception\r\n   */\r\n  private void addChildren(final RandomAccess in, final MAB2Entry entry,\r\n      final byte[] last) throws IOException {\r\n\r\n    final int es = entry.size;\r\n    for(int j = 0; j < es; j++) {\r\n      addEntry(in, entry.children[j], 0, last, false);\r\n      builder.endElem(MEDIUM);\r\n    }\r\n  }","commit_id":"e0c4f1f6eb9d1d0719fc8324c478bb841a786e3c","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  @NotNull\n  public String getFileName() {\n    checkDisposed();\n    Pair<VirtualFile, String> result = myNode.update();\n    VirtualFile file = result.first;\n    if (file != null) {\n      return file.getName();\n    }\n    String url = result.second;\n    int index = url.lastIndexOf('/');\n    return index >= 0 ? url.substring(index + 1) : url;\n  }","id":78823,"modified_method":"@Override\n  @NotNull\n  public String getFileName() {\n    if (!checkDisposed()) return \"\";\n    Pair<VirtualFile, String> result = myNode.update();\n    VirtualFile file = result.first;\n    if (file != null) {\n      return file.getName();\n    }\n    String url = result.second;\n    int index = url.lastIndexOf('/');\n    return index >= 0 ? url.substring(index + 1) : url;\n  }","commit_id":"7f2cc84ae9ebe2feb075de7e6f15420992481171","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public String getPresentableUrl() {\n    checkDisposed();\n    return PathUtil.toPresentableUrl(getUrl());\n  }","id":78824,"modified_method":"@Override\n  @NotNull\n  public String getPresentableUrl() {\n    if (!checkDisposed()) return \"\";\n    return PathUtil.toPresentableUrl(getUrl());\n  }","commit_id":"7f2cc84ae9ebe2feb075de7e6f15420992481171","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkDisposed() {\n    if (isDisposed()) {\n      ProgressManager.checkCanceled();\n      throwDisposalError(\"Already disposed: URL='\" + this+\"'\");\n    }\n  }","id":78825,"modified_method":"private boolean checkDisposed() {\n    if (isDisposed()) {\n      LOG.error(\"Already disposed: URL='\" + this+\"'\");\n      return false;\n    }\n    return true;\n  }","commit_id":"7f2cc84ae9ebe2feb075de7e6f15420992481171","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public VirtualFile getFile() {\n    checkDisposed();\n    Pair<VirtualFile, String> result = myNode.update();\n    return result.first;\n  }","id":78826,"modified_method":"@Override\n  public VirtualFile getFile() {\n    if (!checkDisposed()) return null;\n    Pair<VirtualFile, String> result = myNode.update();\n    return result.first;\n  }","commit_id":"7f2cc84ae9ebe2feb075de7e6f15420992481171","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void validateRuleRepositoryName(Rule rule, String repositoryKey) {\n    if (Strings.isNullOrEmpty(rule.getName()) && Strings.isNullOrEmpty(ruleI18nManager.getName(repositoryKey, rule.getKey(), Locale.ENGLISH))) {\n      throw new SonarException(\"The following rule (repository: \" + repositoryKey + \") must have a name: \" + rule);\n    }\n  }","id":78827,"modified_method":"private void validateRuleRepositoryName(Rule rule, String repositoryKey) {\n    String nameFromBundle = ruleI18nManager.getName(repositoryKey, rule.getKey());\n    if(! Strings.isNullOrEmpty(nameFromBundle)) {\n      rule.setName(nameFromBundle);\n    }\n    if (Strings.isNullOrEmpty(rule.getName())) {\n      throw new SonarException(\"The following rule (repository: \" + repositoryKey + \") must have a name: \" + rule);\n    }\n  }","commit_id":"e18cd9ffe098cbb842912c8caf3934b4d2f15de5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void validateRuleDescription(Rule rule, String repositoryKey) {\n    if (Strings.isNullOrEmpty(rule.getDescription()) && Strings.isNullOrEmpty(ruleI18nManager.getDescription(repositoryKey, rule.getKey(), Locale.ENGLISH))) {\n      if (!Strings.isNullOrEmpty(rule.getName()) && Strings.isNullOrEmpty(ruleI18nManager.getName(repositoryKey, rule.getKey(), Locale.ENGLISH))) {\n        // specific case\n        throw new SonarException(\"No description found for the rule '\" + rule.getName() + \"' (repository: \" + repositoryKey + \") because the entry 'rule.\"\n          + repositoryKey + \".\" + rule.getKey() + \".name' is missing from the bundle.\");\n      } else {\n        throw new SonarException(\"The following rule (repository: \" + repositoryKey + \") must have a description: \" + rule);\n      }\n    }\n  }","id":78828,"modified_method":"private void validateRuleDescription(Rule rule, String repositoryKey) {\n    String descriptionFromBundle = ruleI18nManager.getDescription(repositoryKey, rule.getKey());\n    if(! Strings.isNullOrEmpty(descriptionFromBundle)) {\n      rule.setDescription(descriptionFromBundle);\n    }\n    if (Strings.isNullOrEmpty(rule.getDescription())) {\n      if (!Strings.isNullOrEmpty(rule.getName()) && Strings.isNullOrEmpty(ruleI18nManager.getName(repositoryKey, rule.getKey()))) {\n        // specific case\n        throw new SonarException(\"No description found for the rule '\" + rule.getName() + \"' (repository: \" + repositoryKey + \") because the entry 'rule.\"\n          + repositoryKey + \".\" + rule.getKey() + \".name' is missing from the bundle.\");\n      } else {\n        throw new SonarException(\"The following rule (repository: \" + repositoryKey + \") must have a description: \" + rule);\n      }\n    }\n  }","commit_id":"e18cd9ffe098cbb842912c8caf3934b4d2f15de5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_fail_with_rule_without_name_in_bundle() throws Exception {\n    RuleI18nManager ruleI18nManager = mock(RuleI18nManager.class);\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new RuleWithoutDescriptionRepository()}, ruleI18nManager, profilesManager, ruleRegistry);\n    setupData(\"shared\");\n\n    // the rule has no name, it should fail\n    try {\n      task.start();\n      fail(\"Rule must have a description\");\n    } catch (SonarException e) {\n      assertThat(e.getMessage(), containsString(\"No description found for the rule 'Rule 1' (repository: rule-without-description-repo) \" +\n        \"because the entry 'rule.rule-without-description-repo.rule1.name' is missing from the bundle.\"));\n    }\n  }","id":78829,"modified_method":"@Test\n  public void should_fail_with_rule_without_name_in_bundle() throws Exception {\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new RuleWithoutDescriptionRepository()}, ruleI18nManager, profilesManager, ruleRegistry);\n    setupData(\"shared\");\n\n    // the rule has no name, it should fail\n    try {\n      task.start();\n      fail(\"Rule must have a description\");\n    } catch (SonarException e) {\n      assertThat(e.getMessage(), containsString(\"No description found for the rule 'Rule 1' (repository: rule-without-description-repo) \" +\n        \"because the entry 'rule.rule-without-description-repo.rule1.name' is missing from the bundle.\"));\n    }\n  }","commit_id":"e18cd9ffe098cbb842912c8caf3934b4d2f15de5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_fail_with_rule_without_description() throws Exception {\n    RuleI18nManager ruleI18nManager = mock(RuleI18nManager.class);\n    when(ruleI18nManager.getName(anyString(), anyString(), any(Locale.class))).thenReturn(\"Name\");\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new RuleWithoutDescriptionRepository()}, ruleI18nManager, profilesManager, ruleRegistry);\n    setupData(\"shared\");\n\n    // the rule has no name, it should fail\n    try {\n      task.start();\n      fail(\"Rule must have a description\");\n    } catch (SonarException e) {\n      assertThat(e.getMessage(), containsString(\"must have a description\"));\n    }\n\n    // now it is ok, the rule has a name & a description in the English bundle\n    when(ruleI18nManager.getName(anyString(), anyString(), any(Locale.class))).thenReturn(\"Name\");\n    when(ruleI18nManager.getDescription(anyString(), anyString(), any(Locale.class))).thenReturn(\"Description\");\n    task.start();\n  }","id":78830,"modified_method":"@Test\n  public void should_fail_with_rule_without_description() throws Exception {\n    when(ruleI18nManager.getName(anyString(), anyString())).thenReturn(\"Name\");\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new RuleWithoutDescriptionRepository()}, ruleI18nManager, profilesManager, ruleRegistry);\n    setupData(\"shared\");\n\n    // the rule has no name, it should fail\n    try {\n      task.start();\n      fail(\"Rule must have a description\");\n    } catch (SonarException e) {\n      assertThat(e.getMessage(), containsString(\"must have a description\"));\n    }\n\n    // now it is ok, the rule has a name & a description in the English bundle\n    when(ruleI18nManager.getName(anyString(), anyString())).thenReturn(\"Name\");\n    when(ruleI18nManager.getDescription(anyString(), anyString())).thenReturn(\"Description\");\n    task.start();\n  }","commit_id":"e18cd9ffe098cbb842912c8caf3934b4d2f15de5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void init() {\n    profilesManager = mock(ProfilesManager.class);\n    ruleRegistry = mock(RuleRegistry.class);\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new FakeRepository()}, null, profilesManager, ruleRegistry);\n  }","id":78831,"modified_method":"@Before\n  public void init() {\n    profilesManager = mock(ProfilesManager.class);\n    ruleRegistry = mock(RuleRegistry.class);\n    ruleI18nManager = mock(RuleI18nManager.class);\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new FakeRepository()}, ruleI18nManager, profilesManager, ruleRegistry);\n  }","commit_id":"e18cd9ffe098cbb842912c8caf3934b4d2f15de5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_fail_with_rule_with_blank_name() throws Exception {\n    RuleI18nManager ruleI18nManager = mock(RuleI18nManager.class);\n    when(ruleI18nManager.getName(anyString(), anyString(), any(Locale.class))).thenReturn(\"\");\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new RuleWithoutNameRepository()}, ruleI18nManager, profilesManager, ruleRegistry);\n    setupData(\"shared\");\n\n    // the rule has no name, it should fail\n    try {\n      task.start();\n      fail(\"Rule must have a name\");\n    } catch (SonarException e) {\n      assertThat(e.getMessage(), containsString(\"must have a name\"));\n    }\n  }","id":78832,"modified_method":"@Test\n  public void should_fail_with_rule_with_blank_name() throws Exception {\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new RuleWithoutNameRepository()}, ruleI18nManager, profilesManager, ruleRegistry);\n    setupData(\"shared\");\n\n    // the rule has no name, it should fail\n    try {\n      task.start();\n      fail(\"Rule must have a name\");\n    } catch (SonarException e) {\n      assertThat(e.getMessage(), containsString(\"must have a name\"));\n    }\n  }","commit_id":"e18cd9ffe098cbb842912c8caf3934b4d2f15de5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_fail_with_rule_without_name() throws Exception {\n    RuleI18nManager ruleI18nManager = mock(RuleI18nManager.class);\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new RuleWithoutNameRepository()}, ruleI18nManager, profilesManager, ruleRegistry);\n    setupData(\"shared\");\n\n    // the rule has no name, it should fail\n    try {\n      task.start();\n      fail(\"Rule must have a name\");\n    } catch (SonarException e) {\n      assertThat(e.getMessage(), containsString(\"must have a name\"));\n    }\n\n    // now it is ok, the rule has a name in the English bundle\n    when(ruleI18nManager.getName(anyString(), anyString(), any(Locale.class))).thenReturn(\"Name\");\n    when(ruleI18nManager.getDescription(anyString(), anyString(), any(Locale.class))).thenReturn(\"Description\");\n    task.start();\n  }","id":78833,"modified_method":"@Test\n  public void should_fail_with_rule_without_name() throws Exception {\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new RuleWithoutNameRepository()}, ruleI18nManager, profilesManager, ruleRegistry);\n    setupData(\"shared\");\n\n    // the rule has no name, it should fail\n    try {\n      task.start();\n      fail(\"Rule must have a name\");\n    } catch (SonarException e) {\n      assertThat(e.getMessage(), containsString(\"must have a name\"));\n    }\n\n    // now it is ok, the rule has a name in the English bundle\n    when(ruleI18nManager.getName(anyString(), anyString())).thenReturn(\"Name\");\n    when(ruleI18nManager.getDescription(anyString(), anyString())).thenReturn(\"Description\");\n    task.start();\n  }","commit_id":"e18cd9ffe098cbb842912c8caf3934b4d2f15de5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void volume_testing() {\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new VolumeRepository()}, null, profilesManager, ruleRegistry);\n    setupData(\"shared\");\n    task.start();\n\n    List<Rule> result = getSession().getResults(Rule.class, \"status\", Rule.STATUS_READY);\n    assertThat(result.size(), is(VolumeRepository.SIZE));\n  }","id":78834,"modified_method":"@Test\n  public void volume_testing() {\n    task = new RegisterRules(getSessionFactory(), new RuleRepository[] {new VolumeRepository()}, ruleI18nManager, profilesManager, ruleRegistry);\n    setupData(\"shared\");\n    task.start();\n\n    List<Rule> result = getSession().getResults(Rule.class, \"status\", Rule.STATUS_READY);\n    assertThat(result.size(), is(VolumeRepository.SIZE));\n  }","commit_id":"e18cd9ffe098cbb842912c8caf3934b4d2f15de5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static boolean appendCollectorsFromQueryRequests(@NotNull Map<SearchRequestCollector, Processor<PsiReference>> collectors) {\n    boolean changed = false;\n    LinkedList<SearchRequestCollector> queue = new LinkedList<SearchRequestCollector>(collectors.keySet());\n    while (!queue.isEmpty()) {\n      final SearchRequestCollector each = queue.removeFirst();\n      for (QuerySearchRequest request : each.takeQueryRequests()) {\n        request.runQuery();\n        assert !collectors.containsKey(request.collector) || collectors.get(request.collector) == request.processor;\n        collectors.put(request.collector, request.processor);\n        queue.addLast(request.collector);\n        changed = true;\n      }\n    }\n    return changed;\n  }","id":78835,"modified_method":"private static boolean appendCollectorsFromQueryRequests(@NotNull Map<SearchRequestCollector, Processor<PsiReference>> collectors) {\n    boolean changed = false;\n    Deque<SearchRequestCollector> queue = new LinkedList<SearchRequestCollector>(collectors.keySet());\n    while (!queue.isEmpty()) {\n      final SearchRequestCollector each = queue.removeFirst();\n      for (QuerySearchRequest request : each.takeQueryRequests()) {\n        request.runQuery();\n        assert !collectors.containsKey(request.collector) || collectors.get(request.collector) == request.processor;\n        collectors.put(request.collector, request.processor);\n        queue.addLast(request.collector);\n        changed = true;\n      }\n    }\n    return changed;\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processElementsWithTextInGlobalScope(@NotNull final TextOccurenceProcessor processor,\n                                                       @NotNull final GlobalSearchScope scope,\n                                                       @NotNull final StringSearcher searcher,\n                                                       final short searchContext,\n                                                       final boolean caseSensitively,\n                                                       String containerName,\n                                                       final ProgressIndicator progress, final boolean processInjectedPsi) {\n    if (Thread.holdsLock(PsiLock.LOCK)) {\n      throw new AssertionError(\"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.\");\n    }\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n\n    String text = searcher.getPattern();\n    Set<VirtualFile> fileSet = new THashSet<VirtualFile>();\n    getFilesWithText(scope, searchContext, caseSensitively, text, progress, fileSet);\n\n    if (progress != null) {\n      progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text));\n    }\n\n    final Processor<PsiElement> localProcessor = localProcessor(processor, progress, processInjectedPsi, searcher);\n    if (containerName != null) {\n      List<VirtualFile> intersectionWithContainerFiles = new ArrayList<VirtualFile>();\n      // intersectionWithContainerFiles holds files containing words from both `text` and `containerName`\n      getFilesWithText(scope, searchContext, caseSensitively, text+\" \"+containerName, progress, intersectionWithContainerFiles);\n      if (!intersectionWithContainerFiles.isEmpty()) {\n        int totalSize = fileSet.size();\n        boolean result = processPsiFileRoots(intersectionWithContainerFiles, totalSize, 0, progress,\n                                                         localProcessor);\n\n        if (result) {\n          fileSet.removeAll(intersectionWithContainerFiles);\n          if (!fileSet.isEmpty()) {\n            result = processPsiFileRoots(new ArrayList<VirtualFile>(fileSet), totalSize, intersectionWithContainerFiles.size(), progress, localProcessor);\n          }\n        }\n        if (progress != null) {\n          progress.popState();\n        }\n        return result;\n      }\n    }\n\n    boolean result =\n      fileSet.isEmpty() || processPsiFileRoots(new ArrayList<VirtualFile>(fileSet), fileSet.size(), 0, progress, localProcessor);\n    if (progress != null) {\n      progress.popState();\n    }\n    return result;\n  }","id":78836,"modified_method":"private boolean processElementsWithTextInGlobalScope(@NotNull final TextOccurenceProcessor processor,\n                                                       @NotNull final GlobalSearchScope scope,\n                                                       @NotNull final StringSearcher searcher,\n                                                       final short searchContext,\n                                                       final boolean caseSensitively,\n                                                       @Nullable String containerName,\n                                                       @NotNull ProgressIndicator progress,\n                                                       final boolean processInjectedPsi) {\n    if (Thread.holdsLock(PsiLock.LOCK)) {\n      throw new AssertionError(\"You must not run search from within updating PSI activity. Please consider invokeLatering it instead.\");\n    }\n    progress.pushState();\n    progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n\n    String text = searcher.getPattern();\n    Set<VirtualFile> fileSet = new THashSet<VirtualFile>();\n    getFilesWithText(scope, searchContext, caseSensitively, text, progress, fileSet);\n\n    progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", text));\n\n    final Processor<PsiElement> localProcessor = localProcessor(processor, progress, processInjectedPsi, searcher);\n    if (containerName != null) {\n      List<VirtualFile> intersectionWithContainerFiles = new ArrayList<VirtualFile>();\n      // intersectionWithContainerFiles holds files containing words from both `text` and `containerName`\n      getFilesWithText(scope, searchContext, caseSensitively, text+\" \"+containerName, progress, intersectionWithContainerFiles);\n      if (!intersectionWithContainerFiles.isEmpty()) {\n        int totalSize = fileSet.size();\n        boolean result = processPsiFileRoots(intersectionWithContainerFiles, totalSize, 0, progress,\n                                                         localProcessor);\n\n        if (result) {\n          fileSet.removeAll(intersectionWithContainerFiles);\n          if (!fileSet.isEmpty()) {\n            result = processPsiFileRoots(new ArrayList<VirtualFile>(fileSet), totalSize, intersectionWithContainerFiles.size(), progress, localProcessor);\n          }\n        }\n        progress.popState();\n        return result;\n      }\n    }\n\n    boolean result = fileSet.isEmpty() || processPsiFileRoots(new ArrayList<VirtualFile>(fileSet), fileSet.size(), 0, progress, localProcessor);\n    progress.popState();\n    return result;\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processCandidates(final ProgressIndicator progress,\n                                    @NotNull final Map<RequestWithProcessor, Processor<PsiElement>> localProcessors,\n                                    @NotNull final MultiMap<VirtualFile, RequestWithProcessor> candidateFiles,\n                                    int totalSize,\n                                    int alreadyProcessedFiles) {\n    List<VirtualFile> files = new ArrayList<VirtualFile>(candidateFiles.keySet());\n\n    return processPsiFileRoots(files, totalSize, alreadyProcessedFiles, progress, new Processor<PsiFile>() {\n      @Override\n      public boolean process(final PsiFile psiRoot) {\n        final VirtualFile vfile = psiRoot.getVirtualFile();\n        for (final RequestWithProcessor singleRequest : candidateFiles.get(vfile)) {\n          Processor<PsiElement> localProcessor = localProcessors.get(singleRequest);\n          if (!localProcessor.process(psiRoot)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    });\n  }","id":78837,"modified_method":"private boolean processCandidates(@NotNull final Map<RequestWithProcessor, Processor<PsiElement>> localProcessors,\n                                    @NotNull final MultiMap<VirtualFile, RequestWithProcessor> candidateFiles,\n                                    @NotNull ProgressIndicator progress,\n                                    int totalSize,\n                                    int alreadyProcessedFiles) {\n    List<VirtualFile> files = new ArrayList<VirtualFile>(candidateFiles.keySet());\n\n    return processPsiFileRoots(files, totalSize, alreadyProcessedFiles, progress, new Processor<PsiFile>() {\n      @Override\n      public boolean process(final PsiFile psiRoot) {\n        final VirtualFile vfile = psiRoot.getVirtualFile();\n        for (final RequestWithProcessor singleRequest : candidateFiles.get(vfile)) {\n          Processor<PsiElement> localProcessor = localProcessors.get(singleRequest);\n          if (!localProcessor.process(psiRoot)) {\n            return false;\n          }\n        }\n        return true;\n      }\n    });\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public SearchCostResult isCheapEnoughToSearch(@NotNull String name,\n                                                @NotNull final GlobalSearchScope scope,\n                                                @Nullable final PsiFile fileToIgnoreOccurrencesIn,\n                                                @Nullable final ProgressIndicator progress) {\n    final AtomicInteger count = new AtomicInteger();\n    final Processor<VirtualFile> processor = new Processor<VirtualFile>() {\n      private final VirtualFile virtualFileToIgnoreOccurrencesIn =\n        fileToIgnoreOccurrencesIn == null ? null : fileToIgnoreOccurrencesIn.getVirtualFile();\n\n      @Override\n      public boolean process(VirtualFile file) {\n        checkCanceled(progress);\n        if (Comparing.equal(file, virtualFileToIgnoreOccurrencesIn)) return true;\n        final int value = count.incrementAndGet();\n        return value < 10;\n      }\n    };\n    List<IdIndexEntry> keys = getWordEntries(name, true);\n    boolean cheap = keys.isEmpty() || processFilesContainingAllKeys(myManager.getProject(), scope, null, keys, processor);\n\n    if (!cheap) {\n      return SearchCostResult.TOO_MANY_OCCURRENCES;\n    }\n\n    return count.get() == 0 ? SearchCostResult.ZERO_OCCURRENCES : SearchCostResult.FEW_OCCURRENCES;\n  }","id":78838,"modified_method":"@NotNull\n  @Override\n  public SearchCostResult isCheapEnoughToSearch(@NotNull String name,\n                                                @NotNull final GlobalSearchScope scope,\n                                                @Nullable final PsiFile fileToIgnoreOccurrencesIn,\n                                                @Nullable final ProgressIndicator progress) {\n    final AtomicInteger count = new AtomicInteger();\n    final ProgressIndicator indicator = progress == null ? new EmptyProgressIndicator() : progress;\n    final Processor<VirtualFile> processor = new Processor<VirtualFile>() {\n      private final VirtualFile virtualFileToIgnoreOccurrencesIn =\n        fileToIgnoreOccurrencesIn == null ? null : fileToIgnoreOccurrencesIn.getVirtualFile();\n\n      @Override\n      public boolean process(VirtualFile file) {\n        indicator.checkCanceled();\n        if (Comparing.equal(file, virtualFileToIgnoreOccurrencesIn)) return true;\n        final int value = count.incrementAndGet();\n        return value < 10;\n      }\n    };\n    List<IdIndexEntry> keys = getWordEntries(name, true);\n    boolean cheap = keys.isEmpty() || processFilesContainingAllKeys(myManager.getProject(), scope, null, keys, processor);\n\n    if (!cheap) {\n      return SearchCostResult.TOO_MANY_OCCURRENCES;\n    }\n\n    return count.get() == 0 ? SearchCostResult.ZERO_OCCURRENCES : SearchCostResult.FEW_OCCURRENCES;\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processElementsWithWord(@NotNull final TextOccurenceProcessor processor,\n                                         @NotNull SearchScope searchScope,\n                                         @NotNull final String text,\n                                         final short searchContext,\n                                         @NotNull EnumSet<Options> options,\n                                         @Nullable String containerName) {\n    if (text.isEmpty()) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text\");\n    }\n    final ProgressIndicator progress = ProgressIndicatorProvider.getGlobalProgressIndicator();\n    if (searchScope instanceof GlobalSearchScope) {\n      StringSearcher searcher = new StringSearcher(text, options.contains(Options.CASE_SENSITIVE_SEARCH), true,\n                                                   searchContext == UsageSearchContext.IN_STRINGS,\n                                                   options.contains(Options.PROCESS_ONLY_JAVA_IDENTIFIERS_IF_POSSIBLE));\n\n      return processElementsWithTextInGlobalScope(processor,\n                                                  (GlobalSearchScope)searchScope,\n                                                  searcher,\n                                                  searchContext, options.contains(Options.CASE_SENSITIVE_SEARCH), containerName, progress,\n                                                  options.contains(Options.PROCESS_INJECTED_PSI));\n    }\n    LocalSearchScope scope = (LocalSearchScope)searchScope;\n    PsiElement[] scopeElements = scope.getScope();\n    final StringSearcher searcher = new StringSearcher(text, options.contains(Options.CASE_SENSITIVE_SEARCH), true,\n                                                       searchContext == UsageSearchContext.IN_STRINGS,\n                                                       options.contains(Options.PROCESS_ONLY_JAVA_IDENTIFIERS_IF_POSSIBLE));\n    Processor<PsiElement> localProcessor = localProcessor(processor, progress, options.contains(Options.PROCESS_INJECTED_PSI), searcher);\n    return JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Arrays.asList(scopeElements), progress, true, true, localProcessor);\n  }","id":78839,"modified_method":"public boolean processElementsWithWord(@NotNull final TextOccurenceProcessor processor,\n                                         @NotNull SearchScope searchScope,\n                                         @NotNull final String text,\n                                         final short searchContext,\n                                         @NotNull EnumSet<Options> options,\n                                         @Nullable String containerName) {\n    if (text.isEmpty()) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text\");\n    }\n    ProgressIndicator progress = getOrCreateIndicator();\n    if (searchScope instanceof GlobalSearchScope) {\n      StringSearcher searcher = new StringSearcher(text, options.contains(Options.CASE_SENSITIVE_SEARCH), true,\n                                                   searchContext == UsageSearchContext.IN_STRINGS,\n                                                   options.contains(Options.PROCESS_ONLY_JAVA_IDENTIFIERS_IF_POSSIBLE));\n\n      return processElementsWithTextInGlobalScope(processor,\n                                                  (GlobalSearchScope)searchScope,\n                                                  searcher,\n                                                  searchContext, options.contains(Options.CASE_SENSITIVE_SEARCH), containerName, progress,\n                                                  options.contains(Options.PROCESS_INJECTED_PSI));\n    }\n    LocalSearchScope scope = (LocalSearchScope)searchScope;\n    PsiElement[] scopeElements = scope.getScope();\n    final StringSearcher searcher = new StringSearcher(text, options.contains(Options.CASE_SENSITIVE_SEARCH), true,\n                                                       searchContext == UsageSearchContext.IN_STRINGS,\n                                                       options.contains(Options.PROCESS_ONLY_JAVA_IDENTIFIERS_IF_POSSIBLE));\n    Processor<PsiElement> localProcessor = localProcessor(processor, progress, options.contains(Options.PROCESS_INJECTED_PSI), searcher);\n    return JobLauncher.getInstance().invokeConcurrentlyUnderProgress(Arrays.asList(scopeElements), progress, true, true, localProcessor);\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processVirtualFile(@NotNull final VirtualFile vfile,\n                                  final ProgressIndicator progress,\n                                  @NotNull final Processor<? super PsiFile> localProcessor,\n                                  @NotNull final AtomicBoolean canceled,\n                                  @NotNull AtomicInteger counter,\n                                  int totalSize) throws ApplicationUtil.CannotRunReadActionException {\n    final PsiFile file = ApplicationUtil.tryRunReadAction(new Computable<PsiFile>() {\n      @Override\n      public PsiFile compute() {\n        return vfile.isValid() ? myManager.findFile(vfile) : null;\n      }\n    });\n    if (file != null && !(file instanceof PsiBinaryFile)) {\n      // load contents outside read action\n      if (FileDocumentManager.getInstance().getCachedDocument(vfile) == null) {\n        // cache bytes in vfs\n        try {\n          vfile.contentsToByteArray();\n        }\n        catch (IOException ignored) {\n        }\n      }\n      ApplicationUtil.tryRunReadAction(new Computable<Void>() {\n        @Override\n        public Void compute() {\n          if (myManager.getProject().isDisposed()) throw new ProcessCanceledException();\n          List<PsiFile> psiRoots = file.getViewProvider().getAllFiles();\n          Set<PsiFile> processed = new THashSet<PsiFile>(psiRoots.size() * 2, (float)0.5);\n          for (final PsiFile psiRoot : psiRoots) {\n            checkCanceled(progress);\n            assert psiRoot != null : \"One of the roots of file \" + file + \" is null. All roots: \" + psiRoots + \"; ViewProvider: \" +\n                                     file.getViewProvider() + \"; Virtual file: \" + file.getViewProvider().getVirtualFile();\n            if (!processed.add(psiRoot)) continue;\n            if (!psiRoot.isValid()) {\n              continue;\n            }\n\n            if (!localProcessor.process(psiRoot)) {\n              canceled.set(true);\n              break;\n            }\n          }\n          return null;\n        }\n      });\n    }\n    if (progress != null && progress.isRunning()) {\n      double fraction = (double)counter.incrementAndGet() / totalSize;\n      progress.setFraction(fraction);\n    }\n  }","id":78840,"modified_method":"private void processVirtualFile(@NotNull final VirtualFile vfile,\n                                  @NotNull final ProgressIndicator progress,\n                                  @NotNull final Processor<? super PsiFile> localProcessor,\n                                  @NotNull final AtomicBoolean canceled,\n                                  @NotNull AtomicInteger counter,\n                                  int totalSize) throws ApplicationUtil.CannotRunReadActionException {\n    final PsiFile file = ApplicationUtil.tryRunReadAction(new Computable<PsiFile>() {\n      @Override\n      public PsiFile compute() {\n        return vfile.isValid() ? myManager.findFile(vfile) : null;\n      }\n    });\n    if (file != null && !(file instanceof PsiBinaryFile)) {\n      // load contents outside read action\n      if (FileDocumentManager.getInstance().getCachedDocument(vfile) == null) {\n        // cache bytes in vfs\n        try {\n          vfile.contentsToByteArray();\n        }\n        catch (IOException ignored) {\n        }\n      }\n      ApplicationUtil.tryRunReadAction(new Computable<Void>() {\n        @Override\n        public Void compute() {\n          if (myManager.getProject().isDisposed()) throw new ProcessCanceledException();\n          List<PsiFile> psiRoots = file.getViewProvider().getAllFiles();\n          Set<PsiFile> processed = new THashSet<PsiFile>(psiRoots.size() * 2, (float)0.5);\n          for (final PsiFile psiRoot : psiRoots) {\n            progress.checkCanceled();\n            assert psiRoot != null : \"One of the roots of file \" + file + \" is null. All roots: \" + psiRoots + \"; ViewProvider: \" +\n                                     file.getViewProvider() + \"; Virtual file: \" + file.getViewProvider().getVirtualFile();\n            if (!processed.add(psiRoot)) continue;\n            if (!psiRoot.isValid()) {\n              continue;\n            }\n\n            if (!localProcessor.process(psiRoot)) {\n              canceled.set(true);\n              break;\n            }\n          }\n          return null;\n        }\n      });\n    }\n    if (progress.isRunning()) {\n      double fraction = (double)counter.incrementAndGet() / totalSize;\n      progress.setFraction(fraction);\n    }\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void getFilesWithText(@NotNull GlobalSearchScope scope,\n                                final short searchContext,\n                                final boolean caseSensitively,\n                                @NotNull String text,\n                                final ProgressIndicator progress,\n                                @NotNull Collection<VirtualFile> result) {\n    myManager.startBatchFilesProcessingMode();\n    try {\n      Processor<VirtualFile> processor = new CommonProcessors.CollectProcessor<VirtualFile>(result){\n        @Override\n        public boolean process(VirtualFile file) {\n          checkCanceled(progress);\n          return super.process(file);\n        }\n      };\n      boolean success = processFilesWithText(scope, searchContext, caseSensitively, text, processor);\n      // success == false means exception in index\n    }\n    finally {\n      myManager.finishBatchFilesProcessingMode();\n    }\n  }","id":78841,"modified_method":"private void getFilesWithText(@NotNull GlobalSearchScope scope,\n                                final short searchContext,\n                                final boolean caseSensitively,\n                                @NotNull String text,\n                                @NotNull final ProgressIndicator progress,\n                                @NotNull Collection<VirtualFile> result) {\n    myManager.startBatchFilesProcessingMode();\n    try {\n      Processor<VirtualFile> processor = new CommonProcessors.CollectProcessor<VirtualFile>(result){\n        @Override\n        public boolean process(VirtualFile file) {\n          progress.checkCanceled();\n          return super.process(file);\n        }\n      };\n      boolean success = processFilesWithText(scope, searchContext, caseSensitively, text, processor);\n      // success == false means exception in index\n    }\n    finally {\n      myManager.finishBatchFilesProcessingMode();\n    }\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean processUsagesInNonJavaFiles(@Nullable final PsiElement originalElement,\n                                             @NotNull String qName,\n                                             @NotNull final PsiNonJavaFileReferenceProcessor processor,\n                                             @NotNull final GlobalSearchScope initialScope) {\n    if (qName.isEmpty()) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text. Element: \"+originalElement+ \"; \"+(originalElement == null ? null : originalElement.getClass()));\n    }\n    final ProgressIndicator progress = ProgressIndicatorProvider.getGlobalProgressIndicator();\n\n    int dotIndex = qName.lastIndexOf('.');\n    int dollarIndex = qName.lastIndexOf('$');\n    int maxIndex = Math.max(dotIndex, dollarIndex);\n    final String wordToSearch = maxIndex >= 0 ? qName.substring(maxIndex + 1) : qName;\n    final GlobalSearchScope theSearchScope = ApplicationManager.getApplication().runReadAction(new Computable<GlobalSearchScope>() {\n      @Override\n      public GlobalSearchScope compute() {\n        if (originalElement != null && myManager.isInProject(originalElement) && initialScope.isSearchInLibraries()) {\n          return initialScope.intersectWith(GlobalSearchScope.projectScope(myManager.getProject()));\n        }\n        return initialScope;\n      }\n    });\n    PsiFile[] files = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile[]>() {\n      @Override\n      public PsiFile[] compute() {\n        return CacheManager.SERVICE.getInstance(myManager.getProject()).getFilesWithWord(wordToSearch, UsageSearchContext.IN_PLAIN_TEXT, theSearchScope, true);\n      }\n    });\n\n    final StringSearcher searcher = new StringSearcher(qName, true, true, false);\n    final int patternLength = searcher.getPattern().length();\n\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.search.in.non.java.files.progress\"));\n    }\n\n    final SearchScope useScope = originalElement == null ? null : ApplicationManager.getApplication().runReadAction(new Computable<SearchScope>() {\n      @Override\n      public SearchScope compute() {\n        return getUseScope(originalElement);\n      }\n    });\n\n    final Ref<Boolean> cancelled = new Ref<Boolean>(Boolean.FALSE);\n    for (int i = 0; i < files.length; i++) {\n      checkCanceled(progress);\n      final PsiFile psiFile = files[i];\n      if (psiFile instanceof PsiBinaryFile) continue;\n\n      final CharSequence text = ApplicationManager.getApplication().runReadAction(new Computable<CharSequence>() {\n        @Override\n        public CharSequence compute() {\n          return psiFile.getViewProvider().getContents();\n        }\n      });\n      final char[] textArray = ApplicationManager.getApplication().runReadAction(new Computable<char[]>() {\n        @Override\n        public char[] compute() {\n          return CharArrayUtil.fromSequenceWithoutCopying(text);\n        }\n      });\n      for (int index = LowLevelSearchUtil.searchWord(text, textArray, 0, text.length(), searcher, progress); index >= 0;) {\n        final int finalIndex = index;\n        boolean isReferenceOK = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n          @Override\n          public Boolean compute() {\n            PsiReference referenceAt = psiFile.findReferenceAt(finalIndex);\n            return referenceAt == null || useScope == null ||\n                   !PsiSearchScopeUtil.isInScope(useScope.intersectWith(initialScope), psiFile);\n          }\n        });\n        if (isReferenceOK && !processor.process(psiFile, index, index + patternLength)) {\n          cancelled.set(Boolean.TRUE);\n          break;\n        }\n\n        index = LowLevelSearchUtil.searchWord(text, textArray, index + patternLength, text.length(), searcher, progress);\n      }\n      if (cancelled.get()) break;\n      if (progress != null) {\n        progress.setFraction((double)(i + 1) / files.length);\n      }\n    }\n\n    if (progress != null) {\n      progress.popState();\n    }\n    return !cancelled.get();\n  }","id":78842,"modified_method":"@Override\n  public boolean processUsagesInNonJavaFiles(@Nullable final PsiElement originalElement,\n                                             @NotNull String qName,\n                                             @NotNull final PsiNonJavaFileReferenceProcessor processor,\n                                             @NotNull final GlobalSearchScope initialScope) {\n    if (qName.isEmpty()) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text. Element: \"+originalElement+ \"; \"+(originalElement == null ? null : originalElement.getClass()));\n    }\n    final ProgressIndicator progress = getOrCreateIndicator();\n\n    int dotIndex = qName.lastIndexOf('.');\n    int dollarIndex = qName.lastIndexOf('$');\n    int maxIndex = Math.max(dotIndex, dollarIndex);\n    final String wordToSearch = maxIndex >= 0 ? qName.substring(maxIndex + 1) : qName;\n    final GlobalSearchScope theSearchScope = ApplicationManager.getApplication().runReadAction(new Computable<GlobalSearchScope>() {\n      @Override\n      public GlobalSearchScope compute() {\n        if (originalElement != null && myManager.isInProject(originalElement) && initialScope.isSearchInLibraries()) {\n          return initialScope.intersectWith(GlobalSearchScope.projectScope(myManager.getProject()));\n        }\n        return initialScope;\n      }\n    });\n    PsiFile[] files = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile[]>() {\n      @Override\n      public PsiFile[] compute() {\n        return CacheManager.SERVICE.getInstance(myManager.getProject()).getFilesWithWord(wordToSearch, UsageSearchContext.IN_PLAIN_TEXT, theSearchScope, true);\n      }\n    });\n\n    final StringSearcher searcher = new StringSearcher(qName, true, true, false);\n    final int patternLength = searcher.getPattern().length();\n\n    progress.pushState();\n    progress.setText(PsiBundle.message(\"psi.search.in.non.java.files.progress\"));\n\n    final SearchScope useScope = originalElement == null ? null : ApplicationManager.getApplication().runReadAction(new Computable<SearchScope>() {\n      @Override\n      public SearchScope compute() {\n        return getUseScope(originalElement);\n      }\n    });\n\n    final Ref<Boolean> cancelled = new Ref<Boolean>(Boolean.FALSE);\n    for (int i = 0; i < files.length; i++) {\n      progress.checkCanceled();\n      final PsiFile psiFile = files[i];\n      if (psiFile instanceof PsiBinaryFile) continue;\n\n      final CharSequence text = ApplicationManager.getApplication().runReadAction(new Computable<CharSequence>() {\n        @Override\n        public CharSequence compute() {\n          return psiFile.getViewProvider().getContents();\n        }\n      });\n      final char[] textArray = ApplicationManager.getApplication().runReadAction(new Computable<char[]>() {\n        @Override\n        public char[] compute() {\n          return CharArrayUtil.fromSequenceWithoutCopying(text);\n        }\n      });\n      int index = LowLevelSearchUtil.searchWord(text, textArray, 0, text.length(), searcher, progress);\n      while(index >= 0) {\n        final int finalIndex = index;\n        boolean isReferenceOK = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n          @Override\n          public Boolean compute() {\n            PsiReference referenceAt = psiFile.findReferenceAt(finalIndex);\n            return referenceAt == null || useScope == null ||\n                   !PsiSearchScopeUtil.isInScope(useScope.intersectWith(initialScope), psiFile);\n          }\n        });\n        if (isReferenceOK && !processor.process(psiFile, index, index + patternLength)) {\n          cancelled.set(Boolean.TRUE);\n          break;\n        }\n\n        index = LowLevelSearchUtil.searchWord(text, textArray, index + patternLength, text.length(), searcher, progress);\n      }\n      if (cancelled.get()) break;\n      progress.setFraction((double)(i + 1) / files.length);\n    }\n\n    progress.popState();\n    return !cancelled.get();\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param files to scan for references in this pass.\n   * @param totalSize the number of files to scan in both passes. Can be different from <code>files.size()<\/code> in case of\n   *                  two-pass scan, where we first scan files containing container name and then all the rest files.\n   * @param alreadyProcessedFiles the number of files scanned in previous pass.\n   * @return true if completed\n   */\n  private boolean processPsiFileRoots(@NotNull List<VirtualFile> files,\n                                      final int totalSize,\n                                      int alreadyProcessedFiles,\n                                      final ProgressIndicator progress,\n                                      @NotNull final Processor<? super PsiFile> localProcessor) {\n    myManager.startBatchFilesProcessingMode();\n    try {\n      final AtomicInteger counter = new AtomicInteger(alreadyProcessedFiles);\n      final AtomicBoolean canceled = new AtomicBoolean(false);\n\n      final List<VirtualFile> failedFiles = Collections.synchronizedList(new SmartList<VirtualFile>());\n      boolean completed =\n        JobLauncher.getInstance().invokeConcurrentlyUnderProgress(files, progress, false, false, new Processor<VirtualFile>() {\n          @Override\n          public boolean process(final VirtualFile vfile) {\n            try {\n              TooManyUsagesStatus.getFrom(progress).pauseProcessingIfTooManyUsages();\n              processVirtualFile(vfile, progress, localProcessor, canceled, counter, totalSize);\n            }\n            catch (ApplicationUtil.CannotRunReadActionException action) {\n              failedFiles.add(vfile);\n            }\n            return !canceled.get();\n          }\n        });\n      if (!failedFiles.isEmpty()) {\n        for (final VirtualFile vfile : failedFiles) {\n          checkCanceled(progress);\n          TooManyUsagesStatus.getFrom(progress).pauseProcessingIfTooManyUsages();\n          // we failed to run read action in job launcher thread\n          // run read action in our thread instead\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            @Override\n            public void run() {\n              processVirtualFile(vfile, progress, localProcessor, canceled, counter, totalSize);\n            }\n          });\n        }\n      }\n      return completed;\n    }\n    finally {\n      myManager.finishBatchFilesProcessingMode();\n    }\n\n  }","id":78843,"modified_method":"/**\n   * @param files to scan for references in this pass.\n   * @param totalSize the number of files to scan in both passes. Can be different from <code>files.size()<\/code> in case of\n   *                  two-pass scan, where we first scan files containing container name and then all the rest files.\n   * @param alreadyProcessedFiles the number of files scanned in previous pass.\n   * @return true if completed\n   */\n  private boolean processPsiFileRoots(@NotNull List<VirtualFile> files,\n                                      final int totalSize,\n                                      int alreadyProcessedFiles,\n                                      @NotNull final ProgressIndicator progress,\n                                      @NotNull final Processor<? super PsiFile> localProcessor) {\n    myManager.startBatchFilesProcessingMode();\n    try {\n      final AtomicInteger counter = new AtomicInteger(alreadyProcessedFiles);\n      final AtomicBoolean canceled = new AtomicBoolean(false);\n\n      final List<VirtualFile> failedFiles = Collections.synchronizedList(new SmartList<VirtualFile>());\n      boolean completed =\n        JobLauncher.getInstance().invokeConcurrentlyUnderProgress(files, progress, false, false, new Processor<VirtualFile>() {\n          @Override\n          public boolean process(final VirtualFile vfile) {\n            try {\n              TooManyUsagesStatus.getFrom(progress).pauseProcessingIfTooManyUsages();\n              processVirtualFile(vfile, progress, localProcessor, canceled, counter, totalSize);\n            }\n            catch (ApplicationUtil.CannotRunReadActionException action) {\n              failedFiles.add(vfile);\n            }\n            return !canceled.get();\n          }\n        });\n      if (!failedFiles.isEmpty()) {\n        for (final VirtualFile vfile : failedFiles) {\n          progress.checkCanceled();\n          TooManyUsagesStatus.getFrom(progress).pauseProcessingIfTooManyUsages();\n          // we failed to run read action in job launcher thread\n          // run read action in our thread instead\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            @Override\n            public void run() {\n              processVirtualFile(vfile, progress, localProcessor, canceled, counter, totalSize);\n            }\n          });\n        }\n      }\n      return completed;\n    }\n    finally {\n      myManager.finishBatchFilesProcessingMode();\n    }\n\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processGlobalRequestsOptimized(@NotNull MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                                                 final ProgressIndicator progress,\n                                                 @NotNull final Map<RequestWithProcessor, Processor<PsiElement>> localProcessors) {\n    if (singles.isEmpty()) {\n      return true;\n    }\n\n    if (singles.size() == 1) {\n      final Collection<? extends RequestWithProcessor> requests = singles.values();\n      if (requests.size() == 1) {\n        final RequestWithProcessor theOnly = requests.iterator().next();\n        return processSingleRequest(theOnly.request, theOnly.refProcessor);\n      }\n    }\n\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    }\n    boolean result;\n\n    try {\n      // intersectionCandidateFiles holds files containing words from all requests in `singles` and words in corresponding container names\n      final MultiMap<VirtualFile, RequestWithProcessor> intersectionCandidateFiles = createMultiMap();\n      // restCandidateFiles holds files containing words from all requests in `singles` but EXCLUDING words in corresponding container names\n      final MultiMap<VirtualFile, RequestWithProcessor> restCandidateFiles = createMultiMap();\n      collectFiles(singles, progress, intersectionCandidateFiles, restCandidateFiles);\n\n      if (intersectionCandidateFiles.isEmpty() && restCandidateFiles.isEmpty()) {\n        return true;\n      }\n\n      if (progress != null) {\n        final Set<String> allWords = new TreeSet<String>();\n        for (RequestWithProcessor singleRequest : localProcessors.keySet()) {\n          allWords.add(singleRequest.request.word);\n        }\n        progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", getPresentableWordsDescription(allWords)));\n      }\n\n      if (intersectionCandidateFiles.isEmpty()) {\n        result = processCandidates(progress, localProcessors, restCandidateFiles, restCandidateFiles.size(), 0);\n      }\n      else {\n        int totalSize = restCandidateFiles.size() + intersectionCandidateFiles.size();\n        result = processCandidates(progress, localProcessors, intersectionCandidateFiles, totalSize, 0);\n        if (result) {\n          result = processCandidates(progress, localProcessors, restCandidateFiles, totalSize, intersectionCandidateFiles.size());\n        }\n      }\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n    }\n\n    return result;\n  }","id":78844,"modified_method":"private boolean processGlobalRequestsOptimized(@NotNull MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                                                 @NotNull ProgressIndicator progress,\n                                                 @NotNull final Map<RequestWithProcessor, Processor<PsiElement>> localProcessors) {\n    if (singles.isEmpty()) {\n      return true;\n    }\n\n    if (singles.size() == 1) {\n      final Collection<? extends RequestWithProcessor> requests = singles.values();\n      if (requests.size() == 1) {\n        final RequestWithProcessor theOnly = requests.iterator().next();\n        return processSingleRequest(theOnly.request, theOnly.refProcessor);\n      }\n    }\n\n    progress.pushState();\n    progress.setText(PsiBundle.message(\"psi.scanning.files.progress\"));\n    boolean result;\n\n    try {\n      // intersectionCandidateFiles holds files containing words from all requests in `singles` and words in corresponding container names\n      final MultiMap<VirtualFile, RequestWithProcessor> intersectionCandidateFiles = createMultiMap();\n      // restCandidateFiles holds files containing words from all requests in `singles` but EXCLUDING words in corresponding container names\n      final MultiMap<VirtualFile, RequestWithProcessor> restCandidateFiles = createMultiMap();\n      collectFiles(singles, progress, intersectionCandidateFiles, restCandidateFiles);\n\n      if (intersectionCandidateFiles.isEmpty() && restCandidateFiles.isEmpty()) {\n        return true;\n      }\n\n      final Set<String> allWords = new TreeSet<String>();\n      for (RequestWithProcessor singleRequest : localProcessors.keySet()) {\n        allWords.add(singleRequest.request.word);\n      }\n      progress.setText(PsiBundle.message(\"psi.search.for.word.progress\", getPresentableWordsDescription(allWords)));\n\n      if (intersectionCandidateFiles.isEmpty()) {\n        result = processCandidates(localProcessors, restCandidateFiles, progress, restCandidateFiles.size(), 0);\n      }\n      else {\n        int totalSize = restCandidateFiles.size() + intersectionCandidateFiles.size();\n        result = processCandidates(localProcessors, intersectionCandidateFiles, progress, totalSize, 0);\n        if (result) {\n          result = processCandidates(localProcessors, restCandidateFiles, progress, totalSize, intersectionCandidateFiles.size());\n        }\n      }\n    }\n    finally {\n      progress.popState();\n    }\n\n    return result;\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public PsiElement[] findCommentsContainingIdentifier(@NotNull String identifier, @NotNull SearchScope searchScope) {\n    final ArrayList<PsiElement> results = new ArrayList<PsiElement>();\n    processCommentsContainingIdentifier(identifier, searchScope, new Processor<PsiElement>() {\n      @Override\n      public boolean process(PsiElement element) {\n        synchronized (results) {\n          results.add(element);\n        }\n        return true;\n      }\n    });\n    synchronized (results) {\n      return PsiUtilCore.toPsiElementArray(results);\n    }\n  }","id":78845,"modified_method":"@Override\n  @NotNull\n  public PsiElement[] findCommentsContainingIdentifier(@NotNull String identifier, @NotNull SearchScope searchScope) {\n    final List<PsiElement> results = Collections.synchronizedList(new ArrayList<PsiElement>());\n    processCommentsContainingIdentifier(identifier, searchScope, new CommonProcessors.CollectProcessor<PsiElement>(results));\n    return PsiUtilCore.toPsiElementArray(results);\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void collectFiles(@NotNull MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                            ProgressIndicator progress,\n                            @NotNull final MultiMap<VirtualFile, RequestWithProcessor> intersectionResult,\n                            @NotNull final MultiMap<VirtualFile, RequestWithProcessor> restResult) {\n    for (final Set<IdIndexEntry> keys : singles.keySet()) {\n      if (keys.isEmpty()) {\n        continue;\n      }\n\n      final Collection<RequestWithProcessor> data = singles.get(keys);\n      final GlobalSearchScope commonScope = uniteScopes(data);\n      final Set<VirtualFile> intersectionWithContainerNameFiles = intersectionWithContainerNameFiles(commonScope, data, keys);\n\n      List<VirtualFile> files = new ArrayList<VirtualFile>();\n      CommonProcessors.CollectProcessor<VirtualFile> processor = new CommonProcessors.CollectProcessor<VirtualFile>(files);\n      processFilesContainingAllKeys(myManager.getProject(), commonScope, null, keys, processor);\n      for (final VirtualFile file : files) {\n        checkCanceled(progress);\n        for (final IdIndexEntry entry : keys) {\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            @Override\n            public void run() {\n              FileBasedIndex.getInstance().processValues(IdIndex.NAME, entry, file, new FileBasedIndex.ValueProcessor<Integer>() {\n                @Override\n                public boolean process(VirtualFile file, Integer value) {\n                  int mask = value.intValue();\n                  for (RequestWithProcessor single : data) {\n                    final PsiSearchRequest request = single.request;\n                    if ((mask & request.searchContext) != 0 && ((GlobalSearchScope)request.searchScope).contains(file)) {\n                      MultiMap<VirtualFile, RequestWithProcessor> result =\n                        intersectionWithContainerNameFiles == null || !intersectionWithContainerNameFiles.contains(file) ? restResult : intersectionResult;\n                      result.putValue(file, single);\n                    }\n                  }\n                  return true;\n                }\n              }, commonScope);\n            }\n          });\n        }\n      }\n    }\n  }","id":78846,"modified_method":"private void collectFiles(@NotNull MultiMap<Set<IdIndexEntry>, RequestWithProcessor> singles,\n                            @NotNull ProgressIndicator progress,\n                            @NotNull final MultiMap<VirtualFile, RequestWithProcessor> intersectionResult,\n                            @NotNull final MultiMap<VirtualFile, RequestWithProcessor> restResult) {\n    for (final Set<IdIndexEntry> keys : singles.keySet()) {\n      if (keys.isEmpty()) {\n        continue;\n      }\n\n      final Collection<RequestWithProcessor> data = singles.get(keys);\n      final GlobalSearchScope commonScope = uniteScopes(data);\n      final Set<VirtualFile> intersectionWithContainerNameFiles = intersectionWithContainerNameFiles(commonScope, data, keys);\n\n      List<VirtualFile> files = new ArrayList<VirtualFile>();\n      Processor<VirtualFile> processor = new CommonProcessors.CollectProcessor<VirtualFile>(files);\n      processFilesContainingAllKeys(myManager.getProject(), commonScope, null, keys, processor);\n      for (final VirtualFile file : files) {\n        progress.checkCanceled();\n        for (final IdIndexEntry entry : keys) {\n          ApplicationManager.getApplication().runReadAction(new Runnable() {\n            @Override\n            public void run() {\n              FileBasedIndex.getInstance().processValues(IdIndex.NAME, entry, file, new FileBasedIndex.ValueProcessor<Integer>() {\n                @Override\n                public boolean process(VirtualFile file, Integer value) {\n                  int mask = value.intValue();\n                  for (RequestWithProcessor single : data) {\n                    final PsiSearchRequest request = single.request;\n                    if ((mask & request.searchContext) != 0 && ((GlobalSearchScope)request.searchScope).contains(file)) {\n                      MultiMap<VirtualFile, RequestWithProcessor> result =\n                        intersectionWithContainerNameFiles == null || !intersectionWithContainerNameFiles.contains(file) ? restResult : intersectionResult;\n                      result.putValue(file, single);\n                    }\n                  }\n                  return true;\n                }\n              }, commonScope);\n            }\n          });\n        }\n      }\n    }\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean processRequests(@NotNull SearchRequestCollector collector, @NotNull Processor<PsiReference> processor) {\n    final Map<SearchRequestCollector, Processor<PsiReference>> collectors = ContainerUtil.newHashMap();\n    collectors.put(collector, processor);\n\n    ProgressIndicator progress = ProgressIndicatorProvider.getGlobalProgressIndicator();\n    appendCollectorsFromQueryRequests(collectors);\n    boolean result;\n    do {\n      MultiMap<Set<IdIndexEntry>, RequestWithProcessor> globals = new MultiMap<Set<IdIndexEntry>, RequestWithProcessor>();\n      final List<Computable<Boolean>> customs = ContainerUtil.newArrayList();\n      final Set<RequestWithProcessor> locals = ContainerUtil.newLinkedHashSet();\n      Map<RequestWithProcessor, Processor<PsiElement>> localProcessors = new THashMap<RequestWithProcessor, Processor<PsiElement>>();\n      distributePrimitives(collectors, locals, globals, customs, localProcessors, progress);\n      result = processGlobalRequestsOptimized(globals, progress, localProcessors);\n      if (result) {\n        for (RequestWithProcessor local : locals) {\n          result = processSingleRequest(local.request, local.refProcessor);\n          if (!result) break;\n        }\n        if (result) {\n          for (Computable<Boolean> custom : customs) {\n            result = custom.compute();\n            if (!result) break;\n          }\n        }\n        if (!result) break;\n      }\n    }\n    while(appendCollectorsFromQueryRequests(collectors));\n    return result;\n  }","id":78847,"modified_method":"@Override\n  public boolean processRequests(@NotNull SearchRequestCollector collector, @NotNull Processor<PsiReference> processor) {\n    final Map<SearchRequestCollector, Processor<PsiReference>> collectors = ContainerUtil.newHashMap();\n    collectors.put(collector, processor);\n\n    ProgressIndicator progress = getOrCreateIndicator();\n    appendCollectorsFromQueryRequests(collectors);\n    boolean result;\n    do {\n      MultiMap<Set<IdIndexEntry>, RequestWithProcessor> globals = new MultiMap<Set<IdIndexEntry>, RequestWithProcessor>();\n      final List<Computable<Boolean>> customs = ContainerUtil.newArrayList();\n      final Set<RequestWithProcessor> locals = ContainerUtil.newLinkedHashSet();\n      Map<RequestWithProcessor, Processor<PsiElement>> localProcessors = new THashMap<RequestWithProcessor, Processor<PsiElement>>();\n      distributePrimitives(collectors, locals, globals, customs, localProcessors, progress);\n      result = processGlobalRequestsOptimized(globals, progress, localProcessors);\n      if (result) {\n        for (RequestWithProcessor local : locals) {\n          result = processSingleRequest(local.request, local.refProcessor);\n          if (!result) break;\n        }\n        if (result) {\n          for (Computable<Boolean> custom : customs) {\n            result = custom.compute();\n            if (!result) break;\n          }\n        }\n        if (!result) break;\n      }\n    }\n    while(appendCollectorsFromQueryRequests(collectors));\n    return result;\n  }","commit_id":"f61209413b12db87f76d81f0a86d2dd2b24c7c54","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public Expression createExpression(String expression) {\n        if (block != null) {\n            return block.createExpression(expression);\n        } else {\n            return null;\n        }\n    }","id":78848,"modified_method":"@Override\n    public Expression createExpression(String expression) {\n        Expression answer = null;\n        if (block != null) {\n            answer = block.createExpression(expression);\n        }\n        if (answer == null) {\n            // there quoted literal is empty\n            answer = ExpressionBuilder.constantExpression(\"\");\n        }\n        return answer;\n    }","commit_id":"c31cc5fec2755222d92ab14f8cb0f02094536371","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Expression createExpression(String expression) {\n        if (block != null) {\n            return block.createExpression(expression);\n        } else {\n            return null;\n        }\n    }","id":78849,"modified_method":"@Override\n    public Expression createExpression(String expression) {\n        Expression answer = null;\n        if (block != null) {\n            answer = block.createExpression(expression);\n        }\n        if (answer == null) {\n            // there quoted literal is empty\n            answer = ExpressionBuilder.constantExpression(\"\");\n        }\n        return answer;\n    }","commit_id":"c31cc5fec2755222d92ab14f8cb0f02094536371","url":"https://github.com/apache/camel"},{"original_method":"public FileLanguage() {\n        // do not allow escaping, as Windows uses \\ as path separator\n        setAllowEscape(false);\n    }","id":78850,"modified_method":"public FileLanguage() {\n        // do not allow escaping, as Windows uses \\ as path separator\n        allowEscape = false;\n    }","commit_id":"48c7fc8ec6ea10cc7f61de0cd30cd2858869e106","url":"https://github.com/apache/camel"},{"original_method":"private Expression createExpression(Exchange exchange) {\n        SimpleLanguage simple = (SimpleLanguage) exchange.getContext().resolveLanguage(\"simple\");\n        if (resultType != null) {\n            simple.setResultType(resultType);\n        }\n        // resolve property placeholders\n        try {\n            String resolve = exchange.getContext().resolvePropertyPlaceholders(text);\n            return simple.createExpression(resolve);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapCamelExecutionException(exchange, e);\n        }\n    }","id":78851,"modified_method":"private Expression createExpression(Exchange exchange) {\n        SimpleLanguage simple = (SimpleLanguage) exchange.getContext().resolveLanguage(\"simple\");\n        // resolve property placeholders\n        try {\n            String resolve = exchange.getContext().resolvePropertyPlaceholders(text);\n            Expression exp = simple.createExpression(resolve);\n            if (resultType != null) {\n                exp = ExpressionBuilder.convertToExpression(exp, resultType);\n            }\n            return exp;\n        } catch (Exception e) {\n            throw ObjectHelper.wrapCamelExecutionException(exchange, e);\n        }\n    }","commit_id":"48c7fc8ec6ea10cc7f61de0cd30cd2858869e106","url":"https://github.com/apache/camel"},{"original_method":"private Predicate createPredicate(Exchange exchange) {\n        SimpleLanguage simple = (SimpleLanguage) exchange.getContext().resolveLanguage(\"simple\");\n        if (resultType != null) {\n            simple.setResultType(resultType);\n        }\n        // resolve property placeholders\n        try {\n            String resolve = exchange.getContext().resolvePropertyPlaceholders(text);\n            return simple.createPredicate(resolve);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapCamelExecutionException(exchange, e);\n        }\n    }","id":78852,"modified_method":"private Predicate createPredicate(Exchange exchange) {\n        SimpleLanguage simple = (SimpleLanguage) exchange.getContext().resolveLanguage(\"simple\");\n        // resolve property placeholders\n        try {\n            String resolve = exchange.getContext().resolvePropertyPlaceholders(text);\n            return simple.createPredicate(resolve);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapCamelExecutionException(exchange, e);\n        }\n    }","commit_id":"48c7fc8ec6ea10cc7f61de0cd30cd2858869e106","url":"https://github.com/apache/camel"},{"original_method":"public Expression createExpression(String expression) {\n        ObjectHelper.notNull(expression, \"expression\");\n\n        expression = loadResource(expression);\n\n        // support old simple language syntax\n        @SuppressWarnings(\"deprecation\")\n        Expression answer = SimpleBackwardsCompatibleParser.parseExpression(expression, allowEscape);\n        if (answer == null) {\n            // use the new parser\n            SimpleExpressionParser parser = new SimpleExpressionParser(expression, allowEscape);\n            answer = parser.parseExpression();\n        }\n        if (resultType != null) {\n            answer = ExpressionBuilder.convertToExpression(answer, resultType);\n        }\n        return answer;\n    }","id":78853,"modified_method":"public Expression createExpression(String expression) {\n        ObjectHelper.notNull(expression, \"expression\");\n\n        expression = loadResource(expression);\n\n        // support old simple language syntax\n        @SuppressWarnings(\"deprecation\")\n        Expression answer = SimpleBackwardsCompatibleParser.parseExpression(expression, allowEscape);\n        if (answer == null) {\n            // use the new parser\n            SimpleExpressionParser parser = new SimpleExpressionParser(expression, allowEscape);\n            answer = parser.parseExpression();\n        }\n        return answer;\n    }","commit_id":"48c7fc8ec6ea10cc7f61de0cd30cd2858869e106","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates a new {@link Expression} (or {@link Predicate}\n     * if the resultType is a <tt>Boolean<\/tt>, or <tt>boolean<\/tt> type).\n     */\n    public static Expression simple(String expression, Class<?> resultType) {\n        SimpleLanguage answer = new SimpleLanguage();\n        answer.setResultType(resultType);\n        if (resultType == Boolean.class || resultType == boolean.class) {\n            // if its a boolean as result then its a predicate\n            Predicate predicate = answer.createPredicate(expression);\n            return PredicateToExpressionAdapter.toExpression(predicate);\n        } else {\n            return answer.createExpression(expression);\n        }\n    }","id":78854,"modified_method":"/**\n     * Creates a new {@link Expression} (or {@link Predicate}\n     * if the resultType is a <tt>Boolean<\/tt>, or <tt>boolean<\/tt> type).\n     */\n    public static Expression simple(String expression, Class<?> resultType) {\n        SimpleLanguage answer = new SimpleLanguage();\n        if (resultType == Boolean.class || resultType == boolean.class) {\n            // if its a boolean as result then its a predicate\n            Predicate predicate = answer.createPredicate(expression);\n            return PredicateToExpressionAdapter.toExpression(predicate);\n        } else {\n            Expression exp = answer.createExpression(expression);\n            if (resultType != null) {\n                exp = ExpressionBuilder.convertToExpression(exp, resultType);\n            }\n            return exp;\n        }\n    }","commit_id":"48c7fc8ec6ea10cc7f61de0cd30cd2858869e106","url":"https://github.com/apache/camel"},{"original_method":"public boolean nextChildren(XFormsElementContext context) throws SAXException {\n\n        // Remove ref that that we added earlier\n        if (!firstChild) {\n            context.popGroupRef();\n            // End group\n            super.end(context, Constants.XFORMS_NAMESPACE_URI, \"group\",\n                    Constants.XFORMS_PREFIX + \":group\");\n        }\n\n        while (currentIndex <= lastIndex) {\n            // Update context\n            context.pushGroupRef(context.getRefXPath() + \"[\" + currentIndex + \"]\");\n            context.setRepeatIdIndex(repeatId, currentIndex);\n\n            // Start group\n            AttributesImpl attributes = new AttributesImpl();\n            attributes.addAttribute(Constants.XXFORMS_NAMESPACE_URI, \"position\",\n                    Constants.XXFORMS_PREFIX + \":position\", \"CDATA\", Integer.toString(currentIndex));\n            super.start(context, Constants.XFORMS_NAMESPACE_URI, \"group\",\n                    Constants.XFORMS_PREFIX + \":group\", attributes);\n\n            // Prepare for next one\n            currentIndex++;\n            firstChild = false;\n            return true;\n        }\n        context.removeRepeatId(repeatId);\n        return false;\n    }","id":78855,"modified_method":"public boolean nextChildren(XFormsElementContext context) throws SAXException {\n\n        String variableName = \"v\" + context.getElementDepth();\n\n        if (firstChild) {\n            context.pushGroupRef(context.getRefXPath() + \"[$\" + variableName + \"]\");\n        } else {\n            // End group\n            super.end(context, Constants.XFORMS_NAMESPACE_URI, \"group\",\n                    Constants.XFORMS_PREFIX + \":group\");\n        }\n\n        if (currentIndex <= lastIndex) {\n            // Update context\n            context.setRepeatIdIndex(repeatId, variableName, currentIndex);\n\n            // Start group\n            AttributesImpl attributes = new AttributesImpl();\n            attributes.addAttribute(Constants.XXFORMS_NAMESPACE_URI, \"position\",\n                    Constants.XXFORMS_PREFIX + \":position\", \"CDATA\", Integer.toString(currentIndex));\n            super.start(context, Constants.XFORMS_NAMESPACE_URI, \"group\",\n                    Constants.XFORMS_PREFIX + \":group\", attributes);\n\n            // Prepare for next one\n            currentIndex++;\n            firstChild = false;\n            return true;\n        } else {\n            context.removeRepeatId(repeatId);\n            context.popGroupRef();\n            return false;\n        }\n    }","commit_id":"71eabd4aa72f55472e5cdb7acc0422245903ad4f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(XFormsElementContext context, String uri, String localname,\n                      String qname, Attributes attributes) throws SAXException {\n        final AttributesImpl newAttributes = new AttributesImpl(attributes);\n\n        if((\"if\".equals(localname) || \"when\".equals(localname)) && Constants.XXFORMS_NAMESPACE_URI.equals(uri)) {\n            String test = attributes.getValue(\"test\");\n            if(!test.startsWith(\"/\"))\n                test = context.getRefXPath() + \"/\" + test;\n            String value = XPathUtils.selectBooleanValue(context.getInstance(), test).toString();\n            addExtensionAttribute(newAttributes, \"value\", value);\n        } else if (context.getParentElement(0) instanceof Itemset\n                && (\"copy\".equals(localname) || \"label\".equals(localname))) {\n            // Pass information about the \"ref\" on the element to the parent \"itemset\"\n            Itemset itemset = (Itemset) context.getParentElement(0);\n            Map namespacesMap = new HashMap();\n            for (Enumeration e = context.getNamespaceSupport().getDeclaredPrefixes(); e.hasMoreElements();) {\n                String prefix = (String) e.nextElement();\n                namespacesMap.put(prefix, context.getNamespaceSupport().getURI(prefix));\n            }\n            NamespaceContext namespaceContext = new SimpleNamespaceContext(namespacesMap);\n            if (\"copy\".equals(localname)) {\n                itemset.setCopyRef(attributes.getValue(\"ref\"), namespaceContext);\n            } else {\n                itemset.setLabelRef(attributes.getValue(\"ref\"), namespaceContext);\n            }\n        } else {\n            // Add annotations about referenced element\n            if (attributes.getIndex(\"\", \"ref\") != -1\n                    || attributes.getIndex(Constants.XXFORMS_NAMESPACE_URI, \"position\") != -1) {\n                InstanceData instanceData  = context.getRefInstanceData();\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_READONLY_ATTRIBUTE_NAME, Boolean.toString(instanceData.getReadonly().get()));\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_RELEVANT_ATTRIBUTE_NAME, Boolean.toString(instanceData.getRelevant().get()));\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_REQUIRED_ATTRIBUTE_NAME, Boolean.toString(instanceData.getRequired().get()));\n                addExtensionAttribute(newAttributes, Constants.XXFORMS_VALID_ATTRIBUTE_NAME, Boolean.toString(instanceData.getValid().get()));\n                if (instanceData.getInvalidBindIds() != null)\n                    addExtensionAttribute(newAttributes, Constants.XXFORMS_INVALID_BIND_IDS_ATTRIBUTE_NAME, instanceData.getInvalidBindIds());\n                addExtensionAttribute(newAttributes, \"ref-xpath\", context.getRefXPath());\n                if (DATA_CONTROLS.containsKey(localname)) {\n                    addExtensionAttribute(newAttributes, \"name\", context.getRefName(true));\n                    addExtensionAttribute(newAttributes, \"value\", context.getRefValue());\n                }\n            }\n\n            // Rewrite XPath attributes into full XPath expressions\n            if (attributes.getIndex(\"\", \"ref\") != -1)\n                addExtensionAttribute(newAttributes, \"ref-xpath\", rewriteXPath(context, attributes.getValue(\"ref\")));\n            if (attributes.getIndex(\"\", \"nodeset\") != -1)\n                addExtensionAttribute(newAttributes, \"nodeset-xpath\", rewriteXPath(context, attributes.getValue(\"nodeset\")));\n            if (attributes.getIndex(\"\", \"at\") != -1)\n                addExtensionAttribute(newAttributes, \"at-xpath\", rewriteXPath(context, attributes.getValue(\"at\")));\n            if (attributes.getIndex(\"\", \"value\") != -1)\n                addExtensionAttribute(newAttributes, \"value-xpath\", rewriteXPath(context, attributes.getValue(\"value\")));\n        }\n        context.getContentHandler().startElement(uri, localname, qname, newAttributes);\n    }","id":78856,"modified_method":"public void start(XFormsElementContext context, String uri, String localname,\n                      String qname, Attributes attributes) throws SAXException {\n        try {\n            final AttributesImpl newAttributes = new AttributesImpl(attributes);\n            Map prefixToURI = new HashMap();\n            {\n                for (Enumeration e = context.getNamespaceSupport().getDeclaredPrefixes(); e.hasMoreElements();) {\n                    String prefix = (String) e.nextElement();\n                    prefixToURI.put(prefix, context.getNamespaceSupport().getURI(prefix));\n                }\n            }\n\n            if((\"if\".equals(localname) || \"when\".equals(localname)) && Constants.XXFORMS_NAMESPACE_URI.equals(uri)) {\n                String test = attributes.getValue(\"test\");\n                XPathExpression xpathExpression = XPathCache.createCacheXPath20(context.getPipelineContext(),\n                        context.getDocumentWrapper(), context.getDocumentWrapper().wrap(context.getRefNode()),\n                        \"boolean(\" + test + \")\", prefixToURI, context.getRepeatIdToIndex());\n                Boolean value = (Boolean) xpathExpression.evaluateSingle();\n                addExtensionAttribute(newAttributes, \"value\", Boolean.toString(value.booleanValue()));\n            } else if (context.getParentElement(0) instanceof Itemset\n                    && (\"copy\".equals(localname) || \"label\".equals(localname))) {\n                // Pass information about the \"ref\" on the element to the parent \"itemset\"\n                Itemset itemset = (Itemset) context.getParentElement(0);\n                NamespaceContext namespaceContext = new SimpleNamespaceContext(prefixToURI);\n                if (\"copy\".equals(localname)) {\n                    itemset.setCopyRef(attributes.getValue(\"ref\"), namespaceContext);\n                } else {\n                    itemset.setLabelRef(attributes.getValue(\"ref\"), namespaceContext);\n                }\n            } else {\n                // Add annotations about referenced element\n                if (attributes.getIndex(\"\", \"ref\") != -1\n                        || attributes.getIndex(Constants.XXFORMS_NAMESPACE_URI, \"position\") != -1) {\n                    InstanceData instanceData  = context.getRefInstanceData();\n                    addExtensionAttribute(newAttributes, Constants.XXFORMS_READONLY_ATTRIBUTE_NAME, Boolean.toString(instanceData.getReadonly().get()));\n                    addExtensionAttribute(newAttributes, Constants.XXFORMS_RELEVANT_ATTRIBUTE_NAME, Boolean.toString(instanceData.getRelevant().get()));\n                    addExtensionAttribute(newAttributes, Constants.XXFORMS_REQUIRED_ATTRIBUTE_NAME, Boolean.toString(instanceData.getRequired().get()));\n                    addExtensionAttribute(newAttributes, Constants.XXFORMS_VALID_ATTRIBUTE_NAME, Boolean.toString(instanceData.getValid().get()));\n                    if (instanceData.getInvalidBindIds() != null)\n                        addExtensionAttribute(newAttributes, Constants.XXFORMS_INVALID_BIND_IDS_ATTRIBUTE_NAME, instanceData.getInvalidBindIds());\n                    addExtensionAttribute(newAttributes, \"ref-xpath\", context.getRefXPath());\n                    if (DATA_CONTROLS.containsKey(localname)) {\n                        Node node = context.getRefNode();\n                        addExtensionAttribute(newAttributes, \"name\", context.getRefName(node, true));\n                        addExtensionAttribute(newAttributes, \"value\", context.getRefValue(node));\n                    }\n                }\n\n                // Rewrite XPath attributes into full XPath expressions\n                if (attributes.getIndex(\"\", \"ref\") != -1)\n                    addExtensionAttribute(newAttributes, \"ref-xpath\", rewriteXPath(context, attributes.getValue(\"ref\")));\n                if (attributes.getIndex(\"\", \"nodeset\") != -1)\n                    addExtensionAttribute(newAttributes, \"nodeset-xpath\", rewriteXPath(context, attributes.getValue(\"nodeset\")));\n                if (attributes.getIndex(\"\", \"at\") != -1)\n                    addExtensionAttribute(newAttributes, \"at-xpath\", rewriteXPath(context, attributes.getValue(\"at\")));\n                if (attributes.getIndex(\"\", \"value\") != -1)\n                    addExtensionAttribute(newAttributes, \"value-xpath\", rewriteXPath(context, attributes.getValue(\"value\")));\n            }\n            context.getContentHandler().startElement(uri, localname, qname, newAttributes);\n        } catch (XPathException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"71eabd4aa72f55472e5cdb7acc0422245903ad4f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private List getRefNodeList(String refXPath) {\n        Object value = XPathUtils.xpathWithFullURI(getPipelineContext(), refXPath).evaluate(instance);\n        List result = value instanceof List\n                ? (List) value : value instanceof Element || value instanceof Attribute\n                ? Collections.singletonList(value) : null;\n        if (result == null)\n            throw new OXFException(\"Expression '\" + refXPath\n                    + \"' must return an element, an attribute or a nodeset; it returned a \"\n                    + value.getClass().getName());\n        return result;\n    }","id":78857,"modified_method":"private List getRefNodeList(String refXPath) {\n        try {\n            List result = getXPathExpression(refXPath).evaluate();\n            if (result == null)\n                throw new OXFException(\"Expression '\" + refXPath\n                        + \"' must return an element, an attribute or a nodeset\");\n            return result;\n        } catch (XPathException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"71eabd4aa72f55472e5cdb7acc0422245903ad4f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Returns a name used in the output, which is an encoding of an XPath\n     * expression that can be evaluated on the instance.\n     * @param annotateElement\n     */\n    public String getRefName(boolean annotateElement) {\n        Object value = XPathUtils.xpathWithFullURI(getPipelineContext(), getRefXPath()).evaluate(instance);\n        if (!(value instanceof Element) && !(value instanceof Attribute))\n            throw new OXFException(\"Expression '\" + getRefXPath() + \"' must reference an element or an attribute\");\n        return XFormsUtils.getNameForNode((Node) value, annotateElement);\n    }","id":78858,"modified_method":"/**\n     * Returns a name used in the output, which is an encoding of an XPath\n     * expression that can be evaluated on the instance.\n     * @param annotateElement\n     */\n    public String getRefName(boolean annotateElement) {\n        try {\n            Object value = getXPathExpression(getRefXPath()).evaluateSingle();\n            if (!(value instanceof Element) && !(value instanceof Attribute))\n                throw new OXFException(\"Expression '\" + getRefXPath() + \"' must reference an element or an attribute\");\n            return getRefName((Node)value, annotateElement);\n        } catch (XPathException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"71eabd4aa72f55472e5cdb7acc0422245903ad4f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public XFormsElementContext(PipelineContext pipelineContext, Model model, Document instance,\n                                XFormsOutputConfig config, ContentHandler contentHandler) {\n        this.pipelineContext = pipelineContext;\n        this.model = model;\n        this.instance = instance;\n        this.config = config;\n        this.contentHandler = contentHandler;\n        this.contentHandlerHelper = new ContentHandlerHelper(contentHandler);\n    }","id":78859,"modified_method":"public XFormsElementContext(PipelineContext pipelineContext, Model model, Document instance,\n                                XFormsOutputConfig config, ContentHandler contentHandler) {\n        try {\n            this.pipelineContext = pipelineContext;\n            this.model = model;\n            this.instance = instance;\n            this.config = config;\n            this.contentHandler = contentHandler;\n            this.contentHandlerHelper = new ContentHandlerHelper(contentHandler);\n            this.documentWrapper = new DocumentWrapper(instance, null);\n            this.xpathEvaluator = new XPathEvaluator(documentWrapper);\n            this.standaloneContext = (StandaloneContext) xpathEvaluator.getStaticContext();\n        } catch (XPathException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"71eabd4aa72f55472e5cdb7acc0422245903ad4f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private String getRefValue(String refXPath) {\n        List list = getRefNodeList(refXPath);\n        if (list.size() != 1)\n            throw new OXFException(\"Expression '\" + refXPath\n                    + \"' must return exactly element or an attribute\");\n        Node node = (Node) list.get(0);\n        return node instanceof Element ? ((Element) node).getStringValue() : ((Attribute) node).getValue();\n    }","id":78860,"modified_method":"private String getRefValue(String refXPath) {\n        List list = getRefNodeList(refXPath);\n        if (list.size() != 1)\n            throw new OXFException(\"Expression '\" + refXPath\n                    + \"' must return exactly element or an attribute\");\n        Node node = (Node) list.get(0);\n        return getRefValue(node);\n    }","commit_id":"71eabd4aa72f55472e5cdb7acc0422245903ad4f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void setRepeatIdIndex(String repeatId, int index) {\n        repeatIdToIndex.put(repeatId, new Integer(index));\n    }","id":78861,"modified_method":"public void setRepeatIdIndex(String repeatId, String variableName, int index) {\n        try {\n            // Store index for current repeat id, if one is specified\n            if (repeatId != null)\n                repeatIdToIndex.put(repeatId, new Integer(index));\n\n            // Set value of index for variable\n            Variable variable = (Variable) variables.get(variableName);\n            if (variable == null) {\n                variable = standaloneContext.declareVariable(variableName, new Integer(index));\n                variables.put(variableName, variable);\n            } else {\n                variable.setValue(new Integer(index));\n            }\n        } catch (XPathException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"71eabd4aa72f55472e5cdb7acc0422245903ad4f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static XPathExpression createCacheXPath20\n            (PipelineContext context, DocumentWrapper documentWrapper, NodeInfo nodeInfo,\n             String xpathExpression, Map prefixToURIMap, Map variableToValueMap) {\n        try {\n            // Create Saxon XPath Evaluator\n            final XPathEvaluator xpathEvaluator = new XPathEvaluator(documentWrapper);\n            StandaloneContext standaloneContext = (StandaloneContext) xpathEvaluator.getStaticContext();\n\n            // Declare namespaces\n            if (prefixToURIMap != null) {\n                for (Iterator i = prefixToURIMap.keySet().iterator(); i.hasNext();) {\n                    String prefix = (String) i.next();\n                    standaloneContext.declareNamespace(prefix, (String) prefixToURIMap.get(prefix));\n                }\n            }\n\n            // Declare variables\n            if (variableToValueMap != null) {\n                for (Iterator i = variableToValueMap.keySet().iterator(); i.hasNext();) {\n                    String repeatId = (String) i.next();\n                    Integer index = (Integer) variableToValueMap.get(repeatId);\n                    standaloneContext.declareVariable(repeatId, index);\n                }\n            }\n\n            // Context node\n            if (nodeInfo != null)\n                xpathEvaluator.setContextNode(nodeInfo);\n\n            return xpathEvaluator.createExpression(xpathExpression);\n        } catch (XPathException e) {\n            throw new OXFException(e);\n        }\n    }","id":78862,"modified_method":"public static XPathExpression createCacheXPath20\n            (PipelineContext context, DocumentWrapper documentWrapper, NodeInfo nodeInfo,\n             String xpathExpression, Map prefixToURIMap, Map variableToValueMap) {\n        try {\n            // Create Saxon XPath Evaluator\n            final XPathEvaluator xpathEvaluator = new XPathEvaluator(documentWrapper);\n            StandaloneContext standaloneContext = (StandaloneContext) xpathEvaluator.getStaticContext();\n\n            // Declare namespaces\n            if (prefixToURIMap != null) {\n                for (Iterator i = prefixToURIMap.keySet().iterator(); i.hasNext();) {\n                    String prefix = (String) i.next();\n                    standaloneContext.declareNamespace(prefix, (String) prefixToURIMap.get(prefix));\n                }\n            }\n\n            // Declare variables\n            if (variableToValueMap != null) {\n                for (Iterator i = variableToValueMap.keySet().iterator(); i.hasNext();) {\n                    String repeatId = (String) i.next();\n                    Integer index = (Integer) variableToValueMap.get(repeatId);\n                    standaloneContext.declareVariable(repeatId, index);\n                }\n            }\n\n\n            XPathExpression exp = xpathEvaluator.createExpression(xpathExpression);\n            // Context node\n            if (nodeInfo != null) {\n                //somehow we need to set it both to the evaluator and the expression\n                xpathEvaluator.setContextNode(nodeInfo);\n                exp.setContextNode(nodeInfo);\n            }\n\n            return exp;\n        } catch (XPathException e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"71eabd4aa72f55472e5cdb7acc0422245903ad4f","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void destroy() {\n        Action action = getAction();\n        if (action instanceof Destroyable) {\n            ((Destroyable) action).destroy();\n        }\n        action.removePropertyChangeListener(this);\n    }","id":78863,"modified_method":"public void destroy() {\n        Action action = getAction();\n        if (action instanceof Destroyable) {\n            ((Destroyable) action).destroy();\n        }\n        if (action != null) {\n            action.removePropertyChangeListener(this);\n        }\n    }","commit_id":"101c269132c197ed6f308a4fef869c2d88ff9746","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void applyButtonHiddenPreferences() {\n            String actionName = (String) getAction().getValue(AbstractAction.NAME);\n            boolean hiddenFlag =\n                    Main.pref.getBoolean(actionName + \".itbutton_hidden\", false);\n            setVisible(!hiddenFlag);   \n    }","id":78864,"modified_method":"@Override\n    public void applyButtonHiddenPreferences() {\n        String actionName = (String) getSafeActionValue(AbstractAction.NAME);\n        boolean hiddenFlag = Main.pref.getBoolean(actionName + \".itbutton_hidden\", false);\n        setVisible(!hiddenFlag);   \n    }","commit_id":"101c269132c197ed6f308a4fef869c2d88ff9746","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public Icon getIcon() {\n        return (Icon) getAction().getValue(Action.SMALL_ICON);\n    }","id":78865,"modified_method":"@Override\n    public Icon getIcon() {\n        return (Icon) getSafeActionValue(Action.SMALL_ICON);\n    }","commit_id":"101c269132c197ed6f308a4fef869c2d88ff9746","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public String getActionName() {\n        return (String) getAction().getValue(Action.NAME);\n    }","id":78866,"modified_method":"@Override\n    public String getActionName() {\n        return (String) getSafeActionValue(Action.NAME);\n    }","commit_id":"101c269132c197ed6f308a4fef869c2d88ff9746","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void setButtonHidden(boolean b) {\n            String actionName = (String) getAction().getValue(AbstractAction.NAME);\n            setVisible(!b);\n            if (listener!=null) { // if someone wants to know about changes of visibility\n                if (!b) listener.buttonShown(); else listener.buttonHidden();\n            }\n            Main.pref.put(actionName + \".itbutton_hidden\", b);\n            \n    }","id":78867,"modified_method":"@Override\n    public void setButtonHidden(boolean b) {\n        String actionName = (String) getSafeActionValue(AbstractAction.NAME);\n        setVisible(!b);\n        if (listener!=null) { // if someone wants to know about changes of visibility\n            if (!b) listener.buttonShown(); else listener.buttonHidden();\n        }\n        Main.pref.put(actionName + \".itbutton_hidden\", b);\n    }","commit_id":"101c269132c197ed6f308a4fef869c2d88ff9746","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void uninstall() {\n\t\tdisable();\n\t\tpreferenceStore.removePropertyChangeListener(this);\n\t\tfSourceViewer= null;\n\t\tfConfiguration= null;\n\t\tfPresentationReconciler= null;\n\t}","id":78868,"modified_method":"public void uninstall() {\n\t\tdisable();\n\t\tif (preferenceStore != null) {\n\t\t\tpreferenceStore.removePropertyChangeListener(this);\n\t\t}\n\t\tfSourceViewer= null;\n\t\tfConfiguration= null;\n\t\tfPresentationReconciler= null;\n\t}","commit_id":"166e1964b14414b3ef640c760fd2c854affadd4d","url":"https://github.com/eclipse/xtext"},{"original_method":"public void uninstall() {\n\t\tdisable();\n\t\tpreferenceStore.removePropertyChangeListener(this);\n\t\tfEditor= null;\n\t\tfSourceViewer= null;\n\t\tfConfiguration= null;\n\t\tfPresentationReconciler= null;\n\t}","id":78869,"modified_method":"public void uninstall() {\n\t\tdisable();\n\t\tif (preferenceStore != null) {\n\t\t\tpreferenceStore.removePropertyChangeListener(this);\n\t\t}\n\t\tfEditor= null;\n\t\tfSourceViewer= null;\n\t\tfConfiguration= null;\n\t\tfPresentationReconciler= null;\n\t}","commit_id":"166e1964b14414b3ef640c760fd2c854affadd4d","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void deregister(OutlinePage outlinePage) {\n\t\tsuper.deregister(outlinePage);\n\t\tOutlineWithEditorLinker outlineWithEditorLinker = page2linker.remove(outlinePage);\n\t\toutlineWithEditorLinker.deactivate();\n\t\tgetPreferenceStoreAccess().getPreferenceStore().removePropertyChangeListener(outlineWithEditorLinker);\n\t}","id":78870,"modified_method":"@Override\n\tpublic void deregister(OutlinePage outlinePage) {\n\t\tsuper.deregister(outlinePage);\n\t\tOutlineWithEditorLinker outlineWithEditorLinker = page2linker.remove(outlinePage);\n\t\tif (outlineWithEditorLinker != null) {\n\t\t\toutlineWithEditorLinker.deactivate();\n\t\t\tgetPreferenceStoreAccess().getPreferenceStore().removePropertyChangeListener(outlineWithEditorLinker);\n\t\t}\n\t}","commit_id":"2e1ba684215fc86e800a611d8f5ea03f749b2269","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String getResponseXML(WebDAVRequest webDavReq, Set props)\n\t\tthrows Exception {\n\n\t\tWebDAVStorage storage = webDavReq.getWebDAVStorage();\n\n\t\tlong companyId = webDavReq.getCompanyId();\n\t\tlong groupId = webDavReq.getGroupId();\n\t\tlong depth = WebDAVUtil.getDepth(webDavReq.getHttpServletRequest());\n\n\t\tDocumentFactory docFactory = DocumentFactory.getInstance();\n\n\t\tDocument doc = docFactory.createDocument();\n\n\t\tElement multistatus = docFactory.createElement(\n\t\t\tnew QName(\"multistatus\", WebDAVUtil.DAV_URI));\n\n\t\tdoc.setRootElement(multistatus);\n\n\t\tif (companyId <= 0) {\n\t\t\treturn getResponseXML(doc);\n\t\t}\n\n\t\tif (groupId == 0) {\n\t\t\taddResponse(\n\t\t\t\twebDavReq,\n\t\t\t\tnew BaseResourceImpl(\n\t\t\t\t\tstorage.getRootPath() + StringPool.SLASH + companyId,\n\t\t\t\t\tString.valueOf(companyId)),\n\t\t\t\tprops, multistatus);\n\n\t\t\tif (props.size() > 0) {\n\t\t\t\tIterator itr = storage.getCommunities(webDavReq).iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tResource resource = (Resource)itr.next();\n\n\t\t\t\t\taddResponse(webDavReq, resource, props, multistatus);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn getResponseXML(doc);\n\t\t}\n\n\t\tResource resource = storage.getResource(webDavReq);\n\n\t\tif ((resource == null) && !webDavReq.isGroupPath()) {\n\t\t\tString href = storage.getRootPath() + webDavReq.getPath();\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"No resource found for \" + webDavReq.getPath());\n\t\t\t}\n\n\t\t\taddResponse(href, multistatus);\n\n\t\t\treturn getResponseXML(doc);\n\t\t}\n\n\t\tif (resource != null) {\n\t\t\taddResponse(webDavReq, resource, props, multistatus);\n\n\t\t\tif (resource.isCollection() && (depth != 0)) {\n\t\t\t\tIterator itr = storage.getResources(webDavReq).iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tresource = (Resource)itr.next();\n\n\t\t\t\t\taddResponse(webDavReq, resource, props, multistatus);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (webDavReq.isGroupPath()) {\n\t\t\ttry {\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\t\taddResponse(\n\t\t\t\t\twebDavReq,\n\t\t\t\t\tnew BaseResourceImpl(\n\t\t\t\t\t\tstorage.getRootPath() + StringPool.SLASH + companyId +\n\t\t\t\t\t\t\tStringPool.SLASH + groupId,\n\t\t\t\t\t\tgroup.getName()),\n\t\t\t\t\tprops, multistatus);\n\t\t\t}\n\t\t\tcatch (NoSuchGroupException nsge) {\n\t\t\t\tString href = storage.getRootPath() + webDavReq.getPath();\n\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"No group found for \" + href);\n\t\t\t\t}\n\n\t\t\t\taddResponse(href, multistatus);\n\t\t\t}\n\t\t}\n\n\t\treturn getResponseXML(doc);\n\t}","id":78871,"modified_method":"protected String getResponseXML(WebDAVRequest webDavReq, Set props)\n\t\tthrows Exception {\n\n\t\tWebDAVStorage storage = webDavReq.getWebDAVStorage();\n\n\t\tlong companyId = webDavReq.getCompanyId();\n\t\tlong groupId = webDavReq.getGroupId();\n\t\tlong depth = WebDAVUtil.getDepth(webDavReq.getHttpServletRequest());\n\n\t\tDocumentFactory docFactory = DocumentFactory.getInstance();\n\n\t\tDocument doc = docFactory.createDocument();\n\n\t\tElement multistatus = docFactory.createElement(\n\t\t\tnew QName(\"multistatus\", WebDAVUtil.DAV_URI));\n\n\t\tdoc.setRootElement(multistatus);\n\n\t\tif (companyId <= 0) {\n\t\t\treturn getResponseXML(doc);\n\t\t}\n\n\t\tif (groupId == 0) {\n\t\t\taddResponse(\n\t\t\t\twebDavReq,\n\t\t\t\tnew BaseResourceImpl(\n\t\t\t\t\tstorage.getRootPath() + StringPool.SLASH + companyId,\n\t\t\t\t\tString.valueOf(companyId)),\n\t\t\t\tprops, multistatus);\n\n\t\t\tif (props.size() > 0) {\n\t\t\t\tIterator itr = storage.getCommunities(webDavReq).iterator();\n\n\t\t\t\twhile (itr.hasNext()) {\n\t\t\t\t\tResource resource = (Resource)itr.next();\n\n\t\t\t\t\taddResponse(webDavReq, resource, props, multistatus);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn getResponseXML(doc);\n\t\t}\n\n\t\tResource resource = storage.getResource(webDavReq);\n\n\t\tif ((resource == null) && !webDavReq.isGroupPath()) {\n\t\t\tString href = storage.getRootPath() + webDavReq.getPath();\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"No resource found for \" + webDavReq.getPath());\n\t\t\t}\n\n\t\t\taddResponse(href, multistatus);\n\n\t\t\treturn getResponseXML(doc);\n\t\t}\n\n\t\ttry {\n\t\t\tif (resource != null) {\n\t\t\t\taddResponse(\n\t\t\t\t\tstorage, webDavReq, resource, props, multistatus, depth);\n\t\t\t}\n\t\t\telse if (webDavReq.isGroupPath()) {\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(groupId);\n\n\t\t\t\tresource = new BaseResourceImpl(\n\t\t\t\t\t\tstorage.getRootPath() + StringPool.SLASH + companyId +\n\t\t\t\t\t\tStringPool.SLASH + groupId,\n\t\t\t\t\tgroup.getName());\n\n\t\t\t\taddResponse(\n\t\t\t\t\tstorage, webDavReq, resource, props, multistatus, depth);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchGroupException nsge) {\n\t\t\tString href = storage.getRootPath() + webDavReq.getPath();\n\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"No group found for \" + href);\n\t\t\t}\n\n\t\t\taddResponse(href, multistatus);\n\t\t}\n\n\t\treturn getResponseXML(doc);\n\t}","commit_id":"22e42c7eb60a4508e3108a182c45bd520b0a8689","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addResponse(\n\t\t\tWebDAVRequest webDavReq, Resource resource, Set props,\n\t\t\tElement multistatus)\n\t\tthrows Exception {\n\n\t\t// Start building multistatus response\n\n\t\tElement response = DocUtil.add(\n\t\t\tmultistatus, \"response\", WebDAVUtil.DAV_URI);\n\n\t\tDocUtil.add(response, \"href\", WebDAVUtil.DAV_URI, resource.getHREF());\n\n\t\t// Build success and failure propstat elements\n\n\t\tElement successStat = DocUtil.add(\n\t\t\tresponse, \"propstat\", WebDAVUtil.DAV_URI);\n\t\tElement successProp = DocUtil.add(\n\t\t\tsuccessStat, \"prop\", WebDAVUtil.DAV_URI);\n\t\tElement failureStat = DocUtil.add(\n\t\t\tresponse, \"propstat\", WebDAVUtil.DAV_URI);\n\t\tElement failureProp = DocUtil.add(\n\t\t\tfailureStat, \"prop\", WebDAVUtil.DAV_URI);\n\n\t\tboolean hasSuccess = false;\n\t\tboolean hasFailure = false;\n\n\t\t// Check DAV properties\n\n\t\tif (props.contains(_ALL_PROPS_PAIR)) {\n\t\t\tprops.remove(_ALL_PROPS_PAIR);\n\n\t\t\tif (resource.isCollection()) {\n\t\t\t\tprops.addAll(_ALL_COLLECTION_PROPS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprops.addAll(_ALL_SIMPLE_PROPS);\n\t\t\t}\n\t\t}\n\n\t\tif (props.contains(_CREATIONDATE_PAIR)) {\n\t\t\tprops.remove(_CREATIONDATE_PAIR);\n\n\t\t\tDocUtil.add(\n\t\t\t\tsuccessProp, _CREATIONDATE, WebDAVUtil.DAV_URI,\n\t\t\t\tresource.getCreateDate());\n\n\t\t\thasSuccess = true;\n\t\t}\n\n\t\tif (props.contains(_DISPLAYNAME_PAIR)) {\n\t\t\tprops.remove(_DISPLAYNAME_PAIR);\n\n\t\t\tDocUtil.add(\n\t\t\t\tsuccessProp, _DISPLAYNAME, WebDAVUtil.DAV_URI,\n\t\t\t\tresource.getDisplayName());\n\n\t\t\thasSuccess = true;\n\t\t}\n\n\t\tif (props.contains(_GETLASTMODIFIED_PAIR)) {\n\t\t\tprops.remove(_GETLASTMODIFIED_PAIR);\n\n\t\t\tDocUtil.add(\n\t\t\t\tsuccessProp, _GETLASTMODIFIED, WebDAVUtil.DAV_URI,\n\t\t\t\tresource.getModifiedDate());\n\n\t\t\thasSuccess = true;\n\t\t}\n\n\t\tif (props.contains(_GETCONTENTTYPE_PAIR)) {\n\t\t\tprops.remove(_GETCONTENTTYPE_PAIR);\n\n\t\t\tDocUtil.add(\n\t\t\t\tsuccessProp, _GETCONTENTTYPE, WebDAVUtil.DAV_URI,\n\t\t\t\tresource.getContentType());\n\n\t\t\thasSuccess = true;\n\t\t}\n\n\t\tif (props.contains(_GETCONTENTLENGTH_PAIR)) {\n\t\t\tprops.remove(_GETCONTENTLENGTH_PAIR);\n\n\t\t\tif (!resource.isCollection()) {\n\t\t\t\tDocUtil.add(\n\t\t\t\t\tsuccessProp, _GETCONTENTLENGTH, WebDAVUtil.DAV_URI,\n\t\t\t\t\tresource.getSize());\n\n\t\t\t\thasSuccess = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDocUtil.add(\n\t\t\t\t\tfailureProp, _GETCONTENTLENGTH, WebDAVUtil.DAV_URI);\n\n\t\t\t\thasFailure = true;\n\t\t\t}\n\t\t}\n\n\t\tif (props.contains(_RESOURCETYPE_PAIR)) {\n\t\t\tprops.remove(_RESOURCETYPE_PAIR);\n\n\t\t\tElement resourceType =\n\t\t\t\tDocUtil.add(successProp, _RESOURCETYPE, WebDAVUtil.DAV_URI);\n\n\t\t\tif (resource.isCollection()) {\n\t\t\t\tDocUtil.add(resourceType, \"collection\", WebDAVUtil.DAV_URI);\n\t\t\t}\n\n\t\t\thasSuccess = true;\n\t\t}\n\n\t\t// Check remaining properties against custom properties\n\n\t\tWebDAVProps webDavProps = WebDAVPropsLocalServiceUtil.getWebDAVProps(\n\t\t\twebDavReq.getCompanyId(), resource.getClassName(),\n\t\t\tresource.getPrimaryKey());\n\n\t\tSet customProps = webDavProps.getPropsSet();\n\n\t\tIterator itr = props.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tTuple tuple = (Tuple)itr.next();\n\n\t\t\tString name = (String)tuple.getObject(0);\n\t\t\tNamespace namespace = (Namespace)tuple.getObject(1);\n\n\t\t\tString prefix = namespace.getPrefix();\n\t\t\tString uri = namespace.getURI();\n\n\t\t\tif (customProps.contains(tuple)) {\n\t\t\t\tString text = webDavProps.getText(name, prefix, uri);\n\n\t\t\t\tDocUtil.add(successProp, name, namespace, text);\n\n\t\t\t\thasSuccess = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDocUtil.add(failureProp, name, namespace);\n\n\t\t\t\thasFailure = true;\n\t\t\t}\n\t\t}\n\n\t\t// Clean up propstats\n\n\t\tif (hasSuccess) {\n\t\t\tDocUtil.add(\n\t\t\t\tsuccessStat, \"status\", WebDAVUtil.DAV_URI, \"HTTP/1.1 200 OK\");\n\t\t}\n\t\telse {\n\t\t\tresponse.remove(successStat);\n\t\t}\n\n\t\tif (hasFailure) {\n\t\t\tDocUtil.add(\n\t\t\t\tfailureStat, \"status\", WebDAVUtil.DAV_URI,\n\t\t\t\t\"HTTP/1.1 404 Not Found\");\n\t\t}\n\t\telse {\n\t\t\tresponse.remove(failureStat);\n\t\t}\n\t}","id":78872,"modified_method":"protected void addResponse(\n\t\t\tWebDAVRequest webDavReq, Resource resource, Set props,\n\t\t\tElement multistatus)\n\t\tthrows Exception {\n\n\t\t// Make a deep copy of the props\n\n\t\tprops = new HashSet(props);\n\n\t\t// Start building multistatus response\n\n\t\tElement response = DocUtil.add(\n\t\t\tmultistatus, \"response\", WebDAVUtil.DAV_URI);\n\n\t\tDocUtil.add(response, \"href\", WebDAVUtil.DAV_URI, resource.getHREF());\n\n\t\t// Build success and failure propstat elements\n\n\t\tElement successStat = DocUtil.add(\n\t\t\tresponse, \"propstat\", WebDAVUtil.DAV_URI);\n\t\tElement successProp = DocUtil.add(\n\t\t\tsuccessStat, \"prop\", WebDAVUtil.DAV_URI);\n\t\tElement failureStat = DocUtil.add(\n\t\t\tresponse, \"propstat\", WebDAVUtil.DAV_URI);\n\t\tElement failureProp = DocUtil.add(\n\t\t\tfailureStat, \"prop\", WebDAVUtil.DAV_URI);\n\n\t\tboolean hasSuccess = false;\n\t\tboolean hasFailure = false;\n\n\t\t// Check DAV properties\n\n\t\tif (props.contains(_ALL_PROPS_PAIR)) {\n\t\t\tprops.remove(_ALL_PROPS_PAIR);\n\n\t\t\tif (resource.isCollection()) {\n\t\t\t\tprops.addAll(_ALL_COLLECTION_PROPS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprops.addAll(_ALL_SIMPLE_PROPS);\n\t\t\t}\n\t\t}\n\n\t\tif (props.contains(_CREATIONDATE_PAIR)) {\n\t\t\tprops.remove(_CREATIONDATE_PAIR);\n\n\t\t\tDocUtil.add(\n\t\t\t\tsuccessProp, _CREATIONDATE, WebDAVUtil.DAV_URI,\n\t\t\t\tresource.getCreateDate());\n\n\t\t\thasSuccess = true;\n\t\t}\n\n\t\tif (props.contains(_DISPLAYNAME_PAIR)) {\n\t\t\tprops.remove(_DISPLAYNAME_PAIR);\n\n\t\t\tDocUtil.add(\n\t\t\t\tsuccessProp, _DISPLAYNAME, WebDAVUtil.DAV_URI,\n\t\t\t\tresource.getDisplayName());\n\n\t\t\thasSuccess = true;\n\t\t}\n\n\t\tif (props.contains(_GETLASTMODIFIED_PAIR)) {\n\t\t\tprops.remove(_GETLASTMODIFIED_PAIR);\n\n\t\t\tDocUtil.add(\n\t\t\t\tsuccessProp, _GETLASTMODIFIED, WebDAVUtil.DAV_URI,\n\t\t\t\tresource.getModifiedDate());\n\n\t\t\thasSuccess = true;\n\t\t}\n\n\t\tif (props.contains(_GETCONTENTTYPE_PAIR)) {\n\t\t\tprops.remove(_GETCONTENTTYPE_PAIR);\n\n\t\t\tDocUtil.add(\n\t\t\t\tsuccessProp, _GETCONTENTTYPE, WebDAVUtil.DAV_URI,\n\t\t\t\tresource.getContentType());\n\n\t\t\thasSuccess = true;\n\t\t}\n\n\t\tif (props.contains(_GETCONTENTLENGTH_PAIR)) {\n\t\t\tprops.remove(_GETCONTENTLENGTH_PAIR);\n\n\t\t\tif (!resource.isCollection()) {\n\t\t\t\tDocUtil.add(\n\t\t\t\t\tsuccessProp, _GETCONTENTLENGTH, WebDAVUtil.DAV_URI,\n\t\t\t\t\tresource.getSize());\n\n\t\t\t\thasSuccess = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDocUtil.add(\n\t\t\t\t\tfailureProp, _GETCONTENTLENGTH, WebDAVUtil.DAV_URI);\n\n\t\t\t\thasFailure = true;\n\t\t\t}\n\t\t}\n\n\t\tif (props.contains(_RESOURCETYPE_PAIR)) {\n\t\t\tprops.remove(_RESOURCETYPE_PAIR);\n\n\t\t\tElement resourceType =\n\t\t\t\tDocUtil.add(successProp, _RESOURCETYPE, WebDAVUtil.DAV_URI);\n\n\t\t\tif (resource.isCollection()) {\n\t\t\t\tDocUtil.add(resourceType, \"collection\", WebDAVUtil.DAV_URI);\n\t\t\t}\n\n\t\t\thasSuccess = true;\n\t\t}\n\n\t\t// Check remaining properties against custom properties\n\n\t\tWebDAVProps webDavProps = WebDAVPropsLocalServiceUtil.getWebDAVProps(\n\t\t\twebDavReq.getCompanyId(), resource.getClassName(),\n\t\t\tresource.getPrimaryKey());\n\n\t\tSet customProps = webDavProps.getPropsSet();\n\n\t\tIterator itr = props.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tTuple tuple = (Tuple)itr.next();\n\n\t\t\tString name = (String)tuple.getObject(0);\n\t\t\tNamespace namespace = (Namespace)tuple.getObject(1);\n\n\t\t\tString prefix = namespace.getPrefix();\n\t\t\tString uri = namespace.getURI();\n\n\t\t\tif (customProps.contains(tuple)) {\n\t\t\t\tString text = webDavProps.getText(name, prefix, uri);\n\n\t\t\t\tDocUtil.add(successProp, name, namespace, text);\n\n\t\t\t\thasSuccess = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDocUtil.add(failureProp, name, namespace);\n\n\t\t\t\thasFailure = true;\n\t\t\t}\n\t\t}\n\n\t\t// Clean up propstats\n\n\t\tif (hasSuccess) {\n\t\t\tDocUtil.add(\n\t\t\t\tsuccessStat, \"status\", WebDAVUtil.DAV_URI, \"HTTP/1.1 200 OK\");\n\t\t}\n\t\telse {\n\t\t\tresponse.remove(successStat);\n\t\t}\n\n\t\tif (hasFailure) {\n\t\t\tDocUtil.add(\n\t\t\t\tfailureStat, \"status\", WebDAVUtil.DAV_URI,\n\t\t\t\t\"HTTP/1.1 404 Not Found\");\n\t\t}\n\t\telse {\n\t\t\tresponse.remove(failureStat);\n\t\t}\n\t}","commit_id":"22e42c7eb60a4508e3108a182c45bd520b0a8689","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int process(WebDAVRequest webDavReq) throws WebDAVException {\n\t\tWebDAVStorage storage = webDavReq.getWebDAVStorage();\n\t\tHttpServletRequest req = webDavReq.getHttpServletRequest();\n\n\t\tString destination = WebDAVUtil.getDestination(\n\t\t\treq, storage.getRootPath());\n\n\t\tStringMaker sm = new StringMaker();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tsm.append(\"Destination is \" + destination);\n\t\t}\n\n\t\tint status = HttpServletResponse.SC_FORBIDDEN;\n\n\t\tif ((!destination.equals(webDavReq.getPath())) &&\n\t\t\t(WebDAVUtil.getGroupId(destination) == webDavReq.getGroupId())) {\n\n\t\t\tResource resource = storage.getResource(webDavReq);\n\n\t\t\tif (resource == null) {\n\t\t\t\tstatus = HttpServletResponse.SC_NOT_FOUND;\n\t\t\t}\n\t\t\telse if (resource.isCollection()) {\n\t\t\t\ttry {\n\t\t\t\t\tboolean overwrite = WebDAVUtil.isOverwrite(req);\n\t\t\t\t\tlong depth = WebDAVUtil.getDepth(req);\n\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\tsm.append(\", overwrite is \" + overwrite);\n\t\t\t\t\t\tsm.append(\", depth is \" + depth);\n\n\t\t\t\t\t\t_log.info(sm.toString());\n\t\t\t\t\t}\n\n\t\t\t\t\tstatus = storage.copyCollectionResource(\n\t\t\t\t\t\twebDavReq, resource, destination, overwrite, depth);\n\t\t\t\t}\n\t\t\t\tcatch (InvalidRequestException ire) {\n\t\t\t\t\tstatus = HttpServletResponse.SC_BAD_REQUEST;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean overwrite = WebDAVUtil.isOverwrite(req);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tsm.append(\", overwrite is \" + overwrite);\n\n\t\t\t\t\t_log.info(sm.toString());\n\t\t\t\t}\n\n\t\t\t\tstatus = storage.copySimpleResource(\n\t\t\t\t\twebDavReq, resource, destination, overwrite);\n\t\t\t}\n\t\t}\n\n\t\treturn status;\n\t}","id":78873,"modified_method":"public int process(WebDAVRequest webDavReq) throws WebDAVException {\n\t\tWebDAVStorage storage = webDavReq.getWebDAVStorage();\n\t\tHttpServletRequest req = webDavReq.getHttpServletRequest();\n\n\t\tString destination = WebDAVUtil.getDestination(\n\t\t\treq, storage.getRootPath());\n\n\t\tStringMaker sm = new StringMaker();\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tsm.append(\"Destination is \" + destination);\n\t\t}\n\n\t\tint status = HttpServletResponse.SC_FORBIDDEN;\n\n\t\tif ((!destination.equals(webDavReq.getPath())) &&\n\t\t\t(WebDAVUtil.getGroupId(destination) == webDavReq.getGroupId())) {\n\n\t\t\tResource resource = storage.getResource(webDavReq);\n\n\t\t\tif (resource == null) {\n\t\t\t\tstatus = HttpServletResponse.SC_NOT_FOUND;\n\t\t\t}\n\t\t\telse if (resource.isCollection()) {\n\t\t\t\tboolean overwrite = WebDAVUtil.isOverwrite(req);\n\t\t\t\tlong depth = WebDAVUtil.getDepth(req);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tsm.append(\", overwrite is \" + overwrite);\n\t\t\t\t\tsm.append(\", depth is \" + depth);\n\n\t\t\t\t\t_log.info(sm.toString());\n\t\t\t\t}\n\n\t\t\t\tstatus = storage.copyCollectionResource(\n\t\t\t\t\twebDavReq, resource, destination, overwrite, depth);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tboolean overwrite = WebDAVUtil.isOverwrite(req);\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\tsm.append(\", overwrite is \" + overwrite);\n\n\t\t\t\t\t_log.info(sm.toString());\n\t\t\t\t}\n\n\t\t\t\tstatus = storage.copySimpleResource(\n\t\t\t\t\twebDavReq, resource, destination, overwrite);\n\t\t\t}\n\t\t}\n\n\t\treturn status;\n\t}","commit_id":"22e42c7eb60a4508e3108a182c45bd520b0a8689","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static long getDepth(HttpServletRequest req)\n\t\tthrows InvalidRequestException {\n\n\t\tString value = GetterUtil.getString(req.getHeader(\"Depth\"));\n\n\t\tif (value.equals(\"0\")) {\n\t\t\treturn 0;\n\t\t}\n\t\telse if (value.equalsIgnoreCase(\"infinity\") ||\n\t\t\t\t Validator.isNull(value)) {\n\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\tthrow new InvalidRequestException(value);\n\t\t}\n\t}","id":78874,"modified_method":"public static long getDepth(HttpServletRequest req) {\n\n\t\tString value = GetterUtil.getString(req.getHeader(\"Depth\"));\n\n\t\tif (value.equals(\"0\")) {\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\treturn -1;\n\t\t}\n\t}","commit_id":"22e42c7eb60a4508e3108a182c45bd520b0a8689","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addAuResponse(String key, AuResponse response) {\n\t\tif (_desktop != null && _desktop.isAlive())\n\t\t\tgetUiEngine().addResponse(key, response);\n\t}","id":78875,"modified_method":"public void addAuResponse(String key, AuResponse response) {\n\t\tgetUiEngine().addResponse(key, response);\n\t}","commit_id":"cdf8732dad4e32f71271f739709e4bb723c0b587","url":"https://github.com/zkoss/zk"},{"original_method":"public void addAuResponse(AuResponse response) {\n\t\tif (_desktop != null && _desktop.isAlive())\n\t\t\tgetUiEngine().addResponse(response);\n\t}","id":78876,"modified_method":"public void addAuResponse(AuResponse response) {\n\t\tgetUiEngine().addResponse(response);\n\t}","commit_id":"cdf8732dad4e32f71271f739709e4bb723c0b587","url":"https://github.com/zkoss/zk"},{"original_method":"public void stop() {\n\t\tif (_desktop == null) {\n\t\t\tlog.warning(\"Ignored: Sever-push not started\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal boolean inexec = Executions.getCurrent() != null;\n\t\tif (inexec) //Bug 1815480: don't send if timeout\n\t\t\tstopClientPush();\n\n\t\t_desktop = null; //to cause DesktopUnavailableException being thrown\n\t\twakePending();\n\n\t\t//if inexec, either in working thread, or other event listener\n\t\t//if in working thread, we cannot notify here (too early to wake).\n\t\t//if other listener, no need notify (since onPiggyback not running)\n\t\tif (!inexec) {\n\t\t\tsynchronized (_mutex) {\n\t\t\t\t_mutex.notify(); //wake up onPiggyback\n\t\t\t}\n\t\t}\n\t}","id":78877,"modified_method":"public void stop() {\n\t\tif (_desktop == null) {\n\t\t\tlog.warning(\"Ignored: Sever-push not started\");\n\t\t\treturn;\n\t\t}\n\n\t\tfinal boolean inexec = Executions.getCurrent() != null;\n\t\tif (inexec && _desktop.isAlive()) //Bug 1815480: don't send if timeout\n\t\t\tstopClientPush();\n\n\t\t_desktop = null; //to cause DesktopUnavailableException being thrown\n\t\twakePending();\n\n\t\t//if inexec, either in working thread, or other event listener\n\t\t//if in working thread, we cannot notify here (too early to wake).\n\t\t//if other listener, no need notify (since onPiggyback not running)\n\t\tif (!inexec) {\n\t\t\tsynchronized (_mutex) {\n\t\t\t\t_mutex.notify(); //wake up onPiggyback\n\t\t\t}\n\t\t}\n\t}","commit_id":"cdf8732dad4e32f71271f739709e4bb723c0b587","url":"https://github.com/zkoss/zk"},{"original_method":"public boolean getSawAppend() { return sawAppend; }","id":78878,"modified_method":"public boolean getSawOpenQuote(InstructionHandle handle) {\n            return sawOpenQuote <= handle.getPosition();\n        }","commit_id":"730cdda88baa6f33d84fee58b2d39a8c3dd98e0c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void setSawOpenQuote (boolean saw) { \n\t\t\tsawOpenQuote = saw; \n\t\t}","id":78879,"modified_method":"public boolean getSawCloseQuote(InstructionHandle handle) {\n            return sawCloseQuote <= handle.getPosition();\n        }","commit_id":"730cdda88baa6f33d84fee58b2d39a8c3dd98e0c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tif (methodGen == null) \n\t\t\treturn;\n\n\t\tConstantPoolGen cpg = methodGen.getConstantPool();\n\t\tCFG cfg = classContext.getCFG(method);\n\n\t\tStringAppendState stringAppendState = getStringAppendState(cfg, cpg);\n\t\t\t\t\n\t        ConstantDataflow dataflow = classContext.getConstantDataflow(method);\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\tif (isDatabaseSink(ins, cpg)) {\n\t\t\t\tConstantFrame frame = dataflow.getFactAtLocation(location);\n\t\t\t\tConstant value = frame.getStackValue(0);\n\t\t\t    \n\t\t\t\tif (!value.isConstantString()) {\n\t\t\t\t\t// TODO: verify it's the same string represented by stringAppendState\n\t\t\t\t\t// FIXME: will false positive on const/static strings returns by methods \n\t\t\t\t\tBugInstance bug = generateBugInstance(javaClass, methodGen, ins, stringAppendState);\n\t\t\t\t\tbug.addSourceLine(classContext, methodGen, javaClass.getSourceFileName(), location.getHandle());\n\t\t\t\t\tbugReporter.reportBug(bug);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":78880,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method) throws DataflowAnalysisException,\n            CFGBuilderException {\n        JavaClass javaClass = classContext.getJavaClass();\n        MethodGen methodGen = classContext.getMethodGen(method);\n        if (methodGen == null)\n            return;\n\n        ConstantPoolGen cpg = methodGen.getConstantPool();\n        CFG cfg = classContext.getCFG(method);\n\n        StringAppendState stringAppendState = getStringAppendState(cfg, cpg);\n\n        ConstantDataflow dataflow = classContext.getConstantDataflow(method);\n        for (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n            Location location = i.next();\n            Instruction ins = location.getHandle().getInstruction();\n            if (isDatabaseSink(ins, cpg)) {\n                ConstantFrame frame = dataflow.getFactAtLocation(location);\n                Constant value = frame.getStackValue(0);\n\n                if (!value.isConstantString()) {\n                    // TODO: verify it's the same string represented by\n                    // stringAppendState\n                    // FIXME: will false positive on const/static strings\n                    // returns by methods\n                    InstructionHandle prev = getPreviousInstruction(cfg, location, true);\n                    if (prev == null || !isSafeValue(prev.getInstruction(), cpg)) {\n                        BugInstance bug = generateBugInstance(javaClass, methodGen, location.getHandle(),\n                                stringAppendState);\n                        bug.addSourceLine(classContext, methodGen, javaClass.getSourceFileName(), location.getHandle());\n                        bugReporter.reportBug(bug);\n                    }\n                }\n            }\n        }\n    }","commit_id":"730cdda88baa6f33d84fee58b2d39a8c3dd98e0c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private StringAppendState getStringAppendState(CFG cfg, ConstantPoolGen cpg) {\n\t\tStringAppendState stringAppendState = new StringAppendState();\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\tif (isConstantStringLoad(ins, cpg)) {\n\t\t\t\tstringAppendState = updateStringAppendState(ins, cpg, stringAppendState);\n\t\t\t} else if (isStringAppend(ins, cpg)) { \n\t\t\t\tstringAppendState.setSawAppend(true);\n\n\t\t\t\tInstructionHandle prev = getPreviousInstruction(cfg, location, true);\n\t\t\t\tif (prev != null) {\n\t\t\t\t\tInstruction prevIns = prev.getInstruction();\n\t\t\t\t\tif (!isSafeValue(prevIns, cpg))\n\t\t\t\t\t\tstringAppendState.setSawUnsafeAppend(true);\n\t\t\t\t} else {\n\t\t\t\t\t// FIXME: when would prev legitimately be null, and why would we report?\n                    AnalysisContext.logError(\"In FindSqlInjection, saw null previous in \" + cfg.getMethodGen().getClassName() +\".\" + cfg.getMethodName());\n\t\t\t\t\tstringAppendState.setSawUnsafeAppend(true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn stringAppendState;\n\t}","id":78881,"modified_method":"private StringAppendState getStringAppendState(CFG cfg, ConstantPoolGen cpg) {\n        StringAppendState stringAppendState = new StringAppendState();\n\n        for (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n            Location location = i.next();\n            InstructionHandle handle = location.getHandle();\n            Instruction ins = handle.getInstruction();\n            if (isConstantStringLoad(ins, cpg)) {\n                stringAppendState = updateStringAppendState(handle, cpg, stringAppendState);\n            } else if (isStringAppend(ins, cpg)) {\n                stringAppendState.setSawAppend(handle);\n\n                InstructionHandle prev = getPreviousInstruction(cfg, location, true);\n                if (prev != null) {\n                    Instruction prevIns = prev.getInstruction();\n                    if (!isSafeValue(prevIns, cpg))\n                        stringAppendState.setSawUnsafeAppend(handle);\n                } else {\n                    // FIXME: when would prev legitimately be null, and why\n                    // would we report?\n                    AnalysisContext.logError(\"In FindSqlInjection, saw null previous in \"\n                            + cfg.getMethodGen().getClassName() + \".\" + cfg.getMethodName());\n                    stringAppendState.setSawUnsafeAppend(handle);\n                }\n            }\n        }\n\n        return stringAppendState;\n    }","commit_id":"730cdda88baa6f33d84fee58b2d39a8c3dd98e0c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitClassContext(ClassContext classContext) {\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tMethod[] methodList = javaClass.getMethods();\n\n\t\tfor (Method method : methodList) {\n\t\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\t\tif (methodGen == null)\n\t\t\t\tcontinue;\n\n\t\t\ttry {\n\t\t\t\tanalyzeMethod(classContext, method);\n\t\t\t} catch (DataflowAnalysisException e) {\n\t\t\t\tbugReporter.logError(\n\t\t\t\t\t\"FindSqlInjection caught exception while analyzing \" + \n\t\t\t\t\tmethodGen, e);\n\t\t\t} catch (CFGBuilderException e) {\n\t\t\t\tbugReporter.logError(\n\t\t\t\t\t\"FindSqlInjection caught exception while analyzing \" + \n\t\t\t\t\tmethodGen, e);\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\tSystem.out.println(\n\t\t\t\t\t\"Exception while checking for SQL injection in \" \n\t\t\t\t\t+ methodGen + \" in \" + javaClass.getSourceFileName());\n\t\t\t\t\te.printStackTrace(System.out);\n\t\t\t}\n\t\t}\n\t}","id":78882,"modified_method":"public void setSawUnsafeAppend(InstructionHandle handle) {\n            sawUnsafeAppend = Math.min(sawUnsafeAppend, handle.getPosition());\n        }","commit_id":"730cdda88baa6f33d84fee58b2d39a8c3dd98e0c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private StringAppendState updateStringAppendState(Instruction ins, ConstantPoolGen cpg, StringAppendState stringAppendState) {\n\t\tif (!isConstantStringLoad(ins, cpg)) {\n\t\t\tthrow new IllegalArgumentException(\"instruction must be LDC\");\n\t\t}\n\n\t\tLDC load = (LDC) ins;\n\t\tObject value = load.getValue(cpg);\n\t\tString stringValue = ((String)value).trim();\n\t\tif (stringValue.startsWith(\",\") || stringValue.endsWith(\",\"))\n\t\t\tstringAppendState.setSawComma(true);\n\t\tif (stringValue.endsWith(\"'\"))\n\t\t\tstringAppendState.setSawOpenQuote(true);\n\t\tif (stringValue.startsWith(\"'\"))\n\t\t\tstringAppendState.setSawCloseQuote(true);\n\n\t\treturn stringAppendState;\n\t}","id":78883,"modified_method":"private StringAppendState updateStringAppendState(InstructionHandle handle, ConstantPoolGen cpg,\n            StringAppendState stringAppendState) {\n        Instruction ins = handle.getInstruction();\n        if (!isConstantStringLoad(ins, cpg)) {\n            throw new IllegalArgumentException(\"instruction must be LDC\");\n        }\n\n        LDC load = (LDC) ins;\n        Object value = load.getValue(cpg);\n        String stringValue = ((String) value).trim();\n        if (stringValue.startsWith(\",\") || stringValue.endsWith(\",\"))\n            stringAppendState.setSawComma(handle);\n        if (stringValue.endsWith(\"'\"))\n            stringAppendState.setSawOpenQuote(handle);\n        if (stringValue.startsWith(\"'\"))\n            stringAppendState.setSawCloseQuote(handle);\n\n        return stringAppendState;\n    }","commit_id":"730cdda88baa6f33d84fee58b2d39a8c3dd98e0c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public FindSqlInjection(BugReporter bugReporter) {\n\t\tthis.bugReporter = bugReporter;\n\t}","id":78884,"modified_method":"public boolean getSawUnsafeAppend(InstructionHandle handle) {\n            return sawUnsafeAppend <= handle.getPosition();\n        }","commit_id":"730cdda88baa6f33d84fee58b2d39a8c3dd98e0c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void setSawCloseQuote (boolean saw) {\n\t\t\tsawCloseQuote = saw; \n\t\t}","id":78885,"modified_method":"public void setSawCloseQuote(InstructionHandle handle) {\n            sawCloseQuote = Math.min(sawCloseQuote, handle.getPosition());\n        }","commit_id":"730cdda88baa6f33d84fee58b2d39a8c3dd98e0c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private BugInstance generateBugInstance(JavaClass javaClass, MethodGen methodGen, Instruction ins, StringAppendState stringAppendState) {\n\t\tConstantPoolGen cpg = methodGen.getConstantPool();\n\t\tint priority = LOW_PRIORITY;\n\t\tif (stringAppendState.getSawAppend()) {  \n\t\t\tif (stringAppendState.getSawOpenQuote() && \n\t\t\t\tstringAppendState.getSawCloseQuote()) {\n\t\t\t\tpriority = HIGH_PRIORITY;\n\t\t\t} else if (stringAppendState.getSawComma()) {\n\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t}\n\n\t\t\tif (!stringAppendState.getSawUnsafeAppend()) {\n\t\t\t\tpriority += 2;\n\t\t\t}\n\t\t}\n\n\t\tString description = \"\";\n\t\tif (isExecuteDatabaseSink(ins, cpg)) {\n\t\t\tdescription = \"SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE\";  \n\t\t} else if (isPreparedStatementDatabaseSink(ins, cpg)) {\n\t\t\tdescription = \"SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING\";\n\t\t}\n\t\t\n\t\tBugInstance bug = new BugInstance(this, description, priority);\n\t\tbug.addClassAndMethod(methodGen, javaClass.getSourceFileName());\n\n\t\treturn bug;\n\t}","id":78886,"modified_method":"private BugInstance generateBugInstance(JavaClass javaClass, MethodGen methodGen, InstructionHandle handle,\n            StringAppendState stringAppendState) {\n        Instruction instruction = handle.getInstruction();\n        ConstantPoolGen cpg = methodGen.getConstantPool();\n        int priority = LOW_PRIORITY;\n        if (stringAppendState.getSawAppend(handle)) {\n            if (stringAppendState.getSawOpenQuote(handle) && stringAppendState.getSawCloseQuote(handle)) {\n                priority = HIGH_PRIORITY;\n            } else if (stringAppendState.getSawComma(handle)) {\n                priority = NORMAL_PRIORITY;\n            }\n\n            if (!stringAppendState.getSawUnsafeAppend(handle)) {\n                priority += 2;\n            }\n        }\n\n        String description = \"\";\n        if (isExecuteDatabaseSink(instruction, cpg)) {\n            description = \"SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE\";\n        } else if (isPreparedStatementDatabaseSink(instruction, cpg)) {\n            description = \"SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING\";\n        }\n\n        BugInstance bug = new BugInstance(this, description, priority);\n        bug.addClassAndMethod(methodGen, javaClass.getSourceFileName());\n\n        return bug;\n    }","commit_id":"730cdda88baa6f33d84fee58b2d39a8c3dd98e0c","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tIsNullValueDataflow nullValueDataflow = classContext\n\t\t\t\t.getIsNullValueDataflow(method);\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\n\t\t\tInstruction ins = location.getHandle().getInstruction();\n\t\t\tif (!(ins instanceof ALOAD))\n\t\t\t\tcontinue;\n\t\t\tALOAD load = (ALOAD) ins;\n\n\t\t\tIsNullValueFrame frame = nullValueDataflow\n\t\t\t\t\t.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint index = load.getIndex();\n\t\t\tIsNullValue v = frame.getValue(index);\n\t\t\tif (v.isDefinitelyNull())\n\n\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\"NP_LOAD_OF_KNOWN_NULL_VALUE\", v.isChecked() ? NORMAL_PRIORITY : LOW_PRIORITY)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addSourceLine(\n\t\t\t\t\t\t\t\tSourceLineAnnotation.fromVisitedInstruction(\n\t\t\t\t\t\t\t\t\t\tmethodGen, sourceFile, location\n\t\t\t\t\t\t\t\t\t\t\t\t.getHandle())));\n\n\t\t}\n\t}","id":78887,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\t\tthrows CFGBuilderException, DataflowAnalysisException {\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tIsNullValueDataflow nullValueDataflow = classContext\n\t\t\t\t.getIsNullValueDataflow(method);\n\t\tConstantPoolGen cpg = classContext.getConstantPoolGen();\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tString sourceFile = classContext.getJavaClass().getSourceFileName();\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\t\t\tif (!(ins instanceof ALOAD))\n\t\t\t\tcontinue;\n\t\t\tALOAD load = (ALOAD) ins;\n\n\t\t\tIsNullValueFrame frame = nullValueDataflow\n\t\t\t\t\t.getFactAtLocation(location);\n\t\t\tif (!frame.isValid()) {\n\t\t\t\t// This basic block is probably dead\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint index = load.getIndex();\n\t\t\tIsNullValue v = frame.getValue(index);\n\t\t\tif (v.isDefinitelyNull()) {\n\t\t\t\tInstruction next = handle.getNext().getInstruction();\n\t\t\t\tInstructionHandle prevHandle = handle.getPrev();\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(methodGen, sourceFile, handle);\n\t\t\t\tSourceLineAnnotation prevSourceLineAnnotation = SourceLineAnnotation\n\t\t\t\t.fromVisitedInstruction(methodGen, sourceFile, prevHandle);\n\t\n\t\t\t\tif (next instanceof ARETURN) {\n\t\t\t\t\t// probably stored for duration of finally block\n\t\t\t\t\t// continue;\n\t\t\t\t}\n\t\t\t\tif (sourceLineAnnotation.getStartLine() > prevSourceLineAnnotation.getEndLine()) {\n\t\t\t\t\t// probably stored for duration of finally block\n\t\t\t\t\t// System.out.println(\"Inverted line\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\n\t\t\t\tif (!v.isChecked()) priority++;\n\t\t\t\t\n\t\t\t\tbugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\"NP_LOAD_OF_KNOWN_NULL_VALUE\",\n\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClassAndMethod(methodGen, sourceFile)\n\t\t\t\t\t\t.addSourceLine(sourceLineAnnotation));\n\t\t\t}\n\n\t\t}\n\t}","commit_id":"1dc760609a8ee7ee5e7c050e931e7280092f1b6b","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\n\t\tDataflow<BitSet, LiveLocalStoreAnalysis> llsaDataflow =\n\t\t\tclassContext.getLiveLocalStoreDataflow(method);\n\n\t\tint numLocals = method.getCode().getMaxLocals();\n\t\tint [] localUpdateCount = new int[numLocals];\n\t\tint [] localLoadCount = new int[numLocals];\n\t\tint [] localIncrementCount = new int[numLocals];\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tBitSet liveStoreSetAtEntry = llsaDataflow.getAnalysis().getResultFact(cfg.getEntry());\n\t\tBitSet complainedAbout = new BitSet();\n\n        // Get the local variable table from the method...\n        LocalVariableTable lvt = method.getLocalVariableTable();\n        \n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\tif (location.getBasicBlock().isExceptionHandler())\n\t\t\t\tcontinue;\n\n\t\t\tboolean isStore = isStore(location);\n\t\t\tboolean isLoad = isLoad(location);\n\t\t\tif (!isStore && !isLoad) continue;\n\t\t\tIndexedInstruction ins = (IndexedInstruction) location.getHandle().getInstruction();\n\t\t\tint local = ins.getIndex();\n\t\t\tif (ins instanceof IINC) {\n\t\t\t\tlocalUpdateCount[local]++;\n\t\t\t\tlocalLoadCount[local]++;\n\t\t\t\tlocalIncrementCount[local]++;\n\t\t\t}\n\t\t\telse if (isStore) \n\t\t\t\tlocalUpdateCount[local]++;\n\t\t\telse \n\t\t\t\tlocalLoadCount[local]++;\n\t\t\t}\n\n\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\tif (!isStore(location))\n\t\t\t\tcontinue;\n\n\t\t\t// Ignore exception handler blocks:\n\t\t\t// javac always stores caught exceptions in\n\t\t\t// a local, even if the value is not used.\n\t\t\tif (location.getBasicBlock().isExceptionHandler())\n\t\t\t\tcontinue;\n\n\t\t\tIndexedInstruction ins = (IndexedInstruction) location.getHandle().getInstruction();\n\t\t\tint local = ins.getIndex();\n     \n            // Determine whether we should ignore this local variable...\n            if (lvt != null) {\n            \tLocalVariable lv = lvt.getLocalVariable(local);\n            \tif (lv != null) {\n            \t\tString localName = lv.getName();\n   \n\t                // Is it in our set of excluded names?\n\t                if (EXCLUDED_LOCALS.contains(localName)) {\n\t                    continue;\n\t                }\n            \t}\n            }\n                \n\t\t\tint localsThatAreParameters = method.getArgumentTypes().length;\n\t\t\tif (!method.isStatic()) localsThatAreParameters++;\n\n\t\t\tboolean parameterThatIsDeadAtEntry = local < localsThatAreParameters\n\t\t\t    && !llsaDataflow.getAnalysis().isStoreAlive(liveStoreSetAtEntry, local);\n\t\t\tif (parameterThatIsDeadAtEntry && !complainedAbout.get(local)) {\n\t\t\tBugInstance bugInstance = new BugInstance(this, \"IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN\", NORMAL_PRIORITY)\n\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t.addSourceLine(methodGen, javaClass.getSourceFileName(), location.getHandle());\n\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\tcomplainedAbout.set(local);\n\t\t\t}\n\n\t\t\t// Get live stores at this instruction.\n\t\t\t// Note that the analysis also computes which stores were\n\t\t\t// killed by a subsequent unconditional store.\n\t\t\tBitSet liveStoreSet = llsaDataflow.getAnalysis().getFactAtLocation(location);\n\n\t\t\t// Is store alive?\n\t\t\tif (llsaDataflow.getAnalysis().isStoreAlive(liveStoreSet, local))\n\t\t\t\tcontinue;\n\n\t\t\t// Store is dead\n\n\t\t\t\n\n\t\t\t// Ignore assignments that were killed by a subsequent assignment.\n\t\t\tif (llsaDataflow.getAnalysis().killedByStore(liveStoreSet, local)) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"Store at \" + location.getHandle() +\n\t\t\t\t\t\t\" killed by subsequent store\");\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Ignore dead assignments of null and 0.\n\t\t\t// These often indicate defensive programming.\n\t\t\tInstructionHandle prev = location.getBasicBlock().getPredecessorOf(location.getHandle());\n\t\t\tif (prev != null && defensiveConstantValueOpcodes.get(prev.getInstruction().getOpcode()))\n\t\t\t\tcontinue;\n\n\t\t\tint priority = LOW_PRIORITY;\n\t\t\t// special handling of IINC\n\t\t\tif (ins instanceof IINC) {\n\t\t\t\t\n\t\t\t\t if (localIncrementCount[local] == 1) \n\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\telse continue;\n\n\t\t\t\t}\n\n\t\t\telse if (ins instanceof ASTORE\n\t\t\t\t&& prev != null) { \n\t\t\t\tInstruction prevIns = prev.getInstruction();\n\t\t\t\tif ((prevIns instanceof INVOKESPECIAL &&\n\t\t\t\t\t((INVOKESPECIAL)prevIns).getMethodName(methodGen.getConstantPool()).equals(\"<init>\"))\n\t\t\t\t    || prevIns instanceof ANEWARRAY\n\t\t\t\t    || prevIns instanceof NEWARRAY\n\t\t\t\t    || prevIns instanceof MULTIANEWARRAY)\n\t\t\t\t\tpriority--;\n\t\t\t}\n\n\n\t\t\telse if (localUpdateCount[local] == 2\n\t\t\t\t&& localLoadCount[local] > 0) priority--; // raise priority\n\t\t\telse if (localUpdateCount[local] == 1)\n\t\t\t\tpriority++;\n\n\t\t\telse if (localLoadCount[local] == 0) priority++; // lower priority\n\t\t\tif (parameterThatIsDeadAtEntry) {\n\t\t\t\tif (DEBUG) System.out.println(\"Raising priority\");\n\t\t\t\tpriority--;\n\t\t\t\t}\n\n\t\t\tif (priority < HIGH_PRIORITY)\n\t\t\t\tpriority =  HIGH_PRIORITY;\n\t\t\tif (DEBUG) System.out.println(\" considering reporting bug:\" + priority);\n\t\t\tif (priority != LOW_PRIORITY \n\t\t\t\t|| classesAlreadyReportedOn.add(javaClass.getClassName())) {\n\n\t\t\t// Report the bug\n\t\t\tBugInstance bugInstance = new BugInstance(this, \"DLS_DEAD_LOCAL_STORE\", priority)\n\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t.addSourceLine(methodGen, javaClass.getSourceFileName(), location.getHandle());\n\t\t\tif (DEBUG) System.out.println(\"Reporting \" + bugInstance);\n\n\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\t}\n\t\t}\n\t}","id":78888,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method)\n\t\tthrows DataflowAnalysisException, CFGBuilderException {\n\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\n\t\tDataflow<BitSet, LiveLocalStoreAnalysis> llsaDataflow =\n\t\t\tclassContext.getLiveLocalStoreDataflow(method);\n\n\t\tint numLocals = method.getCode().getMaxLocals();\n\t\tint [] localUpdateCount = new int[numLocals];\n\t\tint [] localLoadCount = new int[numLocals];\n\t\tint [] localIncrementCount = new int[numLocals];\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tBitSet liveStoreSetAtEntry = llsaDataflow.getAnalysis().getResultFact(cfg.getEntry());\n\t\tBitSet complainedAbout = new BitSet();\n\n        // Get the local variable table from the method...\n        LocalVariableTable lvt = method.getLocalVariableTable();\n        \n\t\t// Get number of locals that are parameters.\n\t\tint localsThatAreParameters = method.getArgumentTypes().length;\n\t\tif (!method.isStatic()) localsThatAreParameters++;\n\t\t\n\t\t// Map to store properties used for false-positive heuristics\n\t\tTreeMap<String, String> propertyMap = new TreeMap<String, String>();\n        \n\t\t// Scan method to determine number of loads, stores, and increments\n\t\t// of local variables.\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\t\n\t\t\t// Skip exception handlers, as the exception value is\n\t\t\t// often a dead store.\n\t\t\tif (location.getBasicBlock().isExceptionHandler())\n\t\t\t\tcontinue;\n\n\t\t\tboolean isStore = isStore(location);\n\t\t\tboolean isLoad = isLoad(location);\n\t\t\tif (!isStore && !isLoad)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tIndexedInstruction ins = (IndexedInstruction) location.getHandle().getInstruction();\n\t\t\tint local = ins.getIndex();\n\t\t\tif (ins instanceof IINC) {\n\t\t\t\tlocalUpdateCount[local]++;\n\t\t\t\tlocalLoadCount[local]++;\n\t\t\t\tlocalIncrementCount[local]++;\n\t\t\t} else if (isStore) \n\t\t\t\tlocalUpdateCount[local]++;\n\t\t\telse \n\t\t\t\tlocalLoadCount[local]++;\n\t\t}\n\n\t\t// Scan method for\n\t\t// - dead stores\n\t\t// - stores to parameters that are dead upon entry to the method\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext(); ) {\n\t\t\tLocation location = i.next();\n\t\t\n\t\t\t// Skip any instruction which is not a store\n\t\t\tif (!isStore(location))\n\t\t\t\tcontinue;\n\n\t\t\t// Ignore exception handler blocks:\n\t\t\t// javac always stores caught exceptions in\n\t\t\t// a local, even if the value is not used.\n\t\t\tif (location.getBasicBlock().isExceptionHandler())\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\t// Clear properties for false-positive heuristics\n\t\t\tpropertyMap.clear();\n\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tIndexedInstruction ins = (IndexedInstruction) handle.getInstruction();\n\t\t\tint pc = handle.getPosition();\n\t\t\tint local = ins.getIndex();\n     \n\t\t\t// Get local variable name.\n\t\t\t// This may serve as a heuristic to avoid false warnings.\n            if (lvt != null) {\n            \tLocalVariable lv = lvt.getLocalVariable(local, pc);\n            \tif (lv != null) {\n\t\t\t\t\tString localName = lv.getName();\n\t\t\t\t\tpropertyMap.put(BugProperty.LOCAL_NAME, localName);\n   \n\t                // Is it in our set of excluded names?\n\t                if (DO_EXCLUDE_LOCALS && EXCLUDED_LOCALS.contains(localName)) {\n\t                    continue;\n\t                }\n            \t}\n            }\n\n\t\t\t// Is this a store to a parameter which was dead on entry to the method?\n\t\t\tboolean parameterThatIsDeadAtEntry = local < localsThatAreParameters\n\t\t\t    && !llsaDataflow.getAnalysis().isStoreAlive(liveStoreSetAtEntry, local);\n\t\t\tif (parameterThatIsDeadAtEntry && !complainedAbout.get(local)) {\n\t\t\t\tBugInstance bugInstance = new BugInstance(this, \"IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN\", NORMAL_PRIORITY)\n\t\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t\t.addSourceLine(methodGen, javaClass.getSourceFileName(), location.getHandle());\n//\t\t\t\tif (localName != null)\n//\t\t\t\t\tbugInstance.setProperty(BugProperty.LOCAL_NAME, localName);\n\t\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\t\tcomplainedAbout.set(local);\n\t\t\t}\n\n\t\t\t// Get live stores at this instruction.\n\t\t\t// Note that the analysis also computes which stores were\n\t\t\t// killed by a subsequent unconditional store.\n\t\t\tBitSet liveStoreSet = llsaDataflow.getAnalysis().getFactAtLocation(location);\n\n\t\t\t// Is store alive?\n\t\t\tif (llsaDataflow.getAnalysis().isStoreAlive(liveStoreSet, local))\n\t\t\t\tcontinue;\n\t\t\t// Store is dead\n\n\t\t\t// Ignore assignments that were killed by a subsequent assignment.\n\t\t\tif (llsaDataflow.getAnalysis().killedByStore(liveStoreSet, local)) {\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"Store at \" + location.getHandle() +\n\t\t\t\t\t\t\" killed by subsequent store\");\n\t\t\t\t}\n\t\t\t\tpropertyMap.put(BugProperty.KILLED_BY_SUBSEQUENT_STORE, \"true\");\n\t\t\t\tcontinue; // FIXME - bail early, or collect all props and report? Need to think about\n\t\t\t} else {\n\t\t\t\tpropertyMap.put(BugProperty.KILLED_BY_SUBSEQUENT_STORE, \"false\");\n\t\t\t}\n\n\t\t\t// Ignore dead assignments of null and 0.\n\t\t\t// These often indicate defensive programming.\n\t\t\tInstructionHandle prev = location.getBasicBlock().getPredecessorOf(location.getHandle());\n\t\t\tif (prev != null && defensiveConstantValueOpcodes.get(prev.getInstruction().getOpcode())) {\n\t\t\t\tpropertyMap.put(BugProperty.DEFENSIVE_CONSTANT_OPCODE, \"true\");\n\t\t\t\tcontinue; // FIXME - bail early, or collect all props and report? Need to think about\n\t\t\t} else {\n\t\t\t\tpropertyMap.put(BugProperty.DEFENSIVE_CONSTANT_OPCODE, \"false\");\n\t\t\t}\n\n\t\t\tint priority = LOW_PRIORITY;\n\t\t\t// special handling of IINC\n\t\t\tif (ins instanceof IINC) {\n\t\t\t\t\n\t\t\t\t if (localIncrementCount[local] == 1) \n\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\t\t\t\telse continue;\n\n\t\t\t\t}\n\n\t\t\telse if (ins instanceof ASTORE\n\t\t\t\t&& prev != null) { \n\t\t\t\tInstruction prevIns = prev.getInstruction();\n\t\t\t\tif ((prevIns instanceof INVOKESPECIAL &&\n\t\t\t\t\t((INVOKESPECIAL)prevIns).getMethodName(methodGen.getConstantPool()).equals(\"<init>\"))\n\t\t\t\t    || prevIns instanceof ANEWARRAY\n\t\t\t\t    || prevIns instanceof NEWARRAY\n\t\t\t\t    || prevIns instanceof MULTIANEWARRAY)\n\t\t\t\t\tpriority--;\n\t\t\t}\n\n\n\t\t\telse if (localUpdateCount[local] == 2\n\t\t\t\t&& localLoadCount[local] > 0) priority--; // raise priority\n\t\t\telse if (localUpdateCount[local] == 1)\n\t\t\t\tpriority++;\n\n\t\t\telse if (localLoadCount[local] == 0) priority++; // lower priority\n\t\t\tif (parameterThatIsDeadAtEntry) {\n\t\t\t\tif (DEBUG) System.out.println(\"Raising priority\");\n\t\t\t\tpriority--;\n\t\t\t\t}\n\n\t\t\tif (priority < HIGH_PRIORITY)\n\t\t\t\tpriority =  HIGH_PRIORITY;\n\t\t\tif (DEBUG) System.out.println(\" considering reporting bug:\" + priority);\n\t\t\tif (priority != LOW_PRIORITY \n\t\t\t\t|| classesAlreadyReportedOn.add(javaClass.getClassName())) {\n\n\t\t\t// Report the bug\n\t\t\tBugInstance bugInstance = new BugInstance(this, \"DLS_DEAD_LOCAL_STORE\", priority)\n\t\t\t\t.addClassAndMethod(methodGen, javaClass.getSourceFileName())\n\t\t\t\t.addSourceLine(methodGen, javaClass.getSourceFileName(), location.getHandle());\n\t\t\tif (DEBUG) System.out.println(\"Reporting \" + bugInstance);\n\n\t\t\tbugReporter.reportBug(bugInstance);\n\t\t\t}\n\t\t}\n\t}","commit_id":"60277c113c12b3368141675b22a8e9497333b30f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Converter\n    public XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {\n        XMLInputFactory factory = getInputFactory();\n        try {\n            return factory.createXMLStreamReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange, false));\n        } finally {\n            returnXMLInputFactory(factory);\n        }\n    }","id":78889,"modified_method":"@Converter\n    public XMLStreamReader createXMLStreamReader(InputStream in, Exchange exchange) throws XMLStreamException {\n        XMLInputFactory factory = getInputFactory();\n        try {\n            String charsetName = IOHelper.getCharsetName(exchange, false);\n            if (charsetName == null) {\n                return factory.createXMLStreamReader(IOHelper.buffered(in));\n            } else {\n                return factory.createXMLStreamReader(IOHelper.buffered(in), charsetName);\n            }\n        } finally {\n            returnXMLInputFactory(factory);\n        }\n    }","commit_id":"644c1f0ab894fbd8c33050cd354a38bbb7acac2a","url":"https://github.com/apache/camel"},{"original_method":"@Converter\n    public XMLEventReader createXMLEventReader(InputStream in, Exchange exchange) throws XMLStreamException {\n        XMLInputFactory factory = getInputFactory();\n        try {\n            return factory.createXMLEventReader(IOHelper.buffered(in), IOHelper.getCharsetName(exchange, false));\n        } finally {\n            returnXMLInputFactory(factory);\n        }\n    }","id":78890,"modified_method":"@Converter\n    public XMLEventReader createXMLEventReader(InputStream in, Exchange exchange) throws XMLStreamException {\n        XMLInputFactory factory = getInputFactory();\n        try {\n            String charsetName = IOHelper.getCharsetName(exchange, false);\n            if (charsetName == null) {\n                return factory.createXMLEventReader(IOHelper.buffered(in));\n            } else {\n                return factory.createXMLEventReader(IOHelper.buffered(in), charsetName);\n            }\n        } finally {\n            returnXMLInputFactory(factory);\n        }\n    }","commit_id":"644c1f0ab894fbd8c33050cd354a38bbb7acac2a","url":"https://github.com/apache/camel"},{"original_method":"public void testEncodingXmlStreamReader() throws Exception {\n        TEST_XML_WITH_XML_HEADER_ISO_8859_1_AS_BYTE_ARRAY_STREAM.reset();\n\n        XMLStreamReader reader = null;\n        XMLStreamWriter writer = null;\n        ByteArrayOutputStream output = null;\n        try {\n            // enter text encoded with Latin1\n            reader = context.getTypeConverter().mandatoryConvertTo(XMLStreamReader.class,\n                    TEST_XML_WITH_XML_HEADER_ISO_8859_1_AS_BYTE_ARRAY_STREAM);\n\n            output = new ByteArrayOutputStream();\n            // ensure UTF-8 encoding\n            Exchange exchange = new DefaultExchange(context);\n            exchange.setProperty(Exchange.CHARSET_NAME, UTF_8.name());\n            writer = context.getTypeConverter().mandatoryConvertTo(XMLStreamWriter.class, exchange, output);\n            // copy to writer\n            while (reader.hasNext()) {\n                reader.next();\n                switch (reader.getEventType()) {\n                case XMLEvent.START_DOCUMENT:\n                    writer.writeStartDocument();\n                    break;\n                case XMLEvent.END_DOCUMENT:\n                    writer.writeEndDocument();\n                    break;\n                case XMLEvent.START_ELEMENT:\n                    writer.writeStartElement(reader.getName().getLocalPart());\n                    break;\n                case XMLEvent.CHARACTERS:\n                    writer.writeCharacters(reader.getText());\n                    break;\n                case XMLEvent.END_ELEMENT:\n                    writer.writeEndElement();\n                    break;\n                default:\n                    break;\n                }\n            }\n        } finally {\n            if (reader != null) {\n                reader.close();\n            }\n            if (writer != null) {\n                writer.close();\n            }\n        }\n        assertNotNull(output);\n\n        String result = new String(output.toByteArray(), UTF_8.name());\n\n        assertEquals(TEST_XML, result);\n    }","id":78891,"modified_method":"public void testEncodingXmlStreamReader() throws Exception {\n        TEST_XML_WITH_XML_HEADER_ISO_8859_1_AS_BYTE_ARRAY_STREAM.reset();\n\n        XMLStreamReader reader = null;\n        XMLStreamWriter writer = null;\n        ByteArrayOutputStream output = null;\n        try {\n            // enter text encoded with Latin1\n            reader = context.getTypeConverter().mandatoryConvertTo(XMLStreamReader.class,\n                    TEST_XML_WITH_XML_HEADER_ISO_8859_1_AS_BYTE_ARRAY_STREAM);\n\n            output = new ByteArrayOutputStream();\n            // ensure UTF-8 encoding\n            Exchange exchange = new DefaultExchange(context);\n            //exchange.setProperty(Exchange.CHARSET_NAME, UTF_8.name());\n            writer = context.getTypeConverter().mandatoryConvertTo(XMLStreamWriter.class, exchange, output);\n            // copy to writer\n            while (reader.hasNext()) {\n                reader.next();\n                switch (reader.getEventType()) {\n                case XMLEvent.START_DOCUMENT:\n                    writer.writeStartDocument();\n                    break;\n                case XMLEvent.END_DOCUMENT:\n                    writer.writeEndDocument();\n                    break;\n                case XMLEvent.START_ELEMENT:\n                    writer.writeStartElement(reader.getName().getLocalPart());\n                    break;\n                case XMLEvent.CHARACTERS:\n                    writer.writeCharacters(reader.getText());\n                    break;\n                case XMLEvent.END_ELEMENT:\n                    writer.writeEndElement();\n                    break;\n                default:\n                    break;\n                }\n            }\n        } finally {\n            if (reader != null) {\n                reader.close();\n            }\n            if (writer != null) {\n                writer.close();\n            }\n        }\n        assertNotNull(output);\n\n        String result = new String(output.toByteArray(), UTF_8.name());\n\n        assertEquals(TEST_XML, result);\n    }","commit_id":"644c1f0ab894fbd8c33050cd354a38bbb7acac2a","url":"https://github.com/apache/camel"},{"original_method":"public void testEncodingXmlEventReader() throws Exception {\n        TEST_XML_WITH_XML_HEADER_ISO_8859_1_AS_BYTE_ARRAY_STREAM.reset();\n        XMLEventReader reader = null;\n        XMLEventWriter writer = null;\n        ByteArrayOutputStream output = null;\n        try {\n            // enter text encoded with Latin1\n            reader = context.getTypeConverter().mandatoryConvertTo(XMLEventReader.class,\n                    TEST_XML_WITH_XML_HEADER_ISO_8859_1_AS_BYTE_ARRAY_STREAM);\n\n            output = new ByteArrayOutputStream();\n            // ensure UTF-8 encoding\n            Exchange exchange = new DefaultExchange(context);\n            exchange.setProperty(Exchange.CHARSET_NAME, UTF_8.name());\n            writer = context.getTypeConverter().mandatoryConvertTo(XMLEventWriter.class, exchange, output);\n            while (reader.hasNext()) {\n                writer.add(reader.nextEvent());\n            }\n        } finally {\n            if (reader != null) {\n                reader.close();\n            }\n            if (writer != null) {\n                writer.close();\n            }\n        }\n        assertNotNull(output);\n\n        String result = new String(output.toByteArray(), UTF_8.name());\n\n        boolean equals = TEST_XML_WITH_XML_HEADER.equals(result) || TEST_XML_WITH_XML_HEADER_ISO_8859_1.equals(result);\n        assertTrue(\"Should match header\", equals);\n    }","id":78892,"modified_method":"public void testEncodingXmlEventReader() throws Exception {\n        TEST_XML_WITH_XML_HEADER_ISO_8859_1_AS_BYTE_ARRAY_STREAM.reset();\n        XMLEventReader reader = null;\n        XMLEventWriter writer = null;\n        ByteArrayOutputStream output = null;\n        try {\n            // enter text encoded with Latin1\n            reader = context.getTypeConverter().mandatoryConvertTo(XMLEventReader.class,\n                    TEST_XML_WITH_XML_HEADER_ISO_8859_1_AS_BYTE_ARRAY_STREAM);\n\n            output = new ByteArrayOutputStream();\n            // ensure UTF-8 encoding\n            Exchange exchange = new DefaultExchange(context);\n            //exchange.setProperty(Exchange.CHARSET_NAME, ISO_8859_1.toString());\n            writer = context.getTypeConverter().mandatoryConvertTo(XMLEventWriter.class, exchange, output);\n            while (reader.hasNext()) {\n                writer.add(reader.nextEvent());\n            }\n        } finally {\n            if (reader != null) {\n                reader.close();\n            }\n            if (writer != null) {\n                writer.close();\n            }\n        }\n        assertNotNull(output);\n\n        String result = new String(output.toByteArray(), UTF_8.name());\n        System.out.println(result);\n        boolean equals = TEST_XML_WITH_XML_HEADER.equals(result) || TEST_XML_WITH_XML_HEADER_ISO_8859_1.equals(result);\n        assertTrue(\"Should match header\", equals);\n    }","commit_id":"644c1f0ab894fbd8c33050cd354a38bbb7acac2a","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Marshal from XML to JSON\n     */\n    @Override\n    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {\n        boolean streamTreatment = true;\n        // try to process as an InputStream if it's not a String\n        Object xml = graph instanceof String ? null : exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, graph);\n        // if conversion to InputStream was unfeasible, fall back to String\n        if (xml == null) {\n            xml = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, graph);\n            streamTreatment = false;\n        }\n\n        JSON json;\n        // perform the marshaling to JSON\n        if (streamTreatment) {\n            json = serializer.readFromStream((InputStream) xml);\n        } else {\n            json = serializer.read((String) xml);\n        }\n\n        OutputStreamWriter osw = new OutputStreamWriter(stream, IOHelper.getCharsetName(exchange));\n        json.write(osw);\n        osw.flush();\n\n    }","id":78893,"modified_method":"/**\n     * Marshal from XML to JSON\n     */\n    @Override\n    public void marshal(Exchange exchange, Object graph, OutputStream stream) throws Exception {\n        boolean streamTreatment = true;\n        // try to process as an InputStream if it's not a String\n        Object xml = graph instanceof String ? null : exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, graph);\n        // if conversion to InputStream was unfeasible, fall back to String\n        if (xml == null) {\n            xml = exchange.getContext().getTypeConverter().mandatoryConvertTo(String.class, exchange, graph);\n            streamTreatment = false;\n        }\n\n        JSON json;\n        // perform the marshaling to JSON\n        if (streamTreatment) {\n            json = serializer.readFromStream((InputStream) xml);\n        } else {\n            json = serializer.read((String) xml);\n        }\n        // don't return the default setting here\n        String encoding = IOHelper.getCharsetName(exchange, false);\n        if (encoding == null) {\n            encoding = getEncoding();\n        }\n        OutputStreamWriter osw = null;\n        if (encoding != null) {\n            osw = new OutputStreamWriter(stream, encoding);\n        } else {\n            osw = new OutputStreamWriter(stream);\n        }\n        json.write(osw);\n        osw.flush();\n\n    }","commit_id":"3e49c69790a05e0a3cf8785386bddddbeb0c962a","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Returns the span of the genomeLocs comprising this shard\n     * @param\n     * @return\n     */\n    public GenomeLoc getLocation() {\n        if ( getGenomeLocs() == null )\n            return GenomeLoc.WHOLE_GENOME;\n\n        int start = Integer.MAX_VALUE;\n        int stop = Integer.MIN_VALUE;\n        String contig = null;\n\n        for ( GenomeLoc loc : getGenomeLocs() ) {\n            if ( GenomeLoc.isUnmapped(loc) )\n                // special case the unmapped region marker, just abort out\n                return loc;\n            contig = loc.getContig();\n            if ( loc.getStart() < start ) start = loc.getStart();\n            if ( loc.getStop() > stop ) stop = loc.getStop();\n        }\n\n        return parser.createGenomeLoc(contig, start, stop);\n    }","id":78894,"modified_method":"/**\n     * Returns the span of the genomeLocs comprising this shard\n     * @return a GenomeLoc that starts as the first position in getGenomeLocs() and stops at the stop of the last\n     *    position in getGenomeLocs()\n     */\n    public GenomeLoc getLocation() {\n        if ( spanningLocation == null ) {\n            if ( getGenomeLocs() == null )\n                spanningLocation = GenomeLoc.WHOLE_GENOME;\n            else if ( getGenomeLocs().size() == 0 ) {\n                spanningLocation = getGenomeLocs().get(0);\n            } else {\n                int start = Integer.MAX_VALUE;\n                int stop = Integer.MIN_VALUE;\n                String contig = null;\n\n                for ( GenomeLoc loc : getGenomeLocs() ) {\n                    if ( GenomeLoc.isUnmapped(loc) )\n                        // special case the unmapped region marker, just abort out\n                        return loc;\n                    contig = loc.getContig();\n                    if ( loc.getStart() < start ) start = loc.getStart();\n                    if ( loc.getStop() > stop ) stop = loc.getStop();\n                }\n\n                spanningLocation = parser.createGenomeLoc(contig, start, stop);\n            }\n        }\n\n        return spanningLocation;\n    }","commit_id":"9e17e6be6dc767852072e0d9913bbedad2446f39","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void clearReads() { reads.clear(); }","id":78895,"modified_method":"/**\n     * Clear all of the reads currently in this active region\n     */\n    @Ensures(\"size() == 0\")\n    public void clearReads() {\n        spanIncludingReads = extendedLoc;\n        reads.clear();\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Requires(\"referenceReader.isUppercasingBases()\")\n    public byte[] getFullReference( final CachingIndexedFastaSequenceFile referenceReader ) {\n        return getFullReference(referenceReader, 0);\n    }","id":78896,"modified_method":"/**\n     * See #getActiveRegionReference but using the span including regions not the extended span\n     */\n    public byte[] getFullReference( final IndexedFastaSequenceFile referenceReader ) {\n        return getFullReference(referenceReader, 0);\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Requires(\"referenceReader.isUppercasingBases()\")\n    public byte[] getFullReference( final CachingIndexedFastaSequenceFile referenceReader, final int padding ) {\n        return getReference( referenceReader, padding, fullExtentReferenceLoc );\n    }","id":78897,"modified_method":"/**\n     * See #getActiveRegionReference but using the span including regions not the extended span\n     */\n    public byte[] getFullReference( final IndexedFastaSequenceFile referenceReader, final int padding ) {\n        return getReference(referenceReader, padding, spanIncludingReads);\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ArrayList<GATKSAMRecord> getReads() { return reads; }","id":78898,"modified_method":"/**\n     * Get an unmodifiable list of reads currently in this active region.\n     *\n     * The reads are sorted by their coordinate position\n     *\n     * @return an unmodifiable list of reads in this active region\n     */\n    @Ensures(\"result != null\")\n    public List<GATKSAMRecord> getReads() {\n        return Collections.unmodifiableList(reads);\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public String toString() {\n        return \"ActiveRegion \"  + activeRegionLoc.toString() + \" active?=\" + isActive + \" nReads=\" + reads.size() + \" \";\n    }","id":78899,"modified_method":"@Override\n    public String toString() {\n        return \"ActiveRegion \"  + activeRegionLoc.toString() + \" active?=\" + isActive() + \" nReads=\" + reads.size() + \" \";\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void removeAll( final ArrayList<GATKSAMRecord> readsToRemove ) { reads.removeAll( readsToRemove ); }","id":78900,"modified_method":"/**\n     * Remove all of the reads in readsToRemove from this active region\n     * @param readsToRemove the collection of reads we want to remove\n     */\n    public void removeAll( final Collection<GATKSAMRecord> readsToRemove ) {\n        reads.removeAll(readsToRemove);\n        spanIncludingReads = extendedLoc;\n        for ( final GATKSAMRecord read : reads ) {\n            spanIncludingReads = spanIncludingReads.union( genomeLocParser.createGenomeLoc(read) );\n        }\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void hardClipToActiveRegion() {\n        final ArrayList<GATKSAMRecord> clippedReads = ReadClipper.hardClipToRegion( reads, extendedLoc.getStart(), extendedLoc.getStop() );\n        reads.clear();\n        reads.addAll(clippedReads);\n    }","id":78901,"modified_method":"/**\n     * Clips all of the reads in this active region so that none extend beyond the active region extended loc\n     *\n     * This function may change the getReadSpanLoc, as it updates the read span based on the new clipped\n     * read coordinates.\n     */\n    public void hardClipToActiveRegion() {\n        final ArrayList<GATKSAMRecord> clippedReads = ReadClipper.hardClipToRegion( reads, extendedLoc.getStart(), extendedLoc.getStop() );\n        ReadUtils.sortReadsByCoordinate(clippedReads);\n        clearReads();\n        addAll(clippedReads);\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public GenomeLoc getLocation() { return activeRegionLoc; }","id":78902,"modified_method":"/**\n     * Get the raw span of this active region (excluding the extension)\n     * @return a non-null genome loc\n     */\n    @Override\n    @Ensures(\"result != null\")\n    public GenomeLoc getLocation() { return activeRegionLoc; }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int getExtension() { return extension; }","id":78903,"modified_method":"/**\n     * Get the active region extension applied to this region\n     *\n     * The extension is >= 0 bp in size, and indicates how much padding this art walker wanted for its regions\n     *\n     * @return the size in bp of the region extension\n     */\n    @Ensures(\"result >= 0\")\n    public int getExtension() { return extension; }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Requires(\"referenceReader.isUppercasingBases()\")\n    private byte[] getReference( final CachingIndexedFastaSequenceFile referenceReader, final int padding, final GenomeLoc genomeLoc ) {\n        final byte[] reference =  referenceReader.getSubsequenceAt( genomeLoc.getContig(),\n                Math.max(1, genomeLoc.getStart() - padding),\n                Math.min(referenceReader.getSequenceDictionary().getSequence(genomeLoc.getContig()).getSequenceLength(), genomeLoc.getStop() + padding) ).getBases();\n        return reference;\n    }","id":78904,"modified_method":"/**\n     * Get the reference bases from referenceReader spanned by the extended location of this active region,\n     * including additional padding bp on either side.  If this expanded region would exceed the boundaries\n     * of the active region's contig, the returned result will be truncated to only include on-genome reference\n     * bases\n     * @param referenceReader the source of the reference genome bases\n     * @param padding the padding, in BP, we want to add to either side of this active region extended region\n     * @param genomeLoc a non-null genome loc indicating the base span of the bp we'd like to get the reference for\n     * @return a non-null array of bytes holding the reference bases in referenceReader\n     */\n    @Ensures(\"result != null\")\n    private byte[] getReference( final IndexedFastaSequenceFile referenceReader, final int padding, final GenomeLoc genomeLoc ) {\n        if ( referenceReader == null ) throw new IllegalArgumentException(\"referenceReader cannot be null\");\n        if ( padding < 0 ) throw new IllegalArgumentException(\"padding must be a positive integer but got \" + padding);\n        if ( genomeLoc == null ) throw new IllegalArgumentException(\"genomeLoc cannot be null\");\n        if ( genomeLoc.size() == 0 ) throw new IllegalArgumentException(\"GenomeLoc must have size > 0 but got \" + genomeLoc);\n\n        final byte[] reference =  referenceReader.getSubsequenceAt( genomeLoc.getContig(),\n                Math.max(1, genomeLoc.getStart() - padding),\n                Math.min(referenceReader.getSequenceDictionary().getSequence(genomeLoc.getContig()).getSequenceLength(), genomeLoc.getStop() + padding) ).getBases();\n\n        return reference;\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Requires(\"referenceReader.isUppercasingBases()\")\n    public byte[] getActiveRegionReference( final CachingIndexedFastaSequenceFile referenceReader ) {\n        return getActiveRegionReference(referenceReader, 0);\n    }","id":78905,"modified_method":"/**\n     * See #getActiveRegionReference but with padding == 0\n     */\n    public byte[] getActiveRegionReference( final IndexedFastaSequenceFile referenceReader ) {\n        return getActiveRegionReference(referenceReader, 0);\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean equalExceptReads(final ActiveRegion other) {\n        if ( activeRegionLoc.compareTo(other.activeRegionLoc) != 0 ) return false;\n        if ( isActive != other.isActive ) return false;\n        if ( genomeLocParser != other.genomeLocParser ) return false;\n        if ( extension != other.extension ) return false;\n        if ( extendedLoc.compareTo(other.extendedLoc) != 0 ) return false;\n        return true;\n    }","id":78906,"modified_method":"/**\n     * Is this region equal to other, excluding any reads in either region in the comparison\n     * @param other the other active region we want to test\n     * @return true if this region is equal, excluding any reads and derived values, to other\n     */\n    protected boolean equalExceptReads(final ActiveRegion other) {\n        if ( activeRegionLoc.compareTo(other.activeRegionLoc) != 0 ) return false;\n        if ( isActive() != other.isActive()) return false;\n        if ( genomeLocParser != other.genomeLocParser ) return false;\n        if ( extension != other.extension ) return false;\n        if ( extendedLoc.compareTo(other.extendedLoc) != 0 ) return false;\n        return true;\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public List<ActivityProfileState> getSupportingStates() { return supportingStates; }","id":78907,"modified_method":"/**\n     * Get the active profile states that went into creating this region, if possible\n     * @return an unmodifiable list of states that led to the creation of this region, or an empty\n     *         list if none were provided\n     */\n    @Ensures(\"result != null\")\n    public List<ActivityProfileState> getSupportingStates() {\n        return Collections.unmodifiableList(supportingStates);\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void add( final GATKSAMRecord read ) {\n        fullExtentReferenceLoc = fullExtentReferenceLoc.union( genomeLocParser.createGenomeLoc( read ) );\n        reads.add( read );\n    }","id":78908,"modified_method":"/**\n     * Add read to this active region\n     *\n     * Read must have alignment start >= than the last read currently in this active region.\n     *\n     * @throws IllegalArgumentException if read doesn't overlap the extended region of this active region\n     *\n     * @param read a non-null GATKSAMRecord\n     */\n    @Ensures(\"reads.size() == old(reads.size()) + 1\")\n    public void add( final GATKSAMRecord read ) {\n        if ( read == null ) throw new IllegalArgumentException(\"Read cannot be null\");\n\n        final GenomeLoc readLoc = genomeLocParser.createGenomeLoc( read );\n        if ( ! readOverlapsRegion(read) )\n            throw new IllegalArgumentException(\"Read location \" + readLoc + \" doesn't overlap with active region extended span \" + extendedLoc);\n\n        spanIncludingReads = spanIncludingReads.union( readLoc );\n\n        if ( ! reads.isEmpty() ) {\n            final GATKSAMRecord lastRead = reads.get(size() - 1);\n            if ( ! lastRead.getReferenceIndex().equals(read.getReferenceIndex()) )\n                throw new IllegalArgumentException(\"Attempting to add a read to ActiveRegion not on the same contig as other reads: lastRead \" + lastRead + \" attempting to add \" + read);\n\n            if ( read.getAlignmentStart() < lastRead.getAlignmentStart() )\n                throw new IllegalArgumentException(\"Attempting to add a read to ActiveRegion out of order w.r.t. other reads: lastRead \" + lastRead + \" at \" + lastRead.getAlignmentStart() + \" attempting to add \" + read + \" at \" + read.getAlignmentStart());\n        }\n\n        reads.add( read );\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public int size() { return reads.size(); }","id":78909,"modified_method":"/**\n     * Get the number of reads currently in this active region\n     * @return an integer >= 0\n     */\n    @Ensures(\"result >= 0\")\n    public int size() { return reads.size(); }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Requires(\"referenceReader.isUppercasingBases()\")\n    public byte[] getActiveRegionReference( final CachingIndexedFastaSequenceFile referenceReader, final int padding ) {\n        return getReference( referenceReader, padding, extendedLoc );\n    }","id":78910,"modified_method":"/**\n     * Get the reference bases from referenceReader spanned by the extended location of this active region,\n     * including additional padding bp on either side.  If this expanded region would exceed the boundaries\n     * of the active region's contig, the returned result will be truncated to only include on-genome reference\n     * bases\n     * @param referenceReader the source of the reference genome bases\n     * @param padding the padding, in BP, we want to add to either side of this active region extended region\n     * @return a non-null array of bytes holding the reference bases in referenceReader\n     */\n    @Ensures(\"result != null\")\n    public byte[] getActiveRegionReference( final IndexedFastaSequenceFile referenceReader, final int padding ) {\n        return getReference(referenceReader, padding, extendedLoc);\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ActiveRegion( final GenomeLoc activeRegionLoc, final List<ActivityProfileState> supportingStates, final boolean isActive, final GenomeLocParser genomeLocParser, final int extension ) {\n        if ( activeRegionLoc == null ) throw new IllegalArgumentException(\"activeRegionLoc cannot be null\");\n        if ( genomeLocParser == null ) throw new IllegalArgumentException(\"genomeLocParser cannot be null\");\n        if ( extension < 0 ) throw new IllegalArgumentException(\"extension cannot be < 0 but got \" + extension);\n\n        this.activeRegionLoc = activeRegionLoc;\n        this.supportingStates = supportingStates == null ? Collections.<ActivityProfileState>emptyList() : new ArrayList<ActivityProfileState>(supportingStates);\n        this.isActive = isActive;\n        this.genomeLocParser = genomeLocParser;\n        this.extension = extension;\n        extendedLoc = genomeLocParser.createGenomeLocOnContig(activeRegionLoc.getContig(), activeRegionLoc.getStart() - extension, activeRegionLoc.getStop() + extension);\n        fullExtentReferenceLoc = extendedLoc;\n    }","id":78911,"modified_method":"/**\n     * Create a new ActiveRegion containing no reads\n     *\n     * @param activeRegionLoc the span of this active region\n     * @param supportingStates the states that went into creating this region, or null / empty if none are available.\n     *                         If not empty, must have exactly one state for each bp in activeRegionLoc\n     * @param isActive indicates whether this is an active region, or an inactve one\n     * @param genomeLocParser a non-null parser to let us create new genome locs\n     * @param extension the active region extension to use for this active region\n     */\n    public ActiveRegion( final GenomeLoc activeRegionLoc, final List<ActivityProfileState> supportingStates, final boolean isActive, final GenomeLocParser genomeLocParser, final int extension ) {\n        if ( activeRegionLoc == null ) throw new IllegalArgumentException(\"activeRegionLoc cannot be null\");\n        if ( activeRegionLoc.size() == 0 ) throw new IllegalArgumentException(\"Active region cannot be of zero size, but got \" + activeRegionLoc);\n        if ( genomeLocParser == null ) throw new IllegalArgumentException(\"genomeLocParser cannot be null\");\n        if ( extension < 0 ) throw new IllegalArgumentException(\"extension cannot be < 0 but got \" + extension);\n\n        this.activeRegionLoc = activeRegionLoc;\n        this.supportingStates = supportingStates == null ? Collections.<ActivityProfileState>emptyList() : new ArrayList<ActivityProfileState>(supportingStates);\n        this.isActive = isActive;\n        this.genomeLocParser = genomeLocParser;\n        this.extension = extension;\n        this.extendedLoc = genomeLocParser.createGenomeLocOnContig(activeRegionLoc.getContig(), activeRegionLoc.getStart() - extension, activeRegionLoc.getStop() + extension);\n        this.spanIncludingReads = extendedLoc;\n\n        if ( ! this.supportingStates.isEmpty() ) {\n            if ( this.supportingStates.size() != activeRegionLoc.size() )\n                throw new IllegalArgumentException(\"Supporting states wasn't empty but it doesn't have exactly one state per bp in the active region: states \" + this.supportingStates.size() + \" vs. bp in region = \" + activeRegionLoc.size());\n            GenomeLoc lastStateLoc = null;\n            for ( final ActivityProfileState state : this.supportingStates ) {\n                if ( lastStateLoc != null ) {\n                    if ( state.getLoc().getStart() != lastStateLoc.getStart() + 1 || state.getLoc().getContigIndex() != lastStateLoc.getContigIndex())\n                        throw new IllegalArgumentException(\"Supporting state has an invalid sequence: last state was \" + lastStateLoc + \" but next state was \" + state);\n                }\n                lastStateLoc = state.getLoc();\n            }\n        }\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public GenomeLoc getExtendedLoc() { return extendedLoc; }","id":78912,"modified_method":"/**\n     * Get the span of this active region including the extension value\n     * @return a non-null GenomeLoc\n     */\n    @Ensures(\"result != null\")\n    public GenomeLoc getExtendedLoc() { return extendedLoc; }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"private ActiveRegion assertGoodRegions(final int start, final List<ActiveRegion> regions, final int maxRegionSize, ActiveRegion lastRegion, final List<Boolean> probs, final List<Boolean> seenSites) {\n        for ( final ActiveRegion region : regions ) {\n            Assert.assertTrue(region.getLocation().size() > 0, \"Region \" + region + \" has a bad size\");\n            Assert.assertTrue(region.getLocation().size() <= maxRegionSize, \"Region \" + region + \" has a bad size: it's big than the max region size \" + maxRegionSize);\n            if ( lastRegion != null ) {\n                Assert.assertTrue(region.getLocation().getStart() == lastRegion.getLocation().getStop() + 1, \"Region \" + region + \" doesn't start immediately after previous region\" + lastRegion);\n            }\n\n            // check that all active bases are actually active\n            final int regionOffset = region.getLocation().getStart() - start;\n            Assert.assertTrue(regionOffset >= 0 && regionOffset < probs.size(), \"Region \" + region + \" has a bad offset w.r.t. start\");\n            for ( int j = 0; j < region.getLocation().size(); j++ ) {\n                final int siteOffset = j + regionOffset;\n                Assert.assertEquals(region.isActive, probs.get(siteOffset).booleanValue());\n                Assert.assertFalse(seenSites.get(siteOffset), \"Site \" + j + \" in \" + region + \" was seen already\");\n                seenSites.set(siteOffset, true);\n            }\n\n            lastRegion = region;\n        }\n\n        return lastRegion;\n    }","id":78913,"modified_method":"private ActiveRegion assertGoodRegions(final int start, final List<ActiveRegion> regions, final int maxRegionSize, ActiveRegion lastRegion, final List<Boolean> probs, final List<Boolean> seenSites) {\n        for ( final ActiveRegion region : regions ) {\n            Assert.assertTrue(region.getLocation().size() > 0, \"Region \" + region + \" has a bad size\");\n            Assert.assertTrue(region.getLocation().size() <= maxRegionSize, \"Region \" + region + \" has a bad size: it's big than the max region size \" + maxRegionSize);\n            if ( lastRegion != null ) {\n                Assert.assertTrue(region.getLocation().getStart() == lastRegion.getLocation().getStop() + 1, \"Region \" + region + \" doesn't start immediately after previous region\" + lastRegion);\n            }\n\n            // check that all active bases are actually active\n            final int regionOffset = region.getLocation().getStart() - start;\n            Assert.assertTrue(regionOffset >= 0 && regionOffset < probs.size(), \"Region \" + region + \" has a bad offset w.r.t. start\");\n            for ( int j = 0; j < region.getLocation().size(); j++ ) {\n                final int siteOffset = j + regionOffset;\n                Assert.assertEquals(region.isActive(), probs.get(siteOffset).booleanValue());\n                Assert.assertFalse(seenSites.get(siteOffset), \"Site \" + j + \" in \" + region + \" was seen already\");\n                seenSites.set(siteOffset, true);\n            }\n\n            lastRegion = region;\n        }\n\n        return lastRegion;\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void assertGoodRegions(final List<ActiveRegion> regions, final int start, final int end, final int maxRegionSize) {\n        int lastPosSeen = start - 1;\n        for ( int regionI = 0; regionI < regions.size(); regionI++ ) {\n            final ActiveRegion region = regions.get(regionI);\n            Assert.assertEquals(region.getLocation().getStart(), lastPosSeen + 1, \"discontinuous with previous region.  lastPosSeen \" + lastPosSeen + \" but region is \" + region);\n            Assert.assertTrue(region.getLocation().size() <= maxRegionSize, \"Region is too big: \" + region);\n            lastPosSeen = region.getLocation().getStop();\n\n            for ( final ActivityProfileState state : region.getSupportingStates() ) {\n                Assert.assertEquals(state.isActiveProb > ActivityProfile.ACTIVE_PROB_THRESHOLD, region.isActive,\n                        \"Region is active=\" + region.isActive + \" but contains a state \" + state + \" with prob \"\n                                + state.isActiveProb + \" not within expected values given threshold for activity of \"\n                                + ActivityProfile.ACTIVE_PROB_THRESHOLD);\n            }\n        }\n    }","id":78914,"modified_method":"private void assertGoodRegions(final List<ActiveRegion> regions, final int start, final int end, final int maxRegionSize) {\n        int lastPosSeen = start - 1;\n        for ( int regionI = 0; regionI < regions.size(); regionI++ ) {\n            final ActiveRegion region = regions.get(regionI);\n            Assert.assertEquals(region.getLocation().getStart(), lastPosSeen + 1, \"discontinuous with previous region.  lastPosSeen \" + lastPosSeen + \" but region is \" + region);\n            Assert.assertTrue(region.getLocation().size() <= maxRegionSize, \"Region is too big: \" + region);\n            lastPosSeen = region.getLocation().getStop();\n\n            for ( final ActivityProfileState state : region.getSupportingStates() ) {\n                Assert.assertEquals(state.isActiveProb > ActivityProfile.ACTIVE_PROB_THRESHOLD, region.isActive(),\n                        \"Region is active=\" + region.isActive() + \" but contains a state \" + state + \" with prob \"\n                                + state.isActiveProb + \" not within expected values given threshold for activity of \"\n                                + ActivityProfile.ACTIVE_PROB_THRESHOLD);\n            }\n        }\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"private T processActiveRegion(final ActiveRegion activeRegion, final T sum, final ActiveRegionWalker<M, T> walker) {\n        final Iterator<GATKSAMRecord> liveReads = myReads.iterator();\n        while ( liveReads.hasNext() ) {\n            boolean killed = false;\n            final GATKSAMRecord read = liveReads.next();\n            final GenomeLoc readLoc = this.engine.getGenomeLocParser().createGenomeLoc( read );\n\n            if( activeRegion.getLocation().overlapsP( readLoc ) ) {\n                activeRegion.add(read);\n\n                if ( ! walker.wantsNonPrimaryReads() ) {\n                    liveReads.remove();\n                    killed = true;\n                }\n            } else if( walker.wantsExtendedReads() && activeRegion.getExtendedLoc().overlapsP( readLoc )) {\n                activeRegion.add( read );\n            }\n\n            if ( ! killed && readCannotOccurInAnyMoreActiveRegions(read, activeRegion) ) {\n                liveReads.remove();\n            }\n        }\n\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\">> Map call with \" + activeRegion.getReads().size() + \" \" + (activeRegion.isActive ? \"active\" : \"inactive\") + \" reads @ \" + activeRegion.getLocation() + \" with full extent: \" + activeRegion.getReferenceLoc());\n        }\n\n        if ( LOG_READ_CARRYING )\n            logger.info(String.format(\"Processing region %20s span=%3d active?=%5b with %4d reads.  Overall max reads carried is %s\",\n                    activeRegion.getLocation(), activeRegion.getLocation().size(), activeRegion.isActive, activeRegion.size(), maxReadsInMemory));\n\n        final M x = walker.map(activeRegion, null);\n        return walker.reduce( x, sum );\n    }","id":78915,"modified_method":"private T processActiveRegion(final ActiveRegion activeRegion, final T sum, final ActiveRegionWalker<M, T> walker) {\n        final Iterator<GATKSAMRecord> liveReads = myReads.iterator();\n        while ( liveReads.hasNext() ) {\n            boolean killed = false;\n            final GATKSAMRecord read = liveReads.next();\n            final GenomeLoc readLoc = this.engine.getGenomeLocParser().createGenomeLoc( read );\n\n            if( activeRegion.getLocation().overlapsP( readLoc ) ) {\n                activeRegion.add(read);\n\n                if ( ! walker.wantsNonPrimaryReads() ) {\n                    liveReads.remove();\n                    killed = true;\n                }\n            } else if( walker.wantsExtendedReads() && activeRegion.getExtendedLoc().overlapsP( readLoc )) {\n                activeRegion.add( read );\n            }\n\n            if ( ! killed && readCannotOccurInAnyMoreActiveRegions(read, activeRegion) ) {\n                liveReads.remove();\n            }\n        }\n\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\">> Map call with \" + activeRegion.getReads().size() + \" \" + (activeRegion.isActive() ? \"active\" : \"inactive\") + \" reads @ \" + activeRegion.getLocation() + \" with full extent: \" + activeRegion.getReadSpanLoc());\n        }\n\n        if ( LOG_READ_CARRYING )\n            logger.info(String.format(\"Processing region %20s span=%3d active?=%5b with %4d reads.  Overall max reads carried is %s\",\n                    activeRegion.getLocation(), activeRegion.getLocation().size(), activeRegion.isActive(), activeRegion.size(), maxReadsInMemory));\n\n        final M x = walker.map(activeRegion, null);\n        return walker.reduce( x, sum );\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Write out each active region to the walker activeRegionOutStream\n     *\n     * @param region the region we're currently operating on\n     */\n    @Requires(\"region != null\")\n    private void writeActiveRegion(final ActiveRegion region) {\n        if( walker.activeRegionOutStream != null ) {\n            initializeOutputStreamsIfNecessary();\n            printIGVFormatRow(walker.activeRegionOutStream, region.getLocation().getStartLocation(),\n                    \"end-marker\", 0.0);\n            printIGVFormatRow(walker.activeRegionOutStream, region.getLocation(),\n                    \"size=\" + region.getLocation().size(), region.isActive ? 1.0 : -1.0);\n        }\n    }","id":78916,"modified_method":"/**\n     * Write out each active region to the walker activeRegionOutStream\n     *\n     * @param region the region we're currently operating on\n     */\n    @Requires(\"region != null\")\n    private void writeActiveRegion(final ActiveRegion region) {\n        if( walker.activeRegionOutStream != null ) {\n            initializeOutputStreamsIfNecessary();\n            printIGVFormatRow(walker.activeRegionOutStream, region.getLocation().getStartLocation(),\n                    \"end-marker\", 0.0);\n            printIGVFormatRow(walker.activeRegionOutStream, region.getLocation(),\n                    \"size=\" + region.getLocation().size(), region.isActive() ? 1.0 : -1.0);\n        }\n    }","commit_id":"96d3091d16e046ec819c3b60cd406f54dc24f40b","url":"https://github.com/broadgsa/gatk"},{"original_method":"public GenomeLoc getLocation() {\n            return GenomeLocParser.createGenomeLoc(feature.getChr(), feature.getStart(), feature.getEnd());\n        }","id":78917,"modified_method":"public GenomeLoc getLocation() {\n            if (position == null) position = GenomeLocParser.createGenomeLoc(feature.getChr(), feature.getStart(), feature.getEnd());\n            return position;\n        }","commit_id":"a0d71540df42e86c4b8d56a6bba33ac3ae506cdc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * create an index for the input file\n     * @param inputFile the input file\n     * @param codec the codec to use\n     * @return a linear index for the specified type\n     * @throws IOException if we cannot write the index file\n     */\n    private LinearIndex createIndex(File inputFile, FeatureCodec codec) throws IOException {\n        LinearIndexCreator create = new LinearIndexCreator(inputFile, codec);\n        return create.createIndex();\n    }","id":78918,"modified_method":"/**\n     * create an index for the input file\n     * @param inputFile the input file\n     * @param codec the codec to use\n     * @return a linear index for the specified type\n     * @throws IOException if we cannot write the index file\n     */\n    public static LinearIndex createIndex(File inputFile, FeatureCodec codec) throws IOException {\n        LinearIndexCreator create = new LinearIndexCreator(inputFile, codec);\n        return create.createIndex();\n    }","commit_id":"a0d71540df42e86c4b8d56a6bba33ac3ae506cdc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * this function checks if we need to make an index file. There are three cases:\n     * 1. The index file doesn't exist; return true\n     * 2. The index does exist, but is older than the file.  We delete the index and return true\n     * 3. else return false;\n     * @param inputFile the target file to make an index for\n     * @return true if we need to create an index, false otherwise\n     */\n    private boolean requireIndex(File inputFile) {\n        // can we read the index? if not, create an index\n        File indexFile = new File(inputFile.getAbsolutePath() + linearIndexExtension);\n        if (!(indexFile.canRead())) return true;\n        if (inputFile.lastModified() > indexFile.lastModified()) {\n            logger.warn(\"Removing out of date (index file date older than target file ) index file \" + indexFile);\n            indexFile.delete();\n            return true;\n        }\n        return false;\n    }","id":78919,"modified_method":"/**\n     * this function checks if we need to make an index file. There are three cases:\n     * 1. The index file doesn't exist; return true\n     * 2. The index does exist, but is older than the file.  We delete the index and return true\n     * 3. else return false;\n     * @param inputFile the target file to make an index for\n     * @return true if we need to create an index, false otherwise\n     */\n    public static boolean requireIndex(File inputFile) {\n        // can we read the index? if not, create an index\n        File indexFile = new File(inputFile.getAbsolutePath() + linearIndexExtension);\n        if (!(indexFile.canRead())) return true;\n        if (inputFile.lastModified() > indexFile.lastModified()) {\n            logger.warn(\"Removing out of date (index file date older than target file ) index file \" + indexFile);\n            indexFile.delete();\n            return true;\n        }\n        return false;\n    }","commit_id":"a0d71540df42e86c4b8d56a6bba33ac3ae506cdc","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void initialize(File vcfFile, VCFCodec.LineTransform transform) {\n        VCFCodec codec = new VCFCodec();\n        if (transform != null) codec.setTransformer(transform);\n        try {\n            vcfReader = new FeatureReader(vcfFile,codec);\n            iterator= vcfReader.iterator();\n        } catch (FileNotFoundException e) {\n            throw new StingException(\"Unable to read VCF File from \" + vcfFile, e);\n        } catch (IOException e) {\n            throw new StingException(\"Unable to read VCF File from \" + vcfFile, e);\n        }\n        mHeader = codec.getHeader();\n    }","id":78920,"modified_method":"private void initialize(File vcfFile, VCFCodec.LineTransform transform) {\n        VCFCodec codec = new VCFCodec();\n        LinearIndex index = null;\n        if (TribbleRMDTrackBuilder.requireIndex(vcfFile)) {\n            try {\n                index = TribbleRMDTrackBuilder.createIndex(vcfFile, new VCFCodec());\n            } catch (IOException e) {\n                throw new StingException(\"Unable to make required index for file \" + vcfFile + \" do you have write permissions to the directory?\");\n            }\n        }\n        if (transform != null) codec.setTransformer(transform);\n        try {\n            vcfReader = new FeatureReader(vcfFile,codec);\n            iterator= vcfReader.iterator();\n        } catch (FileNotFoundException e) {\n            throw new StingException(\"Unable to read VCF File from \" + vcfFile, e);\n        } catch (IOException e) {\n            throw new StingException(\"Unable to read VCF File from \" + vcfFile, e);\n        }\n        mHeader = codec.getHeader();\n    }","commit_id":"a0d71540df42e86c4b8d56a6bba33ac3ae506cdc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/** test, using the writer and reader, that we can output and input a VCF file without problems */\n    @Test\n    public void testBasicWriteAndRead() {\n        VCFHeader header = createFakeHeader(metaData,additionalColumns);\n        VCFWriter writer = new VCFWriter(fakeVCFFile);\n        writer.writeHeader(header);\n        writer.addRecord(createVCFRecord(header));\n        writer.addRecord(createVCFRecord(header));\n        writer.close();\n        VCFReader reader = new VCFReader(fakeVCFFile);\n        int counter = 0;\n        // validate what we're reading in\n        validateHeader(reader.getHeader());\n        for (VCFRecord rec : reader) {\n            counter++;\n        }\n        Assert.assertEquals(2,counter);\n        reader.close();\n        fakeVCFFile.delete();\n    }","id":78921,"modified_method":"/** test, using the writer and reader, that we can output and input a VCF file without problems */\n    @Test\n    public void testBasicWriteAndRead() {\n        VCFHeader header = createFakeHeader(metaData,additionalColumns);\n        VCFWriter writer = new VCFWriter(fakeVCFFile);\n        writer.writeHeader(header);\n        writer.addRecord(createVCFRecord(header));\n        writer.addRecord(createVCFRecord(header));\n        writer.close();\n        VCFReader reader = new VCFReader(fakeVCFFile);\n        int counter = 0;\n        // validate what we're reading in\n        validateHeader(reader.getHeader());\n        for (VCFRecord rec : reader) {\n            counter++;\n        }\n        Assert.assertEquals(2,counter);\n        reader.close();\n        new File(fakeVCFFile + TribbleRMDTrackBuilder.linearIndexExtension).delete();\n        fakeVCFFile.delete();\n    }","commit_id":"a0d71540df42e86c4b8d56a6bba33ac3ae506cdc","url":"https://github.com/broadgsa/gatk"},{"original_method":"private <D extends CallableDescriptor> ResolutionStatus checkValueArgumentTypes(CallResolutionContext<D> context) {\n        ResolutionStatus result = SUCCESS;\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : context.candidateCall.getValueArguments().entrySet()) {\n            ValueParameterDescriptor parameterDescriptor = entry.getKey();\n            ResolvedValueArgument resolvedArgument = entry.getValue();\n\n            JetType parameterType = getEffectiveExpectedType(parameterDescriptor);\n\n            List<JetExpression> argumentExpressions = resolvedArgument.getArgumentExpressions();\n            for (JetExpression argumentExpression : argumentExpressions) {\n                JetType type = expressionTypingServices.getType(context.scope, argumentExpression, parameterType, context.dataFlowInfo, context.candidateCall.getTrace());\n                if (type == null || ErrorUtils.isErrorType(type)) {\n                    context.candidateCall.argumentHasNoType();\n                }\n                else if (!typeChecker.isSubtypeOf(type, parameterType)) {\n//                    VariableDescriptor variableDescriptor = AutoCastUtils.getVariableDescriptorFromSimpleName(temporaryTrace.getBindingContext(), argumentExpression);\n//                    if (variableDescriptor != null) {\n//                        JetType autoCastType = null;\n//                        for (JetType possibleType : dataFlowInfo.getPossibleTypesForVariable(variableDescriptor)) {\n//                            if (semanticServices.getTypeChecker().isSubtypeOf(type, parameterType)) {\n//                                autoCastType = possibleType;\n//                                break;\n//                            }\n//                        }\n//                        if (autoCastType != null) {\n//                            if (AutoCastUtils.isStableVariable(variableDescriptor)) {\n//                                temporaryTrace.record(AUTOCAST, argumentExpression, autoCastType);\n//                            }\n//                            else {\n//                                temporaryTrace.report(AUTOCAST_IMPOSSIBLE.on(argumentExpression, autoCastType, variableDescriptor));\n//                                result = false;\n//                            }\n//                        }\n//                    }\n//                    else {\n                    result = OTHER_ERROR;\n                }\n            }\n        }\n        return result;\n    }","id":78922,"modified_method":"private <D extends CallableDescriptor> ResolutionStatus checkValueArgumentTypes(CallResolutionContext<D> context) {\n        ResolutionStatus result = SUCCESS;\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : context.candidateCall.getValueArguments().entrySet()) {\n            ValueParameterDescriptor parameterDescriptor = entry.getKey();\n            ResolvedValueArgument resolvedArgument = entry.getValue();\n\n            JetType parameterType = getEffectiveExpectedType(parameterDescriptor);\n\n            List<JetExpression> argumentExpressions = resolvedArgument.getArgumentExpressions();\n            for (JetExpression argumentExpression : argumentExpressions) {\n                if (argumentExpression == null) {\n                    throw new IllegalStateException(\"A null instead of an expression in the arguments for \" + entry.getKey());\n                }\n                JetType type = expressionTypingServices.getType(context.scope, argumentExpression, parameterType, context.dataFlowInfo, context.candidateCall.getTrace());\n                if (type == null || ErrorUtils.isErrorType(type)) {\n                    context.candidateCall.argumentHasNoType();\n                }\n                else if (!typeChecker.isSubtypeOf(type, parameterType)) {\n//                    VariableDescriptor variableDescriptor = AutoCastUtils.getVariableDescriptorFromSimpleName(temporaryTrace.getBindingContext(), argumentExpression);\n//                    if (variableDescriptor != null) {\n//                        JetType autoCastType = null;\n//                        for (JetType possibleType : dataFlowInfo.getPossibleTypesForVariable(variableDescriptor)) {\n//                            if (semanticServices.getTypeChecker().isSubtypeOf(type, parameterType)) {\n//                                autoCastType = possibleType;\n//                                break;\n//                            }\n//                        }\n//                        if (autoCastType != null) {\n//                            if (AutoCastUtils.isStableVariable(variableDescriptor)) {\n//                                temporaryTrace.record(AUTOCAST, argumentExpression, autoCastType);\n//                            }\n//                            else {\n//                                temporaryTrace.report(AUTOCAST_IMPOSSIBLE.on(argumentExpression, autoCastType, variableDescriptor));\n//                                result = false;\n//                            }\n//                        }\n//                    }\n//                    else {\n                    result = OTHER_ERROR;\n                }\n            }\n        }\n        return result;\n    }","commit_id":"d27138e25284f85d19e52fc52922b4ecf3745f6c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static <D extends CallableDescriptor> void put(ResolvedCallImpl<D> candidateCall, ValueParameterDescriptor valueParameterDescriptor, ValueArgument valueArgument, Map<ValueParameterDescriptor, VarargValueArgument> varargs) {\n        if (valueParameterDescriptor.getVarargElementType() != null) {\n            VarargValueArgument vararg = varargs.get(valueParameterDescriptor);\n            if (vararg == null) {\n                vararg = new VarargValueArgument();\n                varargs.put(valueParameterDescriptor, vararg);\n                candidateCall.recordValueArgument(valueParameterDescriptor, vararg);\n            }\n            vararg.getArgumentExpressions().add(valueArgument.getArgumentExpression());\n        }\n        else {\n            ResolvedValueArgument argument = new ExpressionValueArgument(valueArgument.getArgumentExpression());\n            candidateCall.recordValueArgument(valueParameterDescriptor, argument);\n        }\n    }","id":78923,"modified_method":"private static <D extends CallableDescriptor> void put(ResolvedCallImpl<D> candidateCall, ValueParameterDescriptor valueParameterDescriptor, ValueArgument valueArgument, Map<ValueParameterDescriptor, VarargValueArgument> varargs) {\n        if (valueParameterDescriptor.getVarargElementType() != null) {\n            VarargValueArgument vararg = varargs.get(valueParameterDescriptor);\n            if (vararg == null) {\n                vararg = new VarargValueArgument();\n                varargs.put(valueParameterDescriptor, vararg);\n                candidateCall.recordValueArgument(valueParameterDescriptor, vararg);\n            }\n            JetExpression expression = valueArgument.getArgumentExpression();\n            if (expression != null) {\n                vararg.getArgumentExpressions().add(expression);\n            }\n        }\n        else {\n            ResolvedValueArgument argument = new ExpressionValueArgument(valueArgument.getArgumentExpression());\n            candidateCall.recordValueArgument(valueParameterDescriptor, argument);\n        }\n    }","commit_id":"d27138e25284f85d19e52fc52922b4ecf3745f6c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void resolveArguments(@NotNull OverloadResolutionResults<FunctionDescriptor> results,\n            @NotNull AnnotationDescriptor descriptor, BindingTrace trace) {\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> descriptorToArgument :\n                results.getResultingCall().getValueArguments().entrySet()) {\n            // TODO: are varargs supported here?\n            List<ValueArgument> valueArguments = descriptorToArgument.getValue().getArguments();\n            ValueParameterDescriptor parameterDescriptor = descriptorToArgument.getKey();\n            for (ValueArgument argument : valueArguments) {\n                CompileTimeConstant<?> compileTimeConstant =\n                        resolveAnnotationArgument(argument.getArgumentExpression(), parameterDescriptor.getType(), trace);\n                if (compileTimeConstant != null) {\n                    descriptor.setValueArgument(parameterDescriptor, compileTimeConstant);\n                }\n            }\n        }\n    }","id":78924,"modified_method":"private void resolveArguments(@NotNull OverloadResolutionResults<FunctionDescriptor> results,\n            @NotNull AnnotationDescriptor descriptor, BindingTrace trace) {\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> descriptorToArgument :\n                results.getResultingCall().getValueArguments().entrySet()) {\n            // TODO: are varargs supported here?\n            List<ValueArgument> valueArguments = descriptorToArgument.getValue().getArguments();\n            ValueParameterDescriptor parameterDescriptor = descriptorToArgument.getKey();\n            for (ValueArgument argument : valueArguments) {\n                JetExpression argumentExpression = argument.getArgumentExpression();\n                if (argumentExpression != null) {\n                    CompileTimeConstant<?> compileTimeConstant =\n                            resolveAnnotationArgument(argumentExpression, parameterDescriptor.getType(), trace);\n                    if (compileTimeConstant != null) {\n                        descriptor.setValueArgument(parameterDescriptor, compileTimeConstant);\n                    }\n                }\n            }\n        }\n    }","commit_id":"34a9d6a4697bd97aed4801c73f8dd112758df1d3","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private <D extends CallableDescriptor> ResolutionStatus inferTypeArguments(CallResolutionContext<D> context) {\n        ResolvedCallImpl<D> candidateCall = context.candidateCall;\n        D candidate = candidateCall.getCandidateDescriptor();\n\n        ResolutionDebugInfo.Data debugInfo = context.trace.get(ResolutionDebugInfo.RESOLUTION_DEBUG_INFO, context.call.getCallElement());\n\n        ConstraintSystem constraintSystem = new ConstraintSystemWithPriorities(new DebugConstraintResolutionListener(candidateCall, debugInfo));\n\n        // If the call is recursive, e.g.\n        //   fun foo<T>(t : T) : T = foo(t)\n        // we can't use same descriptor objects for T's as actual type values and same T's as unknowns,\n        // because constraints become trivial (T :< T), and inference fails\n        //\n        // Thus, we replace the parameters of our descriptor with fresh objects (perform alpha-conversion)\n        CallableDescriptor candidateWithFreshVariables = FunctionDescriptorUtil.alphaConvertTypeParameters(candidate);\n\n\n        for (TypeParameterDescriptor typeParameterDescriptor : candidateWithFreshVariables.getTypeParameters()) {\n            constraintSystem.registerTypeVariable(typeParameterDescriptor, Variance.INVARIANT); // TODO: variance of the occurrences\n        }\n\n        TypeSubstitutor substituteDontCare = ConstraintSystemWithPriorities\n            .makeConstantSubstitutor(candidateWithFreshVariables.getTypeParameters(), DONT_CARE);\n\n        // Value parameters\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : candidateCall.getValueArguments().entrySet()) {\n            ResolvedValueArgument resolvedValueArgument = entry.getValue();\n            ValueParameterDescriptor valueParameterDescriptor = candidateWithFreshVariables.getValueParameters().get(entry.getKey().getIndex());\n\n\n            for (ValueArgument valueArgument : resolvedValueArgument.getArguments()) {\n                // TODO : more attempts, with different expected types\n\n                JetType effectiveExpectedType = getEffectiveExpectedType(valueParameterDescriptor, valueArgument);\n\n                // Here we type check expecting an error type (that is a subtype of any type and a supertype of any type\n                // and throw the results away\n                // We'll type check the arguments later, with the inferred types expected\n                TemporaryBindingTrace traceForUnknown = TemporaryBindingTrace.create(context.trace);\n                JetType type = expressionTypingServices.getType(context.scope, valueArgument.getArgumentExpression(), substituteDontCare.substitute(valueParameterDescriptor.getType(), Variance.INVARIANT), traceForUnknown);\n                if (type != null && !ErrorUtils.isErrorType(type)) {\n                    constraintSystem.addSubtypingConstraint(VALUE_ARGUMENT.assertSubtyping(type, effectiveExpectedType));\n                }\n                else {\n                    candidateCall.argumentHasNoType();\n                }\n            }\n        }\n\n        // Receiver\n        // Error is already reported if something is missing\n        ReceiverDescriptor receiverArgument = candidateCall.getReceiverArgument();\n        ReceiverDescriptor receiverParameter = candidateWithFreshVariables.getReceiverParameter();\n        if (receiverArgument.exists() && receiverParameter.exists()) {\n            constraintSystem.addSubtypingConstraint(RECEIVER.assertSubtyping(receiverArgument.getType(), receiverParameter.getType()));\n        }\n\n        // Return type\n        if (context.expectedType != NO_EXPECTED_TYPE) {\n            constraintSystem.addSubtypingConstraint(EXPECTED_TYPE.assertSubtyping(candidateWithFreshVariables.getReturnType(), context.expectedType));\n        }\n\n        // Solution\n        ConstraintSystemSolution solution = constraintSystem.solve();\n        if (solution.getStatus().isSuccessful()) {\n            D substitute = (D) candidateWithFreshVariables.substitute(solution.getSubstitutor());\n            assert substitute != null;\n            replaceValueParametersWithSubstitutedOnes(candidateCall, substitute);\n            candidateCall.setResultingDescriptor(substitute);\n\n            for (TypeParameterDescriptor typeParameterDescriptor : candidateCall.getCandidateDescriptor().getTypeParameters()) {\n                candidateCall.recordTypeArgument(typeParameterDescriptor, solution.getValue(candidateWithFreshVariables.getTypeParameters().get(typeParameterDescriptor.getIndex())));\n            }\n\n            // Here we type check the arguments with inferred types expected\n            checkValueArgumentTypes(context);\n\n            return SUCCESS;\n        }\n        else {\n            context.tracing.typeInferenceFailed(context.trace, solution.getStatus());\n            return OTHER_ERROR.combine(checkAllValueArguments(context));\n        }\n    }","id":78925,"modified_method":"private <D extends CallableDescriptor> ResolutionStatus inferTypeArguments(CallResolutionContext<D> context) {\n        ResolvedCallImpl<D> candidateCall = context.candidateCall;\n        D candidate = candidateCall.getCandidateDescriptor();\n\n        ResolutionDebugInfo.Data debugInfo = context.trace.get(ResolutionDebugInfo.RESOLUTION_DEBUG_INFO, context.call.getCallElement());\n\n        ConstraintSystem constraintSystem = new ConstraintSystemWithPriorities(new DebugConstraintResolutionListener(candidateCall, debugInfo));\n\n        // If the call is recursive, e.g.\n        //   fun foo<T>(t : T) : T = foo(t)\n        // we can't use same descriptor objects for T's as actual type values and same T's as unknowns,\n        // because constraints become trivial (T :< T), and inference fails\n        //\n        // Thus, we replace the parameters of our descriptor with fresh objects (perform alpha-conversion)\n        CallableDescriptor candidateWithFreshVariables = FunctionDescriptorUtil.alphaConvertTypeParameters(candidate);\n\n\n        for (TypeParameterDescriptor typeParameterDescriptor : candidateWithFreshVariables.getTypeParameters()) {\n            constraintSystem.registerTypeVariable(typeParameterDescriptor, Variance.INVARIANT); // TODO: variance of the occurrences\n        }\n\n        TypeSubstitutor substituteDontCare = ConstraintSystemWithPriorities\n            .makeConstantSubstitutor(candidateWithFreshVariables.getTypeParameters(), DONT_CARE);\n\n        // Value parameters\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : candidateCall.getValueArguments().entrySet()) {\n            ResolvedValueArgument resolvedValueArgument = entry.getValue();\n            ValueParameterDescriptor valueParameterDescriptor = candidateWithFreshVariables.getValueParameters().get(entry.getKey().getIndex());\n\n\n            for (ValueArgument valueArgument : resolvedValueArgument.getArguments()) {\n                // TODO : more attempts, with different expected types\n\n                JetType effectiveExpectedType = getEffectiveExpectedType(valueParameterDescriptor, valueArgument);\n\n                // Here we type check expecting an error type (that is a subtype of any type and a supertype of any type\n                // and throw the results away\n                // We'll type check the arguments later, with the inferred types expected\n                TemporaryBindingTrace traceForUnknown = TemporaryBindingTrace.create(context.trace);\n                JetExpression argumentExpression = valueArgument.getArgumentExpression();\n                JetType type = argumentExpression != null ? expressionTypingServices.getType(context.scope, argumentExpression,\n                        substituteDontCare.substitute(valueParameterDescriptor.getType(), Variance.INVARIANT), traceForUnknown) : null;\n                if (type != null && !ErrorUtils.isErrorType(type)) {\n                    constraintSystem.addSubtypingConstraint(VALUE_ARGUMENT.assertSubtyping(type, effectiveExpectedType));\n                }\n                else {\n                    candidateCall.argumentHasNoType();\n                }\n            }\n        }\n\n        // Receiver\n        // Error is already reported if something is missing\n        ReceiverDescriptor receiverArgument = candidateCall.getReceiverArgument();\n        ReceiverDescriptor receiverParameter = candidateWithFreshVariables.getReceiverParameter();\n        if (receiverArgument.exists() && receiverParameter.exists()) {\n            constraintSystem.addSubtypingConstraint(RECEIVER.assertSubtyping(receiverArgument.getType(), receiverParameter.getType()));\n        }\n\n        // Return type\n        if (context.expectedType != NO_EXPECTED_TYPE) {\n            constraintSystem.addSubtypingConstraint(EXPECTED_TYPE.assertSubtyping(candidateWithFreshVariables.getReturnType(), context.expectedType));\n        }\n\n        // Solution\n        ConstraintSystemSolution solution = constraintSystem.solve();\n        if (solution.getStatus().isSuccessful()) {\n            D substitute = (D) candidateWithFreshVariables.substitute(solution.getSubstitutor());\n            assert substitute != null;\n            replaceValueParametersWithSubstitutedOnes(candidateCall, substitute);\n            candidateCall.setResultingDescriptor(substitute);\n\n            for (TypeParameterDescriptor typeParameterDescriptor : candidateCall.getCandidateDescriptor().getTypeParameters()) {\n                candidateCall.recordTypeArgument(typeParameterDescriptor, solution.getValue(candidateWithFreshVariables.getTypeParameters().get(typeParameterDescriptor.getIndex())));\n            }\n\n            // Here we type check the arguments with inferred types expected\n            checkValueArgumentTypes(context);\n\n            return SUCCESS;\n        }\n        else {\n            context.tracing.typeInferenceFailed(context.trace, solution.getStatus());\n            return OTHER_ERROR.combine(checkAllValueArguments(context));\n        }\n    }","commit_id":"77dad4fbfb848f887aec674a4fb49d939e0e6c9c","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ManagedSetStrategy(Factory<String> supportedTypeDescriptions) {\n        super(new ModelType<ManagedSet<?>>() {\n        }, supportedTypeDescriptions);\n    }","id":78926,"modified_method":"public ManagedSetStrategy() {\n        super(new ModelType<ManagedSet<?>>() {\n        });\n    }","commit_id":"2caf4077a9e8e2da40df2c80e92a19ca255cf342","url":"https://github.com/gradle/gradle"},{"original_method":"private Iterable<String> getSupportedTypes() {\n        return Iterables.concat(Iterables.transform(strategies, new Function<ModelSchemaExtractionStrategy, Iterable<String>>() {\n            public Iterable<String> apply(ModelSchemaExtractionStrategy input) {\n                return input.getSupportedManagedTypes();\n            }\n        }));\n    }","id":78927,"modified_method":"private static Iterable<String> getSupportedTypes() {\n        return Arrays.asList(\n            \"interfaces and abstract classes annotated with \" + Managed.class.getName(),\n            \"JDK value types: \" + Joiner.on(\", \").join(Iterables.transform(JdkValueTypeStrategy.TYPES, new Function<ModelType<?>, Object>() {\n                public Object apply(ModelType<?> input) {\n                    return input.getRawClass().getSimpleName();\n                }\n            })),\n            \"Enum types\",\n            ModelMap.class.getName() + \" of a managed type\",\n            ModelSet.class.getName() + \" of a managed type\"\n        );\n    }","commit_id":"2caf4077a9e8e2da40df2c80e92a19ca255cf342","url":"https://github.com/gradle/gradle"},{"original_method":"private String getSupportedTypesDescription() {\n        return Joiner.on(SystemProperties.getInstance().getLineSeparator()).join(Iterables.transform(getSupportedTypes(), new Function<String, String>() {\n            public String apply(String input) {\n                return \" - \" + input;\n            }\n        }));\n    }","id":78928,"modified_method":"public static String getManageablePropertyTypesDescription() {\n        return Joiner.on(SystemProperties.getInstance().getLineSeparator()).join(Iterables.transform(getSupportedTypes(), new Function<String, String>() {\n            public String apply(String input) {\n                return \" - \" + input;\n            }\n        }));\n    }","commit_id":"2caf4077a9e8e2da40df2c80e92a19ca255cf342","url":"https://github.com/gradle/gradle"},{"original_method":"public ModelSchemaExtractor(List<? extends ModelSchemaExtractionStrategy> strategies) {\n        Factory<String> supportedTypeDescriptions = new Factory<String>() {\n            public String create() {\n                return getSupportedTypesDescription();\n            }\n        };\n\n        this.strategies = ImmutableList.<ModelSchemaExtractionStrategy>builder()\n            .add(\n                new PrimitiveStrategy(),\n                new EnumStrategy(),\n                new JdkValueTypeStrategy(),\n                new ModelSetStrategy(supportedTypeDescriptions),\n                new ManagedSetStrategy(supportedTypeDescriptions),\n                new StructStrategy(supportedTypeDescriptions),\n                new SpecializedMapStrategy(),\n                new ModelMapStrategy()\n            )\n            .addAll(strategies)\n            .add(new UnmanagedStrategy())\n            .build();\n    }","id":78929,"modified_method":"public ModelSchemaExtractor(List<? extends ModelSchemaExtractionStrategy> strategies) {\n        this.strategies = ImmutableList.<ModelSchemaExtractionStrategy>builder()\n            .add(\n                new PrimitiveStrategy(),\n                new EnumStrategy(),\n                new JdkValueTypeStrategy(),\n                new ModelSetStrategy(),\n                new ManagedSetStrategy(),\n                new StructStrategy(),\n                new SpecializedMapStrategy(),\n                new ModelMapStrategy()\n            )\n            .addAll(strategies)\n            .add(new UnmanagedStrategy())\n            .build();\n    }","commit_id":"2caf4077a9e8e2da40df2c80e92a19ca255cf342","url":"https://github.com/gradle/gradle"},{"original_method":"public ModelSetStrategy(Factory<String> supportedTypeDescriptions) {\n        super(new ModelType<ModelSet<?>>() {\n        }, supportedTypeDescriptions);\n    }","id":78930,"modified_method":"public ModelSetStrategy() {\n        super(new ModelType<ModelSet<?>>() {\n        });\n    }","commit_id":"2caf4077a9e8e2da40df2c80e92a19ca255cf342","url":"https://github.com/gradle/gradle"},{"original_method":"public SetStrategy(ModelType<?> modelType, Factory<String> supportedTypeDescriptions) {\n        this.modelType = modelType;\n        this.supportedTypeDescriptions = supportedTypeDescriptions;\n    }","id":78931,"modified_method":"public SetStrategy(ModelType<?> modelType) {\n        this.modelType = modelType;\n    }","commit_id":"2caf4077a9e8e2da40df2c80e92a19ca255cf342","url":"https://github.com/gradle/gradle"},{"original_method":"public <T> ModelSchemaExtractionResult<T> extract(ModelSchemaExtractionContext<T> extractionContext, final ModelSchemaCache cache) {\n        ModelType<T> type = extractionContext.getType();\n        if (modelType.isAssignableFrom(type)) {\n            if (!type.getRawClass().equals(modelType.getConcreteClass())) {\n                throw new InvalidManagedModelElementTypeException(extractionContext, String.format(\"subtyping %s is not supported\", modelType.getConcreteClass().getName()));\n            }\n            if (type.isHasWildcardTypeVariables()) {\n                throw new InvalidManagedModelElementTypeException(extractionContext, String.format(\"type parameter of %s cannot be a wildcard\", modelType.getConcreteClass().getName()));\n            }\n\n            List<ModelType<?>> typeVariables = type.getTypeVariables();\n            if (typeVariables.isEmpty()) {\n                throw new InvalidManagedModelElementTypeException(extractionContext, String.format(\"type parameter of %s has to be specified\", modelType.getConcreteClass().getName()));\n            }\n\n            ModelType<?> elementType = typeVariables.get(0);\n\n            if (modelType.isAssignableFrom(elementType)) {\n                throw new InvalidManagedModelElementTypeException(extractionContext, String.format(\"%1$s cannot be used as type parameter of %1$s\", modelType.getConcreteClass().getName()));\n            }\n\n            ModelSchema<T> schema = ModelSchema.collection(extractionContext.getType(), elementType);\n            ModelSchemaExtractionContext<?> typeParamExtractionContext = extractionContext.child(elementType, \"element type\", new Action<ModelSchemaExtractionContext<?>>() {\n                public void execute(ModelSchemaExtractionContext<?> context) {\n                    ModelSchema<?> typeParamSchema = cache.get(context.getType());\n\n                    if (!typeParamSchema.getKind().isManaged()) {\n                        throw new InvalidManagedModelElementTypeException(context.getParent(), String.format(\n                            \"cannot create a managed set of type %s as it is an unmanaged type.%nSupported types:%n%s\",\n                            context.getType(), supportedTypeDescriptions.create()\n                        ));\n                    }\n                }\n            });\n            return new ModelSchemaExtractionResult<T>(schema, ImmutableList.of(typeParamExtractionContext));\n        } else {\n            return null;\n        }\n    }","id":78932,"modified_method":"public <T> ModelSchemaExtractionResult<T> extract(ModelSchemaExtractionContext<T> extractionContext, final ModelSchemaCache cache) {\n        ModelType<T> type = extractionContext.getType();\n        if (modelType.isAssignableFrom(type)) {\n            if (!type.getRawClass().equals(modelType.getConcreteClass())) {\n                throw new InvalidManagedModelElementTypeException(extractionContext, String.format(\"subtyping %s is not supported\", modelType.getConcreteClass().getName()));\n            }\n            if (type.isHasWildcardTypeVariables()) {\n                throw new InvalidManagedModelElementTypeException(extractionContext, String.format(\"type parameter of %s cannot be a wildcard\", modelType.getConcreteClass().getName()));\n            }\n\n            List<ModelType<?>> typeVariables = type.getTypeVariables();\n            if (typeVariables.isEmpty()) {\n                throw new InvalidManagedModelElementTypeException(extractionContext, String.format(\"type parameter of %s has to be specified\", modelType.getConcreteClass().getName()));\n            }\n\n            ModelType<?> elementType = typeVariables.get(0);\n\n            if (modelType.isAssignableFrom(elementType)) {\n                throw new InvalidManagedModelElementTypeException(extractionContext, String.format(\"%1$s cannot be used as type parameter of %1$s\", modelType.getConcreteClass().getName()));\n            }\n\n            ModelSchema<T> schema = ModelSchema.collection(extractionContext.getType(), elementType);\n            ModelSchemaExtractionContext<?> typeParamExtractionContext = extractionContext.child(elementType, \"element type\", new Action<ModelSchemaExtractionContext<?>>() {\n                public void execute(ModelSchemaExtractionContext<?> context) {\n                    ModelSchema<?> typeParamSchema = cache.get(context.getType());\n\n                    if (!typeParamSchema.getKind().isManaged()) {\n                        throw new InvalidManagedModelElementTypeException(context.getParent(), String.format(\n                            \"cannot create a managed set of type %s as it is an unmanaged type. Only @Managed types are allowed.\",\n                            context.getType()\n                        ));\n                    }\n                }\n            });\n            return new ModelSchemaExtractionResult<T>(schema, ImmutableList.of(typeParamExtractionContext));\n        } else {\n            return null;\n        }\n    }","commit_id":"2caf4077a9e8e2da40df2c80e92a19ca255cf342","url":"https://github.com/gradle/gradle"},{"original_method":"public StructStrategy(Factory<String> supportedTypeDescriptions) {\n        this.supportedTypeDescriptions = supportedTypeDescriptions;\n\n        Iterable<Method> ignoredMethods = Iterables.concat(Arrays.asList(Object.class.getMethods()), Arrays.asList(GroovyObject.class.getMethods()));\n        this.ignoredMethods = ImmutableSet.copyOf(Iterables.transform(ignoredMethods, new Function<Method, Equivalence.Wrapper<Method>>() {\n            public Equivalence.Wrapper<Method> apply(@Nullable Method input) {\n                return equivalence.wrap(input);\n            }\n        }));\n    }","id":78933,"modified_method":"public StructStrategy() {\n        Iterable<Method> ignoredMethods = Iterables.concat(Arrays.asList(Object.class.getMethods()), Arrays.asList(GroovyObject.class.getMethods()));\n        this.ignoredMethods = ImmutableSet.copyOf(Iterables.transform(ignoredMethods, new Function<Method, Equivalence.Wrapper<Method>>() {\n            public Equivalence.Wrapper<Method> apply(@Nullable Method input) {\n                return equivalence.wrap(input);\n            }\n        }));\n    }","commit_id":"2caf4077a9e8e2da40df2c80e92a19ca255cf342","url":"https://github.com/gradle/gradle"},{"original_method":"private <R, P> ModelSchemaExtractionContext<P> toPropertyExtractionContext(final ModelSchemaExtractionContext<R> parentContext, final ModelProperty<P> property, final ModelSchemaCache modelSchemaCache) {\n        return parentContext.child(property.getType(), propertyDescription(parentContext, property), new Action<ModelSchemaExtractionContext<P>>() {\n            public void execute(ModelSchemaExtractionContext<P> propertyExtractionContext) {\n                ModelSchema<P> propertySchema = modelSchemaCache.get(property.getType());\n\n                if (property.getName().equals(\"name\") && Named.class.isAssignableFrom(parentContext.getType().getRawClass())) {\n                    if (property.isWritable()) {\n                        throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                            \"@Managed types implementing %s must not declare a setter for the name property\",\n                            Named.class.getName()\n                        ));\n                    } else {\n                        return;\n                    }\n                }\n\n                if (propertySchema.getKind().isAllowedPropertyTypeOfManagedType() && property.isUnmanaged()) {\n                    throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                        \"property '%s' is marked as @Unmanaged, but is of @Managed type '%s'. Please remove the @Managed annotation.%n%s\",\n                        property.getName(), property.getType(), supportedTypeDescriptions.create()\n                    ));\n                }\n\n                if (!propertySchema.getKind().isAllowedPropertyTypeOfManagedType() && !property.isUnmanaged()) {\n                    throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                        \"type %s cannot be used for property '%s' as it is an unmanaged type (please annotate the getter with @org.gradle.model.Unmanaged if you want this property to be unmanaged).%n%s\",\n                        property.getType(), property.getName(), supportedTypeDescriptions.create()\n                    ));\n                }\n\n                if (!property.isWritable()) {\n                    if (property.isUnmanaged()) {\n                        throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                            \"unmanaged property '%s' cannot be read only, unmanaged properties must have setters\",\n                            property.getName())\n                        );\n                    }\n\n                    if (!propertySchema.getKind().isManaged()) {\n                        throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                            \"read only property '%s' has non managed type %s, only managed types can be used\",\n                            property.getName(), property.getType()));\n                    }\n                }\n\n                if (propertySchema.getKind() == ModelSchema.Kind.COLLECTION) {\n                        if (property.isWritable()) {\n                            throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                                \"property '%s' cannot have a setter (%s properties must be read only).\",\n                                property.getName(), property.getType().toString()));\n                        }\n                }\n            }\n        });\n    }","id":78934,"modified_method":"private <R, P> ModelSchemaExtractionContext<P> toPropertyExtractionContext(final ModelSchemaExtractionContext<R> parentContext, final ModelProperty<P> property, final ModelSchemaCache modelSchemaCache) {\n        return parentContext.child(property.getType(), propertyDescription(parentContext, property), new Action<ModelSchemaExtractionContext<P>>() {\n            public void execute(ModelSchemaExtractionContext<P> propertyExtractionContext) {\n                ModelSchema<P> propertySchema = modelSchemaCache.get(property.getType());\n\n                if (property.getName().equals(\"name\") && Named.class.isAssignableFrom(parentContext.getType().getRawClass())) {\n                    if (property.isWritable()) {\n                        throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                            \"@Managed types implementing %s must not declare a setter for the name property\",\n                            Named.class.getName()\n                        ));\n                    } else {\n                        return;\n                    }\n                }\n\n                if (propertySchema.getKind().isAllowedPropertyTypeOfManagedType() && property.isUnmanaged()) {\n                    throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                        \"property '%s' is marked as @Unmanaged, but is of @Managed type '%s'. Please remove the @Managed annotation.%n\",\n                        property.getName(), property.getType()\n                    ));\n                }\n\n                if (!propertySchema.getKind().isAllowedPropertyTypeOfManagedType() && !property.isUnmanaged()) {\n                    throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                        \"type %s cannot be used for property '%s' as it is an unmanaged type (please annotate the getter with @org.gradle.model.Unmanaged if you want this property to be unmanaged).%n%s\",\n                        property.getType(), property.getName(), ModelSchemaExtractor.getManageablePropertyTypesDescription()\n                    ));\n                }\n\n                if (!property.isWritable()) {\n                    if (property.isUnmanaged()) {\n                        throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                            \"unmanaged property '%s' cannot be read only, unmanaged properties must have setters\",\n                            property.getName())\n                        );\n                    }\n\n                    if (!propertySchema.getKind().isManaged()) {\n                        throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                            \"read only property '%s' has non managed type %s, only managed types can be used\",\n                            property.getName(), property.getType()));\n                    }\n                }\n\n                if (propertySchema.getKind() == ModelSchema.Kind.COLLECTION) {\n                    if (property.isWritable()) {\n                        throw new InvalidManagedModelElementTypeException(parentContext, String.format(\n                            \"property '%s' cannot have a setter (%s properties must be read only).\",\n                            property.getName(), property.getType().toString()));\n                    }\n                }\n            }\n        });\n    }","commit_id":"2caf4077a9e8e2da40df2c80e92a19ca255cf342","url":"https://github.com/gradle/gradle"},{"original_method":"private static InputStream transform(List<ResourceRootFilter> filters, FileInputStream original, Ref<File> outputFileRef, CompileContext context) {\n    return new ReaderInputStream(new ChainingFilterTransformer(context, filters, outputFileRef).transform(new InputStreamReader(original)));\n  }","id":78935,"modified_method":"private static InputStream transform(List<ResourceRootFilter> filters, FileInputStream original, Ref<File> outputFileRef, CompileContext context) {\n    final InputStreamReader streamReader = new InputStreamReader(original);\n    final Reader newReader = new ChainingFilterTransformer(context, filters, outputFileRef).transform(streamReader);\n    return streamReader == newReader ? original : new ReaderInputStream(newReader);\n  }","commit_id":"d4cef2332c4c6902f59609ff7aeb636099eda736","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Collection<Rule> byRepository(RuleQuery query) {\n    return Collections2.transform(rules.findByRepository(query.getRepositoryKey()), new Function<org.sonar.api.batch.rule.Rule, Rule>() {\n      @Override\n      public Rule apply(@Nonnull org.sonar.api.batch.rule.Rule input) {\n        return toRule(input);\n      }\n    });\n  }","id":78936,"modified_method":"private Collection<Rule> byRepository(RuleQuery query) {\n    return Collections2.transform(rules.findByRepository(query.getRepositoryKey()), RuleTransformer);\n  }","commit_id":"da4d4ce1007379c26b70e38b5acb84c8718d96df","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public List<LocationSummary> list() {\n    return Lists.newArrayList(Iterables.filter(Iterables.transform(brooklyn().getLocationRegistry().getDefinedLocations().values(),\n        new Function<LocationDefinition, LocationSummary>() {\n          @Override\n          public LocationSummary apply(LocationDefinition l) {\n              try {\n                  return LocationTransformer.newInstance(mgmt(), l, LocationDetailLevel.LOCAL_EXCLUDING_SECRET);\n              } catch (Exception e) {\n                  Exceptions.propagateIfFatal(e);\n                  String spec = l.getSpec();\n                  if (spec == null || specsWarnedOnException.add(spec)) {\n                      log.warn(\"Unable to find details of location {} in REST call to list (ignoring location): {}\", l, e);\n                      if (log.isDebugEnabled()) log.debug(\"Error details for location \"+l, e);\n                  } else {\n                      if (log.isTraceEnabled()) log.trace(\"Unable again to find details of location {} in REST call to list (ignoring location): {}\", l, e);\n                  }\n                  return null;\n              }\n          }\n        }), LocationSummary.class));\n  }","id":78937,"modified_method":"@Override\n    public List<LocationSummary> list() {\n        Function<LocationDefinition, LocationSummary> transformer = new Function<LocationDefinition, LocationSummary>() {\n            @Override\n            public LocationSummary apply(LocationDefinition l) {\n                try {\n                    return LocationTransformer.newInstance(mgmt(), l, LocationDetailLevel.LOCAL_EXCLUDING_SECRET);\n                } catch (Exception e) {\n                    Exceptions.propagateIfFatal(e);\n                    String spec = l.getSpec();\n                    if (spec == null || specsWarnedOnException.add(spec)) {\n                        log.warn(\"Unable to find details of location {} in REST call to list (ignoring location): {}\", l, e);\n                        if (log.isDebugEnabled()) log.debug(\"Error details for location \" + l, e);\n                    } else {\n                        if (log.isTraceEnabled())\n                            log.trace(\"Unable again to find details of location {} in REST call to list (ignoring location): {}\", l, e);\n                    }\n                    return null;\n                }\n            }\n        };\n        Comparator<LocationSummary> nameComparator = new Comparator<LocationSummary>() {\n            @Override\n            public int compare(LocationSummary o1, LocationSummary o2) {\n                return o1.getName().compareTo(o2.getName());\n            }\n        };\n        return FluentIterable.from(brooklyn().getLocationRegistry().getDefinedLocations().values())\n                .transform(transformer)\n                .filter(LocationSummary.class)\n                .toSortedList(nameComparator);\n    }","commit_id":"f8756e27f8781b96ab515dcc2ea0692c3717851c","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tObject source = parserContext.extractSource(element);\n\n\t\tCompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source);\n\t\tparserContext.pushContainingComponent(compDefinition);\n\n\t\tRuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, parserContext);\n\n\t\tRootBeanDefinition handlerMappingDef = new RootBeanDefinition(RequestMappingHandlerMapping.class);\n\t\thandlerMappingDef.setSource(source);\n\t\thandlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\thandlerMappingDef.getPropertyValues().add(\"order\", 0);\n\t\thandlerMappingDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\tString methodMappingName = parserContext.getReaderContext().registerWithGeneratedName(handlerMappingDef);\n\t\tif (element.hasAttribute(\"enableMatrixVariables\")) {\n\t\t\tBoolean enableMatrixVariables = Boolean.valueOf(element.getAttribute(\"enableMatrixVariables\"));\n\t\t\thandlerMappingDef.getPropertyValues().add(\"removeSemicolonContent\", !enableMatrixVariables);\n\t\t}\n\n\t\tRuntimeBeanReference conversionService = getConversionService(element, source, parserContext);\n\t\tRuntimeBeanReference validator = getValidator(element, source, parserContext);\n\t\tRuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element, source, parserContext);\n\n\t\tRootBeanDefinition bindingDef = new RootBeanDefinition(ConfigurableWebBindingInitializer.class);\n\t\tbindingDef.setSource(source);\n\t\tbindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tbindingDef.getPropertyValues().add(\"conversionService\", conversionService);\n\t\tbindingDef.getPropertyValues().add(\"validator\", validator);\n\t\tbindingDef.getPropertyValues().add(\"messageCodesResolver\", messageCodesResolver);\n\n\t\tManagedList<?> messageConverters = getMessageConverters(element, source, parserContext);\n\t\tManagedList<?> argumentResolvers = getArgumentResolvers(element, source, parserContext);\n\t\tManagedList<?> returnValueHandlers = getReturnValueHandlers(element, source, parserContext);\n\t\tString asyncTimeout = getAsyncTimeout(element, source, parserContext);\n\t\tRuntimeBeanReference asyncExecutor = getAsyncExecutor(element, source, parserContext);\n\t\tManagedList<?> callableInterceptors = getCallableInterceptors(element, source, parserContext);\n\t\tManagedList<?> deferredResultInterceptors = getDeferredResultInterceptors(element, source, parserContext);\n\n\t\tRootBeanDefinition handlerAdapterDef = new RootBeanDefinition(RequestMappingHandlerAdapter.class);\n\t\thandlerAdapterDef.setSource(source);\n\t\thandlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\thandlerAdapterDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\thandlerAdapterDef.getPropertyValues().add(\"webBindingInitializer\", bindingDef);\n\t\thandlerAdapterDef.getPropertyValues().add(\"messageConverters\", messageConverters);\n\t\tif (element.hasAttribute(\"ignoreDefaultModelOnRedirect\")) {\n\t\t\tBoolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(\"ignoreDefaultModelOnRedirect\"));\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"ignoreDefaultModelOnRedirect\", ignoreDefaultModel);\n\t\t}\n\t\tif (argumentResolvers != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"customArgumentResolvers\", argumentResolvers);\n\t\t}\n\t\tif (returnValueHandlers != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"customReturnValueHandlers\", returnValueHandlers);\n\t\t}\n\t\tif (asyncTimeout != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"asyncRequestTimeout\", asyncTimeout);\n\t\t}\n\t\tif (asyncExecutor != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"taskExecutor\", asyncExecutor);\n\t\t}\n\t\thandlerAdapterDef.getPropertyValues().add(\"callableInterceptors\", callableInterceptors);\n\t\thandlerAdapterDef.getPropertyValues().add(\"deferredResultInterceptors\", deferredResultInterceptors);\n\t\tString handlerAdapterName = parserContext.getReaderContext().registerWithGeneratedName(handlerAdapterDef);\n\n\t\tString uriCompContribName = MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;\n\t\tRootBeanDefinition uriCompContribDef = new RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);\n\t\turiCompContribDef.setSource(source);\n\t\turiCompContribDef.getPropertyValues().addPropertyValue(\"handlerAdapter\", handlerAdapterDef);\n\t\turiCompContribDef.getPropertyValues().addPropertyValue(\"conversionService\", conversionService);\n\t\tparserContext.getReaderContext().getRegistry().registerBeanDefinition(uriCompContribName, uriCompContribDef);\n\n\t\tRootBeanDefinition csInterceptorDef = new RootBeanDefinition(ConversionServiceExposingInterceptor.class);\n\t\tcsInterceptorDef.setSource(source);\n\t\tcsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, conversionService);\n\t\tRootBeanDefinition mappedCsInterceptorDef = new RootBeanDefinition(MappedInterceptor.class);\n\t\tmappedCsInterceptorDef.setSource(source);\n\t\tmappedCsInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tmappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, (Object) null);\n\t\tmappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, csInterceptorDef);\n\t\tString mappedInterceptorName = parserContext.getReaderContext().registerWithGeneratedName(mappedCsInterceptorDef);\n\n\t\tRootBeanDefinition exceptionHandlerExceptionResolver = new RootBeanDefinition(ExceptionHandlerExceptionResolver.class);\n\t\texceptionHandlerExceptionResolver.setSource(source);\n\t\texceptionHandlerExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\texceptionHandlerExceptionResolver.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\texceptionHandlerExceptionResolver.getPropertyValues().add(\"messageConverters\", messageConverters);\n\t\texceptionHandlerExceptionResolver.getPropertyValues().add(\"order\", 0);\n\t\tString methodExceptionResolverName =\n\t\t\t\tparserContext.getReaderContext().registerWithGeneratedName(exceptionHandlerExceptionResolver);\n\n\t\tRootBeanDefinition responseStatusExceptionResolver = new RootBeanDefinition(ResponseStatusExceptionResolver.class);\n\t\tresponseStatusExceptionResolver.setSource(source);\n\t\tresponseStatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tresponseStatusExceptionResolver.getPropertyValues().add(\"order\", 1);\n\t\tString responseStatusExceptionResolverName =\n\t\t\t\tparserContext.getReaderContext().registerWithGeneratedName(responseStatusExceptionResolver);\n\n\t\tRootBeanDefinition defaultExceptionResolver = new RootBeanDefinition(DefaultHandlerExceptionResolver.class);\n\t\tdefaultExceptionResolver.setSource(source);\n\t\tdefaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tdefaultExceptionResolver.getPropertyValues().add(\"order\", 2);\n\t\tString defaultExceptionResolverName =\n\t\t\t\tparserContext.getReaderContext().registerWithGeneratedName(defaultExceptionResolver);\n\n\t\tparserContext.registerComponent(new BeanComponentDefinition(handlerMappingDef, methodMappingName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(handlerAdapterDef, handlerAdapterName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(uriCompContribDef, uriCompContribName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(exceptionHandlerExceptionResolver, methodExceptionResolverName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(responseStatusExceptionResolver, responseStatusExceptionResolverName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(defaultExceptionResolver, defaultExceptionResolverName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(mappedCsInterceptorDef, mappedInterceptorName));\n\n\t\t// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not \"turned off\"\n\t\tMvcNamespaceUtils.registerDefaultComponents(parserContext, source);\n\n\t\tparserContext.popAndRegisterContainingComponent();\n\n\t\treturn null;\n\t}","id":78938,"modified_method":"@Override\n\tpublic BeanDefinition parse(Element element, ParserContext parserContext) {\n\t\tObject source = parserContext.extractSource(element);\n\n\t\tCompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source);\n\t\tparserContext.pushContainingComponent(compDefinition);\n\n\t\tRuntimeBeanReference contentNegotiationManager = getContentNegotiationManager(element, source, parserContext);\n\n\t\tRootBeanDefinition handlerMappingDef = new RootBeanDefinition(RequestMappingHandlerMapping.class);\n\t\thandlerMappingDef.setSource(source);\n\t\thandlerMappingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\thandlerMappingDef.getPropertyValues().add(\"order\", 0);\n\t\thandlerMappingDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\tString methodMappingName = parserContext.getReaderContext().registerWithGeneratedName(handlerMappingDef);\n\t\tif (element.hasAttribute(\"enable-matrix-variables\") || element.hasAttribute(\"enableMatrixVariables\")) {\n\t\t\tBoolean enableMatrixVariables = Boolean.valueOf(element.getAttribute(\n\t\t\t\t\telement.hasAttribute(\"enable-matrix-variables\") ? \"enable-matrix-variables\" : \"enableMatrixVariables\"));\n\t\t\thandlerMappingDef.getPropertyValues().add(\"removeSemicolonContent\", !enableMatrixVariables);\n\t\t}\n\n\t\tRuntimeBeanReference conversionService = getConversionService(element, source, parserContext);\n\t\tRuntimeBeanReference validator = getValidator(element, source, parserContext);\n\t\tRuntimeBeanReference messageCodesResolver = getMessageCodesResolver(element, source, parserContext);\n\n\t\tRootBeanDefinition bindingDef = new RootBeanDefinition(ConfigurableWebBindingInitializer.class);\n\t\tbindingDef.setSource(source);\n\t\tbindingDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tbindingDef.getPropertyValues().add(\"conversionService\", conversionService);\n\t\tbindingDef.getPropertyValues().add(\"validator\", validator);\n\t\tbindingDef.getPropertyValues().add(\"messageCodesResolver\", messageCodesResolver);\n\n\t\tManagedList<?> messageConverters = getMessageConverters(element, source, parserContext);\n\t\tManagedList<?> argumentResolvers = getArgumentResolvers(element, source, parserContext);\n\t\tManagedList<?> returnValueHandlers = getReturnValueHandlers(element, source, parserContext);\n\t\tString asyncTimeout = getAsyncTimeout(element, source, parserContext);\n\t\tRuntimeBeanReference asyncExecutor = getAsyncExecutor(element, source, parserContext);\n\t\tManagedList<?> callableInterceptors = getCallableInterceptors(element, source, parserContext);\n\t\tManagedList<?> deferredResultInterceptors = getDeferredResultInterceptors(element, source, parserContext);\n\n\t\tRootBeanDefinition handlerAdapterDef = new RootBeanDefinition(RequestMappingHandlerAdapter.class);\n\t\thandlerAdapterDef.setSource(source);\n\t\thandlerAdapterDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\thandlerAdapterDef.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\thandlerAdapterDef.getPropertyValues().add(\"webBindingInitializer\", bindingDef);\n\t\thandlerAdapterDef.getPropertyValues().add(\"messageConverters\", messageConverters);\n\t\tif (element.hasAttribute(\"ignore-default-model-on-redirect\") || element.hasAttribute(\"ignoreDefaultModelOnRedirect\")) {\n\t\t\tBoolean ignoreDefaultModel = Boolean.valueOf(element.getAttribute(\n\t\t\t\t\telement.hasAttribute(\"ignore-default-model-on-redirect\") ? \"ignore-default-model-on-redirect\" : \"ignoreDefaultModelOnRedirect\"));\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"ignoreDefaultModelOnRedirect\", ignoreDefaultModel);\n\t\t}\n\t\tif (argumentResolvers != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"customArgumentResolvers\", argumentResolvers);\n\t\t}\n\t\tif (returnValueHandlers != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"customReturnValueHandlers\", returnValueHandlers);\n\t\t}\n\t\tif (asyncTimeout != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"asyncRequestTimeout\", asyncTimeout);\n\t\t}\n\t\tif (asyncExecutor != null) {\n\t\t\thandlerAdapterDef.getPropertyValues().add(\"taskExecutor\", asyncExecutor);\n\t\t}\n\t\thandlerAdapterDef.getPropertyValues().add(\"callableInterceptors\", callableInterceptors);\n\t\thandlerAdapterDef.getPropertyValues().add(\"deferredResultInterceptors\", deferredResultInterceptors);\n\t\tString handlerAdapterName = parserContext.getReaderContext().registerWithGeneratedName(handlerAdapterDef);\n\n\t\tString uriCompContribName = MvcUriComponentsBuilder.MVC_URI_COMPONENTS_CONTRIBUTOR_BEAN_NAME;\n\t\tRootBeanDefinition uriCompContribDef = new RootBeanDefinition(CompositeUriComponentsContributorFactoryBean.class);\n\t\turiCompContribDef.setSource(source);\n\t\turiCompContribDef.getPropertyValues().addPropertyValue(\"handlerAdapter\", handlerAdapterDef);\n\t\turiCompContribDef.getPropertyValues().addPropertyValue(\"conversionService\", conversionService);\n\t\tparserContext.getReaderContext().getRegistry().registerBeanDefinition(uriCompContribName, uriCompContribDef);\n\n\t\tRootBeanDefinition csInterceptorDef = new RootBeanDefinition(ConversionServiceExposingInterceptor.class);\n\t\tcsInterceptorDef.setSource(source);\n\t\tcsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, conversionService);\n\t\tRootBeanDefinition mappedCsInterceptorDef = new RootBeanDefinition(MappedInterceptor.class);\n\t\tmappedCsInterceptorDef.setSource(source);\n\t\tmappedCsInterceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tmappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(0, (Object) null);\n\t\tmappedCsInterceptorDef.getConstructorArgumentValues().addIndexedArgumentValue(1, csInterceptorDef);\n\t\tString mappedInterceptorName = parserContext.getReaderContext().registerWithGeneratedName(mappedCsInterceptorDef);\n\n\t\tRootBeanDefinition exceptionHandlerExceptionResolver = new RootBeanDefinition(ExceptionHandlerExceptionResolver.class);\n\t\texceptionHandlerExceptionResolver.setSource(source);\n\t\texceptionHandlerExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\texceptionHandlerExceptionResolver.getPropertyValues().add(\"contentNegotiationManager\", contentNegotiationManager);\n\t\texceptionHandlerExceptionResolver.getPropertyValues().add(\"messageConverters\", messageConverters);\n\t\texceptionHandlerExceptionResolver.getPropertyValues().add(\"order\", 0);\n\t\tString methodExceptionResolverName =\n\t\t\t\tparserContext.getReaderContext().registerWithGeneratedName(exceptionHandlerExceptionResolver);\n\n\t\tRootBeanDefinition responseStatusExceptionResolver = new RootBeanDefinition(ResponseStatusExceptionResolver.class);\n\t\tresponseStatusExceptionResolver.setSource(source);\n\t\tresponseStatusExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tresponseStatusExceptionResolver.getPropertyValues().add(\"order\", 1);\n\t\tString responseStatusExceptionResolverName =\n\t\t\t\tparserContext.getReaderContext().registerWithGeneratedName(responseStatusExceptionResolver);\n\n\t\tRootBeanDefinition defaultExceptionResolver = new RootBeanDefinition(DefaultHandlerExceptionResolver.class);\n\t\tdefaultExceptionResolver.setSource(source);\n\t\tdefaultExceptionResolver.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\n\t\tdefaultExceptionResolver.getPropertyValues().add(\"order\", 2);\n\t\tString defaultExceptionResolverName =\n\t\t\t\tparserContext.getReaderContext().registerWithGeneratedName(defaultExceptionResolver);\n\n\t\tparserContext.registerComponent(new BeanComponentDefinition(handlerMappingDef, methodMappingName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(handlerAdapterDef, handlerAdapterName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(uriCompContribDef, uriCompContribName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(exceptionHandlerExceptionResolver, methodExceptionResolverName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(responseStatusExceptionResolver, responseStatusExceptionResolverName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(defaultExceptionResolver, defaultExceptionResolverName));\n\t\tparserContext.registerComponent(new BeanComponentDefinition(mappedCsInterceptorDef, mappedInterceptorName));\n\n\t\t// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not \"turned off\"\n\t\tMvcNamespaceUtils.registerDefaultComponents(parserContext, source);\n\n\t\tparserContext.popAndRegisterContainingComponent();\n\n\t\treturn null;\n\t}","commit_id":"5e02a6dda37ba6ff3b2025a1b2a6200c49cdcdaf","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void testCustomValidator() throws Exception {\n\t\tloadBeanDefinitions(\"mvc-config-custom-validator.xml\", 13);\n\n\t\tRequestMappingHandlerMapping mapping = appContext.getBean(RequestMappingHandlerMapping.class);\n\t\tassertNotNull(mapping);\n\t\tassertFalse(mapping.getUrlPathHelper().shouldRemoveSemicolonContent());\n\n\t\tRequestMappingHandlerAdapter adapter = appContext.getBean(RequestMappingHandlerAdapter.class);\n\t\tassertNotNull(adapter);\n\t\tassertEquals(true, new DirectFieldAccessor(adapter).getPropertyValue(\"ignoreDefaultModelOnRedirect\"));\n\n\t\t// default web binding initializer behavior test\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.addParameter(\"date\", \"2009-10-31\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\tadapter.handle(request, response, handlerMethod);\n\n\t\tassertTrue(appContext.getBean(TestValidator.class).validatorInvoked);\n\t\tassertFalse(handler.recordedValidationError);\n\t}","id":78939,"modified_method":"@Test\n\tpublic void testCustomValidator() throws Exception {\n\t\tdoTestCustomValidator(\"mvc-config-custom-validator.xml\");\n\t}","commit_id":"5e02a6dda37ba6ff3b2025a1b2a6200c49cdcdaf","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n  protected void doUpdatePresentation() {\n    Kind kind = myTracerNode.getKind();\n    SNodeReference nodePointer = myTracerNode.getNodePointer();\n    if (nodePointer != null) {\n      if (kind == Kind.APPROXIMATE_OUTPUT || kind == Kind.APPROXIMATE_INPUT) {\n        setText(\"[approximate location] \" + nodePointer.toString());\n      } else {\n        setText(nodePointer.toString());\n      }\n      setAdditionalText(\"\" + nodePointer.getModelReference().getModelName());\n    } else {\n      setText(\"<\" + kind + \">\");\n    }\n    setAutoExpandable(getChildCount() == 1);\n  }","id":78940,"modified_method":"@Override\n  protected void doUpdatePresentation() {\n    Kind kind = myTracerNode.getKind();\n    SNodeReference nodePointer = myTracerNode.getNodePointer();\n    if (nodePointer != null) {\n      if (kind == Kind.APPROXIMATE_OUTPUT || kind == Kind.APPROXIMATE_INPUT) {\n        setText(\"[approximate location] \" + nodePointer.toString());\n      } else {\n        setText(nodePointer.toString());\n      }\n      SModelReference modelRef = nodePointer.getModelReference();\n      if (modelRef != null) {\n        setAdditionalText(modelRef.getModelName());\n      }\n    } else {\n      setText(\"<\" + kind + \">\");\n    }\n    setAutoExpandable(getChildCount() == 1);\n  }","commit_id":"112f1e95f031b8d755da76b5cf29fabf34bf94de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String getModelName() {\n    return myNodeResult.getModelReference().getSModelFqName().toString();\n  }","id":78941,"modified_method":"public String getModelName() {\n    SModelReference mr = myNodeResult.getModelReference();\n    SModelFqName modelFqName = mr.getSModelFqName();\n    if (modelFqName!=null) return modelFqName.toString();\n    return SModelRepository.getInstance().getModelDescriptor(mr).getLongName();\n  }","commit_id":"312e4cc1ce08302142cd8fd025cbc1707b3968e3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected void doUpdateModelImport(SRepository repository, final SNode containingNode, final SReferenceLink role, SNodeReference newTarget) {\n    super.doUpdateModelImport(repository, containingNode, role, newTarget);\n    if (eq_m5uax2_a0a1a7(role, MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xf979be93cfL, \"extends\")) || eq_m5uax2_a0a1a7_0(role, MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x110356fc618L, 0x110356fe029L, \"intfc\"))) {\n      ((Language) containingNode.getModel().getModule()).addExtendedLanguage(newTarget.getModelReference().getModuleReference());\n    }\n  }","id":78942,"modified_method":"@Override\n  protected void doUpdateModelImport(SRepository repository, final SNode containingNode, final SReferenceLink role, SNodeReference newTarget) {\n    super.doUpdateModelImport(repository, containingNode, role, newTarget);\n    if (eq_m5uax2_a0a1a7(role, MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979ba0450L, 0xf979be93cfL, \"extends\")) || eq_m5uax2_a0a1a7_0(role, MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x110356fc618L, 0x110356fe029L, \"intfc\"))) {\n      SModule targetLanguage = check_m5uax2_a0a0b0h(check_m5uax2_a0a0a1a7(newTarget.getModelReference(), repository));\n      Language sourceLanguage = (Language) check_m5uax2_a0a1a1a7(containingNode.getModel());\n      if (sourceLanguage != null && targetLanguage != null) {\n        sourceLanguage.addExtendedLanguage(targetLanguage.getModuleReference());\n      }\n    }\n  }","commit_id":"867981396992753ec234d6ae846a1ec13e1568e1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<NamedNodeReference, NamedNodeReference> getDataCollector() {\n    return new UpdateReferencesParticipant.MyMoveNodeRefactoringDataCollector() {\n      @Override\n      public NamedNodeReference beforeMove(SNode nodeToMove) {\n        if (!(SNodeOperations.isInstanceOf(nodeToMove, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) || !(nodeToMove.getModel().getModule() instanceof Language)) {\n          return null;\n        }\n        return super.beforeMove(nodeToMove);\n      }\n      @Override\n      public NamedNodeReference afterMove(SNode movedNode) {\n        return super.afterMove(movedNode);\n      }\n    };\n  }","id":78943,"modified_method":"@Override\n  public MoveNodeRefactoringParticipant.MoveNodeRefactoringDataCollector<NamedNodeReference, NamedNodeReference> getDataCollector() {\n    return new UpdateReferencesParticipant.MyMoveNodeRefactoringDataCollector() {\n      @Override\n      public NamedNodeReference beforeMove(SNode nodeToMove) {\n        if (!(SNodeOperations.isInstanceOf(nodeToMove, MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\"))) || !(check_m5uax2_a0a0a0a0a0a0j(nodeToMove.getModel()) instanceof Language)) {\n          return null;\n        }\n        return super.beforeMove(nodeToMove);\n      }\n      @Override\n      public NamedNodeReference afterMove(SNode movedNode) {\n        return super.afterMove(movedNode);\n      }\n    };\n  }","commit_id":"867981396992753ec234d6ae846a1ec13e1568e1","url":"https://github.com/JetBrains/MPS"},{"original_method":"public FactHandle getFactHandle(Object object) {\n        return new FactHandleAdapter(delegate.getFactHandle(object));\n    }","id":78944,"modified_method":"public FactHandle getFactHandle(Object object) {\n        org.kie.api.runtime.rule.FactHandle factHandle = delegate.getFactHandle(object);\n        return factHandle != null ? new FactHandleAdapter(factHandle) : null;\n    }","commit_id":"386dce1443e8404a077e9942f742a2c06cdd87f7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public FactHandle getFactHandle(Object object) {\n        return new FactHandleAdapter(delegate.getFactHandle(object));\n    }","id":78945,"modified_method":"public FactHandle getFactHandle(Object object) {\n        org.kie.api.runtime.rule.FactHandle factHandle = delegate.getFactHandle(object);\n        return factHandle != null ? new FactHandleAdapter(factHandle) : null;\n    }","commit_id":"386dce1443e8404a077e9942f742a2c06cdd87f7","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void propertyChange(final PropertyChangeEvent event) {\r\n        final Object object = event.getSource();\r\n\r\n        try {\r\n            update( getFactHandle( object ),\r\n                    object );\r\n        } catch ( final FactException e ) {\r\n            throw new RuntimeException( e.getMessage() );\r\n        }\r\n    }","id":78946,"modified_method":"public void propertyChange(final PropertyChangeEvent event) {\r\n        final Object object = event.getSource();\r\n\r\n        try {\r\n            FactHandle handle = getFactHandle( object );\r\n            if ( handle == null ) {\r\n                throw new FactException( \"Update error: handle not found for object: \" + object + \". Is it in the working memory?\" );\r\n            }\r\n            update( handle,\r\n                    object );\r\n        } catch ( final FactException e ) {\r\n            throw new RuntimeDroolsException( e.getMessage() );\r\n        }\r\n    }","commit_id":"e8fe1de9a0778a858689b303fd4564bd1fa066e8","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * Returns a stream to the <em>jcr:data<\/em> property if the\n     * {@link #getNode() node} is an <em>nt:file<\/em> or <em>nt:resource<\/em>\n     * node. Otherwise returns <code>null<\/code>. If a valid stream can be\n     * returned, this method also sets the content length resource metadata.\n     */\n    private InputStream getInputStream() {\n        // implement this for nt:file only\n        if (node != null) {\n            try {\n                // find the content node: for nt:file it is jcr:content\n                // otherwise it is the node of this resource\n                Node content = node.isNodeType(NT_FILE)\n                        ? node.getNode(JCR_CONTENT)\n                        : node;\n\n                Property data;\n\n                // if the node has a jcr:data property, use that property\n                if (content.hasProperty(JCR_DATA)) {\n                    data = content.getProperty(JCR_DATA);\n\n                } else {\n\n                    // otherwise try to follow default item trail\n                    try {\n                        Item item = content.getPrimaryItem();\n                        while (item.isNode()) {\n                            item = ((Node) item).getPrimaryItem();\n                        }\n                        data = ((Property) item);\n                    } catch (ItemNotFoundException infe) {\n                        // we don't actually care, but log for completeness\n                        LOGGER.debug(\"getInputStream: No primary items for \"\n                            + toString(), infe);\n                        data = null;\n                    }\n                }\n\n                if (data != null) {\n                    // we set the content length only if the input stream is\n                    // fetched. otherwise the repository needs to load the\n                    // binary property which could cause performance loss\n                    // for all resources that do need to provide the stream\n                    long length = data.getLength();\n                    InputStream stream = data.getStream();\n\n                    getResourceMetadata().setContentLength(length);\n                    return stream;\n                }\n\n            } catch (RepositoryException re) {\n                LOGGER.error(\"getInputStream: Cannot get InputStream for \" + this,\n                    re);\n            }\n        }\n\n        // fallback to non-streamable resource\n        return null;\n    }","id":78947,"modified_method":"/**\n     * Returns a stream to the <em>jcr:data<\/em> property if the\n     * {@link #getNode() node} is an <em>nt:file<\/em> or <em>nt:resource<\/em>\n     * node. Otherwise returns <code>null<\/code>. If a valid stream can be\n     * returned, this method also sets the content length resource metadata.\n     */\n    private InputStream getInputStream() {\n        // implement this for nt:file only\n        if (node != null) {\n            try {\n                // find the content node: for nt:file it is jcr:content\n                // otherwise it is the node of this resource\n                Node content = node.isNodeType(NT_FILE)\n                        ? node.getNode(JCR_CONTENT)\n                        : node;\n\n                Property data;\n\n                // if the node has a jcr:data property, use that property\n                if (content.hasProperty(JCR_DATA)) {\n                    data = content.getProperty(JCR_DATA);\n\n                } else {\n\n                    // otherwise try to follow default item trail\n                    try {\n                        Item item = content.getPrimaryItem();\n                        while (item.isNode()) {\n                            item = ((Node) item).getPrimaryItem();\n                        }\n                        data = ((Property) item);\n\n                        // set the content lenght property as a side effect\n                        // for resources which are not nt:file based and whose\n                        // data is not in jcr:content/jcr:data this will lazily\n                        // set the correct content length\n                        getResourceMetadata().setContentLength(data.getLength());\n\n                    } catch (ItemNotFoundException infe) {\n                        // we don't actually care, but log for completeness\n                        LOGGER.debug(\"getInputStream: No primary items for \"\n                            + toString(), infe);\n                        data = null;\n                    }\n                }\n\n                if (data != null) {\n                    return data.getStream();\n                }\n\n            } catch (RepositoryException re) {\n                LOGGER.error(\"getInputStream: Cannot get InputStream for \" + this,\n                    re);\n            }\n        }\n\n        // fallback to non-streamable resource\n        return null;\n    }","commit_id":"64f3c320cfc07a7f3b61970910bb2da06bd1afd2","url":"https://github.com/apache/sling"},{"original_method":"private void setMetaData(Node node, ResourceMetadata metadata) {\n        try {\n\n            // check stuff for nt:file nodes\n            if (node.isNodeType(NT_FILE)) {\n                metadata.setCreationTime(node.getProperty(JCR_CREATED).getLong());\n\n                // continue our stuff with the jcr:content node\n                // which might be nt:resource, which we support below\n                node = node.getNode(JCR_CONTENT);\n            }\n\n            // check stuff for nt:resource (or similar) nodes\n            if (node.hasProperty(JCR_MIMETYPE)) {\n                metadata.setContentType(node.getProperty(JCR_MIMETYPE).getString());\n            }\n\n            if (node.hasProperty(JCR_ENCODING)) {\n                metadata.setCharacterEncoding(node.getProperty(JCR_ENCODING).getString());\n            }\n\n            if (node.hasProperty(JCR_LASTMODIFIED)) {\n                // We don't check node type, so JCR_LASTMODIFIED might not be a long\n                final Property prop = node.getProperty(JCR_LASTMODIFIED);\n                try {\n                    metadata.setModificationTime(prop.getLong());\n                } catch(ValueFormatException vfe) {\n                    LOGGER.debug(\"Property {} cannot be converted to a long, ignored ({})\",\n                            prop.getPath(), vfe);\n                }\n            }\n        } catch (RepositoryException re) {\n            LOGGER.info(\n                \"setMetaData: Problem extracting metadata information for \"\n                    + getPath(), re);\n        }\n    }","id":78948,"modified_method":"private void setMetaData(Node node, ResourceMetadata metadata) {\n        try {\n\n            // check stuff for nt:file nodes\n            if (node.isNodeType(NT_FILE)) {\n                metadata.setCreationTime(node.getProperty(JCR_CREATED).getLong());\n\n                // continue our stuff with the jcr:content node\n                // which might be nt:resource, which we support below\n                node = node.getNode(JCR_CONTENT);\n            }\n\n            // check stuff for nt:resource (or similar) nodes\n            if (node.hasProperty(JCR_MIMETYPE)) {\n                metadata.setContentType(node.getProperty(JCR_MIMETYPE).getString());\n            }\n\n            if (node.hasProperty(JCR_ENCODING)) {\n                metadata.setCharacterEncoding(node.getProperty(JCR_ENCODING).getString());\n            }\n\n            if (node.hasProperty(JCR_LASTMODIFIED)) {\n                // We don't check node type, so JCR_LASTMODIFIED might not be a long\n                final Property prop = node.getProperty(JCR_LASTMODIFIED);\n                try {\n                    metadata.setModificationTime(prop.getLong());\n                } catch(ValueFormatException vfe) {\n                    LOGGER.debug(\"Property {} cannot be converted to a long, ignored ({})\",\n                            prop.getPath(), vfe);\n                }\n            }\n\n            if (node.hasProperty(JCR_DATA)) {\n                final Property prop = node.getProperty(JCR_DATA);\n                try {\n                    metadata.setContentLength(prop.getLength());\n                } catch (ValueFormatException vfe) {\n                    LOGGER.debug(\n                        \"Length of Property {} cannot be retrieved, ignored ({})\",\n                        prop.getPath(), vfe);\n                }\n            }\n        } catch (RepositoryException re) {\n            LOGGER.info(\n                \"setMetaData: Problem extracting metadata information for \"\n                    + getPath(), re);\n        }\n    }","commit_id":"64f3c320cfc07a7f3b61970910bb2da06bd1afd2","url":"https://github.com/apache/sling"},{"original_method":"private InputStream getInputStream() {\n        Property prop = getProperty();\n\n        try {\n            // we set the content length only if the input stream is\n            // fetched. otherwise the repository needs to load the\n            // binary property which could cause performance loss\n            // for all resources that do need to provide the stream\n            long length = prop.getLength();\n            InputStream stream =  prop.getStream();\n\n            getResourceMetadata().setContentLength(length);\n            return stream;\n        } catch (RepositoryException re) {\n            LOGGER.error(\"getInputStream: Problem accessing the property \"\n                + getPath() + \" stream\", re);\n        }\n\n        // fall back to none in case of an error\n        return null;\n    }","id":78949,"modified_method":"private InputStream getInputStream() {\n        Property prop = getProperty();\n\n        try {\n            return prop.getStream();\n        } catch (RepositoryException re) {\n            LOGGER.error(\"getInputStream: Problem accessing the property \"\n                + getPath() + \" stream\", re);\n        }\n\n        // fall back to none in case of an error\n        return null;\n    }","commit_id":"64f3c320cfc07a7f3b61970910bb2da06bd1afd2","url":"https://github.com/apache/sling"},{"original_method":"public JcrPropertyResource(ResourceResolver resourceResolver,\n                               String path,\n                               Property property)\n    throws RepositoryException {\n        super(resourceResolver, path);\n        this.property = property;\n        this.resourceType = getResourceTypeForNode(property.getParent())\n            + \"/\" + property.getName();\n    }","id":78950,"modified_method":"public JcrPropertyResource(ResourceResolver resourceResolver,\n                               String path,\n                               Property property)\n    throws RepositoryException {\n        super(resourceResolver, path);\n        this.property = property;\n        this.resourceType = getResourceTypeForNode(property.getParent())\n            + \"/\" + property.getName();\n        this.getResourceMetadata().setContentLength(property.getLength());\n    }","commit_id":"64f3c320cfc07a7f3b61970910bb2da06bd1afd2","url":"https://github.com/apache/sling"},{"original_method":"public InputStream getFileAsStream(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tInputStream is = null;\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode contentNode = getFileContentNode(\n\t\t\t\tsession, companyId, repositoryId, fileName, versionNumber);\n\n\t\t\tProperty property = contentNode.getProperty(JCRConstants.JCR_DATA);\n\n\t\t\tValue value = property.getValue();\n\n\t\t\tBinary binary = value.getBinary();\n\n\t\t\tis = new UnsyncBufferedInputStream(binary.getStream());\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\n\t\treturn is;\n\t}","id":78951,"modified_method":"public InputStream getFileAsStream(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber)\n\t\tthrows PortalException, SystemException {\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = JCRFactoryUtil.createSession();\n\n\t\t\tNode contentNode = getFileContentNode(\n\t\t\t\tsession, companyId, repositoryId, fileName, versionNumber);\n\n\t\t\tProperty property = contentNode.getProperty(JCRConstants.JCR_DATA);\n\n\t\t\tValue value = property.getValue();\n\n\t\t\tBinary binary = value.getBinary();\n\n\t\t\treturn binary.getStream();\n\t\t}\n\t\tcatch (RepositoryException re) {\n\t\t\tthrow new SystemException(re);\n\t\t}\n\t\tfinally {\n\t\t\tif (session != null) {\n\t\t\t\tsession.logout();\n\t\t\t}\n\t\t}\n\t}","commit_id":"a5ecea0051a1b1c63a33bb4bb6d8d2d553579f18","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private boolean isBestValueOptimized(Measure measure) {\n    return measure.getDescription() == null\n      && measure.getData() == null\n      && !measure.hasQualityGateStatus()\n      && hasNoVariation(measure)\n      && (measure.getValueType() == NO_VALUE || isBestValue(measure, metric.getBestValue()));\n  }","id":78952,"modified_method":"private boolean isBestValueOptimized(Measure measure) {\n    return measure.getDescription() == null\n      && measure.getData() == null\n      && !measure.hasQualityGateStatus()\n      && hasNoVariation(measure, metric.getBestValue())\n      && (measure.getValueType() == NO_VALUE || isBestValue(measure, metric.getBestValue()));\n  }","commit_id":"e3e705b429b415a842f3a1abab7c902c19351d19","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static boolean hasOnlyZeroVariations(MeasureVariations variations) {\n    return (!variations.hasVariation1() || NumberUtils.compare(variations.getVariation1(), 0.0) == 0)\n      && (!variations.hasVariation2() || NumberUtils.compare(variations.getVariation2(), 0.0) == 0)\n      && (!variations.hasVariation3() || NumberUtils.compare(variations.getVariation3(), 0.0) == 0)\n      && (!variations.hasVariation4() || NumberUtils.compare(variations.getVariation4(), 0.0) == 0)\n      && (!variations.hasVariation5() || NumberUtils.compare(variations.getVariation5(), 0.0) == 0);\n  }","id":78953,"modified_method":"private static boolean hasOnlyZeroVariations(MeasureVariations variations, Double bestValue) {\n    return (!variations.hasVariation1() || isVariationEmptyOrBestValue(variations.getVariation1(), bestValue))\n      && (!variations.hasVariation2() || isVariationEmptyOrBestValue(variations.getVariation2(), bestValue))\n      && (!variations.hasVariation3() || isVariationEmptyOrBestValue(variations.getVariation3(), bestValue))\n      && (!variations.hasVariation4() || isVariationEmptyOrBestValue(variations.getVariation4(), bestValue))\n      && (!variations.hasVariation5() || isVariationEmptyOrBestValue(variations.getVariation5(), bestValue));\n  }","commit_id":"e3e705b429b415a842f3a1abab7c902c19351d19","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static boolean hasNoVariation(Measure measure) {\n    return !measure.hasVariations() || hasOnlyZeroVariations(measure.getVariations());\n  }","id":78954,"modified_method":"private static boolean hasNoVariation(Measure measure, Double bestValue) {\n    return !measure.hasVariations() || hasOnlyZeroVariations(measure.getVariations(), bestValue);\n  }","commit_id":"e3e705b429b415a842f3a1abab7c902c19351d19","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static Measure.NewMeasureBuilder[] builders_of_non_bestValueOptimized_measures() {\n    QualityGateStatus someQualityGateStatus = new QualityGateStatus(Measure.Level.ERROR, null);\n    MeasureVariations someVariations = new MeasureVariations(1d);\n    String someDescription = \"desc\";\n    return new Measure.NewMeasureBuilder[] {\n      newMeasureBuilder().setQualityGateStatus(someQualityGateStatus),\n      newMeasureBuilder().setQualityGateStatus(someQualityGateStatus).setVariations(someVariations),\n      newMeasureBuilder().setVariations(someVariations),\n      newMeasureBuilder().setQualityGateStatus(someQualityGateStatus).setDescription(someDescription),\n      newMeasureBuilder().setDescription(someDescription),\n      newMeasureBuilder().setQualityGateStatus(someQualityGateStatus).setVariations(someVariations).setDescription(someDescription),\n    };\n  }","id":78955,"modified_method":"public static Measure.NewMeasureBuilder[] builders_of_non_bestValueOptimized_measures() {\n    QualityGateStatus someQualityGateStatus = new QualityGateStatus(Measure.Level.ERROR, null);\n    MeasureVariations someVariations = new MeasureVariations(2d);\n    String someDescription = \"desc\";\n    return new Measure.NewMeasureBuilder[] {\n      newMeasureBuilder().setQualityGateStatus(someQualityGateStatus),\n      newMeasureBuilder().setQualityGateStatus(someQualityGateStatus).setVariations(someVariations),\n      newMeasureBuilder().setVariations(someVariations),\n      newMeasureBuilder().setQualityGateStatus(someQualityGateStatus).setDescription(someDescription),\n      newMeasureBuilder().setDescription(someDescription),\n      newMeasureBuilder().setQualityGateStatus(someQualityGateStatus).setVariations(someVariations).setDescription(someDescription),\n    };\n  }","commit_id":"e3e705b429b415a842f3a1abab7c902c19351d19","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"MetricDtoWithBestValue(MetricDto metric, List<Integer> periodIndexes) {\n    this.metric = metric;\n    MeasureDto measure = new MeasureDto().setMetricId(metric.getId());\n    boolean isNewTypeMetric = metric.getKey().toLowerCase(Locale.ENGLISH).startsWith(LOWER_CASE_NEW_METRIC_PREFIX);\n    if (isNewTypeMetric) {\n      for (Integer periodIndex : periodIndexes) {\n        measure.setVariation(periodIndex, 0.0d);\n      }\n    } else {\n      measure.setValue(metric.getBestValue());\n    }\n\n    this.bestValue = measure;\n  }","id":78956,"modified_method":"MetricDtoWithBestValue(MetricDto metric, List<Integer> periodIndexes) {\n    this.metric = metric;\n    MeasureDto measure = new MeasureDto().setMetricId(metric.getId());\n    boolean isNewTypeMetric = metric.getKey().toLowerCase(Locale.ENGLISH).startsWith(LOWER_CASE_NEW_METRIC_PREFIX);\n    if (isNewTypeMetric) {\n      for (Integer periodIndex : periodIndexes) {\n        measure.setVariation(periodIndex, metric.getBestValue());\n      }\n    } else {\n      measure.setValue(metric.getBestValue());\n    }\n\n    this.bestValue = measure;\n  }","commit_id":"e3e705b429b415a842f3a1abab7c902c19351d19","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    final int K = 1<<16;\n    for (Double d : new Double[]{3.14159265358, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.MAX_VALUE, Double.NaN}) {\n      NewChunk nc = new NewChunk(null, 0);\n      for (int i=0;i<K;++i) nc.addNum(d);\n      Assert.assertEquals(K, nc.len());\n      Assert.assertEquals(K, nc.sparseLen());\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(K, cc.len());\n      Assert.assertTrue(cc instanceof C0DChunk);\n      for (int i=0;i<K;++i) Assert.assertEquals(d, cc.at0(i), 0);\n      for (int i=0;i<K;++i) Assert.assertEquals(d, cc.at(i), 0);\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(K, cc2.len());\n      Assert.assertTrue(cc2 instanceof C0DChunk);\n      for (int i=0;i<K;++i) Assert.assertEquals(d, cc2.at0(i), 0);\n      for (int i=0;i<K;++i) Assert.assertEquals(d, cc2.at(i), 0);\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78957,"modified_method":"@Test\n  public void test_inflate_impl() {\n    final int K = 1<<16;\n    for (Double d : new Double[]{3.14159265358, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.MAX_VALUE, Double.NaN}) {\n      NewChunk nc = new NewChunk(null, 0);\n      for (int i=0;i<K;++i) nc.addNum(d);\n      Assert.assertEquals(K, nc.len());\n      Assert.assertEquals(K, nc.sparseLen());\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(K, cc.len());\n      Assert.assertTrue(cc instanceof C0DChunk);\n      for (int i=0;i<K;++i) Assert.assertEquals(d, cc.at0(i), 0);\n      for (int i=0;i<K;++i) Assert.assertEquals(d, cc.at(i), 0);\n\n      nc = cc.inflate_impl(new NewChunk(null, 0));\n      Assert.assertEquals(K, nc.len());\n      Assert.assertEquals(K, nc.sparseLen());\n      for (int i=0;i<K;++i) Assert.assertEquals(d, nc.at0(i), 0);\n      for (int i=0;i<K;++i) Assert.assertEquals(d, nc.at(i), 0);\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(K, cc2.len());\n      Assert.assertTrue(cc2 instanceof C0DChunk);\n      for (int i=0;i<K;++i) Assert.assertEquals(d, cc2.at0(i), 0);\n      for (int i=0;i<K;++i) Assert.assertEquals(d, cc2.at(i), 0);\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    final int K = 1<<18;\n    for (long l : new long[]{Long.MIN_VALUE, Long.MAX_VALUE, 23420384l, 0l, -23423423400023l}) {\n      NewChunk nc = new NewChunk(null, 0);\n      for (int i=0;i<K;++i) nc.addNum(l,0);\n      Assert.assertEquals(K, nc.len());\n      if (l != 0l) Assert.assertEquals(l == 0l ? 0 : K, nc.sparseLen()); //special case for sparse length\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(K, cc.len());\n      Assert.assertTrue(cc instanceof C0LChunk);\n      for (int i=0;i<K;++i) Assert.assertEquals(l, cc.at80(i));\n\n      nc = new NewChunk(null, 0);\n      cc.inflate_impl(nc);\n      Assert.assertEquals(K, nc.len());\n      if (l != 0l) Assert.assertEquals(l == 0l ? 0 : K, nc.len()); //special case for sparse length\n\n      Iterator<NewChunk.Value> it = nc.values(0, K);\n      if (l != 0l) { //if all 0s, then we're already at end\n        for (int i = 0; i < K; ++i) Assert.assertTrue(it.next().rowId0() == i);\n      }\n      Assert.assertTrue(!it.hasNext());\n      for (int i = 0; i < K; ++i) Assert.assertEquals(l, nc.at80(i));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(K, cc2.len());\n      Assert.assertTrue(cc2 instanceof C0LChunk);\n      for (int i=0;i<K;++i) Assert.assertEquals(l, cc2.at80(i));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78958,"modified_method":"@Test\n  public void test_inflate_impl() {\n    final int K = 1<<18;\n    for (long l : new long[]{Long.MIN_VALUE, Long.MAX_VALUE, 23420384l, 0l, -23423423400023l}) {\n      NewChunk nc = new NewChunk(null, 0);\n      for (int i=0;i<K;++i) nc.addNum(l,0);\n      Assert.assertEquals(K, nc.len());\n      if (l != 0l) Assert.assertEquals(l == 0l ? 0 : K, nc.sparseLen()); //special case for sparse length\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(K, cc.len());\n      Assert.assertTrue(cc instanceof C0LChunk);\n      for (int i=0;i<K;++i) Assert.assertEquals(l, cc.at80(i));\n\n      nc = new NewChunk(null, 0);\n      cc.inflate_impl(nc);\n      Assert.assertEquals(K, nc.len());\n      Assert.assertEquals(l == 0 ? 0 : K, nc.sparseLen());\n\n      Iterator<NewChunk.Value> it = nc.values(0, K);\n      if (l != 0l) { //if all 0s, then we're already at end\n        for (int i = 0; i < K; ++i) Assert.assertTrue(it.next().rowId0() == i);\n      }\n      Assert.assertTrue(!it.hasNext());\n      for (int i = 0; i < K; ++i) Assert.assertEquals(l, nc.at80(i));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(K, cc2.len());\n      Assert.assertTrue(cc2 instanceof C0LChunk);\n      for (int i=0;i<K;++i) Assert.assertEquals(l, cc2.at80(i));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      int[] vals = new int[]{0, 1, 3, 254};\n      if (l==1) nc.addNA();\n      for (int v : vals) nc.addNum(v, 0);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C1Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n      Assert.assertTrue(cc.isNA(vals.length+l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C1Chunk);\n      if (l==1) Assert.assertTrue(cc2.isNA0(0));\n      if (l==1) Assert.assertTrue(cc2.isNA(0));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at8(l+i));\n      Assert.assertTrue(cc2.isNA0(vals.length+l));\n      Assert.assertTrue(cc2.isNA(vals.length+l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78959,"modified_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      int[] vals = new int[]{0, 1, 3, 254};\n      if (l==1) nc.addNA();\n      for (int v : vals) nc.addNum(v, 0);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C1Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n      Assert.assertTrue(cc.isNA(vals.length+l));\n\n      nc = new NewChunk(null, 0);\n      cc.inflate_impl(nc);\n      if (l==1) Assert.assertTrue(cc.isNA0(0));\n      Assert.assertEquals(vals.length+l+1, nc.sparseLen());\n      Assert.assertEquals(vals.length+l+1, nc.len());\n      Iterator<NewChunk.Value> it = nc.values(0, vals.length+1+l);\n      for (int i = 0; i < vals.length+1+l; ++i) Assert.assertTrue(it.next().rowId0() == i);\n      Assert.assertTrue(!it.hasNext());\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], nc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], nc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C1Chunk);\n      if (l==1) Assert.assertTrue(cc2.isNA0(0));\n      if (l==1) Assert.assertTrue(cc2.isNA(0));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at8(l+i));\n      Assert.assertTrue(cc2.isNA0(vals.length+l));\n      Assert.assertTrue(cc2.isNA(vals.length+l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    NewChunk nc = new NewChunk(null, 0);\n\n    int[] vals = new int[]{0,1,3,254};\n    for (int v : vals) nc.addNum(v,0);\n\n    Chunk cc = nc.compress();\n    Assert.assertEquals(vals.length, cc.len());\n    Assert.assertTrue(cc instanceof C1NChunk);\n    for (int i=0;i<vals.length;++i) Assert.assertEquals(vals[i], cc.at80(i));\n    for (int i=0;i<vals.length;++i) Assert.assertEquals(vals[i], cc.at8(i));\n\n    Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n    Assert.assertEquals(vals.length, cc.len());\n    Assert.assertTrue(cc2 instanceof C1NChunk);\n    for (int i=0;i<vals.length;++i) Assert.assertEquals(vals[i], cc2.at80(i));\n    for (int i=0;i<vals.length;++i) Assert.assertEquals(vals[i], cc2.at8(i));\n\n    Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n  }","id":78960,"modified_method":"@Test\n  public void test_inflate_impl() {\n    NewChunk nc = new NewChunk(null, 0);\n\n    int[] vals = new int[]{0,1,3,254};\n    for (int v : vals) nc.addNum(v,0);\n\n    Chunk cc = nc.compress();\n    Assert.assertEquals(vals.length, cc.len());\n    Assert.assertTrue(cc instanceof C1NChunk);\n    for (int i=0;i<vals.length;++i) Assert.assertEquals(vals[i], cc.at80(i));\n    for (int i=0;i<vals.length;++i) Assert.assertEquals(vals[i], cc.at8(i));\n\n    nc = cc.inflate_impl(new NewChunk(null, 0));\n    Assert.assertEquals(vals.length, nc.len());\n    Assert.assertEquals(vals.length, nc.sparseLen());\n    for (int i=0;i<vals.length;++i) Assert.assertEquals(vals[i], nc.at80(i));\n    for (int i=0;i<vals.length;++i) Assert.assertEquals(vals[i], nc.at8(i));\n\n    Chunk cc2 = nc.compress();\n    Assert.assertEquals(vals.length, cc.len());\n    Assert.assertTrue(cc2 instanceof C1NChunk);\n    for (int i=0;i<vals.length;++i) Assert.assertEquals(vals[i], cc2.at80(i));\n    for (int i=0;i<vals.length;++i) Assert.assertEquals(vals[i], cc2.at8(i));\n\n    Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n      // 0, 0.2, 0.3, 2.54, NA for l==0\n      // NA, 0, 0.2, 0.3, 2.54, NA for l==1\n      long[] man = new long[]{0, 2, 3, 254};\n      int[] exp = new int[]{1, -1, -1, -2};\n      if (l==1) nc.addNA();\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C1SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc.isNA0(0));\n        Assert.assertTrue(cc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at(l + i), 0);\n      }\n      Assert.assertTrue(cc.isNA0(man.length + l));\n      Assert.assertTrue(cc.isNA(man.length + l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C1SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc2.isNA0(0));\n        Assert.assertTrue(cc2.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at(l + i), 0);\n      }\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n      Assert.assertTrue(cc2.isNA(man.length + l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78961,"modified_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n      // 0, 0.2, 0.3, 2.54, NA for l==0\n      // NA, 0, 0.2, 0.3, 2.54, NA for l==1\n      long[] man = new long[]{0, 2, 3, 254};\n      int[] exp = new int[]{1, -1, -1, -2};\n      if (l==1) nc.addNA();\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C1SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc.isNA0(0));\n        Assert.assertTrue(cc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at(l + i), 0);\n      }\n      Assert.assertTrue(cc.isNA0(man.length + l));\n      Assert.assertTrue(cc.isNA(man.length + l));\n\n      nc = cc.inflate_impl(new NewChunk(null, 0));\n      Assert.assertEquals(man.length + 1 + l, nc.len());\n      Assert.assertEquals(man.length + 1 + l, nc.sparseLen());\n      if (l==1) {\n        Assert.assertTrue(nc.isNA0(0));\n        Assert.assertTrue(nc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) nc.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) nc.at(l + i), 0);\n      }\n      Assert.assertTrue(nc.isNA0(man.length + l));\n      Assert.assertTrue(nc.isNA(man.length + l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C1SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc2.isNA0(0));\n        Assert.assertTrue(cc2.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at(l + i), 0);\n      }\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n      Assert.assertTrue(cc2.isNA(man.length + l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void test_inflate_impl2() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n      long[] man = new long[]{-1228, -997, -9740};\n      int[] exp = new int[]{-4, -4, -5};\n      if (l==1) nc.addNA();\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C1SChunk);\n      if (l==1) Assert.assertTrue(cc.isNA0(0));\n      for (int i = 0; i < man.length; ++i)\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at0(l + i), 0);\n      Assert.assertTrue(cc.isNA0(man.length + l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C1SChunk);\n      if (l==1) Assert.assertTrue(cc2.isNA0(0));\n      for (int i = 0; i < man.length; ++i)\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at0(l + i), 0);\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78962,"modified_method":"@Test public void test_inflate_impl2() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n      long[] man = new long[]{-1228, -997, -9740};\n      int[] exp = new int[]{-4, -4, -5};\n      if (l==1) nc.addNA();\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C1SChunk);\n      if (l==1) Assert.assertTrue(cc.isNA0(0));\n      for (int i = 0; i < man.length; ++i)\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at0(l + i), 0);\n      Assert.assertTrue(cc.isNA0(man.length + l));\n\n      nc = cc.inflate_impl(new NewChunk(null, 0));\n      Assert.assertEquals(man.length + 1 + l, nc.len());\n      Assert.assertEquals(man.length + 1 + l, nc.sparseLen());\n      if (l==1) {\n        Assert.assertTrue(nc.isNA0(0));\n        Assert.assertTrue(nc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) nc.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) nc.at(l + i), 0);\n      }\n      Assert.assertTrue(nc.isNA0(man.length + l));\n      Assert.assertTrue(nc.isNA(man.length + l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C1SChunk);\n      if (l==1) Assert.assertTrue(cc2.isNA0(0));\n      for (int i = 0; i < man.length; ++i)\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at0(l + i), 0);\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      int[] vals = new int[]{-32767, 0, 32767};\n      if (l==1) nc.addNA();\n      for (int v : vals) nc.addNum(v, 0);\n      nc.addNA(); //-32768\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C2Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n      Assert.assertTrue(cc.isNA(vals.length+l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C2Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at8(l+i));\n      Assert.assertTrue(cc2.isNA0(vals.length+l));\n      Assert.assertTrue(cc2.isNA(vals.length+l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78963,"modified_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      int[] vals = new int[]{-32767, 0, 32767};\n      if (l==1) nc.addNA();\n      for (int v : vals) nc.addNum(v, 0);\n      nc.addNA(); //-32768\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C2Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n      Assert.assertTrue(cc.isNA(vals.length+l));\n\n      nc = new NewChunk(null, 0);\n      cc.inflate_impl(nc);\n      if (l==1) Assert.assertTrue(cc.isNA0(0));\n      Assert.assertEquals(vals.length+l+1, nc.sparseLen());\n      Assert.assertEquals(vals.length+l+1, nc.len());\n      Iterator<NewChunk.Value> it = nc.values(0, vals.length+1+l);\n      for (int i = 0; i < vals.length+1+l; ++i) Assert.assertTrue(it.next().rowId0() == i);\n      Assert.assertTrue(!it.hasNext());\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], nc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], nc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C2Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at8(l+i));\n      Assert.assertTrue(cc2.isNA0(vals.length+l));\n      Assert.assertTrue(cc2.isNA(vals.length+l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void test_inflate_impl2() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      long[] man = new long[]{-12767, 34, 0, 52767};\n      int[] exp = new int[]{-3, -2, 1, -3};\n      if (l==1) nc.addNA(); //-32768\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C2SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc.isNA0(0));\n        Assert.assertTrue(cc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at(l + i), 0);\n      }\n      Assert.assertTrue(cc.isNA0(man.length + l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      if (l==1) {\n        Assert.assertTrue(cc2.isNA0(0));\n        Assert.assertTrue(cc2.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at(l + i), 0);\n      }\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n      Assert.assertTrue(cc2.isNA(man.length + l));\n      Assert.assertTrue(cc2 instanceof C2SChunk);\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78964,"modified_method":"@Test public void test_inflate_impl2() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      long[] man = new long[]{-12767, 34, 0, 52767};\n      int[] exp = new int[]{-3, -2, 1, -3};\n      if (l==1) nc.addNA(); //-32768\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C2SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc.isNA0(0));\n        Assert.assertTrue(cc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at(l + i), 0);\n      }\n      Assert.assertTrue(cc.isNA0(man.length + l));\n\n      nc = cc.inflate_impl(new NewChunk(null, 0));\n      Assert.assertEquals(man.length + 1 + l, nc.len());\n      Assert.assertEquals(man.length + 1 + l, nc.sparseLen());\n      if (l==1) {\n        Assert.assertTrue(nc.isNA0(0));\n        Assert.assertTrue(nc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) nc.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) nc.at(l + i), 0);\n      }\n      Assert.assertTrue(nc.isNA0(man.length + l));\n      Assert.assertTrue(nc.isNA(man.length + l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      if (l==1) {\n        Assert.assertTrue(cc2.isNA0(0));\n        Assert.assertTrue(cc2.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at(l + i), 0);\n      }\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n      Assert.assertTrue(cc2.isNA(man.length + l));\n      Assert.assertTrue(cc2 instanceof C2SChunk);\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      // -32.767, 0.34, 0, 32.767, NA for l==0\n      // NA, -32.767, 0.34, 0, 32.767, NA for l==1\n      long[] man = new long[]{-32767, 34, 0, 32767};\n      int[] exp = new int[]{-3, -2, 1, -3};\n      if (l==1) nc.addNA(); //-32768\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C2SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc.isNA0(0));\n        Assert.assertTrue(cc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at(l + i), 0);\n      }\n      Assert.assertTrue(cc.isNA0(man.length + l));\n      Assert.assertTrue(cc.isNA(man.length + l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      if (l==1) {\n        Assert.assertTrue(cc2.isNA0(0));\n        Assert.assertTrue(cc2.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at(l + i), 0);\n      }\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n      Assert.assertTrue(cc2.isNA(man.length + l));\n      Assert.assertTrue(cc2 instanceof C2SChunk);\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78965,"modified_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      // -32.767, 0.34, 0, 32.767, NA for l==0\n      // NA, -32.767, 0.34, 0, 32.767, NA for l==1\n      long[] man = new long[]{-32767, 34, 0, 32767};\n      int[] exp = new int[]{-3, -2, 1, -3};\n      if (l==1) nc.addNA(); //-32768\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C2SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc.isNA0(0));\n        Assert.assertTrue(cc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc.at(l + i), 0);\n      }\n      Assert.assertTrue(cc.isNA0(man.length + l));\n      Assert.assertTrue(cc.isNA(man.length + l));\n\n      nc = cc.inflate_impl(new NewChunk(null, 0));\n      Assert.assertEquals(man.length + 1 + l, nc.len());\n      Assert.assertEquals(man.length + 1 + l, nc.sparseLen());\n      if (l==1) {\n        Assert.assertTrue(nc.isNA0(0));\n        Assert.assertTrue(nc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) nc.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) nc.at(l + i), 0);\n      }\n      Assert.assertTrue(nc.isNA0(man.length + l));\n      Assert.assertTrue(nc.isNA(man.length + l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      if (l==1) {\n        Assert.assertTrue(cc2.isNA0(0));\n        Assert.assertTrue(cc2.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at0(l + i), 0);\n        Assert.assertEquals((float) (man[i] * Math.pow(10, exp[i])), (float) cc2.at(l + i), 0);\n      }\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n      Assert.assertTrue(cc2.isNA(man.length + l));\n      Assert.assertTrue(cc2 instanceof C2SChunk);\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      int[] vals = new int[]{-2147483647, 0, 2147483647};\n      if (l==1) nc.addNA();\n      for (int v : vals) nc.addNum(v, 0);\n      nc.addNA(); //-2147483648\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C4Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n      Assert.assertTrue(cc.isNA(vals.length+l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C4Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at8(l+i));\n      Assert.assertTrue(cc2.isNA0(vals.length+l));\n      Assert.assertTrue(cc2.isNA(vals.length+l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78966,"modified_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      int[] vals = new int[]{-2147483647, 0, 2147483647};\n      if (l==1) nc.addNA();\n      for (int v : vals) nc.addNum(v, 0);\n      nc.addNA(); //-2147483648\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C4Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n      Assert.assertTrue(cc.isNA(vals.length+l));\n\n      nc = new NewChunk(null, 0);\n      cc.inflate_impl(nc);\n      if (l==1) Assert.assertTrue(cc.isNA0(0));\n      Assert.assertEquals(vals.length+l+1, nc.sparseLen());\n      Assert.assertEquals(vals.length+l+1, nc.len());\n      Iterator<NewChunk.Value> it = nc.values(0, vals.length+1+l);\n      for (int i = 0; i < vals.length+1+l; ++i) Assert.assertTrue(it.next().rowId0() == i);\n      Assert.assertTrue(!it.hasNext());\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], nc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], nc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C4Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at8(l+i));\n      Assert.assertTrue(cc2.isNA0(vals.length+l));\n      Assert.assertTrue(cc2.isNA(vals.length+l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      // -2.147483647, 0, 0.0000215, 2.147583647, NA for l==0\n      // NA, -2.147483647, 0, 0.0000215, 2.147583647, NA for l==1\n      long[] man = new long[]{Integer.MIN_VALUE+1, 0, 215, 188001238, Integer.MAX_VALUE};\n      int[] exp = new int[]{-9, 1, -6, -8, -9};\n      if (l==1) nc.addNA(); //-2147483648\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C4SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc.isNA0(0));\n        Assert.assertTrue(cc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc.at0(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc.at0(l + i)) < 1e-10);\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc.at(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc.at(l + i)) < 1e-10);\n      }\n      Assert.assertTrue(cc.isNA0(man.length + l));\n      Assert.assertTrue(cc.isNA(man.length + l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      if (l==1) {\n        Assert.assertTrue(cc2.isNA0(0));\n        Assert.assertTrue(cc2.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc2.at0(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc2.at0(l + i)) < 1e-10);\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc2.at(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc2.at(l + i)) < 1e-10);\n      }\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n      Assert.assertTrue(cc2.isNA(man.length + l));\n      Assert.assertTrue(cc2 instanceof C4SChunk);\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78967,"modified_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      // -2.147483647, 0, 0.0000215, 2.147583647, NA for l==0\n      // NA, -2.147483647, 0, 0.0000215, 2.147583647, NA for l==1\n      long[] man = new long[]{Integer.MIN_VALUE+1, 0, 215, 188001238, Integer.MAX_VALUE};\n      int[] exp = new int[]{-9, 1, -6, -8, -9};\n      if (l==1) nc.addNA(); //-2147483648\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C4SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc.isNA0(0));\n        Assert.assertTrue(cc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc.at0(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc.at0(l + i)) < 1e-10);\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc.at(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc.at(l + i)) < 1e-10);\n      }\n      Assert.assertTrue(cc.isNA0(man.length + l));\n      Assert.assertTrue(cc.isNA(man.length + l));\n\n      nc = cc.inflate_impl(new NewChunk(null, 0));\n      Assert.assertEquals(man.length + 1 + l, nc.len());\n      if (l==1) {\n        Assert.assertTrue(nc.isNA0(0));\n        Assert.assertTrue(nc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + nc.at0(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - nc.at0(l + i)) < 1e-10);\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + nc.at(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - nc.at(l + i)) < 1e-10);\n      }\n      Assert.assertTrue(nc.isNA0(man.length + l));\n      Assert.assertTrue(nc.isNA(man.length + l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      if (l==1) {\n        Assert.assertTrue(cc2.isNA0(0));\n        Assert.assertTrue(cc2.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc2.at0(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc2.at0(l + i)) < 1e-10);\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc2.at(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc2.at(l + i)) < 1e-10);\n      }\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n      Assert.assertTrue(cc2.isNA(man.length + l));\n      Assert.assertTrue(cc2 instanceof C4SChunk);\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test public void test_inflate_impl2() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      // different bias and scale than above, but still using the full 32-bit range (~4.29 billion different integers from -8.1b to -3.8b)\n      long[] man = new long[]{(long)(Integer.MIN_VALUE+1)*100000l - 613030080700000l, -5999999700000l, -58119987600000l, (long)Integer.MAX_VALUE*100000l - 613030080700000l};\n      int[] exp = new int[]{-19, -17, -18, -19};\n\n      if (l==1) nc.addNA(); //-2147483648\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C4SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc.isNA0(0));\n        Assert.assertTrue(cc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc.at0(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc.at0(l + i)) < 1e-10);\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc.at(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc.at(l + i)) < 1e-10);\n      }\n      Assert.assertTrue(cc.isNA0(man.length + l));\n      Assert.assertTrue(cc.isNA(man.length + l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      if (l==1) {\n        Assert.assertTrue(cc2.isNA0(0));\n        Assert.assertTrue(cc2.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc2.at0(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc2.at0(l + i)) < 1e-10);\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc2.at(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc2.at(l + i)) < 1e-10);\n      }\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n      Assert.assertTrue(cc2.isNA(man.length + l));\n      Assert.assertTrue(cc2 instanceof C4SChunk);\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78968,"modified_method":"@Test public void test_inflate_impl2() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      // different bias and scale than above, but still using the full 32-bit range (~4.29 billion different integers from -8.1b to -3.8b)\n      long[] man = new long[]{(long)(Integer.MIN_VALUE+1)*100000l - 613030080700000l, -5999999700000l, -58119987600000l, (long)Integer.MAX_VALUE*100000l - 613030080700000l};\n      int[] exp = new int[]{-19, -17, -18, -19};\n\n      if (l==1) nc.addNA(); //-2147483648\n      for (int i = 0; i < man.length; ++i) nc.addNum(man[i], exp[i]);\n      nc.addNA();\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C4SChunk);\n      if (l==1) {\n        Assert.assertTrue(cc.isNA0(0));\n        Assert.assertTrue(cc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc.at0(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc.at0(l + i)) < 1e-10);\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc.at(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc.at(l + i)) < 1e-10);\n      }\n      Assert.assertTrue(cc.isNA0(man.length + l));\n      Assert.assertTrue(cc.isNA(man.length + l));\n\n      nc = cc.inflate_impl(new NewChunk(null, 0));\n      Assert.assertEquals(man.length + 1 + l, nc.len());\n      if (l==1) {\n        Assert.assertTrue(nc.isNA0(0));\n        Assert.assertTrue(nc.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + nc.at0(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - nc.at0(l + i)) < 1e-10);\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + nc.at(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - nc.at(l + i)) < 1e-10);\n      }\n      Assert.assertTrue(nc.isNA0(man.length + l));\n      Assert.assertTrue(nc.isNA(man.length + l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(man.length + 1 + l, cc.len());\n      if (l==1) {\n        Assert.assertTrue(cc2.isNA0(0));\n        Assert.assertTrue(cc2.isNA(0));\n      }\n      for (int i = 0; i < man.length; ++i) {\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc2.at0(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc2.at0(l + i)) < 1e-10);\n        Assert.assertTrue(\"Expected: \" + man[i] * Math.pow(10, exp[i]) + \", but is \" + cc2.at(l + i), Math.abs((man[i] * Math.pow(10, exp[i])) - cc2.at(l + i)) < 1e-10);\n      }\n      Assert.assertTrue(cc2.isNA0(man.length + l));\n      Assert.assertTrue(cc2.isNA(man.length + l));\n      Assert.assertTrue(cc2 instanceof C4SChunk);\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      long[] vals = new long[]{Long.MIN_VALUE+1, Integer.MIN_VALUE, 0, Integer.MAX_VALUE, Long.MAX_VALUE};\n      if (l==1) nc.addNA();\n      for (long v : vals) nc.addNum(v, 0);\n      nc.addNA(); //-9223372036854775808l\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C8Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n      Assert.assertTrue(cc.isNA(vals.length+l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C8Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at8(l+i));\n      Assert.assertTrue(cc2.isNA0(vals.length+l));\n      Assert.assertTrue(cc2.isNA(vals.length+l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78969,"modified_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      long[] vals = new long[]{Long.MIN_VALUE+1, Integer.MIN_VALUE, 0, Integer.MAX_VALUE, Long.MAX_VALUE};\n      if (l==1) nc.addNA();\n      for (long v : vals) nc.addNum(v, 0);\n      nc.addNA(); //-9223372036854775808l\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C8Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n      Assert.assertTrue(cc.isNA(vals.length+l));\n\n      nc = new NewChunk(null, 0);\n      cc.inflate_impl(nc);\n      if (l==1) Assert.assertTrue(cc.isNA0(0));\n      Assert.assertEquals(vals.length+l+1, nc.sparseLen());\n      Assert.assertEquals(vals.length+l+1, nc.len());\n      Iterator<NewChunk.Value> it = nc.values(0, vals.length+1+l);\n      for (int i = 0; i < vals.length+1+l; ++i) Assert.assertTrue(it.next().rowId0() == i);\n      Assert.assertTrue(!it.hasNext());\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], nc.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], nc.at8(l+i));\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C8Chunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at80(l+i));\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at8(l+i));\n      Assert.assertTrue(cc2.isNA0(vals.length+l));\n      Assert.assertTrue(cc2.isNA(vals.length+l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      double[] vals = new double[]{Double.NaN, Double.MIN_VALUE, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, -3.1415926e-118, 0, 23423423.234234234, 0.00103E217, Double.MAX_VALUE};\n      if (l==1) nc.addNA();\n      for (double v : vals) nc.addNum(v);\n      nc.addNA(); //-9223372036854775808l\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C8DChunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at0(l+i), 0);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at(l+i), 0);\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n      Assert.assertTrue(cc.isNA(vals.length+l));\n\n      Chunk cc2 = cc.inflate_impl(new NewChunk(null, 0)).compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C8DChunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at0(l+i), 0);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at(l+i), 0);\n      Assert.assertTrue(cc2.isNA0(vals.length+l));\n      Assert.assertTrue(cc2.isNA(vals.length+l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","id":78970,"modified_method":"@Test\n  public void test_inflate_impl() {\n    for (int l=0; l<2; ++l) {\n      NewChunk nc = new NewChunk(null, 0);\n\n      double[] vals = new double[]{Double.NaN, Double.MIN_VALUE, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, -3.1415926e-118, 0, 23423423.234234234, 0.00103E217, Double.MAX_VALUE};\n      if (l==1) nc.addNA();\n      for (double v : vals) nc.addNum(v);\n      nc.addNA(); //-9223372036854775808l\n\n      Chunk cc = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc instanceof C8DChunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at0(l+i), 0);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc.at(l+i), 0);\n      Assert.assertTrue(cc.isNA0(vals.length+l));\n      Assert.assertTrue(cc.isNA(vals.length+l));\n\n      nc = cc.inflate_impl(new NewChunk(null, 0));\n      Assert.assertEquals(vals.length + 1 + l, nc.len());\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], nc.at0(l+i), 0);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], nc.at(l+i), 0);\n      Assert.assertTrue(nc.isNA0(vals.length+l));\n      Assert.assertTrue(nc.isNA(vals.length+l));\n\n      Chunk cc2 = nc.compress();\n      Assert.assertEquals(vals.length + 1 + l, cc.len());\n      Assert.assertTrue(cc2 instanceof C8DChunk);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at0(l+i), 0);\n      for (int i = 0; i < vals.length; ++i) Assert.assertEquals(vals[i], cc2.at(l+i), 0);\n      Assert.assertTrue(cc2.isNA0(vals.length+l));\n      Assert.assertTrue(cc2.isNA(vals.length+l));\n\n      Assert.assertTrue(Arrays.equals(cc._mem, cc2._mem));\n    }\n  }","commit_id":"973c026a7a37ea967b76bc6f4f9625f198fe6938","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n    public void handle(HttpExchange http) throws IOException {\n        final URI uri = http.getRequestURI();\n        final String requestMethod = http.getRequestMethod();\n\n        // only GET supported\n        if (!\"GET\".equals(requestMethod)) {\n            http.sendResponseHeaders(405, -1);\n            return;\n        }\n\n        // normalize to request resource\n        String path = uri.getPath();\n        String resource = path.substring(CONTEXT.length(), path.length());\n        if(resource.startsWith(\"/\")) resource = resource.substring(1);\n\n        if(resource.equals(\"\")) respond404(http);\n\n        // load resource\n        InputStream inputStream = getLoader().getResourceAsStream(resource);\n        if(inputStream!=null)\n        {\n            Headers responseHeaders = http.getResponseHeaders();\n            responseHeaders.set(\"Content-Type\", \"text/plain\");// TODO\n            http.sendResponseHeaders(200, 0);\n\n            OutputStream outputStream = http.getResponseBody();\n\n            int nextChar;\n            while ( ( nextChar = inputStream.read() ) != -1  )\n            {\n                outputStream.write(nextChar);\n            }\n            outputStream.close();\n        }\n        else\n        {\n            respond404(http);\n        }\n\n    }","id":78971,"modified_method":"@Override\n    public void handle(HttpExchange http) throws IOException {\n        final URI uri = http.getRequestURI();\n        final String requestMethod = http.getRequestMethod();\n\n        // only GET supported\n        if (!\"GET\".equals(requestMethod)) {\n            http.sendResponseHeaders(405, -1);\n            return;\n        }\n\n        // normalize to request resource\n        String path = uri.getPath();\n        String resource = path.substring(CONTEXT.length(), path.length());\n        if(resource.startsWith(\"/\")) resource = resource.substring(1);\n\n        // respond 404 directory request\n        if(resource.equals(\"\") || resource.indexOf(\".\")==-1) respond404(http);\n\n        // load resource\n        InputStream inputStream = getLoader().getResourceAsStream(resource);\n        if(inputStream!=null)\n        {\n            Headers responseHeaders = http.getResponseHeaders();\n            responseHeaders.set(\"Content-Type\", resolveContentType(path));\n            http.sendResponseHeaders(200, 0);\n\n            OutputStream outputStream = http.getResponseBody();\n\n            int nextChar;\n            while ( ( nextChar = inputStream.read() ) != -1  )\n            {\n                outputStream.write(nextChar);\n            }\n            outputStream.close();\n        }\n        else\n        {\n            respond404(http);\n        }\n\n    }","commit_id":"d67d77e999c446279a6e339e939660df3481f3cc","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void startServer() throws IOException {\n        InetSocketAddress addr = new InetSocketAddress(\"localhost\",8080);\n        HttpServer server = HttpServer.create(addr, 0);\n\n        server.createContext(ConsoleHandler.CONTEXT, new ConsoleHandler());\n        server.setExecutor(Executors.newCachedThreadPool());\n\n        server.start();\n        System.out.println(\"Server is listening on \" +addr);\n    }","id":78972,"modified_method":"private void startServer() throws IOException {\n        InetSocketAddress addr = new InetSocketAddress(\"localhost\",8080);\n        server = HttpServer.create(addr, 0);\n\n        server.createContext(ConsoleHandler.CONTEXT, new ConsoleHandler());\n        server.setExecutor(Executors.newCachedThreadPool());\n\n        server.start();\n        System.out.println(\"Server is listening on \" +addr);\n    }","commit_id":"d67d77e999c446279a6e339e939660df3481f3cc","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static String GET(String resource) throws Exception {\n\n        URLConnection uc = new URL(\"http://localhost:8080/\"+resource).openConnection();\n        BufferedReader in = new BufferedReader( new InputStreamReader(uc.getInputStream()));\n        String inputLine;\n\n        StringBuffer sb = new StringBuffer();\n        while ((inputLine = in.readLine()) != null)\n            sb.append(inputLine);\n\n        in.close();\n        return sb.toString();\n    }","id":78973,"modified_method":"private static String GET(String resource) throws Exception, Http404 {\n\n        HttpURLConnection uc = (HttpURLConnection) new URL(\"http://localhost:8080/\"+resource).openConnection();\n        if(uc.getResponseCode()==404) throw new Http404();\n\n        BufferedReader in = new BufferedReader( new InputStreamReader(uc.getInputStream()));\n        String inputLine;\n\n        StringBuffer sb = new StringBuffer();\n        while ((inputLine = in.readLine()) != null)\n            sb.append(inputLine);\n\n        in.close();\n        return sb.toString();\n    }","commit_id":"d67d77e999c446279a6e339e939660df3481f3cc","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n   * The crux of the matter...\n   * \n   * @param host {@link MapHost} from which we need to  \n   *              shuffle available map-outputs.\n   */\n  private void copyFromHost(MapHost host) throws IOException {\n    // Get completed maps on 'host'\n    List<TaskAttemptID> maps = scheduler.getMapsForHost(host);\n    \n    // Sanity check to catch hosts with only 'OBSOLETE' maps, \n    // especially at the tail of large jobs\n    if (maps.size() == 0) {\n      return;\n    }\n    \n    LOG.debug(\"Fetcher \" + id + \" going to fetch from \" + host);\n    for (TaskAttemptID tmp: maps) {\n      LOG.debug(tmp);\n    }\n    \n    // List of maps to be fetched yet\n    Set<TaskAttemptID> remaining = new HashSet<TaskAttemptID>(maps);\n    \n    // Construct the url and connect\n    DataInputStream input;\n    boolean connectSucceeded = false;\n    \n    try {\n      URL url = getMapOutputURL(host, maps);\n      URLConnection connection = url.openConnection();\n      \n      // generate hash of the url\n      String msgToEncode = SecureShuffleUtils.buildMsgFrom(url);\n      String encHash = SecureShuffleUtils.hashFromString(msgToEncode, jobTokenSecret);\n      \n      // put url hash into http header\n      connection.addRequestProperty(\n          SecureShuffleUtils.HTTP_HEADER_URL_HASH, encHash);\n      // set the read timeout\n      connection.setReadTimeout(readTimeout);\n      connect(connection, connectionTimeout);\n      connectSucceeded = true;\n      input = new DataInputStream(connection.getInputStream());\n      \n      // get the replyHash which is HMac of the encHash we sent to the server\n      String replyHash = connection.getHeaderField(SecureShuffleUtils.HTTP_HEADER_REPLY_URL_HASH);\n      if(replyHash==null) {\n        throw new IOException(\"security validation of TT Map output failed\");\n      }\n      LOG.debug(\"url=\"+msgToEncode+\";encHash=\"+encHash+\";replyHash=\"+replyHash);\n      // verify that replyHash is HMac of encHash\n      SecureShuffleUtils.verifyReply(replyHash, encHash, jobTokenSecret);\n      LOG.info(\"for url=\"+msgToEncode+\" sent hash and receievd reply\");\n    } catch (IOException ie) {\n      ioErrs.increment(1);\n      LOG.warn(\"Failed to connect to \" + host + \" with \" + remaining.size() + \n               \" map outputs\", ie);\n\n      // If connect did not succeed, just mark all the maps as failed,\n      // indirectly penalizing the host\n      if (!connectSucceeded) {\n        for(TaskAttemptID left: remaining) {\n          scheduler.copyFailed(left, host, connectSucceeded);\n        }\n      } else {\n        // If we got a read error at this stage, it implies there was a problem\n        // with the first map, typically lost map. So, penalize only that map\n        // and add the rest\n        TaskAttemptID firstMap = maps.get(0);\n        scheduler.copyFailed(firstMap, host, connectSucceeded);\n      }\n      \n      // Add back all the remaining maps, WITHOUT marking them as failed\n      for(TaskAttemptID left: remaining) {\n        scheduler.putBackKnownMapOutput(host, left);\n      }\n      \n      return;\n    }\n    \n    try {\n      // Loop through available map-outputs and fetch them\n      // On any error, good becomes false and we exit after putting back\n      // the remaining maps to the yet_to_be_fetched list\n      boolean good = true;\n      while (!remaining.isEmpty() && good) {\n        good = copyMapOutput(host, input, remaining);\n      }\n      \n      IOUtils.cleanup(LOG, input);\n      \n      // Sanity check\n      if (good && !remaining.isEmpty()) {\n        throw new IOException(\"server didn't return all expected map outputs: \"\n            + remaining.size() + \" left.\");\n      }\n    } finally {\n      for (TaskAttemptID left : remaining) {\n        scheduler.putBackKnownMapOutput(host, left);\n      }\n    }\n      \n   }","id":78974,"modified_method":"/**\n   * The crux of the matter...\n   * \n   * @param host {@link MapHost} from which we need to  \n   *              shuffle available map-outputs.\n   */\n  private void copyFromHost(MapHost host) throws IOException {\n    // Get completed maps on 'host'\n    List<TaskAttemptID> maps = scheduler.getMapsForHost(host);\n    \n    // Sanity check to catch hosts with only 'OBSOLETE' maps, \n    // especially at the tail of large jobs\n    if (maps.size() == 0) {\n      return;\n    }\n    \n    LOG.debug(\"Fetcher \" + id + \" going to fetch from \" + host);\n    for (TaskAttemptID tmp: maps) {\n      LOG.debug(tmp);\n    }\n    \n    // List of maps to be fetched yet\n    Set<TaskAttemptID> remaining = new HashSet<TaskAttemptID>(maps);\n    \n    // Construct the url and connect\n    DataInputStream input;\n    boolean connectSucceeded = false;\n    \n    try {\n      URL url = getMapOutputURL(host, maps);\n      HttpURLConnection connection = (HttpURLConnection)url.openConnection();\n      \n      // generate hash of the url\n      String msgToEncode = SecureShuffleUtils.buildMsgFrom(url);\n      String encHash = SecureShuffleUtils.hashFromString(msgToEncode, jobTokenSecret);\n      \n      // put url hash into http header\n      connection.addRequestProperty(\n          SecureShuffleUtils.HTTP_HEADER_URL_HASH, encHash);\n      // set the read timeout\n      connection.setReadTimeout(readTimeout);\n      connect(connection, connectionTimeout);\n      connectSucceeded = true;\n      input = new DataInputStream(connection.getInputStream());\n\n      // Validate response code\n      int rc = connection.getResponseCode();\n      if (rc != HttpURLConnection.HTTP_OK) {\n        throw new IOException(\n            \"Got invalid response code \" + rc + \" from \" + url +\n            \": \" + connection.getResponseMessage());\n      }\n      \n      // get the replyHash which is HMac of the encHash we sent to the server\n      String replyHash = connection.getHeaderField(SecureShuffleUtils.HTTP_HEADER_REPLY_URL_HASH);\n      if(replyHash==null) {\n        throw new IOException(\"security validation of TT Map output failed\");\n      }\n      LOG.debug(\"url=\"+msgToEncode+\";encHash=\"+encHash+\";replyHash=\"+replyHash);\n      // verify that replyHash is HMac of encHash\n      SecureShuffleUtils.verifyReply(replyHash, encHash, jobTokenSecret);\n      LOG.info(\"for url=\"+msgToEncode+\" sent hash and receievd reply\");\n    } catch (IOException ie) {\n      ioErrs.increment(1);\n      LOG.warn(\"Failed to connect to \" + host + \" with \" + remaining.size() + \n               \" map outputs\", ie);\n\n      // If connect did not succeed, just mark all the maps as failed,\n      // indirectly penalizing the host\n      if (!connectSucceeded) {\n        for(TaskAttemptID left: remaining) {\n          scheduler.copyFailed(left, host, connectSucceeded);\n        }\n      } else {\n        // If we got a read error at this stage, it implies there was a problem\n        // with the first map, typically lost map. So, penalize only that map\n        // and add the rest\n        TaskAttemptID firstMap = maps.get(0);\n        scheduler.copyFailed(firstMap, host, connectSucceeded);\n      }\n      \n      // Add back all the remaining maps, WITHOUT marking them as failed\n      for(TaskAttemptID left: remaining) {\n        scheduler.putBackKnownMapOutput(host, left);\n      }\n      \n      return;\n    }\n    \n    try {\n      // Loop through available map-outputs and fetch them\n      // On any error, good becomes false and we exit after putting back\n      // the remaining maps to the yet_to_be_fetched list\n      boolean good = true;\n      while (!remaining.isEmpty() && good) {\n        good = copyMapOutput(host, input, remaining);\n      }\n      \n      IOUtils.cleanup(LOG, input);\n      \n      // Sanity check\n      if (good && !remaining.isEmpty()) {\n        throw new IOException(\"server didn't return all expected map outputs: \"\n            + remaining.size() + \" left.\");\n      }\n    } finally {\n      for (TaskAttemptID left : remaining) {\n        scheduler.putBackKnownMapOutput(host, left);\n      }\n    }\n      \n   }","commit_id":"04a47dea7489e3f860b0ab7b8f3ab1fc5a395426","url":"https://github.com/apache/hadoop"},{"original_method":"protected void downloadFile(String fileName, FileOutputStream out, URL url, IProgress progress) throws IOException, InterruptedException {\r\n\t\tInputStream is = null;\r\n\t\t\r\n\t\tbyte[] buffer = new byte[BUFFER_SIZE];\r\n\t\tint read = 0;\r\n\t\tint length = 0;\r\n\t\tint fileread = 0;\r\n\t\tint triesDownload = TRIES_TO_DOWNLOAD;\r\n\t\tboolean first = true;\r\n\t\ttry {\r\n\t\t\twhile (triesDownload > 0) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (!first) {\r\n\t\t\t\t\t\tlog.info(\"Reconnecting\"); //$NON-NLS-1$\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tThread.sleep(TIMEOUT_BETWEEN_DOWNLOADS);\r\n\t\t\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tURLConnection conn = url.openConnection();\r\n\t\t\t\t\tconn.setReadTimeout(30000);\r\n\t\t\t\t\tconn.setConnectTimeout(30000);\r\n\t\t\t\t\tis = conn.getInputStream();\r\n\t\t\t\t\tlong skipped = 0;\r\n\t\t\t\t\twhile (skipped < fileread) {\r\n\t\t\t\t\t\tskipped += is.skip(fileread - skipped);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (first) {\r\n\t\t\t\t\t\tlength = conn.getContentLength();\r\n\t\t\t\t\t\tprogress.startTask(getString(R.string.downloading_file) + \" \" + fileName, length); //$NON-NLS-1$\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t\twhile ((read = is.read(buffer)) != -1) {\r\n\t\t\t\t\t\t if(interruptDownloading){\r\n\t\t\t\t\t\t \tthrow new InterruptedException();\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\tout.write(buffer, 0, read);\r\n\t\t\t\t\t\tprogress.progress(read);\r\n\t\t\t\t\t\tfileread += read;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttriesDownload = 0;\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\tlog.error(\"IOException\", e); //$NON-NLS-1$\r\n\t\t\t\t\ttriesDownload--;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tif (is != null) {\r\n\t\t\t\tis.close();\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(length != fileread){\r\n\t\t\tthrow new IOException(\"File was not fully read\"); //$NON-NLS-1$\r\n\t\t}\r\n\t\t\r\n\t}","id":78975,"modified_method":"protected void downloadFile(String fileName, FileOutputStream out, URL url, IProgress progress) throws IOException, InterruptedException {\r\n\t\tInputStream is = null;\r\n\t\t\r\n\t\tbyte[] buffer = new byte[BUFFER_SIZE];\r\n\t\tint read = 0;\r\n\t\tint length = 0;\r\n\t\tint fileread = 0;\r\n\t\tint triesDownload = TRIES_TO_DOWNLOAD;\r\n\t\tboolean first = true;\r\n\t\ttry {\r\n\t\t\twhile (triesDownload > 0) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (!first) {\r\n\t\t\t\t\t\tlog.info(\"Reconnecting\"); //$NON-NLS-1$\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tThread.sleep(TIMEOUT_BETWEEN_DOWNLOADS);\r\n\t\t\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\r\n\t\t\t\t\tconn.setReadTimeout(30000);\r\n\t\t\t\t\tif (fileread > 0) {\r\n\t\t\t\t\t\tString range = \"bytes=\"+fileread + \"-\" + (length -1); //$NON-NLS-1$ //$NON-NLS-2$\r\n\t\t\t\t\t\tconn.setRequestProperty(\"Range\", range);  //$NON-NLS-1$\r\n\t\t\t\t\t}\r\n\t\t\t\t\tconn.setConnectTimeout(30000);\r\n\t\t\t\t\tlog.info(conn.getResponseMessage() + \" \" + conn.getResponseCode()); //$NON-NLS-1$\r\n\t\t\t\t\tis = conn.getInputStream();\r\n//\t\t\t\t\tlong skipped = 0;\r\n//\t\t\t\t\twhile (skipped < fileread) {\r\n//\t\t\t\t\t\tskipped += is.skip(fileread - skipped);\r\n//\t\t\t\t\t}\r\n\t\t\t\t\tif (first) {\r\n\t\t\t\t\t\tlength = conn.getContentLength();\r\n\t\t\t\t\t\tprogress.startTask(getString(R.string.downloading_file) + \" \" + fileName, length); //$NON-NLS-1$\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t\twhile ((read = is.read(buffer)) != -1) {\r\n\t\t\t\t\t\t if(interruptDownloading){\r\n\t\t\t\t\t\t \tthrow new InterruptedException();\r\n\t\t\t\t\t\t }\r\n\t\t\t\t\t\tout.write(buffer, 0, read);\r\n\t\t\t\t\t\tprogress.progress(read);\r\n\t\t\t\t\t\tfileread += read;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(length <= fileread){\r\n\t\t\t\t\t\ttriesDownload = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\tlog.error(\"IOException\", e); //$NON-NLS-1$\r\n\t\t\t\t\ttriesDownload--;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t} finally {\r\n\t\t\tif (is != null) {\r\n\t\t\t\tis.close();\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(length != fileread){\r\n\t\t\tthrow new IOException(\"File was not fully read\"); //$NON-NLS-1$\r\n\t\t}\r\n\t\t\r\n\t}","commit_id":"aed5ca28aa2f0f0765d3ca13957eefa511966037","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected boolean downloadFile(final String key, final File fileToDownload, final File fileToUnZip, final boolean unzipToDir,\r\n\t\t\tIProgress progress, Long dateModified) throws InterruptedException {\r\n\t\tFileOutputStream out = null;\r\n\t\ttry {\r\n\r\n\t\t\tout = new FileOutputStream(fileToDownload);\r\n\t\t\tURL url = USE_DOWNLOAD_OSMAND_NET ? new URL(\"http://download.osmand.net/indexes/\"+key):  //$NON-NLS-1$\r\n\t\t\t\tDownloaderIndexFromGoogleCode.getInputStreamToLoadIndex(key);\r\n\t\t\ttry {\r\n\t\t\t\tdownloadFile(key, out, url, progress);\r\n\t\t\t} finally {\r\n\t\t\t\tout.close();\r\n\t\t\t\tout = null;\r\n\t\t\t}\r\n\r\n\t\t\tFile toIndex = fileToDownload;\r\n\t\t\tif (fileToDownload.getName().endsWith(\".zip\")) { //$NON-NLS-1$\r\n\t\t\t\tprogress.startTask(getString(R.string.unzipping_file), -1);\r\n\t\t\t\tif (!unzipToDir) {\r\n\t\t\t\t\ttoIndex = fileToUnZip;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfileToUnZip.mkdirs();\r\n\t\t\t\t}\r\n\t\t\t\tZipInputStream zipIn = new ZipInputStream(new FileInputStream(fileToDownload));\r\n\t\t\t\tZipEntry entry = null;\r\n\t\t\t\twhile ((entry = zipIn.getNextEntry()) != null) {\r\n\t\t\t\t\tFile fs;\r\n\t\t\t\t\tif (!unzipToDir) {\r\n\t\t\t\t\t\tString name = entry.getName();\r\n\t\t\t\t\t\t// small simplification\r\n\t\t\t\t\t\tint ind = name.lastIndexOf('_');\r\n\t\t\t\t\t\tif (ind > 0) {\r\n\t\t\t\t\t\t\t// cut version\r\n\t\t\t\t\t\t\tint i = name.indexOf('.', ind);\r\n\t\t\t\t\t\t\tif (i > 0) {\r\n\t\t\t\t\t\t\t\tname = name.substring(0, ind) + name.substring(i, name.length());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfs = new File(fileToUnZip.getParent(), name);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfs = new File(fileToUnZip, entry.getName());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tout = new FileOutputStream(fs);\r\n\t\t\t\t\tint read;\r\n\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\r\n\t\t\t\t\twhile ((read = zipIn.read(buffer)) != -1) {\r\n\t\t\t\t\t\tout.write(buffer, 0, read);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tout.close();\r\n\t\t\t\t}\r\n\t\t\t\tzipIn.close();\r\n\t\t\t\tfileToDownload.delete(); // zip is no needed more\r\n\t\t\t}\r\n\r\n\t\t\tArrayList<String> warnings = new ArrayList<String>();\r\n\t\t\tResourceManager manager = ((OsmandApplication) getApplication()).getResourceManager();\r\n\t\t\tif(dateModified != null){\r\n\t\t\t\ttoIndex.setLastModified(dateModified);\r\n\t\t\t}\r\n\t\t\tif (toIndex.getName().endsWith(IndexConstants.ADDRESS_INDEX_EXT)) {\r\n\t\t\t\tmanager.indexingAddress(progress, warnings, toIndex);\r\n\t\t\t} else if (toIndex.getName().endsWith(IndexConstants.POI_INDEX_EXT)) {\r\n\t\t\t\tmanager.indexingPoi(progress, warnings, toIndex);\r\n\t\t\t} else if (toIndex.getName().endsWith(IndexConstants.TRANSPORT_INDEX_EXT)) {\r\n\t\t\t\tmanager.indexingTransport(progress, warnings, toIndex);\r\n\t\t\t} else if (toIndex.getName().endsWith(IndexConstants.BINARY_MAP_INDEX_EXT)) {\r\n\t\t\t\tmanager.indexingMaps(progress);\r\n\t\t\t} else if (toIndex.getName().endsWith(IndexConstants.VOICE_INDEX_EXT_ZIP)) {\r\n\t\t\t}\r\n\t\t\tif(dateModified != null){\r\n\t\t\t\ttoIndex.setLastModified(dateModified);\r\n\t\t\t}\r\n\t\t\tif (warnings.isEmpty()) {\r\n\t\t\t\tshowWarning(getString(R.string.download_index_success));\r\n\t\t\t} else {\r\n\t\t\t\tshowWarning(warnings.get(0));\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t} catch (IOException e) {\r\n\t\t\tlog.error(\"Exception ocurred\", e); //$NON-NLS-1$\r\n\t\t\tshowWarning(getString(R.string.error_io_error));\r\n\t\t\tif(out != null){\r\n\t\t\t\ttry {\r\n\t\t\t\t\tout.close();\r\n\t\t\t\t} catch (IOException e1) {\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Possibly file is corrupted\r\n\t\t\tfileToDownload.delete();\r\n\t\t\treturn false;\r\n\t\t} catch (InterruptedException e) {\r\n\t\t\t// Possibly file is corrupted\r\n\t\t\tfileToDownload.delete();\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t}","id":78976,"modified_method":"protected boolean downloadFile(final String key, final File fileToDownload, final File fileToUnZip, final boolean unzipToDir,\r\n\t\t\tIProgress progress, Long dateModified) throws InterruptedException {\r\n\t\tFileOutputStream out = null;\r\n\t\ttry {\r\n\r\n\t\t\tout = new FileOutputStream(fileToDownload);\r\n\t\t\tURL url = USE_DOWNLOAD_OSMAND_NET ? new URL(\"http://download.osmand.net/download?file=\"+key):  //$NON-NLS-1$\r\n\t\t\t\tDownloaderIndexFromGoogleCode.getInputStreamToLoadIndex(key);\r\n\t\t\ttry {\r\n\t\t\t\tdownloadFile(key, out, url, progress);\r\n\t\t\t} finally {\r\n\t\t\t\tout.close();\r\n\t\t\t\tout = null;\r\n\t\t\t}\r\n\r\n\t\t\tFile toIndex = fileToDownload;\r\n\t\t\tif (fileToDownload.getName().endsWith(\".zip\")) { //$NON-NLS-1$\r\n\t\t\t\tprogress.startTask(getString(R.string.unzipping_file), -1);\r\n\t\t\t\tif (!unzipToDir) {\r\n\t\t\t\t\ttoIndex = fileToUnZip;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tfileToUnZip.mkdirs();\r\n\t\t\t\t}\r\n\t\t\t\tZipInputStream zipIn = new ZipInputStream(new FileInputStream(fileToDownload));\r\n\t\t\t\tZipEntry entry = null;\r\n\t\t\t\twhile ((entry = zipIn.getNextEntry()) != null) {\r\n\t\t\t\t\tFile fs;\r\n\t\t\t\t\tif (!unzipToDir) {\r\n\t\t\t\t\t\tString name = entry.getName();\r\n\t\t\t\t\t\t// small simplification\r\n\t\t\t\t\t\tint ind = name.lastIndexOf('_');\r\n\t\t\t\t\t\tif (ind > 0) {\r\n\t\t\t\t\t\t\t// cut version\r\n\t\t\t\t\t\t\tint i = name.indexOf('.', ind);\r\n\t\t\t\t\t\t\tif (i > 0) {\r\n\t\t\t\t\t\t\t\tname = name.substring(0, ind) + name.substring(i, name.length());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfs = new File(fileToUnZip.getParent(), name);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfs = new File(fileToUnZip, entry.getName());\r\n\t\t\t\t\t}\r\n\t\t\t\t\tout = new FileOutputStream(fs);\r\n\t\t\t\t\tint read;\r\n\t\t\t\t\tbyte[] buffer = new byte[BUFFER_SIZE];\r\n\t\t\t\t\twhile ((read = zipIn.read(buffer)) != -1) {\r\n\t\t\t\t\t\tout.write(buffer, 0, read);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tout.close();\r\n\t\t\t\t}\r\n\t\t\t\tzipIn.close();\r\n\t\t\t\tfileToDownload.delete(); // zip is no needed more\r\n\t\t\t}\r\n\r\n\t\t\tArrayList<String> warnings = new ArrayList<String>();\r\n\t\t\tResourceManager manager = ((OsmandApplication) getApplication()).getResourceManager();\r\n\t\t\tif(dateModified != null){\r\n\t\t\t\ttoIndex.setLastModified(dateModified);\r\n\t\t\t}\r\n\t\t\tif (toIndex.getName().endsWith(IndexConstants.ADDRESS_INDEX_EXT)) {\r\n\t\t\t\tmanager.indexingAddress(progress, warnings, toIndex);\r\n\t\t\t} else if (toIndex.getName().endsWith(IndexConstants.POI_INDEX_EXT)) {\r\n\t\t\t\tmanager.indexingPoi(progress, warnings, toIndex);\r\n\t\t\t} else if (toIndex.getName().endsWith(IndexConstants.TRANSPORT_INDEX_EXT)) {\r\n\t\t\t\tmanager.indexingTransport(progress, warnings, toIndex);\r\n\t\t\t} else if (toIndex.getName().endsWith(IndexConstants.BINARY_MAP_INDEX_EXT)) {\r\n\t\t\t\tmanager.indexingMaps(progress);\r\n\t\t\t} else if (toIndex.getName().endsWith(IndexConstants.VOICE_INDEX_EXT_ZIP)) {\r\n\t\t\t}\r\n\t\t\tif(dateModified != null){\r\n\t\t\t\ttoIndex.setLastModified(dateModified);\r\n\t\t\t\tmanager.updateIndexLastDateModified(toIndex);\r\n\t\t\t}\r\n\t\t\tif (warnings.isEmpty()) {\r\n\t\t\t\tshowWarning(getString(R.string.download_index_success));\r\n\t\t\t} else {\r\n\t\t\t\tshowWarning(warnings.get(0));\r\n\t\t\t}\r\n\t\t\treturn true;\r\n\t\t} catch (IOException e) {\r\n\t\t\tlog.error(\"Exception ocurred\", e); //$NON-NLS-1$\r\n\t\t\tshowWarning(getString(R.string.error_io_error));\r\n\t\t\tif(out != null){\r\n\t\t\t\ttry {\r\n\t\t\t\t\tout.close();\r\n\t\t\t\t} catch (IOException e1) {\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// Possibly file is corrupted\r\n\t\t\tfileToDownload.delete();\r\n\t\t\treturn false;\r\n\t\t} catch (InterruptedException e) {\r\n\t\t\t// Possibly file is corrupted\r\n\t\t\tfileToDownload.delete();\r\n\t\t\tthrow e;\r\n\t\t}\r\n\t}","commit_id":"aed5ca28aa2f0f0765d3ca13957eefa511966037","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n    * Look up the {@link HTextFlowTarget} for the given hLocale in hTextFlow,\n    * creating a new one if none is present.\n    */\n   private HTextFlowTarget getOrCreateTarget(HTextFlow hTextFlow, HLocale hLocale)\n   {\n      HTextFlowTarget hTextFlowTarget = hTextFlow.getTargets().get(hLocale);\n\n      if (hTextFlowTarget == null)\n      {\n         hTextFlowTarget = new HTextFlowTarget(hTextFlow, hLocale);\n         hTextFlowTarget.setVersionNum(0); // this will be incremented when content is set (below)\n         hTextFlow.getTargets().put(hLocale, hTextFlowTarget);\n         entityManager.persist(hTextFlowTarget);\n      }\n      return hTextFlowTarget;\n   }","id":78977,"modified_method":"/**\n    * Look up the {@link HTextFlowTarget} for the given hLocale in hTextFlow,\n    * creating a new one if none is present.\n    */\n   private HTextFlowTarget getOrCreateTarget(HTextFlow hTextFlow, HLocale hLocale)\n   {\n      HTextFlowTarget hTextFlowTarget = hTextFlow.getTargets().get(hLocale);\n\n      if (hTextFlowTarget == null)\n      {\n         hTextFlowTarget = new HTextFlowTarget(hTextFlow, hLocale);\n         hTextFlowTarget.setVersionNum(0); // this will be incremented when content is set (below)\n         hTextFlow.getTargets().put(hLocale, hTextFlowTarget);\n      }\n      return hTextFlowTarget;\n   }","commit_id":"900d3a13b60045a72aa30e6ab0604ffdd18245d4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public List<TranslationResult> translate(LocaleId localeId, List<TransUnitUpdateRequest> translationRequests)\n   {\n      List<TranslationResult> results = new ArrayList<TranslationResult>();\n\n      //avoid locale check if there is nothing to translate\n      if (translationRequests.isEmpty())\n      {\n         return results;\n      }\n\n      //single locale check - assumes update requests are all from the same project-iteration\n      HTextFlow sampleHTextFlow = (HTextFlow) session.get(HTextFlow.class, translationRequests.get(0).getTransUnitId().getValue());\n      HLocale hLocale = validateLocale(localeId, sampleHTextFlow);\n      for (TransUnitUpdateRequest request : translationRequests)\n      {\n         HTextFlow hTextFlow = (HTextFlow) session.get(HTextFlow.class, request.getTransUnitId().getValue());\n         HTextFlowTarget hTextFlowTarget = getOrCreateTarget(hTextFlow, hLocale);\n\n         TranslationResultImpl result = new TranslationResultImpl();\n         result.baseVersion = hTextFlowTarget.getVersionNum();\n         result.baseContentState = hTextFlowTarget.getState();\n\n         if (request.getBaseTranslationVersion() == hTextFlowTarget.getVersionNum())\n         {\n            try\n            {\n               int nPlurals = getNumPlurals(hLocale, hTextFlow);\n               translate(hTextFlowTarget, request.getNewContents(), request.getNewContentState(), nPlurals);\n               result.isSuccess = true;\n            }\n            catch (HibernateException e)\n            {\n               result.isSuccess = false;\n               log.warn(\"HibernateException while translating\");\n            }\n         }\n         else\n         {\n            // concurrent edits not allowed\n            log.warn(\"translation failed for textflow {0}: base versionNum {1} does not match current versionNum {2}\", hTextFlow.getId() , request.getBaseTranslationVersion(), hTextFlowTarget.getVersionNum());\n            result.isSuccess = false;\n         }\n         result.translatedTextFlowTarget = hTextFlowTarget;\n         results.add(result);\n      }\n\n      return results;\n   }","id":78978,"modified_method":"@Override\n   public List<TranslationResult> translate(LocaleId localeId, List<TransUnitUpdateRequest> translationRequests)\n   {\n      List<TranslationResult> results = new ArrayList<TranslationResult>();\n\n      //avoid locale check if there is nothing to translate\n      if (translationRequests.isEmpty())\n      {\n         return results;\n      }\n\n      //single locale check - assumes update requests are all from the same project-iteration\n      HTextFlow sampleHTextFlow = entityManager.find(HTextFlow.class, translationRequests.get(0).getTransUnitId().getValue());\n      HLocale hLocale = validateLocale(localeId, sampleHTextFlow);\n      for (TransUnitUpdateRequest request : translationRequests)\n      {\n         HTextFlow hTextFlow = entityManager.find(HTextFlow.class, request.getTransUnitId().getValue());\n         HTextFlowTarget hTextFlowTarget = getOrCreateTarget(hTextFlow, hLocale);\n\n         TranslationResultImpl result = new TranslationResultImpl();\n         result.baseVersion = hTextFlowTarget.getVersionNum();\n         result.baseContentState = hTextFlowTarget.getState();\n\n         if (request.getBaseTranslationVersion() == hTextFlowTarget.getVersionNum())\n         {\n            try\n            {\n               int nPlurals = getNumPlurals(hLocale, hTextFlow);\n               translate(hTextFlowTarget, request.getNewContents(), request.getNewContentState(), nPlurals);\n               result.isSuccess = true;\n            }\n            catch (HibernateException e)\n            {\n               result.isSuccess = false;\n               log.warn(\"HibernateException while translating\");\n            }\n         }\n         else\n         {\n            // concurrent edits not allowed\n            log.warn(\"translation failed for textflow {0}: base versionNum {1} does not match current versionNum {2}\", hTextFlow.getId() , request.getBaseTranslationVersion(), hTextFlowTarget.getVersionNum());\n            result.isSuccess = false;\n         }\n         result.translatedTextFlowTarget = hTextFlowTarget;\n         results.add(result);\n      }\n\n      return results;\n   }","commit_id":"900d3a13b60045a72aa30e6ab0604ffdd18245d4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public List<TranslationResult> revertTranslations(LocaleId localeId, List<TransUnitUpdateInfo> translationsToRevert)\n   {\n      List<TranslationResult> results = new ArrayList<TranslationResult>();\n      List<TransUnitUpdateRequest> updateRequests = new ArrayList<TransUnitUpdateRequest>();\n      if (!translationsToRevert.isEmpty())\n      {\n\n         HTextFlow sampleHTextFlow = (HTextFlow) session.get(HTextFlow.class, translationsToRevert.get(0).getTransUnit().getId().getValue());\n         HLocale hLocale = validateLocale(localeId, sampleHTextFlow);\n         for (TransUnitUpdateInfo info : translationsToRevert)\n         {\n            TransUnitId tuId = info.getTransUnit().getId();\n            HTextFlow hTextFlow = (HTextFlow) session.get(HTextFlow.class, tuId.getValue());\n            HTextFlowTarget hTextFlowTarget = getOrCreateTarget(hTextFlow, hLocale);\n\n            //check that version has not advanced\n            // TODO probably also want to check that source has not been updated\n            Integer versionNum = hTextFlowTarget.getVersionNum();\n            log.info(\"hTextFlowTarget version {0}, TransUnit version {1}\", versionNum, info.getTransUnit().getVerNum());\n            if (versionNum.equals(info.getTransUnit().getVerNum()))\n            {\n               //look up replaced version\n               HTextFlowTargetHistory oldTarget = hTextFlowTarget.getHistory().get(Integer.valueOf(info.getPreviousVersionNum()));\n               if (oldTarget != null)\n               {\n                  //generate request\n                  List<String> oldContents = oldTarget.getContents();\n                  ContentState oldState = oldTarget.getState();\n                  TransUnitUpdateRequest request = new TransUnitUpdateRequest(tuId, oldContents, oldState, versionNum);\n                  //add to list\n                  updateRequests.add(request);\n               }\n               else\n               {\n                  log.warn(\"got null previous target for tu with id {0}, version {1}. Cannot revert with no previous state.\", hTextFlow.getId(), info.getPreviousVersionNum());\n                  results.add(buildFailResult(hTextFlowTarget));\n               }\n            }\n            else\n            {\n               log.info(\"attempt to revert target version {0} for tu with id {1}, but current version is {2}. Not reverting.\");\n               results.add(buildFailResult(hTextFlowTarget));\n            }\n         }\n      }\n      results.addAll(translate(localeId, updateRequests));\n      return results;\n   }","id":78979,"modified_method":"@Override\n   public List<TranslationResult> revertTranslations(LocaleId localeId, List<TransUnitUpdateInfo> translationsToRevert)\n   {\n      List<TranslationResult> results = new ArrayList<TranslationResult>();\n      List<TransUnitUpdateRequest> updateRequests = new ArrayList<TransUnitUpdateRequest>();\n      if (!translationsToRevert.isEmpty())\n      {\n\n         HTextFlow sampleHTextFlow = entityManager.find(HTextFlow.class, translationsToRevert.get(0).getTransUnit().getId().getValue());\n         HLocale hLocale = validateLocale(localeId, sampleHTextFlow);\n         for (TransUnitUpdateInfo info : translationsToRevert)\n         {\n            TransUnitId tuId = info.getTransUnit().getId();\n            HTextFlow hTextFlow = entityManager.find(HTextFlow.class, tuId.getValue());\n            HTextFlowTarget hTextFlowTarget = getOrCreateTarget(hTextFlow, hLocale);\n\n            //check that version has not advanced\n            // TODO probably also want to check that source has not been updated\n            Integer versionNum = hTextFlowTarget.getVersionNum();\n            log.info(\"hTextFlowTarget version {0}, TransUnit version {1}\", versionNum, info.getTransUnit().getVerNum());\n            if (versionNum.equals(info.getTransUnit().getVerNum()))\n            {\n               //look up replaced version\n               HTextFlowTargetHistory oldTarget = hTextFlowTarget.getHistory().get(Integer.valueOf(info.getPreviousVersionNum()));\n               if (oldTarget != null)\n               {\n                  //generate request\n                  List<String> oldContents = oldTarget.getContents();\n                  ContentState oldState = oldTarget.getState();\n                  TransUnitUpdateRequest request = new TransUnitUpdateRequest(tuId, oldContents, oldState, versionNum);\n                  //add to list\n                  updateRequests.add(request);\n               }\n               else\n               {\n                  log.warn(\"got null previous target for tu with id {0}, version {1}. Cannot revert with no previous state.\", hTextFlow.getId(), info.getPreviousVersionNum());\n                  results.add(buildFailResult(hTextFlowTarget));\n               }\n            }\n            else\n            {\n               log.info(\"attempt to revert target version {0} for tu with id {1}, but current version is {2}. Not reverting.\");\n               results.add(buildFailResult(hTextFlowTarget));\n            }\n         }\n      }\n      results.addAll(translate(localeId, updateRequests));\n      return results;\n   }","commit_id":"900d3a13b60045a72aa30e6ab0604ffdd18245d4","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public TranslationResult translate(LocaleId localeId, TransUnitUpdateRequest translateRequest) throws ConcurrentTranslationException\n   {\n      HTextFlow hTextFlow = (HTextFlow) session.get(HTextFlow.class, translateRequest.getTransUnitId().getValue());\n      HLocale hLocale = validateLocale(localeId, hTextFlow);\n      HTextFlowTarget hTextFlowTarget = getOrCreateTarget(hTextFlow, hLocale);\n\n      if (translateRequest.getBaseTranslationVersion() != hTextFlowTarget.getVersionNum())\n      {\n         log.warn(\"translation failed for textflow {0}: base versionNum {1} does not match current versionNum {2}\", hTextFlow.getId() , translateRequest.getBaseTranslationVersion(), hTextFlowTarget.getVersionNum());\n         throw new ConcurrentTranslationException(MessageFormat.format(\"base translation version num {0} does not match current version num {1}, aborting\", translateRequest.getBaseTranslationVersion(), hTextFlowTarget.getVersionNum()));\n      }\n\n      TranslationResultImpl result = new TranslationResultImpl();\n      result.baseVersion = hTextFlowTarget.getVersionNum();\n      result.baseContentState = hTextFlowTarget.getState();\n\n      int nPlurals = getNumPlurals(hLocale, hTextFlow);\n      translate(hTextFlowTarget, translateRequest.getNewContents(), translateRequest.getNewContentState(), nPlurals);\n\n      result.translatedTextFlowTarget = hTextFlowTarget;\n      result.isSuccess = true;\n      return result;\n   }","id":78980,"modified_method":"@Override\n   public TranslationResult translate(LocaleId localeId, TransUnitUpdateRequest translateRequest) throws ConcurrentTranslationException\n   {\n      HTextFlow hTextFlow = entityManager.find(HTextFlow.class, translateRequest.getTransUnitId().getValue());\n      HLocale hLocale = validateLocale(localeId, hTextFlow);\n      HTextFlowTarget hTextFlowTarget = getOrCreateTarget(hTextFlow, hLocale);\n\n      if (translateRequest.getBaseTranslationVersion() != hTextFlowTarget.getVersionNum())\n      {\n         log.warn(\"translation failed for textflow {0}: base versionNum {1} does not match current versionNum {2}\", hTextFlow.getId() , translateRequest.getBaseTranslationVersion(), hTextFlowTarget.getVersionNum());\n         throw new ConcurrentTranslationException(MessageFormat.format(\"base translation version num {0} does not match current version num {1}, aborting\", translateRequest.getBaseTranslationVersion(), hTextFlowTarget.getVersionNum()));\n      }\n\n      TranslationResultImpl result = new TranslationResultImpl();\n      result.baseVersion = hTextFlowTarget.getVersionNum();\n      result.baseContentState = hTextFlowTarget.getState();\n\n      int nPlurals = getNumPlurals(hLocale, hTextFlow);\n      translate(hTextFlowTarget, translateRequest.getNewContents(), translateRequest.getNewContentState(), nPlurals);\n\n      result.translatedTextFlowTarget = hTextFlowTarget;\n      result.isSuccess = true;\n      return result;\n   }","commit_id":"900d3a13b60045a72aa30e6ab0604ffdd18245d4","url":"https://github.com/zanata/zanata-server"},{"original_method":"public DevKit getDevKit(String namespace) {\n    List<IModule> modules = myUIDToModulesMap.get(namespace);\n    if (modules == null || modules.isEmpty()) return null;\n    return modulesAs(DevKit.class, modules);\n  }","id":78981,"modified_method":"public DevKit getDevKit(String namespace) {\n    return (DevKit) myUIDToModulesMap.get(namespace);\n  }","commit_id":"af08925eea5ee30e3f60346408bf7018ab84550d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@UseCarefully\n  public void renameUID(Language l, String newUID) {\n    IFile descriptorFile = l.getDescriptorFile();\n    if (descriptorFile != null) {\n      myFileToModuleMap.remove(descriptorFile.getCanonicalPath());\n    }\n    myUIDToModulesMap.get(l.getNamespace()).remove(l);\n\n    List<IModule> modules = myUIDToModulesMap.get(newUID);\n    if (modules == null) {\n      modules = new ArrayList<IModule>(1);\n      myUIDToModulesMap.put(newUID, modules);\n    }\n    modules.add(l);\n    myFileToModuleMap.put(l.newDescriptorFileByNewName(newUID).getCanonicalPath(), l);\n  }","id":78982,"modified_method":"@UseCarefully\n  public void renameUID(Language l, String newUID) {\n    IFile descriptorFile = l.getDescriptorFile();\n    if (descriptorFile != null) {\n      myFileToModuleMap.remove(descriptorFile.getCanonicalPath());\n    }\n    myUIDToModulesMap.remove(l.getNamespace());\n\n    if (myUIDToModulesMap.containsKey(newUID)) {\n      throw new IllegalStateException(\"Can't rename \" + l + \" to \" + newUID);\n    }\n\n    myUIDToModulesMap.put(l.getModuleUID(), l);\n    myFileToModuleMap.put(l.newDescriptorFileByNewName(newUID).getCanonicalPath(), l);\n  }","commit_id":"af08925eea5ee30e3f60346408bf7018ab84550d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void removeModuleFromUIDMap(IModule module) {\n    List<IModule> modules = myUIDToModulesMap.get(module.getModuleUID());\n    if (modules != null) {\n      modules.remove(module);\n    }\n  }","id":78983,"modified_method":"private void removeModuleFromUIDMap(IModule module) {\n    myUIDToModulesMap.remove(module.getModuleUID());\n  }","commit_id":"af08925eea5ee30e3f60346408bf7018ab84550d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public IModule getModuleByUID(String moduleUID) {\n    List<IModule> modules = myUIDToModulesMap.get(moduleUID);\n    if (modules == null || modules.isEmpty()) return null;\n    return modules.get(0);\n  }","id":78984,"modified_method":"public IModule getModuleByUID(String moduleUID) {\n    return myUIDToModulesMap.get(moduleUID);\n  }","commit_id":"af08925eea5ee30e3f60346408bf7018ab84550d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Language getLanguage(String namespace) {\n    List<IModule> modules = myUIDToModulesMap.get(namespace);\n    if (modules == null || modules.isEmpty()) return null;\n    return modulesAs(Language.class, modules);\n  }","id":78985,"modified_method":"public Language getLanguage(String namespace) {\n    return (Language) myUIDToModulesMap.get(namespace);\n  }","commit_id":"af08925eea5ee30e3f60346408bf7018ab84550d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void putModuleWithUID(String moduleUID, IModule module) {\n\n    List<IModule> modulesWithUID = myUIDToModulesMap.get(moduleUID);\n    if (modulesWithUID == null) {\n      modulesWithUID = new ArrayList<IModule>(1);\n      myUIDToModulesMap.put(moduleUID, modulesWithUID);\n    }\n    if (modulesWithUID.size() > 1) {\n      LOG.error(\"can't add module \" + moduleUID + \" : module with the same UID exists at \" + modulesWithUID.get(0).getDescriptorFile() + \" and \" + module.getDescriptorFile(), modulesWithUID.get(0));\n    }\n    if (modulesWithUID.size() == 1 && modulesWithUID.get(0) != module) {\n      LOG.error(\"can't add module \" + moduleUID + \" : module with the same UID exists at \" + modulesWithUID.get(0).getDescriptorFile() + \" and \" + module.getDescriptorFile(), modulesWithUID.get(0));\n    }\n    modulesWithUID.add(module);\n  }","id":78986,"modified_method":"private void putModuleWithUID(String moduleUID, IModule module) {\n\n    if (myUIDToModulesMap.containsKey(moduleUID)) {\n      IModule m = myUIDToModulesMap.get(moduleUID);\n      LOG.error(\"can't add module \" + moduleUID + \" : module with the same UID exists at \" + m.getDescriptorFile() + \" and \" + module.getDescriptorFile(), m);\n    }\n\n    myUIDToModulesMap.put(moduleUID, module);\n  }","commit_id":"af08925eea5ee30e3f60346408bf7018ab84550d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Solution getSolution(String namespace) {\n    List<IModule> modules = myUIDToModulesMap.get(namespace);\n    if (modules == null || modules.isEmpty()) return null;\n    return modulesAs(Solution.class, modules);\n  }","id":78987,"modified_method":"public Solution getSolution(String namespace) {\n    return (Solution) myUIDToModulesMap.get(namespace);\n  }","commit_id":"af08925eea5ee30e3f60346408bf7018ab84550d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public PortletBag create(Portlet portlet) throws Exception {\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\tif (!portletApp.isWARFile() && _warFile) {\n\t\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\t\t_servletContext = ServletContextPool.get(contextPath);\n\n\t\t\t_classLoader = PortalClassLoaderUtil.getClassLoader();\n\t\t}\n\n\t\tClass<?> portletClass = null;\n\n\t\ttry {\n\t\t\tportletClass = _classLoader.loadClass(portlet.getPortletClass());\n\t\t}\n\t\tcatch (Throwable e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tPortletLocalServiceUtil.destroyPortlet(portlet);\n\n\t\t\treturn null;\n\t\t}\n\n\t\tjavax.portlet.Portlet portletInstance =\n\t\t\t(javax.portlet.Portlet)portletClass.newInstance();\n\n\t\tConfigurationAction configurationActionInstance =\n\t\t\tnewConfigurationAction(portlet);\n\n\t\tIndexer indexerInstance = newIndexer(portlet);\n\n\t\tOpenSearch openSearchInstance = newOpenSearch(portlet);\n\n\t\tinitSchedulers(portlet);\n\n\t\tFriendlyURLMapper friendlyURLMapperInstance = newFriendlyURLMapper(\n\t\t\tportlet);\n\n\t\tURLEncoder urlEncoderInstance = newURLEncoder(portlet);\n\n\t\tPortletDataHandler portletDataHandlerInstance = newPortletDataHandler(\n\t\t\tportlet);\n\n\t\tPortletLayoutListener portletLayoutListenerInstance =\n\t\t\tnewPortletLayoutListener(portlet);\n\n\t\tPollerProcessor pollerProcessorInstance = newPollerProcessor(portlet);\n\n\t\tMessageListener popMessageListenerInstance = newPOPMessageListener(\n\t\t\tportlet);\n\n\t\tSocialActivityInterpreter socialActivityInterpreterInstance =\n\t\t\tinitSocialActivityInterpreterInstance(portlet);\n\n\t\tSocialRequestInterpreter socialRequestInterpreterInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getSocialRequestInterpreterClass())) {\n\t\t\tsocialRequestInterpreterInstance =\n\t\t\t\t(SocialRequestInterpreter)newInstance(\n\t\t\t\t\tSocialRequestInterpreter.class,\n\t\t\t\t\tportlet.getSocialRequestInterpreterClass());\n\n\t\t\tsocialRequestInterpreterInstance = new SocialRequestInterpreterImpl(\n\t\t\t\tportlet.getPortletId(), socialRequestInterpreterInstance);\n\n\t\t\tSocialRequestInterpreterLocalServiceUtil.addRequestInterpreter(\n\t\t\t\tsocialRequestInterpreterInstance);\n\t\t}\n\n\t\tWebDAVStorage webDAVStorageInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getWebDAVStorageClass())) {\n\t\t\twebDAVStorageInstance = (WebDAVStorage)newInstance(\n\t\t\t\tWebDAVStorage.class, portlet.getWebDAVStorageClass());\n\n\t\t\twebDAVStorageInstance.setToken(portlet.getWebDAVStorageToken());\n\n\t\t\tWebDAVUtil.addStorage(webDAVStorageInstance);\n\t\t}\n\n\t\tMethod xmlRpcMethodInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getXmlRpcMethodClass())) {\n\t\t\txmlRpcMethodInstance = (Method)newInstance(\n\t\t\t\tMethod.class, portlet.getXmlRpcMethodClass());\n\n\t\t\tXmlRpcServlet.registerMethod(xmlRpcMethodInstance);\n\t\t}\n\n\t\tControlPanelEntry controlPanelEntryInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getControlPanelEntryClass())) {\n\t\t\tcontrolPanelEntryInstance = (ControlPanelEntry)newInstance(\n\t\t\t\tControlPanelEntry.class, portlet.getControlPanelEntryClass());\n\t\t}\n\n\t\tList<AssetRendererFactory> assetRendererFactoryInstances =\n\t\t\tnewAssetRendererFactoryInstances(portlet);\n\n\t\tList<CustomAttributesDisplay> customAttributesDisplayInstances =\n\t\t\tnew ArrayList<CustomAttributesDisplay>();\n\n\t\tfor (String customAttributesDisplayClass :\n\t\t\t\tportlet.getCustomAttributesDisplayClasses()) {\n\n\t\t\tCustomAttributesDisplay customAttributesDisplayInstance =\n\t\t\t\t(CustomAttributesDisplay)newInstance(\n\t\t\t\t\tCustomAttributesDisplay.class,\n\t\t\t\t\tcustomAttributesDisplayClass);\n\n\t\t\tcustomAttributesDisplayInstance.setClassNameId(\n\t\t\t\tPortalUtil.getClassNameId(\n\t\t\t\t\tcustomAttributesDisplayInstance.getClassName()));\n\t\t\tcustomAttributesDisplayInstance.setPortletId(\n\t\t\t\tportlet.getPortletId());\n\n\t\t\tcustomAttributesDisplayInstances.add(\n\t\t\t\tcustomAttributesDisplayInstance);\n\t\t}\n\n\t\tList<WorkflowHandler> workflowHandlerInstances =\n\t\t\tnew ArrayList<WorkflowHandler>();\n\n\t\tfor (String workflowHandlerClass :\n\t\t\t\tportlet.getWorkflowHandlerClasses()) {\n\n\t\t\tWorkflowHandler workflowHandlerInstance =\n\t\t\t\t(WorkflowHandler)newInstance(\n\t\t\t\t\tWorkflowHandler.class, workflowHandlerClass);\n\n\t\t\tworkflowHandlerInstances.add(workflowHandlerInstance);\n\n\t\t\tWorkflowHandlerRegistryUtil.register(workflowHandlerInstance);\n\t\t}\n\n\t\tPreferencesValidator preferencesValidatorInstance = null;\n\n\t\tif (Validator.isNotNull(portlet.getPreferencesValidator())) {\n\t\t\tpreferencesValidatorInstance = (PreferencesValidator)newInstance(\n\t\t\t\tPreferencesValidator.class, portlet.getPreferencesValidator());\n\n\t\t\ttry {\n\t\t\t\tif (PropsValues.PREFERENCE_VALIDATE_ON_STARTUP) {\n\t\t\t\t\tpreferencesValidatorInstance.validate(\n\t\t\t\t\t\tPortletPreferencesSerializer.fromDefaultXML(\n\t\t\t\t\t\t\tportlet.getDefaultPreferences()));\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Portlet with the name \" + portlet.getPortletId() +\n\t\t\t\t\t\t\" does not have valid default preferences\");\n\t\t\t}\n\t\t}\n\n\t\tMap<String, ResourceBundle> resourceBundles = null;\n\n\t\tif (Validator.isNotNull(portlet.getResourceBundle())) {\n\t\t\tresourceBundles = new HashMap<String, ResourceBundle>();\n\n\t\t\tinitResourceBundle(\n\t\t\t\tresourceBundles, portlet, LocaleUtil.getDefault());\n\n\t\t\tSet<String> supportedLocales = portlet.getSupportedLocales();\n\n\t\t\tif (supportedLocales.isEmpty()) {\n\t\t\t\tsupportedLocales = SetUtil.fromArray(PropsValues.LOCALES);\n\t\t\t}\n\n\t\t\tfor (String supportedLocale : supportedLocales) {\n\t\t\t\tLocale locale = LocaleUtil.fromLanguageId(supportedLocale);\n\n\t\t\t\tinitResourceBundle(resourceBundles, portlet, locale);\n\t\t\t}\n\t\t}\n\n\t\tPortletBag portletBag = new PortletBagImpl(\n\t\t\tportlet.getPortletId(), _servletContext, portletInstance,\n\t\t\tconfigurationActionInstance, indexerInstance, openSearchInstance,\n\t\t\tfriendlyURLMapperInstance, urlEncoderInstance,\n\t\t\tportletDataHandlerInstance, portletLayoutListenerInstance,\n\t\t\tpollerProcessorInstance, popMessageListenerInstance,\n\t\t\tsocialActivityInterpreterInstance, socialRequestInterpreterInstance,\n\t\t\twebDAVStorageInstance, xmlRpcMethodInstance,\n\t\t\tcontrolPanelEntryInstance, assetRendererFactoryInstances,\n\t\t\tcustomAttributesDisplayInstances, workflowHandlerInstances,\n\t\t\tpreferencesValidatorInstance, resourceBundles);\n\n\t\tPortletBagPool.put(portlet.getPortletId(), portletBag);\n\n\t\ttry {\n\t\t\tPortletInstanceFactoryUtil.create(portlet, _servletContext);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn portletBag;\n\t}","id":78988,"modified_method":"public PortletBag create(Portlet portlet) throws Exception {\n\t\treturn create(portlet, false);\n\t}","commit_id":"240194731970c5a1a86bce5a36e5a4f7b8e8581e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void clear(Portlet portlet) {\n\t\tMap<String, InvokerPortlet> portletInstances = _pool.get(\n\t\t\tportlet.getRootPortletId());\n\n\t\tif (portletInstances != null) {\n\t\t\tIterator<Map.Entry<String, InvokerPortlet>> itr =\n\t\t\t\tportletInstances.entrySet().iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tMap.Entry<String, InvokerPortlet> entry = itr.next();\n\n\t\t\t\tString portletId = entry.getKey();\n\t\t\t\tInvokerPortlet invokerPortletInstance = entry.getValue();\n\n\t\t\t\tif (PortletConstants.getInstanceId(portletId) == null) {\n\t\t\t\t\tinvokerPortletInstance.destroy();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_pool.remove(portlet.getRootPortletId());\n\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\tif (portletApp.isWARFile()) {\n\t\t\tPortletBag portletBag = PortletBagPool.get(\n\t\t\t\tportlet.getRootPortletId());\n\n\t\t\tif (portletBag != null) {\n\t\t\t\tportletBag.setPortletInstance(null);\n\t\t\t}\n\t\t}\n\t}","id":78989,"modified_method":"public void clear(Portlet portlet) {\n\t\tMap<String, InvokerPortlet> portletInstances = _pool.get(\n\t\t\tportlet.getRootPortletId());\n\n\t\tif (portletInstances != null) {\n\t\t\tIterator<Map.Entry<String, InvokerPortlet>> itr =\n\t\t\t\tportletInstances.entrySet().iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tMap.Entry<String, InvokerPortlet> entry = itr.next();\n\n\t\t\t\tString portletId = entry.getKey();\n\t\t\t\tInvokerPortlet invokerPortletInstance = entry.getValue();\n\n\t\t\t\tif (PortletConstants.getInstanceId(portletId) == null) {\n\t\t\t\t\tinvokerPortletInstance.destroy();\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t_pool.remove(portlet.getRootPortletId());\n\n\t\tPortletApp portletApp = portlet.getPortletApp();\n\n\t\tif (portletApp.isWARFile()) {\n\t\t\tPortletBagPool.remove(portlet.getRootPortletId());\n\t\t}\n\t}","commit_id":"240194731970c5a1a86bce5a36e5a4f7b8e8581e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public InvokerPortlet create(Portlet portlet, ServletContext servletContext)\n\t\tthrows PortletException {\n\n\t\tboolean instanceable = false;\n\n\t\tif ((portlet.isInstanceable()) &&\n\t\t\t(PortletConstants.getInstanceId(portlet.getPortletId()) != null)) {\n\n\t\t\tinstanceable = true;\n\t\t}\n\n\t\tMap<String, InvokerPortlet> portletInstances = _pool.get(\n\t\t\tportlet.getRootPortletId());\n\n\t\tif (portletInstances == null) {\n\t\t\tportletInstances = new ConcurrentHashMap<String, InvokerPortlet>();\n\n\t\t\t_pool.put(portlet.getRootPortletId(), portletInstances);\n\t\t}\n\n\t\tInvokerPortlet instanceInvokerPortletInstance = null;\n\n\t\tif (instanceable) {\n\t\t\tinstanceInvokerPortletInstance = portletInstances.get(\n\t\t\t\tportlet.getPortletId());\n\t\t}\n\n\t\tInvokerPortlet rootInvokerPortletInstance = null;\n\n\t\tif (instanceInvokerPortletInstance == null) {\n\t\t\trootInvokerPortletInstance = portletInstances.get(\n\t\t\t\tportlet.getRootPortletId());\n\n\t\t\tif (rootInvokerPortletInstance == null) {\n\t\t\t\tPortletBag portletBag = PortletBagPool.get(\n\t\t\t\t\tportlet.getRootPortletId());\n\n\t\t\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\t\t\tportlet, servletContext);\n\n\t\t\t\trootInvokerPortletInstance = init(\n\t\t\t\t\tportlet, portletConfig, portletBag.getPortletInstance());\n\n\t\t\t\tportletInstances.put(\n\t\t\t\t\tportlet.getRootPortletId(), rootInvokerPortletInstance);\n\t\t\t}\n\t\t}\n\n\t\tif (instanceable) {\n\t\t\tif (instanceInvokerPortletInstance == null) {\n\t\t\t\tjavax.portlet.Portlet portletInstance =\n\t\t\t\t\trootInvokerPortletInstance.getPortletInstance();\n\n\t\t\t\tPortletConfig portletConfig =\n\t\t\t\t\tPortletConfigFactoryUtil.create(portlet, servletContext);\n\n\t\t\t\tPortletContext portletContext =\n\t\t\t\t\tportletConfig.getPortletContext();\n\t\t\t\tboolean checkAuthToken =\n\t\t\t\t\trootInvokerPortletInstance.isCheckAuthToken();\n\t\t\t\tboolean facesPortlet =\n\t\t\t\t\trootInvokerPortletInstance.isFacesPortlet();\n\t\t\t\tboolean strutsPortlet =\n\t\t\t\t\trootInvokerPortletInstance.isStrutsPortlet();\n\t\t\t\tboolean strutsBridgePortlet =\n\t\t\t\t\trootInvokerPortletInstance.isStrutsBridgePortlet();\n\n\t\t\t\tinstanceInvokerPortletInstance =\n\t\t\t\t\t_internalInvokerPortletPrototype.create(\n\t\t\t\t\t\tportlet, portletInstance, portletConfig, portletContext,\n\t\t\t\t\t\tcheckAuthToken, facesPortlet, strutsPortlet,\n\t\t\t\t\t\tstrutsBridgePortlet);\n\n\t\t\t\tportletInstances.put(\n\t\t\t\t\tportlet.getPortletId(), instanceInvokerPortletInstance);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (rootInvokerPortletInstance != null) {\n\t\t\t\tinstanceInvokerPortletInstance = rootInvokerPortletInstance;\n\t\t\t}\n\t\t}\n\n\t\treturn instanceInvokerPortletInstance;\n\t}","id":78990,"modified_method":"public InvokerPortlet create(Portlet portlet, ServletContext servletContext)\n\t\tthrows PortletException {\n\n\t\tboolean instanceable = false;\n\n\t\tif ((portlet.isInstanceable()) &&\n\t\t\t(PortletConstants.getInstanceId(portlet.getPortletId()) != null)) {\n\n\t\t\tinstanceable = true;\n\t\t}\n\n\t\tMap<String, InvokerPortlet> portletInstances = _pool.get(\n\t\t\tportlet.getRootPortletId());\n\n\t\tif (portletInstances == null) {\n\t\t\tportletInstances = new ConcurrentHashMap<String, InvokerPortlet>();\n\n\t\t\t_pool.put(portlet.getRootPortletId(), portletInstances);\n\t\t}\n\n\t\tInvokerPortlet instanceInvokerPortletInstance = null;\n\n\t\tif (instanceable) {\n\t\t\tinstanceInvokerPortletInstance = portletInstances.get(\n\t\t\t\tportlet.getPortletId());\n\t\t}\n\n\t\tInvokerPortlet rootInvokerPortletInstance = null;\n\n\t\tif (instanceInvokerPortletInstance == null) {\n\t\t\trootInvokerPortletInstance = portletInstances.get(\n\t\t\t\tportlet.getRootPortletId());\n\n\t\t\tif (rootInvokerPortletInstance == null) {\n\t\t\t\tPortletBag portletBag = PortletBagPool.get(\n\t\t\t\t\tportlet.getRootPortletId());\n\n\t\t\t\tif (portletBag == null) {\n\t\t\t\t\tPortletBagFactory portletBagFactory =\n\t\t\t\t\t\tnew PortletBagFactory();\n\n\t\t\t\t\tportletBagFactory.setClassLoader(\n\t\t\t\t\t\tgetClass().getClassLoader());\n\t\t\t\t\tportletBagFactory.setServletContext(servletContext);\n\t\t\t\t\tportletBagFactory.setWARFile(false);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tportletBag = portletBagFactory.create(portlet, true);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tthrow new PortletException(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tPortletBagPool.put(portlet.getRootPortletId(), portletBag);\n\t\t\t\t}\n\n\t\t\t\tPortletConfig portletConfig = PortletConfigFactoryUtil.create(\n\t\t\t\t\tportlet, servletContext);\n\n\t\t\t\trootInvokerPortletInstance = init(\n\t\t\t\t\tportlet, portletConfig, portletBag.getPortletInstance());\n\n\t\t\t\tportletInstances.put(\n\t\t\t\t\tportlet.getRootPortletId(), rootInvokerPortletInstance);\n\t\t\t}\n\t\t}\n\n\t\tif (instanceable) {\n\t\t\tif (instanceInvokerPortletInstance == null) {\n\t\t\t\tjavax.portlet.Portlet portletInstance =\n\t\t\t\t\trootInvokerPortletInstance.getPortletInstance();\n\n\t\t\t\tPortletConfig portletConfig =\n\t\t\t\t\tPortletConfigFactoryUtil.create(portlet, servletContext);\n\n\t\t\t\tPortletContext portletContext =\n\t\t\t\t\tportletConfig.getPortletContext();\n\t\t\t\tboolean checkAuthToken =\n\t\t\t\t\trootInvokerPortletInstance.isCheckAuthToken();\n\t\t\t\tboolean facesPortlet =\n\t\t\t\t\trootInvokerPortletInstance.isFacesPortlet();\n\t\t\t\tboolean strutsPortlet =\n\t\t\t\t\trootInvokerPortletInstance.isStrutsPortlet();\n\t\t\t\tboolean strutsBridgePortlet =\n\t\t\t\t\trootInvokerPortletInstance.isStrutsBridgePortlet();\n\n\t\t\t\tinstanceInvokerPortletInstance =\n\t\t\t\t\t_internalInvokerPortletPrototype.create(\n\t\t\t\t\t\tportlet, portletInstance, portletConfig, portletContext,\n\t\t\t\t\t\tcheckAuthToken, facesPortlet, strutsPortlet,\n\t\t\t\t\t\tstrutsBridgePortlet);\n\n\t\t\t\tportletInstances.put(\n\t\t\t\t\tportlet.getPortletId(), instanceInvokerPortletInstance);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (rootInvokerPortletInstance != null) {\n\t\t\t\tinstanceInvokerPortletInstance = rootInvokerPortletInstance;\n\t\t\t}\n\t\t}\n\n\t\treturn instanceInvokerPortletInstance;\n\t}","commit_id":"240194731970c5a1a86bce5a36e5a4f7b8e8581e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * @see wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#removePage(java.lang.String,\n\t *      wicket.Page)\n\t */\n\tpublic void removePage(String sessionId, Page page)\n\t{\n\t\tsynchronized (storePageMap)\n\t\t{\n\t\t\tstorePageMap.put(new SessionPageKey(sessionId, page,true), page);\n\t\t\tstorePageMap.notifyAll();\n\t\t}\n\t}","id":78991,"modified_method":"/**\n\t * @see wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#removePage(java.lang.String,\n\t *      wicket.Page)\n\t */\n\tpublic void removePage(String sessionId, Page page)\n\t{\n\t\tremovePageFromPendingMap(sessionId,page.getNumericId());\n\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see java.lang.Object#equals(java.lang.Object)\n\t\t */\n\t\tpublic boolean equals(Object obj)\n\t\t{\n\t\t\tif (obj instanceof SessionPageKey)\n\t\t\t{\n\t\t\t\tSessionPageKey key = (SessionPageKey)obj;\n\t\t\t\treturn id == key.id && versionNumber == key.versionNumber\n\t\t\t\t\t\t&& sessionId.equals(key.sessionId) && remove == key.remove;\n\t\t\t}\n\t\t\treturn false;\n\t\t}","id":78992,"modified_method":"/**\n\t\t * @see java.lang.Object#equals(java.lang.Object)\n\t\t */\n\t\tpublic boolean equals(Object obj)\n\t\t{\n\t\t\tif (obj instanceof SessionPageKey)\n\t\t\t{\n\t\t\t\tSessionPageKey key = (SessionPageKey)obj;\n\t\t\t\treturn id == key.id && versionNumber == key.versionNumber\n\t\t\t\t\t\t&& ajaxVersionNumber == key.ajaxVersionNumber\n\t\t\t\t\t\t&& ((pageMap != null && pageMap.equals(key.pageMap)) || (pageMap == null && key.pageMap == null)) \n\t\t\t\t\t\t&& sessionId.equals(key.sessionId);\n\t\t\t}\n\t\t\treturn false;\n\t\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#getPage(java.lang.String,\n\t *      int, int)\n\t */\n\tpublic Page getPage(String sessionId, int id, int versionNumber, int ajaxVersionNumber)\n\t{\n\t\tbyte[] bytes = testMap(sessionId, id, versionNumber,ajaxVersionNumber);\n\t\tif(bytes != null)\n\t\t{\n\t\t\tPage page = (Page)Objects.byteArrayToObject(bytes);\n\t\t\tpage = page.getVersion(versionNumber);\n\t\t\treturn page; \n\t\t}\n\t\tFile sessionDir = new File(getWorkDir(), sessionId);\n\t\tif (sessionDir.exists())\n\t\t{\n\t\t\tFile pageFile = getPageFile(id, versionNumber, ajaxVersionNumber, sessionDir);\n\t\t\tif (pageFile.exists())\n\t\t\t{\n\t\t\t\tlong t1 = System.currentTimeMillis();\n\t\t\t\tFileInputStream fis = null;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tbyte[] pageData = null;\n\t\t\t\t\tfis = new FileInputStream(pageFile);\n\t\t\t\t\tint length = (int)pageFile.length();\n\t\t\t\t\tByteBuffer bb = ByteBuffer.allocate(length);\n\t\t\t\t\tfis.getChannel().read(bb);\n\t\t\t\t\tif (bb.hasArray())\n\t\t\t\t\t{\n\t\t\t\t\t\tpageData = bb.array();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpageData = new byte[length];\n\t\t\t\t\t\tbb.get(pageData);\n\t\t\t\t\t}\n\t\t\t\t\tlong t2 = System.currentTimeMillis();\n\t\t\t\t\tPage page = (Page)Objects.byteArrayToObject(pageData);\n\t\t\t\t\tpage = page.getVersion(versionNumber);\n\t\t\t\t\tif (page != null && log.isDebugEnabled())\n\t\t\t\t\t{\n\t\t\t\t\t\tlong t3 = System.currentTimeMillis();\n\t\t\t\t\t\tlog.debug(\"restoring page \" + page.getClass() + \"[\" + page.getNumericId()\n\t\t\t\t\t\t\t\t+ \",\" + page.getCurrentVersionNumber() + \"] size: \"\n\t\t\t\t\t\t\t\t+ pageData.length + \" for session \" + sessionId + \" took \"\n\t\t\t\t\t\t\t\t+ (t2 - t1) + \" miliseconds to read in and \" + (t3 - t2)\n\t\t\t\t\t\t\t\t+ \" miliseconds to deserialize\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn page;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\"Error loading page \" + id + \",\" + versionNumber\n\t\t\t\t\t\t\t+ \" for the sessionid \" + sessionId + \" from disk\", e);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fis != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfis.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":78993,"modified_method":"/**\n\t * @see wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#getPage(java.lang.String,\n\t *      int, int)\n\t */\n\tpublic Page getPage(String sessionId, String pagemapName, int id, int versionNumber, int ajaxVersionNumber)\n\t{\n\t\tSessionPageKey currentKey = new SessionPageKey(sessionId, id, versionNumber,ajaxVersionNumber,pagemapName ,null);\n\t\tbyte[] bytes = testMap(currentKey);\n\t\tif(bytes != null)\n\t\t{\n\t\t\tPage page = (Page)Objects.byteArrayToObject(bytes);\n\t\t\tpage = page.getVersion(versionNumber);\n\t\t\treturn page; \n\t\t}\n\t\tFile sessionDir = new File(getWorkDir(), sessionId);\n\t\tif (sessionDir.exists())\n\t\t{\n\t\t\tFile pageFile = getPageFile(currentKey, sessionDir);\n\t\t\tif (pageFile.exists())\n\t\t\t{\n\t\t\t\tlong t1 = System.currentTimeMillis();\n\t\t\t\tFileInputStream fis = null;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tbyte[] pageData = null;\n\t\t\t\t\tfis = new FileInputStream(pageFile);\n\t\t\t\t\tint length = (int)pageFile.length();\n\t\t\t\t\tByteBuffer bb = ByteBuffer.allocate(length);\n\t\t\t\t\tfis.getChannel().read(bb);\n\t\t\t\t\tif (bb.hasArray())\n\t\t\t\t\t{\n\t\t\t\t\t\tpageData = bb.array();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpageData = new byte[length];\n\t\t\t\t\t\tbb.get(pageData);\n\t\t\t\t\t}\n\t\t\t\t\tlong t2 = System.currentTimeMillis();\n\t\t\t\t\tPage page = (Page)Objects.byteArrayToObject(pageData);\n\t\t\t\t\tpage = page.getVersion(versionNumber);\n\t\t\t\t\tif (page != null && log.isDebugEnabled())\n\t\t\t\t\t{\n\t\t\t\t\t\tlong t3 = System.currentTimeMillis();\n\t\t\t\t\t\tlog.debug(\"restoring page \" + page.getClass() + \"[\" + page.getNumericId()\n\t\t\t\t\t\t\t\t+ \",\" + page.getCurrentVersionNumber() + \"] size: \"\n\t\t\t\t\t\t\t\t+ pageData.length + \" for session \" + sessionId + \" took \"\n\t\t\t\t\t\t\t\t+ (t2 - t1) + \" miliseconds to read in and \" + (t3 - t2)\n\t\t\t\t\t\t\t\t+ \" miliseconds to deserialize\");\n\t\t\t\t\t}\n\t\t\t\t\treturn page;\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tlog.debug(\"Error loading page \" + id + \",\" + versionNumber\n\t\t\t\t\t\t\t+ \" for the sessionid \" + sessionId + \" from disk\", e);\n\t\t\t\t}\n\t\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tif (fis != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfis.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ex)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ignore\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t\t * @see java.lang.Runnable#run()\n\t\t */\n\t\tpublic void run()\n\t\t{\n\t\t\twhile (!stop)\n\t\t\t{\n\t\t\t\tIterator iterator = null;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\titerator = storePageMap.keySet().iterator();\n\t\t\t\t\tif (!iterator.hasNext())\n\t\t\t\t\t{\n\t\t\t\t\t\tsynchronized (storePageMap)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (stop)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\tstorePageMap.wait();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\twhile (iterator.hasNext())\n\t\t\t\t\t{\n\t\t\t\t\t\tSessionPageKey key = (SessionPageKey)iterator.next();\n\t\t\t\t\t\tObject value = storePageMap.get(key);\n\t\t\t\t\t\t// continue if the value is already null or currently SERIALIZING (by another thread)\n\t\t\t\t\t\tif (value == null || value == SERIALIZING)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (key.remove)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (key.id == -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tremoveSession(key.sessionId);\n\t\t\t\t\t\t\t\t// now remove any other pending save for that\n\t\t\t\t\t\t\t\t// page.\n\t\t\t\t\t\t\t\tremoveSessionFromPendingMap(key.sessionId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tremovePage(key.sessionId, key.id);\n\t\t\t\t\t\t\t\t// now remove any other pending save for that\n\t\t\t\t\t\t\t\t// page.\n\t\t\t\t\t\t\t\tremovePageFromPendingMap(key.sessionId, key.id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbyte[] pageBytes = null;\n\t\t\t\t\t\t\tif ( value instanceof Page)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (storePageMap.put(key, SERIALIZING) == value)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpageBytes = serializePage((Page)value);\n\t\t\t\t\t\t\t\t\tif ( pageBytes != null)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tstorePageMap.put(key, pageBytes);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpageBytes = (byte[])value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ( pageBytes != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsavePage(key, pageBytes);\n\t\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"Error in page save thread\", e);\n\t\t\t\t\t// removing the one that did fail...\n\t\t\t\t\tif (iterator != null)\n\t\t\t\t\t\titerator.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":78994,"modified_method":"/**\n\t\t * @see java.lang.Runnable#run()\n\t\t */\n\t\tpublic void run()\n\t\t{\n\t\t\twhile (!stop)\n\t\t\t{\n\t\t\t\tSessionPageKey key = null;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tObject data = null;\n\t\t\t\t\tsynchronized (storePageMap)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stop)\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\twhile (storePageMap.size() == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstorePageMap.wait();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tkey = (SessionPageKey)storePageMap.get(0);\n\t\t\t\t\t\tdata = key.getObject();\n\t\t\t\t\t\tif ( data instanceof Page)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkey.setObject(SERIALIZING);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbyte[] pageBytes = null;\n\t\t\t\t\tif ( data instanceof Page)\n\t\t\t\t\t{\n\t\t\t\t\t\tpageBytes = serializePage(key,(Page)data);\n\t\t\t\t\t\tsynchronized (key)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkey.setObject(pageBytes);\n\t\t\t\t\t\t\tkey.notifyAll();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if ( data instanceof byte[])\n\t\t\t\t\t{\n\t\t\t\t\t\tpageBytes = (byte[])data;\n\t\t\t\t\t}\n\t\t\t\t\tif ( pageBytes != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tsavePage(key, pageBytes);\n\t\t\t\t\t}\n\t\t\t\t\tif (storePageMap.remove(0) != key)\n\t\t\t\t\t{\n\t\t\t\t\t\tSystem.err.println(\"Remove 0 is not the same!!\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tlog.error(\"Error in page save thread\", e);\n\t\t\t\t\t// removing the one that did fail...\n\t\t\t\t\tstorePageMap.remove(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#unbind(java.lang.String)\n\t */\n\tpublic void unbind(String sessionId)\n\t{\n\t\tsynchronized (storePageMap)\n\t\t{\n\t\t\tSessionPageKey key = new SessionPageKey(sessionId, -1, -1, -1, true,null);\n\t\t\tstorePageMap.put(key, key);\n\t\t\tstorePageMap.notifyAll();\n\t\t}\n\t}","id":78995,"modified_method":"/**\n\t * @see wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#unbind(java.lang.String)\n\t */\n\tpublic void unbind(String sessionId)\n\t{\n\t\tremoveSessionFromPendingMap(sessionId);\n\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Construct.\n\t * \n\t * @param dir\n\t *            The directory to save to.\n\t */\n\tpublic FilePageStore(File dir)\n\t{\n\t\tdefaultWorkDir = dir;\n\t\tstorePageMap = new ConcurrentHashMap();\n\t\tthread = new PageSavingThread();\n\t\tappName = Application.get().getApplicationKey();\n\t\tThread t = new Thread(thread, \"FilePageStoreThread-\" + appName);\n\t\tt.setDaemon(true);\n\t\tt.start();\n\n\t}","id":78996,"modified_method":"/**\n\t * Construct.\n\t * \n\t * @param dir\n\t *            The directory to save to.\n\t */\n\tpublic FilePageStore(File dir)\n\t{\n\t\tdefaultWorkDir = dir;\n\t\tstorePageMap = Collections.synchronizedList(new LinkedList());\n\t\tthread = new PageSavingThread();\n\t\tappName = Application.get().getApplicationKey();\n\t\tThread t = new Thread(thread, \"FilePageStoreThread-\" + appName);\n\t\tt.setDaemon(true);\n\t\tt.start();\n\n\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#storePage(java.lang.String,\n\t *      wicket.Page)\n\t */\n\tpublic void storePage(String sessionId, Page page)\n\t{\n\t\t// if the pagemap falls behind, directly serialize it here.\n\t\tif(storePageMap.size() > 25)\n\t\t{\n\t\t\tbyte[] bytes = serializePage(page);\n\t\t\tif (bytes != null)\n\t\t\t{\n\t\t\t\tstorePageMap.put(new SessionPageKey(sessionId, page,false), bytes);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsynchronized (storePageMap)\n\t\t\t{\n\t\t\t\tstorePageMap.put(new SessionPageKey(sessionId, page,false), page);\n\t\t\t\tstorePageMap.notifyAll();\n\t\t\t}\n\t\t}\n\t}","id":78997,"modified_method":"/**\n\t * @see wicket.protocol.http.SecondLevelCacheSessionStore.IPageStore#storePage(java.lang.String,\n\t *      wicket.Page)\n\t */\n\tpublic void storePage(String sessionId, Page page)\n\t{\n\t\t// if the pagemap falls behind, directly serialize it here.\n\t\tif(storePageMap.size() > 25)\n\t\t{\n\t\t\tSessionPageKey key = new SessionPageKey(sessionId, page);\n\t\t\tbyte[] bytes = serializePage(key,page);\n\t\t\tif (bytes != null)\n\t\t\t{\n\t\t\t\tkey.setObject(bytes);\n\t\t\t\tstorePageMap.add(key);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsynchronized (storePageMap)\n\t\t\t{\n\t\t\t\tstorePageMap.add(new SessionPageKey(sessionId, page));\n\t\t\t\tstorePageMap.notifyAll();\n\t\t\t}\n\t\t}\n\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"private byte[] serializePage(Page page)\n\t{\n\t\tlong t1 = System.currentTimeMillis();\n\t\tbyte[] bytes = Objects.objectToByteArray(page);\n\t\ttotalSerializationTime += (System.currentTimeMillis()-t1);\n\t\treturn bytes;\n\t}","id":78998,"modified_method":"private byte[] serializePage(SessionPageKey key, Page page)\n\t{\n\t\tif (page.getCurrentVersionNumber() != key.versionNumber)\n\t\t{\n\t\t\tSystem.err.println(\"ERROR versionnumber dont match1!\");\n\t\t}\n\t\tlong t1 = System.currentTimeMillis();\n\t\tbyte[] bytes = Objects.objectToByteArray(page);\n\t\ttotalSerializationTime += (System.currentTimeMillis()-t1);\n\t\tif (page.getCurrentVersionNumber() != key.versionNumber)\n\t\t{\n\t\t\tSystem.err.println(\"ERROR versionnumber dont match2!\");\n\t\t}\n\t\treturn bytes;\n\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"},{"original_method":"SessionPageKey(String sessionId, int id, int versionNumber, int ajaxVersionNumber, Class pageClass)\n\t\t{\n\t\t\tthis(sessionId, id, versionNumber, ajaxVersionNumber, false, pageClass);\n\t\t}","id":78999,"modified_method":"SessionPageKey(String sessionId, int id, int versionNumber, int ajaxVersionNumber, String pagemap, Class pageClass)\n\t\t{\n\t\t\tthis(sessionId, id, versionNumber, ajaxVersionNumber, pagemap, pageClass, null);\n\t\t}","commit_id":"78f0193e9b8b811c332bbfea6c1dc1a480184e49","url":"https://github.com/apache/wicket"}]