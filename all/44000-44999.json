[{"original_method":"protected void appendFile(String jsLib) throws MojoExecutionException {\n        // lets copy the kotlin library into the output directory\n        try {\n            final InputStream inputStream = MetaInfServices.loadClasspathResource(jsLib);\n            if (inputStream == null) {\n                System.out.println(\"WARNING: Could not find \" + jsLib + \" on the classpath!\");\n            } else {\n                InputSupplier<InputStream> inputSupplier = new InputSupplier<InputStream>() {\n                    @Override\n                    public InputStream getInput() throws IOException {\n                        return inputStream;\n                    }\n                };\n                String text = \"\\n\" + FileUtil.loadTextAndClose(inputStream);\n                Charset charset = Charset.defaultCharset();\n                Files.append(text, new File(outputFile), charset);\n            }\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage(), e);\n        }\n    }","id":44000,"modified_method":"protected void appendFile(String jsLib, StringBuilder builder) throws MojoExecutionException {\n        // lets copy the kotlin library into the output directory\n        try {\n            final InputStream inputStream = MetaInfServices.loadClasspathResource(jsLib);\n            if (inputStream == null) {\n                System.out.println(\"WARNING: Could not find \" + jsLib + \" on the classpath!\");\n            } else {\n                InputSupplier<InputStream> inputSupplier = new InputSupplier<InputStream>() {\n                    @Override\n                    public InputStream getInput() throws IOException {\n                        return inputStream;\n                    }\n                };\n                String text = \"\\n\" + FileUtil.loadTextAndClose(inputStream);\n                builder.append(text);\n            }\n        } catch (IOException e) {\n            throw new MojoExecutionException(e.getMessage(), e);\n        }\n    }","commit_id":"c09106fe6831446ca42ac68dc9d7923b06f7a4d4","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Creates a shell script for installing and starting up a container.\n     *\n     * @param options\n     * @return\n     * @throws MalformedURLException\n     */\n    public static String buildInstallAndStartScript(CreateContainerOptions options) throws MalformedURLException, URISyntaxException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"#!/bin/bash\").append(\"\\n\");\n        sb.append(RUN_FUNCTION).append(\"\\n\");\n        sb.append(DOWNLOAD_FUNCTION).append(\"\\n\");\n        sb.append(MAVEN_DOWNLOAD_FUNCTION).append(\"\\n\");\n        sb.append(UPDATE_PKGS).append(\"\\n\");\n        sb.append(INSTALL_CURL).append(\"\\n\");\n        sb.append(INSTALL_JDK).append(\"\\n\");\n        sb.append(VALIDATE_REQUIREMENTS).append(\"\\n\");\n        sb.append(EXIT_IF_NOT_EXISTS).append(\"\\n\");\n        sb.append(COPY_NODE_METADATA).append(\"\\n\");\n        sb.append(KARAF_CHECK).append(\"\\n\");\n        sb.append(REPLACE_IN_FILE).append(\"\\n\");\n        sb.append(CONFIGURE_HOSTNAMES).append(\"\\n\");\n        sb.append(\"run mkdir -p ~/containers/ \").append(\"\\n\");\n        sb.append(\"run cd ~/containers/ \").append(\"\\n\");\n        sb.append(\"run mkdir -p \").append(options.getName()).append(\"\\n\");\n        sb.append(\"run cd \").append(options.getName()).append(\"\\n\");\n        //We need admin access to be able to install curl & java.\n        if (options.isAdminAccess()) {\n            //This is not really needed.\n            //Its just here as a silly workaround for some cases which fail to get the first thing installed.\n            sb.append(\"update_pkgs\").append(\"\\n\");\n            sb.append(\"install_openjdk\").append(\"\\n\");\n            sb.append(\"install_curl\").append(\"\\n\");\n        }\n        sb.append(\"validate_requirements\").append(\"\\n\");\n        extractTargzIntoDirectory(sb, options.getProxyUri(), \"org.fusesource.fabric\", \"fuse-fabric\", FabricConstants.FABRIC_VERSION);\n        sb.append(\"run cd `\").append(FIRST_FABRIC_DIRECTORY).append(\"`\\n\");\n        List<String> lines = new ArrayList<String>();\n        String globalResolver = options.getResolver() != null  ? options.getResolver() : ZkDefs.DEFAULT_RESOLVER;\n        lines.add(ZkDefs.GLOBAL_RESOLVER_PROPERTY + \"=\" + options.getResolver());\n        appendFile(sb, \"etc/system.properties\", lines);\n        replaceLineInFile(sb, \"etc/system.properties\", \"karaf.name=root\", \"karaf.name=\" + options.getName());\n        //Apply port range\n        replaceLineInFile(sb, \"etc/org.apache.karaf.shell.cfg\", \"sshPort=\" + DEFAULT_SSH_PORT, \"sshPort=\" + PortUtils.mapPortToRange(DEFAULT_SSH_PORT, options.getMinimumPort(), options.getMaximumPort()));\n        replaceLineInFile(sb, \"etc/org.apache.karaf.management.cfg\", \"rmiRegistryPort = \" + DEFAULT_RMI_REGISTRY_PORT, \"rmiRegistryPort=\" + PortUtils.mapPortToRange(DEFAULT_RMI_REGISTRY_PORT, options.getMinimumPort(), options.getMaximumPort()));\n        replaceLineInFile(sb, \"etc/org.apache.karaf.management.cfg\", \"rmiServerPort = \" + DEFAULT_RMI_SERVER_PORT, \"rmiServerPort=\" + PortUtils.mapPortToRange(DEFAULT_RMI_SERVER_PORT, options.getMinimumPort(), options.getMaximumPort()));\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(ZkDefs.MINIMUM_PORT + \"=\" + options.getMaximumPort()));\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(ZkDefs.MAXIMUM_PORT + \"=\" + options.getMinimumPort()));\n\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(\"\\n\"));\n\n        //Read all system properties\n        for (Map.Entry<String, Properties> entry : options.getSystemProperties().entrySet()) {\n            Properties sysprops = entry.getValue();\n            for (Object type : sysprops.keySet()) {\n                Object value = sysprops.get(type);\n                appendFile(sb, \"etc/system.properties\", Arrays.asList(type + \"=\" + value));\n            }\n        }\n\n        //TODO: Be simple & move all of the code below under system properties MAP.\n        if (options.getPreferredAddress() != null) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(HostUtils.PREFERED_ADDRESS_PROPERTY_NAME + \"=\" + options.getPreferredAddress()));\n        }\n\n        if (options.isEnsembleServer()) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(ZooKeeperClusterService.ENSEMBLE_AUTOSTART + \"=true\"));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(ZooKeeperClusterService.AGENT_AUTOSTART + \"=true\"));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(ZooKeeperClusterService.PROFILES_AUTOIMPORT_PATH + \"=${karaf.home}/fabric/import/\"));\n        } else if (options.getZookeeperUrl() != null) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(\"zookeeper.url = \" + options.getZookeeperUrl()));\n        }\n\n        //Add the proxyURI to the list of repositories\n        if (options.getProxyUri() != null) {\n            appendToLineInFile(sb, \"etc/org.ops4j.pax.url.mvn.cfg\", \"repositories=\", options.getProxyUri().toString() + \",\");\n        }\n        //Just for ensemble servers we want to copy their creation metadata for import.\n        if (options.isEnsembleServer()) {\n            CreateContainerMetadata metadata = options.getMetadataMap().get(options.getName());\n            if (metadata != null) {\n                byte[] metadataPayload = ObjectUtils.toBytes(metadata);\n                if (metadataPayload != null && metadataPayload.length > 0) {\n                    sb.append(\"copy_node_metadata \").append(options.getName()).append(\" \").append(new String(Base64Encoder.encode(metadataPayload))).append(\"\\n\");\n                }\n            }\n        }\n        if (options instanceof CreateJCloudsContainerOptions) {\n            sb.append(\"configure_hostnames\").append(\" \").append(((CreateJCloudsContainerOptions)options).getProviderName()).append(\"\\n\");\n        }\n        if (options.getJvmOpts() != null && !options.getJvmOpts().isEmpty()) {\n            sb.append(\"export JAVA_OPTS=\" + options.getJvmOpts()).append(\"\\n\");\n        }\n        sb.append(\"nohup bin/start &\").append(\"\\n\");\n        sb.append(\"karaf_check `pwd`\").append(\"\\n\");\n        return sb.toString();\n    }","id":44001,"modified_method":"/**\n     * Creates a shell script for installing and starting up a container.\n     *\n     * @param options\n     * @return\n     * @throws MalformedURLException\n     */\n    public static String buildInstallAndStartScript(CreateContainerOptions options) throws MalformedURLException, URISyntaxException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"#!/bin/bash\").append(\"\\n\");\n        sb.append(RUN_FUNCTION).append(\"\\n\");\n        sb.append(DOWNLOAD_FUNCTION).append(\"\\n\");\n        sb.append(MAVEN_DOWNLOAD_FUNCTION).append(\"\\n\");\n        sb.append(UPDATE_PKGS).append(\"\\n\");\n        sb.append(INSTALL_CURL).append(\"\\n\");\n        sb.append(INSTALL_JDK).append(\"\\n\");\n        sb.append(VALIDATE_REQUIREMENTS).append(\"\\n\");\n        sb.append(EXIT_IF_NOT_EXISTS).append(\"\\n\");\n        sb.append(COPY_NODE_METADATA).append(\"\\n\");\n        sb.append(KARAF_CHECK).append(\"\\n\");\n        sb.append(REPLACE_IN_FILE).append(\"\\n\");\n        sb.append(CONFIGURE_HOSTNAMES).append(\"\\n\");\n        sb.append(\"run mkdir -p ~/containers/ \").append(\"\\n\");\n        sb.append(\"run cd ~/containers/ \").append(\"\\n\");\n        sb.append(\"run mkdir -p \").append(options.getName()).append(\"\\n\");\n        sb.append(\"run cd \").append(options.getName()).append(\"\\n\");\n        //We need admin access to be able to install curl & java.\n        if (options.isAdminAccess()) {\n            //This is not really needed.\n            //Its just here as a silly workaround for some cases which fail to get the first thing installed.\n            sb.append(\"update_pkgs\").append(\"\\n\");\n            sb.append(\"install_openjdk\").append(\"\\n\");\n            sb.append(\"install_curl\").append(\"\\n\");\n        }\n        sb.append(\"validate_requirements\").append(\"\\n\");\n        extractTargzIntoDirectory(sb, options.getProxyUri(), \"org.fusesource.fabric\", \"fuse-fabric\", FabricConstants.FABRIC_VERSION);\n        sb.append(\"run cd `\").append(FIRST_FABRIC_DIRECTORY).append(\"`\\n\");\n        List<String> lines = new ArrayList<String>();\n        String globalResolver = options.getResolver() != null  ? options.getResolver() : ZkDefs.DEFAULT_RESOLVER;\n        lines.add(ZkDefs.GLOBAL_RESOLVER_PROPERTY + \"=\" + options.getResolver());\n        appendFile(sb, \"etc/system.properties\", lines);\n        replaceLineInFile(sb, \"etc/system.properties\", \"karaf.name=root\", \"karaf.name=\" + options.getName());\n        //Apply port range\n        replaceLineInFile(sb, \"etc/org.apache.karaf.shell.cfg\", \"sshPort=\" + DEFAULT_SSH_PORT, \"sshPort=\" + PortUtils.mapPortToRange(DEFAULT_SSH_PORT, options.getMinimumPort(), options.getMaximumPort()));\n        replaceLineInFile(sb, \"etc/org.apache.karaf.management.cfg\", \"rmiRegistryPort = \" + DEFAULT_RMI_REGISTRY_PORT, \"rmiRegistryPort=\" + PortUtils.mapPortToRange(DEFAULT_RMI_REGISTRY_PORT, options.getMinimumPort(), options.getMaximumPort()));\n        replaceLineInFile(sb, \"etc/org.apache.karaf.management.cfg\", \"rmiServerPort = \" + DEFAULT_RMI_SERVER_PORT, \"rmiServerPort=\" + PortUtils.mapPortToRange(DEFAULT_RMI_SERVER_PORT, options.getMinimumPort(), options.getMaximumPort()));\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(ZkDefs.MINIMUM_PORT + \"=\" + options.getMaximumPort()));\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(ZkDefs.MAXIMUM_PORT + \"=\" + options.getMinimumPort()));\n\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(\"\\n\"));\n\n        //Read all system properties\n        for (Map.Entry<String, Properties> entry : options.getSystemProperties().entrySet()) {\n            Properties sysprops = entry.getValue();\n            for (Object type : sysprops.keySet()) {\n                Object value = sysprops.get(type);\n                appendFile(sb, \"etc/system.properties\", Arrays.asList(type + \"=\" + value));\n            }\n        }\n\n        //TODO: Be simple & move all of the code below under system properties MAP.\n        if (options.getPreferredAddress() != null) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(HostUtils.PREFERED_ADDRESS_PROPERTY_NAME + \"=\" + options.getPreferredAddress()));\n        }\n\n        if (options.isEnsembleServer()) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(ZooKeeperClusterService.ENSEMBLE_AUTOSTART + \"=true\"));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(ZooKeeperClusterService.AGENT_AUTOSTART + \"=true\"));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(ZooKeeperClusterService.PROFILES_AUTOIMPORT_PATH + \"=${karaf.home}/fabric/import/\"));\n        } else if (options.getZookeeperUrl() != null) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(\"zookeeper.url = \" + options.getZookeeperUrl()));\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(ZooKeeperClusterService.AGENT_AUTOSTART + \"=true\"));\n            appendToLineInFile(sb, \"etc/org.apache.karaf.features.cfg\", \"featuresBoot=\", \"fabric-agent,\");\n        }\n\n        //Add the proxyURI to the list of repositories\n        if (options.getProxyUri() != null) {\n            appendToLineInFile(sb, \"etc/org.ops4j.pax.url.mvn.cfg\", \"repositories=\", options.getProxyUri().toString() + \",\");\n        }\n        //Just for ensemble servers we want to copy their creation metadata for import.\n        if (options.isEnsembleServer()) {\n            CreateContainerMetadata metadata = options.getMetadataMap().get(options.getName());\n            if (metadata != null) {\n                byte[] metadataPayload = ObjectUtils.toBytes(metadata);\n                if (metadataPayload != null && metadataPayload.length > 0) {\n                    sb.append(\"copy_node_metadata \").append(options.getName()).append(\" \").append(new String(Base64Encoder.encode(metadataPayload))).append(\"\\n\");\n                }\n            }\n        }\n        if (options instanceof CreateJCloudsContainerOptions) {\n            sb.append(\"configure_hostnames\").append(\" \").append(((CreateJCloudsContainerOptions)options).getProviderName()).append(\"\\n\");\n        }\n        if (options.getJvmOpts() != null && !options.getJvmOpts().isEmpty()) {\n            sb.append(\"export JAVA_OPTS=\" + options.getJvmOpts()).append(\"\\n\");\n        }\n        sb.append(\"nohup bin/start &\").append(\"\\n\");\n        sb.append(\"karaf_check `pwd`\").append(\"\\n\");\n        return sb.toString();\n    }","commit_id":"af40f2d99ba36fbd4958ec9dadfcd93337ce8989","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private static void extractTargzIntoDirectory(StringBuilder sb, URI proxy, String groupId, String artifactId, String version) {\n        String file = artifactId + \"-\" + version + \".tar.gz\";\n        String path = groupId.replaceAll(\"\\\\.\", \"/\") + \"/\" + artifactId + \"/\" + version + \"/\" + file;\n        sb.append(\"run curl --show-error --get --retry 20 --output \").append(file).append(\" \").append(proxy.resolve(path)).append(\"\\n\");\n        sb.append(\"run tar -xpzf \").append(file).append(\"\\n\");\n    }","id":44002,"modified_method":"private static void extractTargzIntoDirectory(StringBuilder sb, URI proxy, String groupId, String artifactId, String version) {\n\n        String file = artifactId + \"-\" + version + \".tar.gz\";\n        String directory = groupId.replaceAll(\"\\\\.\", \"/\") + \"/\" + artifactId + \"/\" + version + \"/\";\n        //To cover the case of SNAPSHOT dependencies where URL can't be determined we are quering for the availale versions first\n        if(version.contains(\"SNAPSHOT\")) {\n            sb.append(\"run export DISTRO_URL=`curl --silent \").append(proxy.resolve(directory)).append(\"| grep href | grep \\\"tar.gz\\\\\\\"\\\" | sed 's/^.*<a href=\\\"//' | sed 's/\\\".*$//'  | tail -1`\").append(\"\\n\");\n        } else {\n            sb.append(\"run export DISTRO_URL=`\").append(proxy.resolve(directory+file)).append(\"`\").append(\"\\n\");\n        }\n        sb.append(\"run curl --show-error --silent --get --retry 20 --output \").append(file).append(\" \").append(\"$DISTRO_URL\").append(\"\\n\");\n        sb.append(\"run tar -xpzf \").append(file).append(\"\\n\");\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private static void replaceLineInFile(StringBuilder sb, String path, String pattern, String line) {\n        final String MARKER = \"END_OF_FILE\";\n        sb.append(String.format(REPLACE_FORMAT,pattern,line,path)).append(\"\\n\");\n    }","id":44003,"modified_method":"private static void replaceLineInFile(StringBuilder sb, String path, String pattern, String line) {\n        sb.append(String.format(REPLACE_FORMAT,pattern,line,path)).append(\"\\n\");\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static String buildStartupScript(URI proxy, String name, String path,  String zooKeeperUrl, int sshPort, boolean debugAgent) throws MalformedURLException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"function run { echo \\\"Running: $*\\\" ; $* ; rc=$? ; if [ \\\"${rc}\\\" -ne 0 ]; then echo \\\"Command failed\\\" ; exit ${rc} ; fi ; }\\n\");\n        sb.append(\"run mkdir -p \").append(name).append(\"\\n\");\n        sb.append(\"run cd \").append(name).append(\"\\n\");\n        extractTargzIntoDirectory(sb, proxy, \"org.fusesource.fabric\", \"karaf-distro\", \"1.1-SNAPSHOT\");\n        sb.append(\"run cd \").append(\"karaf-distro-1.1-SNAPSHOT\").append(\"\\n\");\n        List<String> lines = new ArrayList<String>();\n\n        appendFile(sb, \"etc/startup.properties\", lines);\n        replaceLineInFile(sb,\"etc/system.properties\",\"karaf.name=root\",\"karaf.name = \"+name);\n        replaceLineInFile(sb,\"etc/org.apache.karaf.shell.cfg\",\"sshPort=8101\",\"sshPort=\"+sshPort);\n        appendFile(sb, \"etc/system.properties\", Arrays.asList(\"zookeeper.url = \" + zooKeeperUrl));\n        if(debugAgent) {\n           sb.append(\"run export KARAF_DEBUG=true\").append(\"\\n\");\n        }\n        sb.append(\"run nohup bin/start\").append(\"\\n\");\n        return sb.toString();\n    }","id":44004,"modified_method":"public static String buildStartupScript(URI proxy, String name, String path,  String zooKeeperUrl, int sshPort, boolean isClusterServer, boolean debugAgent) throws MalformedURLException {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"function run { echo \\\"Running: $*\\\" ; $* ; rc=$? ; if [ \\\"${rc}\\\" -ne 0 ]; then echo \\\"Command failed\\\" ; exit ${rc} ; fi ; }\\n\");\n        sb.append(\"run mkdir -p \").append(name).append(\"\\n\");\n        sb.append(\"run cd \").append(name).append(\"\\n\");\n        extractTargzIntoDirectory(sb, proxy, \"org.fusesource.fabric\", \"karaf-distro\", \"1.1-SNAPSHOT\");\n        sb.append(\"run cd \").append(\"karaf-distro-1.1-SNAPSHOT\").append(\"\\n\");\n        List<String> lines = new ArrayList<String>();\n\n        appendFile(sb, \"etc/startup.properties\", lines);\n        replaceLineInFile(sb,\"etc/system.properties\",\"karaf.name=root\",\"karaf.name = \"+name);\n        replaceLineInFile(sb,\"etc/org.apache.karaf.shell.cfg\",\"sshPort=8101\",\"sshPort=\"+sshPort);\n        if(isClusterServer) {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(ZooKeeperClusterService.CLUSTER_AUTOSTART_PROPERTY+\"=true\"));\n        } else {\n            appendFile(sb, \"etc/system.properties\", Arrays.asList(\"zookeeper.url = \" + zooKeeperUrl));\n        }\n        if(debugAgent) {\n           sb.append(\"run export KARAF_DEBUG=true\").append(\"\\n\");\n        }\n        sb.append(\"run nohup bin/start\").append(\"\\n\");\n        return sb.toString();\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     *\n     * @param proxyUri\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     * @param debugAgent   Flag used to enable debugging on the new Agent.\n     * @param number       The number of Agents to create.\n     */\n    public void create(URI proxyUri, final URI agentUri, final String name, final String zooKeeperUrl, final boolean debugAgent, final int number) {\n        final Agent parent = service.getAgent(agentUri.getSchemeSpecificPart());\n        service.getAgentTemplate(parent).execute(new AgentTemplate.AdminServiceCallback<Object>() {\n            public Object doWithAdminService(AdminServiceMBean adminService) throws Exception {\n                String javaOpts = zooKeeperUrl != null ? \"-Dzookeeper.url=\\\"\" + zooKeeperUrl + \"\\\" -Xmx512M -server\" : \"\";\n                if(debugAgent) {\n                    javaOpts += AgentProvider.DEBUG_AGNET;\n                }\n                String features = \"fabric-agent\";\n                String featuresUrls = \"mvn:org.fusesource.fabric/fabric-distro/1.1-SNAPSHOT/xml/features\";\n\n                for (int i = 1; i <= number; i++) {\n                    String agentName = name;\n                    if (number > 1) {\n                        agentName += i;\n                    }\n                    adminService.createInstance(agentName, 0, 0, 0, null, javaOpts, features, featuresUrls);\n                    adminService.startInstance(agentName, null);\n                }\n                return null;\n            }\n        });\n    }","id":44005,"modified_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     *\n     * @param proxyUri\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     * @param debugAgent   Flag used to enable debugging on the new Agent.\n     * @param number       The number of Agents to create.\n     * @param isClusterServer       Marks if the agent will have the role of the cluster server.\n     * @param debugAgent\n     */\n    public void create(URI proxyUri, final URI agentUri, final String name, final String zooKeeperUrl, final boolean isClusterServer, final boolean debugAgent, final int number) {\n        final Agent parent = service.getAgent(agentUri.getSchemeSpecificPart());\n        service.getAgentTemplate(parent).execute(new AgentTemplate.AdminServiceCallback<Object>() {\n            public Object doWithAdminService(AdminServiceMBean adminService) throws Exception {\n                String javaOpts = zooKeeperUrl != null ? \"-Dzookeeper.url=\\\"\" + zooKeeperUrl + \"\\\" -Xmx512M -server\" : \"\";\n                if(debugAgent) {\n                    javaOpts += DEBUG_AGNET;\n                }\n                if(isClusterServer) {\n                    javaOpts += CLUSTER_SERVER_AGENT;\n                }\n                String features = \"fabric-agent\";\n                String featuresUrls = \"mvn:org.fusesource.fabric/fabric-distro/1.1-SNAPSHOT/xml/features\";\n\n                for (int i = 1; i <= number; i++) {\n                    String agentName = name;\n                    if (number > 1) {\n                        agentName += i;\n                    }\n                    adminService.createInstance(agentName, 0, 0, 0, null, javaOpts, features, featuresUrls);\n                    adminService.startInstance(agentName, null);\n                }\n                return null;\n            }\n        });\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     *\n     * @param proxyUri\n     * @param agentUri      The uri that contains required information to build the Agent.\n     * @param name          The name of the Agent.\n     * @param zooKeeperUrl  The url of Zoo Keeper.\n     * @param debugAgent    Flag used to enable debugging on the new Agent.\n     */\n    @Override\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl, boolean debugAgent) {\n        create(proxyUri, agentUri, name, zooKeeperUrl,debugAgent,1);\n    }","id":44006,"modified_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     *\n     * @param proxyUri\n     * @param agentUri      The uri that contains required information to build the Agent.\n     * @param name          The name of the Agent.\n     * @param zooKeeperUrl  The url of Zoo Keeper.\n     * @param debugAgent    Flag used to enable debugging on the new Agent.\n     */\n    @Override\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl, boolean isClusterServer, boolean debugAgent) {\n        create(proxyUri, agentUri, name, zooKeeperUrl,isClusterServer,debugAgent,1);\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     *\n     * @param proxyUri\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     */\n    @Override\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl) {\n        create(proxyUri, agentUri, name, zooKeeperUrl,false);\n    }","id":44007,"modified_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     *\n     * @param proxyUri\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     */\n    @Override\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl) {\n        create(proxyUri, agentUri, name, zooKeeperUrl,false, false);\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        if (url == null && parent == null) {\n            throw new Exception(\"Either an url or a parent must be specified\");\n        }\n        if (url == null && parent != null) {\n            url = \"child:\" + parent;\n        }\n        List<String> names = this.profiles;\n        if (names == null || names.isEmpty()) {\n            names = Collections.singletonList(\"default\");\n        }\n        Profile[] profiles = getProfiles(version, names);\n        Agent[] children = fabricService.createAgents( url, name, debugAgent, number );\n        for(Agent child:children) {\n            child.setProfiles(profiles);\n        }\n        return null;\n    }","id":44008,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        if (url == null && parent == null) {\n            throw new Exception(\"Either an url or a parent must be specified\");\n        }\n        if (url == null && parent != null) {\n            url = \"child:\" + parent;\n        }\n        List<String> names = this.profiles;\n        if (names == null || names.isEmpty()) {\n            names = Collections.singletonList(\"default\");\n        }\n        Agent[] children = fabricService.createAgents(url, name, isClusterServer, debugAgent, number);\n        try {\n            Profile[] profiles = getProfiles(version, names);\n            for (Agent child : children) {\n                child.setProfiles(profiles);\n            }\n        } catch (Exception ex) {\n\n        }\n\n        return null;\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private String getZooKeeperUrl() {\n        try {\n            Configuration config = configurationAdmin.getConfiguration(\"org.fusesource.fabric.zookeeper\", null);\n            final String zooKeeperUrl = (String) config.getProperties().get(\"zookeeper.url\");\n            if (zooKeeperUrl == null) {\n                throw new IllegalStateException(\"Unable to find the zookeeper url\");\n            }\n            return zooKeeperUrl;\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","id":44009,"modified_method":"private String getZooKeeperUrl() {\n        String zooKeeperUrl = null;\n        try {\n            Configuration config = configurationAdmin.getConfiguration(\"org.fusesource.fabric.zookeeper\", null);\n            zooKeeperUrl = (String) config.getProperties().get(\"zookeeper.url\");\n            if (zooKeeperUrl == null) {\n                throw new IllegalStateException(\"Unable to find the zookeeper url\");\n            }\n\n        } catch (Exception e) {\n          //Ignore it.\n        }\n        return zooKeeperUrl;\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public Agent[] createAgents(String url, String name, boolean debugAgent, int number) {\n        Agent[] agents = new Agent[number];\n        try {\n            final String zooKeeperUrl = getZooKeeperUrl();\n            URI uri = URI.create(url);\n            AgentProvider provider = getProvider(uri.getScheme());\n            if (provider == null) {\n                throw new FabricException(\"Unable to find an agent provider supporting uri '\" + url + \"'\");\n            }\n\n            for (int i = 0; i < number; i++) {\n                String agentName = name;\n                if (number > 1) {\n                    agentName += i + 1;\n                }\n                createAgentConfig(\"\", agentName);\n                agents[i] = new AgentImpl(null, agentName, FabricServiceImpl.this);\n            }\n\n            provider.create(getMavenRepoURI(), uri, name, zooKeeperUrl, debugAgent, number);\n\n        } catch (FabricException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n        return agents;\n    }","id":44010,"modified_method":"public Agent[] createAgents(String url, String name, boolean isClusterServer, boolean debugAgent, int number) {\n        Agent[] agents = new Agent[number];\n        try {\n\n            URI uri = URI.create(url);\n            AgentProvider provider = getProvider(uri.getScheme());\n            if (provider == null) {\n                throw new FabricException(\"Unable to find an agent provider supporting uri '\" + url + \"'\");\n            }\n\n            if (!isClusterServer) {\n                final String zooKeeperUrl = getZooKeeperUrl();\n\n                for (int i = 0; i < number; i++) {\n                    String agentName = name;\n                    if (number > 1) {\n                        agentName += i + 1;\n                    }\n                    createAgentConfig(\"\", agentName);\n                    agents[i] = new AgentImpl(null, agentName, FabricServiceImpl.this);\n                }\n\n                provider.create(getMavenRepoURI(), uri, name, zooKeeperUrl, isClusterServer, debugAgent, number);\n            } else {\n                provider.create(getMavenRepoURI(), uri, name, null, isClusterServer, debugAgent, number);\n            }\n        } catch (FabricException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n        return agents;\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public Agent createAgent(final String url, final String name) {\n        return createAgent(url,name,false);\n    }","id":44011,"modified_method":"public Agent createAgent(final String url, final String name) {\n        return createAgent(url,name,false, false);\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public Agent createAgent(String url, String name, boolean debugAgent) {\n        return createAgents(url,name,debugAgent,1)[0];\n    }","id":44012,"modified_method":"public Agent createAgent(String url, String name, boolean isClusterServer, boolean debugAgent) {\n        return createAgents(url, name, isClusterServer, debugAgent, 1)[0];\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public boolean create(CreateAgentArguments createArgs, String name, String zooKeeperUrl) throws Exception {\n        if (createArgs instanceof CreateJCloudsAgentArguments) {\n            CreateJCloudsAgentArguments args = (CreateJCloudsAgentArguments) createArgs;\n\n            boolean debugAgent = args.isDebugAgent();\n            int number = args.getNumber();\n            String imageId = args.getImageId();\n            String hardwareId = args.getHardwareId();\n            String locationId = args.getLocationId();\n            String group = args.getGroup();\n            String user = args.getUser();\n            JCloudsInstanceType instanceType = args.getInstanceType();\n            String providerName = args.getProviderName();\n            String identity = args.getIdentity();\n            String credential = args.getCredential();\n            String owner = args.getOwner();\n            URI proxyURI = args.getProxyUri();\n\n            doCreateAgent(proxyURI, name, number, zooKeeperUrl, debugAgent, imageId, hardwareId, locationId, group, user, instanceType, providerName, identity, credential, owner);\n            return true;\n        }\n        return false;\n    }","id":44013,"modified_method":"@Override\n    public boolean create(CreateAgentArguments createArgs, String name, String zooKeeperUrl) throws Exception {\n        if (createArgs instanceof CreateJCloudsAgentArguments) {\n            CreateJCloudsAgentArguments args = (CreateJCloudsAgentArguments) createArgs;\n\n            boolean isClusterServer = args.isClusterServer();\n            boolean debugAgent = args.isDebugAgent();\n            int number = args.getNumber();\n            String imageId = args.getImageId();\n            String hardwareId = args.getHardwareId();\n            String locationId = args.getLocationId();\n            String group = args.getGroup();\n            String user = args.getUser();\n            JCloudsInstanceType instanceType = args.getInstanceType();\n            String providerName = args.getProviderName();\n            String identity = args.getIdentity();\n            String credential = args.getCredential();\n            String owner = args.getOwner();\n            URI proxyURI = args.getProxyUri();\n\n            doCreateAgent(proxyURI, name, number, zooKeeperUrl, isClusterServer, debugAgent, imageId, hardwareId, locationId, group, user, instanceType, providerName, identity, credential, owner);\n            return true;\n        }\n        return false;\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     * @param proxyUri     The uri of the maven proxy to use.\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     */\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl, boolean debugAgent) {\n           create(proxyUri, agentUri,name,zooKeeperUrl,debugAgent,1);\n    }","id":44014,"modified_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     * @param proxyUri     The uri of the maven proxy to use.\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     * @param server       Marks if the agent will have the role of the cluster server.\n     * @param debugAgent\n     */\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl, boolean server, boolean debugAgent) {\n           create(proxyUri, agentUri,name,zooKeeperUrl,server,debugAgent,1);\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     * @param proxyUri      The uri of the maven proxy to use.\n     * @param agentUri      The uri that contains required information to build the Agent.\n     * @param name          The name of the Agent.\n     * @param zooKeeperUrl  The url of Zoo Keeper.\n     * @param debugAgent    Flag used to enable debugging on the new Agent.\n     * @param number        The number of Agents to create.\n     */\n    @Override\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl, boolean debugAgent, int number) {\n        String imageId = null;\n        String hardwareId = null;\n        String locationId = null;\n        String group = null;\n        String user = null;\n        JCloudsInstanceType instanceType = JCloudsInstanceType.Smallest;\n        String identity = null;\n        String credential = null;\n        String owner = null;\n\n        try {\n            String providerName = agentUri.getHost();\n\n            if (agentUri.getQuery() != null) {\n                Map<String, String> parameters = parseQuery(agentUri.getQuery());\n                if (parameters != null) {\n                    imageId = parameters.get(IMAGE_ID);\n                    group = parameters.get(GROUP);\n                    locationId = parameters.get(LOCATION_ID);\n                    hardwareId = parameters.get(HARDWARE_ID);\n                    user = parameters.get(USER);\n                    if (parameters.get(INSTANCE_TYPE) != null) {\n                        instanceType = JCloudsInstanceType.get(parameters.get(INSTANCE_TYPE), instanceType);\n                    }\n                }\n            }\n\n            doCreateAgent(proxyUri, name, number, zooKeeperUrl, debugAgent, imageId, hardwareId, locationId, group, user, instanceType, providerName, identity, credential, owner);\n        } catch (FabricException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","id":44015,"modified_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     * @param proxyUri      The uri of the maven proxy to use.\n     * @param agentUri      The uri that contains required information to build the Agent.\n     * @param name          The name of the Agent.\n     * @param zooKeeperUrl  The url of Zoo Keeper.\n     * @param isClusterServer       Marks if the agent will have the role of the cluster server.\n     * @param debugAgent    Flag used to enable debugging on the new Agent.\n     * @param number        The number of Agents to create.\n     */\n    @Override\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl, boolean isClusterServer, boolean debugAgent, int number) {\n        String imageId = null;\n        String hardwareId = null;\n        String locationId = null;\n        String group = null;\n        String user = null;\n        JCloudsInstanceType instanceType = JCloudsInstanceType.Smallest;\n        String identity = null;\n        String credential = null;\n        String owner = null;\n\n        try {\n            String providerName = agentUri.getHost();\n\n            if (agentUri.getQuery() != null) {\n                Map<String, String> parameters = parseQuery(agentUri.getQuery());\n                if (parameters != null) {\n                    imageId = parameters.get(IMAGE_ID);\n                    group = parameters.get(GROUP);\n                    locationId = parameters.get(LOCATION_ID);\n                    hardwareId = parameters.get(HARDWARE_ID);\n                    user = parameters.get(USER);\n                    if (parameters.get(INSTANCE_TYPE) != null) {\n                        instanceType = JCloudsInstanceType.get(parameters.get(INSTANCE_TYPE), instanceType);\n                    }\n                }\n            }\n\n            doCreateAgent(proxyUri, name, number, zooKeeperUrl, isClusterServer, debugAgent, imageId, hardwareId, locationId, group, user, instanceType, providerName, identity, credential, owner);\n        } catch (FabricException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void doCreateAgent(URI proxyUri, String name, int number, String zooKeeperUrl, boolean debugAgent, String imageId, String hardwareId, String locationId, String group, String user, JCloudsInstanceType instanceType, String providerName, String identity, String credential, String owner) throws MalformedURLException, RunNodesException, URISyntaxException {\n        ComputeService computeService = computeServiceMap.get(providerName);\n        if (computeService == null) {\n            //Iterable<? extends Module> modules = ImmutableSet.of(new Log4JLoggingModule(), new JschSshClientModule());\n            Iterable<? extends Module> modules = ImmutableSet.of();\n\n            Properties props = new Properties();\n            props.put(\"provider\", providerName);\n            props.put(\"identity\", identity);\n            props.put(\"credential\", credential);\n            if (!Strings.isNullOrEmpty(owner)) {\n                props.put(\"jclouds.ec2.ami-owners\", owner);\n            }\n\n            RestContextFactory restFactory = new RestContextFactory();\n            ComputeServiceContext context = new ComputeServiceContextFactory(restFactory).createContext(providerName, identity, credential, modules, props);\n            computeService = context.getComputeService();\n        }\n\n        TemplateBuilder builder = computeService.templateBuilder();\n        builder.any();\n        switch (instanceType) {\n            case Smallest:\n                builder.smallest();\n                break;\n            case Biggest:\n                builder.biggest();\n                break;\n            case Fastest:\n                builder.fastest();\n        }\n\n        if (locationId != null) {\n            builder.locationId(locationId);\n        }\n        if (imageId != null) {\n            builder.imageId(imageId);\n        }\n        if (hardwareId != null) {\n            builder.hardwareId(hardwareId);\n        }\n\n        Set<? extends NodeMetadata> metadatas = null;\n        Credentials credentials = null;\n        if (user != null && credentials == null) {\n            credentials = new Credentials(user, null);\n        }\n\n        metadatas = computeService.createNodesInGroup(group, number, builder.build());\n\n        int suffix = 1;\n        if (metadatas != null) {\n            for (NodeMetadata nodeMetadata : metadatas) {\n                String id = nodeMetadata.getId();\n                String agentName = name;\n                if(number > 1) {\n                    agentName+=suffix++;\n                }\n                String script = buildStartupScript(proxyUri, agentName, \"~/\", zooKeeperUrl, DEFAULT_SSH_PORT, debugAgent);\n                if (credentials != null) {\n                    computeService.runScriptOnNode(id, script, RunScriptOptions.Builder.overrideCredentialsWith(credentials).runAsRoot(false));\n                } else {\n                    computeService.runScriptOnNode(id, script);\n                }\n            }\n        }\n    }","id":44016,"modified_method":"protected void doCreateAgent(URI proxyUri, String name, int number, String zooKeeperUrl,boolean isClusterServer, boolean debugAgent, String imageId, String hardwareId, String locationId, String group, String user, JCloudsInstanceType instanceType, String providerName, String identity, String credential, String owner) throws MalformedURLException, RunNodesException, URISyntaxException {\n        ComputeService computeService = computeServiceMap.get(providerName);\n        if (computeService == null) {\n            //Iterable<? extends Module> modules = ImmutableSet.of(new Log4JLoggingModule(), new JschSshClientModule());\n            Iterable<? extends Module> modules = ImmutableSet.of();\n\n            Properties props = new Properties();\n            props.put(\"provider\", providerName);\n            props.put(\"identity\", identity);\n            props.put(\"credential\", credential);\n            if (!Strings.isNullOrEmpty(owner)) {\n                props.put(\"jclouds.ec2.ami-owners\", owner);\n            }\n\n            RestContextFactory restFactory = new RestContextFactory();\n            ComputeServiceContext context = new ComputeServiceContextFactory(restFactory).createContext(providerName, identity, credential, modules, props);\n            computeService = context.getComputeService();\n        }\n\n        TemplateBuilder builder = computeService.templateBuilder();\n        builder.any();\n        switch (instanceType) {\n            case Smallest:\n                builder.smallest();\n                break;\n            case Biggest:\n                builder.biggest();\n                break;\n            case Fastest:\n                builder.fastest();\n        }\n\n        if (locationId != null) {\n            builder.locationId(locationId);\n        }\n        if (imageId != null) {\n            builder.imageId(imageId);\n        }\n        if (hardwareId != null) {\n            builder.hardwareId(hardwareId);\n        }\n\n        Set<? extends NodeMetadata> metadatas = null;\n        Credentials credentials = null;\n        if (user != null && credentials == null) {\n            credentials = new Credentials(user, null);\n        }\n\n        metadatas = computeService.createNodesInGroup(group, number, builder.build());\n\n        int suffix = 1;\n        if (metadatas != null) {\n            for (NodeMetadata nodeMetadata : metadatas) {\n                String id = nodeMetadata.getId();\n                String agentName = name;\n                if(number > 1) {\n                    agentName+=suffix++;\n                }\n                String script = buildStartupScript(proxyUri, agentName, \"~/\", zooKeeperUrl, DEFAULT_SSH_PORT,isClusterServer, debugAgent);\n                if (credentials != null) {\n                    computeService.runScriptOnNode(id, script, RunScriptOptions.Builder.overrideCredentialsWith(credentials).runAsRoot(false));\n                } else {\n                    computeService.runScriptOnNode(id, script);\n                }\n            }\n        }\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     * @param proxyUri     The uri of the maven proxy to use.\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     */\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl, final boolean debugAgent) {\n        create(proxyUri, agentUri, name, zooKeeperUrl, debugAgent, 1);\n    }","id":44017,"modified_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     * @param proxyUri     The uri of the maven proxy to use.\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     * @param isClusterServer       Marks if the agent will have the role of the cluster server.\n     * @param debugAgent\n     */\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl, final boolean isClusterServer, final boolean debugAgent) {\n        create(proxyUri, agentUri, name, zooKeeperUrl, isClusterServer, debugAgent, 1);\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void createAgent(String host, int port, String username, String password, String script, int sshRetries, long retryDelay) throws Exception {\n        Session session = null;\n        Exception connectException = null;\n        for (int i = 0; i < sshRetries; i++) {\n            if (i > 0) {\n                long delayMs = (long) (200L * Math.pow(i, 2));\n                Thread.sleep(delayMs);\n            }\n            try {\n                session = new JSch().getSession(username, host, port);\n                session.setTimeout(60000);\n                session.setPassword(password);\n                java.util.Properties config = new java.util.Properties();\n                config.put(\"StrictHostKeyChecking\", \"no\");\n                session.setConfig(config);\n                session.connect();\n                connectException = null;\n                break;\n            } catch (Exception from) {\n                connectException = from;\n                if (session != null && session.isConnected()) {\n                    session.disconnect();\n                }\n                session = null;\n            }\n        }\n        if (connectException != null) {\n            throw connectException;\n        }\n        ChannelExec executor = null;\n        ByteArrayOutputStream output = new ByteArrayOutputStream();\n        ByteArrayOutputStream error = new ByteArrayOutputStream();\n        try {\n            executor = (ChannelExec) session.openChannel(\"exec\");\n            executor.setPty(true);\n            executor.setCommand(script);\n            executor.setOutputStream(output);\n            executor.setErrStream(error);\n            executor.connect();\n            int errorStatus = -1;\n            for (int i = 0; i < sshRetries; i++) {\n                if (i > 0) {\n                    long delayMs = (long) (200L * Math.pow(i, 2));\n                    Thread.sleep(delayMs);\n                }\n                if ((errorStatus = executor.getExitStatus()) != -1) {\n                    break;\n                }\n            }\n            if (debug) {\n                System.out.println(\"Output : \" + output.toString());\n                System.out.println(\"Error : \" + error.toString());\n            }\n            if (errorStatus != 0) {\n                throw new Exception(String.format(\"%s@%s:%d: received exit status %d executing \\n--- command ---\\n%s\\n--- output ---\\n%s\\n--- error ---\\n%s\\n------\\n\", username, host,\n                        port, executor.getExitStatus(), script, output.toString(), error.toString()));\n            }\n        } finally {\n            if (executor != null) {\n                executor.disconnect();\n            }\n            session.disconnect();\n        }\n    }","id":44018,"modified_method":"protected void createAgent(String host, int port, String username, String password, String script, int sshRetries, long retryDelay) throws Exception {\n        Session session = null;\n        Exception connectException = null;\n        for (int i = 0; i < sshRetries; i++) {\n            if (i > 0) {\n                long delayMs = (long) (200L * Math.pow(i, 2));\n                Thread.sleep(delayMs);\n            }\n            try {\n                session = new JSch().getSession(username, host, port);\n                session.setTimeout(60000);\n                session.setPassword(password);\n                java.util.Properties config = new java.util.Properties();\n                config.put(\"StrictHostKeyChecking\", \"no\");\n                session.setConfig(config);\n                session.connect();\n                connectException = null;\n                break;\n            } catch (Exception from) {\n                connectException = from;\n                if (session != null && session.isConnected()) {\n                    session.disconnect();\n                }\n                session = null;\n            }\n        }\n        if (connectException != null) {\n            throw connectException;\n        }\n        ChannelExec executor = null;\n        ByteArrayOutputStream output = new ByteArrayOutputStream();\n        ByteArrayOutputStream error = new ByteArrayOutputStream();\n        try {\n            executor = (ChannelExec) session.openChannel(\"exec\");\n            executor.setPty(true);\n            executor.setCommand(script);\n            executor.setOutputStream(output);\n            executor.setErrStream(error);\n            executor.connect();\n            int errorStatus = -1;\n\n            for (int i = 0; !executor.isClosed(); i++) {\n                if (i > 0) {\n                    long delayMs = (long) (200L * Math.pow(i, 2));\n                    Thread.sleep(delayMs);\n                }\n                if ((errorStatus = executor.getExitStatus()) != -1) {\n                    break;\n                }\n            }\n            if (debug) {\n                System.out.println(\"Output : \" + output.toString());\n                System.out.println(\"Error : \" + error.toString());\n            }\n\n            if (errorStatus != 0) {\n                throw new Exception(String.format(\"%s@%s:%d: received exit status %d executing \\n--- command ---\\n%s\\n--- output ---\\n%s\\n--- error ---\\n%s\\n------\\n\", username, host,\n                        port, executor.getExitStatus(), script, output.toString(), error.toString()));\n            }\n        } finally {\n            if (executor != null) {\n                executor.disconnect();\n            }\n            session.disconnect();\n        }\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void doCreateAgent(URI proxyUri, String name, int number, String zooKeeperUrl, boolean debugAgent, String path, String host, int port, String username, String password, int sshRetries, int retryDelay) throws Exception {\n        for (int i = 0; i < number; i++) {\n            String agentName = name;\n            if (number != 1) {\n                agentName += i + 1;\n            }\n            String script = buildStartupScript(proxyUri, agentName, path, zooKeeperUrl, DEFAULT_SSH_PORT + i, debugAgent);\n            createAgent(host, port, username, password, script, sshRetries, retryDelay);\n        }\n    }","id":44019,"modified_method":"protected void doCreateAgent(URI proxyUri, String name, int number, String zooKeeperUrl, boolean isClusterServer, boolean debugAgent, String path, String host, int port, String username, String password, int sshRetries, int retryDelay) throws Exception {\n        for (int i = 0; i < number; i++) {\n            String agentName = name;\n            if (number != 1) {\n                agentName += i + 1;\n            }\n            String script = buildStartupScript(proxyUri, agentName, path, zooKeeperUrl, DEFAULT_SSH_PORT + i, isClusterServer, debugAgent);\n            createAgent(host, port, username, password, script, sshRetries, retryDelay);\n        }\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     *\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     */\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl) {\n        create(proxyUri, agentUri, name, zooKeeperUrl, false);\n    }","id":44020,"modified_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     *\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     */\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl) {\n        create(proxyUri, agentUri, name, zooKeeperUrl, false, false);\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     * @param proxyUri     The uri of the maven proxy to use.\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     * @param debugAgent   Flag to enable debuging on the created Agents.\n     * @param number       The number of Agents to create.\n     */\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl, final boolean debugAgent, int number) {\n        try {\n            String path = agentUri.getPath();\n            String host = agentUri.getHost();\n            if (agentUri.getQuery() != null) {\n                debug = agentUri.getQuery().contains(\"debug\");\n            }\n            if (host == null) {\n                throw new IllegalArgumentException(\"host name must be specified in uri '\" + agentUri + \"'\");\n            }\n            int port = agentUri.getPort();\n            if (port == -1) {\n                port = 22;\n            }\n            String ui = agentUri.getUserInfo();\n            String[] uip = ui != null ? ui.split(\":\") : null;\n            if (uip == null || uip.length != 2) {\n                throw new IllegalArgumentException(\"user and password must be supplied in the uri '\" + agentUri + \"'\");\n            }\n            String username = uip[0];\n            String password = uip[1];\n            int sshRetries = 6;\n            int retryDelay = 1;\n            doCreateAgent(proxyUri, name, number, zooKeeperUrl, debugAgent, path, host, port, username, password, sshRetries, retryDelay);\n        } catch (FabricException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","id":44021,"modified_method":"/**\n     * Creates an {@link org.fusesource.fabric.api.Agent} with the given name pointing to the specified zooKeeperUrl.\n     * @param proxyUri     The uri of the maven proxy to use.\n     * @param agentUri     The uri that contains required information to build the Agent.\n     * @param name         The name of the Agent.\n     * @param zooKeeperUrl The url of Zoo Keeper.\n     * @param debugAgent   Flag to enable debuging on the created Agents.\n     * @param number       The number of Agents to create.\n     */\n    public void create(URI proxyUri, URI agentUri, String name, String zooKeeperUrl, final boolean isClusterServer, final boolean debugAgent, int number) {\n        try {\n            String path = agentUri.getPath();\n            String host = agentUri.getHost();\n            if (agentUri.getQuery() != null) {\n                debug = agentUri.getQuery().contains(\"debug\");\n            }\n            if (host == null) {\n                throw new IllegalArgumentException(\"host name must be specified in uri '\" + agentUri + \"'\");\n            }\n            int port = agentUri.getPort();\n            if (port == -1) {\n                port = 22;\n            }\n            String ui = agentUri.getUserInfo();\n            String[] uip = ui != null ? ui.split(\":\") : null;\n            if (uip == null || uip.length != 2) {\n                throw new IllegalArgumentException(\"user and password must be supplied in the uri '\" + agentUri + \"'\");\n            }\n            String username = uip[0];\n            String password = uip[1];\n            int sshRetries = 6;\n            int retryDelay = 1;\n\n            doCreateAgent(proxyUri, name, number, zooKeeperUrl, isClusterServer, debugAgent, path, host, port, username, password, sshRetries, retryDelay);\n        } catch (FabricException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public boolean create(CreateAgentArguments createArgs, String name, String zooKeeperUrl) throws Exception {\n        if (createArgs instanceof CreateSshAgentArguments) {\n            CreateSshAgentArguments args = (CreateSshAgentArguments) createArgs;\n            boolean debugAgent = args.isDebugAgent();\n            int number = args.getNumber();\n            String path = args.getPath();\n            String host = args.getHost();\n            int port = args.getPort();\n            String username = args.getUsername();\n            String password = args.getPassword();\n            int sshRetries = args.getSshRetries();\n            int retryDelay = args.getRetryDelay();\n            URI proxyUri = args.getProxyUri();\n            doCreateAgent(proxyUri, name, number, zooKeeperUrl, debugAgent, path, host, port, username, password, sshRetries, retryDelay);\n            return true;\n        } else {\n            return false;\n        }\n    }","id":44022,"modified_method":"@Override\n    public boolean create(CreateAgentArguments createArgs, String name, String zooKeeperUrl) throws Exception {\n        if (createArgs instanceof CreateSshAgentArguments) {\n            CreateSshAgentArguments args = (CreateSshAgentArguments) createArgs;\n            boolean isClusterServer = args.isClusterServer();\n            boolean debugAgent = args.isDebugAgent();\n            int number = args.getNumber();\n            String path = args.getPath();\n            String host = args.getHost();\n            int port = args.getPort();\n            String username = args.getUsername();\n            String password = args.getPassword();\n            int sshRetries = args.getSshRetries();\n            int retryDelay = args.getRetryDelay();\n            URI proxyUri = args.getProxyUri();\n            doCreateAgent(proxyUri, name, number, zooKeeperUrl, isClusterServer, debugAgent, path, host, port, username, password, sshRetries, retryDelay);\n            return true;\n        } else {\n            return false;\n        }\n    }","commit_id":"9a368020c0b22bfa7b47999390dc4b8fd48b3bba","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@NotNull\n  private PsiElement[] getSelectedPsiElements() {\n    final TreePath[] treePaths = myTree.getSelectionPaths();\n    if (treePaths != null) {\n      Set<PsiElement> result = new HashSet<PsiElement>();\n      for (TreePath path : treePaths) {\n        PackageDependenciesNode node = (PackageDependenciesNode)path.getLastPathComponent();\n        final PsiElement psiElement = node.getPsiElement();\n        if (psiElement != null && psiElement.isValid()) {\n          result.add(psiElement);\n        }\n      }\n      return PsiUtilCore.toPsiElementArray(result);\n    }\n    return PsiElement.EMPTY_ARRAY;\n  }","id":44023,"modified_method":"@NotNull\n  private PsiElement[] getSelectedPsiElements() {\n    final TreePath[] treePaths = myTree.getSelectionPaths();\n    if (treePaths != null) {\n      Set<PsiElement> result = new HashSet<PsiElement>();\n      for (TreePath path : treePaths) {\n        final Object component = path.getLastPathComponent();\n        if (component instanceof PackageDependenciesNode) {\n          PackageDependenciesNode node = (PackageDependenciesNode)component;\n          final PsiElement psiElement = node.getPsiElement();\n          if (psiElement != null && psiElement.isValid()) {\n            result.add(psiElement);\n          }\n        }\n      }\n      return PsiUtilCore.toPsiElementArray(result);\n    }\n    return PsiElement.EMPTY_ARRAY;\n  }","commit_id":"ac43ca69758d9d30292b4da5b7541b303a7af040","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Default_KeymapChanges() {\n    // simple \n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.RenameConcept_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.RenameLink_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.RenameProperty_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.SafeDeleteConcept_Action\", getShortcut(\"alt DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.SafeDeleteLink_Action\", getShortcut(\"alt DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.ShowDefaultHelp_Action\", getShortcut(\" F1\"));\n    // simple parameterized \n    // complex \n  }","id":44024,"modified_method":"public Default_KeymapChanges() {\n    // simple \n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.MoveLinkUp_Action\", getShortcut(\" F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.RenameConcept_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.RenameLink_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.RenameProperty_Action\", getShortcut(\"shift F6\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.SafeDeleteConcept_Action\", getShortcut(\"alt DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.SafeDeleteLink_Action\", getShortcut(\"alt DELETE\"));\n    addSimpleShortcut(\"jetbrains.mps.lang.structure.plugin.ShowDefaultHelp_Action\", getShortcut(\" F1\"));\n    // simple parameterized \n    // complex \n  }","commit_id":"9d925515db4273e1645d3543c06c104fd017f3c0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean init(final RefactoringContext refactoringContext) {\n    final Wrappers._T<SNode> concept = new Wrappers._T<SNode>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        concept.value = SNodeOperations.getAncestor(refactoringContext.getSelectedNode(), \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false);\n      }\n    });\n    if ((concept.value == null)) {\n      return false;\n    }\n\n    if (!(MoveLinkUp.this.ask(refactoringContext))) {\n      return false;\n    }\n    // check if merge possible \n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        refactoringContext.setParameter(\"linkToReplace\", RefUtil.findLinkToMerge(((SNode) refactoringContext.getParameter(\"targetConcept\")), refactoringContext.getSelectedNode()));\n      }\n    });\n    if ((((SNode) refactoringContext.getParameter(\"linkToReplace\")) != null)) {\n      if (!(MoveLinkUp.this.askBool(refactoringContext, \"Merge to link with the same name?\", \"mergeLinks\", new MoveLinkUp_mergeLinks_Settings(refactoringContext)))) {\n        return false;\n      }\n      if (!(((Boolean) refactoringContext.getParameter(\"mergeLinks\")))) {\n        refactoringContext.setParameter(\"linkToReplace\", null);\n      }\n    }\n    return true;\n  }","id":44025,"modified_method":"public boolean init(final RefactoringContext refactoringContext) {\n    final Wrappers._T<SNode> concept = new Wrappers._T<SNode>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        concept.value = SNodeOperations.getAncestor(refactoringContext.getSelectedNode(), \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", false, false);\n      }\n    });\n    if ((concept.value == null)) {\n      return false;\n    }\n    // check if merge possible \n    if (!(((Boolean) refactoringContext.getParameter(\"mergeLinks\")))) {\n      refactoringContext.setParameter(\"linkToReplace\", null);\n    }\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        refactoringContext.setParameter(\"linkToReplace\", RefUtil.findLinkToMerge(((SNode) refactoringContext.getParameter(\"targetConcept\")), refactoringContext.getSelectedNode()));\n      }\n    });\n    return true;\n  }","commit_id":"9d925515db4273e1645d3543c06c104fd017f3c0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getSelectedObject() {\n    final ChildHierarchyTreeNode treeNode = (ChildHierarchyTreeNode) myTree.getSelectionPath().getLastPathComponent();\n    if (treeNode == null) {\n      return null;\n    }\n    final Wrappers._T<SNode> result = new Wrappers._T<SNode>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        result.value = treeNode.getNode();\n      }\n    });\n    return ((SNode) result.value);\n  }","id":44026,"modified_method":"public SNode getSelectedObject() {\n    Object treeNode = myTree.getSelectionPath().getLastPathComponent();\n    if (treeNode == null) {\n      return null;\n    }\n    if (!(treeNode instanceof ChildHierarchyTreeNode)) {\n      return null;\n    }\n    final ChildHierarchyTreeNode treeNodeChild = (ChildHierarchyTreeNode) treeNode;\n    final Wrappers._T<SNode> result = new Wrappers._T<SNode>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        result.value = treeNodeChild.getNode();\n      }\n    });\n    return ((SNode) result.value);\n  }","commit_id":"9d925515db4273e1645d3543c06c104fd017f3c0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public RefactoringAdditions_ActionGroup() {\n    super(\"RefactoringAdditions\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.RenameConcept_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.RenameLink_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.RenameProperty_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.SafeDeleteConcept_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.SafeDeleteLink_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":44027,"modified_method":"public RefactoringAdditions_ActionGroup() {\n    super(\"RefactoringAdditions\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.RenameConcept_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.RenameLink_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.RenameProperty_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.SafeDeleteConcept_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.SafeDeleteLink_Action\");\n      RefactoringAdditions_ActionGroup.this.addAction(\"jetbrains.mps.lang.structure.plugin.MoveLinkUp_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"9d925515db4273e1645d3543c06c104fd017f3c0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new RenameConcept_Action());\n    addAction(new RenameLink_Action());\n    addAction(new RenameProperty_Action());\n    addAction(new SafeDeleteConcept_Action());\n    addAction(new SafeDeleteLink_Action());\n    addAction(new ShowDefaultHelp_Action());\n    addAction(new ShowHelpForAspect_Action());\n    addAction(new ShowHelpForNode_Action());\n    addAction(new ShowHelpForRoot_Action());\n    // groups \n    addGroup(new RefactoringAdditions_ActionGroup());\n    addGroup(new ShowHelp_ActionGroup());\n    addGroup(new Structure_ActionGroup());\n  }","id":44028,"modified_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new MoveLinkUp_Action());\n    addAction(new RenameConcept_Action());\n    addAction(new RenameLink_Action());\n    addAction(new RenameProperty_Action());\n    addAction(new SafeDeleteConcept_Action());\n    addAction(new SafeDeleteLink_Action());\n    addAction(new ShowDefaultHelp_Action());\n    addAction(new ShowHelpForAspect_Action());\n    addAction(new ShowHelpForNode_Action());\n    addAction(new ShowHelpForRoot_Action());\n    // groups \n    addGroup(new RefactoringAdditions_ActionGroup());\n    addGroup(new ShowHelp_ActionGroup());\n    addGroup(new Structure_ActionGroup());\n  }","commit_id":"9d925515db4273e1645d3543c06c104fd017f3c0","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeNodesRemoved(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeNodesRemoved(TreeModelEvent removalEvent)\n\t{\n\t\tif (dirtyAll)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// get the parent node of deleted nodes\n\t\tTreeNode parentNode = (TreeNode)removalEvent.getTreePath().getLastPathComponent();\n\t\tTreeItem parentItem = nodeToItemMap.get(parentNode);\n\n\t\tif (parentItem != null && isNodeVisible(parentNode))\n\t\t{\n\t\t\tif (parentNode.getChildCount() == 0)\n\t\t\t{\n\t\t\t\t// rebuild parent's icon to show it no longer has children\n\t\t\t\tinvalidateNode(parentNode, true);\n\t\t\t}\n\n\t\t\tif (isNodeExpanded(parentNode))\n\t\t\t{\n\t\t\t\t// deleted nodes were visible; we need to delete their TreeItems\n\t\t\t\tfor (Object deletedNode : removalEvent.getChildren())\n\t\t\t\t{\n\t\t\t\t\tTreeItem itemToDelete = nodeToItemMap.get(deletedNode);\n\t\t\t\t\tif (itemToDelete != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tmarkTheLastButOneChildDirty(parentItem, itemToDelete);\n\n\t\t\t\t\t\t// remove all the deleted item's children\n\t\t\t\t\t\tvisitItemChildren(itemToDelete, new IItemCallback()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpublic void visitItem(TreeItem item)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tremoveItem(item);\n\t\t\t\t\t\t\t\tgetTreeState().selectNode(item.getModelObject(), false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tparentItem.getChildren().remove(itemToDelete);\n\t\t\t\t\t\tremoveItem(itemToDelete);\n\t\t\t\t\t\tgetTreeState().selectNode(itemToDelete.getModelObject(), false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":44029,"modified_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeNodesRemoved(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeNodesRemoved(TreeModelEvent removalEvent)\n\t{\n\t\tif (dirtyAll)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// get the parent node of deleted nodes\n\t\tObject parentNode = removalEvent.getTreePath().getLastPathComponent();\n\t\tTreeItem parentItem = nodeToItemMap.get(parentNode);\n\n\t\tif (parentItem != null && isNodeVisible(parentNode))\n\t\t{\n\t\t\tif (isNodeExpanded(parentNode))\n\t\t\t{\n\t\t\t\t// deleted nodes were visible; we need to delete their TreeItems\n\t\t\t\tfor (Object deletedNode : removalEvent.getChildren())\n\t\t\t\t{\n\t\t\t\t\tTreeItem itemToDelete = nodeToItemMap.get(deletedNode);\n\t\t\t\t\tif (itemToDelete != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tmarkTheLastButOneChildDirty(parentItem, itemToDelete);\n\n\t\t\t\t\t\t// remove all the deleted item's children\n\t\t\t\t\t\tvisitItemChildren(itemToDelete, new IItemCallback()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpublic void visitItem(TreeItem item)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tremoveItem(item);\n\t\t\t\t\t\t\t\tgetTreeState().selectNode(item.getModelObject(), false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tparentItem.getChildren().remove(itemToDelete);\n\t\t\t\t\t\tremoveItem(itemToDelete);\n\t\t\t\t\t\tgetTreeState().selectNode(itemToDelete.getModelObject(), false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!parentItem.hasChildTreeItems())\n\t\t\t{\n\t\t\t\t// rebuild parent's icon to show it no longer has children\n\t\t\t\tinvalidateNode(parentNode, true);\n\t\t\t}\n\t\t}\n\t}","commit_id":"714217d07d1e26259a5113b29cdf844e1eeb65c1","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeNodesInserted(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeNodesInserted(TreeModelEvent e)\n\t{\n\t\tif (dirtyAll)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// get the parent node of inserted nodes\n\t\tTreeNode parentNode = (TreeNode)e.getTreePath().getLastPathComponent();\n\n\t\tif (isNodeVisible(parentNode))\n\t\t{\n\t\t\t// parentNode was a leaf before this insertion event only if every one of\n\t\t\t// its current children is in the event's list of children\n\t\t\tboolean wasLeaf = true;\n\t\t\tList<?> eventChildren = Arrays.asList(e.getChildren());\n\t\t\tEnumeration<?> treeChildren = parentNode.children();\n\t\t\twhile (wasLeaf && treeChildren.hasMoreElements())\n\t\t\t{\n\t\t\t\tif (!eventChildren.contains(treeChildren.nextElement()))\n\t\t\t\t{\n\t\t\t\t\twasLeaf = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (wasLeaf)\n\t\t\t{\n\t\t\t\t// parentNode now has children for the first time, so we need to invalidate\n\t\t\t\t// grandparent so that parentNode's junctionLink gets rebuilt with a plus/minus link\n\t\t\t\tObject grandparentNode = getParentNode(parentNode);\n\t\t\t\tinvalidateNodeWithChildren(grandparentNode);\n\t\t\t\tgetTreeState().expandNode(parentNode);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (isNodeExpanded(parentNode))\n\t\t\t\t{\n\t\t\t\t\tTreeItem parentItem = nodeToItemMap.get(parentNode);\n\t\t\t\t\tif (parentItem != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (parentItem.getChildren() == null || parentItem.getChildren().isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinvalidateNode(parentNode, true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int i = 0; i < e.getChildren().length; ++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tObject node = e.getChildren()[i];\n\t\t\t\t\t\t\tint index = e.getChildIndices()[i];\n\t\t\t\t\t\t\tTreeItem item = newTreeItem(parentItem, node, parentItem.getLevel() + 1);\n\t\t\t\t\t\t\titemContainer.add(item);\n\n\t\t\t\t\t\t\tif (parentItem.getChildren() != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tparentItem.getChildren().add(index, item);\n\t\t\t\t\t\t\t\tmarkTheLastButOneChildDirty(parentItem, item);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!dirtyItems.contains(item))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdirtyItems.add(item);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!dirtyItemsCreateDOM.contains(item) &&\n\t\t\t\t\t\t\t\t!item.hasParentWithChildrenMarkedToRecreation())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdirtyItemsCreateDOM.add(item);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":44030,"modified_method":"/**\n\t * @see javax.swing.event.TreeModelListener#treeNodesInserted(javax.swing.event.TreeModelEvent)\n\t */\n\tpublic final void treeNodesInserted(TreeModelEvent e)\n\t{\n\t\tif (dirtyAll)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\t// get the parent node of inserted nodes\n\t\tObject parentNode = e.getTreePath().getLastPathComponent();\n\t\tTreeItem parentItem = nodeToItemMap.get(parentNode);\n\n\n\t\tif (parentItem != null && isNodeVisible(parentNode))\n\t\t{\n\t\t\t// parentNode was a leaf before this insertion event only if every one of\n\t\t\t// its current children is in the event's list of children\n\t\t\tList<?> eventChildren = Arrays.asList(e.getChildren());\n\t\t\tList<TreeItem> itemChildren = parentItem.getChildren();\n\t\t\tboolean wasLeaf = itemChildren == null || eventChildren.containsAll(itemChildren);\n\n\t\t\tif (wasLeaf)\n\t\t\t{\n\t\t\t\t// parentNode now has children for the first time, so we need to invalidate\n\t\t\t\t// grandparent so that parentNode's junctionLink gets rebuilt with a plus/minus link\n\t\t\t\tObject grandparentNode = getParentNode(parentNode);\n\t\t\t\tinvalidateNodeWithChildren(grandparentNode);\n\t\t\t\tgetTreeState().expandNode(parentNode);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (isNodeExpanded(parentNode))\n\t\t\t\t{\n\t\t\t\t\tfinal int[] childIndices = e.getChildIndices();\n\t\t\t\t\tfor (int i = 0; i < eventChildren.size(); ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tObject node = eventChildren.get(i);\n\t\t\t\t\t\tint index = childIndices[i];\n\t\t\t\t\t\tTreeItem item = newTreeItem(parentItem, node, parentItem.getLevel() + 1);\n\t\t\t\t\t\titemContainer.add(item);\n\n\t\t\t\t\t\tif (itemChildren != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\titemChildren.add(index, item);\n\t\t\t\t\t\t\tmarkTheLastButOneChildDirty(parentItem, item);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!dirtyItems.contains(item))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdirtyItems.add(item);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!dirtyItemsCreateDOM.contains(item) &&\n\t\t\t\t\t\t\t!item.hasParentWithChildrenMarkedToRecreation())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdirtyItemsCreateDOM.add(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"714217d07d1e26259a5113b29cdf844e1eeb65c1","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n    public JetTypeInfo visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression, ExpressionTypingContext context) {\n        JetTypeReference right = expression.getRight();\n        JetType result = null;\n        if (right != null) {\n            JetType targetType = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, right, context.trace, true);\n\n            if (isTypeFlexible(expression.getLeft()) || expression.getOperationSign().getReferencedNameElementType() == JetTokens.COLON) {\n                TemporaryBindingTrace temporaryTraceWithExpectedType = TemporaryBindingTrace.create(context.trace);\n                boolean success = checkBinaryWithTypeRHS(expression, context.replaceBindingTrace(temporaryTraceWithExpectedType).replaceExpectedType(targetType), targetType);\n                if (success) {\n                    temporaryTraceWithExpectedType.commit();\n                }\n                else {\n                    checkBinaryWithTypeRHS(expression, context.replaceExpectedType(NO_EXPECTED_TYPE), targetType);\n                }\n            }\n            else {\n                checkBinaryWithTypeRHS(expression, context.replaceExpectedType(NO_EXPECTED_TYPE), targetType);\n            }\n\n            IElementType operationType = expression.getOperationSign().getReferencedNameElementType();\n            result = operationType == JetTokens.AS_SAFE ? TypeUtils.makeNullable(targetType) : targetType;\n        }\n        else {\n            facade.getTypeInfo(expression.getLeft(), context.replaceExpectedType(NO_EXPECTED_TYPE));\n        }\n        return DataFlowUtils.checkType(result, expression, context, context.dataFlowInfo);\n    }","id":44031,"modified_method":"@Override\n    public JetTypeInfo visitBinaryWithTypeRHSExpression(JetBinaryExpressionWithTypeRHS expression, ExpressionTypingContext context) {\n        JetTypeReference right = expression.getRight();\n        JetType result = null;\n        if (right != null) {\n            JetType targetType = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, right, context.trace, true);\n\n            boolean tryWithNoExpectedType = true;\n            if (isTypeFlexible(expression.getLeft()) || expression.getOperationSign().getReferencedNameElementType() == JetTokens.COLON) {\n                TemporaryBindingTrace temporaryTraceWithExpectedType = TemporaryBindingTrace.create(context.trace);\n                ExpressionTypingContext contextWithTemporaryTrace = context.replaceBindingTrace(temporaryTraceWithExpectedType).replaceExpectedType(targetType);\n                JetTypeInfo typeInfo = facade.getTypeInfo(expression.getLeft(), contextWithTemporaryTrace);\n                if (typeInfo.getType() != null && checkBinaryWithTypeRHS(expression, contextWithTemporaryTrace, targetType, typeInfo.getType())) {\n                    temporaryTraceWithExpectedType.commit();\n                    tryWithNoExpectedType = false;\n                }\n            }\n\n            if (tryWithNoExpectedType) {\n                ExpressionTypingContext contextWithNoExpectedType = context.replaceExpectedType(NO_EXPECTED_TYPE);\n                JetTypeInfo typeInfo = facade.getTypeInfo(expression.getLeft(), contextWithNoExpectedType);\n                if (typeInfo.getType() != null) {\n                    checkBinaryWithTypeRHS(expression, contextWithNoExpectedType, targetType, typeInfo.getType());\n                }\n            }\n\n            IElementType operationType = expression.getOperationSign().getReferencedNameElementType();\n            result = operationType == JetTokens.AS_SAFE ? TypeUtils.makeNullable(targetType) : targetType;\n        }\n        else {\n            facade.getTypeInfo(expression.getLeft(), context.replaceExpectedType(NO_EXPECTED_TYPE));\n        }\n        return DataFlowUtils.checkType(result, expression, context, context.dataFlowInfo);\n    }","commit_id":"2b6927ad3bb1562fafb43f9c7567c0eb5051139f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private boolean checkBinaryWithTypeRHS(JetBinaryExpressionWithTypeRHS expression, ExpressionTypingContext context, @NotNull JetType targetType) {\n\n        JetType actualType = facade.getTypeInfo(expression.getLeft(), context).getType();\n        if (actualType == null) return false;\n\n        JetSimpleNameExpression operationSign = expression.getOperationSign();\n        IElementType operationType = operationSign.getReferencedNameElementType();\n        if (operationType == JetTokens.COLON) {\n            if (targetType != NO_EXPECTED_TYPE && !JetTypeChecker.INSTANCE.isSubtypeOf(actualType, targetType)) {\n                context.trace.report(TYPE_MISMATCH.on(expression.getLeft(), targetType, actualType));\n                return false;\n            }\n            return true;\n        }\n        else if (operationType == JetTokens.AS_KEYWORD || operationType == JetTokens.AS_SAFE) {\n            checkForCastImpossibility(expression, actualType, targetType, context);\n            return true;\n        }\n        else {\n            context.trace.report(UNSUPPORTED.on(operationSign, \"binary operation with type RHS\"));\n            return false;\n        }\n    }","id":44032,"modified_method":"private boolean checkBinaryWithTypeRHS(JetBinaryExpressionWithTypeRHS expression, ExpressionTypingContext context, @NotNull JetType targetType, JetType actualType) {\n        JetSimpleNameExpression operationSign = expression.getOperationSign();\n        IElementType operationType = operationSign.getReferencedNameElementType();\n        if (operationType == JetTokens.COLON) {\n            if (targetType != NO_EXPECTED_TYPE && !JetTypeChecker.INSTANCE.isSubtypeOf(actualType, targetType)) {\n                context.trace.report(TYPE_MISMATCH.on(expression.getLeft(), targetType, actualType));\n                return false;\n            }\n            return true;\n        }\n        else if (operationType == JetTokens.AS_KEYWORD || operationType == JetTokens.AS_SAFE) {\n            checkForCastImpossibility(expression, actualType, targetType, context);\n            return true;\n        }\n        else {\n            context.trace.report(UNSUPPORTED.on(operationSign, \"binary operation with type RHS\"));\n            return false;\n        }\n    }","commit_id":"2b6927ad3bb1562fafb43f9c7567c0eb5051139f","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public JetType visitSimpleNameExpression(JetSimpleNameExpression expression, ExpressionTypingContext context) {\n        // TODO : other members\n        // TODO : type substitutions???\n        String referencedName = expression.getReferencedName();\n        if (expression.getReferencedNameElementType() == JetTokens.FIELD_IDENTIFIER\n                && referencedName != null) {\n            PropertyDescriptor property = context.scope.getPropertyByFieldReference(referencedName);\n            if (property == null) {\n                context.trace.report(UNRESOLVED_REFERENCE.on(expression));\n            }\n            else {\n                context.trace.record(REFERENCE_TARGET, expression, property);\n                return DataFlowUtils.checkType(property.getOutType(), expression, context);\n            }\n        }\n        else {\n            return getSelectorReturnType(NO_RECEIVER, null, expression, context); // TODO : Extensions to this\n        }\n        return null;\n    }","id":44033,"modified_method":"@Override\n    public JetType visitSimpleNameExpression(JetSimpleNameExpression expression, ExpressionTypingContext context) {\n        // TODO : other members\n        // TODO : type substitutions???\n        String referencedName = expression.getReferencedName();\n        if (expression.getReferencedNameElementType() == JetTokens.FIELD_IDENTIFIER\n                && referencedName != null) {\n            PropertyDescriptor property = context.scope.getPropertyByFieldReference(referencedName);\n            if (property == null) {\n                context.trace.report(UNRESOLVED_REFERENCE.on(expression));\n            }\n            else {\n                context.trace.record(REFERENCE_TARGET, expression, property);\n                return DataFlowUtils.checkType(property.getOutType(), expression, context);\n            }\n        }\n        else {\n            return DataFlowUtils.checkType(getSelectorReturnType(NO_RECEIVER, null, expression, context), expression, context); // TODO : Extensions to this\n        }\n        return null;\n    }","commit_id":"c6f6f182b68cd16d7237004fddbc88628ec00d13","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public JetType getSelectorReturnType(@NotNull ReceiverDescriptor receiver, @Nullable ASTNode callOperationNode, @NotNull JetExpression selectorExpression, @NotNull ExpressionTypingContext context) {\n        if (selectorExpression instanceof JetCallExpression) {\n            JetCallExpression callExpression = (JetCallExpression) selectorExpression;\n            return context.resolveCall(receiver, callOperationNode, callExpression);\n        }\n        else if (selectorExpression instanceof JetSimpleNameExpression) {\n            JetSimpleNameExpression nameExpression = (JetSimpleNameExpression) selectorExpression;\n\n            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(context.trace);\n            VariableDescriptor variableDescriptor = context.replaceBindingTrace(temporaryTrace).resolveSimpleProperty(receiver, callOperationNode, nameExpression);\n            if (variableDescriptor != null) {\n                temporaryTrace.commit();\n                return DataFlowUtils.checkType(variableDescriptor.getOutType(), nameExpression, context);\n            }\n            ExpressionTypingContext newContext = receiver.exists() ? context.replaceScope(receiver.getType().getMemberScope()) : context;\n            JetType jetType = lookupNamespaceOrClassObject(nameExpression, nameExpression.getReferencedName(), newContext);\n            if (jetType == null) {\n                context.trace.report(UNRESOLVED_REFERENCE.on(nameExpression));\n            }\n            return DataFlowUtils.checkType(jetType, nameExpression, context);\n        }\n        else if (selectorExpression instanceof JetQualifiedExpression) {\n            JetQualifiedExpression qualifiedExpression = (JetQualifiedExpression) selectorExpression;\n            JetExpression newReceiverExpression = qualifiedExpression.getReceiverExpression();\n            JetType newReceiverType = getSelectorReturnType(receiver, callOperationNode, newReceiverExpression, context.replaceExpectedType(NO_EXPECTED_TYPE));\n            JetExpression newSelectorExpression = qualifiedExpression.getSelectorExpression();\n            if (newReceiverType != null && newSelectorExpression != null) {\n                return getSelectorReturnType(new ExpressionReceiver(newReceiverExpression, newReceiverType), qualifiedExpression.getOperationTokenNode(), newSelectorExpression, context);\n            }\n        }\n        else {\n            context.trace.report(ILLEGAL_SELECTOR.on(selectorExpression, selectorExpression.getText()));\n        }\n        return null;\n    }","id":44034,"modified_method":"@Nullable\n    public JetType getSelectorReturnType(@NotNull ReceiverDescriptor receiver, @Nullable ASTNode callOperationNode, @NotNull JetExpression selectorExpression, @NotNull ExpressionTypingContext context) {\n        if (selectorExpression instanceof JetCallExpression) {\n            JetCallExpression callExpression = (JetCallExpression) selectorExpression;\n            return context.resolveCall(receiver, callOperationNode, callExpression);\n        }\n        else if (selectorExpression instanceof JetSimpleNameExpression) {\n            JetSimpleNameExpression nameExpression = (JetSimpleNameExpression) selectorExpression;\n\n            TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(context.trace);\n            VariableDescriptor variableDescriptor = context.replaceBindingTrace(temporaryTrace).resolveSimpleProperty(receiver, callOperationNode, nameExpression);\n            if (variableDescriptor != null) {\n                temporaryTrace.commit();\n                return variableDescriptor.getOutType();\n            }\n            ExpressionTypingContext newContext = receiver.exists() ? context.replaceScope(receiver.getType().getMemberScope()) : context;\n            JetType jetType = lookupNamespaceOrClassObject(nameExpression, nameExpression.getReferencedName(), newContext);\n            if (jetType == null) {\n                context.trace.report(UNRESOLVED_REFERENCE.on(nameExpression));\n            }\n            return jetType;\n        }\n        else if (selectorExpression instanceof JetQualifiedExpression) {\n            JetQualifiedExpression qualifiedExpression = (JetQualifiedExpression) selectorExpression;\n            JetExpression newReceiverExpression = qualifiedExpression.getReceiverExpression();\n            JetType newReceiverType = getSelectorReturnType(receiver, callOperationNode, newReceiverExpression, context.replaceExpectedType(NO_EXPECTED_TYPE));\n            JetExpression newSelectorExpression = qualifiedExpression.getSelectorExpression();\n            if (newReceiverType != null && newSelectorExpression != null) {\n                return getSelectorReturnType(new ExpressionReceiver(newReceiverExpression, newReceiverType), qualifiedExpression.getOperationTokenNode(), newSelectorExpression, context);\n            }\n        }\n        else {\n            context.trace.report(ILLEGAL_SELECTOR.on(selectorExpression, selectorExpression.getText()));\n        }\n        return null;\n    }","commit_id":"c6f6f182b68cd16d7237004fddbc88628ec00d13","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public JetType visitQualifiedExpression(JetQualifiedExpression expression, ExpressionTypingContext contextWithExpectedType) {\n        ExpressionTypingContext context = contextWithExpectedType.replaceExpectedType(NO_EXPECTED_TYPE);\n        // TODO : functions as values\n        JetExpression selectorExpression = expression.getSelectorExpression();\n        JetExpression receiverExpression = expression.getReceiverExpression();\n        JetType receiverType = facade.getType(receiverExpression,\n                                              context\n                                                      .replaceExpectedType(NO_EXPECTED_TYPE)\n                                                      .replaceExpectedReturnType(NO_EXPECTED_TYPE)\n                                                      .replaceNamespacesAllowed(true));\n        if (selectorExpression == null) return null;\n        if (receiverType == null) receiverType = ErrorUtils.createErrorType(\"Type for \" + expression.getText());\n\n        if (selectorExpression instanceof JetSimpleNameExpression) {\n            propagateConstantValues(expression, context, (JetSimpleNameExpression) selectorExpression);\n        }\n\n        JetType selectorReturnType = getSelectorReturnType(new ExpressionReceiver(receiverExpression, receiverType), expression.getOperationTokenNode(), selectorExpression, context);\n\n        //TODO move further\n        if (expression.getOperationSign() == JetTokens.SAFE_ACCESS) {\n            if (selectorReturnType != null && !selectorReturnType.isNullable() && !JetStandardClasses.isUnit(selectorReturnType)) {\n                if (receiverType.isNullable()) {\n                    selectorReturnType = TypeUtils.makeNullable(selectorReturnType);\n                }\n            }\n        }\n\n        JetType result;\n        if (expression.getOperationSign() == JetTokens.QUEST) {\n            if (selectorReturnType != null && !isBoolean(context.semanticServices, selectorReturnType)) {\n                // TODO : more comprehensible error message\n                context.trace.report(TYPE_MISMATCH.on(selectorExpression, context.semanticServices.getStandardLibrary().getBooleanType(), selectorReturnType));\n            }\n            result = TypeUtils.makeNullable(receiverType);\n        }\n        else {\n            result = selectorReturnType;\n        }\n        // TODO : this is suspicious: remove this code?\n        if (result != null) {\n            context.trace.record(BindingContext.EXPRESSION_TYPE, selectorExpression, result);\n        }\n        return DataFlowUtils.checkType(result, expression, contextWithExpectedType);\n    }","id":44035,"modified_method":"@Override\n    public JetType visitQualifiedExpression(JetQualifiedExpression expression, ExpressionTypingContext context) {\n        // TODO : functions as values\n        JetExpression selectorExpression = expression.getSelectorExpression();\n        JetExpression receiverExpression = expression.getReceiverExpression();\n        ExpressionTypingContext contextWithNoExpectedType = context.replaceExpectedType(NO_EXPECTED_TYPE);\n        JetType receiverType = facade.getType(receiverExpression,\n                                              contextWithNoExpectedType\n                                                      .replaceExpectedReturnType(NO_EXPECTED_TYPE)\n                                                      .replaceNamespacesAllowed(true));\n        if (selectorExpression == null) return null;\n        if (receiverType == null) receiverType = ErrorUtils.createErrorType(\"Type for \" + expression.getText());\n\n        if (selectorExpression instanceof JetSimpleNameExpression) {\n            propagateConstantValues(expression, context, (JetSimpleNameExpression) selectorExpression);\n        }\n\n        JetType selectorReturnType = getSelectorReturnType(new ExpressionReceiver(receiverExpression, receiverType), expression.getOperationTokenNode(), selectorExpression, context);\n\n        //TODO move further\n        if (expression.getOperationSign() == JetTokens.SAFE_ACCESS) {\n            if (selectorReturnType != null && !selectorReturnType.isNullable() && !JetStandardClasses.isUnit(selectorReturnType)) {\n                if (receiverType.isNullable()) {\n                    selectorReturnType = TypeUtils.makeNullable(selectorReturnType);\n                }\n            }\n        }\n\n        JetType result;\n        if (expression.getOperationSign() == JetTokens.QUEST) {\n            if (selectorReturnType != null && !isBoolean(context.semanticServices, selectorReturnType)) {\n                // TODO : more comprehensible error message\n                context.trace.report(TYPE_MISMATCH.on(selectorExpression, context.semanticServices.getStandardLibrary().getBooleanType(), selectorReturnType));\n            }\n            result = TypeUtils.makeNullable(receiverType);\n        }\n        else {\n            result = selectorReturnType;\n        }\n        // TODO : this is suspicious: remove this code?\n        if (result != null) {\n            context.trace.record(BindingContext.EXPRESSION_TYPE, selectorExpression, result);\n        }\n        return DataFlowUtils.checkType(result, expression, context);\n    }","commit_id":"c6f6f182b68cd16d7237004fddbc88628ec00d13","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public JetType visitFunctionLiteralExpression(JetFunctionLiteralExpression expression, ExpressionTypingContext context) {\n        JetFunctionLiteral functionLiteral = expression.getFunctionLiteral();\n        JetBlockExpression bodyExpression = functionLiteral.getBodyExpression();\n        if (bodyExpression == null) return null;\n\n        JetType expectedType = context.expectedType;\n        boolean functionTypeExpected = expectedType != TypeUtils.NO_EXPECTED_TYPE && JetStandardClasses.isFunctionType(expectedType);\n\n        SimpleFunctionDescriptorImpl functionDescriptor = createFunctionDescriptor(expression, context, functionTypeExpected);\n\n        List<JetType> parameterTypes = Lists.newArrayList();\n        List<ValueParameterDescriptor> valueParameters = functionDescriptor.getValueParameters();\n        for (ValueParameterDescriptor valueParameter : valueParameters) {\n            parameterTypes.add(valueParameter.getType());\n        }\n        ReceiverDescriptor receiverParameter = functionDescriptor.getReceiverParameter();\n        JetType receiver = receiverParameter != NO_RECEIVER ? receiverParameter.getType() : null;\n\n        JetType returnType = TypeUtils.NO_EXPECTED_TYPE;\n        JetScope functionInnerScope = FunctionDescriptorUtil.getFunctionInnerScope(context.scope, functionDescriptor, context.trace);\n        JetTypeReference returnTypeRef = functionLiteral.getReturnTypeRef();\n        if (returnTypeRef != null) {\n            returnType = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, returnTypeRef, context.trace, true);\n            context.expressionTypingServices.checkFunctionReturnType(expression, context.replaceScope(functionInnerScope).\n                    replaceExpectedType(returnType).replaceDataFlowInfo(context.dataFlowInfo), context.trace);\n        }\n        else {\n            if (functionTypeExpected) {\n                returnType = JetStandardClasses.getReturnTypeFromFunctionType(expectedType);\n            }\n            returnType = context.expressionTypingServices.getBlockReturnedType(functionInnerScope, bodyExpression, CoercionStrategy.COERCION_TO_UNIT,\n                    context.replaceExpectedType(returnType), context.trace);\n        }\n        JetType safeReturnType = returnType == null ? ErrorUtils.createErrorType(\"<return type>\") : returnType;\n        functionDescriptor.setReturnType(safeReturnType);\n\n        boolean hasDeclaredValueParameters = functionLiteral.getValueParameterList() != null;\n        if (!hasDeclaredValueParameters && functionTypeExpected) {\n            JetType expectedReturnType = JetStandardClasses.getReturnTypeFromFunctionType(expectedType);\n            if (JetStandardClasses.isUnit(expectedReturnType)) {\n                functionDescriptor.setReturnType(JetStandardClasses.getUnitType());\n                return DataFlowUtils.checkType(JetStandardClasses.getFunctionType(Collections.<AnnotationDescriptor>emptyList(), receiver, parameterTypes, JetStandardClasses.getUnitType()), expression, context);\n            }\n\n        }\n        return DataFlowUtils.checkType(JetStandardClasses.getFunctionType(Collections.<AnnotationDescriptor>emptyList(), receiver, parameterTypes, safeReturnType), expression, context);\n    }","id":44036,"modified_method":"@Override\n    public JetType visitFunctionLiteralExpression(JetFunctionLiteralExpression expression, ExpressionTypingContext context) {\n        JetFunctionLiteral functionLiteral = expression.getFunctionLiteral();\n        JetBlockExpression bodyExpression = functionLiteral.getBodyExpression();\n        if (bodyExpression == null) return null;\n\n        JetType expectedType = context.expectedType;\n        boolean functionTypeExpected = expectedType != TypeUtils.NO_EXPECTED_TYPE && JetStandardClasses.isFunctionType(expectedType);\n\n        SimpleFunctionDescriptorImpl functionDescriptor = createFunctionDescriptor(expression, context, functionTypeExpected);\n\n        List<JetType> parameterTypes = Lists.newArrayList();\n        List<ValueParameterDescriptor> valueParameters = functionDescriptor.getValueParameters();\n        for (ValueParameterDescriptor valueParameter : valueParameters) {\n            parameterTypes.add(valueParameter.getType());\n        }\n        ReceiverDescriptor receiverParameter = functionDescriptor.getReceiverParameter();\n        JetType receiver = receiverParameter != NO_RECEIVER ? receiverParameter.getType() : null;\n\n        JetType returnType = TypeUtils.NO_EXPECTED_TYPE;\n        JetScope functionInnerScope = FunctionDescriptorUtil.getFunctionInnerScope(context.scope, functionDescriptor, context.trace);\n        JetTypeReference returnTypeRef = functionLiteral.getReturnTypeRef();\n        TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(context.trace);\n        if (returnTypeRef != null) {\n            returnType = context.expressionTypingServices.getTypeResolver().resolveType(context.scope, returnTypeRef, context.trace, true);\n            context.expressionTypingServices.checkFunctionReturnType(expression, context.replaceScope(functionInnerScope).\n                    replaceExpectedType(returnType).replaceBindingTrace(temporaryTrace), temporaryTrace);\n        }\n        else {\n            if (functionTypeExpected) {\n                returnType = JetStandardClasses.getReturnTypeFromFunctionType(expectedType);\n            }\n            returnType = context.expressionTypingServices.getBlockReturnedType(functionInnerScope, bodyExpression, CoercionStrategy.COERCION_TO_UNIT,\n                    context.replaceExpectedType(returnType).replaceBindingTrace(temporaryTrace), temporaryTrace);\n        }\n        temporaryTrace.commit(new Predicate<WritableSlice>() {\n            @Override\n            public boolean apply(@Nullable WritableSlice slice) {\n                return (slice != BindingContext.RESOLUTION_RESULTS_FOR_FUNCTION && slice != BindingContext.RESOLUTION_RESULTS_FOR_PROPERTY &&\n                        slice != BindingContext.TRACE_DELTAS_CACHE);\n            }\n        }, true);\n        JetType safeReturnType = returnType == null ? ErrorUtils.createErrorType(\"<return type>\") : returnType;\n        functionDescriptor.setReturnType(safeReturnType);\n\n        boolean hasDeclaredValueParameters = functionLiteral.getValueParameterList() != null;\n        if (!hasDeclaredValueParameters && functionTypeExpected) {\n            JetType expectedReturnType = JetStandardClasses.getReturnTypeFromFunctionType(expectedType);\n            if (JetStandardClasses.isUnit(expectedReturnType)) {\n                functionDescriptor.setReturnType(JetStandardClasses.getUnitType());\n                return DataFlowUtils.checkType(JetStandardClasses.getFunctionType(Collections.<AnnotationDescriptor>emptyList(), receiver, parameterTypes, JetStandardClasses.getUnitType()), expression, context);\n            }\n\n        }\n        return DataFlowUtils.checkType(JetStandardClasses.getFunctionType(Collections.<AnnotationDescriptor>emptyList(), receiver, parameterTypes, safeReturnType), expression, context);\n    }","commit_id":"98b40ac6d2cec03ef2f82deade3506916c1e6c6d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public JetType visitObjectLiteralExpression(final JetObjectLiteralExpression expression, final ExpressionTypingContext context) {\n        final JetType[] result = new JetType[1];\n        ObservableBindingTrace.RecordHandler<PsiElement, ClassDescriptor> handler = new ObservableBindingTrace.RecordHandler<PsiElement, ClassDescriptor>() {\n\n            @Override\n            public void handleRecord(WritableSlice<PsiElement, ClassDescriptor> slice, PsiElement declaration, final ClassDescriptor descriptor) {\n                if (slice == CLASS && declaration == expression.getObjectDeclaration()) {\n                    JetType defaultType = DeferredType.create(context.trace, new LazyValueWithDefault<JetType>(ErrorUtils.createErrorType(\"Recursive dependency\")) {\n                        @Override\n                        protected JetType compute() {\n                            return descriptor.getDefaultType();\n                        }\n                    });\n                    result[0] = defaultType;\n                    if (!context.trace.get(PROCESSED, expression)) {\n                        context.trace.record(EXPRESSION_TYPE, expression, defaultType);\n                        context.trace.record(PROCESSED, expression);\n                    }\n                }\n            }\n        };\n        ObservableBindingTrace traceAdapter = new ObservableBindingTrace(context.trace);\n        traceAdapter.addHandler(CLASS, handler);\n        TopDownAnalyzer.processObject(context.expressionTypingServices.getProject(), traceAdapter, context.scope, context.scope.getContainingDeclaration(), expression.getObjectDeclaration());\n        return DataFlowUtils.checkType(result[0], expression, context);\n    }","id":44037,"modified_method":"@Override\n    public JetType visitObjectLiteralExpression(final JetObjectLiteralExpression expression, final ExpressionTypingContext context) {\n        DelegatingBindingTrace delegatingBindingTrace = context.trace.get(TRACE_DELTAS_CACHE, expression.getObjectDeclaration());\n        if (delegatingBindingTrace != null) {\n            delegatingBindingTrace.addAllMyDataTo(context.trace);\n            JetType type = context.trace.get(EXPRESSION_TYPE, expression);\n            return DataFlowUtils.checkType(type, expression, context);\n        }\n        final JetType[] result = new JetType[1];\n        final TemporaryBindingTrace temporaryTrace = TemporaryBindingTrace.create(context.trace);\n        ObservableBindingTrace.RecordHandler<PsiElement, ClassDescriptor> handler = new ObservableBindingTrace.RecordHandler<PsiElement, ClassDescriptor>() {\n\n            @Override\n            public void handleRecord(WritableSlice<PsiElement, ClassDescriptor> slice, PsiElement declaration, final ClassDescriptor descriptor) {\n                if (slice == CLASS && declaration == expression.getObjectDeclaration()) {\n                    JetType defaultType = DeferredType.create(context.trace, new LazyValueWithDefault<JetType>(ErrorUtils.createErrorType(\"Recursive dependency\")) {\n                        @Override\n                        protected JetType compute() {\n                            return descriptor.getDefaultType();\n                        }\n                    });\n                    result[0] = defaultType;\n                    if (!context.trace.get(PROCESSED, expression)) {\n                        temporaryTrace.record(EXPRESSION_TYPE, expression, defaultType);\n                        temporaryTrace.record(PROCESSED, expression);\n                    }\n                }\n            }\n        };\n        ObservableBindingTrace traceAdapter = new ObservableBindingTrace(temporaryTrace);\n        traceAdapter.addHandler(CLASS, handler);\n        TopDownAnalyzer.processObject(context.expressionTypingServices.getProject(), traceAdapter, context.scope, context.scope.getContainingDeclaration(), expression.getObjectDeclaration());\n\n        DelegatingBindingTrace cloneDelta = new DelegatingBindingTrace(new BindingTraceContext().getBindingContext());\n        temporaryTrace.addAllMyDataTo(cloneDelta);\n        context.trace.record(TRACE_DELTAS_CACHE, expression.getObjectDeclaration(), cloneDelta);\n        temporaryTrace.commit();\n        return DataFlowUtils.checkType(result[0], expression, context);\n    }","commit_id":"98b40ac6d2cec03ef2f82deade3506916c1e6c6d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public JetTypeInfo getArgumentTypeInfo(\n            @Nullable JetExpression expression,\n            @NotNull CallResolutionContext<?> context,\n            @NotNull ResolveArgumentsMode resolveArgumentsMode,\n            @Nullable TemporaryBindingTrace traceToCommitForCall\n    ) {\n        if (expression == null) {\n            return JetTypeInfo.create(null, context.dataFlowInfo);\n        }\n        if (expression instanceof JetFunctionLiteralExpression) {\n            return getFunctionLiteralTypeInfo((JetFunctionLiteralExpression) expression, context, resolveArgumentsMode);\n        }\n        JetTypeInfo recordedTypeInfo = getRecordedTypeInfo(expression, context.trace.getBindingContext());\n        if (recordedTypeInfo != null) {\n            return recordedTypeInfo;\n        }\n        //todo deparenthesize\n        CallExpressionResolver callExpressionResolver = expressionTypingServices.getCallExpressionResolver();\n        if (!(expression instanceof JetCallExpression) && !(expression instanceof JetQualifiedExpression)) {\n            return expressionTypingServices.getTypeInfo(context.scope, expression, context.expectedType, context.dataFlowInfo, context.trace);\n        }\n\n        JetTypeInfo result;\n        if (expression instanceof JetCallExpression) {\n            result = callExpressionResolver.getCallExpressionTypeInfo(\n                    (JetCallExpression) expression, ReceiverValue.NO_RECEIVER, null,\n                    context.replaceExpectedType(TypeUtils.NO_EXPECTED_TYPE), ResolveMode.NESTED_CALL, context.resolutionResultsCache);\n        }\n        else { // expression instanceof JetQualifiedExpression\n            result = callExpressionResolver.getQualifiedExpressionTypeInfo(\n                    (JetQualifiedExpression) expression, context.replaceExpectedType(TypeUtils.NO_EXPECTED_TYPE),\n                    ResolveMode.NESTED_CALL, context.resolutionResultsCache);\n        }\n\n        recordExpressionType(expression, context.trace, context.scope, result);\n        if (traceToCommitForCall != null) {\n            traceToCommitForCall.commit();\n        }\n        return result;\n    }","id":44038,"modified_method":"@NotNull\n    public JetTypeInfo getArgumentTypeInfo(\n            @Nullable JetExpression expression,\n            @NotNull CallResolutionContext<?> context,\n            @NotNull ResolveArgumentsMode resolveArgumentsMode,\n            @Nullable TemporaryBindingTrace traceToCommitForCall\n    ) {\n        if (expression == null) {\n            return JetTypeInfo.create(null, context.dataFlowInfo);\n        }\n        if (expression instanceof JetFunctionLiteralExpression) {\n            return getFunctionLiteralTypeInfo((JetFunctionLiteralExpression) expression, context, resolveArgumentsMode);\n        }\n        JetTypeInfo recordedTypeInfo = getRecordedTypeInfo(expression, context.trace.getBindingContext());\n        if (recordedTypeInfo != null) {\n            return recordedTypeInfo;\n        }\n        ResolutionContext newContext = context.replaceExpectedType(TypeUtils.NO_EXPECTED_TYPE).replaceResolveMode(ResolveMode.NESTED_CALL);\n        JetTypeInfo result = expressionTypingServices.getTypeInfo(expression, newContext);\n        if (traceToCommitForCall != null) {\n            traceToCommitForCall.commit();\n        }\n        return result;\n    }","commit_id":"4f2df78066706f4e1707c05046279a21674df4b9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public <D extends CallableDescriptor> JetType completeNestedCallsInference(\n            @NotNull CallCandidateResolutionContext<D> context\n    ) {\n        ResolvedCallImpl<D> resolvedCall = context.candidateCall;\n        ConstraintSystem constraintSystem = context.candidateCall.getConstraintSystem();\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : resolvedCall.getValueArguments().entrySet()) {\n            ValueParameterDescriptor parameterDescriptor = entry.getKey();\n            ResolvedValueArgument resolvedArgument = entry.getValue();\n\n            for (ValueArgument argument : resolvedArgument.getArguments()) {\n                JetExpression expression = argument.getArgumentExpression();\n                if (expression == null) continue;\n\n                JetType effectiveExpectedType = getEffectiveExpectedType(parameterDescriptor, argument);\n                JetType expectedType = constraintSystem != null\n                                       ? constraintSystem.getCurrentSubstitutor().substitute(effectiveExpectedType, Variance.INVARIANT)\n                                       : effectiveExpectedType;\n\n                //todo inner calls should be analyzed, for parenthesized, labeled, if, when expressions as well\n                JetVisitor<JetExpression, Void> selectorExpressionFinder = new JetVisitor<JetExpression, Void>() {\n                    @Override\n                    public JetExpression visitQualifiedExpression(JetQualifiedExpression expression, Void data) {\n                        JetExpression selector = expression.getSelectorExpression();\n                        return selector != null ? selector.accept(this, null) : null;\n                    }\n\n                    @Override\n                    public JetExpression visitCallExpression(JetCallExpression expression, Void data) {\n                        return expression;\n                    }\n\n                    @Override\n                    public JetExpression visitSimpleNameExpression(JetSimpleNameExpression expression, Void data) {\n                        return expression;\n                    }\n\n                    @Override\n                    public JetExpression visitJetElement(JetElement element, Void data) {\n                        return null;\n                    }\n                };\n                // selector expression is callExpression or simpleNameExpression (if it's inside qualified expression)\n                JetExpression selectorExpression = expression.accept(selectorExpressionFinder, null);\n                if (selectorExpression == null) continue;\n\n                if (selectorExpression instanceof JetSimpleNameExpression) {\n                    if (expression instanceof JetQualifiedExpression) {\n                        //todo get rid of this hack, 'checkType' once at the end of the analysis\n                        JetType type = context.trace.get(BindingContext.EXPRESSION_TYPE, selectorExpression);\n                        DataFlowUtils.checkType(type, expression, context.replaceExpectedType(expectedType));\n                    }\n                    continue;\n                }\n                CallCandidateResolutionContext<FunctionDescriptor> storedContextForArgument =\n                        context.resolutionResultsCache.getDeferredComputation(CallKey.create(Call.CallType.DEFAULT, selectorExpression));\n                //todo assert storedContextForArgument != null\n                if (storedContextForArgument == null) continue;\n\n                CallCandidateResolutionContext<FunctionDescriptor> contextForArgument =\n                        storedContextForArgument.replaceResolveMode(ResolveMode.TOP_LEVEL_CALL).replaceBindingTrace(context.trace).replaceExpectedType(expectedType);\n                JetType type;\n                if (contextForArgument.candidateCall.hasIncompleteTypeParameters()) {\n                    type = completeTypeInferenceDependentOnExpectedTypeForCall(contextForArgument, true);\n                }\n                else {\n                    type = completeNestedCallsInference(contextForArgument);\n                    checkValueArgumentTypes(contextForArgument);\n                }\n\n                DataFlowUtils.checkType(type, expression, contextForArgument);\n            }\n        }\n        recordReferenceForInvokeFunction(context);\n        return resolvedCall.getResultingDescriptor().getReturnType();\n    }","id":44039,"modified_method":"@Nullable\n    public <D extends CallableDescriptor> JetType completeNestedCallsInference(\n            @NotNull CallCandidateResolutionContext<D> context\n    ) {\n        ResolvedCallImpl<D> resolvedCall = context.candidateCall;\n        ConstraintSystem constraintSystem = context.candidateCall.getConstraintSystem();\n        for (Map.Entry<ValueParameterDescriptor, ResolvedValueArgument> entry : resolvedCall.getValueArguments().entrySet()) {\n            ValueParameterDescriptor parameterDescriptor = entry.getKey();\n            ResolvedValueArgument resolvedArgument = entry.getValue();\n\n            for (ValueArgument argument : resolvedArgument.getArguments()) {\n                JetExpression expression = argument.getArgumentExpression();\n                if (expression == null) continue;\n\n                JetType effectiveExpectedType = getEffectiveExpectedType(parameterDescriptor, argument);\n                JetType expectedType = constraintSystem != null\n                                       ? constraintSystem.getCurrentSubstitutor().substitute(effectiveExpectedType, Variance.INVARIANT)\n                                       : effectiveExpectedType;\n\n                JetVisitor<JetExpression, Void> selectorExpressionFinder = new JetVisitor<JetExpression, Void>() {\n                    @Override\n                    public JetExpression visitQualifiedExpression(JetQualifiedExpression expression, Void data) {\n                        JetExpression selector = expression.getSelectorExpression();\n                        return selector != null ? selector.accept(this, null) : null;\n                    }\n\n                    @Override\n                    public JetExpression visitExpression(JetExpression expression, Void data) {\n                        return expression;\n                    }\n                };\n                JetExpression selectorExpression = expression.accept(selectorExpressionFinder, null);\n\n                CallCandidateResolutionContext<FunctionDescriptor> storedContextForArgument =\n                        context.resolutionResultsCache.getDeferredComputation(CallKey.create(Call.CallType.DEFAULT, selectorExpression));\n                //todo assert storedContextForArgument != null\n                if (storedContextForArgument == null) {\n                    PsiElement parent = expression.getParent();\n                    if (parent instanceof JetWhenExpression && expression == ((JetWhenExpression) parent).getSubjectExpression()\n                        || (expression instanceof JetFunctionLiteralExpression)) {\n                        continue;\n                    }\n                    JetType type = context.trace.get(BindingContext.EXPRESSION_TYPE, expression);\n                    ResolutionContext<?> newContext = context.replaceExpectedType(expectedType);\n                    DataFlowUtils.checkType(type, expression, newContext);\n                    continue;\n                }\n\n                CallCandidateResolutionContext<FunctionDescriptor> contextForArgument =\n                        storedContextForArgument.replaceResolveMode(ResolveMode.TOP_LEVEL_CALL).replaceBindingTrace(context.trace).replaceExpectedType(expectedType);\n                JetType type;\n                if (contextForArgument.candidateCall.hasIncompleteTypeParameters()) {\n                    type = completeTypeInferenceDependentOnExpectedTypeForCall(contextForArgument, true);\n                }\n                else {\n                    type = completeNestedCallsInference(contextForArgument);\n                    checkValueArgumentTypes(contextForArgument);\n                }\n\n                DataFlowUtils.checkType(type, expression, contextForArgument);\n            }\n        }\n        recordReferenceForInvokeFunction(context);\n        return resolvedCall.getResultingDescriptor().getReturnType();\n    }","commit_id":"4f2df78066706f4e1707c05046279a21674df4b9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ControllerResponse processHeartBeat(HeartBeat heartbeat) \n      throws DatatypeConfigurationException, IOException {\n    ControllerResponse response = \n        agentToHeartbeatResponseMap.get(heartbeat.getHostname());\n    if (response != null) {\n      if (response.getResponseId() == heartbeat.getResponseId()) {\n        return response; //duplicate heartbeat\n      }\n    }\n    \n    short responseId = \n        (short) (Short.parseShort(response.getResponseId()) + 1);\n    \n    String hostname = heartbeat.getHostname();\n\n    Node node = Nodes.getInstance().getNodes().get(hostname);\n    NodeState state = node.getNodeState();\n    GregorianCalendar c = new GregorianCalendar();\n    c.setTime(new Date());\n    state.setLastHeartbeatTime(\n        DatatypeFactory.newInstance().newXMLGregorianCalendar(c));\n    \n    Cluster cluster = \n        Clusters.getInstance().getClusterByID(state.getClusterID());\n    ClusterContext clusterContext = new ClusterContextImpl(cluster, node);\n    \n    List<Action> allActions = new ArrayList<Action>();\n    \n    if (heartbeat.getIdle()) {\n      //if the command-execution takes longer than one heartbeat interval\n      //the check for idleness will prevent the same node getting the same \n      //command more than once. In the future this could be improved\n      //to reflect the command execution state more accurately.\n      \n      //get what is currently running on the node\n      List<ServerStatus> roleStatuses = heartbeat.getServersStatus();\n      \n      //what servers are running currently\n      //ADD LOGIC FOR CAPTURING THE CLUSTER-ID THE SERVERS BELONG TO\n      //IF THEY BELONG TO THE CLUSTER-ID THIS NODE IS PART OF, WELL AND GOOD\n      //IF NOT, THEN SEND COMMANDS TO STOP THE SERVERS\n      StartedComponentServers componentServers = new StartedComponentServers();\n      for (ServerStatus status : roleStatuses) {\n        componentServers.roleServerStarted(status.getComponent(), \n            status.getRole());\n      }\n\n      //get the state machine reference to the cluster\n      ClusterFSM clusterSMobject = StateMachineInvoker\n          .getStateMachineClusterInstance(cluster.getID(), \n              cluster.getLatestClusterDefinition().getBlueprintName(), \n              cluster.getLatestClusterDefinition().getBlueprintRevision());\n      //the state machine reference to the services\n      List<ServiceFSM> clusterServices = clusterSMobject.getServices();\n      //go through all the services, and check which role should be started\n      for (ServiceFSM service : clusterServices) {\n        List<RoleFSM> roles = service.getRoles();\n        \n        for (RoleFSM role : roles) {\n          boolean roleServerRunning = componentServers.isStarted(\n              role.getAssociatedService().getServiceName(),\n              role.getRoleName());\n          //TODO: get reference to the plugin impl for this service/component\n          HDFSPluginImpl plugin = new HDFSPluginImpl();\n          //check whether the agent should start any server\n          if (role.shouldStart()) {\n            if (!roleServerRunning) {\n              short retryCount = retryCountForRole.get(hostname);\n              if (retryCount > MAX_RETRY_COUNT) {\n                //LOG the failure to start the role server\n                StateMachineInvoker.getAMBARIEventHandler()\n                .handle(new RoleEvent(RoleEventType.START_FAILURE, role));\n                retryCountForRole.resetAttemptCount(hostname);\n                continue;\n              }\n              List<Action> actions = \n                  plugin.startRoleServer(clusterContext, role.getRoleName());\n              allActions.addAll(actions);\n              retryCountForRole.incrAttemptCount(hostname);\n            }\n            //raise an event to the state machine for a successful role-start\n            if (roleServerRunning) {\n              retryCountForRole.resetAttemptCount(hostname);\n              StateMachineInvoker.getAMBARIEventHandler()\n              .handle(new RoleEvent(RoleEventType.START_SUCCESS, role));\n            }\n          }\n          //check whether the agent should stop any server\n          if (role.shouldStop()) {\n            if (roleServerRunning) {\n              short retryCount = retryCountForRole.get(hostname);\n              if (retryCount > MAX_RETRY_COUNT) {\n                //LOG the failure to stop the role server\n                StateMachineInvoker.getAMBARIEventHandler()\n                .handle(new RoleEvent(RoleEventType.STOP_FAILURE, role));\n                retryCountForRole.resetAttemptCount(hostname);\n                continue;\n              }\n              List<Action> actions = \n                  plugin.stopRoleServer(clusterContext, role.getRoleName());\n              allActions.addAll(actions);\n              retryCountForRole.incrAttemptCount(hostname);\n            }\n            //raise an event to the state machine for a successful role-stop\n            if (!roleServerRunning) {\n              retryCountForRole.resetAttemptCount(hostname);\n              StateMachineInvoker.getAMBARIEventHandler()\n              .handle(new RoleEvent(RoleEventType.STOP_SUCCESS, role));\n            }\n          }\n        }\n      }\n    }\n    ControllerResponse r = new ControllerResponse();\n    r.setResponseId(String.valueOf(responseId));\n    r.setActions(allActions);\n    agentToHeartbeatResponseMap.put(heartbeat.getHostname(), r);\n    return r;\n  }","id":44040,"modified_method":"public ControllerResponse processHeartBeat(HeartBeat heartbeat) \n      throws DatatypeConfigurationException, IOException {\n    ControllerResponse response = \n        agentToHeartbeatResponseMap.get(heartbeat.getHostname());\n    if (response != null) {\n      if (response.getResponseId() == heartbeat.getResponseId()) {\n        return response; //duplicate heartbeat\n      }\n    }\n    \n    short responseId = \n        (short) (Short.parseShort(response.getResponseId()) + 1);\n    \n    String hostname = heartbeat.getHostname();\n\n    Node node = Nodes.getInstance().getNodes().get(hostname);\n    NodeState state = node.getNodeState();\n    GregorianCalendar c = new GregorianCalendar();\n    c.setTime(new Date());\n    state.setLastHeartbeatTime(\n        DatatypeFactory.newInstance().newXMLGregorianCalendar(c));\n    \n    Cluster cluster = \n        Clusters.getInstance().getClusterByID(state.getClusterID());\n    ClusterContext clusterContext = new ClusterContextImpl(cluster, node);\n    \n    List<Action> allActions = new ArrayList<Action>();\n    \n    if (heartbeat.getIdle()) {\n      //if the command-execution takes longer than one heartbeat interval\n      //the check for idleness will prevent the same node getting the same \n      //command more than once. In the future this could be improved\n      //to reflect the command execution state more accurately.\n      \n      String desiredBlueprint = \n          cluster.getLatestClusterDefinition().getBlueprintName();\n      String desiredBlueprintRev = \n          cluster.getLatestClusterDefinition().getBlueprintRevision();\n      String desiredClusterId = cluster.getID();\n      ClusterFSM desiredClusterFSM = StateMachineInvoker\n          .getStateMachineClusterInstance(desiredClusterId, desiredBlueprint,\n              desiredBlueprintRev);\n      \n      StartedComponentServers componentServers = new StartedComponentServers();\n      //check if the node is in the expected cluster (with the appropriate \n      //revision of the blueprint)      \n      //get the list of install/uninstall actions\n      //create a map from component/role to 'started' for easy lookup later\n      List<Action> installAndUninstallActions = \n          getInstallAndUninstallActions(heartbeat, desiredClusterFSM, \n              clusterContext, componentServers);\n\n      //get the state machine reference to the cluster\n      ClusterFSM clusterSMobject = StateMachineInvoker\n          .getStateMachineClusterInstance(desiredClusterId, desiredBlueprint, \n              desiredBlueprintRev);\n      //the state machine reference to the services\n      List<ServiceFSM> clusterServices = clusterSMobject.getServices();\n      //go through all the services, and check which role should be started\n      for (ServiceFSM service : clusterServices) {\n        List<RoleFSM> roles = service.getRoles();\n        \n        for (RoleFSM role : roles) {\n          boolean roleServerRunning = componentServers.isStarted(\n              role.getAssociatedService().getServiceName(),\n              role.getRoleName());\n          //TODO: get reference to the plugin impl for this service/component\n          HDFSPluginImpl plugin = new HDFSPluginImpl();\n          //check whether the agent should start any server\n          if (role.shouldStart()) {\n            if (!roleServerRunning) {\n              short retryCount = retryCountForRole.get(hostname);\n              if (retryCount > MAX_RETRY_COUNT) {\n                //LOG the failure to start the role server\n                StateMachineInvoker.getAMBARIEventHandler()\n                .handle(new RoleEvent(RoleEventType.START_FAILURE, role));\n                retryCountForRole.resetAttemptCount(hostname);\n                continue;\n              }\n              List<Action> actions = \n                  plugin.startRoleServer(clusterContext, role.getRoleName());\n              allActions.addAll(actions);\n              retryCountForRole.incrAttemptCount(hostname);\n            }\n            //raise an event to the state machine for a successful role-start\n            if (roleServerRunning) {\n              retryCountForRole.resetAttemptCount(hostname);\n              StateMachineInvoker.getAMBARIEventHandler()\n              .handle(new RoleEvent(RoleEventType.START_SUCCESS, role));\n            }\n          }\n          //check whether the agent should stop any server\n          if (role.shouldStop()) {\n            if (roleServerRunning) {\n              short retryCount = retryCountForRole.get(hostname);\n              if (retryCount > MAX_RETRY_COUNT) {\n                //LOG the failure to stop the role server\n                StateMachineInvoker.getAMBARIEventHandler()\n                .handle(new RoleEvent(RoleEventType.STOP_FAILURE, role));\n                retryCountForRole.resetAttemptCount(hostname);\n                continue;\n              }\n              List<Action> actions = \n                  plugin.stopRoleServer(clusterContext, role.getRoleName());\n              allActions.addAll(actions);\n              retryCountForRole.incrAttemptCount(hostname);\n            }\n            //raise an event to the state machine for a successful role-stop\n            if (!roleServerRunning) {\n              retryCountForRole.resetAttemptCount(hostname);\n              StateMachineInvoker.getAMBARIEventHandler()\n              .handle(new RoleEvent(RoleEventType.STOP_SUCCESS, role));\n            }\n          }\n        }\n      }\n    }\n    ControllerResponse r = new ControllerResponse();\n    r.setResponseId(String.valueOf(responseId));\n    r.setActions(allActions);\n    agentToHeartbeatResponseMap.put(heartbeat.getHostname(), r);\n    return r;\n  }","commit_id":"0e6fa6dda071952f4d6350026a1220b4cc3f45d1","url":"https://github.com/apache/ambari"},{"original_method":"public ServerStatus(String component, String role, State state) {\n    this.component = component;\n    this.role = role;\n    this.state = state;\n  }","id":44041,"modified_method":"public ServerStatus(State state) {\n    this.state = state;\n  }","commit_id":"0e6fa6dda071952f4d6350026a1220b4cc3f45d1","url":"https://github.com/apache/ambari"},{"original_method":"/** \n   * Update state of the node (Internal API to be used by Ambari agent).\n   *  \n   * @response.representation.200.doc This API is invoked by Ambari agent running\n   *  on a cluster to update the state of various services running on the node.\n   * @response.representation.200.mediaType application/json\n   * @response.representation.200.example { \"a\" : \"b\" }\n   * @response.representation.500.doc Error in accepting heartbeat message\n   * @param message Heartbeat message\n   */\n  @Path(\"heartbeat/{hostname}\")\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})\n  public ControllerResponse heartbeat(HeartBeat message) {\n    ControllerResponse controllerResponse = new ControllerResponse();\n    controllerResponse.setResponseId(\"id-00002\");    \n    String cmd = \"import os\\nos._exit(0)\";\n    String[] param = { \"cluster\", \"role\" };\n    Command command = new Command(\"root\", cmd, param);\n\n    Command cleanUp = new Command(\"root\", cmd, param);\n    \n    Action action = new Action();\n    action.setUser(\"hdfs\");\n    action.setComponent(\"hdfs\");\n    action.setRole(\"datanode\");\n    action.setKind(Kind.STOP_ACTION);\n    action.setSignal(Signal.KILL);\n    action.setClusterId(\"cluster-001\");\n    action.setBluePrintName(\"blueprint\");\n    action.setBluePrintRevision(\"0.1\");\n    action.setId(\"action-001\");\n\n    Action action2 = new Action();\n    action2.setUser(\"hdfs\");\n    action2.setKind(Kind.START_ACTION);\n    action2.setId(\"action-002\");\n    action2.setClusterId(\"cluster-002\");\n    action2.setCommand(command);\n    action2.setCleanUpCommand(cleanUp);\n    action2.setComponent(\"hdfs\");\n    action2.setBluePrintName(\"blueprint\");\n    action2.setBluePrintRevision(\"0.2\");\n    action2.setRole(\"datanode\");\n\n    Action action3 = new Action();\n    action3.setUser(\"hdfs\");\n    action3.setKind(Kind.RUN_ACTION);\n    action3.setId(\"action-003\");\n    action3.setBluePrintName(\"blueprint\");\n    action3.setBluePrintRevision(\"0.2\");\n    action3.setClusterId(\"cluster-003\");\n    action3.setCommand(command);\n    action3.setCleanUpCommand(cleanUp);\n\n    List<Action> actions = new ArrayList<Action>();\n    actions.add(action);\n    actions.add(action2);\n    actions.add(action3);\n    controllerResponse.setActions(actions);\n    return controllerResponse;\n  }","id":44042,"modified_method":"/** \n   * Update state of the node (Internal API to be used by Ambari agent).\n   *  \n   * @response.representation.200.doc This API is invoked by Ambari agent running\n   *  on a cluster to update the state of various services running on the node.\n   * @response.representation.200.mediaType application/json\n   * @response.representation.200.example { \"a\" : \"b\" }\n   * @response.representation.500.doc Error in accepting heartbeat message\n   * @param message Heartbeat message\n   */\n  @Path(\"heartbeat/{hostname}\")\n  @POST\n  @Consumes(MediaType.APPLICATION_JSON)\n  @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})\n  public ControllerResponse heartbeat(HeartBeat message) {\n    ControllerResponse controllerResponse = new ControllerResponse();\n    controllerResponse.setResponseId(\"id-00002\");    \n    String script = \"import os\\nos._exit(0)\";\n    String[] param = { \"cluster\", \"role\" };\n    Command command = new Command(\"root\", script, param);\n\n    Command cleanUp = new Command(\"root\", script, param);\n    \n    Action action = new Action();\n    action.setUser(\"hdfs\");\n    action.setKind(Kind.STOP_ACTION);\n    action.setSignal(Signal.KILL);\n    action.setClusterId(\"cluster-001\");\n    action.setBluePrintName(\"blueprint\");\n    action.setBluePrintRevision(\"0.1\");\n    action.setComponent(\"hdfs\");\n    action.setRole(\"datanode\");\n    action.setId(\"action-001\");\n\n    Action action2 = new Action();\n    action2.setUser(\"hdfs\");\n    action2.setKind(Kind.START_ACTION);\n    action2.setId(\"action-002\");\n    action2.setClusterId(\"cluster-002\");\n    action2.setCommand(command);\n    action2.setCleanUpCommand(cleanUp);\n    action2.setBluePrintName(\"blueprint\");\n    action2.setBluePrintRevision(\"0.2\");\n    action2.setComponent(\"hdfs\");\n    action2.setRole(\"datanode\");\n\n    Action action3 = new Action();\n    action3.setUser(\"hdfs\");\n    action3.setKind(Kind.RUN_ACTION);\n    action3.setId(\"action-003\");\n    action3.setClusterId(\"cluster-003\");\n    action3.setBluePrintName(\"blueprint\");\n    action3.setBluePrintRevision(\"0.2\");\n    action3.setComponent(\"hdfs\");\n    action3.setRole(\"datanode\");\n    action3.setCommand(command);\n    action3.setCleanUpCommand(cleanUp);\n\n    List<Action> actions = new ArrayList<Action>();\n    actions.add(action);\n    actions.add(action2);\n    actions.add(action3);\n    controllerResponse.setActions(actions);\n    return controllerResponse;\n  }","commit_id":"06a53a0633d11b2b56b8d9d12a29c63bb4317a07","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Sample controller to agent response message\n   * \n   * @response.representation.200.example { \"a\" : \"b\" }\n   * @response.representation.200.doc Print an example of Controller Response to Agent\n   * @response.representation.200.mediaType application/json\n   * @return ControllerResponse A list of command to execute on agent\n   */\n  @Path(\"response/sample\")\n  @GET\n  @Produces(\"application/json\")\n  public ControllerResponse getControllerResponse() {\n    ControllerResponse controllerResponse = new ControllerResponse();\n    controllerResponse.setResponseId(\"id-00002\");    \n    \n    String cmd = \"import os\\nos._exit(0)\";\n    String[] param = { \"cluster\", \"role\" };\n\n    Command command = new Command(\"root\", cmd, param);\n    Command cleanUp = new Command(\"root\", cmd, param);\n    \n    Action action = new Action();\n    action.setKind(Kind.CREATE_STRUCTURE_ACTION);\n    action.setComponent(\"hdfs\");\n    action.setRole(\"datanode\");\n    \n    Action action1 = new Action();\n    action1.setBluePrintName(\"blueprint\");\n    action1.setBluePrintRevision(\"0.1\");\n    action1.setUser(\"hdfs\");\n    action1.setComponent(\"hdfs\");\n    action1.setRole(\"datanode\");\n    action1.setKind(Kind.STOP_ACTION);\n    action1.setSignal(Signal.KILL);\n    action1.setClusterId(\"cluster-001\");\n    action1.setId(\"action-001\");\n\n    Action action2 = new Action();\n    action2.setBluePrintName(\"blueprint\");\n    action2.setBluePrintRevision(\"0.1\");\n    action2.setUser(\"hdfs\");\n    action2.setKind(Kind.START_ACTION);\n    action2.setId(\"action-002\");\n    action2.setClusterId(\"cluster-002\");\n    action2.setCommand(command);\n    action2.setCleanUpCommand(cleanUp);\n    action2.setComponent(\"hdfs\");\n    action2.setRole(\"datanode\");\n    \n    Action action3 = new Action();\n    action3.setBluePrintName(\"blueprint\");\n    action3.setBluePrintRevision(\"0.1\");\n    action3.setUser(\"hdfs\");\n    action3.setKind(Kind.RUN_ACTION);\n    action3.setId(\"action-003\");\n    action3.setClusterId(\"cluster-002\");\n    action3.setCommand(command);\n    action3.setCleanUpCommand(cleanUp);\n    \n    Action action4 = new Action();\n    action4.setBluePrintName(\"blueprint\");\n    action4.setBluePrintRevision(\"0.1\");\n    action4.setUser(\"hdfs\");\n    action4.setKind(Kind.WRITE_FILE_ACTION);\n    String owner =\"hdfs\";\n    String group = \"hadoop\";\n    String permission = \"0700\";\n    String path = \"$prefix/config\";\n    String umask = \"022\";\n    String data = \"Content of the file\";\n    action4.setFile(new ConfigFile(owner, group, permission, path, umask, data));\n    \n    Action action5 = new Action();\n    action5.setKind(Kind.DELETE_STRUCTURE_ACTION);\n    action5.setComponent(\"hdfs\");\n    action5.setRole(\"datanode\");\n    \n    List<Action> actions = new ArrayList<Action>();\n    actions.add(action);\n    actions.add(action1);\n    actions.add(action2);\n    actions.add(action3);\n    actions.add(action4);\n    controllerResponse.setActions(actions);\n    return controllerResponse;\n  }","id":44043,"modified_method":"/**\n   * Sample controller to agent response message\n   * \n   * @response.representation.200.example { \"a\" : \"b\" }\n   * @response.representation.200.doc Print an example of Controller Response to Agent\n   * @response.representation.200.mediaType application/json\n   * @return ControllerResponse A list of command to execute on agent\n   */\n  @Path(\"response/sample\")\n  @GET\n  @Produces(\"application/json\")\n  public ControllerResponse getControllerResponse() {\n    ControllerResponse controllerResponse = new ControllerResponse();\n    controllerResponse.setResponseId(\"id-00002\");    \n    \n    String script = \"import os\\nos._exit(0)\";\n    String[] param = { \"cluster\", \"role\" };\n\n    Command command = new Command(\"root\", script, param);\n    Command cleanUp = new Command(\"root\", script, param);\n    \n    Action action = new Action();\n    action.setKind(Kind.CREATE_STRUCTURE_ACTION);\n    action.setComponent(\"hdfs\");\n    action.setRole(\"datanode\");\n    \n    Action action1 = new Action();\n    action1.setBluePrintName(\"blueprint\");\n    action1.setBluePrintRevision(\"0.1\");\n    action1.setUser(\"hdfs\");\n    action1.setComponent(\"hdfs\");\n    action1.setRole(\"datanode\");\n    action1.setKind(Kind.STOP_ACTION);\n    action1.setSignal(Signal.KILL);\n    action1.setClusterId(\"cluster-001\");\n    action1.setId(\"action-001\");\n\n    Action action2 = new Action();\n    action2.setBluePrintName(\"blueprint\");\n    action2.setBluePrintRevision(\"0.1\");\n    action2.setUser(\"hdfs\");\n    action2.setKind(Kind.START_ACTION);\n    action2.setId(\"action-002\");\n    action2.setClusterId(\"cluster-002\");\n    action2.setCommand(command);\n    action2.setCleanUpCommand(cleanUp);\n    action2.setComponent(\"hdfs\");\n    action2.setRole(\"datanode\");\n    \n    Action action3 = new Action();\n    action3.setBluePrintName(\"blueprint\");\n    action3.setBluePrintRevision(\"0.1\");\n    action3.setUser(\"hdfs\");\n    action3.setKind(Kind.RUN_ACTION);\n    action3.setId(\"action-003\");\n    action3.setClusterId(\"cluster-002\");\n    action3.setCommand(command);\n    action3.setCleanUpCommand(cleanUp);\n    action3.setUser(\"hdfs\");\n    action3.setComponent(\"hdfs\");\n    \n    Action action4 = new Action();\n    action4.setBluePrintName(\"blueprint\");\n    action4.setBluePrintRevision(\"0.1\");\n    action4.setUser(\"hdfs\");\n    action4.setKind(Kind.WRITE_FILE_ACTION);\n    action4.setUser(\"hdfs\");\n    action4.setComponent(\"hdfs\");    \n    String owner =\"hdfs\";\n    String group = \"hadoop\";\n    String permission = \"0700\";\n    String path = \"$prefix/config\";\n    String umask = \"022\";\n    String data = \"Content of the file\";\n    action4.setFile(new ConfigFile(owner, group, permission, path, umask, data));\n    \n    Action action5 = new Action();\n    action5.setKind(Kind.DELETE_STRUCTURE_ACTION);\n    action5.setComponent(\"hdfs\");\n    action5.setRole(\"datanode\");\n    \n    List<Action> actions = new ArrayList<Action>();\n    actions.add(action);\n    actions.add(action1);\n    actions.add(action2);\n    actions.add(action3);\n    actions.add(action4);\n    controllerResponse.setActions(actions);\n    return controllerResponse;\n  }","commit_id":"06a53a0633d11b2b56b8d9d12a29c63bb4317a07","url":"https://github.com/apache/ambari"},{"original_method":"public void run() {\n        Map.Entry<Data, Object> mapEntry = recordStore.getMapEntryForBackup(dataKey);\n        if (mapEntry.getValue() != null) {\n            Map.Entry<Object, Object> entry = new AbstractMap.SimpleEntry<Object, Object>(mapService.toObject(dataKey), mapService.toObject(mapEntry.getValue()));\n            entryProcessor.processBackup(entry);\n            if (entry.getValue() == null) {\n                recordStore.removeBackup(dataKey);\n            } else {\n                recordStore.putBackup(dataKey, entry.getValue());\n            }\n        }\n    }","id":44044,"modified_method":"public void run() {\n        Map.Entry<Data, Object> mapEntry = recordStore.getMapEntryForBackup(dataKey);\n        Object objectKey = mapService.toObject(dataKey);\n        final Object valueBeforeProcess = mapService.toObject(mapEntry.getValue());\n        MapEntrySimple<Object, Object> entry = new MapEntrySimple<Object, Object>(objectKey, valueBeforeProcess);\n        entryProcessor.processBackup(entry);\n        if (!entry.isModified()){\n            return;\n        }\n        if (entry.getValue() == null) {\n            recordStore.remove(dataKey);\n        } else {\n            recordStore.putBackup(dataKey, entry.getValue());\n        }\n\n    }","commit_id":"7ab6d2f1f5ef1336a26d8db05f72f14f06ad45f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void run() throws Exception {\n        final InternalPartitionService partitionService = getNodeEngine().getPartitionService();\n        final RecordStore recordStore = mapService.getRecordStore(getPartitionId(), name);\n        MapEntrySimple entry;\n\n        for (Data key : keys) {\n            if (partitionService.getPartitionId(key) != getPartitionId()) {\n                continue;\n            }\n            Object objectKey = mapService.toObject(key);\n            final Map.Entry<Data, Object> mapEntry = recordStore.getMapEntry(key);\n            final Object valueBeforeProcess = mapService.toObject(mapEntry.getValue());\n            entry = new MapEntrySimple(objectKey, valueBeforeProcess);\n            backupProcessor.processBackup(entry);\n            if (entry.getValue() == null) {\n                recordStore.removeBackup(key);\n            } else {\n                recordStore.putBackup(key, entry.getValue());\n            }\n\n        }\n\n    }","id":44045,"modified_method":"@Override\n    public void run() throws Exception {\n        final InternalPartitionService partitionService = getNodeEngine().getPartitionService();\n        final RecordStore recordStore = mapService.getRecordStore(getPartitionId(), name);\n        MapEntrySimple entry;\n\n        for (Data key : keys) {\n            if (partitionService.getPartitionId(key) != getPartitionId()) {\n                continue;\n            }\n            Object objectKey = mapService.toObject(key);\n            final Map.Entry<Data, Object> mapEntry = recordStore.getMapEntry(key);\n            final Object valueBeforeProcess = mapService.toObject(mapEntry.getValue());\n            entry = new MapEntrySimple(objectKey, valueBeforeProcess);\n            backupProcessor.processBackup(entry);\n            if (!entry.isModified()) {\n                continue;\n            }\n            if (entry.getValue() == null) {\n                recordStore.remove(key);\n            } else {\n                recordStore.putBackup(key, entry.getValue());\n            }\n        }\n    }","commit_id":"7ab6d2f1f5ef1336a26d8db05f72f14f06ad45f9","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() {\n        Map.Entry<Data, Object> mapEntry = recordStore.getMapEntryForBackup(dataKey);\n        if (mapEntry.getValue() != null) {\n            Map.Entry<Object, Object> entry = new AbstractMap.SimpleEntry<Object, Object>(mapService.toObject(dataKey), mapService.toObject(mapEntry.getValue()));\n            entryProcessor.processBackup(entry);\n            if (entry.getValue() == null){\n                recordStore.remove(dataKey);\n            } else {\n                recordStore.putBackup(dataKey, entry.getValue());\n            }\n        }\n    }","id":44046,"modified_method":"public void run() {\n        Map.Entry<Data, Object> mapEntry = recordStore.getMapEntryForBackup(dataKey);\n        Object objectKey = mapService.toObject(dataKey);\n        final Object valueBeforeProcess = mapService.toObject(mapEntry.getValue());\n        MapEntrySimple<Object, Object> entry = new MapEntrySimple<Object, Object>(objectKey, valueBeforeProcess);\n        entryProcessor.processBackup(entry);\n        if (!entry.isModified()){\n            return;\n        }\n        if (entry.getValue() == null) {\n            recordStore.remove(dataKey);\n        } else {\n            recordStore.putBackup(dataKey, entry.getValue());\n        }\n\n    }","commit_id":"0b0026e6bc76d6a5a15dafbce41a8d0dd26383be","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void run() throws Exception {\n        final InternalPartitionService partitionService = getNodeEngine().getPartitionService();\n        final RecordStore recordStore = mapService.getRecordStore(getPartitionId(), name);\n        MapEntrySimple entry;\n\n        for (Data key : keys) {\n            if (partitionService.getPartitionId(key) != getPartitionId())\n                continue;\n            Object objectKey = mapService.toObject(key);\n            final Map.Entry<Data, Object> mapEntry = recordStore.getMapEntry(key);\n            final Object valueBeforeProcess = mapService.toObject(mapEntry.getValue());\n            entry = new MapEntrySimple(objectKey, valueBeforeProcess);\n            backupProcessor.processBackup(entry);\n            if (entry.getValue() == null) {\n                recordStore.remove(key);\n            } else {\n                recordStore.putBackup(key, entry.getValue());\n            }\n\n        }\n\n    }","id":44047,"modified_method":"@Override\n    public void run() throws Exception {\n        final InternalPartitionService partitionService = getNodeEngine().getPartitionService();\n        final RecordStore recordStore = mapService.getRecordStore(getPartitionId(), name);\n        MapEntrySimple entry;\n\n        for (Data key : keys) {\n            if (partitionService.getPartitionId(key) != getPartitionId())\n                continue;\n            Object objectKey = mapService.toObject(key);\n            final Map.Entry<Data, Object> mapEntry = recordStore.getMapEntry(key);\n            final Object valueBeforeProcess = mapService.toObject(mapEntry.getValue());\n            entry = new MapEntrySimple(objectKey, valueBeforeProcess);\n            backupProcessor.processBackup(entry);\n            if (!entry.isModified()) {\n                continue;\n            }\n            if (entry.getValue() == null) {\n                recordStore.remove(key);\n            } else {\n                recordStore.putBackup(key, entry.getValue());\n            }\n        }\n    }","commit_id":"0b0026e6bc76d6a5a15dafbce41a8d0dd26383be","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() {\n        mapService = (MapService) getService();\n        RecordStore recordStore = mapService.getRecordStore(getPartitionId(), name);\n        Map.Entry<Data, Object> mapEntry = recordStore.getMapEntryObject(dataKey);\n        entry = new AbstractMap.SimpleEntry<Object,Object>(mapService.toObject(dataKey), mapEntry.getValue());\n        entryProcessor.processBackup(entry);\n        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data, Object>(dataKey, entry.getValue()));\n    }","id":44048,"modified_method":"public void run() {\n        Map.Entry<Data, Object> mapEntry = recordStore.getMapEntryObject(dataKey);\n        if (mapEntry.getValue() != null) {\n            Map.Entry<Object, Object> entry = new AbstractMap.SimpleEntry<Object, Object>(mapService.toObject(dataKey), mapEntry.getValue());\n            entryProcessor.processBackup(entry);\n            recordStore.put(new AbstractMap.SimpleImmutableEntry<Data, Object>(dataKey, entry.getValue()));\n        }\n    }","commit_id":"226d76d97956e134a9e9fa402abc15e3922c7ced","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void run() {\n        Map.Entry<Data, Object> mapEntry = recordStore.getMapEntryObject(dataKey);\n        entry = new AbstractMap.SimpleEntry(mapService.toObject(dataKey), mapService.toObject(mapEntry.getValue()));\n        response = mapService.toData(entryProcessor.process(entry));\n        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data, Object>(dataKey, entry.getValue()));\n    }","id":44049,"modified_method":"public void run() {\n        Map.Entry<Data, Object> mapEntry = recordStore.getMapEntryObject(dataKey);\n        Map.Entry entry = new AbstractMap.SimpleEntry(mapService.toObject(dataKey), mapService.toObject(mapEntry.getValue()));\n        response = mapService.toData(entryProcessor.process(entry));\n        recordStore.put(new AbstractMap.SimpleImmutableEntry<Data, Object>(dataKey, entry.getValue()));\n    }","commit_id":"226d76d97956e134a9e9fa402abc15e3922c7ced","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Operation getBackupOperation() {\n        return new EntryBackupOperation(name, dataKey, entryProcessor.getBackupProcessor());\n    }","id":44050,"modified_method":"public Operation getBackupOperation() {\n        EntryBackupProcessor backupProcessor = entryProcessor.getBackupProcessor();\n        return backupProcessor != null ? new EntryBackupOperation(name, dataKey, backupProcessor) : null;\n    }","commit_id":"226d76d97956e134a9e9fa402abc15e3922c7ced","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Map.Entry<Data, Object> getMapEntryObject(Data dataKey) {\n        Record record = records.get(dataKey);\n        return new AbstractMap.SimpleImmutableEntry<Data, Object>(dataKey, mapService.toObject(record.getValue()));\n    }","id":44051,"modified_method":"public Map.Entry<Data, Object> getMapEntryObject(Data dataKey) {\n        Record record = records.get(dataKey);\n        Object value = record != null ? mapService.toObject(record.getValue()) : null;\n        return new AbstractMap.SimpleImmutableEntry<Data, Object>(dataKey, value);\n    }","commit_id":"226d76d97956e134a9e9fa402abc15e3922c7ced","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Map.Entry<Data, Data> getMapEntryData(Data dataKey) {\n        Record record = records.get(dataKey);\n        return new AbstractMap.SimpleImmutableEntry<Data, Data>(dataKey, mapService.toData(record.getValue()));\n    }","id":44052,"modified_method":"public Map.Entry<Data, Data> getMapEntryData(Data dataKey) {\n        Record record = records.get(dataKey);\n        Data data = record != null ? mapService.toData(record.getValue()) : null;\n        return new AbstractMap.SimpleImmutableEntry<Data, Data>(dataKey, data);\n    }","commit_id":"226d76d97956e134a9e9fa402abc15e3922c7ced","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public Operation getBackupOperation() {\n        return new PartitionWideEntryBackupOperation(name, entryProcessor.getBackupProcessor());\n    }","id":44053,"modified_method":"@Override\n    public Operation getBackupOperation() {\n        EntryBackupProcessor backupProcessor = entryProcessor.getBackupProcessor();\n        return backupProcessor != null ? new PartitionWideEntryBackupOperation(name, backupProcessor) : null;\n    }","commit_id":"226d76d97956e134a9e9fa402abc15e3922c7ced","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public int getAsyncBackupCount() {\n        return mapContainer.getAsyncBackupCount() + mapContainer.getBackupCount();\n    }","id":44054,"modified_method":"public int getAsyncBackupCount() {\n        return mapContainer.getTotalBackupCount();\n    }","commit_id":"226d76d97956e134a9e9fa402abc15e3922c7ced","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n\t * Handles servlet page requests.\n\t * \n\t * @param servletRequest\n\t *            Servlet request object\n\t * @param servletResponse\n\t *            Servlet response object\n\t * @throws ServletException\n\t *             Thrown if something goes wrong during request handling\n\t * @throws IOException\n\t */\n\tpublic void doGet(final HttpServletRequest servletRequest,\n\t\t\tfinal HttpServletResponse servletResponse) throws ServletException, IOException\n\t{\n\t\t// if called externally (i.e. WicketServlet) we need to set the thread local here\n\t\t// AND clean it up at the end of the request\n\t\tboolean externalCall = !Application.exists();\n\t\tif (externalCall)\n\t\t{\n\t\t\tApplication.set(webApplication);\n\t\t}\n\n\t\tString relativePath = getRelativePath(servletRequest);\n\n\t\t// Special-case for home page - we redirect to add a trailing slash.\n\t\tif (relativePath.length() == 0 &&\n\t\t\t\t!Strings.stripJSessionId(servletRequest.getRequestURI()).endsWith(\"/\"))\n\t\t{\n\t\t\tfinal String redirectUrl = servletRequest.getRequestURI() + \"/\";\n\t\t\tservletResponse.sendRedirect(servletResponse.encodeRedirectURL(redirectUrl));\n\t\t\treturn;\n\t\t}\n\n\t\tfinal ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();\n\t\tfinal ClassLoader newClassLoader = getClassLoader();\n\t\ttry\n\t\t{\n\t\t\tif (previousClassLoader != newClassLoader)\n\t\t\t{\n\t\t\t\tThread.currentThread().setContextClassLoader(newClassLoader);\n\t\t\t}\n\n\t\t\t// If the request does not provide information about the encoding of\n\t\t\t// its body (which includes POST parameters), than assume the\n\t\t\t// default encoding as defined by the wicket application. Bear in\n\t\t\t// mind that the encoding of the request usually is equal to the\n\t\t\t// previous response.\n\t\t\t// However it is a known bug of IE that it does not provide this\n\t\t\t// information. Please see the wiki for more details and why all\n\t\t\t// other browser deliberately copied that bug.\n\t\t\tif (servletRequest.getCharacterEncoding() == null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// The encoding defined by the wicket settings is used to\n\t\t\t\t\t// encode the responses. Thus, it is reasonable to assume\n\t\t\t\t\t// the request has the same encoding. This is especially\n\t\t\t\t\t// important for forms and form parameters.\n\t\t\t\t\tservletRequest.setCharacterEncoding(webApplication.getRequestCycleSettings()\n\t\t\t\t\t\t\t.getResponseRequestEncoding());\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedEncodingException ex)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal RequestCycle existingRequestCycle = RequestCycle.get();\n\n\t\t\t// Create a new webrequest\n\t\t\tfinal WebRequest request = existingRequestCycle != null\n\t\t\t\t\t? (WebRequest)existingRequestCycle.getRequest()\n\t\t\t\t\t: webApplication.newWebRequest(servletRequest);\n\n\t\t\t// Are we using REDIRECT_TO_BUFFER?\n\t\t\tif (webApplication.getRequestCycleSettings().getRenderStrategy() == IRequestCycleSettings.REDIRECT_TO_BUFFER)\n\t\t\t{\n\t\t\t\t// Try to see if there is a redirect stored\n\t\t\t\tISessionStore sessionStore = webApplication.getSessionStore();\n\t\t\t\tString sessionId = sessionStore.getSessionId(request, false);\n\t\t\t\tif (sessionId != null)\n\t\t\t\t{\n\t\t\t\t\tBufferedHttpServletResponse bufferedResponse = null;\n\t\t\t\t\tString queryString = servletRequest.getQueryString();\n\t\t\t\t\tif (!Strings.isEmpty(queryString))\n\t\t\t\t\t{\n\t\t\t\t\t\tbufferedResponse = webApplication.popBufferedResponse(sessionId,\n\t\t\t\t\t\t\t\tqueryString);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbufferedResponse = webApplication.popBufferedResponse(sessionId,\n\t\t\t\t\t\t\t\trelativePath);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bufferedResponse != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbufferedResponse.writeTo(servletResponse);\n\t\t\t\t\t\t// redirect responses are ignored for the request\n\t\t\t\t\t\t// logger...\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Create a response object and set the output encoding according to\n\t\t\t// wicket's application setttings.\n\t\t\tfinal WebResponse response = existingRequestCycle != null\n\t\t\t\t\t? (WebResponse)existingRequestCycle.getResponse()\n\t\t\t\t\t: webApplication.newWebResponse(servletResponse);\n\t\t\tresponse.setAjax(request.isAjax());\n\t\t\tresponse.setCharacterEncoding(webApplication.getRequestCycleSettings()\n\t\t\t\t\t.getResponseRequestEncoding());\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Create request cycle\n\t\t\t\tRequestCycle cycle = existingRequestCycle != null\n\t\t\t\t\t\t? existingRequestCycle\n\t\t\t\t\t\t: webApplication.newRequestCycle(request, response);\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// Process request\n\t\t\t\t\tcycle.request();\n\t\t\t\t}\n\t\t\t\tcatch (AbortException e)\n\t\t\t\t{\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\t// Close response\n\t\t\t\tresponse.close();\n\n\t\t\t\t// Clean up thread local session\n\t\t\t\tSession.unset();\n\n\t\t\t\tif (externalCall)\n\t\t\t\t{\n\t\t\t\t\t// Clean up thread local application if this was an external call\n\t\t\t\t\t// (if not, doFilter will clean it up)\n\t\t\t\t\tApplication.unset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (newClassLoader != previousClassLoader)\n\t\t\t{\n\t\t\t\tThread.currentThread().setContextClassLoader(previousClassLoader);\n\t\t\t}\n\t\t}\n\t}","id":44055,"modified_method":"/**\n\t * Handles servlet page requests.\n\t * \n\t * @param servletRequest\n\t *            Servlet request object\n\t * @param servletResponse\n\t *            Servlet response object\n\t * @throws ServletException\n\t *             Thrown if something goes wrong during request handling\n\t * @throws IOException\n\t */\n\tpublic void doGet(final HttpServletRequest servletRequest,\n\t\t\tfinal HttpServletResponse servletResponse) throws ServletException, IOException\n\t{\n\t\tString relativePath = getRelativePath(servletRequest);\n\n\t\t// Special-case for home page - we redirect to add a trailing slash.\n\t\tif (relativePath.length() == 0 &&\n\t\t\t\t!Strings.stripJSessionId(servletRequest.getRequestURI()).endsWith(\"/\"))\n\t\t{\n\t\t\tfinal String redirectUrl = servletRequest.getRequestURI() + \"/\";\n\t\t\tservletResponse.sendRedirect(servletResponse.encodeRedirectURL(redirectUrl));\n\t\t\treturn;\n\t\t}\n\n\t\tfinal ClassLoader previousClassLoader = Thread.currentThread().getContextClassLoader();\n\t\tfinal ClassLoader newClassLoader = getClassLoader();\n\t\ttry\n\t\t{\n\t\t\tif (previousClassLoader != newClassLoader)\n\t\t\t{\n\t\t\t\tThread.currentThread().setContextClassLoader(newClassLoader);\n\t\t\t}\n\n\t\t\t// If the request does not provide information about the encoding of\n\t\t\t// its body (which includes POST parameters), than assume the\n\t\t\t// default encoding as defined by the wicket application. Bear in\n\t\t\t// mind that the encoding of the request usually is equal to the\n\t\t\t// previous response.\n\t\t\t// However it is a known bug of IE that it does not provide this\n\t\t\t// information. Please see the wiki for more details and why all\n\t\t\t// other browser deliberately copied that bug.\n\t\t\tif (servletRequest.getCharacterEncoding() == null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// The encoding defined by the wicket settings is used to\n\t\t\t\t\t// encode the responses. Thus, it is reasonable to assume\n\t\t\t\t\t// the request has the same encoding. This is especially\n\t\t\t\t\t// important for forms and form parameters.\n\t\t\t\t\tservletRequest.setCharacterEncoding(webApplication.getRequestCycleSettings()\n\t\t\t\t\t\t\t.getResponseRequestEncoding());\n\t\t\t\t}\n\t\t\t\tcatch (UnsupportedEncodingException ex)\n\t\t\t\t{\n\t\t\t\t\tthrow new WicketRuntimeException(ex.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfinal RequestCycle existingRequestCycle = RequestCycle.get();\n\n\t\t\t// Create a new webrequest\n\t\t\tfinal WebRequest request = existingRequestCycle != null\n\t\t\t\t\t? (WebRequest)existingRequestCycle.getRequest()\n\t\t\t\t\t: webApplication.newWebRequest(servletRequest);\n\n\t\t\t// Are we using REDIRECT_TO_BUFFER?\n\t\t\tif (webApplication.getRequestCycleSettings().getRenderStrategy() == IRequestCycleSettings.REDIRECT_TO_BUFFER)\n\t\t\t{\n\t\t\t\t// Try to see if there is a redirect stored\n\t\t\t\tISessionStore sessionStore = webApplication.getSessionStore();\n\t\t\t\tString sessionId = sessionStore.getSessionId(request, false);\n\t\t\t\tif (sessionId != null)\n\t\t\t\t{\n\t\t\t\t\tBufferedHttpServletResponse bufferedResponse = null;\n\t\t\t\t\tString queryString = servletRequest.getQueryString();\n\t\t\t\t\tif (!Strings.isEmpty(queryString))\n\t\t\t\t\t{\n\t\t\t\t\t\tbufferedResponse = webApplication.popBufferedResponse(sessionId,\n\t\t\t\t\t\t\t\tqueryString);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tbufferedResponse = webApplication.popBufferedResponse(sessionId,\n\t\t\t\t\t\t\t\trelativePath);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bufferedResponse != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tbufferedResponse.writeTo(servletResponse);\n\t\t\t\t\t\t// redirect responses are ignored for the request\n\t\t\t\t\t\t// logger...\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tWebResponse response = null;\n\t\t\tboolean externalCall = !Application.exists();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// if called externally (i.e. WicketServlet) we need to set the thread local here\n\t\t\t\t// AND clean it up at the end of the request\n\t\t\t\tif (externalCall)\n\t\t\t\t{\n\t\t\t\t\tApplication.set(webApplication);\n\t\t\t\t}\n\n\t\t\t\t// Create a response object and set the output encoding according to\n\t\t\t\t// wicket's application setttings.\n\t\t\t\tresponse = webApplication.newWebResponse(servletResponse);\n\t\t\t\tresponse.setAjax(request.isAjax());\n\t\t\t\tresponse.setCharacterEncoding(webApplication.getRequestCycleSettings()\n\t\t\t\t\t\t.getResponseRequestEncoding());\n\n\t\t\t\t// Create request cycle\n\t\t\t\tRequestCycle cycle = null;\n\n\t\t\t\tif (existingRequestCycle != null)\n\t\t\t\t{\n\t\t\t\t\t// set the real (maybe) buffered response instead of the empty one\n\t\t\t\t\t// that is created by the last modified call.\n\t\t\t\t\texistingRequestCycle.setResponse(response);\n\t\t\t\t\tcycle = existingRequestCycle;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcycle = webApplication.newRequestCycle(request, response);\n\t\t\t\t}\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// Process request\n\t\t\t\t\tcycle.request();\n\t\t\t\t}\n\t\t\t\tcatch (AbortException e)\n\t\t\t\t{\n\t\t\t\t\t// noop\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\t// Close response\n\t\t\t\tif (response != null)\n\t\t\t\t\tresponse.close();\n\n\t\t\t\t// Clean up thread local session\n\t\t\t\tSession.unset();\n\n\t\t\t\tif (externalCall)\n\t\t\t\t{\n\t\t\t\t\t// Clean up thread local application if this was an external call\n\t\t\t\t\t// (if not, doFilter will clean it up)\n\t\t\t\t\tApplication.unset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tif (newClassLoader != previousClassLoader)\n\t\t\t{\n\t\t\t\tThread.currentThread().setContextClassLoader(previousClassLoader);\n\t\t\t}\n\t\t}\n\t}","commit_id":"45400bde2433c7fc72801bdcd91d93f9394ae530","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest,\n\t *      javax.servlet.ServletResponse, javax.servlet.FilterChain)\n\t */\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\t\tthrows IOException, ServletException\n\t{\n\t\tHttpServletRequest httpServletRequest = (HttpServletRequest)request;\n\t\tString relativePath = getRelativePath(httpServletRequest);\n\n\t\tif (isWicketRequest(relativePath))\n\t\t{\n\t\t\t// Set the webapplication for this thread\n\t\t\tApplication.set(webApplication);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tHttpServletResponse httpServletResponse = (HttpServletResponse)response;\n\t\t\t\tlong lastModified = getLastModified(httpServletRequest, httpServletResponse);\n\t\t\t\tif (lastModified == -1)\n\t\t\t\t{\n\t\t\t\t\t// servlet doesn't support if-modified-since, no reason\n\t\t\t\t\t// to go through further expensive logic\n\t\t\t\t\tdoGet(httpServletRequest, httpServletResponse);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlong ifModifiedSince = httpServletRequest.getDateHeader(\"If-Modified-Since\");\n\t\t\t\t\tif (ifModifiedSince < (lastModified / 1000 * 1000))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the servlet mod time is later, call doGet()\n\t\t\t\t\t\t// Round down to the nearest second for a proper compare\n\t\t\t\t\t\t// A ifModifiedSince of -1 will always be less\n\t\t\t\t\t\tmaybeSetLastModified(httpServletResponse, lastModified);\n\t\t\t\t\t\tdoGet(httpServletRequest, httpServletResponse);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\thttpServletResponse.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\t// we might have created a request cycle inside getLastModified, so we need to\n\t\t\t\t// clean it here (in case the doGet method was not called\n\t\t\t\tif (RequestCycle.get() != null)\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tRequestCycle.get().detach();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"error detaching request cycle \" + RequestCycle.get() + \": \" +\n\t\t\t\t\t\t\t\te.getMessage(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// always unset the application thread local\n\t\t\t\tApplication.unset();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchain.doFilter(request, response);\n\t\t}\n\t}","id":44056,"modified_method":"/**\n\t * @see javax.servlet.Filter#doFilter(javax.servlet.ServletRequest,\n\t *      javax.servlet.ServletResponse, javax.servlet.FilterChain)\n\t */\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\t\tthrows IOException, ServletException\n\t{\n\t\tHttpServletRequest httpServletRequest = (HttpServletRequest)request;\n\t\tString relativePath = getRelativePath(httpServletRequest);\n\n\t\tif (isWicketRequest(relativePath))\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Set the webapplication for this thread\n\t\t\t\tApplication.set(webApplication);\n\n\t\t\t\tHttpServletResponse httpServletResponse = (HttpServletResponse)response;\n\t\t\t\tlong lastModified = getLastModified(httpServletRequest);\n\t\t\t\tif (lastModified == -1)\n\t\t\t\t{\n\t\t\t\t\t// servlet doesn't support if-modified-since, no reason\n\t\t\t\t\t// to go through further expensive logic\n\t\t\t\t\tdoGet(httpServletRequest, httpServletResponse);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlong ifModifiedSince = httpServletRequest.getDateHeader(\"If-Modified-Since\");\n\t\t\t\t\tif (ifModifiedSince < (lastModified / 1000 * 1000))\n\t\t\t\t\t{\n\t\t\t\t\t\t// If the servlet mod time is later, call doGet()\n\t\t\t\t\t\t// Round down to the nearest second for a proper compare\n\t\t\t\t\t\t// A ifModifiedSince of -1 will always be less\n\t\t\t\t\t\tmaybeSetLastModified(httpServletResponse, lastModified);\n\t\t\t\t\t\tdoGet(httpServletRequest, httpServletResponse);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\thttpServletResponse.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\t// we might have created a request cycle inside getLastModified, so we need to\n\t\t\t\t// clean it here (in case the doGet method was not called\n\t\t\t\tif (RequestCycle.get() != null)\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tRequestCycle.get().detach();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tlog.error(\"error detaching request cycle \" + RequestCycle.get() + \": \" +\n\t\t\t\t\t\t\t\te.getMessage(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// always unset the application thread local\n\t\t\t\tApplication.unset();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchain.doFilter(request, response);\n\t\t}\n\t}","commit_id":"45400bde2433c7fc72801bdcd91d93f9394ae530","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the last modified time stamp for the given request.\n\t * \n\t * @param servletRequest\n\t * @param servletResponse\n\t * @return The last modified time stamp\n\t */\n\tlong getLastModified(final HttpServletRequest servletRequest,\n\t\t\tfinal HttpServletResponse servletResponse)\n\t{\n\t\tfinal String pathInfo = getRelativePath(servletRequest);\n\n\t\tif (pathInfo.startsWith(WebRequestCodingStrategy.RESOURCES_PATH_PREFIX))\n\t\t{\n\n\t\t\tfinal String resourceReferenceKey = pathInfo\n\t\t\t\t\t.substring(WebRequestCodingStrategy.RESOURCES_PATH_PREFIX.length());\n\n\t\t\tResource resource = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// Try to find shared resource\n\t\t\t\tresource = webApplication.getSharedResources().get(resourceReferenceKey);\n\n\t\t\t\t// If resource found and it is cacheable\n\t\t\t\tif ((resource != null) && resource.isCacheable())\n\t\t\t\t{\n\t\t\t\t\tfinal WebRequest request = webApplication.newWebRequest(servletRequest);\n\t\t\t\t\t// by pass the webApplication.newWebResponse, this makes a buffered response\n\t\t\t\t\t// that\n\t\t\t\t\t// should be done for head requests\n\t\t\t\t\tfinal WebResponse response = new WebResponse(servletResponse);\n\t\t\t\t\tRequestCycle cycle = webApplication.newRequestCycle(request, response);\n\n\n\t\t\t\t\t// Set parameters from servlet request\n\t\t\t\t\tresource.setParameters(request.getParameterMap());\n\n\t\t\t\t\t// Get resource stream\n\t\t\t\t\tIResourceStream stream = resource.getResourceStream();\n\n\t\t\t\t\t// Get last modified time from stream\n\t\t\t\t\tTime time = stream.lastModifiedTime();\n\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tstream.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ignore\n\t\t\t\t\t}\n\n\t\t\t\t\treturn time != null ? time.getMilliseconds() : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (AbortException e)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (resource != null)\n\t\t\t\t{\n\t\t\t\t\tresource.setParameters(null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}","id":44057,"modified_method":"/**\n\t * Gets the last modified time stamp for the given request.\n\t * \n\t * @param servletRequest\n\t * @param servletResponse\n\t * @return The last modified time stamp\n\t */\n\tlong getLastModified(final HttpServletRequest servletRequest)\n\t{\n\t\tfinal String pathInfo = getRelativePath(servletRequest);\n\n\t\tif (pathInfo.startsWith(WebRequestCodingStrategy.RESOURCES_PATH_PREFIX))\n\t\t{\n\n\t\t\tfinal String resourceReferenceKey = pathInfo\n\t\t\t\t\t.substring(WebRequestCodingStrategy.RESOURCES_PATH_PREFIX.length());\n\n\t\t\tResource resource = null;\n\n\t\t\tboolean externalCall = !Application.exists();\n\t\t\ttry\n\t\t\t{\n\t\t\t\t// if called externally (i.e. WicketServlet) we need to set the thread local here\n\t\t\t\t// AND clean it up at the end of the request\n\t\t\t\tif (externalCall)\n\t\t\t\t{\n\t\t\t\t\tApplication.set(webApplication);\n\t\t\t\t}\n\n\t\t\t\t// Try to find shared resource\n\t\t\t\tresource = webApplication.getSharedResources().get(resourceReferenceKey);\n\n\t\t\t\t// If resource found and it is cacheable\n\t\t\t\tif ((resource != null) && resource.isCacheable())\n\t\t\t\t{\n\n\t\t\t\t\tfinal WebRequest request = webApplication.newWebRequest(servletRequest);\n\t\t\t\t\t// by pass the webApplication.newWebResponse, this makes a buffered response\n\t\t\t\t\t// that shouldn't be done for head requests.\n\t\t\t\t\tfinal WebResponse response = new WebResponse();\n\t\t\t\t\tRequestCycle cycle = webApplication.newRequestCycle(request, response);\n\n\n\t\t\t\t\t// Set parameters from servlet request\n\t\t\t\t\tresource.setParameters(request.getParameterMap());\n\n\t\t\t\t\t// Get resource stream\n\t\t\t\t\tIResourceStream stream = resource.getResourceStream();\n\n\t\t\t\t\t// Get last modified time from stream\n\t\t\t\t\tTime time = stream.lastModifiedTime();\n\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tstream.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\t// ignore\n\t\t\t\t\t}\n\n\t\t\t\t\treturn time != null ? time.getMilliseconds() : -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (AbortException e)\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tif (resource != null)\n\t\t\t\t{\n\t\t\t\t\tresource.setParameters(null);\n\t\t\t\t}\n\t\t\t\tif (externalCall)\n\t\t\t\t{\n\t\t\t\t\t// Clean up thread local application if this was an external call\n\t\t\t\t\t// (if not, doFilter will clean it up)\n\t\t\t\t\tApplication.unset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}","commit_id":"45400bde2433c7fc72801bdcd91d93f9394ae530","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see javax.servlet.http.HttpServlet#getLastModified(javax.servlet.http.HttpServletRequest)\n\t */\n\tprotected long getLastModified(final HttpServletRequest servletRequest)\n\t{\n\t\t// Right now I don't see any other way. wicketFilter.getLastModified takes now also\n\t\t// servletResponse, which we don't have at this point\n\t\treturn -1;\n\t\t// return wicketFilter.getLastModified(servletRequest);\n\t}","id":44058,"modified_method":"/**\n\t * @see javax.servlet.http.HttpServlet#getLastModified(javax.servlet.http.HttpServletRequest)\n\t */\n\tprotected long getLastModified(final HttpServletRequest servletRequest)\n\t{\n\t\treturn wicketFilter.getLastModified(servletRequest);\n\t}","commit_id":"45400bde2433c7fc72801bdcd91d93f9394ae530","url":"https://github.com/apache/wicket"},{"original_method":"/**\n     * @see org.apache.sling.core.component.ComponentResponse#getContentType()\n     */\n    public String getContentType() {\n        return this.contentType + \";charset=\" + this.characterEncoding;\n    }","id":44059,"modified_method":"/**\n     * @see org.apache.sling.core.component.ComponentResponse#getContentType()\n     */\n    public String getContentType() {\n        // plaing content type if there is no character encoding\n        if (characterEncoding == null) {\n            return contentType;\n        }\n        \n        // otherwise append the charset\n        return contentType + \";charset=\" + characterEncoding;\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#getOutputStream()\n     */\n    public ServletOutputStream getOutputStream() throws IOException {\n        return this.getRequestData().getBufferProvider().getOutputStream();\n    }","id":44060,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#getOutputStream()\n     */\n    public ServletOutputStream getOutputStream() throws IOException {\n        return getRequestData().getBufferProvider().getOutputStream();\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#getLocale()\n     */\n    public Locale getLocale() {\n        // TODO Should use our Locale Resolver and not let the component set the locale, right ??\n        return this.getResponse().getLocale();\n    }","id":44061,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#getLocale()\n     */\n    public Locale getLocale() {\n        // TODO Should use our Locale Resolver and not let the component set the locale, right ??\n        return getResponse().getLocale();\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#setContentType(java.lang.String)\n     */\n    public void setContentType(String type) {\n        // ignore empty values\n        if (type == null || type.length() == 0) {\n            return;\n        }\n\n        if (type.indexOf(';') > 0) {\n            Map parsedType = RequestUtil.parserHeader(type);\n            if (parsedType.size() == 1) {\n                // expected single entry of token being content type and\n                // a single parameter charset, otherwise just ignore and\n                // use type as is...\n                Map.Entry entry = (Map.Entry) parsedType.entrySet().iterator().next();\n                type = (String) entry.getKey();\n                String charset = (String) ((Map) entry.getValue()).get(\"charset\");\n                this.setCharacterEncoding(charset);\n            }\n        }\n\n        this.contentType = type;\n\n        // set the content type with charset on the underlying response\n        super.setContentType(this.getContentType());\n    }","id":44062,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#setContentType(java.lang.String)\n     */\n    public void setContentType(String type) {\n        // ignore empty values\n        if (type == null || type.length() == 0) {\n            return;\n        }\n\n        if (type.indexOf(';') > 0) {\n            Map parsedType = RequestUtil.parserHeader(type);\n            if (parsedType.size() == 1) {\n                // expected single entry of token being content type and\n                // a single parameter charset, otherwise just ignore and\n                // use type as is...\n                Map.Entry entry = (Map.Entry) parsedType.entrySet().iterator().next();\n                type = (String) entry.getKey();\n                String charset = (String) ((Map) entry.getValue()).get(\"charset\");\n                if (charset != null && charset.length() > 0) {\n                    setCharacterEncoding(charset);\n                }\n            }\n        }\n\n        contentType = type;\n\n        // set the content type with charset on the underlying response\n        super.setContentType(getContentType());\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"protected ComponentResponseImpl(ComponentResponseImpl response) {\n        super(response);\n        this.requestData = response.getRequestData();\n    }","id":44063,"modified_method":"protected ComponentResponseImpl(ComponentResponseImpl response) {\n        super(response);\n        requestData = response.getRequestData();\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"protected final RequestData getRequestData() {\n        return this.requestData;\n    }","id":44064,"modified_method":"protected final RequestData getRequestData() {\n        return requestData;\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"public void setCharacterEncoding(String charset) {\n        if (charset != null && charset.length() > 0) {\n            // should actually check for charset validity ??\n            this.characterEncoding = charset;\n        }\n    }","id":44065,"modified_method":"public void setCharacterEncoding(String charset) {\n        // should actually check for charset validity ??\n        characterEncoding = charset;\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#getWriter()\n     */\n    public PrintWriter getWriter() throws IOException {\n        return this.getRequestData().getBufferProvider().getWriter();\n    }","id":44066,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#getWriter()\n     */\n    public PrintWriter getWriter() throws IOException {\n        return getRequestData().getBufferProvider().getWriter();\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#getBufferSize()\n     */\n    public int getBufferSize() {\n        return this.getRequestData().getContentData().getBufferSize();\n    }","id":44067,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#getBufferSize()\n     */\n    public int getBufferSize() {\n        return getRequestData().getContentData().getBufferSize();\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#getCharacterEncoding()\n     */\n    public String getCharacterEncoding() {\n        return this.characterEncoding;\n    }","id":44068,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#getCharacterEncoding()\n     */\n    public String getCharacterEncoding() {\n        return characterEncoding;\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#resetBuffer()\n     */\n    public void resetBuffer() {\n        this.getRequestData().getContentData().resetBuffer();\n    }","id":44069,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#resetBuffer()\n     */\n    public void resetBuffer() {\n        getRequestData().getContentData().resetBuffer();\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#isCommitted()\n     */\n    public boolean isCommitted() {\n        // TODO: integrate with our output catcher\n        return this.getResponse().isCommitted();\n    }","id":44070,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#isCommitted()\n     */\n    public boolean isCommitted() {\n        // TODO: integrate with our output catcher\n        return getResponse().isCommitted();\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#setBufferSize(int)\n     */\n    public void setBufferSize(int size) {\n        this.getRequestData().getContentData().setBufferSize(size);\n    }","id":44071,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#setBufferSize(int)\n     */\n    public void setBufferSize(int size) {\n        getRequestData().getContentData().setBufferSize(size);\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#reset()\n     */\n    public void reset() {\n        // TODO: integrate with our output catcher\n        this.getResponse().reset();\n    }","id":44072,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#reset()\n     */\n    public void reset() {\n        // TODO: integrate with our output catcher\n        getResponse().reset();\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#flushBuffer()\n     */\n    public void flushBuffer() throws IOException {\n        this.getRequestData().getContentData().flushBuffer();\n    }","id":44073,"modified_method":"/**\n     * @see javax.servlet.ServletResponseWrapper#flushBuffer()\n     */\n    public void flushBuffer() throws IOException {\n        getRequestData().getContentData().flushBuffer();\n    }","commit_id":"d390f151de8c38766e497c0e1a220badc54b13e8","url":"https://github.com/apache/sling"},{"original_method":"public void doFilter(\n\t\t\tServletRequest req, ServletResponse res, FilterChain chain)\n\t\tthrows IOException, ServletException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (isFilterEnabled()) {\n\t\t\t\t_log.debug(VirtualHostFilter.class + \" is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(VirtualHostFilter.class + \" is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tHttpServletRequest httpReq = (HttpServletRequest)req;\n\t\tHttpServletResponse httpRes = (HttpServletResponse)res;\n\n\t\tif (httpReq.getAttribute(SKIP_SET_CHARACTER_ENCODING) == null) {\n\t\t\thttpReq.setCharacterEncoding(StringPool.UTF8);\n\t\t\t//httpRes.setContentType(ContentTypes.TEXT_HTML_UTF8);\n\n\t\t\thttpReq.setAttribute(SKIP_SET_CHARACTER_ENCODING, Boolean.TRUE);\n\t\t}\n\n\t\t// Make sure all redirects issued by the portal are absolute\n\n\t\thttpRes = new AbsoluteRedirectsResponse(httpReq, httpRes);\n\n\t\t// Company id needs to always be called here so that it's properly set\n\t\t// in subsequent calls\n\n\t\tlong companyId = PortalInstances.getCompanyId(httpReq);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Company id \" + companyId);\n\t\t}\n\n\t\tPortalUtil.getCurrentURL(httpReq);\n\n\t\tHttpSession ses = httpReq.getSession();\n\n\t\tBoolean httpsInitial = (Boolean)ses.getAttribute(WebKeys.HTTPS_INITIAL);\n\n\t\tif (httpsInitial == null) {\n\t\t\thttpsInitial = Boolean.valueOf(httpReq.isSecure());\n\n\t\t\tses.setAttribute(WebKeys.HTTPS_INITIAL, httpsInitial);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Setting httpsInitial to \" + httpsInitial);\n\t\t\t}\n\t\t}\n\n\t\tif (!isFilterEnabled()) {\n\t\t\tprocessFilter(VirtualHostFilter.class, req, httpRes, chain);\n\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuffer requestURL = httpReq.getRequestURL();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Received \" + requestURL);\n\t\t}\n\n\t\tif (!isValidRequestURL(requestURL)) {\n\t\t\tprocessFilter(VirtualHostFilter.class, req, httpRes, chain);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\tString friendlyURL = httpReq.getRequestURI().toLowerCase();\n\n\t\tif ((!contextPath.equals(StringPool.SLASH)) &&\n\t\t\t(friendlyURL.indexOf(contextPath) != -1)) {\n\n\t\t\tfriendlyURL = friendlyURL.substring(\n\t\t\t\tcontextPath.length(), friendlyURL.length());\n\t\t}\n\n\t\tfriendlyURL = StringUtil.replace(\n\t\t\tfriendlyURL, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Friendly URL \" + friendlyURL);\n\t\t}\n\n\t\tif (!isValidFriendlyURL(friendlyURL)) {\n\t\t\tprocessFilter(VirtualHostFilter.class, req, httpRes, chain);\n\n\t\t\treturn;\n\t\t}\n\n\t\tLayoutSet layoutSet = (LayoutSet)req.getAttribute(\n\t\t\tWebKeys.VIRTUAL_HOST_LAYOUT_SET);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Layout set \" + layoutSet);\n\t\t}\n\n\t\tif (layoutSet != null) {\n\t\t\ttry {\n\t\t\t\tLastPath lastPath = new LastPath(\n\t\t\t\t\tStringPool.BLANK, friendlyURL, req.getParameterMap());\n\n\t\t\t\treq.setAttribute(WebKeys.LAST_PATH, lastPath);\n\n\t\t\t\tStringMaker prefix = new StringMaker();\n\n\t\t\t\tif (layoutSet.isPrivateLayout()) {\n\t\t\t\t\tprefix.append(PortalUtil.getPathFriendlyURLPrivateGroup());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprefix.append(PortalUtil.getPathFriendlyURLPublic());\n\t\t\t\t}\n\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\tlayoutSet.getGroupId());\n\n\t\t\t\tprefix.append(group.getFriendlyURL());\n\n\t\t\t\tStringMaker redirect = new StringMaker();\n\n\t\t\t\tredirect.append(prefix);\n\t\t\t\tredirect.append(friendlyURL);\n\n\t\t\t\tString query = httpReq.getQueryString();\n\n\t\t\t\tif (query != null) {\n\t\t\t\t\tredirect.append(StringPool.QUESTION);\n\t\t\t\t\tredirect.append(query);\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Redirect to \" + redirect);\n\t\t\t\t}\n\n\t\t\t\tRequestDispatcher rd =\n\t\t\t\t\t_ctx.getRequestDispatcher(redirect.toString());\n\n\t\t\t\trd.forward(req, httpRes);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tprocessFilter(VirtualHostFilter.class, req, httpRes, chain);\n\t}","id":44074,"modified_method":"public void doFilter(\n\t\t\tServletRequest req, ServletResponse res, FilterChain chain)\n\t\tthrows IOException, ServletException {\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (isFilterEnabled()) {\n\t\t\t\t_log.debug(VirtualHostFilter.class + \" is enabled\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.debug(VirtualHostFilter.class + \" is disabled\");\n\t\t\t}\n\t\t}\n\n\t\tHttpServletRequest httpReq = (HttpServletRequest)req;\n\t\tHttpServletResponse httpRes = (HttpServletResponse)res;\n\n\t\thttpReq.setCharacterEncoding(StringPool.UTF8);\n\t\t//httpRes.setContentType(ContentTypes.TEXT_HTML_UTF8);\n\n\t\t// Make sure all redirects issued by the portal are absolute\n\n\t\thttpRes = new AbsoluteRedirectsResponse(httpReq, httpRes);\n\n\t\t// Company id needs to always be called here so that it's properly set\n\t\t// in subsequent calls\n\n\t\tlong companyId = PortalInstances.getCompanyId(httpReq);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Company id \" + companyId);\n\t\t}\n\n\t\tPortalUtil.getCurrentURL(httpReq);\n\n\t\tHttpSession ses = httpReq.getSession();\n\n\t\tBoolean httpsInitial = (Boolean)ses.getAttribute(WebKeys.HTTPS_INITIAL);\n\n\t\tif (httpsInitial == null) {\n\t\t\thttpsInitial = Boolean.valueOf(httpReq.isSecure());\n\n\t\t\tses.setAttribute(WebKeys.HTTPS_INITIAL, httpsInitial);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Setting httpsInitial to \" + httpsInitial);\n\t\t\t}\n\t\t}\n\n\t\tif (!isFilterEnabled()) {\n\t\t\tprocessFilter(VirtualHostFilter.class, req, httpRes, chain);\n\n\t\t\treturn;\n\t\t}\n\n\t\tStringBuffer requestURL = httpReq.getRequestURL();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Received \" + requestURL);\n\t\t}\n\n\t\tif (!isValidRequestURL(requestURL)) {\n\t\t\tprocessFilter(VirtualHostFilter.class, req, httpRes, chain);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString contextPath = PortalUtil.getPathContext();\n\n\t\tString friendlyURL = httpReq.getRequestURI().toLowerCase();\n\n\t\tif ((!contextPath.equals(StringPool.SLASH)) &&\n\t\t\t(friendlyURL.indexOf(contextPath) != -1)) {\n\n\t\t\tfriendlyURL = friendlyURL.substring(\n\t\t\t\tcontextPath.length(), friendlyURL.length());\n\t\t}\n\n\t\tfriendlyURL = StringUtil.replace(\n\t\t\tfriendlyURL, StringPool.DOUBLE_SLASH, StringPool.SLASH);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Friendly URL \" + friendlyURL);\n\t\t}\n\n\t\tif (!isValidFriendlyURL(friendlyURL)) {\n\t\t\tprocessFilter(VirtualHostFilter.class, req, httpRes, chain);\n\n\t\t\treturn;\n\t\t}\n\n\t\tLayoutSet layoutSet = (LayoutSet)req.getAttribute(\n\t\t\tWebKeys.VIRTUAL_HOST_LAYOUT_SET);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Layout set \" + layoutSet);\n\t\t}\n\n\t\tif (layoutSet != null) {\n\t\t\ttry {\n\t\t\t\tLastPath lastPath = new LastPath(\n\t\t\t\t\tStringPool.BLANK, friendlyURL, req.getParameterMap());\n\n\t\t\t\treq.setAttribute(WebKeys.LAST_PATH, lastPath);\n\n\t\t\t\tStringMaker prefix = new StringMaker();\n\n\t\t\t\tif (layoutSet.isPrivateLayout()) {\n\t\t\t\t\tprefix.append(PortalUtil.getPathFriendlyURLPrivateGroup());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tprefix.append(PortalUtil.getPathFriendlyURLPublic());\n\t\t\t\t}\n\n\t\t\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\t\t\tlayoutSet.getGroupId());\n\n\t\t\t\tprefix.append(group.getFriendlyURL());\n\n\t\t\t\tStringMaker redirect = new StringMaker();\n\n\t\t\t\tredirect.append(prefix);\n\t\t\t\tredirect.append(friendlyURL);\n\n\t\t\t\tString query = httpReq.getQueryString();\n\n\t\t\t\tif (query != null) {\n\t\t\t\t\tredirect.append(StringPool.QUESTION);\n\t\t\t\t\tredirect.append(query);\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Redirect to \" + redirect);\n\t\t\t\t}\n\n\t\t\t\tRequestDispatcher rd =\n\t\t\t\t\t_ctx.getRequestDispatcher(redirect.toString());\n\n\t\t\t\trd.forward(req, httpRes);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tprocessFilter(VirtualHostFilter.class, req, httpRes, chain);\n\t}","commit_id":"390cc7b0616975d207afc0b7e631d3ab8b5caf68","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Handle what we can here, calling super.doGet() or super.doPost() for the rest.\n     *\n     * Some parts modified from:\n     * <pre>\n      // ========================================================================\n      // $Id: Default.java,v 1.51 2006/10/08 14:13:18 gregwilkins Exp $\n      // Copyright 199-2004 Mort Bay Consulting Pty. Ltd.\n      // ------------------------------------------------------------------------\n      // Licensed under the Apache License, Version 2.0 (the \"License\");\n      // you may not use this file except in compliance with the License.\n      // You may obtain a copy of the License at \n      // http://www.apache.org/licenses/LICENSE-2.0\n      // Unless required by applicable law or agreed to in writing, software\n      // distributed under the License is distributed on an \"AS IS\" BASIS,\n      // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n      // See the License for the specific language governing permissions and\n      // limitations under the License.\n      // ========================================================================\n     * <\/pre>\n     *\n     */\n    private void doGetAndPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"Service \" + req.getMethod() + \" \\\"\" + req.getContextPath() + \"\\\" \\\"\" + req.getServletPath() + \"\\\" \\\"\" + req.getPathInfo() + '\"');\n        // since we are not overriding handle*(), do this here\n        String method = req.getMethod();\n        // this is the part after /i2psnark\n        String path = req.getServletPath();\n\n        // in-war icons etc.\n        if (path != null && path.startsWith(WARBASE)) {\n            if (method.equals(\"GET\") || method.equals(\"HEAD\"))\n                super.doGet(req, resp);\n            else  // no POST either\n                resp.sendError(405);\n        }\n\n        _themePath = \"/themes/snark/\" + _manager.getTheme() + '/';\n        _imgPath = _themePath + \"images/\";\n        resp.setHeader(\"X-Frame-Options\", \"SAMEORIGIN\");\n        resp.setHeader(\"Content-Security-Policy\", \"default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline'\");\n        resp.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n\n        String pOverride = _manager.util().connected() ? null : \"\";\n        String peerString = getQueryString(req, pOverride, null, null);\n\n        // AJAX for mainsection\n        if (\"/.ajax/xhr1.html\".equals(path)) {\n            resp.setCharacterEncoding(\"UTF-8\");\n            resp.setContentType(\"text/html; charset=UTF-8\");\n            PrintWriter out = resp.getWriter();\n            //if (_log.shouldLog(Log.DEBUG))\n            //    _manager.addMessage((_context.clock().now() / 1000) + \" xhr1 p=\" + req.getParameter(\"p\"));\n            writeMessages(out, false, peerString);\n            writeTorrents(out, req);\n            return;\n        }\n\n        boolean isConfigure = \"/configure\".equals(path);\n        // index.jsp doesn't work, it is grabbed by the war handler before here\n        if (!(path == null || path.equals(\"/\") || path.equals(\"/index.jsp\") ||\n              path.equals(\"/index.html\") || path.equals(\"/_post\") || isConfigure)) {\n            if (path.endsWith(\"/\")) {\n                // Listing of a torrent (torrent detail page)\n                // bypass the horrid Resource.getListHTML()\n                String pathInfo = req.getPathInfo();\n                String pathInContext = addPaths(path, pathInfo);\n                req.setCharacterEncoding(\"UTF-8\");\n                resp.setCharacterEncoding(\"UTF-8\");\n                resp.setContentType(\"text/html; charset=UTF-8\");\n                File resource = getResource(pathInContext);\n                if (resource == null) {\n                    resp.sendError(404);\n                } else {\n                    String base = addPaths(req.getRequestURI(), \"/\");\n                    String listing = getListHTML(resource, base, true, method.equals(\"POST\") ? req.getParameterMap() : null);\n                    if (method.equals(\"POST\")) {\n                        // P-R-G\n                        sendRedirect(req, resp, \"\");\n                    } else if (listing != null) {\n                        resp.getWriter().write(listing);\n                    } else { // shouldn't happen\n                        resp.sendError(404);\n                    }\n                }\n            } else {\n                // local completed files in torrent directories\n                if (method.equals(\"GET\") || method.equals(\"HEAD\"))\n                    super.doGet(req, resp);\n                else if (method.equals(\"POST\"))\n                    super.doPost(req, resp);\n                else\n                    resp.sendError(405);\n            }\n            return;\n        }\n\n        // Either the main page or /configure\n\n        req.setCharacterEncoding(\"UTF-8\");\n        resp.setCharacterEncoding(\"UTF-8\");\n        resp.setContentType(\"text/html; charset=UTF-8\");\n        \n        String nonce = req.getParameter(\"nonce\");\n        if (nonce != null) {\n            if (nonce.equals(String.valueOf(_nonce)))\n                processRequest(req);\n            else  // nonce is constant, shouldn't happen\n                _manager.addMessage(\"Please retry form submission (bad nonce)\");\n            // P-R-G (or G-R-G to hide the params from the address bar)\n            sendRedirect(req, resp, peerString);\n            return;\t\n        }\n        \n        PrintWriter out = resp.getWriter();\n        out.write(DOCTYPE + \"<html>\\n\" +\n                  \"<head><link rel=\\\"shortcut icon\\\" href=\\\"\" + _themePath + \"favicon.ico\\\">\\n\" +\n                  \"<title>\");\n        if (_contextName.equals(DEFAULT_NAME))\n            out.write(_(\"I2PSnark\"));\n        else\n            out.write(_contextName);\n        out.write(\" - \");\n        if (isConfigure)\n            out.write(_(\"Configuration\"));\n        else\n            out.write(_(\"Anonymous BitTorrent Client\"));\n        String peerParam = req.getParameter(\"p\");\n        if (\"2\".equals(peerParam))\n            out.write(\" | Debug Mode\");\n        out.write(\"<\/title>\\n\");\n                                         \n        // we want it to go to the base URI so we don't refresh with some funky action= value\n        int delay = 0;\n        if (!isConfigure) {\n            delay = _manager.getRefreshDelaySeconds();\n            if (delay > 0) {\n                //out.write(\"<meta http-equiv=\\\"refresh\\\" content=\\\"\" + delay + \";/i2psnark/\" + peerString + \"\\\">\\n\");\n                out.write(\"<script src=\\\"/js/ajax.js\\\" type=\\\"text/javascript\\\"><\/script>\\n\" +\n                          \"<script type=\\\"text/javascript\\\">\\n\"  +\n                          \"var failMessage = \\\"<div class=\\\\\\\"routerdown\\\\\\\"><b>\" + _(\"Router is down\") + \"<\\\\/b><\\\\/div>\\\";\\n\" +\n                          \"function requestAjax1() { ajax(\\\"\" + _contextPath + \"/.ajax/xhr1.html\" +\n                          peerString.replace(\"&amp;\", \"&\") +  // don't html escape in js\n                          \"\\\", \\\"mainsection\\\", \" + (delay*1000) + \"); }\\n\" +\n                          \"function initAjax() { setTimeout(requestAjax1, \" + (delay*1000) +\");  }\\n\"  +\n                          \"<\/script>\\n\");\n            }\n        }\n        out.write(HEADER_A + _themePath + HEADER_B + \"<\/head>\\n\");\n        if (isConfigure || delay <= 0)\n            out.write(\"<body>\");\n        else\n            out.write(\"<body onload=\\\"initAjax()\\\">\");\n        out.write(\"<center>\");\n        List<Tracker> sortedTrackers = null;\n        if (isConfigure) {\n            out.write(\"<div class=\\\"snarknavbar\\\"><a href=\\\"\" + _contextPath + \"/\\\" title=\\\"\");\n            out.write(_(\"Torrents\"));\n            out.write(\"\\\" class=\\\"snarkRefresh\\\">\");\n            out.write(toThemeImg(\"arrow_refresh\"));\n            out.write(\">&nbsp;&nbsp;\");\n            if (_contextName.equals(DEFAULT_NAME))\n                out.write(_(\"I2PSnark\"));\n            else\n                out.write(_contextName);\n            out.write(\"<\/a>\");\n        } else {\n            out.write(\"<div class=\\\"snarknavbar\\\"><a href=\\\"\" + _contextPath + '/' + peerString + \"\\\" title=\\\"\");\n            out.write(_(\"Refresh page\"));\n            out.write(\"\\\" class=\\\"snarkRefresh\\\">\");\n            out.write(toThemeImg(\"arrow_refresh\"));\n            out.write(\">&nbsp;&nbsp;\");\n            if (_contextName.equals(DEFAULT_NAME))\n                out.write(_(\"I2PSnark\"));\n            else\n                out.write(_contextName);\n            out.write(\"<\/a> <a href=\\\"http://forum.i2p/viewforum.php?f=21\\\" class=\\\"snarkRefresh\\\" target=\\\"_blank\\\">\");\n            out.write(_(\"Forum\"));\n            out.write(\"<\/a>\\n\");\n\n            sortedTrackers = _manager.getSortedTrackers();\n            for (Tracker t : sortedTrackers) {\n                if (t.baseURL == null || !t.baseURL.startsWith(\"http\"))\n                    continue;\n                out.write(\" <a href=\\\"\" + t.baseURL + \"\\\" class=\\\"snarkRefresh\\\" target=\\\"_blank\\\">\" + t.name + \"<\/a>\");\n            }\n        }\n        out.write(\"<\/div>\\n\");\n        String newURL = req.getParameter(\"newURL\");\n        if (newURL != null && newURL.trim().length() > 0 && req.getMethod().equals(\"GET\"))\n            _manager.addMessage(_(\"Click \\\"Add torrent\\\" button to fetch torrent\"));\n        out.write(\"<div class=\\\"page\\\"><div id=\\\"mainsection\\\" class=\\\"mainsection\\\">\");\n\n        writeMessages(out, isConfigure, peerString);\n\n        if (isConfigure) {\n            // end of mainsection div\n            out.write(\"<div class=\\\"logshim\\\"><\/div><\/div>\\n\");\n            writeConfigForm(out, req);\n            writeTrackerForm(out, req);\n        } else {\n            boolean pageOne = writeTorrents(out, req);\n            // end of mainsection div\n            if (pageOne) {\n                out.write(\"<\/div><div id=\\\"lowersection\\\">\\n\");\n                writeAddForm(out, req);\n                writeSeedForm(out, req, sortedTrackers);\n                writeConfigLink(out);\n                // end of lowersection div\n            }\n            out.write(\"<\/div>\\n\");\n        }\n        out.write(FOOTER);\n    }","id":44075,"modified_method":"/**\n     * Handle what we can here, calling super.doGet() or super.doPost() for the rest.\n     *\n     * Some parts modified from:\n     * <pre>\n      // ========================================================================\n      // $Id: Default.java,v 1.51 2006/10/08 14:13:18 gregwilkins Exp $\n      // Copyright 199-2004 Mort Bay Consulting Pty. Ltd.\n      // ------------------------------------------------------------------------\n      // Licensed under the Apache License, Version 2.0 (the \"License\");\n      // you may not use this file except in compliance with the License.\n      // You may obtain a copy of the License at \n      // http://www.apache.org/licenses/LICENSE-2.0\n      // Unless required by applicable law or agreed to in writing, software\n      // distributed under the License is distributed on an \"AS IS\" BASIS,\n      // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n      // See the License for the specific language governing permissions and\n      // limitations under the License.\n      // ========================================================================\n     * <\/pre>\n     *\n     */\n    private void doGetAndPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        //if (_log.shouldLog(Log.DEBUG))\n        //    _log.debug(\"Service \" + req.getMethod() + \" \\\"\" + req.getContextPath() + \"\\\" \\\"\" + req.getServletPath() + \"\\\" \\\"\" + req.getPathInfo() + '\"');\n        // since we are not overriding handle*(), do this here\n        String method = req.getMethod();\n        // this is the part after /i2psnark\n        String path = req.getServletPath();\n\n        // in-war icons etc.\n        if (path != null && path.startsWith(WARBASE)) {\n            if (method.equals(\"GET\") || method.equals(\"HEAD\"))\n                super.doGet(req, resp);\n            else  // no POST either\n                resp.sendError(405);\n            return;\n        }\n\n        _themePath = \"/themes/snark/\" + _manager.getTheme() + '/';\n        _imgPath = _themePath + \"images/\";\n        req.setCharacterEncoding(\"UTF-8\");\n\n        String pOverride = _manager.util().connected() ? null : \"\";\n        String peerString = getQueryString(req, pOverride, null, null);\n\n        // AJAX for mainsection\n        if (\"/.ajax/xhr1.html\".equals(path)) {\n            setHTMLHeaders(resp);\n            PrintWriter out = resp.getWriter();\n            //if (_log.shouldLog(Log.DEBUG))\n            //    _manager.addMessage((_context.clock().now() / 1000) + \" xhr1 p=\" + req.getParameter(\"p\"));\n            writeMessages(out, false, peerString);\n            writeTorrents(out, req);\n            return;\n        }\n\n        boolean isConfigure = \"/configure\".equals(path);\n        // index.jsp doesn't work, it is grabbed by the war handler before here\n        if (!(path == null || path.equals(\"/\") || path.equals(\"/index.jsp\") ||\n              path.equals(\"/index.html\") || path.equals(\"/_post\") || isConfigure)) {\n            if (path.endsWith(\"/\")) {\n                // Listing of a torrent (torrent detail page)\n                // bypass the horrid Resource.getListHTML()\n                String pathInfo = req.getPathInfo();\n                String pathInContext = addPaths(path, pathInfo);\n                File resource = getResource(pathInContext);\n                if (resource == null) {\n                    resp.sendError(404);\n                } else {\n                    String base = addPaths(req.getRequestURI(), \"/\");\n                    String listing = getListHTML(resource, base, true, method.equals(\"POST\") ? req.getParameterMap() : null);\n                    if (method.equals(\"POST\")) {\n                        // P-R-G\n                        sendRedirect(req, resp, \"\");\n                    } else if (listing != null) {\n                        setHTMLHeaders(resp);\n                        resp.getWriter().write(listing);\n                    } else { // shouldn't happen\n                        resp.sendError(404);\n                    }\n                }\n            } else {\n                // local completed files in torrent directories\n                if (method.equals(\"GET\") || method.equals(\"HEAD\"))\n                    super.doGet(req, resp);\n                else if (method.equals(\"POST\"))\n                    super.doPost(req, resp);\n                else\n                    resp.sendError(405);\n            }\n            return;\n        }\n\n        // Either the main page or /configure\n\n        String nonce = req.getParameter(\"nonce\");\n        if (nonce != null) {\n            if (nonce.equals(String.valueOf(_nonce)))\n                processRequest(req);\n            else  // nonce is constant, shouldn't happen\n                _manager.addMessage(\"Please retry form submission (bad nonce)\");\n            // P-R-G (or G-R-G to hide the params from the address bar)\n            sendRedirect(req, resp, peerString);\n            return;\t\n        }\n        \n        setHTMLHeaders(resp);\n        PrintWriter out = resp.getWriter();\n        out.write(DOCTYPE + \"<html>\\n\" +\n                  \"<head><link rel=\\\"shortcut icon\\\" href=\\\"\" + _themePath + \"favicon.ico\\\">\\n\" +\n                  \"<title>\");\n        if (_contextName.equals(DEFAULT_NAME))\n            out.write(_(\"I2PSnark\"));\n        else\n            out.write(_contextName);\n        out.write(\" - \");\n        if (isConfigure)\n            out.write(_(\"Configuration\"));\n        else\n            out.write(_(\"Anonymous BitTorrent Client\"));\n        String peerParam = req.getParameter(\"p\");\n        if (\"2\".equals(peerParam))\n            out.write(\" | Debug Mode\");\n        out.write(\"<\/title>\\n\");\n                                         \n        // we want it to go to the base URI so we don't refresh with some funky action= value\n        int delay = 0;\n        if (!isConfigure) {\n            delay = _manager.getRefreshDelaySeconds();\n            if (delay > 0) {\n                //out.write(\"<meta http-equiv=\\\"refresh\\\" content=\\\"\" + delay + \";/i2psnark/\" + peerString + \"\\\">\\n\");\n                out.write(\"<script src=\\\"/js/ajax.js\\\" type=\\\"text/javascript\\\"><\/script>\\n\" +\n                          \"<script type=\\\"text/javascript\\\">\\n\"  +\n                          \"var failMessage = \\\"<div class=\\\\\\\"routerdown\\\\\\\"><b>\" + _(\"Router is down\") + \"<\\\\/b><\\\\/div>\\\";\\n\" +\n                          \"function requestAjax1() { ajax(\\\"\" + _contextPath + \"/.ajax/xhr1.html\" +\n                          peerString.replace(\"&amp;\", \"&\") +  // don't html escape in js\n                          \"\\\", \\\"mainsection\\\", \" + (delay*1000) + \"); }\\n\" +\n                          \"function initAjax() { setTimeout(requestAjax1, \" + (delay*1000) +\");  }\\n\"  +\n                          \"<\/script>\\n\");\n            }\n        }\n        out.write(HEADER_A + _themePath + HEADER_B + \"<\/head>\\n\");\n        if (isConfigure || delay <= 0)\n            out.write(\"<body>\");\n        else\n            out.write(\"<body onload=\\\"initAjax()\\\">\");\n        out.write(\"<center>\");\n        List<Tracker> sortedTrackers = null;\n        if (isConfigure) {\n            out.write(\"<div class=\\\"snarknavbar\\\"><a href=\\\"\" + _contextPath + \"/\\\" title=\\\"\");\n            out.write(_(\"Torrents\"));\n            out.write(\"\\\" class=\\\"snarkRefresh\\\">\");\n            out.write(toThemeImg(\"arrow_refresh\"));\n            out.write(\">&nbsp;&nbsp;\");\n            if (_contextName.equals(DEFAULT_NAME))\n                out.write(_(\"I2PSnark\"));\n            else\n                out.write(_contextName);\n            out.write(\"<\/a>\");\n        } else {\n            out.write(\"<div class=\\\"snarknavbar\\\"><a href=\\\"\" + _contextPath + '/' + peerString + \"\\\" title=\\\"\");\n            out.write(_(\"Refresh page\"));\n            out.write(\"\\\" class=\\\"snarkRefresh\\\">\");\n            out.write(toThemeImg(\"arrow_refresh\"));\n            out.write(\">&nbsp;&nbsp;\");\n            if (_contextName.equals(DEFAULT_NAME))\n                out.write(_(\"I2PSnark\"));\n            else\n                out.write(_contextName);\n            out.write(\"<\/a> <a href=\\\"http://forum.i2p/viewforum.php?f=21\\\" class=\\\"snarkRefresh\\\" target=\\\"_blank\\\">\");\n            out.write(_(\"Forum\"));\n            out.write(\"<\/a>\\n\");\n\n            sortedTrackers = _manager.getSortedTrackers();\n            for (Tracker t : sortedTrackers) {\n                if (t.baseURL == null || !t.baseURL.startsWith(\"http\"))\n                    continue;\n                out.write(\" <a href=\\\"\" + t.baseURL + \"\\\" class=\\\"snarkRefresh\\\" target=\\\"_blank\\\">\" + t.name + \"<\/a>\");\n            }\n        }\n        out.write(\"<\/div>\\n\");\n        String newURL = req.getParameter(\"newURL\");\n        if (newURL != null && newURL.trim().length() > 0 && req.getMethod().equals(\"GET\"))\n            _manager.addMessage(_(\"Click \\\"Add torrent\\\" button to fetch torrent\"));\n        out.write(\"<div class=\\\"page\\\"><div id=\\\"mainsection\\\" class=\\\"mainsection\\\">\");\n\n        writeMessages(out, isConfigure, peerString);\n\n        if (isConfigure) {\n            // end of mainsection div\n            out.write(\"<div class=\\\"logshim\\\"><\/div><\/div>\\n\");\n            writeConfigForm(out, req);\n            writeTrackerForm(out, req);\n        } else {\n            boolean pageOne = writeTorrents(out, req);\n            // end of mainsection div\n            if (pageOne) {\n                out.write(\"<\/div><div id=\\\"lowersection\\\">\\n\");\n                writeAddForm(out, req);\n                writeSeedForm(out, req, sortedTrackers);\n                writeConfigLink(out);\n                // end of lowersection div\n            }\n            out.write(\"<\/div>\\n\");\n        }\n        out.write(FOOTER);\n    }","commit_id":"3db297de950ae4614c391392d015233c273dcc71","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"private void doRename(final PsiElement elementToRename, final Editor editor, final DataContext dataContext) {\n    if (!isAvailableOnDataContext(dataContext)) {\n      LOG.error(\"Recursive invocation\");\n      RenameHandlerRegistry.getInstance().getRenameHandler(dataContext).invoke(\n        elementToRename.getProject(),\n        editor,\n        elementToRename.getContainingFile(), dataContext\n      );\n      return;\n    }\n\n    VariableInplaceRenamer renamer = createRenamer(elementToRename, editor);\n    boolean startedRename = renamer == null ? false : renamer.performInplaceRename();\n\n    if (!startedRename) {\n      try {\n        ourPreventInlineRenameFlag.set(Boolean.TRUE);\n\n        RenameHandler handler = RenameHandlerRegistry.getInstance().getRenameHandler(dataContext);\n        assert handler != null;\n        handler.invoke(\n          elementToRename.getProject(),\n          editor,\n          elementToRename.getContainingFile(), dataContext\n        );\n      } finally {\n        ourPreventInlineRenameFlag.set(null);\n      }\n    }\n  }","id":44076,"modified_method":"@Nullable\n  public VariableInplaceRenamer doRename(final PsiElement elementToRename, final Editor editor, final DataContext dataContext) {\n\n    VariableInplaceRenamer renamer = createRenamer(elementToRename, editor);\n    boolean startedRename = renamer == null ? false : renamer.performInplaceRename();\n\n    if (!startedRename) {\n      try {\n        ourPreventInlineRenameFlag.set(Boolean.TRUE);\n\n        RenameHandler handler = RenameHandlerRegistry.getInstance().getRenameHandler(dataContext);\n        assert handler != null;\n        handler.invoke(\n          elementToRename.getProject(),\n          editor,\n          elementToRename.getContainingFile(), dataContext\n        );\n      } finally {\n        ourPreventInlineRenameFlag.set(null);\n      }\n    }\n    return renamer;\n  }","commit_id":"0f6593e2d44f24d296c71c24a93e12757882a9fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull final Project project, @NotNull final PsiElement[] elements, final DataContext dataContext) {\n    PsiElement element = elements.length == 1 ? elements[0] : null;\n    if (element == null) element = PsiElementRenameHandler.getElement(dataContext);\n    LOG.assertTrue(element != null);\n    Editor editor = PlatformDataKeys.EDITOR.getData(dataContext);\n    doRename(element, editor, dataContext);\n  }","id":44077,"modified_method":"public void invoke(@NotNull final Project project, @NotNull final PsiElement[] elements, final DataContext dataContext) {\n    PsiElement element = elements.length == 1 ? elements[0] : null;\n    if (element == null) element = PsiElementRenameHandler.getElement(dataContext);\n    LOG.assertTrue(element != null);\n    Editor editor = PlatformDataKeys.EDITOR.getData(dataContext);\n    if (checkAvailable(element, editor, dataContext)) {\n      doRename(element, editor, dataContext);\n    }\n  }","commit_id":"0f6593e2d44f24d296c71c24a93e12757882a9fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file, final DataContext dataContext) {\n    PsiElement element = PsiElementRenameHandler.getElement(dataContext);\n    editor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n    doRename(element, editor, dataContext);\n  }","id":44078,"modified_method":"public void invoke(@NotNull final Project project, final Editor editor, final PsiFile file, final DataContext dataContext) {\n    PsiElement element = PsiElementRenameHandler.getElement(dataContext);\n    editor.getScrollingModel().scrollToCaret(ScrollType.MAKE_VISIBLE);\n    if (checkAvailable(element, editor, dataContext)) {\n      doRename(element, editor, dataContext);\n    }\n  }","commit_id":"0f6593e2d44f24d296c71c24a93e12757882a9fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void performRefactoring(UsageInfo[] usages) {\n    List<Pair<String, RefactoringElementListener>> listenersForPackages = new ArrayList<Pair<String,RefactoringElementListener>>();\n\n    final Set entries = myAllRenames.entrySet();\n    for (Iterator iterator = entries.iterator(); iterator.hasNext();) {\n      Map.Entry<PsiElement, String> entry = (Map.Entry<PsiElement, String>)iterator.next();\n      PsiElement element = entry.getKey();\n      String newName = entry.getValue();\n\n      final RefactoringElementListener elementListener = getTransaction().getElementListener(element);\n      RenameUtil.doRename(element, newName, extractUsagesForElement(element, usages), myProject, elementListener);\n      if (element instanceof PsiPackage) {\n        final PsiPackage psiPackage = (PsiPackage) element;\n        final String newQualifiedName = RenameUtil.getQualifiedNameAfterRename(psiPackage.getQualifiedName(), newName);\n        listenersForPackages.add(Pair.create(newQualifiedName, elementListener));\n      }\n    }\n\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    for (int i = 0; i < listenersForPackages.size(); i++) {\n      Pair<String, RefactoringElementListener> pair = listenersForPackages.get(i);\n      final PsiPackage aPackage = psiManager.findPackage(pair.getFirst());\n      LOG.assertTrue(aPackage != null);\n      pair.getSecond().elementRenamed(aPackage);\n    }\n\n    final UsageInfo[] usagesForNonCodeRenaming;\n    usagesForNonCodeRenaming = usages;\n    myUsagesForNonCodeRenaming = usagesForNonCodeRenaming;\n  }","id":44079,"modified_method":"protected void performRefactoring(UsageInfo[] usages) {\n    List<Pair<String, RefactoringElementListener>> listenersForPackages = new ArrayList<Pair<String,RefactoringElementListener>>();\n\n    final Set entries = myAllRenames.entrySet();\n    for (Iterator iterator = entries.iterator(); iterator.hasNext();) {\n      Map.Entry<PsiElement, String> entry = (Map.Entry<PsiElement, String>)iterator.next();\n      PsiElement element = entry.getKey();\n      String newName = entry.getValue();\n\n      if (newName != null) {\n        final RefactoringElementListener elementListener = getTransaction().getElementListener(element);\n        RenameUtil.doRename(element, newName, extractUsagesForElement(element, usages), myProject, elementListener);\n        if (element instanceof PsiPackage) {\n          final PsiPackage psiPackage = (PsiPackage) element;\n          final String newQualifiedName = RenameUtil.getQualifiedNameAfterRename(psiPackage.getQualifiedName(), newName);\n          listenersForPackages.add(Pair.create(newQualifiedName, elementListener));\n        }\n      }\n    }\n\n    final PsiManager psiManager = PsiManager.getInstance(myProject);\n    for (int i = 0; i < listenersForPackages.size(); i++) {\n      Pair<String, RefactoringElementListener> pair = listenersForPackages.get(i);\n      final PsiPackage aPackage = psiManager.findPackage(pair.getFirst());\n      LOG.assertTrue(aPackage != null);\n      pair.getSecond().elementRenamed(aPackage);\n    }\n\n    final UsageInfo[] usagesForNonCodeRenaming;\n    usagesForNonCodeRenaming = usages;\n    myUsagesForNonCodeRenaming = usagesForNonCodeRenaming;\n  }","commit_id":"453fdc91dabe1d73624cebb2744f8bb37e7be35a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handlePost(URI uri, HTTPRequest request, ToadletContext ctx)\n\t\tthrows ToadletContextClosedException, IOException {\n\t\t\n\t\tMultiValueTable headers = new MultiValueTable();\n\t\t\n\t\tString pass = request.getPartAsString(\"formPassword\", 32);\n\t\tif((pass == null) || !pass.equals(core.formPassword)) {\n\t\t\tMultiValueTable hdrs = new MultiValueTable();\n\t\t\theaders.put(\"Location\", \"/queue/\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", hdrs, null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tString path=request.getPath();\n\n\t\t// remove leading / and plugins/ from path\n\t\tif(path.startsWith(\"/\")) path = path.substring(1);\n\t\tif(path.startsWith(\"plugins/\")) path = path.substring(\"plugins/\".length());\n\t\t\n\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Pproxy received POST on \"+path);\n\n\t\tif(path.length()>0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tString plugin = null;\n\t\t\t\t// split path into plugin class name and 'daa' path for plugin\n\t\t\t\tint to = path.indexOf(\"/\");\n\t\t\t\tif(to == -1)\n\t\t\t\t{\n\t\t\t\t\tplugin = path;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplugin = path.substring(0, to);\n\t\t\t\t}\n\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pm.handleHTTPPost(plugin, request));\n\t\t\t}\n\t\t\tcatch(PluginHTTPException ex)\n\t\t\t{\n\t\t\t\t// TODO: make it into html\n\t\t\t\tif((ex.getCode() < 400) && (ex.getCode() >= 300)) {\n\t\t\t\t\theaders = new MultiValueTable();\n\t\t\t\t\theaders.put(\"Location\", ex.getReply());\n\t\t\t\t\tctx.sendReplyHeaders(ex.getCode(), \"Found\", headers, null, 0);\n\t\t\t\t}else\n\t\t\t\t\twriteReply(ctx, ex.getCode(), ex.getMimeType(), ex.getDesc(), ex.getReply());\n\t\t\t}\n\t\t\tcatch(Throwable t)\n\t\t\t{\n\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\tString msg = \"<html><head><title>Internal Error<\/title><\/head><body><h1>Internal Error: please report<\/h1><pre>\";\n\t\t\t\tStringWriter sw = new StringWriter();\n\t\t\t\tPrintWriter pw = new PrintWriter(sw);\n\t\t\t\tt.printStackTrace(pw);\n\t\t\t\tpw.flush();\n\t\t\t\tmsg = msg + sw.toString() + \"<\/pre><\/body><\/html>\";\n\t\t\t\tthis.writeReply(ctx, 500, \"text/html\", \"Internal Error\", msg);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\n\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", \"You are not permitted access to this page\");\n\t\t\treturn;\n\t\t}\n\t\t\t\n\t\tif (request.isPartSet(\"load\")) {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Loading \"+request.getPartAsString(\"load\", MAX_PLUGIN_NAME_LENGTH));\n\t\t\tpm.startPlugin(request.getPartAsString(\"load\", MAX_PLUGIN_NAME_LENGTH), true);\n\t\t\t//writeReply(ctx, 200, \"text/html\", \"OK\", mkForwardPage(\"Loading plugin\", \"Loading plugin...\", \".\", 5));\n\t\n\t\t\theaders.put(\"Location\", \".\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}if (request.isPartSet(\"cancel\")){\n\t\t\theaders.put(\"Location\", \"/plugins/\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}if (request.getPartAsString(\"unloadconfirm\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\tpm.killPlugin(request.getPartAsString(\"unloadconfirm\", MAX_PLUGIN_NAME_LENGTH));\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Plugins\", ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-success\");\n\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Plugin unloaded\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tinfoboxContent.addChild(\"#\", \"The plugin \" + request.getPartAsString(\"remove\", MAX_PLUGIN_NAME_LENGTH) + \" has been unloaded.\");\n\t\t\tinfoboxContent.addChild(\"br\");\n\t\t\tinfoboxContent.addChild(\"a\", \"href\", \"/plugins/\", \"Return to Plugin page.\");\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t}if (request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Plugins\", ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-query\");\n\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Unload plugin?\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tinfoboxContent.addChild(\"#\", \"Are you sure you wish to unload \" + request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH) + '?');\n\t\t\tHTMLNode unloadForm = \n\t\t\t\tctx.addFormChild(infoboxContent, \"/plugins/\", \"unloadPluginConfirmForm\");\n\t\t\tunloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", \"Cancel\" });\n\t\t\tunloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"unloadconfirm\", request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH) });\n\t\t\tunloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"confirm\", \"Unload\" });\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t}else if (request.getPartAsString(\"reload\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\tString fn = null;\n\t\t\tIterator it = pm.getPlugins().iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tPluginInfoWrapper pi = (PluginInfoWrapper) it.next();\n\t\t\t\tif (pi.getThreadName().equals(request.getPartAsString(\"reload\", MAX_PLUGIN_NAME_LENGTH))) {\n\t\t\t\t\tfn = pi.getFilename();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (fn == null) {\n\t\t\t\tthis.sendErrorPage(ctx, 404, \"Plugin Not Found\", \"The specified plugin could not be located in order to reload it.\");\n\t\t\t\t//writeReply(ctx, 200, \"text/html\", \"OK\", mkForwardPage(ctx,\"Error\", \"Plugin not found...\", \".\", 5));\n\t\t\t} else {\n\t\t\t\tpm.killPlugin(request.getPartAsString(\"reload\", MAX_PLUGIN_NAME_LENGTH));\n\t\t\t\tpm.startPlugin(fn, true);\n\t\t\t\t\n\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t}\n\t\t\treturn;\n\t\t}else {\n\t\t\t// Ignore\n\t\t\theaders.put(\"Location\", \".\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t}\n\n\t\t}\n\n\t}","id":44080,"modified_method":"public void handlePost(URI uri, HTTPRequest request, ToadletContext ctx)\n\t\tthrows ToadletContextClosedException, IOException {\n\t\t\n\t\tMultiValueTable headers = new MultiValueTable();\n\t\t\n\t\tString pass = request.getPartAsString(\"formPassword\", 32);\n\t\tif((pass == null) || !pass.equals(core.formPassword)) {\n\t\t\tMultiValueTable hdrs = new MultiValueTable();\n\t\t\theaders.put(\"Location\", \"/queue/\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", hdrs, null, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tString path=request.getPath();\n\n\t\t// remove leading / and plugins/ from path\n\t\tif(path.startsWith(\"/\")) path = path.substring(1);\n\t\tif(path.startsWith(\"plugins/\")) path = path.substring(\"plugins/\".length());\n\t\t\n\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Pproxy received POST on \"+path);\n\n\t\tif(path.length()>0)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tString plugin = null;\n\t\t\t\t// split path into plugin class name and 'daa' path for plugin\n\t\t\t\tint to = path.indexOf(\"/\");\n\t\t\t\tif(to == -1)\n\t\t\t\t{\n\t\t\t\t\tplugin = path;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tplugin = path.substring(0, to);\n\t\t\t\t}\n\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pm.handleHTTPPost(plugin, request));\n\t\t\t}\n\t\t\tcatch(PluginHTTPException ex)\n\t\t\t{\n\t\t\t\t// TODO: make it into html\n\t\t\t\tif(ex.getHeaders() != null) {\n\t\t\t\t\tString data = ex.getReply();\n\t\t\t\t\tctx.sendReplyHeaders(ex.getCode(), \"Found\", ex.getHeaders(), ex.getMimeType(), (data == null ? 0 : data.length()));\n\t\t\t\t\tctx.writeData(data.getBytes());\n\t\t\t\t}else\n\t\t\t\t\twriteReply(ctx, ex.getCode(), ex.getMimeType(), ex.getDesc(), ex.getReply());\n\t\t\t}\n\t\t\tcatch(Throwable t)\n\t\t\t{\n\t\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\t\tString msg = \"<html><head><title>Internal Error<\/title><\/head><body><h1>Internal Error: please report<\/h1><pre>\";\n\t\t\t\tStringWriter sw = new StringWriter();\n\t\t\t\tPrintWriter pw = new PrintWriter(sw);\n\t\t\t\tt.printStackTrace(pw);\n\t\t\t\tpw.flush();\n\t\t\t\tmsg = msg + sw.toString() + \"<\/pre><\/body><\/html>\";\n\t\t\t\tthis.writeReply(ctx, 500, \"text/html\", \"Internal Error\", msg);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\n\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", \"You are not permitted access to this page\");\n\t\t\treturn;\n\t\t}\n\t\t\t\n\t\tif (request.isPartSet(\"load\")) {\n\t\t\tif(Logger.shouldLog(Logger.MINOR, this)) Logger.minor(this, \"Loading \"+request.getPartAsString(\"load\", MAX_PLUGIN_NAME_LENGTH));\n\t\t\tpm.startPlugin(request.getPartAsString(\"load\", MAX_PLUGIN_NAME_LENGTH), true);\n\t\t\t//writeReply(ctx, 200, \"text/html\", \"OK\", mkForwardPage(\"Loading plugin\", \"Loading plugin...\", \".\", 5));\n\t\n\t\t\theaders.put(\"Location\", \".\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}if (request.isPartSet(\"cancel\")){\n\t\t\theaders.put(\"Location\", \"/plugins/\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\treturn;\n\t\t}if (request.getPartAsString(\"unloadconfirm\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\tpm.killPlugin(request.getPartAsString(\"unloadconfirm\", MAX_PLUGIN_NAME_LENGTH));\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Plugins\", ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-success\");\n\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Plugin unloaded\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tinfoboxContent.addChild(\"#\", \"The plugin \" + request.getPartAsString(\"remove\", MAX_PLUGIN_NAME_LENGTH) + \" has been unloaded.\");\n\t\t\tinfoboxContent.addChild(\"br\");\n\t\t\tinfoboxContent.addChild(\"a\", \"href\", \"/plugins/\", \"Return to Plugin page.\");\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t}if (request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\tHTMLNode pageNode = ctx.getPageMaker().getPageNode(\"Plugins\", ctx);\n\t\t\tHTMLNode contentNode = ctx.getPageMaker().getContentNode(pageNode);\n\t\t\tHTMLNode infobox = contentNode.addChild(\"div\", \"class\", \"infobox infobox-query\");\n\t\t\tinfobox.addChild(\"div\", \"class\", \"infobox-header\", \"Unload plugin?\");\n\t\t\tHTMLNode infoboxContent = infobox.addChild(\"div\", \"class\", \"infobox-content\");\n\t\t\tinfoboxContent.addChild(\"#\", \"Are you sure you wish to unload \" + request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH) + '?');\n\t\t\tHTMLNode unloadForm = \n\t\t\t\tctx.addFormChild(infoboxContent, \"/plugins/\", \"unloadPluginConfirmForm\");\n\t\t\tunloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"cancel\", \"Cancel\" });\n\t\t\tunloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"unloadconfirm\", request.getPartAsString(\"unload\", MAX_PLUGIN_NAME_LENGTH) });\n\t\t\tunloadForm.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"submit\", \"confirm\", \"Unload\" });\n\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pageNode.generate());\n\t\t\treturn;\n\t\t}else if (request.getPartAsString(\"reload\", MAX_PLUGIN_NAME_LENGTH).length() > 0) {\n\t\t\tString fn = null;\n\t\t\tIterator it = pm.getPlugins().iterator();\n\t\t\twhile (it.hasNext()) {\n\t\t\t\tPluginInfoWrapper pi = (PluginInfoWrapper) it.next();\n\t\t\t\tif (pi.getThreadName().equals(request.getPartAsString(\"reload\", MAX_PLUGIN_NAME_LENGTH))) {\n\t\t\t\t\tfn = pi.getFilename();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (fn == null) {\n\t\t\t\tthis.sendErrorPage(ctx, 404, \"Plugin Not Found\", \"The specified plugin could not be located in order to reload it.\");\n\t\t\t\t//writeReply(ctx, 200, \"text/html\", \"OK\", mkForwardPage(ctx,\"Error\", \"Plugin not found...\", \".\", 5));\n\t\t\t} else {\n\t\t\t\tpm.killPlugin(request.getPartAsString(\"reload\", MAX_PLUGIN_NAME_LENGTH));\n\t\t\t\tpm.startPlugin(fn, true);\n\t\t\t\t\n\t\t\t\theaders.put(\"Location\", \".\");\n\t\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t\t}\n\t\t\treturn;\n\t\t}else {\n\t\t\t// Ignore\n\t\t\theaders.put(\"Location\", \".\");\n\t\t\tctx.sendReplyHeaders(302, \"Found\", headers, null, 0);\n\t\t}\n\n\t\t}\n\n\t}","commit_id":"f588cb2db998db3828a1be34fbd163532b81c551","url":"https://github.com/freenet/fred"},{"original_method":"public void handleGet(URI uri, HTTPRequest request, ToadletContext ctx)\n\t\t\tthrows ToadletContextClosedException, IOException {\n\t\t//String basepath = \"/plugins/\";\n\t\tString path = request.getPath();\n\n\t\t// remove leading / and plugins/ from path\n\t\tif(path.startsWith(\"/\")) path = path.substring(1);\n\t\tif(path.startsWith(\"plugins/\")) path = path.substring(\"plugins/\".length());\n\n    \tif(Logger.shouldLog(Logger.MINOR, this))\n    \t\tLogger.minor(this, \"Pproxy fetching \"+path);\n\t\ttry {\n\t\t\tif (path.equals(\"\")) {\n\t\t\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", \"You are not permitted access to this page\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.showPluginList(ctx, request);\n\t\t\t} else {\n\t\t\t\t// split path into plugin class name and 'data' path for plugin\n\t\t\t\tint to = path.indexOf(\"/\");\n\t\t\t\tString plugin;\n\t\t\t\tif (to == -1) {\n\t\t\t\t\tplugin = path;\n\t\t\t\t} else {\n\t\t\t\t\tplugin = path.substring(0, to);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Plugin may need to know where it was accessed from, so it can e.g. produce relative URLs.\n\t\t\t\t//writeReply(ctx, 200, \"text/html\", \"OK\", mkPage(\"plugin\", pm.handleHTTPGet(plugin, data)));\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pm.handleHTTPGet(plugin, request));\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t//FetchResult result = fetch(key);\n\t\t\t//writeReply(ctx, 200, result.getMimeType(), \"OK\", result.asBucket());\n\t\t\t\n\t\t} catch (PluginHTTPException ex) {\n\t\t\t// TODO: make it into html\n\t\t\tif((ex.getCode() < 400) && (ex.getCode() >= 300)) {\n\t\t\t\tMultiValueTable headers = new MultiValueTable();\n\t\t\t\theaders.put(\"Location\", ex.getReply());\n\t\t\t\tctx.sendReplyHeaders(ex.getCode(), \"Found\", headers, null, 0);\n\t\t\t}else\n\t\t\t\twriteReply(ctx, ex.getCode(), ex.getMimeType(), ex.getDesc(), ex.getReply());\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tString msg = \"<html><head><title>Internal Error<\/title><\/head><body><h1>Internal Error: please report<\/h1><pre>\";\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tPrintWriter pw = new PrintWriter(sw);\n\t\t\tt.printStackTrace(pw);\n\t\t\tpw.flush();\n\t\t\tmsg = msg + sw.toString() + \"<\/pre><\/body><\/html>\";\n\t\t\tthis.writeReply(ctx, 500, \"text/html\", \"Internal Error\", msg);\n\t\t}\n\t}","id":44081,"modified_method":"public void handleGet(URI uri, HTTPRequest request, ToadletContext ctx)\n\t\t\tthrows ToadletContextClosedException, IOException {\n\t\t//String basepath = \"/plugins/\";\n\t\tString path = request.getPath();\n\n\t\t// remove leading / and plugins/ from path\n\t\tif(path.startsWith(\"/\")) path = path.substring(1);\n\t\tif(path.startsWith(\"plugins/\")) path = path.substring(\"plugins/\".length());\n\n    \tif(Logger.shouldLog(Logger.MINOR, this))\n    \t\tLogger.minor(this, \"Pproxy fetching \"+path);\n\t\ttry {\n\t\t\tif (path.equals(\"\")) {\n\t\t\t\tif(!ctx.isAllowedFullAccess()) {\n\t\t\t\t\tsuper.sendErrorPage(ctx, 403, \"Unauthorized\", \"You are not permitted access to this page\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.showPluginList(ctx, request);\n\t\t\t} else {\n\t\t\t\t// split path into plugin class name and 'data' path for plugin\n\t\t\t\tint to = path.indexOf(\"/\");\n\t\t\t\tString plugin;\n\t\t\t\tif (to == -1) {\n\t\t\t\t\tplugin = path;\n\t\t\t\t} else {\n\t\t\t\t\tplugin = path.substring(0, to);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Plugin may need to know where it was accessed from, so it can e.g. produce relative URLs.\n\t\t\t\t//writeReply(ctx, 200, \"text/html\", \"OK\", mkPage(\"plugin\", pm.handleHTTPGet(plugin, data)));\n\t\t\t\twriteReply(ctx, 200, \"text/html\", \"OK\", pm.handleHTTPGet(plugin, request));\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t//FetchResult result = fetch(key);\n\t\t\t//writeReply(ctx, 200, result.getMimeType(), \"OK\", result.asBucket());\n\t\t\t\n\t\t} catch (PluginHTTPException ex) {\n\t\t\t// TODO: make it into html\n\t\t\tif(ex.getHeaders() != null) {\n\t\t\t\tString data = ex.getReply();\n\t\t\t\tctx.sendReplyHeaders(ex.getCode(), \"Found\", ex.getHeaders(), ex.getMimeType(), (data == null ? 0 : data.length()));\n\t\t\t\tctx.writeData(data.getBytes());\n\t\t\t}else\n\t\t\t\twriteReply(ctx, ex.getCode(), ex.getMimeType(), ex.getDesc(), ex.getReply());\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tString msg = \"<html><head><title>Internal Error<\/title><\/head><body><h1>Internal Error: please report<\/h1><pre>\";\n\t\t\tStringWriter sw = new StringWriter();\n\t\t\tPrintWriter pw = new PrintWriter(sw);\n\t\t\tt.printStackTrace(pw);\n\t\t\tpw.flush();\n\t\t\tmsg = msg + sw.toString() + \"<\/pre><\/body><\/html>\";\n\t\t\tthis.writeReply(ctx, 500, \"text/html\", \"Internal Error\", msg);\n\t\t}\n\t}","commit_id":"f588cb2db998db3828a1be34fbd163532b81c551","url":"https://github.com/freenet/fred"},{"original_method":"private static Config buildTuningConfiguration( Configuration configuration )\n    {\n        return new Config( new ConfigurationDefaults( GraphDatabaseSettings.class ).apply( stringMap(\n                    GraphDatabaseSettings.store_dir.name(),\n                    configuration.get( DataGenerator.store_dir ),\n                    GraphDatabaseSettings.all_stores_total_mapped_memory_size.name(),\n                    configuration.get( all_stores_total_mapped_memory_size ),\n                    ConsistencyCheckSettings.consistency_check_execution_order.name(),\n                    configuration.get( execution_order ).name(),\n                    ConsistencyCheckSettings.consistency_check_window_pool_implementation.name(),\n                    configuration.get( window_pool_implementation ).name(),\n                    GraphDatabaseSettings.mapped_memory_page_size.name(),\n                    configuration.get( mapped_memory_page_size ),\n                    GraphDatabaseSettings.log_mapped_memory_stats.name(),\n                    configuration.get( log_mapped_memory_stats ).toString(),\n                    GraphDatabaseSettings.log_mapped_memory_stats_filename.name(),\n                    configuration.get( log_mapped_memory_stats_filename ),\n                    GraphDatabaseSettings.log_mapped_memory_stats_interval.name(),\n                    configuration.get( log_mapped_memory_stats_interval ).toString() ) ) );\n    }","id":44082,"modified_method":"private static Config buildTuningConfiguration( Configuration configuration )\n    {\n        Map<String, String> passedOnConfiguration = passOn( configuration,\n                param( GraphDatabaseSettings.store_dir, DataGenerator.store_dir ),\n                param( GraphDatabaseSettings.all_stores_total_mapped_memory_size, all_stores_total_mapped_memory_size ),\n                param( ConsistencyCheckSettings.consistency_check_execution_order, execution_order ),\n                param( ConsistencyCheckSettings.consistency_check_window_pool_implementation,\n                        window_pool_implementation ),\n                param( GraphDatabaseSettings.mapped_memory_page_size, mapped_memory_page_size ),\n                param( GraphDatabaseSettings.log_mapped_memory_stats, log_mapped_memory_stats ),\n                param( GraphDatabaseSettings.log_mapped_memory_stats_filename, log_mapped_memory_stats_filename ),\n                param( GraphDatabaseSettings.log_mapped_memory_stats_interval, log_mapped_memory_stats_interval ) );\n\n        addLegacyMemoryMappingConfiguration( passedOnConfiguration,\n                configuration.get( all_stores_total_mapped_memory_size ) );\n\n        return new Config( new ConfigurationDefaults( GraphDatabaseSettings.class ).apply( passedOnConfiguration ) );\n    }","commit_id":"a35e07e4d068ffcac63a1eedd437e285ca9b0161","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static void run( Configuration configuration ) throws Exception\n    {\n        if ( configuration.get( generate_graph ) )\n        {\n            DataGenerator.run( configuration );\n        }\n        // ensure that the store is recovered\n        new EmbeddedGraphDatabase( configuration.get( DataGenerator.store_dir ) ).shutdown();\n\n        // run the consistency check\n        ProgressMonitorFactory progress;\n        if ( configuration.get( DataGenerator.report_progress ) )\n        {\n            progress = ProgressMonitorFactory.textual( System.out );\n        }\n        else\n        {\n            progress = ProgressMonitorFactory.NONE;\n        }\n        if ( configuration.get( wait_before_check ) )\n        {\n            System.out.println( \"Press return to start the checker...\" );\n            System.in.read();\n        }\n\n        Config tuningConfiguration = buildTuningConfiguration( configuration );\n        StoreAccess storeAccess = createStoreAccess( configuration.get( DataGenerator.store_dir ), tuningConfiguration );\n\n        configuration.get( checker_version ).run(\n                new TimingProgress( new TimeLogger( new JsonReportWriter( configuration ) ), progress ),\n                storeAccess, tuningConfiguration );\n    }","id":44083,"modified_method":"private static void run( Configuration configuration ) throws Exception\n    {\n        if ( configuration.get( generate_graph ) )\n        {\n            DataGenerator.run( configuration );\n        }\n        // ensure that the store is recovered\n        new EmbeddedGraphDatabase( configuration.get( DataGenerator.store_dir ) ).shutdown();\n\n        // run the consistency check\n        ProgressMonitorFactory progress;\n        if ( configuration.get( DataGenerator.report_progress ) )\n        {\n            progress = ProgressMonitorFactory.textual( System.out );\n        }\n        else\n        {\n            progress = ProgressMonitorFactory.NONE;\n        }\n        if ( configuration.get( wait_before_check ) )\n        {\n            System.out.println( \"Press return to start the checker...\" );\n            System.in.read();\n        }\n\n        Config tuningConfiguration = buildTuningConfiguration( configuration );\n        StoreAccess storeAccess = createStoreAccess( configuration.get( DataGenerator.store_dir ), tuningConfiguration );\n\n        JsonReportWriter reportWriter = new JsonReportWriter( configuration, tuningConfiguration );\n        TimingProgress progressMonitor = new TimingProgress( new TimeLogger( reportWriter ), progress );\n\n        configuration.get( checker_version ).run( progressMonitor, storeAccess, tuningConfiguration );\n    }","commit_id":"a35e07e4d068ffcac63a1eedd437e285ca9b0161","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void testAddMBCategorySite() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Site Name\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Site Name\", RuntimeVariables.replace(\"Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Add Category']\",\n\t\t\tRuntimeVariables.replace(\"Add Category\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_name']\",\n\t\t\tRuntimeVariables.replace(\"MB Category Name\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"MB Category Name\"),\n\t\t\tselenium.getText(\"//td[1]/a/strong\"));\n\t\tassertEquals(RuntimeVariables.replace(\"0\"),\n\t\t\tselenium.getText(\"//td[2]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"0\"),\n\t\t\tselenium.getText(\"//td[3]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"0\"),\n\t\t\tselenium.getText(\"//td[4]/a\"));\n\t}","id":44084,"modified_method":"public void testAddMBCategorySite() throws Exception {\n\t\tselenium.open(\"/web/site-name\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Message Boards Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Add Category']\",\n\t\t\tRuntimeVariables.replace(\"Add Category\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_name']\",\n\t\t\tRuntimeVariables.replace(\"MB Category Name\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"MB Category Name\"),\n\t\t\tselenium.getText(\"//td[1]/a/strong\"));\n\t\tassertEquals(RuntimeVariables.replace(\"0\"),\n\t\t\tselenium.getText(\"//td[2]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"0\"),\n\t\t\tselenium.getText(\"//td[3]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"0\"),\n\t\t\tselenium.getText(\"//td[4]/a\"));\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPageMBSite() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Sites\", RuntimeVariables.replace(\"Sites\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Site Name\"),\n\t\t\tselenium.getText(\"//td[1]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\tselenium.getText(\"//span[@title='Actions']/ul/li/strong/a/span\"));\n\t\tselenium.clickAt(\"//span[@title='Actions']/ul/li/strong/a/span\",\n\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Manage Pages\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Manage Pages\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Add Page\"),\n\t\t\tselenium.getText(\"//div/span/button[1]\"));\n\t\tselenium.clickAt(\"//div/span/button[1]\",\n\t\t\tRuntimeVariables.replace(\"Add Page\"));\n\t\tselenium.type(\"//input[@id='_156_name_en_US']\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Add Page']\",\n\t\t\tRuntimeVariables.replace(\"Add Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tselenium.clickAt(\"//div[3]/ul/li/div/div[1]\",\n\t\t\tRuntimeVariables.replace(\"Public Pages\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//li/ul/li/div/div[3]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Message Boards Test Page\"),\n\t\t\tselenium.getText(\"//li/ul/li/div/div[3]/a\"));\n\t}","id":44085,"modified_method":"public void testAddPageMBSite() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Sites\", RuntimeVariables.replace(\"Sites\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Site Name\"),\n\t\t\tselenium.getText(\"//tr[4]/td[1]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"xpath=(//span[@title='Actions']/ul/li/strong/a/span)[2]\"));\n\t\tselenium.clickAt(\"xpath=(//span[@title='Actions']/ul/li/strong/a/span)[2]\",\n\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Manage Pages\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Manage Pages\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Add Page\"),\n\t\t\tselenium.getText(\"//div/span/button[1]\"));\n\t\tselenium.clickAt(\"//div/span/button[1]\",\n\t\t\tRuntimeVariables.replace(\"Add Page\"));\n\t\tselenium.type(\"//input[@id='_156_name_en_US']\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Add Page']\",\n\t\t\tRuntimeVariables.replace(\"Add Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tselenium.clickAt(\"//div[3]/ul/li/div/div[1]\",\n\t\t\tRuntimeVariables.replace(\"Public Pages\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//li/ul/li/div/div[3]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Message Boards Test Page\"),\n\t\t\tselenium.getText(\"//li/ul/li/div/div[3]/a\"));\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddPortletMBSite() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Site Name\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Site Name\", RuntimeVariables.replace(\"Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\"//a[@id='_145_addApplication']\",\n\t\t\t\t\"More\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Message Boards']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Message Boards']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","id":44086,"modified_method":"public void testAddPortletMBSite() throws Exception {\n\t\tselenium.open(\"/web/site-name\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Message Boards Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isPartialText(\"//a[@id='_145_addApplication']\",\n\t\t\t\t\"More\"));\n\t\tselenium.clickAt(\"//a[@id='_145_addApplication']\",\n\t\t\tRuntimeVariables.replace(\"More\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\"//div[@title='Message Boards']/p/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//div[@title='Message Boards']/p/a\",\n\t\t\tRuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//section\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertTrue(selenium.isVisible(\"//section\"));\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAddSite() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Sites\", RuntimeVariables.replace(\"Sites\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Add\", RuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[1]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Site\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[1]/a\"));\n\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[1]/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_134_name']\",\n\t\t\tRuntimeVariables.replace(\"Site Name\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Site Name\"),\n\t\t\tselenium.getText(\"//td[1]/a\"));\n\t}","id":44087,"modified_method":"public void testAddSite() throws Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Sites\", RuntimeVariables.replace(\"Sites\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Add\", RuntimeVariables.replace(\"Add\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Site\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\",\n\t\t\tRuntimeVariables.replace(\"Site\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_134_name']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_134_name']\",\n\t\t\tRuntimeVariables.replace(\"Site Name\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Site Name\"),\n\t\t\tselenium.getText(\"//tr[4]/td[1]/a\"));\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testAssignMembersSiteUser() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Sites\",\n\t\t\t\t\tRuntimeVariables.replace(\"Site Memberships\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[7]/span/ul/li/strong/a/span\"));\n\t\t\t\tselenium.clickAt(\"//td[7]/span/ul/li/strong/a/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[3]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Manage Memberships\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[3]/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Manage Memberships\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Add Members\",\n\t\t\t\t\tRuntimeVariables.replace(\"Add Members\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"User\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"User\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@name='_174_keywords']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@name='_174_keywords']\",\n\t\t\t\t\tRuntimeVariables.replace(\"usersn\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Search']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"usersn\"),\n\t\t\t\t\tselenium.getText(\"//tr[3]/td[3]\"));\n\n\t\t\t\tboolean UserSelectedChecked = selenium.isChecked(\"_174_rowIds\");\n\n\t\t\t\tif (UserSelectedChecked) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@name='_174_rowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"User Select\"));\n\n\t\t\tcase 2:\n\t\t\t\tselenium.clickAt(\"//input[@value='Update Associations']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Update Associations\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Your request completed successfully.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":44088,"modified_method":"public void testAssignMembersSiteUser() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Sites\", RuntimeVariables.replace(\"Sites\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Site Name\"),\n\t\t\t\t\tselenium.getText(\"//tr[4]/td[1]/a\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"xpath=(//span[@title='Actions']/ul/li/strong/a/span)[2]\"));\n\t\t\t\tselenium.clickAt(\"xpath=(//span[@title='Actions']/ul/li/strong/a/span)[2]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[3]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Manage Memberships\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[3]/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Manage Memberships\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"link=Add Members\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Add Members\",\n\t\t\t\t\tRuntimeVariables.replace(\"Add Members\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"User\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\"));\n\t\t\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"User\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean basicVisible = selenium.isVisible(\"link=\\u00ab Basic\");\n\n\t\t\t\tif (!basicVisible) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=\\u00ab Basic\",\n\t\t\t\t\tRuntimeVariables.replace(\"\\u00ab Basic\"));\n\n\t\t\tcase 2:\n\t\t\t\tselenium.type(\"//input[@id='_174_toggle_id_users_admin_user_searchkeywords']\",\n\t\t\t\t\tRuntimeVariables.replace(\"usersn\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Search']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"userfn userln\"),\n\t\t\t\t\tselenium.getText(\"//tr[3]/td[2]\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"usersn\"),\n\t\t\t\t\tselenium.getText(\"//tr[3]/td[3]\"));\n\t\t\t\tassertFalse(selenium.isChecked(\"//input[@name='_174_rowIds']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@name='_174_rowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"User Selected\"));\n\t\t\t\tassertTrue(selenium.isChecked(\"//input[@name='_174_rowIds']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Your request completed successfully.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\t\t\tselenium.clickAt(\"link=Site Memberships\",\n\t\t\t\t\tRuntimeVariables.replace(\"Summary\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"userfn userln\"),\n\t\t\t\t\tselenium.getText(\"//tr[4]/td[1]\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"usersn\"),\n\t\t\t\t\tselenium.getText(\"//tr[4]/td[2]\"));\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testConfigurePortletEmailFromAddress()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Site Name\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Site Name\", RuntimeVariables.replace(\"Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//strong/a\"));\n\t\tselenium.clickAt(\"//strong/a\", RuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Email From\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Email From\",\n\t\t\tRuntimeVariables.replace(\"Email From\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_86_emailFromAddress']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_86_emailFromAddress']\",\n\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk@gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t}","id":44089,"modified_method":"public void testConfigurePortletEmailFromAddress()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/site-name\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Message Boards Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Options\"),\n\t\t\tselenium.getText(\"//span[@title='Options']/ul/li/strong/a\"));\n\t\tselenium.clickAt(\"//span[@title='Options']/ul/li/strong/a\",\n\t\t\tRuntimeVariables.replace(\"Options\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Configuration\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\"));\n\t\tselenium.clickAt(\"//div[@class='lfr-component lfr-menu-list']/ul/li[2]/a\",\n\t\t\tRuntimeVariables.replace(\"Configuration\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Email From\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Email From\",\n\t\t\tRuntimeVariables.replace(\"Email From\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_86_emailFromAddress']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_86_emailFromAddress']\",\n\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk@gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"You have successfully updated the setup.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tassertEquals(\"liferay.qa.server.trunk@gmail.com\",\n\t\t\tselenium.getValue(\"//input[@id='_86_emailFromAddress']\"));\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testEditMBCategoryMailingListActiveActions()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Site Name\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Site Name\", RuntimeVariables.replace(\"Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Message Boards Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"MB Category Name\"),\n\t\t\tselenium.getText(\"//td[1]/a/strong\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a/span\"));\n\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a/span\",\n\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Edit\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\"));\n\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_19_mailingListActiveCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_19_mailingListActiveCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Active\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_19_mailingListActiveCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_19_emailAddress']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_emailAddress']\",\n\t\t\tRuntimeVariables.replace(\"liferay-mailinglist@googlegroups.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@name='_19_inProtocol']\",\n\t\t\tRuntimeVariables.replace(\"POP\"));\n\t\tassertTrue(selenium.isChecked(\"//input[@name='_19_inProtocol']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_inServerName']\",\n\t\t\tRuntimeVariables.replace(\"pop.gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_inServerPort']\",\n\t\t\tRuntimeVariables.replace(\"995\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\"//input[@id='_19_inUseSSLCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_19_inUseSSLCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Use a Secure Network Connection\"));\n\t\tassertTrue(selenium.isChecked(\"//input[@id='_19_inUseSSLCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_inUserName']\",\n\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk@gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_inPassword']\",\n\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_inReadInterval']\",\n\t\t\tRuntimeVariables.replace(\"1\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outEmailAddress']\",\n\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk@gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\"//input[@id='_19_outCustomCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_19_outCustomCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Use Customer Outgoing Server\"));\n\t\tassertTrue(selenium.isChecked(\"//input[@id='_19_outCustomCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_19_outEmailAddress']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outEmailAddress']\",\n\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk@gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outServerName']\",\n\t\t\tRuntimeVariables.replace(\"smtp.gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outServerPort']\",\n\t\t\tRuntimeVariables.replace(\"465\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\"//input[@id='_19_outUseSSLCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_19_outUseSSLCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Use a Secure Network Connection\"));\n\t\tassertTrue(selenium.isChecked(\"//input[@id='_19_outUseSSLCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outUserName']\",\n\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk@gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outPassword']\",\n\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t}","id":44090,"modified_method":"public void testEditMBCategoryMailingListActiveActions()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/site-name\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Message Boards Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"MB Category Name\"),\n\t\t\tselenium.getText(\"//a/strong\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\tselenium.getText(\"//span[@title='Actions']/ul/li/strong/a/span\"));\n\t\tselenium.clickAt(\"//span[@title='Actions']/ul/li/strong/a/span\",\n\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"Edit\"),\n\t\t\tselenium.getText(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\"));\n\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li/a\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\"//input[@id='_19_mailingListActiveCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_19_mailingListActiveCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Active\"));\n\t\tassertTrue(selenium.isChecked(\n\t\t\t\t\"//input[@id='_19_mailingListActiveCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_19_emailAddress']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_emailAddress']\",\n\t\t\tRuntimeVariables.replace(\"liferay-mailinglist@googlegroups.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@name='_19_inProtocol']\",\n\t\t\tRuntimeVariables.replace(\"POP\"));\n\t\tassertTrue(selenium.isChecked(\"//input[@name='_19_inProtocol']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_inServerName']\",\n\t\t\tRuntimeVariables.replace(\"pop.gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_inServerPort']\",\n\t\t\tRuntimeVariables.replace(\"995\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\"//input[@id='_19_inUseSSLCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_19_inUseSSLCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Use a Secure Network Connection\"));\n\t\tassertTrue(selenium.isChecked(\"//input[@id='_19_inUseSSLCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_inUserName']\",\n\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk@gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_inPassword']\",\n\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_inReadInterval']\",\n\t\t\tRuntimeVariables.replace(\"1\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outEmailAddress']\",\n\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk@gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\"//input[@id='_19_outCustomCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_19_outCustomCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Use Customer Outgoing Server\"));\n\t\tassertTrue(selenium.isChecked(\"//input[@id='_19_outCustomCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"//input[@id='_19_outEmailAddress']\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outEmailAddress']\",\n\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk@gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outServerName']\",\n\t\t\tRuntimeVariables.replace(\"smtp.gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outServerPort']\",\n\t\t\tRuntimeVariables.replace(\"465\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertFalse(selenium.isChecked(\"//input[@id='_19_outUseSSLCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@id='_19_outUseSSLCheckbox']\",\n\t\t\tRuntimeVariables.replace(\"Use a Secure Network Connection\"));\n\t\tassertTrue(selenium.isChecked(\"//input[@id='_19_outUseSSLCheckbox']\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outUserName']\",\n\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk@gmail.com\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.type(\"//input[@id='_19_outPassword']\",\n\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Save']\",\n\t\t\tRuntimeVariables.replace(\"Save\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testGmailServer_TearDownEmail() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.openWindow(\"http://www.gmail.com/\",\n\t\t\t\t\tRuntimeVariables.replace(\"gmail\"));\n\t\t\t\tselenium.waitForPopUp(\"gmail\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.selectWindow(\"gmail\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean signedIn1 = selenium.isPartialText(\"//td/a\", \"Sign out\");\n\n\t\t\t\tif (!signedIn1) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean signInAsADifferentUserPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"link=Sign in as a different user\");\n\n\t\t\t\tif (!signInAsADifferentUserPresent) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Sign in as a different user\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign in as a different user\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@id='Email']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Email']\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"liferay.qa.server.trunk@gmail.com\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Passwd']\",\n\t\t\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean staySignedInChecked = selenium.isChecked(\n\t\t\t\t\t\t\"PersistentCookie\");\n\n\t\t\t\tif (staySignedInChecked) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='PersistentCookie']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Stay signed in\"));\n\n\t\t\tcase 4:\n\t\t\t\tassertTrue(selenium.isChecked(\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='signIn']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign In\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@type='checkbox']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@type='checkbox']\",\n\t\t\t\t\tRuntimeVariables.replace(\"All\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\"));\n\t\t\t\tselenium.clickAt(\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Delete\"));\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean signedIn2 = selenium.isPartialText(\"//td/a\", \"Sign out\");\n\n\t\t\t\tif (!signedIn2) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\n\t\t\tcase 5:\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":44091,"modified_method":"public void testGmailServer_TearDownEmail() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.selectFrame(\"relative=top\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.openWindow(\"http://www.gmail.com/\",\n\t\t\t\t\tRuntimeVariables.replace(\"gmail\"));\n\t\t\t\tselenium.waitForPopUp(\"gmail\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.selectWindow(\"gmail\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(10000);\n\n\t\t\t\tboolean SignedIn1 = selenium.isElementPresent(\"link=Sign out\");\n\n\t\t\t\tif (!SignedIn1) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\t\t\t\tselenium.clickAt(\"//span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign in to Gmail\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean signInAsADifferentUserPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"link=Sign out and sign in as a different user\");\n\n\t\t\t\tif (!signInAsADifferentUserPresent) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Sign out and sign in as a different user\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"Sign out and sign in as a different user\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@id='Email']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Email']\",\n\t\t\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Passwd']\",\n\t\t\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean staySignedInChecked = selenium.isChecked(\n\t\t\t\t\t\t\"PersistentCookie\");\n\n\t\t\t\tif (staySignedInChecked) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='PersistentCookie']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Stay signed in\"));\n\n\t\t\tcase 4:\n\t\t\t\tassertTrue(selenium.isChecked(\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='signIn']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign In\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@type='checkbox']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@type='checkbox']\",\n\t\t\t\t\tRuntimeVariables.replace(\"All\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\"));\n\t\t\t\tselenium.clickAt(\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Delete\"));\n\t\t\t\tThread.sleep(10000);\n\n\t\t\t\tboolean signedIn2 = selenium.isElementPresent(\"link=Sign out\");\n\n\t\t\t\tif (!signedIn2) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\n\t\t\tcase 5:\n\t\t\t\tThread.sleep(10000);\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testGmailServer_TearDownMailingListMessage()\n\t\tthrows Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.openWindow(\"http://www.gmail.com/\",\n\t\t\t\t\tRuntimeVariables.replace(\"gmail\"));\n\t\t\t\tselenium.waitForPopUp(\"gmail\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.selectWindow(\"gmail\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean signedIn1 = selenium.isPartialText(\"//td/a\", \"Sign out\");\n\n\t\t\t\tif (!signedIn1) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\t\t\t\tselenium.clickAt(\"//span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign in to Gmail\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean signInAsADifferentUserPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"link=Sign in as a different user\");\n\n\t\t\t\tif (!signInAsADifferentUserPresent) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Sign in as a different user\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign in as a different user\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@id='Email']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Email']\",\n\t\t\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Passwd']\",\n\t\t\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean staySignedInChecked = selenium.isChecked(\n\t\t\t\t\t\t\"PersistentCookie\");\n\n\t\t\t\tif (staySignedInChecked) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='PersistentCookie']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Stay signed in\"));\n\n\t\t\tcase 4:\n\t\t\t\tassertTrue(selenium.isChecked(\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='signIn']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign In\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tselenium.openWindow(\"http://groups.google.com/\",\n\t\t\t\t\tRuntimeVariables.replace(\"Google Groups\"));\n\t\t\t\tselenium.waitForPopUp(\"Google Groups\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.selectWindow(\"Google Groups\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"liferay-mailinglist\"),\n\t\t\t\t\tselenium.getText(\"//a[1]/font/b\"));\n\t\t\t\tselenium.clickAt(\"//a[1]/font/b\",\n\t\t\t\t\tRuntimeVariables.replace(\"liferay-mailinglist\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MLMessage1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[1]/a\");\n\n\t\t\t\tif (!MLMessage1Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//span[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"[MB Category Name] MB Message Subject\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Remove\",\n\t\t\t\t\tRuntimeVariables.replace(\"Remove\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.check(\"//input[@id='really_delete.yes']\");\n\t\t\t\tselenium.clickAt(\"//input[@name='Action.Confirm']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Confirm\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MLMessage2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[1]/a\");\n\n\t\t\t\tif (!MLMessage2Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//span[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"[MB Category Name] MB Message Subject\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Remove\",\n\t\t\t\t\tRuntimeVariables.replace(\"Remove\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.check(\"//input[@id='really_delete.yes']\");\n\t\t\t\tselenium.clickAt(\"//input[@name='Action.Confirm']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Confirm\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MLMessage3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[1]/a\");\n\n\t\t\t\tif (!MLMessage3Present) {\n\t\t\t\t\tlabel = 7;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//span[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"[MB Category Name] MB Message Subject\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Remove\",\n\t\t\t\t\tRuntimeVariables.replace(\"Remove\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.check(\"//input[@id='really_delete.yes']\");\n\t\t\t\tselenium.clickAt(\"//input[@name='Action.Confirm']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Confirm\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MLMessage4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[1]/a\");\n\n\t\t\t\tif (!MLMessage4Present) {\n\t\t\t\t\tlabel = 8;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//span[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"[MB Category Name] MB Message Subject\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Remove\",\n\t\t\t\t\tRuntimeVariables.replace(\"Remove\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.check(\"//input[@id='really_delete.yes']\");\n\t\t\t\tselenium.clickAt(\"//input[@name='Action.Confirm']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Confirm\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MLMessage5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[1]/a\");\n\n\t\t\t\tif (!MLMessage5Present) {\n\t\t\t\t\tlabel = 9;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//span[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"[MB Category Name] MB Message Subject\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Remove\",\n\t\t\t\t\tRuntimeVariables.replace(\"Remove\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.check(\"//input[@id='really_delete.yes']\");\n\t\t\t\tselenium.clickAt(\"//input[@name='Action.Confirm']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Confirm\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\n\t\t\t\tboolean SignedIn2 = selenium.isPartialText(\"//td/a\", \"Sign out\");\n\n\t\t\t\tif (!SignedIn2) {\n\t\t\t\t\tlabel = 10;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\n\t\t\tcase 10:\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":44092,"modified_method":"public void testGmailServer_TearDownMailingListMessage()\n\t\tthrows Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.selectFrame(\"relative=top\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.openWindow(\"http://www.gmail.com/\",\n\t\t\t\t\tRuntimeVariables.replace(\"gmail\"));\n\t\t\t\tselenium.waitForPopUp(\"gmail\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.selectWindow(\"gmail\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(10000);\n\n\t\t\t\tboolean SignedIn1 = selenium.isElementPresent(\"link=Sign out\");\n\n\t\t\t\tif (!SignedIn1) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\t\t\t\tselenium.clickAt(\"//span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign in to Gmail\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean signInAsADifferentUserPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"link=Sign out and sign in as a different user\");\n\n\t\t\t\tif (!signInAsADifferentUserPresent) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Sign out and sign in as a different user\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"Sign out and sign in as a different user\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@id='Email']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Email']\",\n\t\t\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Passwd']\",\n\t\t\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean staySignedInChecked = selenium.isChecked(\n\t\t\t\t\t\t\"PersistentCookie\");\n\n\t\t\t\tif (staySignedInChecked) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='PersistentCookie']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Stay signed in\"));\n\n\t\t\tcase 4:\n\t\t\t\tassertTrue(selenium.isChecked(\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='signIn']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign In\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(10000);\n\t\t\t\tselenium.openWindow(\"http://groups.google.com/\",\n\t\t\t\t\tRuntimeVariables.replace(\"Google Groups\"));\n\t\t\t\tselenium.waitForPopUp(\"Google Groups\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.selectWindow(\"Google Groups\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(10000);\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"liferay-mailinglist\"),\n\t\t\t\t\tselenium.getText(\"//a[1]/font/b\"));\n\t\t\t\tselenium.clickAt(\"//a[1]/font/b\",\n\t\t\t\t\tRuntimeVariables.replace(\"liferay-mailinglist\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MLMessage1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[1]/a\");\n\n\t\t\t\tif (!MLMessage1Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//span[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"[MB Category Name] MB Message Subject\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Remove\",\n\t\t\t\t\tRuntimeVariables.replace(\"Remove\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.check(\"//input[@id='really_delete.yes']\");\n\t\t\t\tselenium.clickAt(\"//input[@name='Action.Confirm']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Confirm\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MLMessage2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[1]/a\");\n\n\t\t\t\tif (!MLMessage2Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//span[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"[MB Category Name] MB Message Subject\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Remove\",\n\t\t\t\t\tRuntimeVariables.replace(\"Remove\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.check(\"//input[@id='really_delete.yes']\");\n\t\t\t\tselenium.clickAt(\"//input[@name='Action.Confirm']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Confirm\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MLMessage3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[1]/a\");\n\n\t\t\t\tif (!MLMessage3Present) {\n\t\t\t\t\tlabel = 7;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//span[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"[MB Category Name] MB Message Subject\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Remove\",\n\t\t\t\t\tRuntimeVariables.replace(\"Remove\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.check(\"//input[@id='really_delete.yes']\");\n\t\t\t\tselenium.clickAt(\"//input[@name='Action.Confirm']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Confirm\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MLMessage4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[1]/a\");\n\n\t\t\t\tif (!MLMessage4Present) {\n\t\t\t\t\tlabel = 8;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//span[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"[MB Category Name] MB Message Subject\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Remove\",\n\t\t\t\t\tRuntimeVariables.replace(\"Remove\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.check(\"//input[@id='really_delete.yes']\");\n\t\t\t\tselenium.clickAt(\"//input[@name='Action.Confirm']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Confirm\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean MLMessage5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//span[1]/a\");\n\n\t\t\t\tif (!MLMessage5Present) {\n\t\t\t\t\tlabel = 9;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//span[1]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"[MB Category Name] MB Message Subject\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Remove\",\n\t\t\t\t\tRuntimeVariables.replace(\"Remove\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.check(\"//input[@id='really_delete.yes']\");\n\t\t\t\tselenium.clickAt(\"//input[@name='Action.Confirm']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Confirm\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\tcase 9:\n\n\t\t\t\tboolean SignedIn2 = selenium.isPartialText(\"//td/a\", \"Sign out\");\n\n\t\t\t\tif (!SignedIn2) {\n\t\t\t\t\tlabel = 10;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\n\t\t\tcase 10:\n\t\t\t\tThread.sleep(10000);\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testGmail_ReplyMBCategoryThreadMessageEmail()\n\t\tthrows Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.openWindow(\"http://www.gmail.com/\",\n\t\t\t\t\tRuntimeVariables.replace(\"gmail\"));\n\t\t\t\tselenium.waitForPopUp(\"gmail\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.selectWindow(\"gmail\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(60000);\n\n\t\t\t\tboolean SignedIn = selenium.isPartialText(\"//td/a\", \"Sign out\");\n\n\t\t\t\tif (!SignedIn) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\t\t\t\tselenium.clickAt(\"//span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign in to Gmail\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean signInAsADifferentUserPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"link=Sign in as a different user\");\n\n\t\t\t\tif (!signInAsADifferentUserPresent) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Sign in as a different user\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign in as a different user\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@id='Email']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Email']\",\n\t\t\t\t\tRuntimeVariables.replace(\"liferay.qa.testing.trunk\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Passwd']\",\n\t\t\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean staySignedInChecked = selenium.isChecked(\n\t\t\t\t\t\t\"PersistentCookie\");\n\n\t\t\t\tif (staySignedInChecked) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='PersistentCookie']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Stay signed in\"));\n\n\t\t\tcase 4:\n\t\t\t\tassertTrue(selenium.isChecked(\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='signIn']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign In\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"liferay.qa.server.trunk\"),\n\t\t\t\t\tselenium.getText(\"//td[3]/div/span\"));\n\t\t\t\tselenium.clickAt(\"//td[3]/div/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//h1/span[1]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertTrue(selenium.isPartialText(\"//h1/span[1]\",\n\t\t\t\t\t\t\"[MB Category Name]\"));\n\t\t\t\tassertTrue(selenium.isPartialText(\"//h1/span[1]\",\n\t\t\t\t\t\t\"MB Message Subject\"));\n\t\t\t\tassertTrue(selenium.isPartialText(\n\t\t\t\t\t\t\"//div[contains(child::text(),'MB Message Body')]\",\n\t\t\t\t\t\t\"MB Message Body\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div/table/tbody/tr/td[1]/div/span\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div/table/tbody/tr/td[1]/div/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"Reply\"));\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tselenium.selectFrame(\"//iframe[@id='canvas_frame']\");\n\t\t\t\tselenium.selectFrame(\"//iframe[@class='Am Al editable']\");\n\t\t\t\tselenium.type(\"//body\",\n\t\t\t\t\tRuntimeVariables.replace(\"MB Message Email Reply\"));\n\t\t\t\tselenium.selectFrame(\"relative=top\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Send\"),\n\t\t\t\t\tselenium.getText(\"//div[3]/div/div/div/div[1]/b\"));\n\t\t\t\tselenium.clickAt(\"//div[3]/div/div/div/div[1]/b\",\n\t\t\t\t\tRuntimeVariables.replace(\"Send\"));\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean SignedIn2 = selenium.isPartialText(\"//td/a\", \"Sign out\");\n\n\t\t\t\tif (!SignedIn2) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\n\t\t\tcase 5:\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":44093,"modified_method":"public void testGmail_ReplyMBCategoryThreadMessageEmail()\n\t\tthrows Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.selectFrame(\"relative=top\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.openWindow(\"http://www.gmail.com/\",\n\t\t\t\t\tRuntimeVariables.replace(\"gmail\"));\n\t\t\t\tselenium.waitForPopUp(\"gmail\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.selectWindow(\"gmail\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(80000);\n\n\t\t\t\tboolean SignedIn1 = selenium.isElementPresent(\"link=Sign out\");\n\n\t\t\t\tif (!SignedIn1) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\t\t\t\tselenium.clickAt(\"//span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign in to Gmail\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean signInAsADifferentUserPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"link=Sign out and sign in as a different user\");\n\n\t\t\t\tif (!signInAsADifferentUserPresent) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Sign out and sign in as a different user\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"Sign out and sign in as a different user\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@id='Email']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Email']\",\n\t\t\t\t\tRuntimeVariables.replace(\"liferay.qa.testing.trunk\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Passwd']\",\n\t\t\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean staySignedInChecked = selenium.isChecked(\n\t\t\t\t\t\t\"PersistentCookie\");\n\n\t\t\t\tif (staySignedInChecked) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='PersistentCookie']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Stay signed in\"));\n\n\t\t\tcase 4:\n\t\t\t\tassertTrue(selenium.isChecked(\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='signIn']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign In\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"liferay.qa.server.trunk\"),\n\t\t\t\t\tselenium.getText(\"//td[3]/div/span\"));\n\t\t\t\tselenium.clickAt(\"//td[3]/div/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"liferay.qa.server.trunk\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//h1/span[1]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertTrue(selenium.isPartialText(\"//h1/span[1]\",\n\t\t\t\t\t\t\"[MB Category Name]\"));\n\t\t\t\tassertTrue(selenium.isPartialText(\"//h1/span[1]\",\n\t\t\t\t\t\t\"MB Message Subject\"));\n\t\t\t\tassertTrue(selenium.isPartialText(\n\t\t\t\t\t\t\"//div[contains(child::text(),'MB Message Body')]\",\n\t\t\t\t\t\t\"MB Message Body\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[7]/div/table/tbody/tr/td[1]/div/span\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[7]/div/table/tbody/tr/td[1]/div/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"Reply\"));\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tselenium.selectFrame(\"//iframe[@id='canvas_frame']\");\n\t\t\t\tselenium.selectFrame(\"//iframe[@class='Am Al editable']\");\n\t\t\t\tselenium.type(\"//body\",\n\t\t\t\t\tRuntimeVariables.replace(\"MB Message Email Reply\"));\n\t\t\t\tselenium.selectFrame(\"relative=top\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Send\"),\n\t\t\t\t\tselenium.getText(\"//div[3]/div/div/div/div[1]/b\"));\n\t\t\t\tselenium.clickAt(\"//div[3]/div/div/div/div[1]/b\",\n\t\t\t\t\tRuntimeVariables.replace(\"Send\"));\n\t\t\t\tThread.sleep(10000);\n\n\t\t\t\tboolean SignedIn2 = selenium.isElementPresent(\"link=Sign out\");\n\n\t\t\t\tif (!SignedIn2) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\n\t\t\tcase 5:\n\t\t\t\tThread.sleep(10000);\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testGmail_TearDownEmail() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.openWindow(\"http://www.gmail.com/\",\n\t\t\t\t\tRuntimeVariables.replace(\"gmail\"));\n\t\t\t\tselenium.waitForPopUp(\"gmail\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.selectWindow(\"gmail\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean signedIn1 = selenium.isPartialText(\"//td/a\", \"Sign out\");\n\n\t\t\t\tif (!signedIn1) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean signInAsADifferentUserPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"link=Sign in as a different user\");\n\n\t\t\t\tif (!signInAsADifferentUserPresent) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Sign in as a different user\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign in as a different user\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@id='Email']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Email']\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"liferay.qa.testing.trunk@gmail.com\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Passwd']\",\n\t\t\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean staySignedInChecked = selenium.isChecked(\n\t\t\t\t\t\t\"PersistentCookie\");\n\n\t\t\t\tif (staySignedInChecked) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='PersistentCookie']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Stay signed in\"));\n\n\t\t\tcase 4:\n\t\t\t\tassertTrue(selenium.isChecked(\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='signIn']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign In\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@type='checkbox']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@type='checkbox']\",\n\t\t\t\t\tRuntimeVariables.replace(\"All\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\"));\n\t\t\t\tselenium.clickAt(\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Delete\"));\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean signedIn2 = selenium.isPartialText(\"//td/a\", \"Sign out\");\n\n\t\t\t\tif (!signedIn2) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\n\t\t\tcase 5:\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tThread.sleep(5000);\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":44094,"modified_method":"public void testGmail_TearDownEmail() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.selectFrame(\"relative=top\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.openWindow(\"http://www.gmail.com/\",\n\t\t\t\t\tRuntimeVariables.replace(\"gmail\"));\n\t\t\t\tselenium.waitForPopUp(\"gmail\", RuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.selectWindow(\"gmail\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(10000);\n\n\t\t\t\tboolean SignedIn1 = selenium.isElementPresent(\"link=Sign out\");\n\n\t\t\t\tif (!SignedIn1) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\t\t\t\tselenium.clickAt(\"//span/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign in to Gmail\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\n\t\t\t\tboolean signInAsADifferentUserPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"link=Sign out and sign in as a different user\");\n\n\t\t\t\tif (!signInAsADifferentUserPresent) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=Sign out and sign in as a different user\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"Sign out and sign in as a different user\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@id='Email']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Email']\",\n\t\t\t\t\tRuntimeVariables.replace(\"liferay.qa.testing.trunk\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@id='Passwd']\",\n\t\t\t\t\tRuntimeVariables.replace(\"loveispatient\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean staySignedInChecked = selenium.isChecked(\n\t\t\t\t\t\t\"PersistentCookie\");\n\n\t\t\t\tif (staySignedInChecked) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertFalse(selenium.isChecked(\n\t\t\t\t\t\t\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='PersistentCookie']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Stay signed in\"));\n\n\t\t\tcase 4:\n\t\t\t\tassertTrue(selenium.isChecked(\"//input[@id='PersistentCookie']\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@id='signIn']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Sign In\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//input[@type='checkbox']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@type='checkbox']\",\n\t\t\t\t\tRuntimeVariables.replace(\"All\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\"));\n\t\t\t\tselenium.clickAt(\"//div/div/div/div[1]/div[1]/div[1]/div/div/div[2]/div[3]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Delete\"));\n\t\t\t\tThread.sleep(10000);\n\n\t\t\t\tboolean signedIn2 = selenium.isElementPresent(\"link=Sign out\");\n\n\t\t\t\tif (!signedIn2) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Sign out\"),\n\t\t\t\t\tselenium.getText(\"//td/a\"));\n\t\t\t\tselenium.clickAt(\"//td/a\", RuntimeVariables.replace(\"Sign out\"));\n\n\t\t\tcase 5:\n\t\t\t\tThread.sleep(10000);\n\t\t\t\tselenium.close();\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTestSuite(AddSiteTest.class);\n\t\ttestSuite.addTestSuite(AddUserGmailTest.class);\n\t\ttestSuite.addTestSuite(AssignMembersSiteUserTest.class);\n\t\ttestSuite.addTestSuite(AddPageMBSiteTest.class);\n\t\ttestSuite.addTestSuite(AddPortletMBSiteTest.class);\n\t\ttestSuite.addTestSuite(ConfigurePortletEmailFromAddressTest.class);\n\t\ttestSuite.addTestSuite(AddMBCategorySiteTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tEditMBCategoryMailingListActiveActionsTest.class);\n\t\ttestSuite.addTestSuite(Gmail_TearDownEmailTest.class);\n\t\ttestSuite.addTestSuite(GmailServer_TearDownEmailTest.class);\n\t\ttestSuite.addTestSuite(PostNewMBCategoryThreadMessageSiteTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tGmail_ReplyMBCategoryThreadMessageEmailTest.class);\n\t\ttestSuite.addTestSuite(Gmail_ViewMBThreadMessageGmailTest.class);\n\t\ttestSuite.addTestSuite(Gmail_TearDownEmailTest.class);\n\t\ttestSuite.addTestSuite(GmailServer_TearDownEmailTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tGmailServer_TearDownMailingListMessageTest.class);\n\t\ttestSuite.addTestSuite(TearDownMBCategoryTest.class);\n\t\ttestSuite.addTestSuite(TearDownPageSiteTest.class);\n\t\ttestSuite.addTestSuite(TearDownUserTest.class);\n\t\ttestSuite.addTestSuite(TearDownSitesTest.class);\n\n\t\treturn testSuite;\n\t}","id":44095,"modified_method":"public static Test suite() {\n\t\tTestSuite testSuite = new TestSuite();\n\n\t\ttestSuite.addTestSuite(AddSiteTest.class);\n\t\ttestSuite.addTestSuite(AddUserGmailTest.class);\n\t\ttestSuite.addTestSuite(AssignMembersSiteUserTest.class);\n\t\ttestSuite.addTestSuite(AddPageMBSiteTest.class);\n\t\ttestSuite.addTestSuite(AddPortletMBSiteTest.class);\n\t\ttestSuite.addTestSuite(ConfigurePortletEmailFromAddressTest.class);\n\t\ttestSuite.addTestSuite(AddMBCategorySiteTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tEditMBCategoryMailingListActiveActionsTest.class);\n\t\ttestSuite.addTestSuite(Gmail_TearDownEmailTest.class);\n\t\ttestSuite.addTestSuite(GmailServer_TearDownEmailTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tGmailServer_TearDownMailingListMessageTest.class);\n\t\ttestSuite.addTestSuite(PostNewMBCategoryThreadMessageSiteTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tGmail_ReplyMBCategoryThreadMessageEmailTest.class);\n\t\ttestSuite.addTestSuite(ViewMBThreadMessageGmailTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tGmail_ViewMBThreadMessageGmailMailingListTest.class);\n\t\ttestSuite.addTestSuite(Gmail_TearDownEmailTest.class);\n\t\ttestSuite.addTestSuite(GmailServer_TearDownEmailTest.class);\n\t\ttestSuite.addTestSuite(\n\t\t\tGmailServer_TearDownMailingListMessageTest.class);\n\t\ttestSuite.addTestSuite(TearDownMBCategoryTest.class);\n\t\ttestSuite.addTestSuite(TearDownPageSiteTest.class);\n\t\ttestSuite.addTestSuite(TearDownUserTest.class);\n\t\ttestSuite.addTestSuite(TearDownSiteTest.class);\n\n\t\treturn testSuite;\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testPostNewMBCategoryThreadMessageSite()\n\t\tthrows Exception {\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Site Name\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Site Name\", RuntimeVariables.replace(\"Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"MB Category Name\"),\n\t\t\tselenium.getText(\"//a/strong\"));\n\t\tselenium.clickAt(\"//a/strong\",\n\t\t\tRuntimeVariables.replace(\"MB Category Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Post New Thread']\",\n\t\t\tRuntimeVariables.replace(\"Post New Thread\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"New Message\"),\n\t\t\tselenium.getText(\"//h1[@class='header-title']/span\"));\n\t\tselenium.type(\"//input[@id='_19_subject']\",\n\t\t\tRuntimeVariables.replace(\"MB Message Subject\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//td[@id='cke_contents__19_editor']/iframe\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.selectFrame(\"//td[@id='cke_contents__19_editor']/iframe\");\n\t\tselenium.type(\"//body\", RuntimeVariables.replace(\"MB Message Body\"));\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Publish']\",\n\t\t\tRuntimeVariables.replace(\"Publish\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tselenium.open(\"/web/guest/home/\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Site Name\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Site Name\", RuntimeVariables.replace(\"Site Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\"link=Message Boards Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"MB Category Name\"),\n\t\t\tselenium.getText(\"//a/strong\"));\n\t\tselenium.clickAt(\"//a/strong\",\n\t\t\tRuntimeVariables.replace(\"MB Category Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"MB Message Subject\"),\n\t\t\tselenium.getText(\"//td[1]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Joe Bloggs\"),\n\t\t\tselenium.getText(\"//td[3]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"1\"),\n\t\t\tselenium.getText(\"//td[4]/a\"));\n\t\tassertTrue(selenium.isPartialText(\"//td[6]/a\", \"Joe Bloggs\"));\n\t\tselenium.clickAt(\"//td[1]/a\",\n\t\t\tRuntimeVariables.replace(\"MB Message Subject\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"MB Message Subject\"),\n\t\t\tselenium.getText(\"//div[@class='subject']/a/strong\"));\n\t\tassertEquals(RuntimeVariables.replace(\"MB Message Body\"),\n\t\t\tselenium.getText(\"//div[@class='thread-body']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Joe Bloggs\"),\n\t\t\tselenium.getText(\"//span[@class='user-name']\"));\n\t}","id":44096,"modified_method":"public void testPostNewMBCategoryThreadMessageSite()\n\t\tthrows Exception {\n\t\tselenium.selectWindow(\"null\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.open(\"/web/site-name\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Message Boards Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"MB Category Name\"),\n\t\t\tselenium.getText(\"//a/strong\"));\n\t\tselenium.clickAt(\"//a/strong\",\n\t\t\tRuntimeVariables.replace(\"MB Category Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Post New Thread']\",\n\t\t\tRuntimeVariables.replace(\"Post New Thread\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"New Message\"),\n\t\t\tselenium.getText(\"//h1[@class='header-title']/span\"));\n\t\tselenium.type(\"//input[@id='_19_subject']\",\n\t\t\tRuntimeVariables.replace(\"MB Message Subject\"));\n\t\tselenium.saveScreenShotAndSource();\n\t\tThread.sleep(5000);\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\"//td[@id='cke_contents__19_editor']/iframe\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.selectFrame(\"//td[@id='cke_contents__19_editor']/iframe\");\n\t\tselenium.type(\"//body\", RuntimeVariables.replace(\"MB Message Body\"));\n\t\tselenium.selectFrame(\"relative=top\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"//input[@value='Publish']\",\n\t\t\tRuntimeVariables.replace(\"Publish\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\"Your request completed successfully.\"),\n\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\tselenium.open(\"/web/site-name\");\n\n\t\tfor (int second = 0;; second++) {\n\t\t\tif (second >= 60) {\n\t\t\t\tfail(\"timeout\");\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tif (selenium.isElementPresent(\"link=Message Boards Test Page\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tThread.sleep(1000);\n\t\t}\n\n\t\tselenium.saveScreenShotAndSource();\n\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"MB Category Name\"),\n\t\t\tselenium.getText(\"//a/strong\"));\n\t\tselenium.clickAt(\"//a/strong\",\n\t\t\tRuntimeVariables.replace(\"MB Category Name\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"MB Message Subject\"),\n\t\t\tselenium.getText(\"//td[1]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Joe Bloggs\"),\n\t\t\tselenium.getText(\"//td[3]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"1\"),\n\t\t\tselenium.getText(\"//td[4]/a\"));\n\t\tassertEquals(RuntimeVariables.replace(\"1\"),\n\t\t\tselenium.getText(\"//td[5]/a\"));\n\t\tassertTrue(selenium.isPartialText(\"//td[6]/a\", \"Joe Bloggs\"));\n\t\tselenium.clickAt(\"//td[1]/a\",\n\t\t\tRuntimeVariables.replace(\"MB Message Subject\"));\n\t\tselenium.waitForPageToLoad(\"30000\");\n\t\tselenium.saveScreenShotAndSource();\n\t\tassertEquals(RuntimeVariables.replace(\"MB Message Subject\"),\n\t\t\tselenium.getText(\"//div[@class='subject']/a/strong\"));\n\t\tassertEquals(RuntimeVariables.replace(\"MB Message Body\"),\n\t\t\tselenium.getText(\"//div[@class='thread-body']\"));\n\t\tassertEquals(RuntimeVariables.replace(\"Joe Bloggs\"),\n\t\t\tselenium.getText(\"//span[@class='user-name']\"));\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testTearDownMBCategory() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Site Name\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Site Name\",\n\t\t\t\t\tRuntimeVariables.replace(\"Site Name\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean category1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!category1Present) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean category2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!category2Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean category3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!category3Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean category4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!category4Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean category5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!category5Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":44097,"modified_method":"public void testTearDownMBCategory() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.selectWindow(\"null\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.selectFrame(\"relative=top\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.open(\"/web/site-name\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"link=Message Boards Test Page\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Message Boards Test Page\",\n\t\t\t\t\tRuntimeVariables.replace(\"Message Boards Test Page\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean category1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!category1Present) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean category2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!category2Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean category3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!category3Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean category4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!category4Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean category5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//td[5]/span/ul/li/strong/a\");\n\n\t\t\t\tif (!category5Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Actions\"),\n\t\t\t\t\tselenium.getText(\"//td[5]/span/ul/li/strong/a\"));\n\t\t\t\tselenium.clickAt(\"//td[5]/span/ul/li/strong/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Actions\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\n\t\t\t\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//div[@class='lfr-component lfr-menu-list']/ul/li[5]/a\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete this[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testTearDownPageSite() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\t\t\t\tselenium.clickAt(\"//div[@id='dockbar']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Dockbar\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"//li[contains(@class,'manage-page')]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//li[contains(@class,'manage-page')]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Manage Pages\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Public Pages\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//a[@class='layout-tree']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean welcomePresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (welcomePresent) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\tcase 2:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page1Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page2Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page3Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page4Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Welcome\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li[2]/div/div[3]/a\");\n\n\t\t\t\tif (!page5Present) {\n\t\t\t\t\tlabel = 7;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li[2]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":44098,"modified_method":"public void testTearDownPageSite() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/site-name\");\n\t\t\t\tselenium.clickAt(\"//div[@id='dockbar']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Dockbar\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\n\t\t\t\t\t\t\t\t\t\"//li[contains(@class,'manage-page')]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//li[contains(@class,'manage-page')]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Manage Pages\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (RuntimeVariables.replace(\"Public Pages\")\n\t\t\t\t\t\t\t\t\t\t\t\t.equals(selenium.getText(\n\t\t\t\t\t\t\t\t\t\t\"//a[@class='layout-tree']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean welcomePresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (welcomePresent) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\n\t\t\tcase 2:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//li/ul/li[1]/div/div[3]/a\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean page1Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (!page1Present) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li/ul/li[1]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean page2Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (!page2Present) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li/ul/li[1]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean page3Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (!page3Present) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li/ul/li[1]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean page4Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (!page4Present) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li/ul/li[1]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//div[@id='_88_layoutsTreeOutput']/ul/li/div/div[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"Drop Down Arrow\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean page5Present = selenium.isElementPresent(\n\t\t\t\t\t\t\"//li/ul/li[1]/div/div[3]/a\");\n\n\t\t\t\tif (!page5Present) {\n\t\t\t\t\tlabel = 7;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//li/ul/li[1]/div/div[3]/a\",\n\t\t\t\t\tRuntimeVariables.replace(\"Page Name\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (!RuntimeVariables.replace(\"/home\")\n\t\t\t\t\t\t\t\t\t\t\t\t .equals(selenium.getValue(\n\t\t\t\t\t\t\t\t\t\t\"//input[@id='_88_friendlyURL']\"))) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//button[3]\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Delete\"),\n\t\t\t\t\tselenium.getText(\"//button[3]\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\"//button[3]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to delete the selected page[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testTearDownUser() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Users and Organizations\",\n\t\t\t\t\tRuntimeVariables.replace(\"Users and Organizations\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"View All Users\"),\n\t\t\t\t\tselenium.getText(\"//a[@id='_125_allUsersLink']\"));\n\t\t\t\tselenium.clickAt(\"//a[@id='_125_allUsersLink']\",\n\t\t\t\t\tRuntimeVariables.replace(\"View All Users\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean basic1Visible = selenium.isVisible(\"link=\\u00ab Basic\");\n\n\t\t\t\tif (!basic1Visible) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=\\u00ab Basic\",\n\t\t\t\t\tRuntimeVariables.replace(\"\\u00ab Basic\"));\n\n\t\t\tcase 2:\n\t\t\t\tselenium.type(\"//input[@name='_125_keywords']\",\n\t\t\t\t\tRuntimeVariables.replace(\"userfn\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Search']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean user1Deactivated = selenium.isElementPresent(\n\t\t\t\t\t\t\"//input[@name='_125_rowIds']\");\n\n\t\t\t\tif (!user1Deactivated) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@name='_125_rowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Checkbox\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Deactivate']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to deactivate the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 3:\n\n\t\t\t\tboolean user2Deactivated = selenium.isElementPresent(\n\t\t\t\t\t\t\"//input[@name='_125_rowIds']\");\n\n\t\t\t\tif (!user2Deactivated) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@name='_125_rowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Checkbox\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Deactivate']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to deactivate the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 4:\n\n\t\t\t\tboolean user3Deactivated = selenium.isElementPresent(\n\t\t\t\t\t\t\"//input[@name='_125_rowIds']\");\n\n\t\t\t\tif (!user3Deactivated) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@name='_125_rowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Checkbox\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Deactivate']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to deactivate the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 5:\n\n\t\t\t\tboolean user4Deactivated = selenium.isElementPresent(\n\t\t\t\t\t\t\"//input[@name='_125_rowIds']\");\n\n\t\t\t\tif (!user4Deactivated) {\n\t\t\t\t\tlabel = 6;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@name='_125_rowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Checkbox\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Deactivate']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to deactivate the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 6:\n\n\t\t\t\tboolean user5Deactivated = selenium.isElementPresent(\n\t\t\t\t\t\t\"//input[@name='_125_rowIds']\");\n\n\t\t\t\tif (!user5Deactivated) {\n\t\t\t\t\tlabel = 7;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@name='_125_rowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Checkbox\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Deactivate']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to deactivate the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 7:\n\t\t\t\tselenium.clickAt(\"link=Users and Organizations\",\n\t\t\t\t\tRuntimeVariables.replace(\"Users and Organizations\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"View All Users\"),\n\t\t\t\t\tselenium.getText(\"//span/a/span\"));\n\t\t\t\tselenium.clickAt(\"//span/a/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"View All Users\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Advanced \\u00bb\",\n\t\t\t\t\tRuntimeVariables.replace(\"Advanced \\u00bb\"));\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//select[@id='_125_status']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.select(\"//select[@id='_125_status']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Inactive\"));\n\t\t\t\tselenium.clickAt(\"//div[2]/span[2]/span/input\",\n\t\t\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\t\t\tThread.sleep(5000);\n\n\t\t\t\tboolean user1Deleted = selenium.isElementPresent(\n\t\t\t\t\t\t\"xPath=(//input[@name='_125_rowIds'])[1]\");\n\n\t\t\t\tif (!user1Deleted) {\n\t\t\t\t\tlabel = 8;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"xPath=(//input[@name='_125_rowIds'])[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"xPath=(//input[@value='Delete'])[1]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to permanently delete the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean user2Deleted = selenium.isElementPresent(\n\t\t\t\t\t\t\"xPath=(//input[@name='_125_rowIds'])[1]\");\n\n\t\t\t\tif (!user2Deleted) {\n\t\t\t\t\tlabel = 9;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"xPath=(//input[@name='_125_rowIds'])[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"xPath=(//input[@value='Delete'])[1]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to permanently delete the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean user3Deleted = selenium.isElementPresent(\n\t\t\t\t\t\t\"xPath=(//input[@name='_125_rowIds'])[1]\");\n\n\t\t\t\tif (!user3Deleted) {\n\t\t\t\t\tlabel = 10;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"xPath=(//input[@name='_125_rowIds'])[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"xPath=(//input[@value='Delete'])[1]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to permanently delete the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean user4Deleted = selenium.isElementPresent(\n\t\t\t\t\t\t\"xPath=(//input[@name='_125_rowIds'])[1]\");\n\n\t\t\t\tif (!user4Deleted) {\n\t\t\t\t\tlabel = 11;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"xPath=(//input[@name='_125_rowIds'])[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"xPath=(//input[@value='Delete'])[1]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to permanently delete the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean user5Deleted = selenium.isElementPresent(\n\t\t\t\t\t\t\"xPath=(//input[@name='_125_rowIds'])[1]\");\n\n\t\t\t\tif (!user5Deleted) {\n\t\t\t\t\tlabel = 12;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"xPath=(//input[@name='_125_rowIds'])[1]\",\n\t\t\t\t\tRuntimeVariables.replace(\"\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"xPath=(//input[@value='Delete'])[1]\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to permanently delete the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\tcase 8:\n\t\t\tcase 9:\n\t\t\tcase 10:\n\t\t\tcase 11:\n\t\t\tcase 12:\n\t\t\t\tselenium.clickAt(\"link=Users and Organizations\",\n\t\t\t\t\tRuntimeVariables.replace(\"Users and Organizations\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"View All Users\"),\n\t\t\t\t\tselenium.getText(\"//span/a/span\"));\n\t\t\t\tselenium.clickAt(\"//span/a/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"View All Users\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean basicVisible = selenium.isVisible(\"link=\\u00ab Basic\");\n\n\t\t\t\tif (!basicVisible) {\n\t\t\t\t\tlabel = 13;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"link=\\u00ab Basic\",\n\t\t\t\t\tRuntimeVariables.replace(\"\\u00ab Basic\"));\n\n\t\t\tcase 13:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","id":44099,"modified_method":"public void testTearDownUser() throws Exception {\n\t\tint label = 1;\n\n\t\twhile (label >= 1) {\n\t\t\tswitch (label) {\n\t\t\tcase 1:\n\t\t\t\tselenium.open(\"/web/guest/home/\");\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isElementPresent(\"link=Control Panel\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Control Panel\",\n\t\t\t\t\tRuntimeVariables.replace(\"Control Panel\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"link=Users and Organizations\",\n\t\t\t\t\tRuntimeVariables.replace(\"Users and Organizations\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean UsersPresent = selenium.isElementPresent(\n\t\t\t\t\t\t\"//a[@id='_125_allUsersLink']\");\n\n\t\t\t\tif (!UsersPresent) {\n\t\t\t\t\tlabel = 4;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Search All Users\"),\n\t\t\t\t\tselenium.getText(\"//a[@id='_125_allUsersLink']\"));\n\t\t\t\tselenium.clickAt(\"//a[@id='_125_allUsersLink']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Search All Users\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.type(\"//input[@name='_125_keywords']\",\n\t\t\t\t\tRuntimeVariables.replace(\"userfn\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.clickAt(\"//input[@value='Search']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean UsersExists = selenium.isPartialText(\"//div[5]\",\n\t\t\t\t\t\t\"No users were found\");\n\n\t\t\t\tif (UsersExists) {\n\t\t\t\t\tlabel = 5;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@name='_125_allRowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Check All\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Deactivate']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to deactivate the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Your request completed successfully.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"\\u00ab Back to Users and Organizations Home\"),\n\t\t\t\t\tselenium.getText(\"//a[@id='_125_TabsBack']\"));\n\t\t\t\tselenium.clickAt(\"//a[@id='_125_TabsBack']\",\n\t\t\t\t\tRuntimeVariables.replace(\n\t\t\t\t\t\t\"\\u00ab Back to Users and Organizations Home\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Search All Users\"),\n\t\t\t\t\tselenium.getText(\"//span/a/span\"));\n\t\t\t\tselenium.clickAt(\"//span/a/span\",\n\t\t\t\t\tRuntimeVariables.replace(\"Search All Users\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean AdvanceViewVisible = selenium.isElementPresent(\n\t\t\t\t\t\t\"link=Advanced \\u00bb\");\n\n\t\t\t\tif (!AdvanceViewVisible) {\n\t\t\t\t\tlabel = 2;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"Advanced \\u00bb\"),\n\t\t\t\t\tselenium.getText(\"link=Advanced \\u00bb\"));\n\t\t\t\tselenium.clickAt(\"link=Advanced \\u00bb\",\n\t\t\t\t\tRuntimeVariables.replace(\"Advanced \\u00bb\"));\n\n\t\t\tcase 2:\n\n\t\t\t\tfor (int second = 0;; second++) {\n\t\t\t\t\tif (second >= 60) {\n\t\t\t\t\t\tfail(\"timeout\");\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (selenium.isVisible(\"//select[@id='_125_status']\")) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t}\n\n\t\t\t\t\tThread.sleep(1000);\n\t\t\t\t}\n\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tselenium.select(\"//select[@id='_125_status']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Inactive\"));\n\t\t\t\tselenium.clickAt(\"//input[@value='Search']\",\n\t\t\t\t\tRuntimeVariables.replace(\"Search\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tselenium.saveScreenShotAndSource();\n\n\t\t\t\tboolean userDeleted = selenium.isElementPresent(\n\t\t\t\t\t\t\"//input[@name='_125_rowIds']\");\n\n\t\t\t\tif (!userDeleted) {\n\t\t\t\t\tlabel = 3;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tselenium.clickAt(\"//input[@name='_125_allRowIds']\",\n\t\t\t\t\tRuntimeVariables.replace(\"All Row IDs\"));\n\t\t\t\tselenium.click(RuntimeVariables.replace(\n\t\t\t\t\t\t\"//input[@value='Delete']\"));\n\t\t\t\tselenium.waitForPageToLoad(\"30000\");\n\t\t\t\tassertTrue(selenium.getConfirmation()\n\t\t\t\t\t\t\t\t   .matches(\"^Are you sure you want to permanently delete the selected users[\\\\s\\\\S]$\"));\n\t\t\t\tselenium.saveScreenShotAndSource();\n\t\t\t\tassertEquals(RuntimeVariables.replace(\n\t\t\t\t\t\t\"Your request completed successfully.\"),\n\t\t\t\t\tselenium.getText(\"//div[@class='portlet-msg-success']\"));\n\n\t\t\tcase 3:\n\t\t\t\tassertEquals(RuntimeVariables.replace(\"\\u00ab Basic\"),\n\t\t\t\t\tselenium.getText(\"link=\\u00ab Basic\"));\n\t\t\t\tselenium.clickAt(\"link=\\u00ab Basic\",\n\t\t\t\t\tRuntimeVariables.replace(\"\\u00ab Basic\"));\n\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\tcase 100:\n\t\t\t\tlabel = -1;\n\t\t\t}\n\t\t}\n\t}","commit_id":"e28188d4e4f7e437cd5a512958fba16b5bf5f268","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Returns a string from the gzipped file using the default\n     * encoding.\n     * @param f file to read\n     * @return string representation of that file.\n     * @throws IOException if things go wrong\n     */\n    public static String stringFromGZippedFile(File f) throws IOException {\n        return new String(bytesFromGZippedFile(f), charset());\n    }","id":44100,"modified_method":"/**\n     * Returns a string from the gzipped file using the default\n     * encoding.\n     * @param f file to read\n     * @return string representation of that file.\n     * @throws IOException if things go wrong\n     */\n    public static String stringFromGZippedFile(File f) throws IOException {\n        return new String(bytesFromGZippedFile(f), charset().name());\n    }","commit_id":"cb6669bf9e0c86c7beae8dce56738b1f621dba34","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void stringToGZippedFile(String s, File f) throws IOException {\n\t    if (s == null) throw new NullPointerException(\"string argument cannot be null\");\n\t    if (f == null) throw new NullPointerException(\"file argument cannot be null\");\n\t    \n\t    byte[] bytes = s.getBytes(charset());\n\t    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n\t    writeInputStreamToGZippedFile(bais, f);\n    }","id":44101,"modified_method":"public static void stringToGZippedFile(String s, File f) throws IOException {\n\t    if (s == null) throw new NullPointerException(\"string argument cannot be null\");\n\t    if (f == null) throw new NullPointerException(\"file argument cannot be null\");\n\t    \n\t    byte[] bytes = s.getBytes(charset().name());\n\t    ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n\t    writeInputStreamToGZippedFile(bais, f);\n    }","commit_id":"cb6669bf9e0c86c7beae8dce56738b1f621dba34","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns a string from the file using the default\n     * encoding.\n     * @param f file to read\n     * @return string representation of that file.\n     * @throws IOException if things go wrong\n     */\n    public static String stringFromFile(File f) throws IOException {\n        return new String(bytesFromFile(f), charset());\n    }","id":44102,"modified_method":"/**\n     * Returns a string from the file using the default\n     * encoding.\n     * @param f file to read\n     * @return string representation of that file.\n     * @throws IOException if things go wrong\n     */\n    public static String stringFromFile(File f) throws IOException {\n        return new String(bytesFromFile(f), charset().name());\n    }","commit_id":"cb6669bf9e0c86c7beae8dce56738b1f621dba34","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns a string from the file using the specified\n     * encoding.\n     * @param f file to read\n     * @param encoding to be used, <code>null<\/code> will use the default\n     * @return string representation of the file.\n     * @throws IOException if things go wrong\n     */\n    public static String stringFromFile(File f, String encoding) throws IOException {\n        if (encoding == null) {\n            return new String(bytesFromFile(f), charset());\n        }\n        return new String(bytesFromFile(f), encoding);\n    }","id":44103,"modified_method":"/**\n     * Returns a string from the file using the specified\n     * encoding.\n     * @param f file to read\n     * @param encoding to be used, <code>null<\/code> will use the default\n     * @return string representation of the file.\n     * @throws IOException if things go wrong\n     */\n    public static String stringFromFile(File f, String encoding) throws IOException {\n        if (encoding == null) {\n            return new String(bytesFromFile(f), charset().name());\n        }\n        return new String(bytesFromFile(f), encoding);\n    }","commit_id":"cb6669bf9e0c86c7beae8dce56738b1f621dba34","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setCharset(String charset) throws UnsupportedCharsetException {\r\n        // testing if charset exists\r\n        Charset.forName(charset);\r\n        \r\n        // remember it\r\n        this.charset = charset;\r\n    }","id":44104,"modified_method":"public void setCharset(String charset) throws UnsupportedCharsetException {\r\n        if (charset == null) return;\r\n        \r\n        // testing if charset exists\r\n        Charset.forName(charset);\r\n        \r\n        // remember it\r\n        this.charset = charset;\r\n    }","commit_id":"c5d30209413350be0bf106c26dbba135ebd4bd0b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public plasmaParserDocument parseSource(URL location, String mimeType, String charset, File sourceFile) throws InterruptedException {\r\n\r\n        Parser theParser = null;\r\n        try {\r\n            mimeType = getRealMimeType(mimeType);\r\n            String fileExt = getFileExt(location);\r\n            \r\n            if (this.theLogger.isFine())\r\n                this.theLogger.logFine(\"Parsing \" + location + \" with mimeType '\" + mimeType + \r\n                                       \"' and file extension '\" + fileExt + \"'.\");\r\n            \r\n            /*\r\n             * There are some problematic mimeType - fileExtension combination where we have to enforce\r\n             * a mimeType detection to get the proper parser for the content\r\n             * \r\n             * - application/zip + .odt\r\n             * - text/plain + .odt\r\n             * - text/plain + .vcf\r\n             * - text/xml + .rss\r\n             * - text/xml + .atom\r\n             * \r\n             * In all these cases we can trust the fileExtension and have to determine the proper mimeType.\r\n             * \r\n             */\r\n            \r\n//            // Handling of not trustable mimeTypes\r\n//            // - text/plain\r\n//            // - text/xml\r\n//            // - application/octet-stream\r\n//            // - application/zip\r\n//            if (\r\n//                    (mimeType.equalsIgnoreCase(\"text/plain\") && !fileExt.equalsIgnoreCase(\"txt\")) || \r\n//                    (mimeType.equalsIgnoreCase(\"text/xml\")   && !fileExt.equalsIgnoreCase(\"txt\")) \r\n//            ) {\r\n//                if (this.theLogger.isFine())\r\n//                    this.theLogger.logFine(\"Document \" + location + \" has an mimeType '\" + mimeType + \r\n//                                           \"' that seems not to be correct for file extension '\" + fileExt + \"'.\");                \r\n//                \r\n//                if (enabledParserList.containsKey(\"application/octet-stream\")) {\r\n//                    theParser = this.getParser(\"application/octet-stream\");\r\n//                    Object newMime = theParser.getClass().getMethod(\"getMimeType\", new Class[]{File.class}).invoke(theParser, sourceFile);\r\n//                    if (newMime == null)\r\n//                    if (newMime instanceof String) {\r\n//                        String newMimeType = (String)newMime;\r\n//                        if ((newMimeType.equals(\"application/octet-stream\")) {\r\n//                            return null;\r\n//                        }\r\n//                        mimeType = newMimeType;\r\n//                    }\r\n//                } else {\r\n//                    return null;\r\n//                }\r\n//            } else if (mimeType.equalsIgnoreCase(\"application/zip\") && fileExt.equalsIgnoreCase(\"odt\")){\r\n//                if (enabledParserList.containsKey(\"application/vnd.oasis.opendocument.text\")) {\r\n//                    mimeType = \"application/vnd.oasis.opendocument.text\";\r\n//                } else {\r\n//                    return null;\r\n//                }\r\n//            }        \r\n            \r\n            // getting the correct parser for the given mimeType\r\n            theParser = this.getParser(mimeType);\r\n            \r\n            // if a parser was found we use it ...\r\n            if (theParser != null) {\r\n                return theParser.parse(location, mimeType,charset,sourceFile);\r\n            } else if (realtimeParsableMimeTypesContains(mimeType)) {                      \r\n                // ...otherwise we make a scraper and transformer\r\n                htmlFilterContentScraper scraper = new htmlFilterContentScraper(location);\r\n                scraper.setCharset(PARSER_MODE_URLREDIRECTOR);\r\n                \r\n                OutputStream hfos = new htmlFilterOutputStream(null, scraper, null, false);            \r\n                serverFileUtils.copy(sourceFile, hfos);\r\n                hfos.close();\r\n                return transformScraper(location, mimeType, scraper);\r\n            } else {\r\n                serverLog.logWarning(\"PARSER\", \"parseSource2: wrong mime type\");\r\n                return null;\r\n            }\r\n        } catch (Exception e) {\r\n            if (e instanceof InterruptedException) throw (InterruptedException) e;\r\n            serverLog.logSevere(\"PARSER\", \"parseSource2: \" + e.getMessage(), e);\r\n            return null;\r\n        } finally {\r\n            if (theParser != null) {\r\n                try { plasmaParser.theParserPool.returnObject(mimeType, theParser); } catch (Exception e) { }\r\n            }\r\n        }\r\n    }","id":44105,"modified_method":"public plasmaParserDocument parseSource(URL location, String mimeType, String charset, File sourceFile) throws InterruptedException {\r\n\r\n        Parser theParser = null;\r\n        try {\r\n            mimeType = getRealMimeType(mimeType);\r\n            String fileExt = getFileExt(location);\r\n            \r\n            if (this.theLogger.isFine())\r\n                this.theLogger.logFine(\"Parsing \" + location + \" with mimeType '\" + mimeType + \r\n                                       \"' and file extension '\" + fileExt + \"'.\");\r\n            \r\n            /*\r\n             * There are some problematic mimeType - fileExtension combination where we have to enforce\r\n             * a mimeType detection to get the proper parser for the content\r\n             * \r\n             * - application/zip + .odt\r\n             * - text/plain + .odt\r\n             * - text/plain + .vcf\r\n             * - text/xml + .rss\r\n             * - text/xml + .atom\r\n             * \r\n             * In all these cases we can trust the fileExtension and have to determine the proper mimeType.\r\n             * \r\n             */\r\n            \r\n//            // Handling of not trustable mimeTypes\r\n//            // - text/plain\r\n//            // - text/xml\r\n//            // - application/octet-stream\r\n//            // - application/zip\r\n//            if (\r\n//                    (mimeType.equalsIgnoreCase(\"text/plain\") && !fileExt.equalsIgnoreCase(\"txt\")) || \r\n//                    (mimeType.equalsIgnoreCase(\"text/xml\")   && !fileExt.equalsIgnoreCase(\"txt\")) \r\n//            ) {\r\n//                if (this.theLogger.isFine())\r\n//                    this.theLogger.logFine(\"Document \" + location + \" has an mimeType '\" + mimeType + \r\n//                                           \"' that seems not to be correct for file extension '\" + fileExt + \"'.\");                \r\n//                \r\n//                if (enabledParserList.containsKey(\"application/octet-stream\")) {\r\n//                    theParser = this.getParser(\"application/octet-stream\");\r\n//                    Object newMime = theParser.getClass().getMethod(\"getMimeType\", new Class[]{File.class}).invoke(theParser, sourceFile);\r\n//                    if (newMime == null)\r\n//                    if (newMime instanceof String) {\r\n//                        String newMimeType = (String)newMime;\r\n//                        if ((newMimeType.equals(\"application/octet-stream\")) {\r\n//                            return null;\r\n//                        }\r\n//                        mimeType = newMimeType;\r\n//                    }\r\n//                } else {\r\n//                    return null;\r\n//                }\r\n//            } else if (mimeType.equalsIgnoreCase(\"application/zip\") && fileExt.equalsIgnoreCase(\"odt\")){\r\n//                if (enabledParserList.containsKey(\"application/vnd.oasis.opendocument.text\")) {\r\n//                    mimeType = \"application/vnd.oasis.opendocument.text\";\r\n//                } else {\r\n//                    return null;\r\n//                }\r\n//            }        \r\n            \r\n            // getting the correct parser for the given mimeType\r\n            theParser = this.getParser(mimeType);\r\n            \r\n            // if a parser was found we use it ...\r\n            if (theParser != null) {\r\n                return theParser.parse(location, mimeType,charset,sourceFile);\r\n            } else if (realtimeParsableMimeTypesContains(mimeType)) {                      \r\n                // ...otherwise we make a scraper and transformer\r\n                htmlFilterContentScraper scraper = new htmlFilterContentScraper(location);\r\n                \r\n                // set the charset if known\r\n                if (charset != null) {\r\n                    try {\r\n                    scraper.setCharset(charset);\r\n                    } catch (UnsupportedCharsetException e) {\r\n                        serverLog.logWarning(\"PARSER\", \"parseSource2: unknown or unsupported charset '\" + charset + \"'\");\r\n                        return null;                        \r\n                    }\r\n                }                \r\n                \r\n                OutputStream hfos = new htmlFilterOutputStream(null, scraper, null, false);            \r\n                serverFileUtils.copy(sourceFile, hfos);\r\n                hfos.close();\r\n                return transformScraper(location, mimeType, scraper);\r\n            } else {\r\n                serverLog.logWarning(\"PARSER\", \"parseSource2: wrong mime type\");\r\n                return null;\r\n            }\r\n        } catch (Exception e) {\r\n            if (e instanceof InterruptedException) throw (InterruptedException) e;\r\n            serverLog.logSevere(\"PARSER\", \"parseSource2: \" + e.getMessage(), e);\r\n            return null;\r\n        } finally {\r\n            if (theParser != null) {\r\n                try { plasmaParser.theParserPool.returnObject(mimeType, theParser); } catch (Exception e) { }\r\n            }\r\n        }\r\n    }","commit_id":"c5d30209413350be0bf106c26dbba135ebd4bd0b","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private String urlDecode(ByteChunk bc, Charset charset)\n        throws IOException {\n        if( urlDec==null ) {\n            urlDec=new UDecoder();\n        }\n        urlDec.convert(bc);\n        bc.setCharset(charset);\n        return bc.toString();\n    }","id":44106,"modified_method":"private void urlDecode(ByteChunk bc)\n        throws IOException {\n        if( urlDec==null ) {\n            urlDec=new UDecoder();\n        }\n        urlDec.convert(bc);\n    }","commit_id":"0286e5f088076566e3f75946139300432a4c90ea","url":"https://github.com/apache/tomcat"},{"original_method":"private void processParameters(byte bytes[], int start, int len,\n                                  Charset charset) {\n\n        if(log.isDebugEnabled()) {\n            log.debug(sm.getString(\"parameters.bytes\",\n                    new String(bytes, start, len, DEFAULT_CHARSET)));\n        }\n\n        int decodeFailCount = 0;\n\n        int pos = start;\n        int end = start + len;\n\n        while(pos < end) {\n            parameterCount ++;\n\n            if (limit > -1 && parameterCount >= limit) {\n                log.warn(sm.getString(\"parameters.maxCountFail\",\n                        Integer.valueOf(limit)));\n                break;\n            }\n            int nameStart = pos;\n            int nameEnd = -1;\n            int valueStart = -1;\n            int valueEnd = -1;\n\n            boolean parsingName = true;\n            boolean decodeName = false;\n            boolean decodeValue = false;\n            boolean parameterComplete = false;\n\n            do {\n                switch(bytes[pos]) {\n                    case '=':\n                        if (parsingName) {\n                            // Name finished. Value starts from next character\n                            nameEnd = pos;\n                            parsingName = false;\n                            valueStart = ++pos;\n                        } else {\n                            // Equals character in value\n                            pos++;\n                        }\n                        break;\n                    case '&':\n                        if (parsingName) {\n                            // Name finished. No value.\n                            nameEnd = pos;\n                        } else {\n                            // Value finished\n                            valueEnd  = pos;\n                        }\n                        parameterComplete = true;\n                        pos++;\n                        break;\n                    case '%':\n                        // Decoding required\n                        if (parsingName) {\n                            decodeName = true;\n                        } else {\n                            decodeValue = true;\n                        }\n                        pos ++;\n                        break;\n                    default:\n                        pos ++;\n                        break;\n                }\n            } while (!parameterComplete && pos < end);\n\n            if (pos == end) {\n                if (nameEnd == -1) {\n                    nameEnd = pos;\n                } else if (valueStart > -1 && valueEnd == -1){\n                    valueEnd = pos;\n                }\n            }\n\n            if (log.isDebugEnabled() && valueStart == -1) {\n                log.debug(sm.getString(\"parameters.noequal\",\n                        Integer.valueOf(nameStart), Integer.valueOf(nameEnd),\n                        new String(bytes, nameStart, nameEnd-nameStart,\n                                DEFAULT_CHARSET)));\n            }\n\n            if (nameEnd <= nameStart ) {\n                if (log.isInfoEnabled()) {\n                    String extract;\n                    if (valueEnd >= nameStart) {\n                        extract = new String(bytes, nameStart,\n                                valueEnd - nameStart, DEFAULT_CHARSET);\n                        log.info(sm.getString(\"parameters.invalidChunk\",\n                                Integer.valueOf(nameStart),\n                                Integer.valueOf(valueEnd),\n                                extract));\n                    } else {\n                        log.info(sm.getString(\"parameters.invalidChunk\",\n                                Integer.valueOf(nameStart),\n                                Integer.valueOf(nameEnd),\n                                null));\n                    }\n                }\n                continue;\n                // invalid chunk - it's better to ignore\n            }\n\n            tmpName.setBytes(bytes, nameStart, nameEnd - nameStart);\n            tmpValue.setBytes(bytes, valueStart, valueEnd - valueStart);\n\n            // Take copies as if anything goes wrong originals will be\n            // corrupted. This means original values can be logged.\n            // For performance - only done for debug\n            if (log.isDebugEnabled()) {\n                try {\n                    origName.append(bytes, nameStart, nameEnd - nameStart);\n                    origValue.append(bytes, valueStart, valueEnd - valueStart);\n                } catch (IOException ioe) {\n                    // Should never happen...\n                    log.error(sm.getString(\"paramerers.copyFail\"), ioe);\n                }\n            }\n\n            try {\n                String name;\n                String value;\n\n                if (decodeName) {\n                    name = urlDecode(tmpName, charset);\n                } else {\n                    tmpName.setCharset(charset);\n                    name = tmpName.toString();\n                }\n\n                if (decodeValue) {\n                    value = urlDecode(tmpValue, charset);\n                } else {\n                    tmpValue.setCharset(charset);\n                    value = tmpValue.toString();\n                }\n\n                addParameter(name, value);\n            } catch (IOException e) {\n                decodeFailCount++;\n                if (decodeFailCount == 1 || log.isDebugEnabled()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"parameters.decodeFail.debug\",\n                                origName.toString(), origValue.toString()), e);\n                    } else if (log.isInfoEnabled()) {\n                        log.info(sm.getString(\"parameters.decodeFail.info\",\n                                tmpName.toString(), tmpValue.toString()), e);\n                    }\n                }\n            }\n\n            tmpName.recycle();\n            tmpValue.recycle();\n            // Only recycle copies if we used them\n            if (log.isDebugEnabled()) {\n                origName.recycle();\n                origValue.recycle();\n            }\n        }\n\n        if (decodeFailCount > 1 && !log.isDebugEnabled()) {\n            log.info(sm.getString(\"parameters.multipleDecodingFail\",\n                    Integer.valueOf(decodeFailCount)));\n        }\n    }","id":44107,"modified_method":"private void processParameters(byte bytes[], int start, int len,\n                                  Charset charset) {\n\n        if(log.isDebugEnabled()) {\n            log.debug(sm.getString(\"parameters.bytes\",\n                    new String(bytes, start, len, DEFAULT_CHARSET)));\n        }\n\n        int decodeFailCount = 0;\n\n        int pos = start;\n        int end = start + len;\n\n        while(pos < end) {\n            parameterCount ++;\n\n            if (limit > -1 && parameterCount >= limit) {\n                log.warn(sm.getString(\"parameters.maxCountFail\",\n                        Integer.valueOf(limit)));\n                break;\n            }\n            int nameStart = pos;\n            int nameEnd = -1;\n            int valueStart = -1;\n            int valueEnd = -1;\n\n            boolean parsingName = true;\n            boolean decodeName = false;\n            boolean decodeValue = false;\n            boolean parameterComplete = false;\n\n            do {\n                switch(bytes[pos]) {\n                    case '=':\n                        if (parsingName) {\n                            // Name finished. Value starts from next character\n                            nameEnd = pos;\n                            parsingName = false;\n                            valueStart = ++pos;\n                        } else {\n                            // Equals character in value\n                            pos++;\n                        }\n                        break;\n                    case '&':\n                        if (parsingName) {\n                            // Name finished. No value.\n                            nameEnd = pos;\n                        } else {\n                            // Value finished\n                            valueEnd  = pos;\n                        }\n                        parameterComplete = true;\n                        pos++;\n                        break;\n                    case '%':\n                        // Decoding required\n                        if (parsingName) {\n                            decodeName = true;\n                        } else {\n                            decodeValue = true;\n                        }\n                        pos ++;\n                        break;\n                    default:\n                        pos ++;\n                        break;\n                }\n            } while (!parameterComplete && pos < end);\n\n            if (pos == end) {\n                if (nameEnd == -1) {\n                    nameEnd = pos;\n                } else if (valueStart > -1 && valueEnd == -1){\n                    valueEnd = pos;\n                }\n            }\n\n            if (log.isDebugEnabled() && valueStart == -1) {\n                log.debug(sm.getString(\"parameters.noequal\",\n                        Integer.valueOf(nameStart), Integer.valueOf(nameEnd),\n                        new String(bytes, nameStart, nameEnd-nameStart,\n                                DEFAULT_CHARSET)));\n            }\n\n            if (nameEnd <= nameStart ) {\n                if (log.isInfoEnabled()) {\n                    String extract;\n                    if (valueEnd >= nameStart) {\n                        extract = new String(bytes, nameStart,\n                                valueEnd - nameStart, DEFAULT_CHARSET);\n                        log.info(sm.getString(\"parameters.invalidChunk\",\n                                Integer.valueOf(nameStart),\n                                Integer.valueOf(valueEnd),\n                                extract));\n                    } else {\n                        log.info(sm.getString(\"parameters.invalidChunk\",\n                                Integer.valueOf(nameStart),\n                                Integer.valueOf(nameEnd),\n                                null));\n                    }\n                }\n                continue;\n                // invalid chunk - it's better to ignore\n            }\n\n            tmpName.setBytes(bytes, nameStart, nameEnd - nameStart);\n            tmpValue.setBytes(bytes, valueStart, valueEnd - valueStart);\n\n            // Take copies as if anything goes wrong originals will be\n            // corrupted. This means original values can be logged.\n            // For performance - only done for debug\n            if (log.isDebugEnabled()) {\n                try {\n                    origName.append(bytes, nameStart, nameEnd - nameStart);\n                    origValue.append(bytes, valueStart, valueEnd - valueStart);\n                } catch (IOException ioe) {\n                    // Should never happen...\n                    log.error(sm.getString(\"paramerers.copyFail\"), ioe);\n                }\n            }\n\n            try {\n                String name;\n                String value;\n\n                if (decodeName) {\n                    urlDecode(tmpName);\n                }\n                tmpName.setCharset(charset);\n                name = tmpName.toString();\n\n                if (decodeValue) {\n                    urlDecode(tmpValue);\n                }\n                tmpValue.setCharset(charset);\n                value = tmpValue.toString();\n\n                addParameter(name, value);\n            } catch (IOException e) {\n                decodeFailCount++;\n                if (decodeFailCount == 1 || log.isDebugEnabled()) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\"parameters.decodeFail.debug\",\n                                origName.toString(), origValue.toString()), e);\n                    } else if (log.isInfoEnabled()) {\n                        log.info(sm.getString(\"parameters.decodeFail.info\",\n                                tmpName.toString(), tmpValue.toString()), e);\n                    }\n                }\n            }\n\n            tmpName.recycle();\n            tmpValue.recycle();\n            // Only recycle copies if we used them\n            if (log.isDebugEnabled()) {\n                origName.recycle();\n                origValue.recycle();\n            }\n        }\n\n        if (decodeFailCount > 1 && !log.isDebugEnabled()) {\n            log.info(sm.getString(\"parameters.multipleDecodingFail\",\n                    Integer.valueOf(decodeFailCount)));\n        }\n    }","commit_id":"0286e5f088076566e3f75946139300432a4c90ea","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void parse(ParseContext context) throws IOException {\n        byte[] content = null;\n        String contentType = null;\n        int indexedChars = defaultIndexedChars;\n        boolean langDetect = defaultLangDetect;\n        String name = null;\n        String language = null;\n\n        XContentParser parser = context.parser();\n        XContentParser.Token token = parser.currentToken();\n        if (token == XContentParser.Token.VALUE_STRING) {\n            content = parser.binaryValue();\n        } else {\n            String currentFieldName = null;\n            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                if (token == XContentParser.Token.FIELD_NAME) {\n                    currentFieldName = parser.currentName();\n                } else if (token == XContentParser.Token.VALUE_STRING) {\n                    if (\"_content\".equals(currentFieldName)) {\n                        content = parser.binaryValue();\n                    } else if (\"_content_type\".equals(currentFieldName)) {\n                        contentType = parser.text();\n                    } else if (\"_name\".equals(currentFieldName)) {\n                        name = parser.text();\n                    } else if (\"_language\".equals(currentFieldName)) {\n                        language = parser.text();\n                    }\n                } else if (token == XContentParser.Token.VALUE_NUMBER) {\n                    if (\"_indexed_chars\".equals(currentFieldName) || \"_indexedChars\".equals(currentFieldName)) {\n                        indexedChars = parser.intValue();\n                    }\n                } else if (token == XContentParser.Token.VALUE_BOOLEAN) {\n                    if (\"_detect_language\".equals(currentFieldName) || \"_detectLanguage\".equals(currentFieldName)) {\n                        langDetect = parser.booleanValue();\n                    }\n                }\n            }\n        }\n\n        // Throw clean exception when no content is provided Fix #23\n        if (content == null) {\n            throw new MapperParsingException(\"No content is provided.\");\n        }\n\n        Metadata metadata = new Metadata();\n        if (contentType != null) {\n            metadata.add(Metadata.CONTENT_TYPE, contentType);\n        }\n        if (name != null) {\n            metadata.add(Metadata.RESOURCE_NAME_KEY, name);\n        }\n\n        String parsedContent;\n        try {\n            Tika tika = tika();\n            if (tika == null) {\n                if (!ignoreErrors) {\n                    throw new MapperParsingException(\"Tika can not be initialized with the current Locale [\" +\n                            Locale.getDefault().getLanguage() + \"] on the current JVM [\" +\n                            Constants.JAVA_VERSION + \"]\");\n                } else {\n                    logger.warn(\"Tika can not be initialized with the current Locale [{}] on the current JVM [{}]\",\n                            Locale.getDefault().getLanguage(), Constants.JAVA_VERSION);\n                    return;\n                }\n            }\n            // Set the maximum length of strings returned by the parseToString method, -1 sets no limit\n            parsedContent = tika.parseToString(new BytesStreamInput(content), metadata, indexedChars);\n        } catch (Throwable e) {\n            // It could happen that Tika adds a System property `sun.font.fontmanager` which should not happen\n            // TODO Remove when this will be fixed in Tika. See https://issues.apache.org/jira/browse/TIKA-1548\n            System.clearProperty(\"sun.font.fontmanager\");\n\n            // #18: we could ignore errors when Tika does not parse data\n            if (!ignoreErrors) {\n                logger.trace(\"exception caught\", e);\n                throw new MapperParsingException(\"Failed to extract [\" + indexedChars + \"] characters of text for [\" + name + \"] : \"\n                        + e.getMessage());\n            } else {\n                logger.debug(\"Failed to extract [{}] characters of text for [{}]: [{}]\", indexedChars, name, e.getMessage());\n                logger.trace(\"exception caught\", e);\n            }\n            return;\n        }\n\n        context = context.createExternalValueContext(parsedContent);\n        contentMapper.parse(context);\n\n        if (langDetect) {\n            try {\n                if (language != null) {\n                    metadata.add(Metadata.CONTENT_LANGUAGE, language);\n                } else {\n                    LanguageIdentifier identifier = new LanguageIdentifier(parsedContent);\n                    language = identifier.getLanguage();\n                }\n                context = context.createExternalValueContext(language);\n                languageMapper.parse(context);\n            } catch(Throwable t) {\n                logger.debug(\"Cannot detect language: [{}]\", t.getMessage());\n            }\n        }\n\n        if (name != null) {\n            try {\n                context = context.createExternalValueContext(name);\n                nameMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing name: [{}]\",\n                        e.getMessage());\n            }\n        }\n\n        if (metadata.get(Metadata.DATE) != null) {\n            try {\n                context = context.createExternalValueContext(metadata.get(Metadata.DATE));\n                dateMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing date: [{}]: [{}]\",\n                        e.getMessage(), context.externalValue());\n            }\n        }\n\n        if (metadata.get(Metadata.TITLE) != null) {\n            try {\n                context = context.createExternalValueContext(metadata.get(Metadata.TITLE));\n                titleMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing title: [{}]: [{}]\",\n                        e.getMessage(), context.externalValue());\n            }\n        }\n\n        if (metadata.get(Metadata.AUTHOR) != null) {\n            try {\n                context = context.createExternalValueContext(metadata.get(Metadata.AUTHOR));\n                authorMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing author: [{}]: [{}]\",\n                        e.getMessage(), context.externalValue());\n            }\n        }\n\n        if (metadata.get(Metadata.KEYWORDS) != null) {\n            try {\n                context = context.createExternalValueContext(metadata.get(Metadata.KEYWORDS));\n                keywordsMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing keywords: [{}]: [{}]\",\n                        e.getMessage(), context.externalValue());\n            }\n        }\n\n        if (contentType == null) {\n            contentType = metadata.get(Metadata.CONTENT_TYPE);\n        }\n        if (contentType != null) {\n            try {\n                context = context.createExternalValueContext(contentType);\n                contentTypeMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing content_type: [{}]: [{}]\", e.getMessage(), context.externalValue());\n            }\n        }\n\n        int length = content.length;\n        // If we have CONTENT_LENGTH from Tika we use it\n        if (metadata.get(Metadata.CONTENT_LENGTH) != null) {\n            length = Integer.parseInt(metadata.get(Metadata.CONTENT_LENGTH));\n        }\n\n        try {\n            context = context.createExternalValueContext(length);\n            contentLengthMapper.parse(context);\n        } catch(MapperParsingException e){\n            if (!ignoreErrors) throw e;\n            if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing content_length: [{}]: [{}]\", e.getMessage(), context.externalValue());\n        }\n\n//        multiFields.parse(this, context);\n        if (copyTo != null) {\n            copyTo.parse(context);\n        }\n    }","id":44108,"modified_method":"@Override\n    public Mapper parse(ParseContext context) throws IOException {\n        byte[] content = null;\n        String contentType = null;\n        int indexedChars = defaultIndexedChars;\n        boolean langDetect = defaultLangDetect;\n        String name = null;\n        String language = null;\n\n        XContentParser parser = context.parser();\n        XContentParser.Token token = parser.currentToken();\n        if (token == XContentParser.Token.VALUE_STRING) {\n            content = parser.binaryValue();\n        } else {\n            String currentFieldName = null;\n            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                if (token == XContentParser.Token.FIELD_NAME) {\n                    currentFieldName = parser.currentName();\n                } else if (token == XContentParser.Token.VALUE_STRING) {\n                    if (\"_content\".equals(currentFieldName)) {\n                        content = parser.binaryValue();\n                    } else if (\"_content_type\".equals(currentFieldName)) {\n                        contentType = parser.text();\n                    } else if (\"_name\".equals(currentFieldName)) {\n                        name = parser.text();\n                    } else if (\"_language\".equals(currentFieldName)) {\n                        language = parser.text();\n                    }\n                } else if (token == XContentParser.Token.VALUE_NUMBER) {\n                    if (\"_indexed_chars\".equals(currentFieldName) || \"_indexedChars\".equals(currentFieldName)) {\n                        indexedChars = parser.intValue();\n                    }\n                } else if (token == XContentParser.Token.VALUE_BOOLEAN) {\n                    if (\"_detect_language\".equals(currentFieldName) || \"_detectLanguage\".equals(currentFieldName)) {\n                        langDetect = parser.booleanValue();\n                    }\n                }\n            }\n        }\n\n        // Throw clean exception when no content is provided Fix #23\n        if (content == null) {\n            throw new MapperParsingException(\"No content is provided.\");\n        }\n\n        Metadata metadata = new Metadata();\n        if (contentType != null) {\n            metadata.add(Metadata.CONTENT_TYPE, contentType);\n        }\n        if (name != null) {\n            metadata.add(Metadata.RESOURCE_NAME_KEY, name);\n        }\n\n        String parsedContent;\n        try {\n            Tika tika = tika();\n            if (tika == null) {\n                if (!ignoreErrors) {\n                    throw new MapperParsingException(\"Tika can not be initialized with the current Locale [\" +\n                            Locale.getDefault().getLanguage() + \"] on the current JVM [\" +\n                            Constants.JAVA_VERSION + \"]\");\n                } else {\n                    logger.warn(\"Tika can not be initialized with the current Locale [{}] on the current JVM [{}]\",\n                            Locale.getDefault().getLanguage(), Constants.JAVA_VERSION);\n                    return null;\n                }\n            }\n            // Set the maximum length of strings returned by the parseToString method, -1 sets no limit\n            parsedContent = tika.parseToString(new BytesStreamInput(content), metadata, indexedChars);\n        } catch (Throwable e) {\n            // It could happen that Tika adds a System property `sun.font.fontmanager` which should not happen\n            // TODO Remove when this will be fixed in Tika. See https://issues.apache.org/jira/browse/TIKA-1548\n            System.clearProperty(\"sun.font.fontmanager\");\n\n            // #18: we could ignore errors when Tika does not parse data\n            if (!ignoreErrors) {\n                logger.trace(\"exception caught\", e);\n                throw new MapperParsingException(\"Failed to extract [\" + indexedChars + \"] characters of text for [\" + name + \"] : \"\n                        + e.getMessage());\n            } else {\n                logger.debug(\"Failed to extract [{}] characters of text for [{}]: [{}]\", indexedChars, name, e.getMessage());\n                logger.trace(\"exception caught\", e);\n            }\n            return null;\n        }\n\n        context = context.createExternalValueContext(parsedContent);\n        contentMapper.parse(context);\n\n        if (langDetect) {\n            try {\n                if (language != null) {\n                    metadata.add(Metadata.CONTENT_LANGUAGE, language);\n                } else {\n                    LanguageIdentifier identifier = new LanguageIdentifier(parsedContent);\n                    language = identifier.getLanguage();\n                }\n                context = context.createExternalValueContext(language);\n                languageMapper.parse(context);\n            } catch(Throwable t) {\n                logger.debug(\"Cannot detect language: [{}]\", t.getMessage());\n            }\n        }\n\n        if (name != null) {\n            try {\n                context = context.createExternalValueContext(name);\n                nameMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing name: [{}]\",\n                        e.getMessage());\n            }\n        }\n\n        if (metadata.get(Metadata.DATE) != null) {\n            try {\n                context = context.createExternalValueContext(metadata.get(Metadata.DATE));\n                dateMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing date: [{}]: [{}]\",\n                        e.getMessage(), context.externalValue());\n            }\n        }\n\n        if (metadata.get(Metadata.TITLE) != null) {\n            try {\n                context = context.createExternalValueContext(metadata.get(Metadata.TITLE));\n                titleMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing title: [{}]: [{}]\",\n                        e.getMessage(), context.externalValue());\n            }\n        }\n\n        if (metadata.get(Metadata.AUTHOR) != null) {\n            try {\n                context = context.createExternalValueContext(metadata.get(Metadata.AUTHOR));\n                authorMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing author: [{}]: [{}]\",\n                        e.getMessage(), context.externalValue());\n            }\n        }\n\n        if (metadata.get(Metadata.KEYWORDS) != null) {\n            try {\n                context = context.createExternalValueContext(metadata.get(Metadata.KEYWORDS));\n                keywordsMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing keywords: [{}]: [{}]\",\n                        e.getMessage(), context.externalValue());\n            }\n        }\n\n        if (contentType == null) {\n            contentType = metadata.get(Metadata.CONTENT_TYPE);\n        }\n        if (contentType != null) {\n            try {\n                context = context.createExternalValueContext(contentType);\n                contentTypeMapper.parse(context);\n            } catch(MapperParsingException e){\n                if (!ignoreErrors) throw e;\n                if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing content_type: [{}]: [{}]\", e.getMessage(), context.externalValue());\n            }\n        }\n\n        int length = content.length;\n        // If we have CONTENT_LENGTH from Tika we use it\n        if (metadata.get(Metadata.CONTENT_LENGTH) != null) {\n            length = Integer.parseInt(metadata.get(Metadata.CONTENT_LENGTH));\n        }\n\n        try {\n            context = context.createExternalValueContext(length);\n            contentLengthMapper.parse(context);\n        } catch(MapperParsingException e){\n            if (!ignoreErrors) throw e;\n            if (logger.isDebugEnabled()) logger.debug(\"Ignoring MapperParsingException catch while parsing content_length: [{}]: [{}]\", e.getMessage(), context.externalValue());\n        }\n\n//        multiFields.parse(this, context);\n        if (copyTo != null) {\n            copyTo.parse(context);\n        }\n\n        return null;\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void merge(Mapper mergeWith, MergeContext mergeContext) throws MergeMappingException {\n        // ignore this for now\n    }","id":44109,"modified_method":"@Override\n    public void merge(Mapper mergeWith, MergeResult mergeResult) throws MergeMappingException {\n        // ignore this for now\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleMappings() throws Exception {\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/date/date-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n\n        // Our mapping should be kept as a String\n        assertThat(docMapper.mappers().fullName(\"file.date\").mapper(), instanceOf(StringFieldMapper.class));\n    }","id":44110,"modified_method":"@Test\n    public void testSimpleMappings() throws Exception {\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/date/date-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n\n        // Our mapping should be kept as a String\n        assertThat(docMapper.mappers().getMapper(\"file.date\"), instanceOf(StringFieldMapper.class));\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test(expected = MapperParsingException.class)\n    public void testMultipleDocsEncryptedNotIgnoringErrors() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(ImmutableSettings.builder().put(\"index.mapping.attachment.ignore_errors\", false).build());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"_id\", 1)\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.title\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.author\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.keywords\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.content_type\").mapper().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().smartName(\"file1.content_length\").mapper().names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2\").mapper().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.title\").mapper().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.author\").mapper().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.keywords\").mapper().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.content_type\").mapper().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().smartName(\"file2.content_length\").mapper().names().indexName()).numericValue().longValue(), is(344L));\n    }","id":44111,"modified_method":"@Test(expected = MapperParsingException.class)\n    public void testMultipleDocsEncryptedNotIgnoringErrors() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(ImmutableSettings.builder().put(\"index.mapping.attachment.ignore_errors\", false).build());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"_id\", 1)\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2\").names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").names().indexName()).numericValue().longValue(), is(344L));\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testMultipleDocsEncryptedLast() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .field(\"_id\", 1)\n                    .field(\"file1\", html)\n                    .field(\"file2\", pdf)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1\").mapper().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.title\").mapper().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.author\").mapper().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.keywords\").mapper().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.content_type\").mapper().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().smartName(\"file1.content_length\").mapper().names().indexName()).numericValue().longValue(), is(344L));\n\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.title\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.author\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.keywords\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.content_type\").mapper().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().smartName(\"file2.content_length\").mapper().names().indexName()), nullValue());\n    }","id":44112,"modified_method":"@Test\n    public void testMultipleDocsEncryptedLast() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .field(\"_id\", 1)\n                    .field(\"file1\", html)\n                    .field(\"file2\", pdf)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1\").names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").names().indexName()).numericValue().longValue(), is(344L));\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").names().indexName()), nullValue());\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testMultipleDocsEncryptedFirst() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"_id\", 1)\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.title\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.author\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.keywords\").mapper().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().smartName(\"file1.content_type\").mapper().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().smartName(\"file1.content_length\").mapper().names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2\").mapper().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.title\").mapper().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.author\").mapper().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.keywords\").mapper().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file2.content_type\").mapper().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().smartName(\"file2.content_length\").mapper().names().indexName()).numericValue().longValue(), is(344L));\n    }","id":44113,"modified_method":"@Test\n    public void testMultipleDocsEncryptedFirst() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser();\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"_id\", 1)\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2\").names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").names().indexName()).numericValue().longValue(), is(344L));\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLangDetectDocumentEnabled() throws Exception {\n        // We replace the mapper with another one which have index.mapping.attachment.detect_language = false\n        setupMapperParser(false);\n\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/text-in-english.txt\");\n\n        XContentBuilder xcb = jsonBuilder()\n                .startObject()\n                .field(\"_id\", 1)\n                .startObject(\"file\")\n                    .field(\"_name\", \"text-in-english.txt\")\n                    .field(\"_content\", html)\n                    .field(\"_detect_language\", true)\n                .endObject().endObject();\n\n        ParseContext.Document doc =  docMapper.parse(xcb.bytes()).rootDoc();\n\n        // Our mapping should be kept as a String\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.language\").mapper().names().indexName()), equalTo(\"en\"));\n    }","id":44114,"modified_method":"@Test\n    public void testLangDetectDocumentEnabled() throws Exception {\n        // We replace the mapper with another one which have index.mapping.attachment.detect_language = false\n        setupMapperParser(false);\n\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/text-in-english.txt\");\n\n        XContentBuilder xcb = jsonBuilder()\n                .startObject()\n                .field(\"_id\", 1)\n                .startObject(\"file\")\n                    .field(\"_name\", \"text-in-english.txt\")\n                    .field(\"_content\", html)\n                    .field(\"_detect_language\", true)\n                .endObject().endObject();\n\n        ParseContext.Document doc =  docMapper.parse(xcb.bytes()).rootDoc();\n\n        // Our mapping should be kept as a String\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.language\").names().indexName()), equalTo(\"en\"));\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void setupMapperParser(boolean langDetect) throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(\n                ImmutableSettings.settingsBuilder().put(\"index.mapping.attachment.detect_language\", langDetect).build());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/language/language-mapping.json\");\n        docMapper = mapperParser.parse(mapping);\n\n        assertThat(docMapper.mappers().fullName(\"file.language\").mapper(), instanceOf(StringFieldMapper.class));\n    }","id":44115,"modified_method":"public void setupMapperParser(boolean langDetect) throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(\n                ImmutableSettings.settingsBuilder().put(\"index.mapping.attachment.detect_language\", langDetect).build());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/language/language-mapping.json\");\n        docMapper = mapperParser.parse(mapping);\n\n        assertThat(docMapper.mappers().getMapper(\"file.language\"), instanceOf(StringFieldMapper.class));\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void testLanguage(String filename, String expected, String... forcedLanguage) throws IOException {\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        XContentBuilder xcb = jsonBuilder()\n                .startObject()\n                    .field(\"_id\", 1)\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html);\n\n        if (forcedLanguage.length > 0) {\n            xcb.field(\"_language\", forcedLanguage[0]);\n        }\n\n        xcb.endObject().endObject();\n\n        ParseContext.Document doc =  docMapper.parse(xcb.bytes()).rootDoc();\n\n        // Our mapping should be kept as a String\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.language\").mapper().names().indexName()), equalTo(expected));\n    }","id":44116,"modified_method":"private void testLanguage(String filename, String expected, String... forcedLanguage) throws IOException {\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        XContentBuilder xcb = jsonBuilder()\n                .startObject()\n                    .field(\"_id\", 1)\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html);\n\n        if (forcedLanguage.length > 0) {\n            xcb.field(\"_language\", forcedLanguage[0]);\n        }\n\n        xcb.endObject().endObject();\n\n        ParseContext.Document doc =  docMapper.parse(xcb.bytes()).rootDoc();\n\n        // Our mapping should be kept as a String\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.language\").names().indexName()), equalTo(expected));\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void checkMeta(String filename, Settings settings, Long expectedDate, Long expectedLength) throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(settings);\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/metadata/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .field(\"_id\", 1)\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html)\n                    .endObject()\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().smartName(\"file\").mapper().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.name\").mapper().names().indexName()), equalTo(filename));\n        if (expectedDate == null) {\n            assertThat(doc.getField(docMapper.mappers().smartName(\"file.date\").mapper().names().indexName()), nullValue());\n        } else {\n            assertThat(doc.getField(docMapper.mappers().smartName(\"file.date\").mapper().names().indexName()).numericValue().longValue(), is(expectedDate));\n        }\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.title\").mapper().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.author\").mapper().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.keywords\").mapper().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.content_type\").mapper().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().smartName(\"file.content_length\").mapper().names().indexName()).numericValue().longValue(), is(expectedLength));\n    }","id":44117,"modified_method":"protected void checkMeta(String filename, Settings settings, Long expectedDate, Long expectedLength) throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(settings);\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/metadata/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .field(\"_id\", 1)\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html)\n                    .endObject()\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file\").names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.name\").names().indexName()), equalTo(filename));\n        if (expectedDate == null) {\n            assertThat(doc.getField(docMapper.mappers().getMapper(\"file.date\").names().indexName()), nullValue());\n        } else {\n            assertThat(doc.getField(docMapper.mappers().getMapper(\"file.date\").names().indexName()).numericValue().longValue(), is(expectedDate));\n        }\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.author\").names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.keywords\").names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file.content_length\").names().indexName()).numericValue().longValue(), is(expectedLength));\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleMappings() throws Exception {\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/multifield/multifield-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n\n\n        assertThat(docMapper.mappers().fullName(\"file\").mapper(), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().fullName(\"file.suggest\").mapper(), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().fullName(\"file.date\").mapper(), instanceOf(DateFieldMapper.class));\n        assertThat(docMapper.mappers().fullName(\"file.date.string\").mapper(), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().fullName(\"file.title\").mapper(), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().fullName(\"file.title.suggest\").mapper(), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().fullName(\"file.name\").mapper(), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().fullName(\"file.name.suggest\").mapper(), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().fullName(\"file.author\").mapper(), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().fullName(\"file.author.suggest\").mapper(), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().fullName(\"file.keywords\").mapper(), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().fullName(\"file.keywords.suggest\").mapper(), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().fullName(\"file.content_type\").mapper(), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().fullName(\"file.content_type.suggest\").mapper(), instanceOf(StringFieldMapper.class));\n    }","id":44118,"modified_method":"@Test\n    public void testSimpleMappings() throws Exception {\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/multifield/multifield-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n\n\n        assertThat(docMapper.mappers().getMapper(\"file\"), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().getMapper(\"file.suggest\"), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().getMapper(\"file.date\"), instanceOf(DateFieldMapper.class));\n        assertThat(docMapper.mappers().getMapper(\"file.date.string\"), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().getMapper(\"file.title\"), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().getMapper(\"file.title.suggest\"), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().getMapper(\"file.name\"), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().getMapper(\"file.name.suggest\"), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().getMapper(\"file.author\"), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().getMapper(\"file.author.suggest\"), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().getMapper(\"file.keywords\"), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().getMapper(\"file.keywords.suggest\"), instanceOf(StringFieldMapper.class));\n\n        assertThat(docMapper.mappers().getMapper(\"file.content_type\"), instanceOf(StringFieldMapper.class));\n        assertThat(docMapper.mappers().getMapper(\"file.content_type.suggest\"), instanceOf(StringFieldMapper.class));\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleMappings() throws Exception {\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html\");\n\n        BytesReference json = jsonBuilder().startObject().field(\"_id\", 1).field(\"file\", html).endObject().bytes();\n\n        ParseContext.Document doc = docMapper.parse(json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.content_type\").mapper().names().indexName()), equalTo(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.title\").mapper().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file\").mapper().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n\n        // re-parse it\n        String builtMapping = docMapper.mappingSource().string();\n        docMapper = mapperParser.parse(builtMapping);\n\n        json = jsonBuilder().startObject().field(\"_id\", 1).field(\"file\", html).endObject().bytes();\n\n        doc = docMapper.parse(json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.content_type\").mapper().names().indexName()), equalTo(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file.title\").mapper().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().smartName(\"file\").mapper().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n    }","id":44119,"modified_method":"@Test\n    public void testSimpleMappings() throws Exception {\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html\");\n\n        BytesReference json = jsonBuilder().startObject().field(\"_id\", 1).field(\"file\", html).endObject().bytes();\n\n        ParseContext.Document doc = docMapper.parse(json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").names().indexName()), equalTo(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file\").names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n\n        // re-parse it\n        String builtMapping = docMapper.mappingSource().string();\n        docMapper = mapperParser.parse(builtMapping);\n\n        json = jsonBuilder().startObject().field(\"_id\", 1).field(\"file\", html).endObject().bytes();\n\n        doc = docMapper.parse(json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").names().indexName()), equalTo(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file\").names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void printMetadataContent(ParseContext.Document doc, String field) {\n            terminal.println(\"- %s: %s\", field, doc.get(docMapper.mappers().smartName(\"file.\" + field).mapper().names().indexName()));\n        }","id":44120,"modified_method":"private void printMetadataContent(ParseContext.Document doc, String field) {\n            terminal.println(\"- %s: %s\", field, doc.get(docMapper.mappers().getMapper(\"file.\" + field).names().indexName()));\n        }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public ExitStatus execute(Settings settings, Environment env) throws Exception {\n            XContentBuilder builder = jsonBuilder().startObject().field(\"_id\", 1).field(\"file\").startObject();\n\n            if (base64text != null) {\n                // If base64 is provided\n                builder.field(\"_content\", base64text);\n            } else {\n                // A file is provided\n                byte[] bytes = copyToBytes(Paths.get(url));\n                builder.field(\"_content\", bytes);\n            }\n\n            if (size >= 0) {\n                builder.field(\"_indexed_chars\", size);\n            }\n\n            BytesReference json = builder.endObject().endObject().bytes();\n\n            ParseContext.Document doc = docMapper.parse(json).rootDoc();\n\n            terminal.println(\"## Extracted text\");\n            terminal.println(\"--------------------- BEGIN -----------------------\");\n            terminal.println(\"%s\", doc.get(docMapper.mappers().smartName(\"file\").mapper().names().indexName()));\n            terminal.println(\"---------------------- END ------------------------\");\n            terminal.println(\"## Metadata\");\n            printMetadataContent(doc, AttachmentMapper.FieldNames.AUTHOR);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.CONTENT_LENGTH);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.CONTENT_TYPE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.DATE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.KEYWORDS);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.LANGUAGE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.NAME);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.TITLE);\n\n            return ExitStatus.OK;\n        }","id":44121,"modified_method":"@Override\n        public ExitStatus execute(Settings settings, Environment env) throws Exception {\n            XContentBuilder builder = jsonBuilder().startObject().field(\"_id\", 1).field(\"file\").startObject();\n\n            if (base64text != null) {\n                // If base64 is provided\n                builder.field(\"_content\", base64text);\n            } else {\n                // A file is provided\n                byte[] bytes = copyToBytes(Paths.get(url));\n                builder.field(\"_content\", bytes);\n            }\n\n            if (size >= 0) {\n                builder.field(\"_indexed_chars\", size);\n            }\n\n            BytesReference json = builder.endObject().endObject().bytes();\n\n            ParseContext.Document doc = docMapper.parse(json).rootDoc();\n\n            terminal.println(\"## Extracted text\");\n            terminal.println(\"--------------------- BEGIN -----------------------\");\n            terminal.println(\"%s\", doc.get(docMapper.mappers().getMapper(\"file\").names().indexName()));\n            terminal.println(\"---------------------- END ------------------------\");\n            terminal.println(\"## Metadata\");\n            printMetadataContent(doc, AttachmentMapper.FieldNames.AUTHOR);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.CONTENT_LENGTH);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.CONTENT_TYPE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.DATE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.KEYWORDS);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.LANGUAGE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.NAME);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.TITLE);\n\n            return ExitStatus.OK;\n        }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void printMetadataContent(ParseContext.Document doc, String field) {\n        logger.debug(\"- [{}]: [{}]\", field, doc.get(docMapper.mappers().smartName(\"file.\" + field).mapper().names().indexName()));\n    }","id":44122,"modified_method":"private void printMetadataContent(ParseContext.Document doc, String field) {\n        logger.debug(\"- [{}]: [{}]\", field, doc.get(docMapper.mappers().getMapper(\"file.\" + field).names().indexName()));\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void testMapper(String filename, boolean errorExpected) throws IOException {\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .field(\"_id\", 1)\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html)\n                    .endObject()\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(json).rootDoc();\n        if (!errorExpected) {\n            assertThat(doc.get(docMapper.mappers().smartName(\"file\").mapper().names().indexName()), not(isEmptyOrNullString()));\n            logger.debug(\"-> extracted content: {}\", doc.get(docMapper.mappers().smartName(\"file\").mapper().names().indexName()));\n            logger.debug(\"-> extracted metadata:\");\n            printMetadataContent(doc, AUTHOR);\n            printMetadataContent(doc, CONTENT_LENGTH);\n            printMetadataContent(doc, CONTENT_TYPE);\n            printMetadataContent(doc, DATE);\n            printMetadataContent(doc, KEYWORDS);\n            printMetadataContent(doc, LANGUAGE);\n            printMetadataContent(doc, NAME);\n            printMetadataContent(doc, TITLE);\n        }\n    }","id":44123,"modified_method":"protected void testMapper(String filename, boolean errorExpected) throws IOException {\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .field(\"_id\", 1)\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html)\n                    .endObject()\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(json).rootDoc();\n        if (!errorExpected) {\n            assertThat(doc.get(docMapper.mappers().getMapper(\"file\").names().indexName()), not(isEmptyOrNullString()));\n            logger.debug(\"-> extracted content: {}\", doc.get(docMapper.mappers().getMapper(\"file\").names().indexName()));\n            logger.debug(\"-> extracted metadata:\");\n            printMetadataContent(doc, AUTHOR);\n            printMetadataContent(doc, CONTENT_LENGTH);\n            printMetadataContent(doc, CONTENT_TYPE);\n            printMetadataContent(doc, DATE);\n            printMetadataContent(doc, KEYWORDS);\n            printMetadataContent(doc, LANGUAGE);\n            printMetadataContent(doc, NAME);\n            printMetadataContent(doc, TITLE);\n        }\n    }","commit_id":"65a83e63d3ba80c5dda1d3f8fef7b0f660ba7955","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float, float) */\r\n\tstatic public void schedule (Task task, float delaySeconds, float intervalSeconds) {\r\n\t\tinstance().scheduleTask(task, delaySeconds, intervalSeconds);\r\n\t}","id":44124,"modified_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float, float) */\r\n\tstatic public Task schedule (Task task, float delaySeconds, float intervalSeconds) {\r\n\t\treturn instance().scheduleTask(task, delaySeconds, intervalSeconds);\r\n\t}","commit_id":"8c6a19b3d3dbbeaa054c8ed7f270753442a061fa","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #postTask(Task) */\r\n\tstatic public void post (Task task) {\r\n\t\tinstance().postTask(task);\r\n\t}","id":44125,"modified_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #postTask(Task) */\r\n\tstatic public Task post (Task task) {\r\n\t\treturn instance().postTask(task);\r\n\t}","commit_id":"8c6a19b3d3dbbeaa054c8ed7f270753442a061fa","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task to occur once after the specified delay and then a number of additional times at the specified interval. */\r\n\tpublic void scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\r\n\t\tif (task.repeatCount != CANCELLED) throw new IllegalArgumentException(\"The same task may not be scheduled twice.\");\r\n\t\ttask.executeTimeMillis = TimeUtils.nanoTime() / 1000000 + (long)(delaySeconds * 1000);\r\n\t\ttask.intervalMillis = (long)(intervalSeconds * 1000);\r\n\t\ttask.repeatCount = repeatCount;\r\n\t\tsynchronized (tasks) {\r\n\t\t\ttasks.add(task);\r\n\t\t}\r\n\t\twake();\r\n\t}","id":44126,"modified_method":"/** Schedules a task to occur once after the specified delay and then a number of additional times at the specified interval. */\r\n\tpublic Task scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\r\n\t\tif (task.repeatCount != CANCELLED) throw new IllegalArgumentException(\"The same task may not be scheduled twice.\");\r\n\t\ttask.executeTimeMillis = TimeUtils.nanoTime() / 1000000 + (long)(delaySeconds * 1000);\r\n\t\ttask.intervalMillis = (long)(intervalSeconds * 1000);\r\n\t\ttask.repeatCount = repeatCount;\r\n\t\tsynchronized (tasks) {\r\n\t\t\ttasks.add(task);\r\n\t\t}\r\n\t\twake();\r\n\t\treturn task;\r\n\t}","commit_id":"8c6a19b3d3dbbeaa054c8ed7f270753442a061fa","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task to occur once after the specified delay and then repeatedly at the specified interval until cancelled. */\r\n\tpublic void scheduleTask (Task task, float delaySeconds, float intervalSeconds) {\r\n\t\tscheduleTask(task, delaySeconds, intervalSeconds, FOREVER);\r\n\t}","id":44127,"modified_method":"/** Schedules a task to occur once after the specified delay and then repeatedly at the specified interval until cancelled. */\r\n\tpublic Task scheduleTask (Task task, float delaySeconds, float intervalSeconds) {\r\n\t\treturn scheduleTask(task, delaySeconds, intervalSeconds, FOREVER);\r\n\t}","commit_id":"8c6a19b3d3dbbeaa054c8ed7f270753442a061fa","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task to occur once as soon as possible, but not sooner than the start of the next frame. */\r\n\tpublic void postTask (Task task) {\r\n\t\tscheduleTask(task, 0, 0, 0);\r\n\t}","id":44128,"modified_method":"/** Schedules a task to occur once as soon as possible, but not sooner than the start of the next frame. */\r\n\tpublic Task postTask (Task task) {\r\n\t\treturn scheduleTask(task, 0, 0, 0);\r\n\t}","commit_id":"8c6a19b3d3dbbeaa054c8ed7f270753442a061fa","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float, float, int) */\r\n\tstatic public void schedule (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\r\n\t\tinstance().scheduleTask(task, delaySeconds, intervalSeconds, repeatCount);\r\n\t}","id":44129,"modified_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float, float, int) */\r\n\tstatic public Task schedule (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\r\n\t\treturn instance().scheduleTask(task, delaySeconds, intervalSeconds, repeatCount);\r\n\t}","commit_id":"8c6a19b3d3dbbeaa054c8ed7f270753442a061fa","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task to occur once after the specified delay. */\r\n\tpublic void scheduleTask (Task task, float delaySeconds) {\r\n\t\tscheduleTask(task, delaySeconds, 0, 0);\r\n\t}","id":44130,"modified_method":"/** Schedules a task to occur once after the specified delay. */\r\n\tpublic Task scheduleTask (Task task, float delaySeconds) {\r\n\t\treturn scheduleTask(task, delaySeconds, 0, 0);\r\n\t}","commit_id":"8c6a19b3d3dbbeaa054c8ed7f270753442a061fa","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float) */\r\n\tstatic public void schedule (Task task, float delaySeconds) {\r\n\t\tinstance().scheduleTask(task, delaySeconds);\r\n\t}","id":44131,"modified_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float) */\r\n\tstatic public Task schedule (Task task, float delaySeconds) {\r\n\t\treturn instance().scheduleTask(task, delaySeconds);\r\n\t}","commit_id":"8c6a19b3d3dbbeaa054c8ed7f270753442a061fa","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task to occur once after the specified delay. */\r\n\tpublic void scheduleTask (Task task, float delaySeconds) {\r\n\t\tscheduleTask(task, delaySeconds, 0, 0);\r\n\t}","id":44132,"modified_method":"/** Schedules a task to occur once after the specified delay. */\r\n\tpublic Task scheduleTask (Task task, float delaySeconds) {\r\n\t\treturn scheduleTask(task, delaySeconds, 0, 0);\r\n\t}","commit_id":"c4c0db96097ee51ebdda6de7b2c40a2fd4386e8d","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task to occur once after the specified delay and then repeatedly at the specified interval until cancelled. */\r\n\tpublic void scheduleTask (Task task, float delaySeconds, float intervalSeconds) {\r\n\t\tscheduleTask(task, delaySeconds, intervalSeconds, FOREVER);\r\n\t}","id":44133,"modified_method":"/** Schedules a task to occur once after the specified delay and then repeatedly at the specified interval until cancelled. */\r\n\tpublic Task scheduleTask (Task task, float delaySeconds, float intervalSeconds) {\r\n\t\treturn scheduleTask(task, delaySeconds, intervalSeconds, FOREVER);\r\n\t}","commit_id":"c4c0db96097ee51ebdda6de7b2c40a2fd4386e8d","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task to occur once as soon as possible, but not sooner than the start of the next frame. */\r\n\tpublic void postTask (Task task) {\r\n\t\tscheduleTask(task, 0, 0, 0);\r\n\t}","id":44134,"modified_method":"/** Schedules a task to occur once as soon as possible, but not sooner than the start of the next frame. */\r\n\tpublic Task postTask (Task task) {\r\n\t\treturn scheduleTask(task, 0, 0, 0);\r\n\t}","commit_id":"c4c0db96097ee51ebdda6de7b2c40a2fd4386e8d","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float) */\r\n\tstatic public void schedule (Task task, float delaySeconds) {\r\n\t\tinstance().scheduleTask(task, delaySeconds);\r\n\t}","id":44135,"modified_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float) */\r\n\tstatic public Task schedule (Task task, float delaySeconds) {\r\n\t\treturn instance().scheduleTask(task, delaySeconds);\r\n\t}","commit_id":"c4c0db96097ee51ebdda6de7b2c40a2fd4386e8d","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task to occur once after the specified delay and then a number of additional times at the specified interval. */\r\n\tpublic void scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\r\n\t\tif (task.repeatCount != CANCELLED) throw new IllegalArgumentException(\"The same task may not be scheduled twice.\");\r\n\t\ttask.executeTimeMillis = System.nanoTime() / 1000000 + (long)(delaySeconds * 1000);\r\n\t\ttask.intervalMillis = (long)(intervalSeconds * 1000);\r\n\t\ttask.repeatCount = repeatCount;\r\n\t\tsynchronized (tasks) {\r\n\t\t\ttasks.add(task);\r\n\t\t}\r\n\t\twake();\r\n\t}","id":44136,"modified_method":"/** Schedules a task to occur once after the specified delay and then a number of additional times at the specified interval. */\r\n\tpublic Task scheduleTask (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\r\n\t\tif (task.repeatCount != CANCELLED) throw new IllegalArgumentException(\"The same task may not be scheduled twice.\");\r\n\t\ttask.executeTimeMillis = System.nanoTime() / 1000000 + (long)(delaySeconds * 1000);\r\n\t\ttask.intervalMillis = (long)(intervalSeconds * 1000);\r\n\t\ttask.repeatCount = repeatCount;\r\n\t\tsynchronized (tasks) {\r\n\t\t\ttasks.add(task);\r\n\t\t}\r\n\t\twake();\r\n\t\t\r\n\t\treturn task;\r\n\t}","commit_id":"c4c0db96097ee51ebdda6de7b2c40a2fd4386e8d","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #postTask(Task) */\r\n\tstatic public void post (Task task) {\r\n\t\tinstance().postTask(task);\r\n\t}","id":44137,"modified_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #postTask(Task) */\r\n\tstatic public Task post (Task task) {\r\n\t\treturn instance().postTask(task);\r\n\t}","commit_id":"c4c0db96097ee51ebdda6de7b2c40a2fd4386e8d","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float, float, int) */\r\n\tstatic public void schedule (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\r\n\t\tinstance().scheduleTask(task, delaySeconds, intervalSeconds, repeatCount);\r\n\t}","id":44138,"modified_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float, float, int) */\r\n\tstatic public Task schedule (Task task, float delaySeconds, float intervalSeconds, int repeatCount) {\r\n\t\treturn instance().scheduleTask(task, delaySeconds, intervalSeconds, repeatCount);\r\n\t}","commit_id":"c4c0db96097ee51ebdda6de7b2c40a2fd4386e8d","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float, float) */\r\n\tstatic public void schedule (Task task, float delaySeconds, float intervalSeconds) {\r\n\t\tinstance().scheduleTask(task, delaySeconds, intervalSeconds);\r\n\t}","id":44139,"modified_method":"/** Schedules a task on {@link #instance}.\r\n\t * @see #scheduleTask(Task, float, float) */\r\n\tstatic public Task schedule (Task task, float delaySeconds, float intervalSeconds) {\r\n\t\treturn instance().scheduleTask(task, delaySeconds, intervalSeconds);\r\n\t}","commit_id":"c4c0db96097ee51ebdda6de7b2c40a2fd4386e8d","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void create () {\r\n\t\tnew Timer().scheduleTask(new Task() {\r\n\t\t\t@Override\r\n\t\t\tpublic void run () {\r\n\t\t\t\tGdx.app.log(\"TimerTest\", \"ping\");\r\n\t\t\t}\r\n\t\t}, 1, 1);\r\n\t}","id":44140,"modified_method":"@Override\r\n\tpublic void create () {\r\n\t\tTimer timer = new Timer();\r\n\t\tTask task = timer.scheduleTask(new Task() {\r\n\t\t\t@Override\r\n\t\t\tpublic void run () {\r\n\t\t\t\tGdx.app.log(\"TimerTest\", \"ping\");\r\n\t\t\t}\r\n\t\t}, 1, 1);\r\n\t\t\r\n\t\tGdx.app.log(\"TimerTest\",\"is task scheduled: \"+String.valueOf(task.isScheduled()));\r\n\t}","commit_id":"c4c0db96097ee51ebdda6de7b2c40a2fd4386e8d","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * @todo the list of needed parameters is really long, maybe this should become a Plexus component\n     */\n    protected void write( File projectBaseDir, File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, List classpathContainers, ArtifactRepository localRepository,\n                         ArtifactResolver artifactResolver, ArtifactFactory artifactFactory,\n                         List remoteArtifactRepositories, boolean downloadSources )\n        throws EclipsePluginException\n    {\n\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".classpath\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new EclipsePluginException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"classpath\" ); //$NON-NLS-1$\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n\n            writer.addAttribute( \"kind\", \"src\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", dir.getPath() ); //$NON-NLS-1$\n            if ( dir.getOutput() != null )\n            {\n                writer.addAttribute( \"output\", dir.getOutput() ); //$NON-NLS-1$\n            }\n\n            writer.endElement();\n\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"output\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, project.getBuild() //$NON-NLS-1$\n            .getOutputDirectory(), false ) );\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The JRE reference\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"var\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"rootpath\", \"JRE_SRCROOT\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", \"JRE_LIB\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"sourcepath\", \"JRE_SRC\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n\n        Set artifacts = project.getArtifacts();\n\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            addDependency( writer, artifact, referencedReactorArtifacts, localRepository, artifactResolver,\n                           artifactFactory, remoteArtifactRepositories, downloadSources );\n        }\n\n        // ----------------------------------------------------------------------\n        // Additional container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = classpathContainers.iterator(); it.hasNext(); )\n        {\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n            writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", (String) it.next() ); //$NON-NLS-1$\n            writer.endElement(); // name\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n    }","id":44141,"modified_method":"/**\n     * @todo the list of needed parameters is really long, maybe this should become a Plexus component\n     * @param outputDirectory TODO\n     */\n    protected void write( File projectBaseDir, File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, List classpathContainers, ArtifactRepository localRepository,\n                         ArtifactResolver artifactResolver, ArtifactFactory artifactFactory,\n                         List remoteArtifactRepositories, boolean downloadSources, String outputDirectory )\n        throws EclipsePluginException\n    {\n\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".classpath\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new EclipsePluginException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"classpath\" ); //$NON-NLS-1$\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n\n            writer.addAttribute( \"kind\", \"src\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", dir.getPath() ); //$NON-NLS-1$\n            if ( dir.getOutput() != null )\n            {\n                writer.addAttribute( \"output\", dir.getOutput() ); //$NON-NLS-1$\n            }\n\n            writer.endElement();\n\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"output\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", EclipseUtils.toRelativeAndFixSeparator( projectBaseDir,  //$NON-NLS-1$  \n            outputDirectory, false ) );\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The JRE reference\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"var\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"rootpath\", \"JRE_SRCROOT\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", \"JRE_LIB\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"sourcepath\", \"JRE_SRC\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n\n        Set artifacts = project.getArtifacts();\n\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            addDependency( writer, artifact, referencedReactorArtifacts, localRepository, artifactResolver,\n                           artifactFactory, remoteArtifactRepositories, downloadSources );\n        }\n\n        // ----------------------------------------------------------------------\n        // Additional container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = classpathContainers.iterator(); it.hasNext(); )\n        {\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n            writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", (String) it.next() ); //$NON-NLS-1$\n            writer.endElement(); // name\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n    }","commit_id":"190b1f077c284ff3a9f18131450093e6efc997d4","url":"https://github.com/apache/maven"},{"original_method":"public void write()\n        throws EclipsePluginException\n    {\n        File projectBaseDir = executedProject.getFile().getParentFile();\n\n        // build the list of referenced ARTIFACTS produced by reactor projects\n        List reactorArtifacts = EclipseUtils.resolveReactorArtifacts( project, reactorProjects );\n\n        // build a list of UNIQUE source dirs (both src and resources) to be used in classpath and wtpmodules\n        EclipseSourceDir[] sourceDirs = EclipseUtils.buildDirectoryList( executedProject, outputDir, getLog() );\n\n        // use project since that one has all artifacts resolved.\n        new EclipseClasspathWriter( getLog() ).write( projectBaseDir, outputDir, project, reactorArtifacts, sourceDirs,\n                                                      classpathContainers, localRepository, artifactResolver,\n                                                      artifactFactory, remoteArtifactRepositories, downloadSources );\n\n        new EclipseProjectWriter( getLog() ).write( projectBaseDir, outputDir, project, executedProject,\n                                                    reactorArtifacts, projectnatures, buildcommands );\n\n        new EclipseSettingsWriter( getLog() ).write( projectBaseDir, outputDir, executedProject );\n\n        new EclipseWtpmodulesWriter( getLog() ).write( outputDir, executedProject, reactorArtifacts, sourceDirs,\n                                                       localRepository );\n\n        getLog().info( Messages.getString( \"EclipsePlugin.wrote\", //$NON-NLS-1$\n                                           new Object[]{project.getArtifactId(), outputDir.getAbsolutePath()} ) );\n    }","id":44142,"modified_method":"public void write()\n        throws EclipsePluginException\n    {\n        File projectBaseDir = executedProject.getFile().getParentFile();\n\n        // build the list of referenced ARTIFACTS produced by reactor projects\n        List reactorArtifacts = EclipseUtils.resolveReactorArtifacts( project, reactorProjects );\n\n        // build a list of UNIQUE source dirs (both src and resources) to be used in classpath and wtpmodules\n        EclipseSourceDir[] sourceDirs = EclipseUtils.buildDirectoryList( executedProject, outputDir, getLog(), outputDirectory );\n\n        // use project since that one has all artifacts resolved.\n        new EclipseClasspathWriter( getLog() ).write( projectBaseDir, outputDir, project, reactorArtifacts, sourceDirs,\n                                                      classpathContainers, localRepository, artifactResolver,\n                                                      artifactFactory, remoteArtifactRepositories, downloadSources, outputDirectory );\n\n        new EclipseProjectWriter( getLog() ).write( projectBaseDir, outputDir, project, executedProject,\n                                                    reactorArtifacts, projectnatures, buildcommands );\n\n        new EclipseSettingsWriter( getLog() ).write( projectBaseDir, outputDir, executedProject );\n\n        new EclipseWtpmodulesWriter( getLog() ).write( outputDir, executedProject, reactorArtifacts, sourceDirs,\n                                                       localRepository );\n\n        getLog().info( Messages.getString( \"EclipsePlugin.wrote\", //$NON-NLS-1$\n                                           new Object[]{project.getArtifactId(), outputDir.getAbsolutePath()} ) );\n    }","commit_id":"190b1f077c284ff3a9f18131450093e6efc997d4","url":"https://github.com/apache/maven"},{"original_method":"private void testProject( String projectName, File outputDir )\n        throws Exception\n    {\n        File basedir = getTestFile( \"src/test/projects/\" + projectName );\n\n        MavenProjectBuilder builder = (MavenProjectBuilder) lookup( MavenProjectBuilder.ROLE );\n\n        EclipsePlugin plugin = new EclipsePlugin();\n\n        File repo = getTestFile( \"src/test/repository\" );\n\n        ArtifactRepositoryLayout localRepositoryLayout = (ArtifactRepositoryLayout) lookup(\n            ArtifactRepositoryLayout.ROLE, \"legacy\" );\n\n        ArtifactRepository localRepository = new DefaultArtifactRepository( \"local\", \"file://\" + repo.getAbsolutePath(),\n                                                                            localRepositoryLayout );\n\n        MavenProject project = builder\n            .buildWithDependencies( new File( basedir, \"project.xml\" ), localRepository, null );\n\n        File projectOutputDir = basedir;\n\n        if ( outputDir == null )\n        {\n            outputDir = basedir;\n        }\n        else\n        {\n            outputDir.mkdirs();\n\n            projectOutputDir = new File( outputDir, project.getArtifactId() );\n        }\n\n        // Shouldn't PlexusTestCase at least offer a predefined log instance?\n        //  if ( log.isDebugEnabled() )\n        //  {\n        //    log.debug( \"basedir: \" + basedir + \"\\noutputdir: \" + outputDir + \"\\nprojectOutputDir: \" + projectOutputDir );\n        //  }\n\n        plugin.setOutputDir( outputDir );\n\n        for ( Iterator it = project.getArtifacts().iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            artifact.setFile( new File( localRepository.getBasedir(), localRepository.pathOf( artifact ) ) );\n        }\n\n        plugin.setProject( project );\n\n        plugin.setLocalRepository( localRepository );\n\n        plugin.setArtifactFactory( (ArtifactFactory) lookup( ArtifactFactory.ROLE ) );\n        plugin.setArtifactResolver( (ArtifactResolver) lookup( ArtifactResolver.ROLE ) );\n        plugin.setRemoteArtifactRepositories( new ArrayList( 0 ) );\n\n        List projectNatures = new ArrayList();\n        projectNatures.add( \"org.eclipse.jdt.core.javanature\" );\n        plugin.setProjectnatures( projectNatures );\n\n        List buildcommands = new ArrayList();\n        buildcommands.add( \"org.eclipse.jdt.core.javabuilder\" );\n        plugin.setBuildcommands( buildcommands );\n\n        plugin.setClasspathContainers( new ArrayList() );\n\n        plugin.setDownloadSources( true );\n\n        // @todo how to test injected parameters?\n\n        plugin.execute();\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"project\" ),\n                          new File( projectOutputDir, \".project\" ) );\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"classpath\" ),\n                          new File( projectOutputDir, \".classpath\" ) );\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"wtpmodules\" ),\n                          new File( projectOutputDir, \".wtpmodules\" ) );\n\n        if ( new File( basedir, \"settings\" ).exists() )\n        {\n            assertFileEquals( localRepository.getBasedir(), new File( basedir, \"settings\" ),\n                              new File( basedir, \".settings/org.eclipse.jdt.core.prefs\" ) );\n        }\n    }","id":44143,"modified_method":"private void testProject( String projectName, File outputDir )\n        throws Exception\n    {\n        File basedir = getTestFile( \"src/test/projects/\" + projectName );\n\n        MavenProjectBuilder builder = (MavenProjectBuilder) lookup( MavenProjectBuilder.ROLE );\n\n        EclipsePlugin plugin = new EclipsePlugin();\n\n        File repo = getTestFile( \"src/test/repository\" );\n\n        ArtifactRepositoryLayout localRepositoryLayout = (ArtifactRepositoryLayout) lookup(\n            ArtifactRepositoryLayout.ROLE, \"legacy\" );\n\n        ArtifactRepository localRepository = new DefaultArtifactRepository( \"local\", \"file://\" + repo.getAbsolutePath(),\n                                                                            localRepositoryLayout );\n\n        MavenProject project = builder\n            .buildWithDependencies( new File( basedir, \"project.xml\" ), localRepository, null );\n\n        File projectOutputDir = basedir;\n\n        if ( outputDir == null )\n        {\n            outputDir = basedir;\n        }\n        else\n        {\n            outputDir.mkdirs();\n\n            projectOutputDir = new File( outputDir, project.getArtifactId() );\n        }\n\n        // Shouldn't PlexusTestCase at least offer a predefined log instance?\n        //  if ( log.isDebugEnabled() )\n        //  {\n        //    log.debug( \"basedir: \" + basedir + \"\\noutputdir: \" + outputDir + \"\\nprojectOutputDir: \" + projectOutputDir );\n        //  }\n\n        plugin.setOutputDir( outputDir );\n\n        for ( Iterator it = project.getArtifacts().iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            artifact.setFile( new File( localRepository.getBasedir(), localRepository.pathOf( artifact ) ) );\n        }\n\n        plugin.setProject( project );\n        plugin.setOutputDirectory( project.getBuild().getOutputDirectory() );\n\n        plugin.setLocalRepository( localRepository );\n\n        plugin.setArtifactFactory( (ArtifactFactory) lookup( ArtifactFactory.ROLE ) );\n        plugin.setArtifactResolver( (ArtifactResolver) lookup( ArtifactResolver.ROLE ) );\n        plugin.setRemoteArtifactRepositories( new ArrayList( 0 ) );\n\n        List projectNatures = new ArrayList();\n        projectNatures.add( \"org.eclipse.jdt.core.javanature\" );\n        plugin.setProjectnatures( projectNatures );\n\n        List buildcommands = new ArrayList();\n        buildcommands.add( \"org.eclipse.jdt.core.javabuilder\" );\n        plugin.setBuildcommands( buildcommands );\n\n        plugin.setClasspathContainers( new ArrayList() );\n\n        plugin.setDownloadSources( true );\n\n        // @todo how to test injected parameters?\n\n        plugin.execute();\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"project\" ),\n                          new File( projectOutputDir, \".project\" ) );\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"classpath\" ),\n                          new File( projectOutputDir, \".classpath\" ) );\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"wtpmodules\" ),\n                          new File( projectOutputDir, \".wtpmodules\" ) );\n\n        if ( new File( basedir, \"settings\" ).exists() )\n        {\n            assertFileEquals( localRepository.getBasedir(), new File( basedir, \"settings\" ),\n                              new File( basedir, \".settings/org.eclipse.jdt.core.prefs\" ) );\n        }\n    }","commit_id":"190b1f077c284ff3a9f18131450093e6efc997d4","url":"https://github.com/apache/maven"},{"original_method":"public static EclipseSourceDir[] buildDirectoryList( MavenProject project, File basedir, Log log )\n    {\n        File projectBaseDir = project.getFile().getParentFile();\n\n        // avoid duplicated entries\n        Set directories = new TreeSet();\n\n        EclipseUtils.extractSourceDirs( directories, project.getCompileSourceRoots(), basedir, projectBaseDir, false, null );\n\n        EclipseUtils.extractResourceDirs( directories, project.getBuild().getResources(), project, basedir, projectBaseDir, false,\n                             null, log );\n\n        EclipseUtils.extractSourceDirs( directories, project.getTestCompileSourceRoots(), basedir, projectBaseDir, true,\n                           EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, project.getBuild()\n                               .getTestOutputDirectory(), false ) );\n\n        EclipseUtils.extractResourceDirs( directories, project.getBuild().getTestResources(), project, basedir, projectBaseDir,\n                             true, EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, project.getBuild()\n                                 .getTestOutputDirectory(), false ), log );\n\n        return (EclipseSourceDir[]) directories.toArray( new EclipseSourceDir[directories.size()] );\n    }","id":44144,"modified_method":"public static EclipseSourceDir[] buildDirectoryList( MavenProject project, File basedir, Log log, String outputDirectory )\n    {\n        File projectBaseDir = project.getFile().getParentFile();\n\n        // avoid duplicated entries\n        Set directories = new TreeSet();\n\n        EclipseUtils.extractSourceDirs( directories, project.getCompileSourceRoots(), basedir, projectBaseDir, false, null );\n\n        EclipseUtils.extractResourceDirs( directories, project.getBuild().getResources(), project, basedir, projectBaseDir, false,\n                             null, log );\n\n        // If using the standard output location, don't mix the test output into it.\n        String testOutput = outputDirectory.equals( project.getBuild().getOutputDirectory() ) ?  \n                EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, project.getBuild().getTestOutputDirectory(), false ) :\n                null;\n        \n        EclipseUtils.extractSourceDirs( directories, project.getTestCompileSourceRoots(), basedir, projectBaseDir, true,\n                testOutput );\n\n        EclipseUtils.extractResourceDirs( directories, project.getBuild().getTestResources(), project, basedir, projectBaseDir,\n                             true, testOutput, log );\n\n        return (EclipseSourceDir[]) directories.toArray( new EclipseSourceDir[directories.size()] );\n    }","commit_id":"190b1f077c284ff3a9f18131450093e6efc997d4","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * @todo the list of needed parameters is really long, maybe this should become a Plexus component\n     */\n    protected void write( File projectBaseDir, File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, List classpathContainers, ArtifactRepository localRepository,\n                         ArtifactResolver artifactResolver, ArtifactFactory artifactFactory,\n                         List remoteArtifactRepositories, boolean downloadSources )\n        throws EclipsePluginException\n    {\n\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".classpath\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new EclipsePluginException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"classpath\" ); //$NON-NLS-1$\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n\n            writer.addAttribute( \"kind\", \"src\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", dir.getPath() ); //$NON-NLS-1$\n            if ( dir.getOutput() != null )\n            {\n                writer.addAttribute( \"output\", dir.getOutput() ); //$NON-NLS-1$\n            }\n\n            writer.endElement();\n\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"output\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, project.getBuild() //$NON-NLS-1$\n            .getOutputDirectory(), false ) );\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The JRE reference\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"var\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"rootpath\", \"JRE_SRCROOT\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", \"JRE_LIB\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"sourcepath\", \"JRE_SRC\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n\n        Set artifacts = project.getArtifacts();\n\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            addDependency( writer, artifact, referencedReactorArtifacts, localRepository, artifactResolver,\n                           artifactFactory, remoteArtifactRepositories, downloadSources );\n        }\n\n        // ----------------------------------------------------------------------\n        // Additional container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = classpathContainers.iterator(); it.hasNext(); )\n        {\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n            writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", (String) it.next() ); //$NON-NLS-1$\n            writer.endElement(); // name\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n    }","id":44145,"modified_method":"/**\n     * @todo the list of needed parameters is really long, maybe this should become a Plexus component\n     * @param outputDirectory TODO\n     */\n    protected void write( File projectBaseDir, File basedir, MavenProject project, List referencedReactorArtifacts,\n                         EclipseSourceDir[] sourceDirs, List classpathContainers, ArtifactRepository localRepository,\n                         ArtifactResolver artifactResolver, ArtifactFactory artifactFactory,\n                         List remoteArtifactRepositories, boolean downloadSources, String outputDirectory )\n        throws EclipsePluginException\n    {\n\n        FileWriter w;\n\n        try\n        {\n            w = new FileWriter( new File( basedir, \".classpath\" ) ); //$NON-NLS-1$\n        }\n        catch ( IOException ex )\n        {\n            throw new EclipsePluginException( Messages.getString( \"EclipsePlugin.erroropeningfile\" ), ex ); //$NON-NLS-1$\n        }\n\n        XMLWriter writer = new PrettyPrintXMLWriter( w );\n\n        writer.startElement( \"classpath\" ); //$NON-NLS-1$\n\n        // ----------------------------------------------------------------------\n        // Source roots and resources\n        // ----------------------------------------------------------------------\n\n        for ( int j = 0; j < sourceDirs.length; j++ )\n        {\n            EclipseSourceDir dir = sourceDirs[j];\n\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n\n            writer.addAttribute( \"kind\", \"src\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", dir.getPath() ); //$NON-NLS-1$\n            if ( dir.getOutput() != null )\n            {\n                writer.addAttribute( \"output\", dir.getOutput() ); //$NON-NLS-1$\n            }\n\n            writer.endElement();\n\n        }\n\n        // ----------------------------------------------------------------------\n        // The default output\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"output\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", EclipseUtils.toRelativeAndFixSeparator( projectBaseDir,  //$NON-NLS-1$  \n            outputDirectory, false ) );\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The JRE reference\n        // ----------------------------------------------------------------------\n\n        writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n        writer.addAttribute( \"kind\", \"var\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"rootpath\", \"JRE_SRCROOT\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"path\", \"JRE_LIB\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.addAttribute( \"sourcepath\", \"JRE_SRC\" ); //$NON-NLS-1$ //$NON-NLS-2$\n        writer.endElement();\n\n        // ----------------------------------------------------------------------\n        // The dependencies\n        // ----------------------------------------------------------------------\n\n        Set artifacts = project.getArtifacts();\n\n        for ( Iterator it = artifacts.iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            addDependency( writer, artifact, referencedReactorArtifacts, localRepository, artifactResolver,\n                           artifactFactory, remoteArtifactRepositories, downloadSources );\n        }\n\n        // ----------------------------------------------------------------------\n        // Additional container classpath entries\n        // ----------------------------------------------------------------------\n\n        for ( Iterator it = classpathContainers.iterator(); it.hasNext(); )\n        {\n            writer.startElement( \"classpathentry\" ); //$NON-NLS-1$\n            writer.addAttribute( \"kind\", \"con\" ); //$NON-NLS-1$ //$NON-NLS-2$\n            writer.addAttribute( \"path\", (String) it.next() ); //$NON-NLS-1$\n            writer.endElement(); // name\n        }\n\n        writer.endElement();\n\n        IOUtil.close( w );\n    }","commit_id":"0c41d88abb4adce73c12081b146b4bd8f3f37257","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void write()\n        throws EclipsePluginException\n    {\n        File projectBaseDir = executedProject.getFile().getParentFile();\n\n        // build the list of referenced ARTIFACTS produced by reactor projects\n        List reactorArtifacts = EclipseUtils.resolveReactorArtifacts( project, reactorProjects );\n\n        // build a list of UNIQUE source dirs (both src and resources) to be used in classpath and wtpmodules\n        EclipseSourceDir[] sourceDirs = EclipseUtils.buildDirectoryList( executedProject, outputDir, getLog() );\n\n        // use project since that one has all artifacts resolved.\n        new EclipseClasspathWriter( getLog() ).write( projectBaseDir, outputDir, project, reactorArtifacts, sourceDirs,\n                                                      classpathContainers, localRepository, artifactResolver,\n                                                      artifactFactory, remoteArtifactRepositories, downloadSources );\n\n        new EclipseProjectWriter( getLog() ).write( projectBaseDir, outputDir, project, executedProject,\n                                                    reactorArtifacts, projectnatures, buildcommands );\n\n        new EclipseSettingsWriter( getLog() ).write( projectBaseDir, outputDir, executedProject );\n\n        new EclipseWtpmodulesWriter( getLog() ).write( outputDir, executedProject, reactorArtifacts, sourceDirs,\n                                                       localRepository );\n\n        getLog().info( Messages.getString( \"EclipsePlugin.wrote\", //$NON-NLS-1$\n                                           new Object[]{project.getArtifactId(), outputDir.getAbsolutePath()} ) );\n    }","id":44146,"modified_method":"public void write()\n        throws EclipsePluginException\n    {\n        File projectBaseDir = executedProject.getFile().getParentFile();\n\n        // build the list of referenced ARTIFACTS produced by reactor projects\n        List reactorArtifacts = EclipseUtils.resolveReactorArtifacts( project, reactorProjects );\n\n        // build a list of UNIQUE source dirs (both src and resources) to be used in classpath and wtpmodules\n        EclipseSourceDir[] sourceDirs = EclipseUtils.buildDirectoryList( executedProject, outputDir, getLog(), outputDirectory );\n\n        // use project since that one has all artifacts resolved.\n        new EclipseClasspathWriter( getLog() ).write( projectBaseDir, outputDir, project, reactorArtifacts, sourceDirs,\n                                                      classpathContainers, localRepository, artifactResolver,\n                                                      artifactFactory, remoteArtifactRepositories, downloadSources, outputDirectory );\n\n        new EclipseProjectWriter( getLog() ).write( projectBaseDir, outputDir, project, executedProject,\n                                                    reactorArtifacts, projectnatures, buildcommands );\n\n        new EclipseSettingsWriter( getLog() ).write( projectBaseDir, outputDir, executedProject );\n\n        new EclipseWtpmodulesWriter( getLog() ).write( outputDir, executedProject, reactorArtifacts, sourceDirs,\n                                                       localRepository );\n\n        getLog().info( Messages.getString( \"EclipsePlugin.wrote\", //$NON-NLS-1$\n                                           new Object[]{project.getArtifactId(), outputDir.getAbsolutePath()} ) );\n    }","commit_id":"0c41d88abb4adce73c12081b146b4bd8f3f37257","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void testProject( String projectName, File outputDir )\n        throws Exception\n    {\n        File basedir = getTestFile( \"src/test/projects/\" + projectName );\n\n        MavenProjectBuilder builder = (MavenProjectBuilder) lookup( MavenProjectBuilder.ROLE );\n\n        EclipsePlugin plugin = new EclipsePlugin();\n\n        File repo = getTestFile( \"src/test/repository\" );\n\n        ArtifactRepositoryLayout localRepositoryLayout = (ArtifactRepositoryLayout) lookup(\n            ArtifactRepositoryLayout.ROLE, \"legacy\" );\n\n        ArtifactRepository localRepository = new DefaultArtifactRepository( \"local\", \"file://\" + repo.getAbsolutePath(),\n                                                                            localRepositoryLayout );\n\n        MavenProject project = builder\n            .buildWithDependencies( new File( basedir, \"project.xml\" ), localRepository, null );\n\n        File projectOutputDir = basedir;\n\n        if ( outputDir == null )\n        {\n            outputDir = basedir;\n        }\n        else\n        {\n            outputDir.mkdirs();\n\n            projectOutputDir = new File( outputDir, project.getArtifactId() );\n        }\n\n        // Shouldn't PlexusTestCase at least offer a predefined log instance?\n        //  if ( log.isDebugEnabled() )\n        //  {\n        //    log.debug( \"basedir: \" + basedir + \"\\noutputdir: \" + outputDir + \"\\nprojectOutputDir: \" + projectOutputDir );\n        //  }\n\n        plugin.setOutputDir( outputDir );\n\n        for ( Iterator it = project.getArtifacts().iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            artifact.setFile( new File( localRepository.getBasedir(), localRepository.pathOf( artifact ) ) );\n        }\n\n        plugin.setProject( project );\n\n        plugin.setLocalRepository( localRepository );\n\n        plugin.setArtifactFactory( (ArtifactFactory) lookup( ArtifactFactory.ROLE ) );\n        plugin.setArtifactResolver( (ArtifactResolver) lookup( ArtifactResolver.ROLE ) );\n        plugin.setRemoteArtifactRepositories( new ArrayList( 0 ) );\n\n        List projectNatures = new ArrayList();\n        projectNatures.add( \"org.eclipse.jdt.core.javanature\" );\n        plugin.setProjectnatures( projectNatures );\n\n        List buildcommands = new ArrayList();\n        buildcommands.add( \"org.eclipse.jdt.core.javabuilder\" );\n        plugin.setBuildcommands( buildcommands );\n\n        plugin.setClasspathContainers( new ArrayList() );\n\n        plugin.setDownloadSources( true );\n\n        // @todo how to test injected parameters?\n\n        plugin.execute();\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"project\" ),\n                          new File( projectOutputDir, \".project\" ) );\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"classpath\" ),\n                          new File( projectOutputDir, \".classpath\" ) );\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"wtpmodules\" ),\n                          new File( projectOutputDir, \".wtpmodules\" ) );\n\n        if ( new File( basedir, \"settings\" ).exists() )\n        {\n            assertFileEquals( localRepository.getBasedir(), new File( basedir, \"settings\" ),\n                              new File( basedir, \".settings/org.eclipse.jdt.core.prefs\" ) );\n        }\n    }","id":44147,"modified_method":"private void testProject( String projectName, File outputDir )\n        throws Exception\n    {\n        File basedir = getTestFile( \"src/test/projects/\" + projectName );\n\n        MavenProjectBuilder builder = (MavenProjectBuilder) lookup( MavenProjectBuilder.ROLE );\n\n        EclipsePlugin plugin = new EclipsePlugin();\n\n        File repo = getTestFile( \"src/test/repository\" );\n\n        ArtifactRepositoryLayout localRepositoryLayout = (ArtifactRepositoryLayout) lookup(\n            ArtifactRepositoryLayout.ROLE, \"legacy\" );\n\n        ArtifactRepository localRepository = new DefaultArtifactRepository( \"local\", \"file://\" + repo.getAbsolutePath(),\n                                                                            localRepositoryLayout );\n\n        MavenProject project = builder\n            .buildWithDependencies( new File( basedir, \"project.xml\" ), localRepository, null );\n\n        File projectOutputDir = basedir;\n\n        if ( outputDir == null )\n        {\n            outputDir = basedir;\n        }\n        else\n        {\n            outputDir.mkdirs();\n\n            projectOutputDir = new File( outputDir, project.getArtifactId() );\n        }\n\n        // Shouldn't PlexusTestCase at least offer a predefined log instance?\n        //  if ( log.isDebugEnabled() )\n        //  {\n        //    log.debug( \"basedir: \" + basedir + \"\\noutputdir: \" + outputDir + \"\\nprojectOutputDir: \" + projectOutputDir );\n        //  }\n\n        plugin.setOutputDir( outputDir );\n\n        for ( Iterator it = project.getArtifacts().iterator(); it.hasNext(); )\n        {\n            Artifact artifact = (Artifact) it.next();\n            artifact.setFile( new File( localRepository.getBasedir(), localRepository.pathOf( artifact ) ) );\n        }\n\n        plugin.setProject( project );\n        plugin.setOutputDirectory( project.getBuild().getOutputDirectory() );\n\n        plugin.setLocalRepository( localRepository );\n\n        plugin.setArtifactFactory( (ArtifactFactory) lookup( ArtifactFactory.ROLE ) );\n        plugin.setArtifactResolver( (ArtifactResolver) lookup( ArtifactResolver.ROLE ) );\n        plugin.setRemoteArtifactRepositories( new ArrayList( 0 ) );\n\n        List projectNatures = new ArrayList();\n        projectNatures.add( \"org.eclipse.jdt.core.javanature\" );\n        plugin.setProjectnatures( projectNatures );\n\n        List buildcommands = new ArrayList();\n        buildcommands.add( \"org.eclipse.jdt.core.javabuilder\" );\n        plugin.setBuildcommands( buildcommands );\n\n        plugin.setClasspathContainers( new ArrayList() );\n\n        plugin.setDownloadSources( true );\n\n        // @todo how to test injected parameters?\n\n        plugin.execute();\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"project\" ),\n                          new File( projectOutputDir, \".project\" ) );\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"classpath\" ),\n                          new File( projectOutputDir, \".classpath\" ) );\n\n        assertFileEquals( localRepository.getBasedir(), new File( basedir, \"wtpmodules\" ),\n                          new File( projectOutputDir, \".wtpmodules\" ) );\n\n        if ( new File( basedir, \"settings\" ).exists() )\n        {\n            assertFileEquals( localRepository.getBasedir(), new File( basedir, \"settings\" ),\n                              new File( basedir, \".settings/org.eclipse.jdt.core.prefs\" ) );\n        }\n    }","commit_id":"0c41d88abb4adce73c12081b146b4bd8f3f37257","url":"https://github.com/apache/maven-plugins"},{"original_method":"public static EclipseSourceDir[] buildDirectoryList( MavenProject project, File basedir, Log log )\n    {\n        File projectBaseDir = project.getFile().getParentFile();\n\n        // avoid duplicated entries\n        Set directories = new TreeSet();\n\n        EclipseUtils.extractSourceDirs( directories, project.getCompileSourceRoots(), basedir, projectBaseDir, false, null );\n\n        EclipseUtils.extractResourceDirs( directories, project.getBuild().getResources(), project, basedir, projectBaseDir, false,\n                             null, log );\n\n        EclipseUtils.extractSourceDirs( directories, project.getTestCompileSourceRoots(), basedir, projectBaseDir, true,\n                           EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, project.getBuild()\n                               .getTestOutputDirectory(), false ) );\n\n        EclipseUtils.extractResourceDirs( directories, project.getBuild().getTestResources(), project, basedir, projectBaseDir,\n                             true, EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, project.getBuild()\n                                 .getTestOutputDirectory(), false ), log );\n\n        return (EclipseSourceDir[]) directories.toArray( new EclipseSourceDir[directories.size()] );\n    }","id":44148,"modified_method":"public static EclipseSourceDir[] buildDirectoryList( MavenProject project, File basedir, Log log, String outputDirectory )\n    {\n        File projectBaseDir = project.getFile().getParentFile();\n\n        // avoid duplicated entries\n        Set directories = new TreeSet();\n\n        EclipseUtils.extractSourceDirs( directories, project.getCompileSourceRoots(), basedir, projectBaseDir, false, null );\n\n        EclipseUtils.extractResourceDirs( directories, project.getBuild().getResources(), project, basedir, projectBaseDir, false,\n                             null, log );\n\n        // If using the standard output location, don't mix the test output into it.\n        String testOutput = outputDirectory.equals( project.getBuild().getOutputDirectory() ) ?  \n                EclipseUtils.toRelativeAndFixSeparator( projectBaseDir, project.getBuild().getTestOutputDirectory(), false ) :\n                null;\n        \n        EclipseUtils.extractSourceDirs( directories, project.getTestCompileSourceRoots(), basedir, projectBaseDir, true,\n                testOutput );\n\n        EclipseUtils.extractResourceDirs( directories, project.getBuild().getTestResources(), project, basedir, projectBaseDir,\n                             true, testOutput, log );\n\n        return (EclipseSourceDir[]) directories.toArray( new EclipseSourceDir[directories.size()] );\n    }","commit_id":"0c41d88abb4adce73c12081b146b4bd8f3f37257","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void transferSucceeded( TransferEvent event )\n    {\n        TransferResource artifact = event.getResource();\n        long contentLength = event.getTransferredBytes();\n        if ( contentLength >= 0 )\n        {\n            String type = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" );\n            String len = contentLength >= 1024 ? toKB( contentLength ) + \" KB\" : contentLength + \" B\";\n\n            String throughput = \"\";\n            long duration = System.currentTimeMillis() - artifact.getTransferStartTime();\n            if ( duration > 0 )\n            {\n                DecimalFormat format = new DecimalFormat( \"0.0\", new DecimalFormatSymbols( Locale.ENGLISH ) );\n                double kbPerSec = ( contentLength / 1024.0 ) / ( duration / 1000.0 );\n                throughput = \" at \" + format.format( kbPerSec ) + \" KB/sec\";\n            }\n\n            out.println( type + \": \" + artifact.getRepositoryUrl() + artifact.getResourceName() + \" (\" + len\n                + throughput + \")\" );\n        }\n    }","id":44149,"modified_method":"public void transferSucceeded( TransferEvent event )\n    {\n        TransferResource resource = event.getResource();\n        long contentLength = event.getTransferredBytes();\n        if ( contentLength >= 0 )\n        {\n            String type = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" );\n            String len = contentLength >= 1024 ? toKB( contentLength ) + \" KB\" : contentLength + \" B\";\n\n            String throughput = \"\";\n            long duration = System.currentTimeMillis() - resource.getTransferStartTime();\n            if ( duration > 0 )\n            {\n                DecimalFormat format = new DecimalFormat( \"0.0\", new DecimalFormatSymbols( Locale.ENGLISH ) );\n                double kbPerSec = ( contentLength / 1024.0 ) / ( duration / 1000.0 );\n                throughput = \" at \" + format.format( kbPerSec ) + \" KB/sec\";\n            }\n\n            out.println( type + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len\n                + throughput + \")\" );\n        }\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private Model loadPom( RepositorySystemSession session, ArtifactDescriptorRequest request,\n                           ArtifactDescriptorResult result )\n        throws ArtifactDescriptorException\n    {\n        Set<String> visited = new LinkedHashSet<String>();\n        for ( Artifact artifact = request.getArtifact();; )\n        {\n            try\n            {\n                VersionRequest versionRequest =\n                    new VersionRequest( artifact, request.getRepositories(), request.getRequestContext() );\n                versionResolver.resolveVersion( session, versionRequest );\n            }\n            catch ( VersionResolutionException e )\n            {\n                result.addException( e );\n                throw new ArtifactDescriptorException( result );\n            }\n\n            if ( !visited.add( artifact.getGroupId() + ':' + artifact.getArtifactId() + ':' + artifact.getBaseVersion() ) )\n            {\n                RepositoryException exception =\n                    new RepositoryException( \"Artifact relocations form a cycle: \" + visited );\n                invalidDescriptor( session, artifact, exception );\n                if ( session.isIgnoreInvalidArtifactDescriptor() )\n                {\n                    return null;\n                }\n                result.addException( exception );\n                throw new ArtifactDescriptorException( result );\n            }\n\n            Artifact pomArtifact = artifact;\n            if ( pomArtifact.getClassifier().length() > 0 || !\"pom\".equals( pomArtifact.getExtension() ) )\n            {\n                pomArtifact = new SubArtifact( artifact, \"\", \"pom\" );\n            }\n\n            ArtifactResult resolveResult;\n            try\n            {\n                ArtifactRequest resolveRequest =\n                    new ArtifactRequest( pomArtifact, request.getRepositories(), request.getRequestContext() );\n                resolveResult = artifactResolver.resolveArtifact( session, resolveRequest );\n                pomArtifact = resolveResult.getArtifact();\n                result.setRepository( resolveResult.getRepository() );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                if ( e.getCause() instanceof ArtifactNotFoundException )\n                {\n                    missingDescriptor( session, artifact );\n                    if ( session.isIgnoreMissingArtifactDescriptor() )\n                    {\n                        return null;\n                    }\n                }\n                result.addException( e );\n                throw new ArtifactDescriptorException( result );\n            }\n\n            Model model;\n            try\n            {\n                ModelBuildingRequest modelRequest = new DefaultModelBuildingRequest();\n                modelRequest.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL );\n                modelRequest.setProcessPlugins( false );\n                modelRequest.setTwoPhaseBuilding( false );\n                modelRequest.setSystemProperties( toProperties( session.getSystemProperties() ) );\n                modelRequest.setUserProperties( toProperties( session.getUserProperties() ) );\n                modelRequest.setModelCache( DefaultModelCache.newInstance( session ) );\n                modelRequest.setModelResolver( new DefaultModelResolver( session, request.getRequestContext(),\n                                                                         artifactResolver, remoteRepositoryManager,\n                                                                         request.getRepositories() ) );\n                if ( resolveResult.getRepository() instanceof WorkspaceRepository )\n                {\n                    modelRequest.setPomFile( pomArtifact.getFile() );\n                }\n                else\n                {\n                    modelRequest.setModelSource( new FileModelSource( pomArtifact.getFile() ) );\n                }\n\n                model = modelBuilder.build( modelRequest ).getEffectiveModel();\n            }\n            catch ( ModelBuildingException e )\n            {\n                for ( ModelProblem problem : e.getProblems() )\n                {\n                    if ( problem.getException() instanceof UnresolvableModelException )\n                    {\n                        result.addException( problem.getException() );\n                        throw new ArtifactDescriptorException( result );\n                    }\n                }\n                invalidDescriptor( session, artifact, e );\n                if ( session.isIgnoreInvalidArtifactDescriptor() )\n                {\n                    return null;\n                }\n                result.addException( e );\n                throw new ArtifactDescriptorException( result );\n            }\n\n            Relocation relocation = getRelocation( model );\n\n            if ( relocation != null )\n            {\n                result.addRelocation( artifact );\n                artifact =\n                    new RelocatedArtifact( artifact, relocation.getGroupId(), relocation.getArtifactId(),\n                                           relocation.getVersion() );\n                result.setArtifact( artifact );\n            }\n            else\n            {\n                return model;\n            }\n        }\n    }","id":44150,"modified_method":"private Model loadPom( RepositorySystemSession session, ArtifactDescriptorRequest request,\n                           ArtifactDescriptorResult result )\n        throws ArtifactDescriptorException\n    {\n        Set<String> visited = new LinkedHashSet<String>();\n        for ( Artifact artifact = request.getArtifact();; )\n        {\n            try\n            {\n                VersionRequest versionRequest =\n                    new VersionRequest( artifact, request.getRepositories(), request.getRequestContext() );\n                VersionResult versionResult = versionResolver.resolveVersion( session, versionRequest );\n\n                artifact = artifact.setVersion( versionResult.getVersion() );\n            }\n            catch ( VersionResolutionException e )\n            {\n                result.addException( e );\n                throw new ArtifactDescriptorException( result );\n            }\n\n            if ( !visited.add( artifact.getGroupId() + ':' + artifact.getArtifactId() + ':' + artifact.getBaseVersion() ) )\n            {\n                RepositoryException exception =\n                    new RepositoryException( \"Artifact relocations form a cycle: \" + visited );\n                invalidDescriptor( session, artifact, exception );\n                if ( session.isIgnoreInvalidArtifactDescriptor() )\n                {\n                    return null;\n                }\n                result.addException( exception );\n                throw new ArtifactDescriptorException( result );\n            }\n\n            Artifact pomArtifact = artifact;\n            if ( pomArtifact.getClassifier().length() > 0 || !\"pom\".equals( pomArtifact.getExtension() ) )\n            {\n                pomArtifact = new SubArtifact( artifact, \"\", \"pom\" );\n            }\n\n            ArtifactResult resolveResult;\n            try\n            {\n                ArtifactRequest resolveRequest =\n                    new ArtifactRequest( pomArtifact, request.getRepositories(), request.getRequestContext() );\n                resolveResult = artifactResolver.resolveArtifact( session, resolveRequest );\n                pomArtifact = resolveResult.getArtifact();\n                result.setRepository( resolveResult.getRepository() );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                if ( e.getCause() instanceof ArtifactNotFoundException )\n                {\n                    missingDescriptor( session, artifact );\n                    if ( session.isIgnoreMissingArtifactDescriptor() )\n                    {\n                        return null;\n                    }\n                }\n                result.addException( e );\n                throw new ArtifactDescriptorException( result );\n            }\n\n            Model model;\n            try\n            {\n                ModelBuildingRequest modelRequest = new DefaultModelBuildingRequest();\n                modelRequest.setValidationLevel( ModelBuildingRequest.VALIDATION_LEVEL_MINIMAL );\n                modelRequest.setProcessPlugins( false );\n                modelRequest.setTwoPhaseBuilding( false );\n                modelRequest.setSystemProperties( toProperties( session.getSystemProperties() ) );\n                modelRequest.setUserProperties( toProperties( session.getUserProperties() ) );\n                modelRequest.setModelCache( DefaultModelCache.newInstance( session ) );\n                modelRequest.setModelResolver( new DefaultModelResolver( session, request.getRequestContext(),\n                                                                         artifactResolver, remoteRepositoryManager,\n                                                                         request.getRepositories() ) );\n                if ( resolveResult.getRepository() instanceof WorkspaceRepository )\n                {\n                    modelRequest.setPomFile( pomArtifact.getFile() );\n                }\n                else\n                {\n                    modelRequest.setModelSource( new FileModelSource( pomArtifact.getFile() ) );\n                }\n\n                model = modelBuilder.build( modelRequest ).getEffectiveModel();\n            }\n            catch ( ModelBuildingException e )\n            {\n                for ( ModelProblem problem : e.getProblems() )\n                {\n                    if ( problem.getException() instanceof UnresolvableModelException )\n                    {\n                        result.addException( problem.getException() );\n                        throw new ArtifactDescriptorException( result );\n                    }\n                }\n                invalidDescriptor( session, artifact, e );\n                if ( session.isIgnoreInvalidArtifactDescriptor() )\n                {\n                    return null;\n                }\n                result.addException( e );\n                throw new ArtifactDescriptorException( result );\n            }\n\n            Relocation relocation = getRelocation( model );\n\n            if ( relocation != null )\n            {\n                result.addRelocation( artifact );\n                artifact =\n                    new RelocatedArtifact( artifact, relocation.getGroupId(), relocation.getArtifactId(),\n                                           relocation.getVersion() );\n                result.setArtifact( artifact );\n            }\n            else\n            {\n                return model;\n            }\n        }\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"public RepositorySystemSession newRepositorySession( MavenExecutionRequest request )\n    {\n        DefaultRepositorySystemSession session = new DefaultRepositorySystemSession();\n\n        session.setCache( request.getRepositoryCache() );\n\n        session.setIgnoreInvalidArtifactDescriptor( true ).setIgnoreMissingArtifactDescriptor( true );\n\n        session.setUserProps( request.getUserProperties() );\n        session.setSystemProps( request.getSystemProperties() );\n        Map<Object, Object> configProps = new LinkedHashMap<Object, Object>();\n        configProps.put( ConfigurationProperties.USER_AGENT, getUserAgent() );\n        configProps.put( ConfigurationProperties.INTERACTIVE, Boolean.valueOf( request.isInteractiveMode() ) );\n        configProps.putAll( request.getSystemProperties() );\n        configProps.putAll( request.getUserProperties() );\n        session.setConfigProps( configProps );\n\n        session.setOffline( request.isOffline() );\n        session.setChecksumPolicy( request.getGlobalChecksumPolicy() );\n        session.setUpdatePolicy( request.isUpdateSnapshots() ? RepositoryPolicy.UPDATE_POLICY_ALWAYS : null );\n\n        session.setNotFoundCachingEnabled( request.isCacheNotFound() );\n        session.setTransferErrorCachingEnabled( request.isCacheTransferError() );\n\n        session.setArtifactTypeRegistry( RepositoryUtils.newArtifactTypeRegistry( artifactHandlerManager ) );\n\n        LocalRepository localRepo = new LocalRepository( request.getLocalRepository().getBasedir() );\n        session.setLocalRepositoryManager( repoSystem.newLocalRepositoryManager( localRepo ) );\n\n        if ( request.getWorkspaceReader() != null )\n        {\n            session.setWorkspaceReader( request.getWorkspaceReader() );\n        }\n        else\n        {\n            session.setWorkspaceReader( workspaceRepository );\n        }\n\n        DefaultSettingsDecryptionRequest decrypt = new DefaultSettingsDecryptionRequest();\n        decrypt.setProxies( request.getProxies() );\n        decrypt.setServers( request.getServers() );\n        SettingsDecryptionResult decrypted = settingsDecrypter.decrypt( decrypt );\n\n        if ( logger.isDebugEnabled() )\n        {\n            for ( SettingsProblem problem : decrypted.getProblems() )\n            {\n                logger.debug( problem.getMessage(), problem.getException() );\n            }\n        }\n\n        DefaultMirrorSelector mirrorSelector = new DefaultMirrorSelector();\n        for ( Mirror mirror : request.getMirrors() )\n        {\n            mirrorSelector.add( mirror.getId(), mirror.getUrl(), mirror.getLayout(), false, mirror.getMirrorOf(),\n                                mirror.getMirrorOfLayouts() );\n        }\n        session.setMirrorSelector( mirrorSelector );\n\n        DefaultProxySelector proxySelector = new DefaultProxySelector();\n        for ( Proxy proxy : decrypted.getProxies() )\n        {\n            Authentication proxyAuth = new Authentication( proxy.getUsername(), proxy.getPassword() );\n            proxySelector.add( new org.sonatype.aether.repository.Proxy( proxy.getProtocol(), proxy.getHost(), proxy.getPort(),\n                                                                proxyAuth ), proxy.getNonProxyHosts() );\n        }\n        session.setProxySelector( proxySelector );\n\n        DefaultAuthenticationSelector authSelector = new DefaultAuthenticationSelector();\n        for ( Server server : decrypted.getServers() )\n        {\n            Authentication auth =\n                new Authentication( server.getUsername(), server.getPassword(), server.getPrivateKey(),\n                                    server.getPassphrase() );\n            authSelector.add( server.getId(), auth );\n        }\n        session.setAuthenticationSelector( authSelector );\n\n        DependencyTraverser depTraverser = new FatArtifactTraverser();\n        session.setDependencyTraverser( depTraverser );\n\n        DependencyManager depManager = new ClassicDependencyManager();\n        session.setDependencyManager( depManager );\n\n        DependencySelector depFilter =\n            new AndDependencySelector( new ScopeDependencySelector( \"test\", \"provided\" ), new OptionalDependencySelector(),\n                                     new ExclusionDependencySelector() );\n        session.setDependencySelector( depFilter );\n\n        DependencyGraphTransformer transformer =\n            new ChainedDependencyGraphTransformer( new ConflictMarker(), new JavaEffectiveScopeCalculator(),\n                                                   new NearestVersionConflictResolver(),\n                                                   new JavaDependencyContextRefiner() );\n        session.setDependencyGraphTransformer( transformer );\n\n        session.setTransferListener( request.getTransferListener() );\n\n        session.setRepositoryListener( new AbstractRepositoryListener()\n        {\n            @Override\n            public void artifactInstalling( RepositoryEvent event )\n            {\n                logger.info( \"Installing \" + event.getArtifact().getFile() + \" to \" + event.getFile() );\n            }\n\n            @Override\n            public void metadataInstalling( RepositoryEvent event )\n            {\n                logger.debug( \"Installing \" + event.getMetadata() + \" to \" + event.getFile() );\n            }\n\n            @Override\n            public void artifactDescriptorInvalid( RepositoryEvent event )\n            {\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.warn( \"The POM for \" + event.getArtifact() + \" is invalid\"\n                        + \", transitive dependencies (if any) will not be available: \"\n                        + event.getException().getMessage() );\n                }\n                else\n                {\n                    logger.warn( \"The POM for \" + event.getArtifact() + \" is invalid\"\n                        + \", transitive dependencies (if any) will not be available\"\n                        + \", enable debug logging for more details\" );\n                }\n            }\n\n            @Override\n            public void artifactDescriptorMissing( RepositoryEvent event )\n            {\n                logger.warn( \"The POM for \" + event.getArtifact() + \" is missing, no dependency information available\" );\n            }\n        } );\n\n        return session;\n    }","id":44151,"modified_method":"public RepositorySystemSession newRepositorySession( MavenExecutionRequest request )\n    {\n        DefaultRepositorySystemSession session = new DefaultRepositorySystemSession();\n\n        session.setCache( request.getRepositoryCache() );\n\n        session.setIgnoreInvalidArtifactDescriptor( true ).setIgnoreMissingArtifactDescriptor( true );\n\n        session.setUserProps( request.getUserProperties() );\n        session.setSystemProps( request.getSystemProperties() );\n        Map<Object, Object> configProps = new LinkedHashMap<Object, Object>();\n        configProps.put( ConfigurationProperties.USER_AGENT, getUserAgent() );\n        configProps.put( ConfigurationProperties.INTERACTIVE, Boolean.valueOf( request.isInteractiveMode() ) );\n        configProps.putAll( request.getSystemProperties() );\n        configProps.putAll( request.getUserProperties() );\n        session.setConfigProps( configProps );\n\n        session.setOffline( request.isOffline() );\n        session.setChecksumPolicy( request.getGlobalChecksumPolicy() );\n        session.setUpdatePolicy( request.isUpdateSnapshots() ? RepositoryPolicy.UPDATE_POLICY_ALWAYS : null );\n\n        session.setNotFoundCachingEnabled( request.isCacheNotFound() );\n        session.setTransferErrorCachingEnabled( request.isCacheTransferError() );\n\n        session.setArtifactTypeRegistry( RepositoryUtils.newArtifactTypeRegistry( artifactHandlerManager ) );\n\n        LocalRepository localRepo = new LocalRepository( request.getLocalRepository().getBasedir() );\n        session.setLocalRepositoryManager( repoSystem.newLocalRepositoryManager( localRepo ) );\n\n        if ( request.getWorkspaceReader() != null )\n        {\n            session.setWorkspaceReader( request.getWorkspaceReader() );\n        }\n        else\n        {\n            session.setWorkspaceReader( workspaceRepository );\n        }\n\n        DefaultSettingsDecryptionRequest decrypt = new DefaultSettingsDecryptionRequest();\n        decrypt.setProxies( request.getProxies() );\n        decrypt.setServers( request.getServers() );\n        SettingsDecryptionResult decrypted = settingsDecrypter.decrypt( decrypt );\n\n        if ( logger.isDebugEnabled() )\n        {\n            for ( SettingsProblem problem : decrypted.getProblems() )\n            {\n                logger.debug( problem.getMessage(), problem.getException() );\n            }\n        }\n\n        DefaultMirrorSelector mirrorSelector = new DefaultMirrorSelector();\n        for ( Mirror mirror : request.getMirrors() )\n        {\n            mirrorSelector.add( mirror.getId(), mirror.getUrl(), mirror.getLayout(), false, mirror.getMirrorOf(),\n                                mirror.getMirrorOfLayouts() );\n        }\n        session.setMirrorSelector( mirrorSelector );\n\n        DefaultProxySelector proxySelector = new DefaultProxySelector();\n        for ( Proxy proxy : decrypted.getProxies() )\n        {\n            Authentication proxyAuth = new Authentication( proxy.getUsername(), proxy.getPassword() );\n            proxySelector.add( new org.sonatype.aether.repository.Proxy( proxy.getProtocol(), proxy.getHost(), proxy.getPort(),\n                                                                proxyAuth ), proxy.getNonProxyHosts() );\n        }\n        session.setProxySelector( proxySelector );\n\n        DefaultAuthenticationSelector authSelector = new DefaultAuthenticationSelector();\n        for ( Server server : decrypted.getServers() )\n        {\n            Authentication auth =\n                new Authentication( server.getUsername(), server.getPassword(), server.getPrivateKey(),\n                                    server.getPassphrase() );\n            authSelector.add( server.getId(), auth );\n        }\n        session.setAuthenticationSelector( authSelector );\n\n        DependencyTraverser depTraverser = new FatArtifactTraverser();\n        session.setDependencyTraverser( depTraverser );\n\n        DependencyManager depManager = new ClassicDependencyManager();\n        session.setDependencyManager( depManager );\n\n        DependencySelector depFilter =\n            new AndDependencySelector( new ScopeDependencySelector( \"test\", \"provided\" ), new OptionalDependencySelector(),\n                                     new ExclusionDependencySelector() );\n        session.setDependencySelector( depFilter );\n\n        DependencyGraphTransformer transformer =\n            new ChainedDependencyGraphTransformer( new ConflictMarker(), new JavaEffectiveScopeCalculator(),\n                                                   new NearestVersionConflictResolver(),\n                                                   new JavaDependencyContextRefiner() );\n        session.setDependencyGraphTransformer( transformer );\n\n        session.setTransferListener( request.getTransferListener() );\n\n        session.setRepositoryListener( new LoggingRepositoryListener( logger ) );\n\n        return session;\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private PluginPrefixResult processResults( PluginPrefixRequest request, List<MetadataResult> results,\n                                               List<MetadataRequest> requests )\n    {\n        for ( MetadataResult res : results )\n        {\n            if ( res.getException() != null )\n            {\n                if ( res.getException() instanceof MetadataNotFoundException )\n                {\n                    logger.debug( \"Could not find \" + res.getRequest().getMetadata() + \" in \"\n                        + res.getRequest().getRepository() );\n                }\n                else if ( logger.isDebugEnabled() )\n                {\n                    logger.warn( \"Could not retrieve \" + res.getRequest().getMetadata() + \" from \"\n                        + res.getRequest().getRepository() + \": \" + res.getException().getMessage(), res.getException() );\n                }\n                else\n                {\n                    logger.warn( \"Could not retrieve \" + res.getRequest().getMetadata() + \" from \"\n                        + res.getRequest().getRepository() + \": \" + res.getException().getMessage() );\n                }\n            }\n\n            org.sonatype.aether.metadata.Metadata metadata = res.getMetadata();\n\n            if ( metadata != null )\n            {\n                ArtifactRepository repository = res.getRequest().getRepository();\n                if ( repository == null )\n                {\n                    repository = request.getRepositorySession().getLocalRepository();\n                }\n\n                PluginPrefixResult result =\n                    resolveFromRepository( request, metadata.getGroupId(), metadata.getFile(), repository );\n\n                if ( result != null )\n                {\n                    return result;\n                }\n            }\n\n            if ( requests != null && !res.isUpdated() )\n            {\n                requests.add( res.getRequest() );\n            }\n        }\n\n        return null;\n    }","id":44152,"modified_method":"private PluginPrefixResult processResults( PluginPrefixRequest request, List<MetadataResult> results,\n                                               List<MetadataRequest> requests )\n    {\n        for ( MetadataResult res : results )\n        {\n            org.sonatype.aether.metadata.Metadata metadata = res.getMetadata();\n\n            if ( metadata != null )\n            {\n                ArtifactRepository repository = res.getRequest().getRepository();\n                if ( repository == null )\n                {\n                    repository = request.getRepositorySession().getLocalRepository();\n                }\n\n                PluginPrefixResult result =\n                    resolveFromRepository( request, metadata.getGroupId(), metadata, repository );\n\n                if ( result != null )\n                {\n                    return result;\n                }\n            }\n\n            if ( requests != null && !res.isUpdated() )\n            {\n                requests.add( res.getRequest() );\n            }\n        }\n\n        return null;\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private PluginPrefixResult resolveFromRepository( PluginPrefixRequest request, String pluginGroup,\n                                                      File metadataFile, ArtifactRepository repository )\n    {\n        if ( metadataFile != null && metadataFile.isFile() )\n        {\n            try\n            {\n                Map<String, ?> options = Collections.singletonMap( MetadataReader.IS_STRICT, Boolean.FALSE );\n\n                Metadata pluginGroupMetadata = metadataReader.read( metadataFile, options );\n\n                List<org.apache.maven.artifact.repository.metadata.Plugin> plugins = pluginGroupMetadata.getPlugins();\n\n                if ( plugins != null )\n                {\n                    for ( org.apache.maven.artifact.repository.metadata.Plugin plugin : plugins )\n                    {\n                        if ( request.getPrefix().equals( plugin.getPrefix() ) )\n                        {\n                            return new DefaultPluginPrefixResult( pluginGroup, plugin.getArtifactId(), repository );\n                        }\n                    }\n                }\n            }\n            catch ( IOException e )\n            {\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.warn( \"Error reading plugin group metadata: \" + e.getMessage(), e );\n                }\n                else\n                {\n                    logger.warn( \"Error reading plugin group metadata: \" + e.getMessage() );\n                }\n            }\n        }\n\n        return null;\n    }","id":44153,"modified_method":"private PluginPrefixResult resolveFromRepository( PluginPrefixRequest request, String pluginGroup,\n                                                      org.sonatype.aether.metadata.Metadata metadata,\n                                                      ArtifactRepository repository )\n    {\n        if ( metadata != null && metadata.getFile() != null && metadata.getFile().isFile() )\n        {\n            try\n            {\n                Map<String, ?> options = Collections.singletonMap( MetadataReader.IS_STRICT, Boolean.FALSE );\n\n                Metadata pluginGroupMetadata = metadataReader.read( metadata.getFile(), options );\n\n                List<org.apache.maven.artifact.repository.metadata.Plugin> plugins = pluginGroupMetadata.getPlugins();\n\n                if ( plugins != null )\n                {\n                    for ( org.apache.maven.artifact.repository.metadata.Plugin plugin : plugins )\n                    {\n                        if ( request.getPrefix().equals( plugin.getPrefix() ) )\n                        {\n                            return new DefaultPluginPrefixResult( pluginGroup, plugin.getArtifactId(), repository );\n                        }\n                    }\n                }\n            }\n            catch ( IOException e )\n            {\n                invalidMetadata( request.getRepositorySession(), metadata, repository, e );\n            }\n        }\n\n        return null;\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private void mergeMetadata( Versions versions, File metadataFile, ArtifactRepository repository )\n    {\n        if ( metadataFile != null && metadataFile.isFile() )\n        {\n            try\n            {\n                Map<String, ?> options = Collections.singletonMap( MetadataReader.IS_STRICT, Boolean.FALSE );\n\n                Metadata repoMetadata = metadataReader.read( metadataFile, options );\n\n                mergeMetadata( versions, repoMetadata, repository );\n            }\n            catch ( IOException e )\n            {\n                if ( logger.isDebugEnabled() )\n                {\n                    logger.warn( \"Failed to read metadata \" + metadataFile + \": \" + e.getMessage(), e );\n                }\n                else\n                {\n                    logger.warn( \"Failed to read metadata \" + metadataFile + \": \" + e.getMessage() );\n                }\n            }\n        }\n    }","id":44154,"modified_method":"private void mergeMetadata( RepositorySystemSession session, Versions versions,\n                                org.sonatype.aether.metadata.Metadata metadata, ArtifactRepository repository )\n    {\n        if ( metadata != null && metadata.getFile() != null && metadata.getFile().isFile() )\n        {\n            try\n            {\n                Map<String, ?> options = Collections.singletonMap( MetadataReader.IS_STRICT, Boolean.FALSE );\n\n                Metadata repoMetadata = metadataReader.read( metadata.getFile(), options );\n\n                mergeMetadata( versions, repoMetadata, repository );\n            }\n            catch ( IOException e )\n            {\n                invalidMetadata( session, metadata, repository, e );\n            }\n        }\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private PluginVersionResult resolveFromRepository( PluginVersionRequest request )\n        throws PluginVersionResolutionException\n    {\n        DefaultPluginVersionResult result = new DefaultPluginVersionResult();\n\n        org.sonatype.aether.metadata.Metadata metadata =\n            new DefaultMetadata( request.getGroupId(), request.getArtifactId(), \"maven-metadata.xml\",\n                                 DefaultMetadata.Nature.RELEASE_OR_SNAPSHOT );\n\n        List<MetadataRequest> requests = new ArrayList<MetadataRequest>();\n\n        requests.add( new MetadataRequest( metadata, null, REPOSITORY_CONTEXT ) );\n\n        for ( RemoteRepository repository : request.getRepositories() )\n        {\n            requests.add( new MetadataRequest( metadata, repository, REPOSITORY_CONTEXT ) );\n        }\n\n        List<MetadataResult> results = repositorySystem.resolveMetadata( request.getRepositorySession(), requests );\n\n        LocalRepository localRepo = request.getRepositorySession().getLocalRepository();\n\n        Versions versions = new Versions();\n\n        for ( MetadataResult res : results )\n        {\n            if ( res.getException() != null )\n            {\n                if ( res.getException() instanceof MetadataNotFoundException )\n                {\n                    logger.debug( \"Could not find \" + res.getRequest().getMetadata() + \" in \"\n                        + res.getRequest().getRepository() );\n                }\n                else if ( logger.isDebugEnabled() )\n                {\n                    logger.warn( \"Could not retrieve \" + res.getRequest().getMetadata() + \" from \"\n                        + res.getRequest().getRepository() + \": \" + res.getException().getMessage(), res.getException() );\n                }\n                else\n                {\n                    logger.warn( \"Could not retrieve \" + res.getRequest().getMetadata() + \" from \"\n                        + res.getRequest().getRepository() + \": \" + res.getException().getMessage() );\n                }\n            }\n\n            if ( res.getMetadata() != null )\n            {\n                mergeMetadata( versions, res.getMetadata().getFile(), res.getRequest().getRepository() );\n            }\n        }\n\n        if ( StringUtils.isNotEmpty( versions.releaseVersion ) )\n        {\n            result.setVersion( versions.releaseVersion );\n            result.setRepository( ( versions.releaseRepository == null ) ? localRepo : versions.releaseRepository );\n        }\n        else if ( StringUtils.isNotEmpty( versions.latestVersion ) )\n        {\n            result.setVersion( versions.latestVersion );\n            result.setRepository( ( versions.latestRepository == null ) ? localRepo : versions.latestRepository );\n        }\n        else\n        {\n            throw new PluginVersionResolutionException( request.getGroupId(), request.getArtifactId(), localRepo,\n                                                        request.getRepositories(),\n                                                        \"Plugin not found in any plugin repository\" );\n        }\n\n        return result;\n    }","id":44155,"modified_method":"private PluginVersionResult resolveFromRepository( PluginVersionRequest request )\n        throws PluginVersionResolutionException\n    {\n        DefaultPluginVersionResult result = new DefaultPluginVersionResult();\n\n        org.sonatype.aether.metadata.Metadata metadata =\n            new DefaultMetadata( request.getGroupId(), request.getArtifactId(), \"maven-metadata.xml\",\n                                 DefaultMetadata.Nature.RELEASE_OR_SNAPSHOT );\n\n        List<MetadataRequest> requests = new ArrayList<MetadataRequest>();\n\n        requests.add( new MetadataRequest( metadata, null, REPOSITORY_CONTEXT ) );\n\n        for ( RemoteRepository repository : request.getRepositories() )\n        {\n            requests.add( new MetadataRequest( metadata, repository, REPOSITORY_CONTEXT ) );\n        }\n\n        List<MetadataResult> results = repositorySystem.resolveMetadata( request.getRepositorySession(), requests );\n\n        LocalRepository localRepo = request.getRepositorySession().getLocalRepository();\n\n        Versions versions = new Versions();\n\n        for ( MetadataResult res : results )\n        {\n            ArtifactRepository repository = res.getRequest().getRepository();\n            if ( repository == null )\n            {\n                repository = request.getRepositorySession().getLocalRepository();\n            }\n\n            mergeMetadata( request.getRepositorySession(), versions, res.getMetadata(), repository );\n        }\n\n        if ( StringUtils.isNotEmpty( versions.releaseVersion ) )\n        {\n            result.setVersion( versions.releaseVersion );\n            result.setRepository( ( versions.releaseRepository == null ) ? localRepo : versions.releaseRepository );\n        }\n        else if ( StringUtils.isNotEmpty( versions.latestVersion ) )\n        {\n            result.setVersion( versions.latestVersion );\n            result.setRepository( ( versions.latestRepository == null ) ? localRepo : versions.latestRepository );\n        }\n        else\n        {\n            throw new PluginVersionResolutionException( request.getGroupId(), request.getArtifactId(), localRepo,\n                                                        request.getRepositories(),\n                                                        \"Plugin not found in any plugin repository\" );\n        }\n\n        return result;\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private void invalidMetadata( RepositorySystemSession session, Metadata metadata, Exception exception )\n    {\n        RepositoryListener listener = session.getRepositoryListener();\n        if ( listener != null )\n        {\n            DefaultRepositoryEvent event = new DefaultRepositoryEvent( session, metadata );\n            event.setException( exception );\n            listener.metadataInvalid( event );\n        }\n    }","id":44156,"modified_method":"private void invalidMetadata( RepositorySystemSession session, Metadata metadata, ArtifactRepository repository,\n                                  Exception exception )\n    {\n        RepositoryListener listener = session.getRepositoryListener();\n        if ( listener != null )\n        {\n            DefaultRepositoryEvent event = new DefaultRepositoryEvent( session, metadata );\n            event.setException( exception );\n            event.setRepository( repository );\n            listener.metadataInvalid( event );\n        }\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private Versioning readVersions( RepositorySystemSession session, Metadata metadata, VersionRangeResult result )\n    {\n        Versioning versioning = null;\n\n        FileInputStream fis = null;\n        try\n        {\n            if ( metadata != null && metadata.getFile() != null )\n            {\n                fis = new FileInputStream( metadata.getFile() );\n                org.apache.maven.artifact.repository.metadata.Metadata m = new MetadataXpp3Reader().read( fis, false );\n                versioning = m.getVersioning();\n            }\n        }\n        catch ( FileNotFoundException e )\n        {\n            // tolerable\n        }\n        catch ( Exception e )\n        {\n            invalidMetadata( session, metadata, e );\n            result.addException( e );\n        }\n        finally\n        {\n            IOUtil.close( fis );\n        }\n\n        return ( versioning != null ) ? versioning : new Versioning();\n    }","id":44157,"modified_method":"private Versioning readVersions( RepositorySystemSession session, Metadata metadata, ArtifactRepository repository,\n                                     VersionRangeResult result )\n    {\n        Versioning versioning = null;\n\n        FileInputStream fis = null;\n        try\n        {\n            if ( metadata != null && metadata.getFile() != null )\n            {\n                fis = new FileInputStream( metadata.getFile() );\n                org.apache.maven.artifact.repository.metadata.Metadata m = new MetadataXpp3Reader().read( fis, false );\n                versioning = m.getVersioning();\n            }\n        }\n        catch ( FileNotFoundException e )\n        {\n            // tolerable\n        }\n        catch ( Exception e )\n        {\n            invalidMetadata( session, metadata, repository, e );\n            result.addException( e );\n        }\n        finally\n        {\n            IOUtil.close( fis );\n        }\n\n        return ( versioning != null ) ? versioning : new Versioning();\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private Map<String, ArtifactRepository> getVersions( RepositorySystemSession session, VersionRangeResult result,\n                                                         VersionRangeRequest request )\n    {\n        Map<String, ArtifactRepository> versionIndex = new HashMap<String, ArtifactRepository>();\n\n        Metadata metadata =\n            new DefaultMetadata( request.getArtifact().getGroupId(), request.getArtifact().getArtifactId(),\n                                 MAVEN_METADATA_XML, Metadata.Nature.RELEASE_OR_SNAPSHOT );\n\n        List<MetadataRequest> metadataRequests = new ArrayList<MetadataRequest>( request.getRepositories().size() );\n        for ( RemoteRepository repository : request.getRepositories() )\n        {\n            MetadataRequest metadataRequest = new MetadataRequest( metadata, repository, request.getRequestContext() );\n            metadataRequest.setDeleteLocalCopyIfMissing( true );\n            metadataRequests.add( metadataRequest );\n        }\n        List<MetadataResult> metadataResults = metadataResolver.resolveMetadata( session, metadataRequests );\n\n        WorkspaceReader workspace = session.getWorkspaceReader();\n        if ( workspace != null )\n        {\n            List<String> versions = workspace.findVersions( request.getArtifact() );\n            for ( String version : versions )\n            {\n                versionIndex.put( version, workspace.getRepository() );\n            }\n        }\n\n        LocalRepositoryManager lrm = session.getLocalRepositoryManager();\n        File localMetadataFile = new File( lrm.getRepository().getBasedir(), lrm.getPathForLocalMetadata( metadata ) );\n        if ( localMetadataFile.isFile() )\n        {\n            metadata = metadata.setFile( localMetadataFile );\n            Versioning versioning = readVersions( session, metadata, result );\n            for ( String version : versioning.getVersions() )\n            {\n                if ( !versionIndex.containsKey( version ) )\n                {\n                    versionIndex.put( version, lrm.getRepository() );\n                }\n            }\n        }\n\n        for ( MetadataResult metadataResult : metadataResults )\n        {\n            result.addException( metadataResult.getException() );\n            Versioning versioning = readVersions( session, metadataResult.getMetadata(), result );\n            for ( String version : versioning.getVersions() )\n            {\n                if ( !versionIndex.containsKey( version ) )\n                {\n                    versionIndex.put( version, metadataResult.getRequest().getRepository() );\n                }\n            }\n        }\n\n        return versionIndex;\n    }","id":44158,"modified_method":"private Map<String, ArtifactRepository> getVersions( RepositorySystemSession session, VersionRangeResult result,\n                                                         VersionRangeRequest request )\n    {\n        Map<String, ArtifactRepository> versionIndex = new HashMap<String, ArtifactRepository>();\n\n        Metadata metadata =\n            new DefaultMetadata( request.getArtifact().getGroupId(), request.getArtifact().getArtifactId(),\n                                 MAVEN_METADATA_XML, Metadata.Nature.RELEASE_OR_SNAPSHOT );\n\n        List<MetadataRequest> metadataRequests = new ArrayList<MetadataRequest>( request.getRepositories().size() );\n\n        metadataRequests.add( new MetadataRequest( metadata, null, request.getRequestContext() ) );\n\n        for ( RemoteRepository repository : request.getRepositories() )\n        {\n            MetadataRequest metadataRequest = new MetadataRequest( metadata, repository, request.getRequestContext() );\n            metadataRequest.setDeleteLocalCopyIfMissing( true );\n            metadataRequests.add( metadataRequest );\n        }\n\n        List<MetadataResult> metadataResults = metadataResolver.resolveMetadata( session, metadataRequests );\n\n        WorkspaceReader workspace = session.getWorkspaceReader();\n        if ( workspace != null )\n        {\n            List<String> versions = workspace.findVersions( request.getArtifact() );\n            for ( String version : versions )\n            {\n                versionIndex.put( version, workspace.getRepository() );\n            }\n        }\n\n        for ( MetadataResult metadataResult : metadataResults )\n        {\n            result.addException( metadataResult.getException() );\n\n            ArtifactRepository repository = metadataResult.getRequest().getRepository();\n            if ( repository == null )\n            {\n                repository = session.getLocalRepository();\n            }\n\n            Versioning versioning = readVersions( session, metadataResult.getMetadata(), repository, result );\n            for ( String version : versioning.getVersions() )\n            {\n                if ( !versionIndex.containsKey( version ) )\n                {\n                    versionIndex.put( version, repository );\n                }\n            }\n        }\n\n        return versionIndex;\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private Versioning readVersions( RepositorySystemSession session, Metadata metadata, VersionResult result )\n    {\n        Versioning versioning = null;\n\n        FileInputStream fis = null;\n        try\n        {\n            if ( metadata != null && metadata.getFile() != null )\n            {\n                fis = new FileInputStream( metadata.getFile() );\n                org.apache.maven.artifact.repository.metadata.Metadata m = new MetadataXpp3Reader().read( fis, false );\n                versioning = m.getVersioning();\n            }\n        }\n        catch ( FileNotFoundException e )\n        {\n            // tolerable\n        }\n        catch ( Exception e )\n        {\n            invalidMetadata( session, metadata, e );\n            result.addException( e );\n        }\n        finally\n        {\n            IOUtil.close( fis );\n        }\n\n        return ( versioning != null ) ? versioning : new Versioning();\n    }","id":44159,"modified_method":"private Versioning readVersions( RepositorySystemSession session, Metadata metadata, ArtifactRepository repository,\n                                     VersionResult result )\n    {\n        Versioning versioning = null;\n\n        FileInputStream fis = null;\n        try\n        {\n            if ( metadata != null && metadata.getFile() != null )\n            {\n                fis = new FileInputStream( metadata.getFile() );\n                org.apache.maven.artifact.repository.metadata.Metadata m = new MetadataXpp3Reader().read( fis, false );\n                versioning = m.getVersioning();\n            }\n        }\n        catch ( FileNotFoundException e )\n        {\n            // tolerable\n        }\n        catch ( Exception e )\n        {\n            invalidMetadata( session, metadata, repository, e );\n            result.addException( e );\n        }\n        finally\n        {\n            IOUtil.close( fis );\n        }\n\n        return ( versioning != null ) ? versioning : new Versioning();\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"public VersionResult resolveVersion( RepositorySystemSession session, VersionRequest request )\n        throws VersionResolutionException\n    {\n        Artifact artifact = request.getArtifact();\n\n        String version = artifact.getVersion();\n\n        VersionResult result = new VersionResult( request );\n\n        Key cacheKey = null;\n        RepositoryCache cache = session.getCache();\n        if ( cache != null && !ConfigurationProperties.get( session, \"aether.versionResolver.noCache\", false ) )\n        {\n            cacheKey = new Key( session, request );\n\n            Object obj = cache.get( session, cacheKey );\n            if ( obj instanceof Record )\n            {\n                Record record = (Record) obj;\n                result.setVersion( record.version );\n                result.setRepository( CacheUtils.getRepository( session, request.getRepositories(), record.repoClass,\n                                                                record.repoId ) );\n                return result;\n            }\n        }\n\n        Metadata metadata;\n\n        if ( RELEASE.equals( version ) )\n        {\n            metadata =\n                new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML,\n                                     Metadata.Nature.RELEASE );\n        }\n        else if ( LATEST.equals( version ) )\n        {\n            metadata =\n                new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML,\n                                     Metadata.Nature.RELEASE_OR_SNAPSHOT );\n        }\n        else if ( version.endsWith( SNAPSHOT ) )\n        {\n            WorkspaceReader workspace = session.getWorkspaceReader();\n            if ( workspace != null && workspace.findVersions( artifact ).contains( version ) )\n            {\n                metadata = null;\n                result.setRepository( workspace.getRepository() );\n            }\n            else\n            {\n                metadata =\n                    new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), version, MAVEN_METADATA_XML,\n                                         Metadata.Nature.SNAPSHOT );\n            }\n        }\n        else\n        {\n            metadata = null;\n        }\n\n        if ( metadata == null )\n        {\n            result.setVersion( version );\n        }\n        else\n        {\n            List<MetadataRequest> metadataRequests = new ArrayList<MetadataRequest>( request.getRepositories().size() );\n            for ( RemoteRepository repository : request.getRepositories() )\n            {\n                MetadataRequest metadataRequest =\n                    new MetadataRequest( metadata, repository, request.getRequestContext() );\n                metadataRequest.setDeleteLocalCopyIfMissing( true );\n                metadataRequest.setFavorLocalRepository( true );\n                metadataRequests.add( metadataRequest );\n            }\n            List<MetadataResult> metadataResults = metadataResolver.resolveMetadata( session, metadataRequests );\n\n            LocalRepositoryManager lrm = session.getLocalRepositoryManager();\n            File localMetadataFile =\n                new File( lrm.getRepository().getBasedir(), lrm.getPathForLocalMetadata( metadata ) );\n            if ( localMetadataFile.isFile() )\n            {\n                metadata = metadata.setFile( localMetadataFile );\n            }\n\n            Map<String, VersionInfo> infos = new HashMap<String, VersionInfo>();\n            merge( artifact, infos, readVersions( session, metadata, result ),\n                   session.getLocalRepositoryManager().getRepository() );\n\n            for ( MetadataResult metadataResult : metadataResults )\n            {\n                result.addException( metadataResult.getException() );\n                merge( artifact, infos, readVersions( session, metadataResult.getMetadata(), result ),\n                       metadataResult.getRequest().getRepository() );\n            }\n\n            if ( RELEASE.equals( version ) )\n            {\n                resolve( result, infos, RELEASE );\n            }\n            else if ( LATEST.equals( version ) )\n            {\n                if ( !resolve( result, infos, LATEST ) )\n                {\n                    resolve( result, infos, RELEASE );\n                }\n\n                if ( result.getVersion() != null && result.getVersion().endsWith( SNAPSHOT ) )\n                {\n                    VersionRequest subRequest = new VersionRequest();\n                    subRequest.setArtifact( artifact.setVersion( result.getVersion() ) );\n                    if ( result.getRepository() instanceof RemoteRepository )\n                    {\n                        subRequest.setRepositories( Collections.singletonList( (RemoteRepository) result.getRepository() ) );\n                    }\n                    else\n                    {\n                        subRequest.setRepositories( request.getRepositories() );\n                    }\n                    VersionResult subResult = resolveVersion( session, subRequest );\n                    result.setVersion( subResult.getVersion() );\n                    result.setRepository( subResult.getRepository() );\n                    for ( Exception exception : subResult.getExceptions() )\n                    {\n                        result.addException( exception );\n                    }\n                }\n            }\n            else\n            {\n                if ( !resolve( result, infos, SNAPSHOT + getKey( artifact.getClassifier(), artifact.getExtension() ) )\n                    && !resolve( result, infos, SNAPSHOT ) )\n                {\n                    result.setVersion( version );\n                }\n            }\n\n            if ( StringUtils.isEmpty( result.getVersion() ) )\n            {\n                throw new VersionResolutionException( result );\n            }\n        }\n\n        if ( cacheKey != null && metadata != null && isSafelyCacheable( session, artifact ) )\n        {\n            cache.put( session, cacheKey, new Record( result.getVersion(), result.getRepository() ) );\n        }\n\n        return result;\n    }","id":44160,"modified_method":"public VersionResult resolveVersion( RepositorySystemSession session, VersionRequest request )\n        throws VersionResolutionException\n    {\n        Artifact artifact = request.getArtifact();\n\n        String version = artifact.getVersion();\n\n        VersionResult result = new VersionResult( request );\n\n        Key cacheKey = null;\n        RepositoryCache cache = session.getCache();\n        if ( cache != null && !ConfigurationProperties.get( session, \"aether.versionResolver.noCache\", false ) )\n        {\n            cacheKey = new Key( session, request );\n\n            Object obj = cache.get( session, cacheKey );\n            if ( obj instanceof Record )\n            {\n                Record record = (Record) obj;\n                result.setVersion( record.version );\n                result.setRepository( CacheUtils.getRepository( session, request.getRepositories(), record.repoClass,\n                                                                record.repoId ) );\n                return result;\n            }\n        }\n\n        Metadata metadata;\n\n        if ( RELEASE.equals( version ) )\n        {\n            metadata =\n                new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML,\n                                     Metadata.Nature.RELEASE );\n        }\n        else if ( LATEST.equals( version ) )\n        {\n            metadata =\n                new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), MAVEN_METADATA_XML,\n                                     Metadata.Nature.RELEASE_OR_SNAPSHOT );\n        }\n        else if ( version.endsWith( SNAPSHOT ) )\n        {\n            WorkspaceReader workspace = session.getWorkspaceReader();\n            if ( workspace != null && workspace.findVersions( artifact ).contains( version ) )\n            {\n                metadata = null;\n                result.setRepository( workspace.getRepository() );\n            }\n            else\n            {\n                metadata =\n                    new DefaultMetadata( artifact.getGroupId(), artifact.getArtifactId(), version, MAVEN_METADATA_XML,\n                                         Metadata.Nature.SNAPSHOT );\n            }\n        }\n        else\n        {\n            metadata = null;\n        }\n\n        if ( metadata == null )\n        {\n            result.setVersion( version );\n        }\n        else\n        {\n            List<MetadataRequest> metadataRequests = new ArrayList<MetadataRequest>( request.getRepositories().size() );\n\n            metadataRequests.add( new MetadataRequest( metadata, null, request.getRequestContext() ) );\n\n            for ( RemoteRepository repository : request.getRepositories() )\n            {\n                MetadataRequest metadataRequest =\n                    new MetadataRequest( metadata, repository, request.getRequestContext() );\n                metadataRequest.setDeleteLocalCopyIfMissing( true );\n                metadataRequest.setFavorLocalRepository( true );\n                metadataRequests.add( metadataRequest );\n            }\n\n            List<MetadataResult> metadataResults = metadataResolver.resolveMetadata( session, metadataRequests );\n\n            Map<String, VersionInfo> infos = new HashMap<String, VersionInfo>();\n\n            for ( MetadataResult metadataResult : metadataResults )\n            {\n                result.addException( metadataResult.getException() );\n\n                ArtifactRepository repository = metadataResult.getRequest().getRepository();\n                if ( repository == null )\n                {\n                    repository = session.getLocalRepository();\n                }\n\n                Versioning versioning = readVersions( session, metadataResult.getMetadata(), repository, result );\n                merge( artifact, infos, versioning, repository );\n            }\n\n            if ( RELEASE.equals( version ) )\n            {\n                resolve( result, infos, RELEASE );\n            }\n            else if ( LATEST.equals( version ) )\n            {\n                if ( !resolve( result, infos, LATEST ) )\n                {\n                    resolve( result, infos, RELEASE );\n                }\n\n                if ( result.getVersion() != null && result.getVersion().endsWith( SNAPSHOT ) )\n                {\n                    VersionRequest subRequest = new VersionRequest();\n                    subRequest.setArtifact( artifact.setVersion( result.getVersion() ) );\n                    if ( result.getRepository() instanceof RemoteRepository )\n                    {\n                        subRequest.setRepositories( Collections.singletonList( (RemoteRepository) result.getRepository() ) );\n                    }\n                    else\n                    {\n                        subRequest.setRepositories( request.getRepositories() );\n                    }\n                    VersionResult subResult = resolveVersion( session, subRequest );\n                    result.setVersion( subResult.getVersion() );\n                    result.setRepository( subResult.getRepository() );\n                    for ( Exception exception : subResult.getExceptions() )\n                    {\n                        result.addException( exception );\n                    }\n                }\n            }\n            else\n            {\n                if ( !resolve( result, infos, SNAPSHOT + getKey( artifact.getClassifier(), artifact.getExtension() ) )\n                    && !resolve( result, infos, SNAPSHOT ) )\n                {\n                    result.setVersion( version );\n                }\n            }\n\n            if ( StringUtils.isEmpty( result.getVersion() ) )\n            {\n                throw new VersionResolutionException( result );\n            }\n        }\n\n        if ( cacheKey != null && metadata != null && isSafelyCacheable( session, artifact ) )\n        {\n            cache.put( session, cacheKey, new Record( result.getVersion(), result.getRepository() ) );\n        }\n\n        return result;\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private void invalidMetadata( RepositorySystemSession session, Metadata metadata, Exception exception )\n    {\n        RepositoryListener listener = session.getRepositoryListener();\n        if ( listener != null )\n        {\n            DefaultRepositoryEvent event = new DefaultRepositoryEvent( session, metadata );\n            event.setException( exception );\n            listener.metadataInvalid( event );\n        }\n    }","id":44161,"modified_method":"private void invalidMetadata( RepositorySystemSession session, Metadata metadata, ArtifactRepository repository,\n                                  Exception exception )\n    {\n        RepositoryListener listener = session.getRepositoryListener();\n        if ( listener != null )\n        {\n            DefaultRepositoryEvent event = new DefaultRepositoryEvent( session, metadata );\n            event.setException( exception );\n            event.setRepository( repository );\n            listener.metadataInvalid( event );\n        }\n    }","commit_id":"11afa6961fa34cb4d666759b646c06f700a744f9","url":"https://github.com/apache/maven"},{"original_method":"private void rewriteMetadata( Artifact artifact, RewriteTransaction transaction, File sourceBase,\n                                  ArtifactRepository sourceRepo, File targetBase, ArtifactRepository targetRepo,\n                                  Reporter artifactReporter, boolean reportOnly )\n        throws Exception\n    {\n        ArtifactMetadata metadata = new ArtifactRepositoryMetadata( artifact );\n\n        File metadataSource = new File( sourceBase, sourceRepo.pathOfRemoteRepositoryMetadata( metadata ) );\n        File metadataTarget = new File( targetBase, targetRepo.pathOfRemoteRepositoryMetadata( metadata ) );\n\n        mergeMetadata( metadataSource, metadataTarget, transaction, artifactReporter, reportOnly );\n\n        metadata = new SnapshotArtifactRepositoryMetadata( artifact );\n\n        metadataSource = new File( sourceBase, sourceRepo.pathOfRemoteRepositoryMetadata( metadata ) );\n        metadataTarget = new File( targetBase, targetRepo.pathOfRemoteRepositoryMetadata( metadata ) );\n\n        mergeMetadata( metadataSource, metadataTarget, transaction, artifactReporter, reportOnly );\n\n        // The rest is for POM metadata - translation and bridging of locations in the target repo may be required.\n        ArtifactMetadata pom = new ProjectArtifactMetadata( artifact, null );\n\n        File sourcePom = new File( sourceBase, sourceRepo.pathOfRemoteRepositoryMetadata( pom ) );\n        File targetPom = new File( targetBase, targetRepo.pathOfRemoteRepositoryMetadata( pom ).replace( '+', '-' ) );\n\n        String pomContents = null;\n\n        boolean shouldRewritePom = true;\n\n        if ( sourcePom.exists() )\n        {\n            pomContents = readPomContents( sourcePom );\n\n            if ( pomContents.indexOf( \"modelVersion\" ) > -1 )\n            {\n                shouldRewritePom = false;\n\n                copyMetadata( sourcePom, targetPom, transaction, artifactReporter, reportOnly );\n            }\n        }\n        else if ( targetPom.exists() )\n        {\n            // we have a target pom for this artifact already, and we'll only be making up a new pom.\n            // let's leave the existing one alone.\n            shouldRewritePom = false;\n        }\n\n        File bridgedTargetPom = null;\n\n        boolean wroteBridge = false;\n\n        if ( shouldRewritePom )\n        {\n            ArtifactPomRewriter artifactPomRewriter = null;\n\n            try\n            {\n                artifactPomRewriter = (ArtifactPomRewriter) container.lookup( ArtifactPomRewriter.ROLE,\n                                                                              ArtifactPomRewriter.V3_POM );\n\n                transaction.addFile( targetPom );\n\n                bridgedTargetPom = new File( targetBase,\n                                             bridgingLayout.pathOfRemoteRepositoryMetadata( pom ).replace( '+', '-' ) );\n\n                transaction.addFile( bridgedTargetPom );\n\n                File targetPomParent = targetPom.getParentFile();\n                if ( !targetPomParent.exists() )\n                {\n                    targetPomParent.mkdirs();\n                }\n\n                FileWriter to = null;\n                try\n                {\n                    StringReader from = null;\n                    if ( pomContents != null )\n                    {\n                        from = new StringReader( pomContents );\n                    }\n\n                    to = new FileWriter( targetPom );\n\n                    artifactPomRewriter.rewrite( artifact, from, to, artifactReporter, reportOnly );\n                }\n                finally\n                {\n                    IOUtil.close( to );\n                }\n\n                wroteBridge = bridgePomLocations( targetPom, bridgedTargetPom, artifactReporter, transaction,\n                                                  reportOnly );\n            }\n            finally\n            {\n                if ( artifactPomRewriter != null )\n                {\n                    try\n                    {\n                        container.release( artifactPomRewriter );\n                    }\n                    catch ( ComponentLifecycleException e )\n                    {\n                    }\n                }\n            }\n        }\n\n        digestVerifier.verifyDigest( sourcePom, targetPom, transaction, artifactReporter, reportOnly );\n\n        if ( wroteBridge )\n        {\n            digestVerifier.verifyDigest( sourcePom, bridgedTargetPom, transaction, artifactReporter, reportOnly );\n        }\n    }","id":44162,"modified_method":"private void rewriteMetadata( Artifact artifact, RewriteTransaction transaction, File sourceBase,\n                                  ArtifactRepository sourceRepo, File targetBase, ArtifactRepository targetRepo,\n                                  Reporter artifactReporter, boolean reportOnly )\n        throws Exception\n    {\n        ArtifactMetadata metadata = new ArtifactRepositoryMetadata( artifact );\n\n        File metadataSource = new File( sourceBase, sourceRepo.pathOfRemoteRepositoryMetadata( metadata ) );\n        File metadataTarget = new File( targetBase, targetRepo.pathOfRemoteRepositoryMetadata( metadata ) );\n\n        Metadata sourceMetadata = readMetadata( metadataSource, artifact );\n        if ( sourceMetadata.getVersioning() == null )\n        {\n            sourceMetadata.setVersioning( new Versioning() );\n        }\n        if ( !sourceMetadata.getVersioning().getVersions().contains( artifact.getBaseVersion() ) )\n        {\n            sourceMetadata.getVersioning().addVersion( artifact.getBaseVersion() );\n        }\n        mergeMetadata( sourceMetadata, metadataTarget, reportOnly );\n\n        metadata = new SnapshotArtifactRepositoryMetadata( artifact );\n\n        metadataSource = new File( sourceBase, sourceRepo.pathOfRemoteRepositoryMetadata( metadata ) );\n        metadataTarget = new File( targetBase, targetRepo.pathOfRemoteRepositoryMetadata( metadata ) );\n\n        sourceMetadata = readMetadata( metadataSource, artifact );\n        if ( artifact.isSnapshot() )\n        {\n            if ( sourceMetadata.getVersioning() == null )\n            {\n                sourceMetadata.setVersioning( new Versioning() );\n            }\n            if ( sourceMetadata.getVersioning().getSnapshot() == null )\n            {\n                sourceMetadata.getVersioning().setSnapshot( new Snapshot() );\n            }\n\n            int i = artifact.getVersion().indexOf( '-' );\n            if ( i >= 0 )\n            {\n                Snapshot snapshot = sourceMetadata.getVersioning().getSnapshot();\n                snapshot.setTimestamp( artifact.getVersion().substring( 0, i ) );\n                snapshot.setBuildNumber( Integer.valueOf( artifact.getVersion().substring( i + 1 ) ).intValue() );\n            }\n        }\n        mergeMetadata( sourceMetadata, metadataTarget, reportOnly );\n\n        // The rest is for POM metadata - translation and bridging of locations in the target repo may be required.\n        ArtifactMetadata pom = new ProjectArtifactMetadata( artifact, null );\n\n        File sourcePom = new File( sourceBase, sourceRepo.pathOfRemoteRepositoryMetadata( pom ) );\n        File targetPom = new File( targetBase, targetRepo.pathOfRemoteRepositoryMetadata( pom ).replace( '+', '-' ) );\n\n        String pomContents = null;\n\n        boolean shouldRewritePom = true;\n\n        if ( sourcePom.exists() )\n        {\n            pomContents = readPomContents( sourcePom );\n\n            if ( pomContents.indexOf( \"modelVersion\" ) > -1 )\n            {\n                shouldRewritePom = false;\n\n                copyMetadata( sourcePom, targetPom, transaction, artifactReporter, reportOnly );\n            }\n        }\n        else if ( targetPom.exists() )\n        {\n            // we have a target pom for this artifact already, and we'll only be making up a new pom.\n            // let's leave the existing one alone.\n            shouldRewritePom = false;\n        }\n\n        File bridgedTargetPom = null;\n\n        boolean wroteBridge = false;\n\n        if ( shouldRewritePom )\n        {\n            ArtifactPomRewriter artifactPomRewriter = null;\n\n            try\n            {\n                artifactPomRewriter = (ArtifactPomRewriter) container.lookup( ArtifactPomRewriter.ROLE,\n                                                                              ArtifactPomRewriter.V3_POM );\n\n                transaction.addFile( targetPom );\n\n                bridgedTargetPom = new File( targetBase,\n                                             bridgingLayout.pathOfRemoteRepositoryMetadata( pom ).replace( '+', '-' ) );\n\n                transaction.addFile( bridgedTargetPom );\n\n                File targetPomParent = targetPom.getParentFile();\n                if ( !targetPomParent.exists() )\n                {\n                    targetPomParent.mkdirs();\n                }\n\n                FileWriter to = null;\n                try\n                {\n                    StringReader from = null;\n                    if ( pomContents != null )\n                    {\n                        from = new StringReader( pomContents );\n                    }\n\n                    to = new FileWriter( targetPom );\n\n                    artifactPomRewriter.rewrite( artifact, from, to, artifactReporter, reportOnly );\n                }\n                finally\n                {\n                    IOUtil.close( to );\n                }\n\n                wroteBridge = bridgePomLocations( targetPom, bridgedTargetPom, artifactReporter, transaction,\n                                                  reportOnly );\n            }\n            finally\n            {\n                if ( artifactPomRewriter != null )\n                {\n                    try\n                    {\n                        container.release( artifactPomRewriter );\n                    }\n                    catch ( ComponentLifecycleException e )\n                    {\n                    }\n                }\n            }\n        }\n\n        digestVerifier.verifyDigest( sourcePom, targetPom, transaction, artifactReporter, reportOnly );\n\n        if ( wroteBridge )\n        {\n            digestVerifier.verifyDigest( sourcePom, bridgedTargetPom, transaction, artifactReporter, reportOnly );\n        }\n    }","commit_id":"52d376bf7f34c9686da678c08547f11ef1fba719","url":"https://github.com/apache/maven"},{"original_method":"private void mergeMetadata( File source, File target, RewriteTransaction transaction, Reporter artifactReporter,\n                                boolean reportOnly )\n        throws IOException, DigestException, ReportWriteException, XmlPullParserException\n    {\n        if ( source.exists() )\n        {\n            if ( !target.exists() )\n            {\n                copyMetadata( source, target, transaction, artifactReporter, reportOnly );\n            }\n            else\n            {\n                MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();\n\n                Metadata sourceMetadata = null;\n\n                Reader reader = null;\n\n                try\n                {\n                    reader = new FileReader( source );\n\n                    sourceMetadata = mappingReader.read( reader );\n                }\n                finally\n                {\n                    IOUtil.close( reader );\n                    reader = null;\n                }\n\n                Metadata targetMetadata = null;\n\n                try\n                {\n                    reader = new FileReader( target );\n\n                    targetMetadata = mappingReader.read( reader );\n                }\n                finally\n                {\n                    IOUtil.close( reader );\n                }\n\n                boolean changed = false;\n\n                changed |= targetMetadata.merge( sourceMetadata );\n\n                if ( changed )\n                {\n                    Writer writer = null;\n                    try\n                    {\n                        target.getParentFile().mkdirs();\n                        writer = new FileWriter( target );\n\n                        MetadataXpp3Writer mappingWriter = new MetadataXpp3Writer();\n\n                        mappingWriter.write( writer, targetMetadata );\n                    }\n                    finally\n                    {\n                        IOUtil.close( writer );\n                    }\n                }\n\n                digestVerifier.verifyDigest( source, target, transaction, artifactReporter, reportOnly );\n            }\n        }\n    }","id":44163,"modified_method":"private void mergeMetadata( Metadata sourceMetadata, File target, boolean reportOnly )\n        throws IOException, DigestException, XmlPullParserException, NoSuchAlgorithmException\n    {\n        if ( target.exists() )\n        {\n            Metadata targetMetadata = null;\n\n            Reader reader = null;\n\n            try\n            {\n                reader = new FileReader( target );\n\n                MetadataXpp3Reader mappingReader = new MetadataXpp3Reader();\n\n                targetMetadata = mappingReader.read( reader );\n            }\n            finally\n            {\n                IOUtil.close( reader );\n            }\n\n            boolean changed = targetMetadata.merge( sourceMetadata );\n\n            if ( changed )\n            {\n                Writer writer = null;\n                try\n                {\n                    target.getParentFile().mkdirs();\n                    writer = new FileWriter( target );\n\n                    MetadataXpp3Writer mappingWriter = new MetadataXpp3Writer();\n\n                    mappingWriter.write( writer, targetMetadata );\n\n                    if ( !reportOnly )\n                    {\n                        File digestFile = artifactDigestor.getDigestFile( target, Digestor.MD5 );\n                        artifactDigestor.createArtifactDigest( target, digestFile, Digestor.MD5 );\n                        digestFile = artifactDigestor.getDigestFile( target, Digestor.SHA );\n                        artifactDigestor.createArtifactDigest( target, digestFile, Digestor.SHA );\n                    }\n                }\n                finally\n                {\n                    IOUtil.close( writer );\n                }\n            }\n        }\n    }","commit_id":"52d376bf7f34c9686da678c08547f11ef1fba719","url":"https://github.com/apache/maven"},{"original_method":"private List<LaunchableGradleTask> tasks(Project project) {\n        List<LaunchableGradleTask> tasks = Lists.newArrayList();\n        for (Task task : taskLister.listProjectTasks(project)) {\n            tasks.add(new LaunchableGradleTask()\n                    .setPath(task.getPath())\n                    .setName(task.getName())\n                    .setDisplayName(task.toString())\n                    .setDescription(task.getDescription()));\n        }\n        return tasks;\n    }","id":44164,"modified_method":"private List<LaunchableGradleTask> tasks(Project project) {\n        List<LaunchableGradleTask> tasks = Lists.newArrayList();\n        for (Task task : taskLister.listProjectTasks(project, true)) {\n            tasks.add(new LaunchableGradleTask()\n                    .setPath(task.getPath())\n                    .setName(task.getName())\n                    .setDisplayName(task.toString())\n                    .setDescription(task.getDescription()));\n        }\n        return tasks;\n    }","commit_id":"d3ba0e11bf98011f7c4de2cb71bb8d5da23e5743","url":"https://github.com/gradle/gradle"},{"original_method":"public Collection<Task> listProjectTasks(Project project) {\n        ProjectInternal projectInternal = (ProjectInternal) project;\n        TaskContainerInternal tasks = projectInternal.getTasks();\n        tasks.actualize();\n        return Sets.union(tasks, projectInternal.getImplicitTasks());\n    }","id":44165,"modified_method":"public Collection<Task> listProjectTasks(Project project, boolean includeImplicit) {\n        ProjectInternal projectInternal = (ProjectInternal) project;\n        TaskContainerInternal tasks = projectInternal.getTasks();\n        tasks.actualize();\n        return includeImplicit\n                ? Sets.union(tasks, projectInternal.getImplicitTasks())\n                : tasks;\n    }","commit_id":"d3ba0e11bf98011f7c4de2cb71bb8d5da23e5743","url":"https://github.com/gradle/gradle"},{"original_method":"public void generate(Project project) throws IOException {\n        renderer.showDetail(isDetail());\n        renderer.addDefaultTasks(project.getDefaultTasks());\n\n        AggregateMultiProjectTaskReportModel aggregateModel = new AggregateMultiProjectTaskReportModel(!isDetail());\n        TaskDetailsFactory taskDetailsFactory = new TaskDetailsFactory(project);\n\n        SingleProjectTaskReportModel projectTaskModel = new SingleProjectTaskReportModel(taskDetailsFactory);\n        projectTaskModel.build(getProjectTaskLister().listProjectTasks(project));\n        aggregateModel.add(projectTaskModel);\n\n        for (Project subproject : project.getSubprojects()) {\n            SingleProjectTaskReportModel subprojectTaskModel = new SingleProjectTaskReportModel(taskDetailsFactory);\n            subprojectTaskModel.build(getProjectTaskLister().listProjectTasks(subproject));\n            aggregateModel.add(subprojectTaskModel);\n        }\n\n        aggregateModel.build();\n\n        DefaultGroupTaskReportModel model = new DefaultGroupTaskReportModel();\n        model.build(aggregateModel);\n\n        for (String group : model.getGroups()) {\n            renderer.startTaskGroup(group);\n            for (TaskDetails task : model.getTasksForGroup(group)) {\n                renderer.addTask(task);\n                for (TaskDetails child : task.getChildren()) {\n                    renderer.addChildTask(child);\n                }\n            }\n        }\n        renderer.completeTasks();\n\n        for (Rule rule : project.getTasks().getRules()) {\n            renderer.addRule(rule);\n        }\n    }","id":44166,"modified_method":"public void generate(Project project) throws IOException {\n        renderer.showDetail(isDetail());\n        renderer.addDefaultTasks(project.getDefaultTasks());\n\n        AggregateMultiProjectTaskReportModel aggregateModel = new AggregateMultiProjectTaskReportModel(!isDetail());\n        TaskDetailsFactory taskDetailsFactory = new TaskDetailsFactory(project);\n\n        SingleProjectTaskReportModel projectTaskModel = new SingleProjectTaskReportModel(taskDetailsFactory);\n        projectTaskModel.build(getProjectTaskLister().listProjectTasks(project, true));\n        aggregateModel.add(projectTaskModel);\n\n        for (Project subproject : project.getSubprojects()) {\n            SingleProjectTaskReportModel subprojectTaskModel = new SingleProjectTaskReportModel(taskDetailsFactory);\n            subprojectTaskModel.build(getProjectTaskLister().listProjectTasks(subproject, false));\n            aggregateModel.add(subprojectTaskModel);\n        }\n\n        aggregateModel.build();\n\n        DefaultGroupTaskReportModel model = new DefaultGroupTaskReportModel();\n        model.build(aggregateModel);\n\n        for (String group : model.getGroups()) {\n            renderer.startTaskGroup(group);\n            for (TaskDetails task : model.getTasksForGroup(group)) {\n                renderer.addTask(task);\n                for (TaskDetails child : task.getChildren()) {\n                    renderer.addChildTask(child);\n                }\n            }\n        }\n        renderer.completeTasks();\n\n        for (Rule rule : project.getTasks().getRules()) {\n            renderer.addRule(rule);\n        }\n    }","commit_id":"d3ba0e11bf98011f7c4de2cb71bb8d5da23e5743","url":"https://github.com/gradle/gradle"},{"original_method":"@Override \n    public Map<DynamicOperandImpl, Set<StaticOperandImpl>> getInMap() {\n        Map<DynamicOperandImpl, Set<StaticOperandImpl>> m1 = constraint1.getInMap();\n        Map<DynamicOperandImpl, Set<StaticOperandImpl>> m2 = constraint2.getInMap();\n        if (m1.isEmpty()) {\n            return m1;\n        } else if (m2.isEmpty()) {\n            return m2;\n        }\n        Map<DynamicOperandImpl, Set<StaticOperandImpl>> result = Maps.newHashMap();\n        result.putAll(m1);\n        for (Entry<DynamicOperandImpl, Set<StaticOperandImpl>> e2 : m2.entrySet()) {\n            Set<StaticOperandImpl> l2 = e2.getValue();\n            Set<StaticOperandImpl> l1 = m1.get(e2.getKey());\n            // l1 might be null (l2 not, as it's from the iterator)\n            Set<StaticOperandImpl> list = l1 == null ? l2 : Sets.union(l1, l2);\n            result.put(e2.getKey(), list);\n        }\n        return result;\n    }","id":44167,"modified_method":"@Override \n    public Map<DynamicOperandImpl, Set<StaticOperandImpl>> getInMap() {\n        Map<DynamicOperandImpl, Set<StaticOperandImpl>> m1 = constraint1.getInMap();\n        Map<DynamicOperandImpl, Set<StaticOperandImpl>> m2 = constraint2.getInMap();\n        if (m1.isEmpty()) {\n            return m1;\n        } else if (m2.isEmpty()) {\n            return m2;\n        }\n        Map<DynamicOperandImpl, Set<StaticOperandImpl>> result = Maps.newHashMap();\n        for (Entry<DynamicOperandImpl, Set<StaticOperandImpl>> e2 : m2.entrySet()) {\n            Set<StaticOperandImpl> l2 = e2.getValue();\n            Set<StaticOperandImpl> l1 = m1.get(e2.getKey());\n            if (l1 != null && !l1.isEmpty() && !l2.isEmpty()) {\n                Set<StaticOperandImpl> list = Sets.union(l1, l2);\n                result.put(e2.getKey(), list);\n            }\n        }\n        return result;\n    }","commit_id":"11cccb00e0cece37956caebd102d5d0c79bb5323","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\r\n   * Calculates axis caption depending on view width / height.\r\n   * @param space space of view axis available for captions\r\n   */\r\n  void calcCaption(final int space) {\r\n    if(type == Kind.DBL || type == Kind.INT) {\r\n      final double range = Math.abs(max - min);\r\n      if(range == 0) {\r\n        nrCaptions = 1;\r\n        return;\r\n      }\r\n      final boolean dbl = type == Kind.DBL;\r\n\r\n      actlCaptionStep = calculatedCaptionStep;\r\n      nrCaptions = (int) (range / actlCaptionStep) + 1;\r\n      while(2 * nrCaptions * PlotView.CAPTIONWHITESPACE * 2 < space &&\r\n          dbl ? dbl : actlCaptionStep % 2 == 0) {\r\n        actlCaptionStep /= 2;\r\n        nrCaptions = (int) (range / actlCaptionStep);\r\n      }\r\n      while(nrCaptions * PlotView.CAPTIONWHITESPACE * 2 > space) {\r\n        actlCaptionStep *= 2;\r\n        nrCaptions = (int) (range / actlCaptionStep);\r\n      }\r\n\r\n      // find first label after minimum value\r\n      firstLabel = sigVal;\r\n      while(firstLabel > min + actlCaptionStep * 1.2d)\r\n        firstLabel -= actlCaptionStep;\r\n\r\n      // type == TEXT / CAT\r\n    } else {\r\n      nrCaptions = space / (PlotView.CAPTIONWHITESPACE * 3);\r\n      if(nrCaptions > nrCats)\r\n        nrCaptions = nrCats;\r\n      actlCaptionStep = 1.0d / (nrCaptions - 1);\r\n    }\r\n  }","id":44168,"modified_method":"/**\r\n   * Calculates axis caption depending on view width / height.\r\n   * @param space space of view axis available for captions\r\n   */\r\n  void calcCaption(final int space) {\r\n    if(type == Kind.DBL || type == Kind.INT) {\r\n      final double range = Math.abs(max - min);\r\n      if(range == 0) {\r\n        nrCaptions = 1;\r\n        return;\r\n      }\r\n      final boolean dbl = type == Kind.DBL;\r\n\r\n      actlCaptionStep = calculatedCaptionStep;\r\n      nrCaptions = (int) (range / actlCaptionStep) + 1;\r\n      while(2 * nrCaptions * PlotView.CAPTIONWHITESPACE * 3 < space &&\r\n          dbl ? dbl : actlCaptionStep % 2 == 0) {\r\n        actlCaptionStep /= 2;\r\n        nrCaptions = (int) (range / actlCaptionStep);\r\n      }\r\n      while(nrCaptions * PlotView.CAPTIONWHITESPACE * 3 > space) {\r\n        actlCaptionStep *= 2;\r\n        nrCaptions = (int) (range / actlCaptionStep);\r\n      }\r\n\r\n      // find first label after minimum value\r\n      firstLabel = sigVal;\r\n      while(firstLabel > min + actlCaptionStep * 1.2d)\r\n        firstLabel -= actlCaptionStep;\r\n\r\n      // type == TEXT / CAT\r\n    } else {\r\n      nrCaptions = space / (PlotView.CAPTIONWHITESPACE * 4);\r\n      if(nrCaptions > nrCats)\r\n        nrCaptions = nrCats;\r\n      actlCaptionStep = 1.0d / (nrCaptions - 1);\r\n    }\r\n  }","commit_id":"b53d57746a158390888ff37536d3b48fe9ab15c9","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void mousePressed(final MouseEvent e) {\r\n    if(working || painting) return;\r\n    // right only button used to call popup menu\r\n    if(SwingUtilities.isRightMouseButton(e)) {\r\n      rightClick = true;\r\n      return;\r\n    }\r\n    if(rightClick) markingChanged = true;\r\n    mouseX = e.getX();\r\n    mouseY = e.getY();\r\n    focus();\r\n    // no item is focused. no nodes marked after mouse click\r\n    if(focused == -1) {\r\n      // a marking update is triggered with an empty node set as argument\r\n      notifyMark(new Nodes(GUI.context.data()), this);\r\n      markingChanged = true;\r\n      return;\r\n    }\r\n\r\n    // node marking if item focused. if more than one icon is in focus range\r\n    // all of these are marked. focus range means exact same x AND y coordinate.\r\n    final int pre = plotData.findPre(focused);\r\n    if(pre < 0) return;\r\n\r\n    markingChanged = true;\r\n    final IntList il = new IntList();\r\n    // get coordinates for focused item\r\n    final int mx = calcCoordinate(true, plotData.xAxis.co[pre]);\r\n    final int my = calcCoordinate(false, plotData.yAxis.co[pre]);\r\n    for(int i = 0; i < plotData.size; i++) {\r\n      // get coordinates for current item\r\n      final int x = calcCoordinate(true, plotData.xAxis.co[i]);\r\n      final int y = calcCoordinate(false, plotData.yAxis.co[i]);\r\n      if(mx == x && my == y) {\r\n        il.add(plotData.pres[i]);\r\n      }\r\n    }\r\n\r\n    // right mouse or shift down\r\n    if(e.isShiftDown()) {\r\n      final Nodes marked = GUI.context.marked();\r\n      marked.union(il.finish());\r\n      notifyMark(marked, this);\r\n      // double click\r\n    } else if(e.getClickCount() == 2) {\r\n      final Nodes marked = new Nodes(GUI.context.data());\r\n      marked.union(il.finish());\r\n      notifyContext(marked, false, null);\r\n      // simple mouse click\r\n    } else {\r\n      final Nodes marked = new Nodes(GUI.context.data());\r\n      marked.union(il.finish());\r\n      notifyMark(marked, this);\r\n    }\r\n  }","id":44169,"modified_method":"@Override\r\n  public void mousePressed(final MouseEvent e) {\r\n    if(working || painting) return;\r\n    // right only button used to call popup menu\r\n    if(SwingUtilities.isRightMouseButton(e)) {\r\n      rightClick = true;\r\n      return;\r\n    }\r\n    if(rightClick) markingChanged = true;\r\n    mouseX = e.getX();\r\n    mouseY = e.getY();\r\n    focus();\r\n    // no item is focused. no nodes marked after mouse click\r\n    if(focused == -1) {\r\n      // a marking update is triggered with an empty node set as argument\r\n      notifyMark(new Nodes(GUI.context.data()), this);\r\n      markingChanged = true;\r\n      return;\r\n    }\r\n\r\n    // node marking if item focused. if more than one icon is in focus range\r\n    // all of these are marked. focus range means exact same x AND y coordinate.\r\n    final int pre = plotData.findPre(focused);\r\n    if(pre < 0) return;\r\n    markingChanged = true;\r\n    final int[] il = getOverlappingNodes(pre);\r\n\r\n    // right mouse or shift down\r\n    if(e.isShiftDown()) {\r\n      final Nodes marked = GUI.context.marked();\r\n      marked.union(il);\r\n      notifyMark(marked, this);\r\n      // double click\r\n    } else if(e.getClickCount() == 2) {\r\n      final Nodes marked = new Nodes(GUI.context.data());\r\n      marked.union(il);\r\n      notifyContext(marked, false, null);\r\n      // simple mouse click\r\n    } else {\r\n      final Nodes marked = new Nodes(GUI.context.data());\r\n      marked.union(il);\r\n      notifyMark(marked, this);\r\n    }\r\n  }","commit_id":"b53d57746a158390888ff37536d3b48fe9ab15c9","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void paintComponent(final Graphics g) {\r\n    final Data data = GUI.context.data();\r\n    if(data == null) return;\r\n\r\n    super.paintComponent(g);\r\n    BaseXLayout.antiAlias(g);\r\n\r\n    if(plotData == null) {\r\n      refreshInit();\r\n      return;\r\n    }\r\n\r\n    final int w = getWidth();\r\n    final int h = getHeight();\r\n    plotWidth = w - (MARGIN[1] + MARGIN[3]);\r\n    plotHeight = h - (MARGIN[0] + MARGIN[2]);\r\n\r\n    final int sz = sizeFactor();\r\n    if(plotWidth - sz < 0 || plotHeight - sz < 0) {\r\n      g.setFont(GUIConstants.font);\r\n      g.setColor(Color.black);\r\n      BaseXLayout.drawCenter(g, NOSPACE, w, h / 2 - MARGIN[0]);\r\n      return;\r\n    }\r\n\r\n    painting = true;\r\n\r\n    // draw buffered plot image\r\n    if(plotImg == null || plotChanged) createPlotImage();\r\n    g.drawImage(plotImg, 0, 0, this);\r\n\r\n    // draw buffered image of marked items\r\n    if(markingChanged || markedImg == null) createMarkedNodes();\r\n    g.drawImage(markedImg, 0, 0, this);\r\n\r\n    // draw focused item\r\n    final int f = plotData.findPre(focused);\r\n    if(f > -1) {\r\n      if(!dragging) {\r\n        final double x1 = plotData.xAxis.co[f];\r\n        final double y1 = plotData.yAxis.co[f];\r\n        drawItem(g, x1, y1, true, false, false);\r\n        // draw focused x and y value\r\n        g.setFont(GUIConstants.font);\r\n        final int textH = g.getFontMetrics().getHeight();\r\n        final String name = plotData.getName(focused);\r\n        final String x = formatString(true);\r\n        final String y = formatString(false);\r\n        final String label = (x.length() > 16 ?\r\n            x.substring(0, 14) + \"..\" : x) + \" / \"\r\n            + (y.length() > 16 ? y.substring(0, 14) + \"..\" : y);\r\n        final int xa = calcCoordinate(true, x1) + 15;\r\n        int ya = calcCoordinate(false, y1) + GUIProp.plotdots;\r\n        final int ww = getWidth();\r\n\r\n        if(name.length() > 0 && plotData.xAxis.attrID != data.nameID &&\r\n            plotData.yAxis.attrID != data.nameID) {\r\n          final int lw = BaseXLayout.width(g, label);\r\n          if(ya < MARGIN[0] + textH && xa < w - lw) {\r\n            ya += 2 * textH - GUIProp.plotdots;\r\n          }\r\n          if(xa > w - lw)\r\n            BaseXLayout.drawTooltip(g, name + \": \" + label, xa, ya, ww, 10);\r\n          else {\r\n            BaseXLayout.drawTooltip(g, name, xa, ya - textH, ww, 10);\r\n            BaseXLayout.drawTooltip(g, label, xa, ya, ww, 10);\r\n          }\r\n        } else\r\n          BaseXLayout.drawTooltip(g, label, xa, ya, ww, 10);\r\n      }\r\n    }\r\n\r\n    // draw selection box\r\n    if(dragging) {\r\n      g.setColor(GUIConstants.back);\r\n      final int selW = selectionBox.getWidth();\r\n      final int selH = selectionBox.getHeight();\r\n      final int x1 = selectionBox.x1;\r\n      final int y1 = selectionBox.y1;\r\n      g.fillRect(selW > 0 ? x1 : x1 + selW, selH > 0 ? y1 : y1 + selH,\r\n          Math.abs(selW), Math.abs(selH));\r\n      g.setColor(GUIConstants.frame);\r\n      g.drawRect(selW > 0 ? x1 : x1 + selW, selH > 0 ? y1 : y1 + selH,\r\n          Math.abs(selW), Math.abs(selH));\r\n    }\r\n    markingChanged = false;\r\n    plotChanged = false;\r\n    painting = false;\r\n  }","id":44170,"modified_method":"@Override\r\n  public void paintComponent(final Graphics g) {\r\n    final Data data = GUI.context.data();\r\n    if(data == null) return;\r\n\r\n    super.paintComponent(g);\r\n    BaseXLayout.antiAlias(g);\r\n\r\n    if(plotData == null) {\r\n      refreshInit();\r\n      return;\r\n    }\r\n\r\n    final int w = getWidth();\r\n    final int h = getHeight();\r\n    plotWidth = w - (MARGIN[1] + MARGIN[3]);\r\n    plotHeight = h - (MARGIN[0] + MARGIN[2]);\r\n\r\n    final int sz = sizeFactor();\r\n    if(plotWidth - sz < 0 || plotHeight - sz < 0) {\r\n      g.setFont(GUIConstants.font);\r\n      g.setColor(Color.black);\r\n      BaseXLayout.drawCenter(g, NOSPACE, w, h / 2 - MARGIN[0]);\r\n      return;\r\n    }\r\n\r\n    painting = true;\r\n\r\n    // draw buffered plot image\r\n    if(plotImg == null || plotChanged) createPlotImage();\r\n    g.drawImage(plotImg, 0, 0, this);\r\n\r\n    // draw buffered image of marked items\r\n    if(markingChanged || markedImg == null) createMarkedNodes();\r\n    g.drawImage(markedImg, 0, 0, this);\r\n\r\n    // draw focused item\r\n    final int f = plotData.findPre(focused);\r\n    if(f > -1) {\r\n      // determine number of overlapping nodes (plotting second)\r\n      final int ol = getOverlappingNodes(f).length;\r\n      if(!dragging) {\r\n        final double x1 = plotData.xAxis.co[f];\r\n        final double y1 = plotData.yAxis.co[f];\r\n        drawItem(g, x1, y1, true, false, false);\r\n        // draw focused x and y value\r\n        g.setFont(GUIConstants.font);\r\n        final int textH = g.getFontMetrics().getHeight();\r\n        final String name = plotData.getName(focused) + \r\n          (ol > 1 ? (\"  (\" + ol + \") \") : \"\");\r\n        final String x = formatString(true);\r\n        final String y = formatString(false);\r\n        final String label = (x.length() > 16 ?\r\n            x.substring(0, 14) + \"..\" : x) + \" / \"\r\n            + (y.length() > 16 ? y.substring(0, 14) + \"..\" : y);\r\n        final int xa = calcCoordinate(true, x1) + 15;\r\n        int ya = calcCoordinate(false, y1) + GUIProp.plotdots;\r\n        final int ww = getWidth();\r\n\r\n        if(name.length() > 0 && plotData.xAxis.attrID != data.nameID &&\r\n            plotData.yAxis.attrID != data.nameID) {\r\n          final int lw = BaseXLayout.width(g, label);\r\n          if(ya < MARGIN[0] + textH && xa < w - lw) {\r\n            ya += 2 * textH - GUIProp.plotdots;\r\n          }\r\n          if(xa > w - lw)\r\n            BaseXLayout.drawTooltip(g, name + \": \" + label, xa, ya, ww, 10);\r\n          else {\r\n            BaseXLayout.drawTooltip(g, name, xa, ya - textH, ww, 10);\r\n            BaseXLayout.drawTooltip(g, label, xa, ya, ww, 10);\r\n          }\r\n        } else\r\n          BaseXLayout.drawTooltip(g, label, xa, ya, ww, 10);\r\n      }\r\n    }\r\n\r\n    // draw selection box\r\n    if(dragging) {\r\n      g.setColor(GUIConstants.back);\r\n      final int selW = selectionBox.getWidth();\r\n      final int selH = selectionBox.getHeight();\r\n      final int x1 = selectionBox.x1;\r\n      final int y1 = selectionBox.y1;\r\n      g.fillRect(selW > 0 ? x1 : x1 + selW, selH > 0 ? y1 : y1 + selH,\r\n          Math.abs(selW), Math.abs(selH));\r\n      g.setColor(GUIConstants.frame);\r\n      g.drawRect(selW > 0 ? x1 : x1 + selW, selH > 0 ? y1 : y1 + selH,\r\n          Math.abs(selW), Math.abs(selH));\r\n    }\r\n    markingChanged = false;\r\n    plotChanged = false;\r\n    painting = false;\r\n  }","commit_id":"b53d57746a158390888ff37536d3b48fe9ab15c9","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void mouseReleased(final MouseEvent e) {\r\n    if(working || painting) return;\r\n    dragging = false;\r\n    notifyFocus(-1, this);\r\n    repaint();\r\n  }","id":44171,"modified_method":"@Override\r\n  public void mouseReleased(final MouseEvent e) {\r\n    if(working || painting) return;\r\n    dragging = false;\r\n    repaint();\r\n  }","commit_id":"b53d57746a158390888ff37536d3b48fe9ab15c9","url":"https://github.com/BaseXdb/basex"},{"original_method":"@NotNull\n  @Override\n  public PsiReference[] getReferencesByElement(@NotNull final PsiElement element, @NotNull ProcessingContext context) {\n    final PyDocStringOwner docStringOwner = PsiTreeUtil.getParentOfType(element, PyDocStringOwner.class);\n    if (docStringOwner != null && element == docStringOwner.getDocStringExpression()) {\n      final List<PsiReference> result = new ArrayList<PsiReference>();\n      String docString = element.getText();\n      int pos = 0;\n      while (pos < docString.length()) {\n        final TextRange tagRange = findNextTag(docString, pos, ALL_PARAM_TAGS);\n        if (tagRange == null) {\n          break;\n        }\n        pos = CharMatcher.anyOf(\" \\t*\").negate().indexIn(docString, tagRange.getEndOffset());\n        CharMatcher identifierMatcher = new CharMatcher() {\n                                        @Override public boolean matches(char c) {\n                                          return Character.isLetterOrDigit(c) || c == '_';\n                                        }}.negate();\n        final String tagName = docString.substring(tagRange.getStartOffset(), tagRange.getEndOffset());\n        boolean isRType = isReturnType(tagName);\n        if (tagName.startsWith(\":\") && !isRType) {           // if ReST parameter tag\n          int ws = CharMatcher.anyOf(\" \\t*\").indexIn(docString, pos+1);\n          if (ws != -1) {\n            int next = CharMatcher.anyOf(\" \\t*\").negate().indexIn(docString, ws);\n            if (next != -1 && !docString.substring(pos, next).contains(\":\")) {\n              int endPos = identifierMatcher.indexIn(docString, pos);\n              PyType type = PyTypeParser.getTypeByName(element, docString.substring(pos, endPos));\n              result.add(new DocStringTypeReference(element, new TextRange(pos, endPos), type));\n              pos = next;\n            }\n          }\n        }\n        int endPos = identifierMatcher.indexIn(docString, pos);\n        if (endPos < 0) {\n          endPos = docString.length();\n        }\n        if (!isRType)\n          result.add(new DocStringParameterReference(element, new TextRange(pos, endPos)));\n        if (tagName.equals(\":type\") || tagName.equals(\"@type\") || isRType) {\n          pos = CharMatcher.anyOf(\" \\t*\").negate().indexIn(docString, endPos+1);\n          endPos = CharMatcher.anyOf(\"\\n\\r\").indexIn(docString, pos+1);\n          if (endPos == -1)\n            endPos  = pos;\n          Map<TextRange, PyType> map =  PyTypeParser.parseDocstring(element, docString.substring(pos, endPos), pos);\n          for (Map.Entry<TextRange, PyType> pair : map.entrySet())\n            result.add(new DocStringTypeReference(element, pair.getKey(), pair.getValue()));\n        }\n        pos = endPos;\n      }\n\n      return result.toArray(new PsiReference[result.size()]);\n    }\n    return PsiReference.EMPTY_ARRAY;\n  }","id":44172,"modified_method":"@NotNull\n  @Override\n  public PsiReference[] getReferencesByElement(@NotNull final PsiElement element, @NotNull ProcessingContext context) {\n    final PyDocStringOwner docStringOwner = PsiTreeUtil.getParentOfType(element, PyDocStringOwner.class);\n    if (docStringOwner != null && element == docStringOwner.getDocStringExpression()) {\n      final List<PsiReference> result = new ArrayList<PsiReference>();\n      String docString = element.getText();\n      int pos = 0;\n      while (pos < docString.length()) {\n        final TextRange tagRange = findNextTag(docString, pos, ALL_PARAM_TAGS);\n        if (tagRange == null) {\n          break;\n        }\n        pos = CharMatcher.anyOf(\" \\t*\").negate().indexIn(docString, tagRange.getEndOffset());\n        CharMatcher identifierMatcher = new CharMatcher() {\n                                        @Override public boolean matches(char c) {\n                                          return Character.isLetterOrDigit(c) || c == '_';\n                                        }}.negate();\n        final String tagName = docString.substring(tagRange.getStartOffset(), tagRange.getEndOffset());\n        boolean isRType = isReturnType(tagName);\n        if (tagName.startsWith(\":\") && !isRType) {           // if ReST parameter tag\n          int ws = CharMatcher.anyOf(\" \\t*\").indexIn(docString, pos+1);\n          if (ws != -1) {\n            int next = CharMatcher.anyOf(\" \\t*\").negate().indexIn(docString, ws);\n            if (next != -1 && !docString.substring(pos, next).contains(\":\")) {\n              int endPos = identifierMatcher.indexIn(docString, pos);\n              result.addAll(parseTypeReferences(element, docString.substring(pos, endPos), pos));\n              pos = next;\n            }\n          }\n        }\n        int endPos = identifierMatcher.indexIn(docString, pos);\n        if (endPos < 0) {\n          endPos = docString.length();\n        }\n        if (!isRType)\n          result.add(new DocStringParameterReference(element, new TextRange(pos, endPos)));\n        if (tagName.equals(\":type\") || tagName.equals(\"@type\") || isRType) {\n          pos = CharMatcher.anyOf(\" \\t*\").negate().indexIn(docString, endPos+1);\n          endPos = CharMatcher.anyOf(\"\\n\\r\").indexIn(docString, pos+1);\n          if (endPos == -1) {\n            endPos = pos;\n          }\n          result.addAll(parseTypeReferences(element, docString.substring(pos, endPos), pos));\n        }\n        pos = endPos;\n      }\n\n      return result.toArray(new PsiReference[result.size()]);\n    }\n    return PsiReference.EMPTY_ARRAY;\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiElement resolve() {\n    if (myType instanceof PyClassType) {\n      return ((PyClassType)myType).getPyClass();\n    }\n    return null;\n  }","id":44173,"modified_method":"@Nullable\n  public PsiElement resolve() {\n    if (myType instanceof PyClassType) {\n      return ((PyClassType)myType).getPyClass();\n    }\n    if (myType instanceof PyImportedModuleType) {\n      final PyImportedModule module = ((PyImportedModuleType)myType).getImportedModule();\n      return PyUtil.turnDirIntoInit(ResolveImportUtil.resolveInRoots(module.getContainingFile(), module.getImportedPrefix()));\n    }\n    return null;\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n    if (element == resolve()) {\n      return element;\n    }\n    if (myElement instanceof PyStringLiteralExpression && element instanceof PyClass) {\n      final PyStringLiteralExpression e = (PyStringLiteralExpression)myElement;\n      final PyClass cls = (PyClass)element;\n      PyQualifiedName qname = ResolveImportUtil.findCanonicalImportPath(cls, element);\n      if (qname != null) {\n        qname = qname.append(cls.getName());\n        ElementManipulator<PyStringLiteralExpression> manipulator = ElementManipulators.getManipulator(e);\n        myType = new PyClassType(cls, false);\n        return manipulator.handleContentChange(e, getRangeInElement(), qname.toString());\n      }\n    }\n    return null;\n  }","id":44174,"modified_method":"@Override\n  public PsiElement bindToElement(@NotNull PsiElement element) throws IncorrectOperationException {\n    if (element.equals(resolve())) {\n      return element;\n    }\n    if (myElement instanceof PyStringLiteralExpression && element instanceof PyClass) {\n      final PyStringLiteralExpression e = (PyStringLiteralExpression)myElement;\n      final PyClass cls = (PyClass)element;\n      PyQualifiedName qname = ResolveImportUtil.findCanonicalImportPath(cls, element);\n      if (qname != null) {\n        qname = qname.append(cls.getName());\n        ElementManipulator<PyStringLiteralExpression> manipulator = ElementManipulators.getManipulator(e);\n        myType = new PyClassType(cls, false);\n        return manipulator.handleContentChange(e, myFullRange, qname.toString());\n      }\n    }\n    return null;\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DocStringTypeReference(PsiElement element, TextRange range, PyType type) {\n    super(element, range);\n    myType = type;\n  }","id":44175,"modified_method":"public DocStringTypeReference(PsiElement element, TextRange range, TextRange fullRange, PyType type) {\n    super(element, range);\n    myFullRange = fullRange;\n    myType = type;\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PyType parseObjectType(PsiElement anchor, String type, PyBuiltinCache builtinCache) {\n    final PyClassType classType = builtinCache.getObjectType(type);\n    if (classType != null) {\n      return classType;\n    }\n    final PsiFile anchorFile = anchor.getContainingFile();\n    if (anchorFile instanceof PyFile) {\n      final PyClass aClass = ((PyFile)anchorFile).findTopLevelClass(type);\n      if (aClass != null) {\n        return new PyClassType(aClass, false);\n      }\n    }\n    if (StringUtil.isJavaIdentifier(type)) {\n      final Collection<PyClass> classes = PyClassNameIndex.find(type, anchor.getProject(), true);\n      if (classes.size() == 1) {\n        return new PyClassType(classes.iterator().next(), false);\n      }\n    }\n    if (CharMatcher.JAVA_LETTER_OR_DIGIT.or(CharMatcher.is('.')).or(CharMatcher.is('_')).matchesAllOf(type)) {\n      final int pos = type.lastIndexOf('.');\n      final String shortName = pos > 0 ? type.substring(pos + 1) : type;\n      final Collection<PyClass> classes = PyClassNameIndex.find(shortName, anchor.getProject(), true);\n      for (PyClass aClass : classes) {\n        if (type.equals(aClass.getQualifiedName())) {\n          return new PyClassType(aClass, false);\n        }\n      }\n      // Workaround for stdlib modules _abcoll, _functools, etc.\n      for (PyClass aClass : classes) {\n        if (aClass.getQualifiedName().startsWith(\"_\")) {\n          return new PyClassType(aClass, false);\n        }\n      }\n    }\n    return null;\n  }","id":44176,"modified_method":"@Nullable\n  private static PyType parseObjectType(PsiElement anchor, String type, PyBuiltinCache builtinCache, Map<TextRange, PyType> types,\n                                        Map<PyType, TextRange> fullRanges, int offset) {\n    final TextRange whole = new TextRange(offset, offset + type.length());\n    final PyClassType classType = builtinCache.getObjectType(type);\n    if (classType != null) {\n      types.put(whole, classType);\n      return classType;\n    }\n    final PsiFile anchorFile = anchor.getContainingFile();\n    if (anchorFile instanceof PyFile) {\n      final PyClass aClass = ((PyFile)anchorFile).findTopLevelClass(type);\n      if (aClass != null) {\n        final PyType t = new PyClassType(aClass, false);\n        types.put(whole, t);\n        return t;\n      }\n    }\n    if (StringUtil.isJavaIdentifier(type)) {\n      final Collection<PyClass> classes = PyClassNameIndex.find(type, anchor.getProject(), true);\n      if (classes.size() == 1) {\n        final PyType t = new PyClassType(classes.iterator().next(), false);\n        types.put(whole, t);\n        return t;\n      }\n    }\n    if (CharMatcher.JAVA_LETTER_OR_DIGIT.or(CharMatcher.is('.')).or(CharMatcher.is('_')).matchesAllOf(type)) {\n      final List<TextRange> ranges = splitRanges(type, \".\");\n      final TextRange classRange = !ranges.isEmpty() ? ranges.remove(ranges.size() - 1) : new TextRange(0, type.length());\n      if (!ranges.isEmpty()) {\n        final TextRange first = ranges.get(0);\n        for (TextRange range : ranges) {\n          final PyQualifiedName moduleName = PyQualifiedName.fromDottedString(first.union(range).substring(type));\n          final PyType t = new PyImportedModuleType(new PyImportedModule(anchor.getContainingFile(), moduleName));\n          types.put(range.shiftRight(offset), t);\n        }\n      }\n      final String shortName = classRange.substring(type);\n      final Collection<PyClass> classes = PyClassNameIndex.find(shortName, anchor.getProject(), true);\n      for (PyClass aClass : classes) {\n        if (type.equals(aClass.getQualifiedName())) {\n          final PyType t = new PyClassType(aClass, false);\n          types.put(classRange.shiftRight(offset), t);\n          fullRanges.put(t, whole);\n          return t;\n        }\n      }\n      // Workaround for stdlib modules _abcoll, _functools, etc.\n      for (PyClass aClass : classes) {\n        if (aClass.getQualifiedName().startsWith(\"_\")) {\n          final PyType t = new PyClassType(aClass, false);\n          types.put(classRange.shiftRight(offset), t);\n          fullRanges.put(t, whole);\n          return t;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PyType parseUnionType(PsiElement anchor, String type) {\n    final List<String> elements = StringUtil.split(type, \" or \");\n    PyType result = null;\n    for (String element : elements) {\n      PyType elementType = getTypeByName(anchor, element);\n      if (elementType != null) {\n        if (result == null) {\n          result = elementType;\n        }\n        else {\n          result = PyUnionType.union(result, elementType);\n        }\n      }\n    }\n    return result;\n  }","id":44177,"modified_method":"@Nullable\n  private static PyType parseUnionType(PsiElement anchor, String type, Map<TextRange, PyType> types,\n                                       Map<PyType, TextRange> fullRanges, int offset) {\n    final List<TextRange> ranges = splitRanges(type, \" or \");\n    PyType result = null;\n    for (TextRange range : ranges) {\n      final PyType t = parse(anchor, range.substring(type), types, fullRanges, offset + range.getStartOffset());\n      if (t != null) {\n        result = (result == null) ? t : PyUnionType.union(result, t);\n      }\n    }\n    return result;\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PyType parseListType(PsiElement anchor, String elementTypeName) {\n    PyClass list = PyBuiltinCache.getInstance(anchor).getClass(\"list\");\n    PyType elementType = getTypeByName(anchor, elementTypeName);\n    return new PyCollectionTypeImpl(list, false, elementType);\n  }","id":44178,"modified_method":"@Nullable\n  private static PyType parse(PsiElement anchor, String type, Map<TextRange, PyType> types, Map<PyType, TextRange> fullRanges, int offset) {\n    if (type == null) {\n      return null;\n    }\n\n    final String trimmed = DocStringUtil.trimDocString(type);\n    offset += type.indexOf(trimmed);\n    type = trimmed;\n    final TextRange whole = new TextRange(offset, offset + type.length());\n    if (type.equals(\"None\")) {\n      final PyType t = PyNoneType.INSTANCE;\n      types.put(whole, t);\n      return t;\n    }\n    if (type.startsWith(\"(\") && type.endsWith(\")\")) {\n      return parseTupleType(anchor, type.substring(1, type.length() - 1), types, fullRanges, offset + 1);\n    }\n    if (type.contains(\" or \")) {\n      return parseUnionType(anchor, type, types, fullRanges, offset);\n    }\n\n    final PyBuiltinCache builtinCache = PyBuiltinCache.getInstance(anchor);\n\n    if (type.equals(\"unknown\")) {\n      return null;\n    }\n    if (type.equals(\"string\")) {\n      PyType t = builtinCache.getStringType(LanguageLevel.forElement(anchor));\n      types.put(whole, t);\n      return t;\n    }\n    if (type.equals(\"str\")) {\n      final PyType t = builtinCache.getStrType();\n      types.put(whole, t);\n      return t;\n    }\n    if (type.equals(\"bytes\")) {\n      final PyType t = builtinCache.getBytesType(LanguageLevel.forElement(anchor));\n      types.put(whole, t);\n      return t;\n    }\n    if (type.equals(\"boolean\")) {\n      final PyType t = builtinCache.getBoolType();\n      types.put(whole, t);\n      return t;\n    }\n    if (type.equals(\"file object\")) {\n      final PyType t = builtinCache.getObjectType(\"file\");\n      types.put(whole, t);\n      return t;\n    }\n    if (type.equals(\"dictionary\")) {\n      final PyType t = builtinCache.getObjectType(\"dict\");\n      types.put(whole, t);\n      return t;\n    }\n    if (type.startsWith(\"dict from\")) {\n      return parseDictFromToType(anchor, type, types, fullRanges, offset);\n    }\n    if (type.equals(\"integer\")) {\n      final PyType t = builtinCache.getIntType();\n      types.put(whole, t);\n      return t;\n    }\n    final Matcher m = PARAMETRIZED_CLASS.matcher(type);\n    if (m.matches()) {\n      final PyType objType = parseObjectType(anchor, m.group(1), builtinCache, types, fullRanges, offset + m.start(1));\n      final PyType elementType = parse(anchor, m.group(2), types, fullRanges, offset + m.start(2));\n      if (objType != null) {\n        if (objType instanceof PyClassType && elementType != null) {\n          return new PyCollectionTypeImpl(((PyClassType)objType).getPyClass(), false, elementType);\n        }\n        return objType;\n      }\n    }\n    return parseObjectType(anchor, type, builtinCache, types, fullRanges, offset);\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PyType parseTupleType(PsiElement anchor, String elementTypeNames) {\n    final List<String> elements = StringUtil.split(elementTypeNames, \",\");\n    PyType[] elementTypes = new PyType[elements.size()];\n    for (int i = 0; i < elementTypes.length; i++) {\n      elementTypes [i] = getTypeByName(anchor, elements.get(i).trim());\n    }\n    return new PyTupleType(anchor, elementTypes);\n  }","id":44179,"modified_method":"@NotNull\n  public static ParseResult parse(PsiElement anchor, String type) {\n    final Map<TextRange, PyType> types = new HashMap<TextRange, PyType>();\n    final Map<PyType, TextRange> fullRanges = new HashMap<PyType, TextRange>();\n    final PyType t = parse(anchor, type, types, fullRanges, 0);\n    return new ParseResult(t, types, fullRanges);\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PyType getTypeByName(PsiElement anchor, String type) {\n    if (type == null) {\n      return null;\n    }\n\n    type = type.trim();\n    if (type.endsWith(\".\")) {\n      type = type.substring(0, type.length()-1);\n    }\n    if (type.equals(\"None\")) {\n      return PyNoneType.INSTANCE;\n    }\n\n    if (type.startsWith(\"(\") && type.endsWith(\")\")) {\n      return parseTupleType(anchor, type.substring(1, type.length()-1));\n    }\n    if (type.contains(\" or \")) {\n      return parseUnionType(anchor, type);\n    }\n\n    final PyBuiltinCache builtinCache = PyBuiltinCache.getInstance(anchor);\n\n    if (type.equals(\"unknown\")) {\n      return null;\n    }\n    if (type.equals(\"string\")) {\n      return builtinCache.getStringType(LanguageLevel.forElement(anchor));\n    }\n    if (type.equals(\"str\")) {\n      return builtinCache.getStrType();\n    }\n    if (type.equals(\"bytes\")) {\n      return builtinCache.getBytesType(LanguageLevel.forElement(anchor));\n    }\n    if (type.equals(\"boolean\")) {\n      return builtinCache.getBoolType();\n    }\n    if (type.equals(\"file object\")) {\n      return builtinCache.getObjectType(\"file\");\n    }\n    if (type.equals(\"dictionary\")) {\n      return builtinCache.getObjectType(\"dict\");\n    }\n    if (type.startsWith(\"dict from\")) {\n      return parseDictType(anchor, type.substring(9).trim());\n    }\n    if (type.equals(\"integer\")) {\n      return builtinCache.getIntType();\n    }\n    final Matcher m = PARAMETRIZED_CLASS.matcher(type);\n    if (m.matches()) {\n      final PyType objType = parseObjectType(anchor, m.group(1), builtinCache);\n      final PyType elementType = getTypeByName(anchor, m.group(2));\n      if (objType != null) {\n        if (objType instanceof PyClassType && elementType != null) {\n          return new PyCollectionTypeImpl(((PyClassType)objType).getPyClass(), false, elementType);\n        }\n        return objType;\n      }\n    }\n    return parseObjectType(anchor, type, builtinCache);\n  }","id":44180,"modified_method":"@Nullable\n  public static PyType getTypeByName(PsiElement anchor, String type) {\n    final ParseResult result = parse(anchor, type);\n    return result.getType();\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PyType parseDictType(PsiElement anchor, String fromToTypeNames) {\n    int pos = fromToTypeNames.indexOf(\" to \");\n    if (pos > 0) {\n      String toTypeName = fromToTypeNames.substring(pos + 4).trim();\n      PyClass dict = PyBuiltinCache.getInstance(anchor).getClass(\"dict\");\n      return new PyCollectionTypeImpl(dict, false, getTypeByName(anchor, toTypeName));\n    }\n    return PyBuiltinCache.getInstance(anchor).getDictType();\n  }","id":44181,"modified_method":"@Nullable\n  private static PyType parseDictFromToType(PsiElement anchor, String type, Map<TextRange, PyType> types,\n                                            Map<PyType, TextRange> fullRanges, int offset) {\n    final Matcher m = DICT_TYPE.matcher(type);\n    PyClassType dict = PyBuiltinCache.getInstance(anchor).getDictType();\n    if (dict != null) {\n      if (m.matches()) {\n        PyType to = parse(anchor, m.group(2), types, fullRanges, offset + m.start(2));\n        return new PyCollectionTypeImpl(dict.getPyClass(), false, to);\n      }\n      return dict;\n    }\n    return null;\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getTypeName(@NotNull PyType type, @NotNull TypeEvalContext context) {\n    if (type instanceof PyTypeReference) {\n      final PyType resolved = ((PyTypeReference)type).resolve(null, context);\n      if (resolved != null) {\n        return getTypeName(resolved, context);\n      }\n      return UNKNOWN;\n    }\n    final String name = type.getName();\n    if (type instanceof PyCollectionType) {\n      final PyType elementType = ((PyCollectionType)type).getElementType(context);\n      if (elementType != null) {\n        return String.format(\"%s of %s\", name, elementType.getName());\n      }\n    }\n    return name;\n  }","id":44182,"modified_method":"public static String getTypeName(@NotNull PyType type, @NotNull final TypeEvalContext context) {\n    if (type instanceof PyTypeReference) {\n    final PyType resolved = ((PyTypeReference)type).resolve(null, context);\n      if (resolved != null) {\n        return getTypeName(resolved, context);\n      }\n      return UNKNOWN;\n    }\n    final String name = type.getName();\n    if (type instanceof PyCollectionType) {\n      final PyType elementType = ((PyCollectionType)type).getElementType(context);\n      if (elementType != null) {\n        return String.format(\"%s of %s\", name, getTypeName(elementType, context));\n      }\n    }\n    if (type instanceof PyUnionType) {\n      return String.format(\"one of (%s)\", StringUtil.join(((PyUnionType)type).getMembers(),\n                                                          new Function<PyType, String>() {\n                                                            @Override\n                                                            public String fun(PyType t) {\n                                                              return getTypeName(t, context);\n                                                            }\n                                                          }, \", \"));\n    }\n    return name;\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected int parseTag(String[] lines, int index, String tagPrefix) {\n    String line = lines[index].trim();\n    int tagEnd = StringUtil.indexOfAny(line, \" \\t:\", 1, line.length());\n    if (tagEnd < 0) return index;\n    String tagName = line.substring(1, tagEnd);\n    String tagValue = line.substring(tagEnd).trim();\n    tagValue = DocstringUtil.unifyDocstring(tagValue);\n    int pos = tagValue.indexOf(':');\n    if (pos < 0) return index;\n    String value = tagValue.substring(pos+1).trim();\n    while(index+1 < lines.length && !lines[index+1].trim().startsWith(tagPrefix)) {\n      index++;\n      value += \" \" + lines[index].trim();\n    }\n    if (pos == 0) {\n      mySimpleTagValues.put(tagName, value);\n    }\n    else {\n      if (\"param\".equals(tagName) || \"parameter\".equals(tagName) ||\n        \"arg\".equals(tagName) || \"argument\".equals(tagName)) {\n        int ws = CharMatcher.anyOf(\" \\t*\").indexIn(tagValue, 1);\n        if (ws != -1) {\n          int next = CharMatcher.anyOf(\" \\t*\").negate().indexIn(tagValue, ws);\n          if (next != -1 && !tagValue.substring(0, next).contains(\":\")) {\n            Map<String, String> argValues = myArgTagValues.get(\"type\");\n            if (argValues == null) {\n              argValues = Maps.newLinkedHashMap();\n              myArgTagValues.put(\"type\", argValues);\n            }\n            CharMatcher identifierMatcher = new CharMatcher() {\n                                        @Override public boolean matches(char c) {\n                                          return Character.isLetterOrDigit(c) || c == '_' || c == '.';\n                                        }}.negate();\n            int endType = identifierMatcher.indexIn(tagValue, 0);\n            int endArg = tagValue.indexOf(':');\n            String arg = tagValue.substring(endType, endArg).trim();\n            argValues.put(arg, tagValue.substring(0, endType).trim());\n            argValues = myArgTagValues.get(tagName);\n            if (argValues == null) {\n              argValues = Maps.newLinkedHashMap();\n              myArgTagValues.put(tagName, argValues);\n            }\n            argValues.put(arg, value);\n            return index;\n          }\n        }\n      }\n      String arg = tagValue.substring(0, pos).trim();\n      Map<String, String> argValues = myArgTagValues.get(tagName);\n      if (argValues == null) {\n        argValues = Maps.newLinkedHashMap();\n        myArgTagValues.put(tagName, argValues);\n      }\n      argValues.put(arg, value);\n    }\n    return index;\n  }","id":44183,"modified_method":"protected int parseTag(String[] lines, int index, String tagPrefix) {\n    String line = lines[index].trim();\n    int tagEnd = StringUtil.indexOfAny(line, \" \\t:\", 1, line.length());\n    if (tagEnd < 0) return index;\n    String tagName = line.substring(1, tagEnd);\n    String tagValue = line.substring(tagEnd).trim();\n    tagValue = DocStringUtil.trimDocString(tagValue);\n    int pos = tagValue.indexOf(':');\n    if (pos < 0) return index;\n    String value = tagValue.substring(pos+1).trim();\n    while(index+1 < lines.length && !lines[index+1].trim().startsWith(tagPrefix)) {\n      index++;\n      value += \" \" + lines[index].trim();\n    }\n    if (pos == 0) {\n      mySimpleTagValues.put(tagName, value);\n    }\n    else {\n      if (\"param\".equals(tagName) || \"parameter\".equals(tagName) ||\n        \"arg\".equals(tagName) || \"argument\".equals(tagName)) {\n        int ws = CharMatcher.anyOf(\" \\t*\").indexIn(tagValue, 1);\n        if (ws != -1) {\n          int next = CharMatcher.anyOf(\" \\t*\").negate().indexIn(tagValue, ws);\n          if (next != -1 && !tagValue.substring(0, next).contains(\":\")) {\n            Map<String, String> argValues = myArgTagValues.get(\"type\");\n            if (argValues == null) {\n              argValues = Maps.newLinkedHashMap();\n              myArgTagValues.put(\"type\", argValues);\n            }\n            CharMatcher identifierMatcher = new CharMatcher() {\n                                        @Override public boolean matches(char c) {\n                                          return Character.isLetterOrDigit(c) || c == '_' || c == '.';\n                                        }}.negate();\n            int endType = identifierMatcher.indexIn(tagValue, 0);\n            int endArg = tagValue.indexOf(':');\n            String arg = tagValue.substring(endType, endArg).trim();\n            argValues.put(arg, tagValue.substring(0, endType).trim());\n            argValues = myArgTagValues.get(tagName);\n            if (argValues == null) {\n              argValues = Maps.newLinkedHashMap();\n              myArgTagValues.put(tagName, argValues);\n            }\n            argValues.put(arg, value);\n            return index;\n          }\n        }\n      }\n      String arg = tagValue.substring(0, pos).trim();\n      Map<String, String> argValues = myArgTagValues.get(tagName);\n      if (argValues == null) {\n        argValues = Maps.newLinkedHashMap();\n        myArgTagValues.put(tagName, argValues);\n      }\n      argValues.put(arg, value);\n    }\n    return index;\n  }","commit_id":"360da2c89afef87aa2f97061ab61fea9b5db7f19","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n    if (newElementName.startsWith(AndroidResourceUtil.NEW_ID_PREFIX)) {\n      newElementName = AndroidResourceUtil.getResourceNameByReferenceText(newElementName);\n    }\n    ResourceValue value = myValue.getValue();\n    assert value != null;\n    String resType = value.getResourceType();\n    if (resType != null && newElementName != null) {\n      myValue.setValue(ResourceValue.referenceTo(value.getPrefix(), value.getPackage(), resType,\n                                                 AndroidCommonUtils.getResourceName(resType, newElementName)));\n    }\n    return myValue.getXmlTag();\n  }","id":44184,"modified_method":"@Override\n  public PsiElement handleElementRename(String newElementName) throws IncorrectOperationException {\n    if (newElementName.startsWith(AndroidResourceUtil.NEW_ID_PREFIX)) {\n      newElementName = AndroidResourceUtil.getResourceNameByReferenceText(newElementName);\n    }\n    ResourceValue value = myValue.getValue();\n    assert value != null;\n    String resType = value.getResourceType();\n\n    if (resType != null && newElementName != null) {\n      // todo: do not allow new value resource name to contain dot, because it is impossible to check if it file or value otherwise\n\n      final String newResName = newElementName.contains(\".\") // it is file\n                                ? AndroidCommonUtils.getResourceName(resType, newElementName)\n                                : newElementName;\n      myValue.setValue(ResourceValue.referenceTo(value.getPrefix(), value.getPackage(), resType, newResName));\n    }\n    return myValue.getXmlTag();\n  }","commit_id":"2f1bc8b1b4f145ca6682d80e8772043382c5872a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean containsAddTemplatePermission(\n\t\t\tPermissionChecker permissionChecker, long groupId, long classNameId,\n\t\t\tlong resourceClassNameId)\n\t\tthrows PortalException {\n\n\t\tServiceWrapper<DDMTemplatePermissionSupport>\n\t\t\ttemplatePermissionSupportServiceWrapper =\n\t\t\t\t_ddmPermissionSupportTracker.\n\t\t\t\t\tgetDDMTemplatePermissionSupportServiceWrapper(\n\t\t\t\t\t\tresourceClassNameId);\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tgroupId,\n\t\t\tgetResourceName(\n\t\t\t\ttemplatePermissionSupportServiceWrapper, classNameId),\n\t\t\tgroupId,\n\t\t\tgetAddTemplateActionId(templatePermissionSupportServiceWrapper));\n\t}","id":44185,"modified_method":"public static boolean containsAddTemplatePermission(\n\t\t\tPermissionChecker permissionChecker, long groupId, long classNameId,\n\t\t\tlong resourceClassNameId)\n\t\tthrows PortalException {\n\n\t\tServiceWrapper<DDMTemplatePermissionSupport>\n\t\t\ttemplatePermissionSupportServiceWrapper =\n\t\t\t\t_ddmPermissionSupportTracker.\n\t\t\t\t\tgetDDMTemplatePermissionSupportServiceWrapper(\n\t\t\t\t\t\tresourceClassNameId);\n\n\t\tString resourceName = getResourceName(\n\t\t\ttemplatePermissionSupportServiceWrapper, classNameId);\n\n\t\tboolean portletResource =\n\t\t\tResourceActionsUtil.getPortletNames().contains(resourceName);\n\n\t\tif (portletResource) {\n\t\t\treturn PortletPermissionUtil.contains(\n\t\t\t\tpermissionChecker, groupId, null, resourceName,\n\t\t\t\tgetAddTemplateActionId(\n\t\t\t\t\ttemplatePermissionSupportServiceWrapper));\n\t\t}\n\n\t\treturn permissionChecker.hasPermission(\n\t\t\tgroupId, resourceName, groupId,\n\t\t\tgetAddTemplateActionId(templatePermissionSupportServiceWrapper));\n\t}","commit_id":"319cd0b7a9a244a5cc0c617433cd86209eca4694","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    protected String getResourceName(InjectionPoint injectionPoint) {\n        return getEJBResourceName(injectionPoint, super.getResourceName(injectionPoint));\n    }","id":44186,"modified_method":"@Override\n    protected String getResourceName(InjectionPoint injectionPoint) {\n        Resource resource = injectionPoint.getAnnotated().getAnnotation(Resource.class);\n        String mappedName = resource.mappedName();\n        String lookup = resource.lookup();\n        if (!lookup.isEmpty()) {\n            return lookup;\n        }\n        if (!mappedName.isEmpty()) {\n            return mappedName;\n        }\n        String proposedName = super.getResourceName(injectionPoint);\n        return getEJBResourceName(injectionPoint, proposedName);\n    }","commit_id":"1e9bbf872675c81df08825a7c6e86e83b41e7f6e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Clusterable\n\tpublic void pause(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\tupdateMemoryClusteredJob(\n\t\t\t\t\tjobName, groupName, TriggerState.PAUSED);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to pause job {jobName=\" + jobName + \", groupName=\" +\n\t\t\t\t\tgroupName + \"}\",\n\t\t\t\te);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.pause(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44187,"modified_method":"@Clusterable\n\tpublic void pause(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\t\tupdateMemoryClusteredJob(\n\t\t\t\t\tjobName, groupName, TriggerState.PAUSED);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_schedulerEngine.pause(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processClusterEvent(ClusterEvent clusterEvent) {\n\t\t\ttry {\n\t\t\t\tLock lock = updateMemorySchedulerClusterMaster();\n\n\t\t\t\tisMemorySchedulerClusterLockOwner(lock);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to update memory scheduler cluster lock\", e);\n\t\t\t}\n\t\t}","id":44188,"modified_method":"public void processClusterEvent(ClusterEvent clusterEvent) {\n\t\t\ttry {\n\t\t\t\tgetMasterAddressString();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to update memory scheduler cluster lock\", e);\n\t\t\t}\n\t\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void initialize() throws SchedulerException {\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n\t\t\t_readLock = readWriteLock.readLock();\n\t\t\t_writeLock = readWriteLock.writeLock();\n\n\t\t\t_localClusterNodeAddress = getSerializedString(\n\t\t\t\tClusterExecutorUtil.getLocalClusterNodeAddress());\n\n\t\t\t_clusterEventListener = new MemorySchedulerClusterEventListener();\n\n\t\t\tClusterExecutorUtil.addClusterEventListener(_clusterEventListener);\n\n\t\t\tif (!isMemorySchedulerClusterLockOwner(\n\t\t\t\t\tlockMemorySchedulerCluster(null))) {\n\n\t\t\t\tinitMemoryClusteredJobs();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\"Unable to initialize scheduler\", e);\n\t\t}\n\t}","id":44189,"modified_method":"public void initialize() throws SchedulerException {\n\t\ttry {\n\t\t\tReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n\t\t\t_readLock = readWriteLock.readLock();\n\t\t\t_writeLock = readWriteLock.writeLock();\n\n\t\t\t_localClusterNodeAddress = getSerializedString(\n\t\t\t\tClusterExecutorUtil.getLocalClusterNodeAddress());\n\n\t\t\t_clusterEventListener = new MemorySchedulerClusterEventListener();\n\n\t\t\tClusterExecutorUtil.addClusterEventListener(_clusterEventListener);\n\n\t\t\tString masterAddressString = getMasterAddressString();\n\n\t\t\tboolean master = _localClusterNodeAddress.equals(\n\t\t\t\tmasterAddressString);\n\n\t\t\tif (!master) {\n\t\t\t\tList<SchedulerResponse> schedulerResponses = callMaster(\n\t\t\t\t\tmasterAddressString, _getScheduledJobsMethodKey3,\n\t\t\t\t\tStorageType.MEMORY_CLUSTERED);\n\n\t\t\t\tinitMemoryClusteredJobs(schedulerResponses);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\"Unable to initialize scheduler\", e);\n\t\t}\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Clusterable\n\tpublic void unschedule(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\t_memoryClusteredJobs.remove(getFullName(jobName, groupName));\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to unschedule job {jobName=\" + jobName +\n\t\t\t\t\t\", groupName=\" + groupName + \"}\",\n\t\t\t\te);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.unschedule(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44190,"modified_method":"@Clusterable\n\tpublic void unschedule(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\t\t_memoryClusteredJobs.remove(getFullName(jobName, groupName));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_schedulerEngine.unschedule(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Clusterable\n\tpublic void resume(String groupName) throws SchedulerException {\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\tupdateMemoryClusteredJobs(groupName, TriggerState.NORMAL);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to resume jobs in group \" + groupName, e);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.resume(groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44191,"modified_method":"@Clusterable\n\tpublic void resume(String groupName) throws SchedulerException {\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\t\tupdateMemoryClusteredJobs(groupName, TriggerState.NORMAL);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_schedulerEngine.resume(groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Clusterable\n\tpublic void resume(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\tupdateMemoryClusteredJob(\n\t\t\t\t\tjobName, groupName, TriggerState.NORMAL);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to resume job {jobName=\" + jobName + \", groupName=\" +\n\t\t\t\t\tgroupName + \"}\",\n\t\t\t\te);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.resume(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44192,"modified_method":"@Clusterable\n\tpublic void resume(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\t\tupdateMemoryClusteredJob(\n\t\t\t\t\tjobName, groupName, TriggerState.NORMAL);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_schedulerEngine.resume(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Object getDeserializedObject(String string) throws Exception {\n\t\tbyte[] bytes = Base64.decode(string);\n\n\t\tUnsyncByteArrayInputStream byteArrayInputStream =\n\t\t\tnew UnsyncByteArrayInputStream(bytes);\n\n\t\tObjectInputStream objectInputStream = new ObjectInputStream(\n\t\t\tbyteArrayInputStream);\n\n\t\tObject object = objectInputStream.readObject();\n\n\t\tobjectInputStream.close();\n\n\t\treturn object;\n\t}","id":44193,"modified_method":"protected Object getDeserializedObject(String string)\n\t\tthrows SchedulerException {\n\n\t\tbyte[] bytes = Base64.decode(string);\n\n\t\tUnsyncByteArrayInputStream byteArrayInputStream =\n\t\t\tnew UnsyncByteArrayInputStream(bytes);\n\n\t\tObjectInputStream objectInputStream = null;\n\n\t\ttry {\n\t\t\tobjectInputStream = new ObjectInputStream(byteArrayInputStream);\n\n\t\t\tObject object = objectInputStream.readObject();\n\n\t\t\treturn object;\n\t\t}\n\t\tcatch(Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to deserialize object from \" + string, e);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tobjectInputStream.close();\n\t\t\t}\n\t\t\tcatch(Exception e) {\n\t\t\t}\n\t\t}\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<SchedulerResponse> getScheduledJobs(String groupName)\n\t\tthrows SchedulerException {\n\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\treturn (List<SchedulerResponse>)callMaster(\n\t\t\t\t\t_getScheduledJobsMethodKey2, groupName);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to get jobs in group \" + groupName, e);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\treturn _schedulerEngine.getScheduledJobs(groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\t}","id":44194,"modified_method":"public List<SchedulerResponse> getScheduledJobs(String groupName)\n\t\tthrows SchedulerException {\n\n\t\tStorageType storageType = getStorageType(groupName);\n\n\t\tif (storageType.equals(StorageType.MEMORY_CLUSTERED)) {\n\t\t\tString masterAddressString = getMasterAddressString();\n\n\t\t\tboolean master = _localClusterNodeAddress.equals(\n\t\t\t\tmasterAddressString);\n\n\t\t\tif (!master) {\n\t\t\t\treturn callMaster(\n\t\t\t\t\tmasterAddressString, _getScheduledJobsMethodKey2,\n\t\t\t\t\tgroupName);\n\t\t\t}\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\treturn _schedulerEngine.getScheduledJobs(groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Clusterable\n\tpublic void suppressError(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to suppress error for job {jobName=\" + jobName +\n\t\t\t\t\t\", groupName=\" + groupName + \"}\",\n\t\t\t\te);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.suppressError(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44195,"modified_method":"@Clusterable\n\tpublic void suppressError(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\treturn;\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.suppressError(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getSerializedString(Object object) throws Exception {\n\t\tUnsyncByteArrayOutputStream byteArrayOutputStream =\n\t\t\tnew UnsyncByteArrayOutputStream();\n\n\t\tObjectOutputStream objectOutputStream = new ObjectOutputStream(\n\t\t\tbyteArrayOutputStream);\n\n\t\tobjectOutputStream.writeObject(object);\n\t\tobjectOutputStream.close();\n\n\t\tbyte[] bytes = byteArrayOutputStream.toByteArray();\n\n\t\treturn Base64.encode(bytes);\n\t}","id":44196,"modified_method":"protected void initMemoryClusteredJobs(\n\t\t\tList<SchedulerResponse> schedulerResponses)\n\t\tthrows Exception {\n\n\t\tfor (SchedulerResponse schedulerResponse : schedulerResponses) {\n\t\t\tTrigger oldTrigger = schedulerResponse.getTrigger();\n\n\t\t\tString jobName = schedulerResponse.getJobName();\n\t\t\tString groupName = SchedulerEngineUtil.namespaceGroupName(\n\t\t\t\tschedulerResponse.getGroupName(), StorageType.MEMORY_CLUSTERED);\n\n\t\t\tTrigger newTrigger = TriggerFactoryUtil.buildTrigger(\n\t\t\t\toldTrigger.getTriggerType(), jobName, groupName,\n\t\t\t\toldTrigger.getStartDate(), oldTrigger.getEndDate(),\n\t\t\t\toldTrigger.getTriggerContent());\n\n\t\t\tschedulerResponse.setTrigger(newTrigger);\n\n\t\t\tTriggerState triggerState = SchedulerEngineUtil.getJobState(\n\t\t\t\tschedulerResponse);\n\n\t\t\tMessage message = schedulerResponse.getMessage();\n\n\t\t\tmessage.remove(JOB_STATE);\n\n\t\t\t_memoryClusteredJobs.put(\n\t\t\t\tgetFullName(jobName, groupName),\n\t\t\t\tnew ObjectValuePair<SchedulerResponse, TriggerState>(\n\t\t\t\t\tschedulerResponse, triggerState));\n\t\t}\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SchedulerResponse getScheduledJob(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn null;\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\treturn (SchedulerResponse)callMaster(\n\t\t\t\t\t_getScheduledJobMethodKey, jobName, groupName);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to get job {jobName=\" + jobName + \", groupName=\" +\n\t\t\t\t\tgroupName + \"}\",\n\t\t\t\te);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\treturn _schedulerEngine.getScheduledJob(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\t}","id":44197,"modified_method":"public SchedulerResponse getScheduledJob(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tStorageType storageType = getStorageType(groupName);\n\n\t\tif (storageType.equals(StorageType.MEMORY_CLUSTERED)) {\n\t\t\tString masterAddressString = getMasterAddressString();\n\n\t\t\tboolean master = _localClusterNodeAddress.equals(\n\t\t\t\tmasterAddressString);\n\n\t\t\tif (!master) {\n\t\t\t\treturn (SchedulerResponse)callMaster(\n\t\t\t\t\tmasterAddressString, _getScheduledJobMethodKey, jobName,\n\t\t\t\t\tgroupName);\n\t\t\t}\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\treturn _schedulerEngine.getScheduledJob(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Lock updateMemorySchedulerClusterMaster() throws SchedulerException {\n\t\ttry {\n\t\t\tLock lock = lockMemorySchedulerCluster(null);\n\n\t\t\tAddress address = (Address)getDeserializedObject(lock.getOwner());\n\n\t\t\tif (ClusterExecutorUtil.isClusterNodeAlive(address)) {\n\t\t\t\treturn lock;\n\t\t\t}\n\n\t\t\treturn lockMemorySchedulerCluster(lock.getOwner());\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to update memory scheduler cluster master\", e);\n\t\t}\n\t}","id":44198,"modified_method":"public Lock updateMemorySchedulerClusterMaster() throws SchedulerException {\n\t\tgetMasterAddressString();\n\n\t\treturn null;\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Clusterable\n\tpublic void schedule(\n\t\t\tTrigger trigger, String description, String destinationName,\n\t\t\tMessage message)\n\t\tthrows SchedulerException {\n\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\tString groupName = trigger.getGroupName();\n\t\tString jobName = trigger.getJobName();\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\tSchedulerResponse schedulerResponse = new SchedulerResponse();\n\n\t\t\t\tschedulerResponse.setDescription(description);\n\t\t\t\tschedulerResponse.setDestinationName(destinationName);\n\t\t\t\tschedulerResponse.setGroupName(groupName);\n\t\t\t\tschedulerResponse.setJobName(jobName);\n\t\t\t\tschedulerResponse.setMessage(message);\n\t\t\t\tschedulerResponse.setTrigger(trigger);\n\n\t\t\t\t_memoryClusteredJobs.put(\n\t\t\t\t\tgetFullName(jobName, groupName),\n\t\t\t\t\tnew ObjectValuePair<SchedulerResponse, TriggerState>(\n\t\t\t\t\t\tschedulerResponse, TriggerState.NORMAL));\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to schedule job {jobName=\" + jobName + \", groupName=\" +\n\t\t\t\t\tgroupName + \"}\",\n\t\t\t\te);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.schedule(\n\t\t\t\ttrigger, description, destinationName, message);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44199,"modified_method":"@Clusterable\n\tpublic void schedule(\n\t\t\tTrigger trigger, String description, String destinationName,\n\t\t\tMessage message)\n\t\tthrows SchedulerException {\n\n\t\tString groupName = trigger.getGroupName();\n\t\tString jobName = trigger.getJobName();\n\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\t\tSchedulerResponse schedulerResponse = new SchedulerResponse();\n\n\t\t\t\tschedulerResponse.setDescription(description);\n\t\t\t\tschedulerResponse.setDestinationName(destinationName);\n\t\t\t\tschedulerResponse.setGroupName(groupName);\n\t\t\t\tschedulerResponse.setJobName(jobName);\n\t\t\t\tschedulerResponse.setMessage(message);\n\t\t\t\tschedulerResponse.setTrigger(trigger);\n\n\t\t\t\t_memoryClusteredJobs.put(\n\t\t\t\t\tgetFullName(jobName, groupName),\n\t\t\t\t\tnew ObjectValuePair<SchedulerResponse, TriggerState>(\n\t\t\t\t\t\tschedulerResponse, TriggerState.NORMAL));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_schedulerEngine.schedule(\n\t\t\t\ttrigger, description, destinationName, message);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<SchedulerResponse> getScheduledJobs()\n\t\tthrows SchedulerException {\n\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave()) {\n\t\t\t\treturn (List<SchedulerResponse>)callMaster(\n\t\t\t\t\t_getScheduledJobsMethodKey1);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\"Unable to get jobs\", e);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\treturn _schedulerEngine.getScheduledJobs();\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\t}","id":44200,"modified_method":"public List<SchedulerResponse> getScheduledJobs()\n\t\tthrows SchedulerException {\n\n\t\tString masterAddressString = getMasterAddressString();\n\t\tboolean master = _localClusterNodeAddress.equals(masterAddressString);\n\n\t\tif (!master) {\n\t\t\treturn callMaster(masterAddressString, _getScheduledJobsMethodKey1);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\treturn _schedulerEngine.getScheduledJobs();\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void shutdown() throws SchedulerException {\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tClusterExecutorUtil.removeClusterEventListener(\n\t\t\t\t_clusterEventListener);\n\n\t\t\tLockLocalServiceUtil.unlock(\n\t\t\t\t_LOCK_CLASS_NAME, _LOCK_CLASS_NAME, _localClusterNodeAddress,\n\t\t\t\tPropsValues.MEMORY_CLUSTER_SCHEDULER_LOCK_CACHE_ENABLED);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\"Unable to shutdown scheduler\", e);\n\t\t}\n\n\t\t_schedulerEngine.shutdown();\n\t}","id":44201,"modified_method":"public void shutdown() throws SchedulerException {\n\t\ttry {\n\t\t\tClusterExecutorUtil.removeClusterEventListener(\n\t\t\t\t_clusterEventListener);\n\n\t\t\tLockLocalServiceUtil.unlock(\n\t\t\t\t_LOCK_CLASS_NAME, _LOCK_CLASS_NAME, _localClusterNodeAddress,\n\t\t\t\tPropsValues.MEMORY_CLUSTER_SCHEDULER_LOCK_CACHE_ENABLED);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\"Unable to shutdown scheduler\", e);\n\t\t}\n\n\t\t_schedulerEngine.shutdown();\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Clusterable\n\tpublic void delete(String groupName) throws SchedulerException {\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\tremoveMemoryClusteredJobs(groupName);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to delete jobs in group \" + groupName, e);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.delete(groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44202,"modified_method":"@Clusterable\n\tpublic void delete(String groupName) throws SchedulerException {\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\t\tremoveMemoryClusteredJobs(groupName);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_schedulerEngine.delete(groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Clusterable\n\tpublic void pause(String groupName) throws SchedulerException {\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\tupdateMemoryClusteredJobs(groupName, TriggerState.PAUSED);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to pause jobs in group \" + groupName, e);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.pause(groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44203,"modified_method":"@Clusterable\n\tpublic void pause(String groupName) throws SchedulerException {\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\t\tupdateMemoryClusteredJobs(groupName, TriggerState.PAUSED);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_schedulerEngine.pause(groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Clusterable\n\tpublic void update(Trigger trigger) throws SchedulerException {\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\tString jobName = trigger.getJobName();\n\t\tString groupName = trigger.getGroupName();\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\tfor (ObjectValuePair<SchedulerResponse, TriggerState>\n\t\t\t\t\t\tmemoryClusteredJob : _memoryClusteredJobs.values()) {\n\n\t\t\t\t\tSchedulerResponse schedulerResponse =\n\t\t\t\t\t\tmemoryClusteredJob.getKey();\n\n\t\t\t\t\tif (jobName.equals(schedulerResponse.getJobName()) &&\n\t\t\t\t\t\tgroupName.equals(schedulerResponse.getGroupName())) {\n\n\t\t\t\t\t\tschedulerResponse.setTrigger(trigger);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new Exception(\n\t\t\t\t\t\"Unable to update trigger for memory clustered job\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to update job {jobName=\" + jobName + \", groupName=\" +\n\t\t\t\t\tgroupName + \"}\",\n\t\t\t\te);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.update(trigger);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44204,"modified_method":"@Clusterable\n\tpublic void update(Trigger trigger) throws SchedulerException {\n\t\tString jobName = trigger.getJobName();\n\t\tString groupName = trigger.getGroupName();\n\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\t\tfor (ObjectValuePair<SchedulerResponse, TriggerState>\n\t\t\t\t\t\tmemoryClusteredJob : _memoryClusteredJobs.values()) {\n\n\t\t\t\t\tSchedulerResponse schedulerResponse =\n\t\t\t\t\t\tmemoryClusteredJob.getKey();\n\n\t\t\t\t\tif (jobName.equals(schedulerResponse.getJobName()) &&\n\t\t\t\t\t\tgroupName.equals(schedulerResponse.getGroupName())) {\n\n\t\t\t\t\t\tschedulerResponse.setTrigger(trigger);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthrow new SchedulerException(\n\t\t\t\t\t\"Unable to update trigger for memory clustered job\");\n\t\t\t}\n\n\t\t\t_schedulerEngine.update(trigger);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void start() throws SchedulerException {\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\t_schedulerEngine.start();\n\t}","id":44205,"modified_method":"public void start() throws SchedulerException {\n\t\t_schedulerEngine.start();\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Clusterable\n\tpublic void delete(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\t_memoryClusteredJobs.remove(getFullName(jobName, groupName));\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to delete job {jobName=\" + jobName + \", groupName=\" +\n\t\t\t\t\tgroupName + \"}\",\n\t\t\t\te);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.delete(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44206,"modified_method":"@Clusterable\n\tpublic void delete(String jobName, String groupName)\n\t\tthrows SchedulerException {\n\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\t\t_memoryClusteredJobs.remove(getFullName(jobName, groupName));\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_schedulerEngine.delete(jobName, groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isMemorySchedulerSlave(String groupName)\n\t\tthrows Exception {\n\n\t\tif (groupName != null) {\n\t\t\tStorageType storageType = getStorageType(groupName);\n\n\t\t\tif (!storageType.equals(StorageType.MEMORY_CLUSTERED)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tLock lock = lockMemorySchedulerCluster(null);\n\n\t\tif (isMemorySchedulerClusterLockOwner(lock)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","id":44207,"modified_method":"protected boolean isMemoryClusteredSlaveJob(String groupName)\n\t\tthrows SchedulerException {\n\n\t\tStorageType storageType = getStorageType(groupName);\n\n\t\tif (!storageType.equals(StorageType.MEMORY_CLUSTERED)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString masterAddressString = getMasterAddressString();\n\n\t\tboolean master = _localClusterNodeAddress.equals(masterAddressString);\n\n\t\tif (master) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Clusterable\n\tpublic void unschedule(String groupName) throws SchedulerException {\n\t\tif (!PropsValues.SCHEDULER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (isMemorySchedulerSlave(groupName)) {\n\t\t\t\tremoveMemoryClusteredJobs(groupName);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to unschedule jobs in group \" + groupName, e);\n\t\t}\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\t_schedulerEngine.unschedule(groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","id":44208,"modified_method":"@Clusterable\n\tpublic void unschedule(String groupName) throws SchedulerException {\n\t\tboolean isMemoryClusteredSlaveJob = isMemoryClusteredSlaveJob(\n\t\t\tgroupName);\n\n\t\t_readLock.lock();\n\n\t\ttry {\n\t\t\tif (isMemoryClusteredSlaveJob) {\n\t\t\t\tremoveMemoryClusteredJobs(groupName);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_schedulerEngine.unschedule(groupName);\n\t\t}\n\t\tfinally {\n\t\t\t_readLock.unlock();\n\t\t}\n\n\t\tskipClusterInvoking(groupName);\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static SchedulerEngine createClusterSchedulerEngine(\n\t\tSchedulerEngine schedulerEngine) {\n\n\t\tif (PropsValues.CLUSTER_LINK_ENABLED) {\n\t\t\tschedulerEngine = new ClusterSchedulerEngine(schedulerEngine);\n\t\t}\n\n\t\treturn schedulerEngine;\n\t}","id":44209,"modified_method":"public static SchedulerEngine createClusterSchedulerEngine(\n\t\tSchedulerEngine schedulerEngine) {\n\n\t\tif (PropsValues.CLUSTER_LINK_ENABLED && PropsValues.SCHEDULER_ENABLED) {\n\t\t\tschedulerEngine = new ClusterSchedulerEngine(schedulerEngine);\n\t\t}\n\n\t\treturn schedulerEngine;\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Object callMaster(MethodKey methodKey, Object... arguments)\n\t\tthrows Exception {\n\n\t\tMethodHandler methodHandler = new MethodHandler(methodKey, arguments);\n\n\t\tLock lock = updateMemorySchedulerClusterMaster();\n\n\t\tAddress address = (Address)getDeserializedObject(lock.getOwner());\n\n\t\tif (address.equals(ClusterExecutorUtil.getLocalClusterNodeAddress())) {\n\t\t\tif (methodKey == _getScheduledJobsMethodKey3) {\n\t\t\t\treturn methodHandler.invoke(false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn methodHandler.invoke(schedulerEngine);\n\t\t\t}\n\t\t}\n\n\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\tmethodHandler, address);\n\n\t\tclusterRequest.setBeanIdentifier(_beanIdentifier);\n\n\t\tFutureClusterResponses futureClusterResponses =\n\t\t\tClusterExecutorUtil.execute(clusterRequest);\n\n\t\ttry {\n\t\t\tClusterNodeResponses clusterNodeResponses =\n\t\t\t\tfutureClusterResponses.get(20, TimeUnit.SECONDS);\n\n\t\t\tClusterNodeResponse clusterNodeResponse =\n\t\t\t\tclusterNodeResponses.getClusterResponse(address);\n\n\t\t\treturn clusterNodeResponse.getResult();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to load scheduled jobs from cluster node \" +\n\t\t\t\t\taddress.getDescription(),\n\t\t\t\te);\n\t\t}\n\t}","id":44210,"modified_method":"protected <T> T callMaster(\n\t\t\tString masterAddressString, MethodKey methodKey,\n\t\t\tObject... arguments)\n\t\tthrows SchedulerException {\n\n\t\tMethodHandler methodHandler = new MethodHandler(methodKey, arguments);\n\n\t\tAddress address = (Address)getDeserializedObject(masterAddressString);\n\n\t\tClusterRequest clusterRequest = ClusterRequest.createUnicastRequest(\n\t\t\tmethodHandler, address);\n\n\t\tclusterRequest.setBeanIdentifier(_beanIdentifier);\n\n\t\ttry {\n\t\t\tFutureClusterResponses futureClusterResponses =\n\t\t\t\tClusterExecutorUtil.execute(clusterRequest);\n\n\t\t\tClusterNodeResponses clusterNodeResponses =\n\t\t\t\tfutureClusterResponses.get(20, TimeUnit.SECONDS);\n\n\t\t\tClusterNodeResponse clusterNodeResponse =\n\t\t\t\tclusterNodeResponses.getClusterResponse(address);\n\n\t\t\treturn (T)clusterNodeResponse.getResult();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(\n\t\t\t\t\"Unable to load scheduled jobs from cluster node \" +\n\t\t\t\t\taddress.getDescription(),\n\t\t\t\te);\n\t\t}\n\t}","commit_id":"c47d5a3e426d1bf12f85c89ec53cc073afda20f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void customizeComponents() {\n        Gst.init();\n        progressSlider.addChangeListener(new ChangeListener() {\n\n            /**\n             * Should always try to synchronize any call to\n             * progressSlider.setValue() to avoid a different thread\n             * changing playbin while stateChanged() is processing\n             */\n            @Override\n            public void stateChanged(ChangeEvent e) {\n                int time = progressSlider.getValue();\n                if(playbin2 != null && !autoTracking) {\n                    State orig = playbin2.getState();\n                    playbin2.pause();\n                    playbin2.seek(ClockTime.fromMillis(time));\n                    playbin2.setState(orig);\n                }\n            }\n\n        });\n    }","id":44211,"modified_method":"private void customizeComponents() {\n        Gst.init();\n        progressSlider.addChangeListener(new ChangeListener() {\n\n            /**\n             * Should always try to synchronize any call to\n             * progressSlider.setValue() to avoid a different thread\n             * changing playbin while stateChanged() is processing\n             */\n            @Override\n            public void stateChanged(ChangeEvent e) {\n                int time = progressSlider.getValue();\n                synchronized(playbinLock) {\n                    if(playbin2 != null && !autoTracking) {\n                        State orig = playbin2.getState();\n                        playbin2.pause();\n                        playbin2.seek(ClockTime.fromMillis(time));\n                        playbin2.setState(orig);\n                    }\n                }\n            }\n\n        });\n    }","commit_id":"1f797d675caefde1853038036209d8090a6e49bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void reset() {\n        synchronized(lock) {\n            if(playbin2 != null) {\n                if(playbin2.isPlaying()) {\n                    playbin2.stop();\n                }\n                playbin2.setState(State.NULL);\n//                try {\n//                    Thread.sleep(20); // gstreamer needs to catch up\n//                } catch (InterruptedException ex) { }\n                if(playbin2.getState().equals(State.NULL)) {\n                    playbin2.dispose();\n                }\n                playbin2 = null;\n            }\n            videoComponent = null;\n        }\n    }","id":44212,"modified_method":"private void reset() {\n        synchronized(playbinLock) {\n            if(playbin2 != null) {\n                if(playbin2.isPlaying()) {\n                    playbin2.stop();\n                }\n                playbin2.setState(State.NULL);\n//                try {\n//                    Thread.sleep(20); // gstreamer needs to catch up\n//                } catch (InterruptedException ex) { }\n                if(playbin2.getState().equals(State.NULL)) {\n                    playbin2.dispose();\n                }\n                playbin2 = null;\n            }\n            videoComponent = null;\n        }\n    }","commit_id":"1f797d675caefde1853038036209d8090a6e49bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Initialize all the necessary vars to play a video/audio file.\n     * @param file the File to play\n     */\n    private void setupVideo(File file) {\n        java.io.File ioFile = getJFile(file);\n        \n        pauseButton.setText(\"►\");\n        synchronized(lock) { // defensive programming\n            progressSlider.setValue(0);\n        }\n        \n        playbin2 = new PlayBin2(\"VideoPlayer\");\n        videoComponent = new VideoComponent();\n        playbin2.setVideoSink(videoComponent.getElement());\n        \n        videoPanel.removeAll();\n        videoPanel.setLayout(new BoxLayout(videoPanel, BoxLayout.Y_AXIS));\n        videoPanel.add(videoComponent);\n        videoPanel.revalidate();\n        videoPanel.repaint();\n        \n        playbin2.setInputFile(ioFile);\n        \n        setComponentsVisibility(true);\n        playbin2.setState(State.READY);\n    }","id":44213,"modified_method":"/**\n     * Initialize all the necessary vars to play a video/audio file.\n     * @param file the File to play\n     */\n    private void setupVideo(File file) {\n        java.io.File ioFile = getJFile(file);\n        \n        pauseButton.setText(\"►\");\n        progressSlider.setValue(0);\n        \n        videoComponent = new VideoComponent();\n        synchronized(playbinLock) {\n            playbin2 = new PlayBin2(\"VideoPlayer\");\n            playbin2.setVideoSink(videoComponent.getElement());\n        }\n        \n        videoPanel.removeAll();\n        videoPanel.setLayout(new BoxLayout(videoPanel, BoxLayout.Y_AXIS));\n        videoPanel.add(videoComponent);\n        videoPanel.revalidate();\n        videoPanel.repaint();\n        \n        synchronized(playbinLock) {\n            playbin2.setInputFile(ioFile);\n            playbin2.setState(State.READY);\n        }\n        setComponentsVisibility(true);\n    }","commit_id":"1f797d675caefde1853038036209d8090a6e49bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void play() {\n            if (jFile == null || !jFile.exists()) {\n                progressLabel.setText(\"Error buffering file\");\n                return;\n            }\n            playbin2.play(); // must play, then pause and get state to get duration.\n            playbin2.pause();\n            playbin2.getState();\n            String duration = playbin2.queryDuration().toString();\n            durationMillis = playbin2.queryDuration().toMillis();\n            progressSlider.setMaximum((int)durationMillis);\n            progressSlider.setMinimum(0);\n            final String finalDuration;\n            if(duration.length() == 8 && duration.substring(0,3).equals(\"00:\")) {\n                finalDuration = duration.substring(3);\n                progressLabel.setText(\"00:00/\" + duration);\n            } else {\n                finalDuration = duration;\n                progressLabel.setText(\"00:00:00/\" + duration);\n            }\n            playbin2.play();\n            pauseButton.setText(\"||\");\n            new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    long positionMillis = 0;\n                    while (positionMillis < durationMillis\n                            && playbin2 != null\n                            && !playbin2.getState().equals(State.NULL)) {\n                        String position = playbin2.queryPosition().toString();\n                        positionMillis = playbin2.queryPosition().toMillis();\n                        if (position.length() == 8) {\n                            position = position.substring(3);\n                        }\n                        progressLabel.setText(position + \"/\" + finalDuration);\n                        synchronized(lock) { // defensive programming\n                            autoTracking = true;\n                            progressSlider.setValue((int) positionMillis);\n                            autoTracking = false;\n                        }\n                        try {\n                            Thread.sleep(20);\n                        } catch (InterruptedException ex) {\n                        }\n                    }\n                    if (finalDuration.length() == 5) {\n                        progressLabel.setText(\"00:00/\" + finalDuration);\n                    } else {\n                        progressLabel.setText(\"00:00:00/\" + finalDuration);\n                    }\n                    // If it reaches the end\n                    if(progressSlider.getValue() == progressSlider.getMaximum()) {\n                        restartVideo();\n                    }\n                }\n                \n                public void restartVideo() {\n                    synchronized(lock) {\n                        if (playbin2 != null) {\n                            playbin2.stop();\n                            playbin2.setState(State.READY); // ready to be played again\n                            pauseButton.setText(\"►\");\n                            progressSlider.setValue(0);\n                        }\n                    }\n                }\n            }).start();\n        }","id":44214,"modified_method":"private void play() {\n            if (jFile == null || !jFile.exists()) {\n                progressLabel.setText(\"Error buffering file\");\n                return;\n            }\n            synchronized(playbinLock) {\n                playbin2.play(); // must play, then pause and get state to get duration.\n                playbin2.pause();\n                playbin2.getState();\n                duration = playbin2.queryDuration().toString();\n                durationMillis = playbin2.queryDuration().toMillis();\n            }\n            progressSlider.setMaximum((int)durationMillis);\n            progressSlider.setMinimum(0);\n            final String finalDuration;\n            if(duration.length() == 8 && duration.substring(0,3).equals(\"00:\")) {\n                finalDuration = duration.substring(3);\n                progressLabel.setText(\"00:00/\" + duration);\n            } else {\n                finalDuration = duration;\n                progressLabel.setText(\"00:00:00/\" + duration);\n            }\n            synchronized(playbinLock) {\n                playbin2.play();\n            }\n            pauseButton.setText(\"||\");\n            new Thread(new Runnable() {\n\n                @Override\n                public void run() {\n                    long positionMillis = 0;\n                    while (positionMillis < durationMillis\n                            && playbin2 != null \n                            && !playbin2.getState().equals(State.NULL)) {\n                        synchronized(playbinLock) {\n                            position = playbin2.queryPosition().toString();\n                            positionMillis = playbin2.queryPosition().toMillis();\n                        }\n                        if (position.length() == 8) {\n                            position = position.substring(3);\n                        }\n                        progressLabel.setText(position + \"/\" + finalDuration);\n                        autoTracking = true;\n                        progressSlider.setValue((int) positionMillis);\n                        autoTracking = false;\n                        try {\n                            Thread.sleep(20);\n                        } catch (InterruptedException ex) { }\n                    }\n                    if (finalDuration.length() == 5) {\n                        progressLabel.setText(\"00:00/\" + finalDuration);\n                    } else {\n                        progressLabel.setText(\"00:00:00/\" + finalDuration);\n                    }\n                    // If it reached the end\n                    if(progressSlider.getValue() == progressSlider.getMaximum()) {\n                        restartVideo();\n                    }\n                }\n                \n                public void restartVideo() {\n                    synchronized(playbinLock) {\n                        if (playbin2 != null) {\n                            playbin2.stop();\n                            playbin2.setState(State.READY); // ready to be played again\n                        }\n                    }\n                    pauseButton.setText(\"►\");\n                    progressSlider.setValue(0);\n                }\n            }).start();\n        }","commit_id":"1f797d675caefde1853038036209d8090a6e49bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Initialize vars and display the image on the panel.\n     * @param file \n     */\n    private void showImage(File file) {\n        java.io.File ioFile = getJFile(file);\n        if (!ioFile.exists()) {\n            try {\n                ContentUtils.writeToFile(file, ioFile);\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Error buffering file\", ex);\n            }\n        }\n        \n        playbin2 = new PlayBin2(\"ImageViewer\");\n        videoComponent = new VideoComponent();\n        playbin2.setVideoSink(videoComponent.getElement());\n        \n        videoPanel.removeAll();\n        videoPanel.setLayout(new BoxLayout(videoPanel, BoxLayout.Y_AXIS));\n        videoPanel.add(videoComponent);\n        videoPanel.revalidate();\n        videoPanel.repaint();\n        \n        playbin2.setInputFile(ioFile);\n        videoPanel.setVisible(true);\n        playbin2.play();\n    }","id":44215,"modified_method":"/**\n     * Initialize vars and display the image on the panel.\n     * @param file \n     */\n    private void showImage(File file) {\n        java.io.File ioFile = getJFile(file);\n        if (!ioFile.exists()) {\n            try {\n                ContentUtils.writeToFile(file, ioFile);\n            } catch (IOException ex) {\n                logger.log(Level.WARNING, \"Error buffering file\", ex);\n            }\n        }\n        \n        videoComponent = new VideoComponent();\n        synchronized(playbinLock) {\n            playbin2 = new PlayBin2(\"ImageViewer\");\n            playbin2.setVideoSink(videoComponent.getElement());\n        }\n        \n        videoPanel.removeAll();\n        videoPanel.setLayout(new BoxLayout(videoPanel, BoxLayout.Y_AXIS));\n        videoPanel.add(videoComponent);\n        videoPanel.revalidate();\n        videoPanel.repaint();\n        \n        synchronized(playbinLock) {\n            playbin2.setInputFile(ioFile);\n            playbin2.play();\n        }\n        videoPanel.setVisible(true);\n    }","commit_id":"1f797d675caefde1853038036209d8090a6e49bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"private void pauseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pauseButtonActionPerformed\n        if(playbin2.getState().equals(State.PLAYING)){\n            playbin2.pause();\n            pauseButton.setText(\"►\");\n            playbin2.setState(State.PAUSED);\n        } else if(playbin2.getState().equals(State.PAUSED)) {\n            playbin2.play();\n            pauseButton.setText(\"||\");\n            playbin2.setState(State.PLAYING);\n        } else if(playbin2.getState().equals(State.READY)) {\n            ExtractMedia em = new ExtractMedia(currentFile, getJFile(currentFile));\n            em.execute();\n        }\n    }","id":44216,"modified_method":"private void pauseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pauseButtonActionPerformed\n        synchronized(playbinLock) {\n            if(playbin2.getState().equals(State.PLAYING)){\n                playbin2.pause();\n                pauseButton.setText(\"►\");\n                playbin2.setState(State.PAUSED);\n            } else if(playbin2.getState().equals(State.PAUSED)) {\n                playbin2.play();\n                pauseButton.setText(\"||\");\n                playbin2.setState(State.PLAYING);\n            } else if(playbin2.getState().equals(State.READY)) {\n                ExtractMedia em = new ExtractMedia(currentFile, getJFile(currentFile));\n                em.execute();\n            }\n        }\n    }","commit_id":"1f797d675caefde1853038036209d8090a6e49bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        pauseButton = new javax.swing.JButton();\n        videoPanel = new javax.swing.JPanel();\n        progressSlider = new javax.swing.JSlider();\n        progressLabel = new javax.swing.JLabel();\n\n        pauseButton.setText(org.openide.util.NbBundle.getMessage(DataContentViewerMedia.class, \"DataContentViewerMedia.pauseButton.text\")); // NOI18N\n        pauseButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                pauseButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout videoPanelLayout = new javax.swing.GroupLayout(videoPanel);\n        videoPanel.setLayout(videoPanelLayout);\n        videoPanelLayout.setHorizontalGroup(\n            videoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 283, Short.MAX_VALUE)\n        );\n        videoPanelLayout.setVerticalGroup(\n            videoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 242, Short.MAX_VALUE)\n        );\n\n        progressSlider.setValue(0);\n\n        progressLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerMedia.class, \"DataContentViewerMedia.progressLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(videoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(pauseButton)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(progressSlider, javax.swing.GroupLayout.DEFAULT_SIZE, 160, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(progressLabel)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addComponent(videoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                    .addComponent(pauseButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(progressSlider, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(progressLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))\n        );\n    }","id":44217,"modified_method":"/**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        pauseButton = new javax.swing.JButton();\n        videoPanel = new javax.swing.JPanel();\n        progressSlider = new javax.swing.JSlider();\n        progressLabel = new javax.swing.JLabel();\n\n        pauseButton.setText(org.openide.util.NbBundle.getMessage(DataContentViewerMedia.class, \"DataContentViewerMedia.pauseButton.text\")); // NOI18N\n        pauseButton.setMaximumSize(new java.awt.Dimension(45, 23));\n        pauseButton.setMinimumSize(new java.awt.Dimension(45, 23));\n        pauseButton.setPreferredSize(new java.awt.Dimension(45, 23));\n        pauseButton.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                pauseButtonActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout videoPanelLayout = new javax.swing.GroupLayout(videoPanel);\n        videoPanel.setLayout(videoPanelLayout);\n        videoPanelLayout.setHorizontalGroup(\n            videoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 283, Short.MAX_VALUE)\n        );\n        videoPanelLayout.setVerticalGroup(\n            videoPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGap(0, 242, Short.MAX_VALUE)\n        );\n\n        progressSlider.setValue(0);\n\n        progressLabel.setText(org.openide.util.NbBundle.getMessage(DataContentViewerMedia.class, \"DataContentViewerMedia.progressLabel.text\")); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);\n        this.setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addComponent(videoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n            .addGroup(layout.createSequentialGroup()\n                .addComponent(pauseButton, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(progressSlider, javax.swing.GroupLayout.DEFAULT_SIZE, 158, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addComponent(progressLabel)\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                .addComponent(videoPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)\n                    .addComponent(pauseButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(progressSlider, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(progressLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))\n        );\n    }","commit_id":"1f797d675caefde1853038036209d8090a6e49bc","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"void mainLoop () {\r\n\t\ttry {\r\n\t\t\tgraphics.setupDisplay();\r\n\t\t} catch (LWJGLException e) {\r\n\t\t\tthrow new GdxRuntimeException(e);\r\n\t\t}\r\n\r\n\t\tlistener.create();\r\n\t\tlistener.resize(graphics.getWidth(), graphics.getHeight());\r\n\t\tgraphics.resize = false;\r\n\r\n\t\tint lastWidth = graphics.getWidth();\r\n\t\tint lastHeight = graphics.getHeight();\r\n\r\n\t\tgraphics.lastTime = System.nanoTime();\r\n\t\tboolean wasActive = true;\r\n\t\twhile (running) {\r\n\t\t\tDisplay.processMessages();\r\n\t\t\tif (Display.isCloseRequested()) exit();\r\n\r\n\t\t\tboolean isActive = Display.isActive();\r\n\t\t\tif (wasActive && !isActive) { // if it's just recently minimized from active state\r\n\t\t\t\twasActive = false;\r\n\t\t\t\tlistener.pause();\r\n\t\t\t}\r\n\t\t\tif (!wasActive && isActive) { // if it's just recently focused from minimized state\r\n\t\t\t\twasActive = true;\r\n\t\t\t\tlistener.resume();\r\n\t\t\t}\r\n\r\n\t\t\tboolean shouldRender = false;\r\n\r\n\t\t\tif (graphics.canvas != null) {\r\n\t\t\t\tint width = graphics.canvas.getWidth();\r\n\t\t\t\tint height = graphics.canvas.getHeight();\r\n\t\t\t\tif (lastWidth != width || lastHeight != height) {\r\n\t\t\t\t\tlastWidth = width;\r\n\t\t\t\t\tlastHeight = height;\r\n\t\t\t\t\tGdx.gl.glViewport(0, 0, lastWidth, lastHeight);\r\n\t\t\t\t\tlistener.resize(lastWidth, lastHeight);\r\n\t\t\t\t\tshouldRender = true;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tgraphics.config.x = Display.getX();\r\n\t\t\t\tgraphics.config.y = Display.getY();\r\n\t\t\t\tif (graphics.resize || Display.wasResized() || Display.getWidth() != graphics.config.width\r\n\t\t\t\t\t|| Display.getHeight() != graphics.config.height) {\r\n\t\t\t\t\tgraphics.resize = false;\r\n\t\t\t\t\tGdx.gl.glViewport(0, 0, Display.getWidth(), Display.getHeight());\r\n\t\t\t\t\tgraphics.config.width = Display.getWidth();\r\n\t\t\t\t\tgraphics.config.height = Display.getHeight();\r\n\t\t\t\t\tif (listener != null) listener.resize(Display.getWidth(), Display.getHeight());\r\n\t\t\t\t\tgraphics.requestRendering();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tsynchronized (runnables) {\r\n\t\t\t\texecutedRunnables.clear();\r\n\t\t\t\texecutedRunnables.addAll(runnables);\r\n\t\t\t\trunnables.clear();\r\n\t\t\t}\r\n\r\n\t\t\tfor (int i = 0; i < executedRunnables.size; i++) {\r\n\t\t\t\tshouldRender = true;\r\n\t\t\t\texecutedRunnables.get(i).run(); // calls out to random app code that could do anything ...\r\n\t\t\t}\r\n\r\n\t\t\t// If one of the runnables set running to false, for example after an exit().\r\n\t\t\tif (!running) break;\r\n\r\n\t\t\tinput.update();\r\n\t\t\tshouldRender |= graphics.shouldRender();\r\n\t\t\tinput.processEvents();\r\n\t\t\tif (audio != null) audio.update();\r\n\r\n\t\t\tif (!isActive && graphics.config.backgroundFPS == -1) shouldRender = false;\r\n\t\t\tint frameRate = isActive ? graphics.config.foregroundFPS : graphics.config.backgroundFPS;\r\n\t\t\tif (shouldRender) {\r\n\t\t\t\tgraphics.updateTime();\r\n\t\t\t\tlistener.render();\r\n\t\t\t\tDisplay.update(false);\r\n\t\t\t} else {\r\n\t\t\t\t// Sleeps to avoid wasting CPU in an empty loop.\r\n\t\t\t\tif (frameRate == -1) frameRate = 10;\r\n\t\t\t\tif (frameRate == 0) frameRate = graphics.config.backgroundFPS;\r\n\t\t\t\tif (frameRate == 0) frameRate = 30;\r\n\t\t\t}\r\n\t\t\tif (frameRate > 0) Display.sync(frameRate);\r\n\t\t}\r\n\r\n\t\tArray<LifecycleListener> listeners = lifecycleListeners;\r\n\t\tsynchronized (listeners) {\r\n\t\t\tfor (LifecycleListener listener : listeners) {\r\n\t\t\t\tlistener.pause();\r\n\t\t\t\tlistener.dispose();\r\n\t\t\t}\r\n\t\t}\r\n\t\tlistener.pause();\r\n\t\tlistener.dispose();\r\n\t\tDisplay.destroy();\r\n\t\tif (audio != null) audio.dispose();\r\n\t\tif (graphics.config.forceExit) System.exit(-1);\r\n\t}","id":44218,"modified_method":"void mainLoop () {\r\n\t\tArray<LifecycleListener> lifecycleListeners = this.lifecycleListeners;\r\n\r\n\t\ttry {\r\n\t\t\tgraphics.setupDisplay();\r\n\t\t} catch (LWJGLException e) {\r\n\t\t\tthrow new GdxRuntimeException(e);\r\n\t\t}\r\n\r\n\t\tlistener.create();\r\n\t\tlistener.resize(graphics.getWidth(), graphics.getHeight());\r\n\t\tgraphics.resize = false;\r\n\r\n\t\tint lastWidth = graphics.getWidth();\r\n\t\tint lastHeight = graphics.getHeight();\r\n\r\n\t\tgraphics.lastTime = System.nanoTime();\r\n\t\tboolean wasActive = true;\r\n\t\twhile (running) {\r\n\t\t\tDisplay.processMessages();\r\n\t\t\tif (Display.isCloseRequested()) exit();\r\n\r\n\t\t\tboolean isActive = Display.isActive();\r\n\t\t\tif (wasActive && !isActive) { // if it's just recently minimized from active state\r\n\t\t\t\twasActive = false;\r\n\t\t\t\tsynchronized (lifecycleListeners) {\r\n\t\t\t\t\tfor (LifecycleListener listener : lifecycleListeners)\r\n\t\t\t\t\t\tlistener.pause();\r\n\t\t\t\t}\r\n\t\t\t\tlistener.pause();\r\n\t\t\t}\r\n\t\t\tif (!wasActive && isActive) { // if it's just recently focused from minimized state\r\n\t\t\t\twasActive = true;\r\n\t\t\t\tlistener.resume();\r\n\t\t\t\tsynchronized (lifecycleListeners) {\r\n\t\t\t\t\tfor (LifecycleListener listener : lifecycleListeners)\r\n\t\t\t\t\t\tlistener.resume();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tboolean shouldRender = false;\r\n\r\n\t\t\tif (graphics.canvas != null) {\r\n\t\t\t\tint width = graphics.canvas.getWidth();\r\n\t\t\t\tint height = graphics.canvas.getHeight();\r\n\t\t\t\tif (lastWidth != width || lastHeight != height) {\r\n\t\t\t\t\tlastWidth = width;\r\n\t\t\t\t\tlastHeight = height;\r\n\t\t\t\t\tGdx.gl.glViewport(0, 0, lastWidth, lastHeight);\r\n\t\t\t\t\tlistener.resize(lastWidth, lastHeight);\r\n\t\t\t\t\tshouldRender = true;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tgraphics.config.x = Display.getX();\r\n\t\t\t\tgraphics.config.y = Display.getY();\r\n\t\t\t\tif (graphics.resize || Display.wasResized() || Display.getWidth() != graphics.config.width\r\n\t\t\t\t\t|| Display.getHeight() != graphics.config.height) {\r\n\t\t\t\t\tgraphics.resize = false;\r\n\t\t\t\t\tGdx.gl.glViewport(0, 0, Display.getWidth(), Display.getHeight());\r\n\t\t\t\t\tgraphics.config.width = Display.getWidth();\r\n\t\t\t\t\tgraphics.config.height = Display.getHeight();\r\n\t\t\t\t\tif (listener != null) listener.resize(Display.getWidth(), Display.getHeight());\r\n\t\t\t\t\tgraphics.requestRendering();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tsynchronized (runnables) {\r\n\t\t\t\texecutedRunnables.clear();\r\n\t\t\t\texecutedRunnables.addAll(runnables);\r\n\t\t\t\trunnables.clear();\r\n\t\t\t}\r\n\r\n\t\t\tfor (int i = 0; i < executedRunnables.size; i++) {\r\n\t\t\t\tshouldRender = true;\r\n\t\t\t\texecutedRunnables.get(i).run(); // calls out to random app code that could do anything ...\r\n\t\t\t}\r\n\r\n\t\t\t// If one of the runnables set running to false, for example after an exit().\r\n\t\t\tif (!running) break;\r\n\r\n\t\t\tinput.update();\r\n\t\t\tshouldRender |= graphics.shouldRender();\r\n\t\t\tinput.processEvents();\r\n\t\t\tif (audio != null) audio.update();\r\n\r\n\t\t\tif (!isActive && graphics.config.backgroundFPS == -1) shouldRender = false;\r\n\t\t\tint frameRate = isActive ? graphics.config.foregroundFPS : graphics.config.backgroundFPS;\r\n\t\t\tif (shouldRender) {\r\n\t\t\t\tgraphics.updateTime();\r\n\t\t\t\tlistener.render();\r\n\t\t\t\tDisplay.update(false);\r\n\t\t\t} else {\r\n\t\t\t\t// Sleeps to avoid wasting CPU in an empty loop.\r\n\t\t\t\tif (frameRate == -1) frameRate = 10;\r\n\t\t\t\tif (frameRate == 0) frameRate = graphics.config.backgroundFPS;\r\n\t\t\t\tif (frameRate == 0) frameRate = 30;\r\n\t\t\t}\r\n\t\t\tif (frameRate > 0) Display.sync(frameRate);\r\n\t\t}\r\n\r\n\t\tsynchronized (lifecycleListeners) {\r\n\t\t\tfor (LifecycleListener listener : lifecycleListeners) {\r\n\t\t\t\tlistener.pause();\r\n\t\t\t\tlistener.dispose();\r\n\t\t\t}\r\n\t\t}\r\n\t\tlistener.pause();\r\n\t\tlistener.dispose();\r\n\t\tDisplay.destroy();\r\n\t\tif (audio != null) audio.dispose();\r\n\t\tif (graphics.config.forceExit) System.exit(-1);\r\n\t}","commit_id":"ccda37142202866f99a437e343be26c8a7672298","url":"https://github.com/libgdx/libgdx"},{"original_method":"static private void wake () {\r\n\t\tsynchronized (instances) {\r\n\t\t\tinstances.notifyAll();\r\n\t\t}\r\n\t}","id":44219,"modified_method":"static void wake () {\r\n\t\tsynchronized (instances) {\r\n\t\t\tinstances.notifyAll();\r\n\t\t}\r\n\t}","commit_id":"ccda37142202866f99a437e343be26c8a7672298","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Starts the timer if it was stopped. */\r\n\tpublic void start () {\r\n\t\tsynchronized (instances) {\r\n\t\t\tif (instances.contains(this, true)) return;\r\n\t\t\tinstances.add(this);\r\n\t\t\twake();\r\n\t\t}\r\n\t}","id":44220,"modified_method":"/** Starts the timer if it was stopped. */\r\n\tpublic void start () {\r\n\t\tsynchronized (instances) {\r\n\t\t\tif (instances.contains(this, true)) return;\r\n\t\t\tinstances.add(this);\r\n\t\t\tif (thread == null) thread = new TimerThread();\r\n\t\t\twake();\r\n\t\t}\r\n\t}","commit_id":"ccda37142202866f99a437e343be26c8a7672298","url":"https://github.com/libgdx/libgdx"},{"original_method":"private Authenticator getAuthenticator() {\n        Service service = getConfiguredService(JMX_HTTP_ADAPTER_NAME);\n        if (service == null) {\n            // Didn't find the service we were looking for\n            log().warn(\"Could not find configured service for '\" + JMX_HTTP_ADAPTER_NAME + \"'\");\n            return null;\n        }\n\n        org.opennms.netmgt.config.service.Attribute[] attribs = service.getAttribute();\n\n        if (attribs == null) {\n            // the AuthenticationMethod is not set, so no authentication\n            return null;\n        }\n\n        boolean usingBasic = false;\n        for (org.opennms.netmgt.config.service.Attribute attrib : attribs) {\n            if (attrib.getName().equals(\"AuthenticationMethod\")) {\n                if (!attrib.getValue().getContent().equals(\"basic\")) {\n                    log().error(\"AuthenticationMethod is \\\"\"\n                              + attrib.getValue()\n                              + \"\\\", but only \\\"basic\\\" is supported\");\n                    return null;\n                }\n                usingBasic = true;\n                break;\n            }\n        }\n            \n        if (!usingBasic) {\n            // AuthenticationMethod is not set to basic, so no authentication\n            return null;\n        }\n\n        Invoke[] invokes = service.getInvoke();\n        if (invokes == null) {\n            // No username or password could be set\n            return null;\n        }\n        \n        String username = null;\n        String password = null;\n        for (Invoke invoke : invokes) {\n            if (invoke.getMethod().equals(\"addAuthorization\")) {\n                Argument[] args = invoke.getArgument();\n                if (args != null && args.length == 2\n                        && args[0].getContent().equals(\"manager\")) {\n                    username = args[0].getContent();\n                    password = args[1].getContent();\n                    break;\n                }\n            }\n        }\n            \n        if (username == null || password == null) {\n            // Didn't find a username or password\n            return null;\n        }\n            \n        final String username_f = username;\n        final String password_f = password;\n        \n        return new Authenticator() {\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(username_f,\n                                                  password_f.toCharArray());\n            }\n        };\n    }","id":44221,"modified_method":"public Authenticator getAuthenticator() {\n        return m_authenticator;\n    }","commit_id":"a35bc172eb124b4aaef9c3d9d183bf6707a60003","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void status() {\n        Authenticator.setDefault(getAuthenticator());\n\n        StatusGetter statusGetter = new StatusGetter();\n        statusGetter.setVerbose(isVerbose());\n        \n        String url = getInvokeUrl() + \"&operation=status\";\n        try {\n            statusGetter.setInvokeURL(new URL(url));\n        } catch (MalformedURLException e) {\n            String message = \"Error creating URL object for invoke URL: '\"\n                + url + \"': \" + e;\n            System.err.println(message);\n            log().error(message, e);\n        }\n\n        try {\n            statusGetter.queryStatus();\n        } catch (Throwable t) {\n            String message =  \"Error invoking status command: \" + t;\n            System.err.println(message);\n            log().error(message, t);\n            System.exit(1);\n        }\n\n        int exitValue;\n        switch (statusGetter.getStatus()) {\n        case NOT_RUNNING:\n        case CONNECTION_REFUSED:\n            exitValue = 3;  // According to LSB: 3 - service not running\n            break;\n\n        case PARTIALLY_RUNNING:\n            /*\n             * According to LSB: reserved for application So, I say\n             * 160 - partially running\n             */\n            exitValue = 160;\n            break;\n\n        case RUNNING:\n            exitValue = 0; // everything should be good and running\n            break;\n\n        default:\n            String message = \"Unknown status returned from \"\n                + \"statusGetter.getStatus(): \"\n                + statusGetter.getStatus();\n            System.err.println(message);\n            log().error(message);\n            exitValue = 1;\n            break;\n        }\n\n        System.exit(exitValue);\n    }","id":44222,"modified_method":"public int status() {\n        Authenticator.setDefault(getAuthenticator());\n\n        StatusGetter statusGetter = new StatusGetter();\n        statusGetter.setVerbose(isVerbose());\n        \n        String url = getInvokeUrl() + \"&operation=status\";\n        try {\n            statusGetter.setInvokeURL(new URL(url));\n        } catch (MalformedURLException e) {\n            String message = \"Error creating URL object for invoke URL: '\"\n                + url + \"': \" + e;\n            System.err.println(message);\n            log().error(message, e);\n        }\n\n        try {\n            statusGetter.queryStatus();\n        } catch (Throwable t) {\n            String message =  \"Error invoking status command: \" + t;\n            System.err.println(message);\n            log().error(message, t);\n            return 1;\n        }\n\n        switch (statusGetter.getStatus()) {\n        case NOT_RUNNING:\n        case CONNECTION_REFUSED:\n            return 3;  // According to LSB: 3 - service not running\n\n        case PARTIALLY_RUNNING:\n            /*\n             * According to LSB: reserved for application So, I say\n             * 160 - partially running\n             */\n            return 160;\n\n        case RUNNING:\n            return 0; // everything should be good and running\n\n        default:\n            String message = \"Unknown status returned from \"\n                + \"statusGetter.getStatus(): \"\n                + statusGetter.getStatus();\n            System.err.println(message);\n            log().error(message);\n            return 1;\n        }\n    }","commit_id":"a35bc172eb124b4aaef9c3d9d183bf6707a60003","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void invokeOperation(String operation) {\n        Authenticator.setDefault(getAuthenticator());\n\n        String urlString = getInvokeUrl() + \"&operation=\" + operation;\n        try {\n            URL invoke = new URL(urlString);\n            InputStream in = invoke.openStream();\n            int ch;\n            while ((ch = in.read()) != -1) {\n                System.out.write((char) ch);\n            }\n            in.close();\n            System.out.println(\"\");\n            System.out.flush();\n            System.exit(0);\n        } catch (ConnectException e) {\n            log().error(e.getMessage() + \" when attempting to fetch URL \\\"\"\n                      + urlString + \"\\\"\");\n            if (isVerbose()) {\n                System.out.println(e.getMessage()\n                                   + \" when attempting to fetch URL \\\"\"\n                                   + urlString + \"\\\"\");\n            }\n            System.exit(1);\n        } catch (Throwable t) {\n            log().error(\"error invoking \" + operation + \" operation\", t);\n            System.out.println(\"error invoking \" + operation + \" operation\");\n            t.printStackTrace();\n            System.exit(1);\n        }\n    }","id":44223,"modified_method":"int invokeOperation(String operation) {\n        Authenticator.setDefault(getAuthenticator());\n\n        String urlString = getInvokeUrl() + \"&operation=\" + operation;\n        try {\n            URL invoke = new URL(urlString);\n            HttpURLConnection connection = (HttpURLConnection) invoke.openConnection();\n            connection.setReadTimeout(getHttpRequestReadTimeout());\n            InputStream in = connection.getInputStream();\n\n            int ch;\n            while ((ch = in.read()) != -1) {\n                System.out.write((char) ch);\n            }\n            in.close();\n            System.out.println(\"\");\n            System.out.flush();\n        } catch (ConnectException e) {\n            log().error(e.getMessage() + \" when attempting to fetch URL \\\"\"\n                      + urlString + \"\\\"\");\n            if (isVerbose()) {\n                System.out.println(e.getMessage()\n                                   + \" when attempting to fetch URL \\\"\"\n                                   + urlString + \"\\\"\");\n            }\n            return 1;\n        } catch (Throwable t) {\n            log().error(\"error invoking \" + operation + \" operation\", t);\n            System.out.println(\"error invoking \" + operation + \" operation\");\n            t.printStackTrace();\n            return 1;\n        }\n\n        return 0;\n    }","commit_id":"a35bc172eb124b4aaef9c3d9d183bf6707a60003","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void stop() {\n        invokeOperation(\"stop\");\n    }","id":44224,"modified_method":"public int stop() {\n        return invokeOperation(\"stop\");\n    }","commit_id":"a35bc172eb124b4aaef9c3d9d183bf6707a60003","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static Category log() {\n        return ThreadCategory.getInstance(Category.class);\n    }","id":44225,"modified_method":"private Category log() {\n        return ThreadCategory.getInstance(getClass());\n    }","commit_id":"a35bc172eb124b4aaef9c3d9d183bf6707a60003","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void main(String[] argv) {\n        configureLog4j();\n        \n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        \n        Controller c = new Controller();\n\n        for (int i = 0; i < argv.length; i++) {\n            if (argv[i].equals(\"-h\")) {\n                System.out.println(\"Usage: java org.opennms.netmgt.vmmgr.Controller \"\n                                   + \"[<options>] <command>\");\n                System.out.println(\"Accepted options:\");\n                System.out.println(\"        -v              Verbose mode.\");\n                System.out.println(\"        -u <URL>        Alternate invoker URL.\");\n                System.out.println(\"\");\n                System.out.println(\"Accepted commands: start, stop, status\");\n                System.out.println(\"\");\n                System.out.println(\"The default invoker URL is: \"\n                        + DEFAULT_INVOKER_URL);\n                System.exit(0);\n            } else if (argv[i].equals(\"-v\")) {\n                c.setVerbose(true);\n            } else if (argv[i].equals(\"-u\")) {\n                c.setInvokeUrl(argv[i + 1]);\n                i++;\n            } else if (i != (argv.length - 1)) {\n                System.err.println(\"Invalid command-line option: \\\"\"\n                        + argv[i] + \"\\\".  Use \\\"-h\\\" option for help.\");\n                System.exit(1);\n            } else {\n                break;\n            }\n        }\n\n        if (argv.length == 0) {\n            System.err.println(\"You must specify a command.  Use \\\"-h\\\"\"\n                               + \" option for help\");\n            System.exit(1);\n        }\n\n        String command = argv[argv.length - 1];\n\n        if (\"start\".equals(command)) {\n            c.start();\n        } else if (\"stop\".equals(command)) {\n            c.stop();\n        } else if (\"status\".equals(command)) {\n            c.status();\n        } else if (\"check\".equals(command)) {\n            c.check();\n        } else if (\"exit\".equals(command)) {\n            c.exit();\n        } else {\n            System.err.println(\"Invalid command \\\"\" + command + \"\\\".\");\n            System.err.println(\"Use \\\"-h\\\" option for help.\");\n            System.exit(1);\n        }\n    }","id":44226,"modified_method":"public static void main(String[] argv) {\n        configureLog4j();\n        \n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        \n        Controller c = new Controller();\n\n        for (int i = 0; i < argv.length; i++) {\n            if (argv[i].equals(\"-h\")) {\n                System.out.println(\"Usage: java org.opennms.netmgt.vmmgr.Controller \"\n                                   + \"[<options>] <command>\");\n                System.out.println(\"Accepted options:\");\n                System.out.println(\"        -t <timeout>    HTTP connection timeout in seconds.  Defaults to 30.\");\n                System.out.println(\"        -u <URL>        Alternate invoker URL.\");\n                System.out.println(\"        -v              Verbose mode.\");\n                System.out.println(\"\");\n                System.out.println(\"Accepted commands: start, stop, status\");\n                System.out.println(\"\");\n                System.out.println(\"The default invoker URL is: \"\n                        + DEFAULT_INVOKER_URL);\n                System.exit(0);\n            } else if (argv[i].equals(\"-t\")) {\n                c.setHttpRequestReadTimeout(Integer.parseInt(argv[i + 1]) * 1000);\n                i++;\n            } else if (argv[i].equals(\"-v\")) {\n                c.setVerbose(true);\n            } else if (argv[i].equals(\"-u\")) {\n                c.setInvokeUrl(argv[i + 1]);\n                i++;\n            } else if (i != (argv.length - 1)) {\n                System.err.println(\"Invalid command-line option: \\\"\"\n                        + argv[i] + \"\\\".  Use \\\"-h\\\" option for help.\");\n                System.exit(1);\n            } else {\n                break;\n            }\n        }\n\n        if (argv.length == 0) {\n            System.err.println(\"You must specify a command.  Use \\\"-h\\\"\"\n                               + \" option for help\");\n            System.exit(1);\n        }\n        \n        c.setAuthenticator(c.createAuthenticatorUsingConfigCredentials());\n\n        String command = argv[argv.length - 1];\n\n        if (\"start\".equals(command)) {\n            c.start();\n        } else if (\"stop\".equals(command)) {\n            System.exit(c.stop());\n        } else if (\"status\".equals(command)) {\n            System.exit(c.status());\n        } else if (\"check\".equals(command)) {\n            System.exit(c.check());\n        } else if (\"exit\".equals(command)) {\n            System.exit(c.exit());\n        } else {\n            System.err.println(\"Invalid command \\\"\" + command + \"\\\".\");\n            System.err.println(\"Use \\\"-h\\\" option for help.\");\n            System.exit(1);\n        }\n    }","commit_id":"a35bc172eb124b4aaef9c3d9d183bf6707a60003","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void exit() {\n        invokeOperation(\"doSystemExit\");\n    }","id":44227,"modified_method":"public int exit() {\n        return invokeOperation(\"doSystemExit\");\n    }","commit_id":"a35bc172eb124b4aaef9c3d9d183bf6707a60003","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void check() {\n        try {\n            DatabaseChecker checker = new DatabaseChecker();\n            checker.check();\n        } catch (Throwable t) {\n            log().error(\"error invoking check command\", t);\n            System.err.println(t);\n            System.exit(1);\n        }\n        System.exit(0);\n    }","id":44228,"modified_method":"public int check() {\n        try {\n            DatabaseChecker checker = new DatabaseChecker();\n            checker.check();\n        } catch (Throwable t) {\n            log().error(\"error invoking check command\", t);\n            System.err.println(t);\n            return 1;\n        }\n        return 0;\n    }","commit_id":"a35bc172eb124b4aaef9c3d9d183bf6707a60003","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static Category log() {\n        return ThreadCategory.getInstance(Category.class);\n    }","id":44229,"modified_method":"private Category log() {\n        return ThreadCategory.getInstance(getClass());\n    }","commit_id":"92608c64c43bc43d44157f8607a5d008185be746","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void status() {\n        Authenticator.setDefault(getAuthenticator());\n\n        StatusGetter statusGetter = new StatusGetter();\n        statusGetter.setVerbose(isVerbose());\n        \n        String url = getInvokeUrl() + \"&operation=status\";\n        try {\n            statusGetter.setInvokeURL(new URL(url));\n        } catch (MalformedURLException e) {\n            String message = \"Error creating URL object for invoke URL: '\"\n                + url + \"': \" + e;\n            System.err.println(message);\n            log().error(message, e);\n        }\n\n        try {\n            statusGetter.queryStatus();\n        } catch (Throwable t) {\n            String message =  \"Error invoking status command: \" + t;\n            System.err.println(message);\n            log().error(message, t);\n            System.exit(1);\n        }\n\n        int exitValue;\n        switch (statusGetter.getStatus()) {\n        case NOT_RUNNING:\n        case CONNECTION_REFUSED:\n            exitValue = 3;  // According to LSB: 3 - service not running\n            break;\n\n        case PARTIALLY_RUNNING:\n            /*\n             * According to LSB: reserved for application So, I say\n             * 160 - partially running\n             */\n            exitValue = 160;\n            break;\n\n        case RUNNING:\n            exitValue = 0; // everything should be good and running\n            break;\n\n        default:\n            String message = \"Unknown status returned from \"\n                + \"statusGetter.getStatus(): \"\n                + statusGetter.getStatus();\n            System.err.println(message);\n            log().error(message);\n            exitValue = 1;\n            break;\n        }\n\n        System.exit(exitValue);\n    }","id":44230,"modified_method":"public int status() {\n        Authenticator.setDefault(getAuthenticator());\n\n        StatusGetter statusGetter = new StatusGetter();\n        statusGetter.setVerbose(isVerbose());\n        \n        String url = getInvokeUrl() + \"&operation=status\";\n        try {\n            statusGetter.setInvokeURL(new URL(url));\n        } catch (MalformedURLException e) {\n            String message = \"Error creating URL object for invoke URL: '\"\n                + url + \"': \" + e;\n            System.err.println(message);\n            log().error(message, e);\n        }\n\n        try {\n            statusGetter.queryStatus();\n        } catch (Throwable t) {\n            String message =  \"Error invoking status command: \" + t;\n            System.err.println(message);\n            log().error(message, t);\n            return 1;\n        }\n\n        switch (statusGetter.getStatus()) {\n        case NOT_RUNNING:\n        case CONNECTION_REFUSED:\n            return 3;  // According to LSB: 3 - service not running\n\n        case PARTIALLY_RUNNING:\n            /*\n             * According to LSB: reserved for application So, I say\n             * 160 - partially running\n             */\n            return 160;\n\n        case RUNNING:\n            return 0; // everything should be good and running\n\n        default:\n            String message = \"Unknown status returned from \"\n                + \"statusGetter.getStatus(): \"\n                + statusGetter.getStatus();\n            System.err.println(message);\n            log().error(message);\n            return 1;\n        }\n    }","commit_id":"92608c64c43bc43d44157f8607a5d008185be746","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Authenticator getAuthenticator() {\n        Service service = getConfiguredService(JMX_HTTP_ADAPTER_NAME);\n        if (service == null) {\n            // Didn't find the service we were looking for\n            log().warn(\"Could not find configured service for '\" + JMX_HTTP_ADAPTER_NAME + \"'\");\n            return null;\n        }\n\n        org.opennms.netmgt.config.service.Attribute[] attribs = service.getAttribute();\n\n        if (attribs == null) {\n            // the AuthenticationMethod is not set, so no authentication\n            return null;\n        }\n\n        boolean usingBasic = false;\n        for (org.opennms.netmgt.config.service.Attribute attrib : attribs) {\n            if (attrib.getName().equals(\"AuthenticationMethod\")) {\n                if (!attrib.getValue().getContent().equals(\"basic\")) {\n                    log().error(\"AuthenticationMethod is \\\"\"\n                              + attrib.getValue()\n                              + \"\\\", but only \\\"basic\\\" is supported\");\n                    return null;\n                }\n                usingBasic = true;\n                break;\n            }\n        }\n            \n        if (!usingBasic) {\n            // AuthenticationMethod is not set to basic, so no authentication\n            return null;\n        }\n\n        Invoke[] invokes = service.getInvoke();\n        if (invokes == null) {\n            // No username or password could be set\n            return null;\n        }\n        \n        String username = null;\n        String password = null;\n        for (Invoke invoke : invokes) {\n            if (invoke.getMethod().equals(\"addAuthorization\")) {\n                Argument[] args = invoke.getArgument();\n                if (args != null && args.length == 2\n                        && args[0].getContent().equals(\"manager\")) {\n                    username = args[0].getContent();\n                    password = args[1].getContent();\n                    break;\n                }\n            }\n        }\n            \n        if (username == null || password == null) {\n            // Didn't find a username or password\n            return null;\n        }\n            \n        final String username_f = username;\n        final String password_f = password;\n        \n        return new Authenticator() {\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(username_f,\n                                                  password_f.toCharArray());\n            }\n        };\n    }","id":44231,"modified_method":"public Authenticator getAuthenticator() {\n        return m_authenticator;\n    }","commit_id":"92608c64c43bc43d44157f8607a5d008185be746","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void main(String[] argv) {\n        configureLog4j();\n        \n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        \n        Controller c = new Controller();\n\n        for (int i = 0; i < argv.length; i++) {\n            if (argv[i].equals(\"-h\")) {\n                System.out.println(\"Usage: java org.opennms.netmgt.vmmgr.Controller \"\n                                   + \"[<options>] <command>\");\n                System.out.println(\"Accepted options:\");\n                System.out.println(\"        -v              Verbose mode.\");\n                System.out.println(\"        -u <URL>        Alternate invoker URL.\");\n                System.out.println(\"\");\n                System.out.println(\"Accepted commands: start, stop, status\");\n                System.out.println(\"\");\n                System.out.println(\"The default invoker URL is: \"\n                        + DEFAULT_INVOKER_URL);\n                System.exit(0);\n            } else if (argv[i].equals(\"-v\")) {\n                c.setVerbose(true);\n            } else if (argv[i].equals(\"-u\")) {\n                c.setInvokeUrl(argv[i + 1]);\n                i++;\n            } else if (i != (argv.length - 1)) {\n                System.err.println(\"Invalid command-line option: \\\"\"\n                        + argv[i] + \"\\\".  Use \\\"-h\\\" option for help.\");\n                System.exit(1);\n            } else {\n                break;\n            }\n        }\n\n        if (argv.length == 0) {\n            System.err.println(\"You must specify a command.  Use \\\"-h\\\"\"\n                               + \" option for help\");\n            System.exit(1);\n        }\n\n        String command = argv[argv.length - 1];\n\n        if (\"start\".equals(command)) {\n            c.start();\n        } else if (\"stop\".equals(command)) {\n            c.stop();\n        } else if (\"status\".equals(command)) {\n            c.status();\n        } else if (\"check\".equals(command)) {\n            c.check();\n        } else if (\"exit\".equals(command)) {\n            c.exit();\n        } else {\n            System.err.println(\"Invalid command \\\"\" + command + \"\\\".\");\n            System.err.println(\"Use \\\"-h\\\" option for help.\");\n            System.exit(1);\n        }\n    }","id":44232,"modified_method":"public static void main(String[] argv) {\n        configureLog4j();\n        \n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        \n        Controller c = new Controller();\n\n        for (int i = 0; i < argv.length; i++) {\n            if (argv[i].equals(\"-h\")) {\n                System.out.println(\"Usage: java org.opennms.netmgt.vmmgr.Controller \"\n                                   + \"[<options>] <command>\");\n                System.out.println(\"Accepted options:\");\n                System.out.println(\"        -t <timeout>    HTTP connection timeout in seconds.  Defaults to 30.\");\n                System.out.println(\"        -u <URL>        Alternate invoker URL.\");\n                System.out.println(\"        -v              Verbose mode.\");\n                System.out.println(\"\");\n                System.out.println(\"Accepted commands: start, stop, status\");\n                System.out.println(\"\");\n                System.out.println(\"The default invoker URL is: \"\n                        + DEFAULT_INVOKER_URL);\n                System.exit(0);\n            } else if (argv[i].equals(\"-t\")) {\n                c.setHttpRequestReadTimeout(Integer.parseInt(argv[i + 1]) * 1000);\n                i++;\n            } else if (argv[i].equals(\"-v\")) {\n                c.setVerbose(true);\n            } else if (argv[i].equals(\"-u\")) {\n                c.setInvokeUrl(argv[i + 1]);\n                i++;\n            } else if (i != (argv.length - 1)) {\n                System.err.println(\"Invalid command-line option: \\\"\"\n                        + argv[i] + \"\\\".  Use \\\"-h\\\" option for help.\");\n                System.exit(1);\n            } else {\n                break;\n            }\n        }\n\n        if (argv.length == 0) {\n            System.err.println(\"You must specify a command.  Use \\\"-h\\\"\"\n                               + \" option for help\");\n            System.exit(1);\n        }\n        \n        c.setAuthenticator(c.createAuthenticatorUsingConfigCredentials());\n\n        String command = argv[argv.length - 1];\n\n        if (\"start\".equals(command)) {\n            c.start();\n        } else if (\"stop\".equals(command)) {\n            System.exit(c.stop());\n        } else if (\"status\".equals(command)) {\n            System.exit(c.status());\n        } else if (\"check\".equals(command)) {\n            System.exit(c.check());\n        } else if (\"exit\".equals(command)) {\n            System.exit(c.exit());\n        } else {\n            System.err.println(\"Invalid command \\\"\" + command + \"\\\".\");\n            System.err.println(\"Use \\\"-h\\\" option for help.\");\n            System.exit(1);\n        }\n    }","commit_id":"92608c64c43bc43d44157f8607a5d008185be746","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void stop() {\n        invokeOperation(\"stop\");\n    }","id":44233,"modified_method":"public int stop() {\n        return invokeOperation(\"stop\");\n    }","commit_id":"92608c64c43bc43d44157f8607a5d008185be746","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void exit() {\n        invokeOperation(\"doSystemExit\");\n    }","id":44234,"modified_method":"public int exit() {\n        return invokeOperation(\"doSystemExit\");\n    }","commit_id":"92608c64c43bc43d44157f8607a5d008185be746","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void check() {\n        try {\n            DatabaseChecker checker = new DatabaseChecker();\n            checker.check();\n        } catch (Throwable t) {\n            log().error(\"error invoking check command\", t);\n            System.err.println(t);\n            System.exit(1);\n        }\n        System.exit(0);\n    }","id":44235,"modified_method":"public int check() {\n        try {\n            DatabaseChecker checker = new DatabaseChecker();\n            checker.check();\n        } catch (Throwable t) {\n            log().error(\"error invoking check command\", t);\n            System.err.println(t);\n            return 1;\n        }\n        return 0;\n    }","commit_id":"92608c64c43bc43d44157f8607a5d008185be746","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void invokeOperation(String operation) {\n        Authenticator.setDefault(getAuthenticator());\n\n        String urlString = getInvokeUrl() + \"&operation=\" + operation;\n        try {\n            URL invoke = new URL(urlString);\n            InputStream in = invoke.openStream();\n            int ch;\n            while ((ch = in.read()) != -1) {\n                System.out.write((char) ch);\n            }\n            in.close();\n            System.out.println(\"\");\n            System.out.flush();\n            System.exit(0);\n        } catch (ConnectException e) {\n            log().error(e.getMessage() + \" when attempting to fetch URL \\\"\"\n                      + urlString + \"\\\"\");\n            if (isVerbose()) {\n                System.out.println(e.getMessage()\n                                   + \" when attempting to fetch URL \\\"\"\n                                   + urlString + \"\\\"\");\n            }\n            System.exit(1);\n        } catch (Throwable t) {\n            log().error(\"error invoking \" + operation + \" operation\", t);\n            System.out.println(\"error invoking \" + operation + \" operation\");\n            t.printStackTrace();\n            System.exit(1);\n        }\n    }","id":44236,"modified_method":"int invokeOperation(String operation) {\n        Authenticator.setDefault(getAuthenticator());\n\n        String urlString = getInvokeUrl() + \"&operation=\" + operation;\n        try {\n            URL invoke = new URL(urlString);\n            HttpURLConnection connection = (HttpURLConnection) invoke.openConnection();\n            connection.setReadTimeout(getHttpRequestReadTimeout());\n            InputStream in = connection.getInputStream();\n\n            int ch;\n            while ((ch = in.read()) != -1) {\n                System.out.write((char) ch);\n            }\n            in.close();\n            System.out.println(\"\");\n            System.out.flush();\n        } catch (ConnectException e) {\n            log().error(e.getMessage() + \" when attempting to fetch URL \\\"\"\n                      + urlString + \"\\\"\");\n            if (isVerbose()) {\n                System.out.println(e.getMessage()\n                                   + \" when attempting to fetch URL \\\"\"\n                                   + urlString + \"\\\"\");\n            }\n            return 1;\n        } catch (Throwable t) {\n            log().error(\"error invoking \" + operation + \" operation\", t);\n            System.out.println(\"error invoking \" + operation + \" operation\");\n            t.printStackTrace();\n            return 1;\n        }\n\n        return 0;\n    }","commit_id":"92608c64c43bc43d44157f8607a5d008185be746","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void check() {\n        try {\n            DatabaseChecker checker = new DatabaseChecker();\n            checker.check();\n        } catch (Throwable t) {\n            log().error(\"error invoking check command\", t);\n            System.err.println(t);\n            System.exit(1);\n        }\n        System.exit(0);\n    }","id":44237,"modified_method":"public int check() {\n        try {\n            DatabaseChecker checker = new DatabaseChecker();\n            checker.check();\n        } catch (Throwable t) {\n            log().error(\"error invoking check command\", t);\n            System.err.println(t);\n            return 1;\n        }\n        return 0;\n    }","commit_id":"c7bcbf17fa1385e178e099836012aaaed33cf3a6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private void invokeOperation(String operation) {\n        Authenticator.setDefault(getAuthenticator());\n\n        String urlString = getInvokeUrl() + \"&operation=\" + operation;\n        try {\n            URL invoke = new URL(urlString);\n            InputStream in = invoke.openStream();\n            int ch;\n            while ((ch = in.read()) != -1) {\n                System.out.write((char) ch);\n            }\n            in.close();\n            System.out.println(\"\");\n            System.out.flush();\n            System.exit(0);\n        } catch (ConnectException e) {\n            log().error(e.getMessage() + \" when attempting to fetch URL \\\"\"\n                      + urlString + \"\\\"\");\n            if (isVerbose()) {\n                System.out.println(e.getMessage()\n                                   + \" when attempting to fetch URL \\\"\"\n                                   + urlString + \"\\\"\");\n            }\n            System.exit(1);\n        } catch (Throwable t) {\n            log().error(\"error invoking \" + operation + \" operation\", t);\n            System.out.println(\"error invoking \" + operation + \" operation\");\n            t.printStackTrace();\n            System.exit(1);\n        }\n    }","id":44238,"modified_method":"int invokeOperation(String operation) {\n        Authenticator.setDefault(getAuthenticator());\n\n        String urlString = getInvokeUrl() + \"&operation=\" + operation;\n        try {\n            URL invoke = new URL(urlString);\n            HttpURLConnection connection = (HttpURLConnection) invoke.openConnection();\n            connection.setReadTimeout(getHttpRequestReadTimeout());\n            InputStream in = connection.getInputStream();\n\n            int ch;\n            while ((ch = in.read()) != -1) {\n                System.out.write((char) ch);\n            }\n            in.close();\n            System.out.println(\"\");\n            System.out.flush();\n        } catch (ConnectException e) {\n            log().error(e.getMessage() + \" when attempting to fetch URL \\\"\"\n                      + urlString + \"\\\"\");\n            if (isVerbose()) {\n                System.out.println(e.getMessage()\n                                   + \" when attempting to fetch URL \\\"\"\n                                   + urlString + \"\\\"\");\n            }\n            return 1;\n        } catch (Throwable t) {\n            log().error(\"error invoking \" + operation + \" operation\", t);\n            System.out.println(\"error invoking \" + operation + \" operation\");\n            t.printStackTrace();\n            return 1;\n        }\n\n        return 0;\n    }","commit_id":"c7bcbf17fa1385e178e099836012aaaed33cf3a6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private static Category log() {\n        return ThreadCategory.getInstance(Category.class);\n    }","id":44239,"modified_method":"private Category log() {\n        return ThreadCategory.getInstance(getClass());\n    }","commit_id":"c7bcbf17fa1385e178e099836012aaaed33cf3a6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void main(String[] argv) {\n        configureLog4j();\n        \n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        \n        Controller c = new Controller();\n\n        for (int i = 0; i < argv.length; i++) {\n            if (argv[i].equals(\"-h\")) {\n                System.out.println(\"Usage: java org.opennms.netmgt.vmmgr.Controller \"\n                                   + \"[<options>] <command>\");\n                System.out.println(\"Accepted options:\");\n                System.out.println(\"        -v              Verbose mode.\");\n                System.out.println(\"        -u <URL>        Alternate invoker URL.\");\n                System.out.println(\"\");\n                System.out.println(\"Accepted commands: start, stop, status\");\n                System.out.println(\"\");\n                System.out.println(\"The default invoker URL is: \"\n                        + DEFAULT_INVOKER_URL);\n                System.exit(0);\n            } else if (argv[i].equals(\"-v\")) {\n                c.setVerbose(true);\n            } else if (argv[i].equals(\"-u\")) {\n                c.setInvokeUrl(argv[i + 1]);\n                i++;\n            } else if (i != (argv.length - 1)) {\n                System.err.println(\"Invalid command-line option: \\\"\"\n                        + argv[i] + \"\\\".  Use \\\"-h\\\" option for help.\");\n                System.exit(1);\n            } else {\n                break;\n            }\n        }\n\n        if (argv.length == 0) {\n            System.err.println(\"You must specify a command.  Use \\\"-h\\\"\"\n                               + \" option for help\");\n            System.exit(1);\n        }\n\n        String command = argv[argv.length - 1];\n\n        if (\"start\".equals(command)) {\n            c.start();\n        } else if (\"stop\".equals(command)) {\n            c.stop();\n        } else if (\"status\".equals(command)) {\n            c.status();\n        } else if (\"check\".equals(command)) {\n            c.check();\n        } else if (\"exit\".equals(command)) {\n            c.exit();\n        } else {\n            System.err.println(\"Invalid command \\\"\" + command + \"\\\".\");\n            System.err.println(\"Use \\\"-h\\\" option for help.\");\n            System.exit(1);\n        }\n    }","id":44240,"modified_method":"public static void main(String[] argv) {\n        configureLog4j();\n        \n        ThreadCategory.setPrefix(LOG4J_CATEGORY);\n        \n        Controller c = new Controller();\n\n        for (int i = 0; i < argv.length; i++) {\n            if (argv[i].equals(\"-h\")) {\n                System.out.println(\"Usage: java org.opennms.netmgt.vmmgr.Controller \"\n                                   + \"[<options>] <command>\");\n                System.out.println(\"Accepted options:\");\n                System.out.println(\"        -t <timeout>    HTTP connection timeout in seconds.  Defaults to 30.\");\n                System.out.println(\"        -u <URL>        Alternate invoker URL.\");\n                System.out.println(\"        -v              Verbose mode.\");\n                System.out.println(\"\");\n                System.out.println(\"Accepted commands: start, stop, status\");\n                System.out.println(\"\");\n                System.out.println(\"The default invoker URL is: \"\n                        + DEFAULT_INVOKER_URL);\n                System.exit(0);\n            } else if (argv[i].equals(\"-t\")) {\n                c.setHttpRequestReadTimeout(Integer.parseInt(argv[i + 1]) * 1000);\n                i++;\n            } else if (argv[i].equals(\"-v\")) {\n                c.setVerbose(true);\n            } else if (argv[i].equals(\"-u\")) {\n                c.setInvokeUrl(argv[i + 1]);\n                i++;\n            } else if (i != (argv.length - 1)) {\n                System.err.println(\"Invalid command-line option: \\\"\"\n                        + argv[i] + \"\\\".  Use \\\"-h\\\" option for help.\");\n                System.exit(1);\n            } else {\n                break;\n            }\n        }\n\n        if (argv.length == 0) {\n            System.err.println(\"You must specify a command.  Use \\\"-h\\\"\"\n                               + \" option for help\");\n            System.exit(1);\n        }\n        \n        c.setAuthenticator(c.createAuthenticatorUsingConfigCredentials());\n\n        String command = argv[argv.length - 1];\n\n        if (\"start\".equals(command)) {\n            c.start();\n        } else if (\"stop\".equals(command)) {\n            System.exit(c.stop());\n        } else if (\"status\".equals(command)) {\n            System.exit(c.status());\n        } else if (\"check\".equals(command)) {\n            System.exit(c.check());\n        } else if (\"exit\".equals(command)) {\n            System.exit(c.exit());\n        } else {\n            System.err.println(\"Invalid command \\\"\" + command + \"\\\".\");\n            System.err.println(\"Use \\\"-h\\\" option for help.\");\n            System.exit(1);\n        }\n    }","commit_id":"c7bcbf17fa1385e178e099836012aaaed33cf3a6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void status() {\n        Authenticator.setDefault(getAuthenticator());\n\n        StatusGetter statusGetter = new StatusGetter();\n        statusGetter.setVerbose(isVerbose());\n        \n        String url = getInvokeUrl() + \"&operation=status\";\n        try {\n            statusGetter.setInvokeURL(new URL(url));\n        } catch (MalformedURLException e) {\n            String message = \"Error creating URL object for invoke URL: '\"\n                + url + \"': \" + e;\n            System.err.println(message);\n            log().error(message, e);\n        }\n\n        try {\n            statusGetter.queryStatus();\n        } catch (Throwable t) {\n            String message =  \"Error invoking status command: \" + t;\n            System.err.println(message);\n            log().error(message, t);\n            System.exit(1);\n        }\n\n        int exitValue;\n        switch (statusGetter.getStatus()) {\n        case NOT_RUNNING:\n        case CONNECTION_REFUSED:\n            exitValue = 3;  // According to LSB: 3 - service not running\n            break;\n\n        case PARTIALLY_RUNNING:\n            /*\n             * According to LSB: reserved for application So, I say\n             * 160 - partially running\n             */\n            exitValue = 160;\n            break;\n\n        case RUNNING:\n            exitValue = 0; // everything should be good and running\n            break;\n\n        default:\n            String message = \"Unknown status returned from \"\n                + \"statusGetter.getStatus(): \"\n                + statusGetter.getStatus();\n            System.err.println(message);\n            log().error(message);\n            exitValue = 1;\n            break;\n        }\n\n        System.exit(exitValue);\n    }","id":44241,"modified_method":"public int status() {\n        Authenticator.setDefault(getAuthenticator());\n\n        StatusGetter statusGetter = new StatusGetter();\n        statusGetter.setVerbose(isVerbose());\n        \n        String url = getInvokeUrl() + \"&operation=status\";\n        try {\n            statusGetter.setInvokeURL(new URL(url));\n        } catch (MalformedURLException e) {\n            String message = \"Error creating URL object for invoke URL: '\"\n                + url + \"': \" + e;\n            System.err.println(message);\n            log().error(message, e);\n        }\n\n        try {\n            statusGetter.queryStatus();\n        } catch (Throwable t) {\n            String message =  \"Error invoking status command: \" + t;\n            System.err.println(message);\n            log().error(message, t);\n            return 1;\n        }\n\n        switch (statusGetter.getStatus()) {\n        case NOT_RUNNING:\n        case CONNECTION_REFUSED:\n            return 3;  // According to LSB: 3 - service not running\n\n        case PARTIALLY_RUNNING:\n            /*\n             * According to LSB: reserved for application So, I say\n             * 160 - partially running\n             */\n            return 160;\n\n        case RUNNING:\n            return 0; // everything should be good and running\n\n        default:\n            String message = \"Unknown status returned from \"\n                + \"statusGetter.getStatus(): \"\n                + statusGetter.getStatus();\n            System.err.println(message);\n            log().error(message);\n            return 1;\n        }\n    }","commit_id":"c7bcbf17fa1385e178e099836012aaaed33cf3a6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Authenticator getAuthenticator() {\n        Service service = getConfiguredService(JMX_HTTP_ADAPTER_NAME);\n        if (service == null) {\n            // Didn't find the service we were looking for\n            log().warn(\"Could not find configured service for '\" + JMX_HTTP_ADAPTER_NAME + \"'\");\n            return null;\n        }\n\n        org.opennms.netmgt.config.service.Attribute[] attribs = service.getAttribute();\n\n        if (attribs == null) {\n            // the AuthenticationMethod is not set, so no authentication\n            return null;\n        }\n\n        boolean usingBasic = false;\n        for (org.opennms.netmgt.config.service.Attribute attrib : attribs) {\n            if (attrib.getName().equals(\"AuthenticationMethod\")) {\n                if (!attrib.getValue().getContent().equals(\"basic\")) {\n                    log().error(\"AuthenticationMethod is \\\"\"\n                              + attrib.getValue()\n                              + \"\\\", but only \\\"basic\\\" is supported\");\n                    return null;\n                }\n                usingBasic = true;\n                break;\n            }\n        }\n            \n        if (!usingBasic) {\n            // AuthenticationMethod is not set to basic, so no authentication\n            return null;\n        }\n\n        Invoke[] invokes = service.getInvoke();\n        if (invokes == null) {\n            // No username or password could be set\n            return null;\n        }\n        \n        String username = null;\n        String password = null;\n        for (Invoke invoke : invokes) {\n            if (invoke.getMethod().equals(\"addAuthorization\")) {\n                Argument[] args = invoke.getArgument();\n                if (args != null && args.length == 2\n                        && args[0].getContent().equals(\"manager\")) {\n                    username = args[0].getContent();\n                    password = args[1].getContent();\n                    break;\n                }\n            }\n        }\n            \n        if (username == null || password == null) {\n            // Didn't find a username or password\n            return null;\n        }\n            \n        final String username_f = username;\n        final String password_f = password;\n        \n        return new Authenticator() {\n            protected PasswordAuthentication getPasswordAuthentication() {\n                return new PasswordAuthentication(username_f,\n                                                  password_f.toCharArray());\n            }\n        };\n    }","id":44242,"modified_method":"public Authenticator getAuthenticator() {\n        return m_authenticator;\n    }","commit_id":"c7bcbf17fa1385e178e099836012aaaed33cf3a6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void exit() {\n        invokeOperation(\"doSystemExit\");\n    }","id":44243,"modified_method":"public int exit() {\n        return invokeOperation(\"doSystemExit\");\n    }","commit_id":"c7bcbf17fa1385e178e099836012aaaed33cf3a6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void stop() {\n        invokeOperation(\"stop\");\n    }","id":44244,"modified_method":"public int stop() {\n        return invokeOperation(\"stop\");\n    }","commit_id":"c7bcbf17fa1385e178e099836012aaaed33cf3a6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void execute(EditorContext editorContext) {\n    EditorCell selectedCell = editorContext.getSelectedCell();\n    if (selectedCell == null) {\n      return;\n    }\n    final String cellId = selectedCell.getCellId();\n    SNode actualSelectedNode = selectedCell.getSNode();\n    boolean isLabel = selectedCell instanceof EditorCell_Label;\n    int startPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionStart() : -1);\n    int endPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionEnd() : -1);\n    SNode nodeToSelect = CommentUtil.commentOut(myNode);\n    editorContext.flushEvents();\n    if (cellId != null) {\n      EditorCell newNodeCell = editorContext.getEditorComponent().findNodeCell(actualSelectedNode);\n      if (newNodeCell != null) {\n        EditorCell cellToSelect = CellFinderUtil.findChildByCondition(newNodeCell, new Condition<EditorCell>() {\n          public boolean met(EditorCell cell) {\n            return eq_9lx3n0_a0a0a0a1a0a0b0j0h(cell.getCellId(), cellId);\n          }\n        }, true, true);\n        if (cellToSelect != null) {\n          if (isLabel) {\n            editorContext.getSelectionManager().setSelection(actualSelectedNode, cellId, startPosition, endPosition);\n          } else {\n            editorContext.getSelectionManager().setSelection(actualSelectedNode, cellId);\n          }\n\n          return;\n        }\n      }\n    }\n    SelectionUtil.selectCell(editorContext, nodeToSelect, SelectionManager.LAST_EDITABLE_CELL);\n  }","id":44245,"modified_method":"public void execute(EditorContext editorContext) {\n    EditorCell selectedCell = editorContext.getSelectedCell();\n    if (selectedCell == null) {\n      return;\n    }\n    String cellId = selectedCell.getCellId();\n    SNode actualSelectedNode = selectedCell.getSNode();\n    boolean isLabel = selectedCell instanceof EditorCell_Label;\n    int startPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionStart() : -1);\n    int endPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionEnd() : -1);\n    SNode nodeToSelect = CommentUtil.commentOut(myNode);\n    editorContext.flushEvents();\n    if (cellId != null) {\n      SelectionManager selectionManager = editorContext.getSelectionManager();\n      if (isLabel) {\n        selectionManager.setSelection(actualSelectedNode, cellId, startPosition, endPosition);\n      } else {\n        selectionManager.setSelection(actualSelectedNode, cellId);\n      }\n      if (selectionManager.getSelection() != null) {\n        return;\n      }\n    }\n    SelectionUtil.selectCell(editorContext, nodeToSelect, SelectionManager.LAST_EDITABLE_CELL);\n  }","commit_id":"67051b1be11145d61ea4a1a470c4f3fb91a65c81","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(EditorContext editorContext) {\n    EditorCell selectedCell = editorContext.getSelectedCell();\n    if (selectedCell == null) {\n      return;\n    }\n    final String cellId = selectedCell.getCellId();\n    SNode actualSelectedNode = selectedCell.getSNode();\n    boolean isLabel = selectedCell instanceof EditorCell_Label;\n    int startPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionStart() : -1);\n    int endPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionEnd() : -1);\n    SNode uncommentedNode = CommentUtil.uncomment(myNode);\n    editorContext.flushEvents();\n    if (cellId != null) {\n      EditorCell newNodeCell = editorContext.getEditorComponent().findNodeCell(actualSelectedNode);\n      if (newNodeCell != null) {\n        EditorCell cellToSelect = CellFinderUtil.findChildByCondition(newNodeCell, new Condition<EditorCell>() {\n          public boolean met(EditorCell cell) {\n            return eq_juwut9_a0a0a0a1a0a0b0j0g(cell.getCellId(), cellId);\n          }\n        }, true, true);\n        if (cellToSelect != null) {\n          if (isLabel) {\n            editorContext.getSelectionManager().setSelection(actualSelectedNode, cellId, startPosition, endPosition);\n          } else {\n            editorContext.getSelectionManager().setSelection(actualSelectedNode, cellId);\n          }\n          return;\n        }\n      }\n    }\n    SelectionUtil.selectCell(editorContext, uncommentedNode, SelectionManager.LAST_EDITABLE_CELL);\n  }","id":44246,"modified_method":"public void execute(EditorContext editorContext) {\n    EditorCell selectedCell = editorContext.getSelectedCell();\n    if (selectedCell == null) {\n      return;\n    }\n    String cellId = selectedCell.getCellId();\n    SNode actualSelectedNode = selectedCell.getSNode();\n    boolean isLabel = selectedCell instanceof EditorCell_Label;\n    int startPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionStart() : -1);\n    int endPosition = (isLabel ? ((EditorCell_Label) selectedCell).getSelectionEnd() : -1);\n    SNode uncommentedNode = CommentUtil.uncomment(myNode);\n    editorContext.flushEvents();\n    if (cellId != null) {\n      SelectionManager selectionManager = editorContext.getSelectionManager();\n      if (isLabel) {\n        selectionManager.setSelection(actualSelectedNode, cellId, startPosition, endPosition);\n      } else {\n        selectionManager.setSelection(actualSelectedNode, cellId);\n      }\n      if (selectionManager.getSelection() != null) {\n        return;\n      }\n    }\n    SelectionUtil.selectCell(editorContext, uncommentedNode, SelectionManager.LAST_EDITABLE_CELL);\n  }","commit_id":"67051b1be11145d61ea4a1a470c4f3fb91a65c81","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  protected void addReferenceCell(final SReferenceLink referenceLink) {\n    SReference reference = mySNode.getReference(referenceLink);\n    if (reference == null) {\n      String noTargetText = \"<no \" + referenceLink.getRoleName() + \">\";\n      jetbrains.mps.nodeEditor.cells.EditorCell_Label noRefCell = referenceLink.isOptional() ?\n          new EditorCell_Constant(myEditorContext, mySNode, \"\") : new EditorCell_Error(myEditorContext, mySNode, noTargetText);\n      noRefCell.setText(\"\");\n      noRefCell.setEditable(true);\n      noRefCell.setDefaultText(noTargetText);\n\n      noRefCell.setAction(CellActionType.DELETE, new CellAction_DeleteEasily(mySNode));\n      noRefCell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteEasily(mySNode));\n\n      noRefCell.setCellId(\"empty_\" + referenceLink.getRoleName());\n      noRefCell.setRole(referenceLink.getRoleName());\n      noRefCell.setReferenceCell(true);\n      noRefCell.setSubstituteInfo(new DefaultSReferenceSubstituteInfo(mySNode, referenceLink, myEditorContext));\n      noRefCell.setRole(referenceLink.getRoleName());\n      setIndent(noRefCell);\n      addCell(noRefCell);\n    } else {\n      final SNode referentNode = reference.getTargetNode();\n      if (referentNode == null || referentNode.getModel() == null || !VisibilityUtil.isVisible(myEditorContext.getModel(), referentNode.getModel())) {\n        //todo do we need this?\n        String rinfo = ((jetbrains.mps.smodel.SReference) reference).getResolveInfo();\n        EditorCell errorCell = createErrorCell(rinfo != null ? rinfo : \"?\" + referenceLink.getRoleName() + \"?\", referenceLink);\n        errorCell.setCellId(\"error_\" + referenceLink.getRoleName());\n        addCell(errorCell);\n      } else {\n        EditorCell cell = myEditorContext.getEditorComponent().getUpdater().getCurrentUpdateSession().updateReferencedNodeCell(new Computable<EditorCell>() {\n          @Override\n          public EditorCell compute() {\n            return createReferentEditorCell(myEditorContext, referenceLink, referentNode);\n          }\n        }, referentNode, referenceLink.getRoleName());\n        //todo what is that?\n        CellUtil.setupIDeprecatableStyles(referentNode, cell);\n        setSemanticNodeToCells(cell, mySNode);\n\n        //todo rewrite cell actions\n        cell.setAction(CellActionType.DELETE, new CellAction_DeleteReference(mySNode, referenceLink.getRoleName()));\n        cell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteReference(mySNode, referenceLink.getRoleName()));\n        cell.setSubstituteInfo(new DefaultSReferenceSubstituteInfo(mySNode, referenceLink, myEditorContext));\n        cell.setCellId(\"reference_\" + referenceLink.getRoleName());\n        //todo attributes\n        addCellWithRole(IterableUtils.first(AttributeOperations.getLinkAttributes(mySNode, referenceLink)), AttributeKind.Reference.class, cell);\n      }\n    }\n\n  }","id":44247,"modified_method":"@Override\n  protected void addReferenceCell(final SReferenceLink referenceLink) {\n    SReference reference = mySNode.getReference(referenceLink);\n    if (reference == null) {\n      String noTargetText = \"<no \" + referenceLink.getRoleName() + \">\";\n      jetbrains.mps.nodeEditor.cells.EditorCell_Label noRefCell = referenceLink.isOptional() ?\n          new EditorCell_Constant(myEditorContext, mySNode, \"\") : new EditorCell_Error(myEditorContext, mySNode, noTargetText);\n      noRefCell.setText(\"\");\n      noRefCell.setEditable(true);\n      noRefCell.setDefaultText(noTargetText);\n\n      noRefCell.setAction(CellActionType.DELETE, new CellAction_DeleteEasily(mySNode));\n      noRefCell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteEasily(mySNode));\n\n      noRefCell.setCellId(\"empty_\" + referenceLink.getRoleName());\n      noRefCell.setRole(referenceLink.getRoleName());\n      noRefCell.setReferenceCell(true);\n      noRefCell.setSubstituteInfo(new DefaultSReferenceSubstituteInfo(mySNode, referenceLink, myEditorContext));\n      noRefCell.setRole(referenceLink.getRoleName());\n      setIndent(noRefCell);\n      addCell(noRefCell);\n    } else {\n      final SNode referentNode = reference.getTargetNode();\n      if (referentNode == null || referentNode.getModel() == null || !VisibilityUtil.isVisible(myEditorContext.getModel(), referentNode.getModel())) {\n        //todo do we need this?\n        String rinfo = ((jetbrains.mps.smodel.SReference) reference).getResolveInfo();\n        EditorCell errorCell = createErrorCell(rinfo != null ? rinfo : \"?\" + referenceLink.getRoleName() + \"?\", referenceLink);\n        errorCell.setCellId(\"error_\" + referenceLink.getRoleName());\n        addCell(errorCell);\n      } else {\n        EditorCell cell = myEditorContext.getEditorComponent().getUpdater().getCurrentUpdateSession().updateReferencedNodeCell(new Computable<EditorCell>() {\n          @Override\n          public EditorCell compute() {\n            return createReferentEditorCell(myEditorContext, referenceLink, referentNode);\n          }\n        }, referentNode, referenceLink.getRoleName());\n        //todo what is that?\n        CellUtil.setupIDeprecatableStyles(referentNode, cell);\n        setSemanticNodeToCells(cell, mySNode);\n\n        //todo rewrite cell actions\n        cell.setAction(CellActionType.DELETE, new CellAction_DeleteReference(mySNode, referenceLink.getRoleName()));\n        cell.setAction(CellActionType.BACKSPACE, new CellAction_DeleteReference(mySNode, referenceLink.getRoleName()));\n        cell.setSubstituteInfo(new DefaultSReferenceSubstituteInfo(mySNode, referenceLink, myEditorContext));\n        if (cell.getCellId() == null) {\n          cell.setCellId(\"reference_\" + referenceLink.getRoleName());\n        }\n        //todo attributes\n        addCellWithRole(IterableUtils.first(AttributeOperations.getLinkAttributes(mySNode, referenceLink)), AttributeKind.Reference.class, cell);\n      }\n    }\n\n  }","commit_id":"67051b1be11145d61ea4a1a470c4f3fb91a65c81","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).getUpdater().addExplicitEditorHintsForNode(((SNode) MapSequence.fromMap(_params).get(\"node\")).getReference(), \"jetbrains.mps.lang.core.editor.BaseEditorContextHints.reflectiveEditor\");\n    ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).rebuildEditorContent();\n  }","id":44248,"modified_method":"@Override\n  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    EditorContext editorContext = ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).getEditorContext();\n    EditorCell selectedCell = editorContext.getSelectedCell();\n    if (selectedCell == null) {\n      return;\n    }\n    int x = selectedCell.getX();\n    int y = selectedCell.getY();\n    int caretX = selectedCell.getCaretX();\n\n    ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).getUpdater().addExplicitEditorHintsForNode(((SNode) MapSequence.fromMap(_params).get(\"node\")).getReference(), \"jetbrains.mps.lang.core.editor.BaseEditorContextHints.reflectiveEditor\");\n    ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).rebuildEditorContent();\n    editorContext.flushEvents();\n    EditorCell targetCell = ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).findCellWeak(x, y);\n    if (targetCell != null) {\n      targetCell.setCaretX(caretX);\n      editorContext.getSelectionManager().setSelection(targetCell);\n    } else {\n      SelectionUtil.selectCell(editorContext, ((SNode) ((SNode) MapSequence.fromMap(_params).get(\"node\"))), SelectionManager.FIRST_EDITABLE_CELL);\n    }\n  }","commit_id":"67051b1be11145d61ea4a1a470c4f3fb91a65c81","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).getUpdater().removeExplicitEditorHintsForNode(((SNode) MapSequence.fromMap(_params).get(\"node\")).getReference(), \"jetbrains.mps.lang.core.editor.BaseEditorContextHints.reflectiveEditor\");\n    ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).rebuildEditorContent();\n  }","id":44249,"modified_method":"@Override\n  public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    EditorContext editorContext = ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).getEditorContext();\n    EditorCell selectedCell = editorContext.getSelectedCell();\n    if (selectedCell == null) {\n      return;\n    }\n    int x = selectedCell.getX();\n    int y = selectedCell.getY();\n    int caretX = selectedCell.getCaretX();\n    ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).getUpdater().removeExplicitEditorHintsForNode(((SNode) MapSequence.fromMap(_params).get(\"node\")).getReference(), \"jetbrains.mps.lang.core.editor.BaseEditorContextHints.reflectiveEditor\");\n    ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).rebuildEditorContent();\n    editorContext.flushEvents();\n    EditorCell targetCell = ((EditorComponent) MapSequence.fromMap(_params).get(\"editorComponent\")).findCellWeak(x, y);\n    if (targetCell != null) {\n      targetCell.setCaretX(caretX);\n      editorContext.getSelectionManager().setSelection(targetCell);\n    } else {\n      SelectionUtil.selectCell(editorContext, ((SNode) ((SNode) MapSequence.fromMap(_params).get(\"node\"))), SelectionManager.FIRST_EDITABLE_CELL);\n    }\n  }","commit_id":"67051b1be11145d61ea4a1a470c4f3fb91a65c81","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n      if ((AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(\"testDefaultEditor.structure.DefaultNodeAttribute\")) != null)) {\n        SNodeOperations.deleteNode(AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(\"testDefaultEditor.structure.DefaultNodeAttribute\")));\n      } else {\n        AttributeOperations.setAttribute(node, new IAttributeDescriptor.NodeAttribute(\"testDefaultEditor.structure.DefaultNodeAttribute\"), SConceptOperations.createNewNode(\"testDefaultEditor.structure.DefaultNodeAttribute\", null));\n      }\n    }","id":44250,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n      if ((AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(\"testDefaultEditor.structure.DefaultNodeAttribute\")) != null)) {\n        SNodeOperations.deleteNode(AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(\"testDefaultEditor.structure.DefaultNodeAttribute\")));\n      } else {\n        AttributeOperations.setAttribute(node, new IAttributeDescriptor.NodeAttribute(\"testDefaultEditor.structure.DefaultNodeAttribute\"), SConceptOperations.createNewNode(\"testDefaultEditor.structure.DefaultNodeAttribute\", null));\n        SelectionUtil.selectCell(editorContext, AttributeOperations.getAttribute(node, new IAttributeDescriptor.NodeAttribute(\"testDefaultEditor.structure.DefaultNodeAttribute\")), \"const\");\n      }\n    }","commit_id":"31b5e755dd84d1937c9300221b4798ad6c3d89e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n      if ((AttributeOperations.getAttribute(node, new IAttributeDescriptor.PropertyAttribute(\"testDefaultEditor.structure.DefaultPropertyAttribute\", \"age\")) != null)) {\n        SNodeOperations.deleteNode(AttributeOperations.getAttribute(node, new IAttributeDescriptor.PropertyAttribute(\"testDefaultEditor.structure.DefaultPropertyAttribute\", \"age\")));\n      } else {\n        AttributeOperations.setAttribute(node, new IAttributeDescriptor.PropertyAttribute(\"testDefaultEditor.structure.DefaultPropertyAttribute\", \"age\"), SConceptOperations.createNewNode(\"testDefaultEditor.structure.DefaultPropertyAttribute\", null));\n      }\n\n    }","id":44251,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n      if ((AttributeOperations.getAttribute(node, new IAttributeDescriptor.PropertyAttribute(\"testDefaultEditor.structure.DefaultPropertyAttribute\", \"age\")) != null)) {\n        SNodeOperations.deleteNode(AttributeOperations.getAttribute(node, new IAttributeDescriptor.PropertyAttribute(\"testDefaultEditor.structure.DefaultPropertyAttribute\", \"age\")));\n      } else {\n        AttributeOperations.setAttribute(node, new IAttributeDescriptor.PropertyAttribute(\"testDefaultEditor.structure.DefaultPropertyAttribute\", \"age\"), SConceptOperations.createNewNode(\"testDefaultEditor.structure.DefaultPropertyAttribute\", null));\n        SelectionUtil.selectCell(editorContext, AttributeOperations.getAttribute(node, new IAttributeDescriptor.PropertyAttribute(\"testDefaultEditor.structure.DefaultPropertyAttribute\", \"age\")), \"const\");\n      }\n\n    }","commit_id":"31b5e755dd84d1937c9300221b4798ad6c3d89e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(final SNode node, final EditorContext editorContext) {\n      if ((AttributeOperations.getAttribute(node, new IAttributeDescriptor.LinkAttribute(\"testDefaultEditor.structure.DefaultReferenceAttribute\", \"bestFriend\")) != null)) {\n        SNodeOperations.deleteNode(AttributeOperations.getAttribute(node, new IAttributeDescriptor.LinkAttribute(\"testDefaultEditor.structure.DefaultReferenceAttribute\", \"bestFriend\")));\n      } else {\n        AttributeOperations.setAttribute(node, new IAttributeDescriptor.LinkAttribute(\"testDefaultEditor.structure.DefaultReferenceAttribute\", \"bestFriend\"), SConceptOperations.createNewNode(\"testDefaultEditor.structure.DefaultReferenceAttribute\", null));\n      }\n\n    }","id":44252,"modified_method":"public void execute(final SNode node, final EditorContext editorContext) {\n      if ((AttributeOperations.getAttribute(node, new IAttributeDescriptor.LinkAttribute(\"testDefaultEditor.structure.DefaultReferenceAttribute\", \"bestFriend\")) != null)) {\n        SNodeOperations.deleteNode(AttributeOperations.getAttribute(node, new IAttributeDescriptor.LinkAttribute(\"testDefaultEditor.structure.DefaultReferenceAttribute\", \"bestFriend\")));\n      } else {\n        AttributeOperations.setAttribute(node, new IAttributeDescriptor.LinkAttribute(\"testDefaultEditor.structure.DefaultReferenceAttribute\", \"bestFriend\"), SConceptOperations.createNewNode(\"testDefaultEditor.structure.DefaultReferenceAttribute\", null));\n        SelectionUtil.selectCell(editorContext, AttributeOperations.getAttribute(node, new IAttributeDescriptor.LinkAttribute(\"testDefaultEditor.structure.DefaultReferenceAttribute\", \"bestFriend\")), \"const\");\n      }\n\n    }","commit_id":"31b5e755dd84d1937c9300221b4798ad6c3d89e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addPropertyCellForNonNullConcept(String name) {\n    CellProviderWithRole provider = new PropertyCellProvider(mySNode, myEditorContext);\n    provider.setRole(name);\n    provider.setNoTargetText(\"<no \" + name + \">\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(myEditorContext);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    editorCell.setCellId(\"property_\" + name);\n     addCellWithRole(provider, editorCell);\n  }","id":44253,"modified_method":"private void addPropertyCellForNonNullConcept(String name) {\n    CellProviderWithRole provider = new PropertyCellProvider(mySNode, myEditorContext);\n    provider.setRole(name);\n    provider.setNoTargetText(\"<no \" + name + \">\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(myEditorContext);\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    if (editorCell.getCellId() == null) {\n      editorCell.setCellId(\"property_\" + name);\n    }\n    addCellWithRole(provider, editorCell);\n  }","commit_id":"31b5e755dd84d1937c9300221b4798ad6c3d89e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addRefCellForNonNullConcept(String role) {\n    CellProviderWithRole provider = new RefCellCellProvider(mySNode, myEditorContext);\n    provider.setAuxiliaryCellProvider(new MyAbstractCellProvider(role));\n    provider.setRole(role);\n    provider.setNoTargetText(\"<no \" + role + \">\");\n    EditorCell editorCell = provider.createEditorCell(myEditorContext);\n    if (editorCell.getRole() == null) {\n      editorCell.setRole(role);\n      editorCell.setReferenceCell(true);\n    }\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    addCellWithRole(provider, editorCell);\n  }","id":44254,"modified_method":"private void addRefCellForNonNullConcept(String role) {\n    CellProviderWithRole provider = new RefCellCellProvider(mySNode, myEditorContext);\n    provider.setAuxiliaryCellProvider(new MyAbstractCellProvider(role));\n    provider.setRole(role);\n    provider.setNoTargetText(\"<no \" + role + \">\");\n    EditorCell editorCell = provider.createEditorCell(myEditorContext);\n    if (editorCell.getRole() == null) {\n      editorCell.setRole(role);\n      editorCell.setReferenceCell(true);\n    }\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    if (editorCell.getCellId() == null) {\n      editorCell.setCellId(\"reference_\" + role);\n    }\n    addCellWithRole(provider, editorCell);\n  }","commit_id":"31b5e755dd84d1937c9300221b4798ad6c3d89e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_gltv09_a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"$N$\");\n    editorCell.setCellId(\"Constant_gltv09_a0\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":44255,"modified_method":"private EditorCell createConstant_gltv09_a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"$N$\");\n    editorCell.setCellId(\"const\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"31b5e755dd84d1937c9300221b4798ad6c3d89e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_tfur4z_a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"$P$\");\n    editorCell.setCellId(\"Constant_tfur4z_a0\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":44256,"modified_method":"private EditorCell createConstant_tfur4z_a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"$P$\");\n    editorCell.setCellId(\"const\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"31b5e755dd84d1937c9300221b4798ad6c3d89e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_nltvu5_a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"$R$\");\n    editorCell.setCellId(\"Constant_nltvu5_a0\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":44257,"modified_method":"private EditorCell createConstant_nltvu5_a0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"$R$\");\n    editorCell.setCellId(\"const\");\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"31b5e755dd84d1937c9300221b4798ad6c3d89e4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent targetCreature = game.getPermanent(source.getFirstTarget());\r\n        if (targetCreature != null) {\r\n            Player player = game.getPlayer(targetCreature.getControllerId());\r\n            if (player != null) {\r\n                cost.clearPaid();\r\n                if (!cost.pay(source, game, targetCreature.getControllerId(), targetCreature.getControllerId(), false)) {\r\n                    return targetCreature.moveToZone(Zone.HAND, source.getSourceId(), game, true);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","id":44258,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Permanent targetCreature = game.getPermanent(source.getFirstTarget());\r\n        if (targetCreature != null) {\r\n            Player player = game.getPlayer(targetCreature.getControllerId());\r\n            if (player != null) {\r\n                cost.clearPaid();\r\n                final StringBuilder sb = new StringBuilder(\"Pay {1} otherwise \").append(targetCreature.getName()).append(\" will be returned to its owner's hand)\");\r\n                if (player.chooseUse(Outcome.Benefit, sb.toString(), game)) {\r\n                    cost.pay(source, game, targetCreature.getControllerId(), targetCreature.getControllerId(), true);\r\n                }\r\n                if (!cost.isPaid()) {\r\n                    return targetCreature.moveToZone(Zone.HAND, source.getSourceId(), game, true);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"2aa984d4d6338d258499e42aaeaee8bc952cb31d","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public String getText(Mode mode) {\n        StringBuilder sb = new StringBuilder();\n        if (mode.getTargets().size() == 0) {\n            sb.append(\"counter it\");\n        }\n        else {\n            sb.append(\"Counter target \").append(mode.getTargets().get(0).getTargetName());\n        }\n        sb.append(\" unless its controller pays \");\n        if (cost != null) {\n            sb.append(cost.getText());\n        } else {\n            sb.append(\"{X}\");\n        }\n        if (genericMana != null && !genericMana.getMessage().isEmpty()) {\n            sb.append(\", where X is your \");\n            sb.append(genericMana.getMessage());\n        }\n        return sb.toString();\n    }","id":44259,"modified_method":"@Override\n    public String getText(Mode mode) {\n        if (staticText != null && !staticText.isEmpty()) {\n            return staticText;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        if (mode.getTargets().size() == 0) {\n            sb.append(\"counter it\");\n        }\n        else {\n            sb.append(\"Counter target \").append(mode.getTargets().get(0).getTargetName());\n        }\n        sb.append(\" unless its controller pays \");\n        if (cost != null) {\n            sb.append(cost.getText());\n        } else {\n            sb.append(\"{X}\");\n        }\n        if (genericMana != null && !genericMana.getMessage().isEmpty()) {\n            sb.append(\", where X is your \");\n            sb.append(genericMana.getMessage());\n        }\n        return sb.toString();\n    }","commit_id":"a2b650722a617a55656ef0abfcb0aeb37058a51c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        StackObject spell = game.getStack().getStackObject(targetPointer.getFirst(game, source));\n        if (spell != null) {\n            Player player = game.getPlayer(spell.getControllerId());\n            if (player != null) {\n                Cost costToPay;\n                if (cost != null) {\n                    costToPay = cost.copy();\n                } else  {\n                    costToPay = new GenericManaCost(genericMana.calculate(game, source));\n                }\n                costToPay.clearPaid();\n                if (!costToPay.pay(source, game, spell.getSourceId(), spell.getControllerId(), false)) {\n                    return game.getStack().counter(spell.getId(), source.getSourceId(), game);\n                }\n                return true;\n            }\n        }\n        return false;\n    }","id":44260,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        StackObject spell = game.getStack().getStackObject(targetPointer.getFirst(game, source));\n        if (spell != null) {\n            Player player = game.getPlayer(spell.getControllerId());\n            if (player != null) {\n                Cost costToPay;\n                if (cost != null) {\n                    costToPay = cost.copy();\n                } else  {\n                    costToPay = new GenericManaCost(genericMana.calculate(game, source));\n                }\n                String message;\n                if (costToPay instanceof ManaCost) {\n                    message = \"Would you like to pay \" + costToPay.getText() + \" to prevent counter effect?\";\n                } else {\n                    message = costToPay.getText() + \" to prevent counter effect?\";\n                }\n                costToPay.clearPaid();\n                if (!(player.chooseUse(Outcome.Benefit, message, game) && costToPay.pay(source, game, spell.getSourceId(), spell.getControllerId(), false))) {\n                    return game.getStack().counter(spell.getId(), source.getSourceId(), game);\n                }\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"a2b650722a617a55656ef0abfcb0aeb37058a51c","url":"https://github.com/magefree/mage"},{"original_method":"public PainfulQuandryEffect() {\n        super(Outcome.Damage);\n        staticText = \"player loses 5 life unless he or she discards a card\";\n    }","id":44261,"modified_method":"public PainfulQuandryEffect() {\n        super(Outcome.LoseLife);\n        staticText = \"that player loses 5 life unless he or she discards a card\";\n    }","commit_id":"6dc7b72198733fa30770b89ad31f0cee16a4f3d8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(targetPointer.getFirst(game, source));\n        if (player != null) {\n            Cost cost = new DiscardTargetCost(new TargetCardInHand());\n            if (cost.canPay(source, player.getId(), player.getId(), game)) {\n                if (!cost.pay(source, game, player.getId(), player.getId(), false)) {\n                    player.loseLife(5, game);\n                }\n                return true;\n            }\n        }\n        return false;\n    }","id":44262,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(targetPointer.getFirst(game, source));\n        if (player != null) {\n            boolean paid = false;\n            Cost cost = new DiscardTargetCost(new TargetCardInHand());\n            if (cost.canPay(source, player.getId(), player.getId(), game)\n                    && player.chooseUse(Outcome.Detriment, \"Discard a card (otherwise you lose 5 life)?\", game)) {\n                paid = cost.pay(source, game, source.getSourceId(), player.getId(), false);\n            }\n            if (!paid) {\n                player.loseLife(5, game);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"6dc7b72198733fa30770b89ad31f0cee16a4f3d8","url":"https://github.com/magefree/mage"},{"original_method":"public PainfulQuandary(UUID ownerId) {\n        super(ownerId, 73, \"Painful Quandary\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{3}{B}{B}\");\n        this.expansionSetCode = \"SOM\";\n        this.color.setBlack(true);\n        this.addAbility(new PainfulQuandryAbility());\n    }","id":44263,"modified_method":"public PainfulQuandary(UUID ownerId) {\n        super(ownerId, 73, \"Painful Quandary\", Rarity.RARE, new CardType[]{CardType.ENCHANTMENT}, \"{3}{B}{B}\");\n        this.expansionSetCode = \"SOM\";\n        this.color.setBlack(true);\n\n        // Whenever an opponent casts a spell, that player loses 5 life unless he or she discards a card.\n        this.addAbility(new SpellCastOpponentTriggeredAbility(new PainfulQuandryEffect(), false));\n    }","commit_id":"6dc7b72198733fa30770b89ad31f0cee16a4f3d8","url":"https://github.com/magefree/mage"},{"original_method":"public Element toXML(boolean bWithAttachmentContent, boolean bWithVersions, XWikiContext context) throws XWikiException {\r\n        Element docel = new DOMElement(\"attachment\");\r\n        Element el = new DOMElement(\"filename\");\r\n        el.addText(getFilename());\r\n        docel.add(el);\r\n\r\n        el = new DOMElement(\"filesize\");\r\n        el.addText(\"\" + getFilesize());\r\n        docel.add(el);\r\n\r\n        el = new DOMElement(\"author\");\r\n        el.addText(getAuthor());\r\n        docel.add(el);\r\n\r\n        long d = getDate().getTime();\r\n        el = new DOMElement(\"date\");\r\n        el.addText(\"\" + d);\r\n        docel.add(el);\r\n\r\n        el = new DOMElement(\"version\");\r\n        el.addText(getVersion());\r\n        docel.add(el);\r\n\r\n        el = new DOMElement(\"comment\");\r\n        el.addText(getComment());\r\n        docel.add(el);\r\n\r\n        if (bWithAttachmentContent) {\r\n            el = new DOMElement(\"content\");\r\n            // We need to make sure content is loaded\r\n            loadContent(context);\r\n            XWikiAttachmentContent acontent = getAttachment_content();\r\n            if (acontent!=null) {\r\n             byte[] bcontent = getAttachment_content().getContent();\r\n             String content = new String(Base64.encodeBase64(bcontent));\r\n             el.addText(content);\r\n            } else {\r\n                el.addText(\"\");\r\n            }\r\n            docel.add(el);\r\n        }\r\n\r\n        if (bWithVersions) {\r\n            // We need to make sure content is loaded\r\n            loadArchive(context);\r\n            XWikiAttachmentArchive aarchive = getAttachment_archive();\r\n            if (aarchive!=null) {\r\n                el = new DOMElement(\"versions\");\r\n                try {\r\n                    el.addText(aarchive.getArchive().toString());\r\n                } catch (XWikiException e) {\r\n                    return null;\r\n                }\r\n                docel.add(el);\r\n            }\r\n        }\r\n        return docel;\r\n    }","id":44264,"modified_method":"public Element toXML(boolean bWithAttachmentContent, boolean bWithVersions, XWikiContext context) throws XWikiException {\r\n        Element docel = new DOMElement(\"attachment\");\r\n        Element el = new DOMElement(\"filename\");\r\n        el.addText(getFilename());\r\n        docel.add(el);\r\n\r\n        el = new DOMElement(\"filesize\");\r\n        el.addText(\"\" + getFilesize());\r\n        docel.add(el);\r\n\r\n        el = new DOMElement(\"author\");\r\n        el.addText(getAuthor());\r\n        docel.add(el);\r\n\r\n        long d = getDate().getTime();\r\n        el = new DOMElement(\"date\");\r\n        el.addText(\"\" + d);\r\n        docel.add(el);\r\n\r\n        el = new DOMElement(\"version\");\r\n        el.addText(getVersion());\r\n        docel.add(el);\r\n\r\n        el = new DOMElement(\"comment\");\r\n        el.addText(getComment());\r\n        docel.add(el);\r\n\r\n        if (bWithAttachmentContent) {\r\n            el = new DOMElement(\"content\");\r\n            // We need to make sure content is loaded\r\n            loadContent(context);\r\n            XWikiAttachmentContent acontent = getAttachment_content();\r\n            if (acontent!=null) {\r\n             byte[] bcontent = getAttachment_content().getContent();\r\n             String content = new String(Base64.encodeBase64(bcontent));\r\n             el.addText(content);\r\n            } else {\r\n                el.addText(\"\");\r\n            }\r\n            docel.add(el);\r\n        }\r\n\r\n        if (bWithVersions) {\r\n            // We need to make sure content is loaded\r\n            loadArchive(context);\r\n            XWikiAttachmentArchive aarchive = getAttachment_archive();\r\n            if (aarchive!=null) {\r\n                el = new DOMElement(\"versions\");\r\n                try {\r\n                    el.addText(new String(aarchive.getArchive()));\r\n                } catch (XWikiException e) {\r\n                    return null;\r\n                }\r\n                docel.add(el);\r\n            }\r\n        }\r\n        return docel;\r\n    }","commit_id":"6ad812f9c336bd288dd14bbef6cb4326e6f160eb","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testGitService() {\n        FabricTestSupport.getRequiredService(GitService.class);\n    }","id":44265,"modified_method":"@Test\n    public void testGitService() {\n        ServiceLocator.getRequiredService(GitService.class);\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testBootstrapConfiguration() {\n        BootstrapConfiguration service = FabricTestSupport.getRequiredService(BootstrapConfiguration.class);\n        CreateEnsembleOptions options = service.getBootstrapOptions();\n        Assert.assertFalse(\"Ensemble start\", options.isEnsembleStart());\n    }","id":44266,"modified_method":"@Test\n    public void testBootstrapConfiguration() {\n        BootstrapConfiguration service = ServiceLocator.getRequiredService(BootstrapConfiguration.class);\n        CreateEnsembleOptions options = service.getBootstrapOptions();\n        Assert.assertFalse(\"Ensemble start\", options.isEnsembleStart());\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Deployment\n    @StartLevelAware(autostart = true)\n    public static Archive<?> deployment() {\n        final ArchiveBuilder archive = new ArchiveBuilder(\"bootstrap-service-test\");\n        archive.addClasses(RuntimeType.TOMCAT, AnnotatedContextListener.class);\n        archive.addClasses(FabricTestSupport.class);\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                if (ArchiveBuilder.getTargetContainer() == RuntimeType.KARAF) {\n                    OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                    builder.addBundleManifestVersion(2);\n                    builder.addBundleSymbolicName(archive.getName());\n                    builder.addBundleVersion(\"1.0.0\");\n                    builder.addManifestHeader(Constants.GRAVIA_ENABLED, Boolean.TRUE.toString());\n                    builder.addImportPackages(RuntimeLocator.class, FabricService.class);\n                    return builder.openStream();\n                } else {\n                    ManifestBuilder builder = new ManifestBuilder();\n                    builder.addIdentityCapability(archive.getName(), \"1.0.0\");\n                    builder.addManifestHeader(\"Dependencies\", \"org.jboss.gravia,io.fabric8.api\");\n                    return builder.openStream();\n                }\n            }\n        });\n        return archive.getArchive();\n    }","id":44267,"modified_method":"@Deployment\n    @StartLevelAware(autostart = true)\n    public static Archive<?> deployment() {\n        final ArchiveBuilder archive = new ArchiveBuilder(\"bootstrap-service-test\");\n        archive.addClasses(RuntimeType.TOMCAT, AnnotatedContextListener.class);\n        archive.addPackage(CommandSupport.class.getPackage());\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                if (ArchiveBuilder.getTargetContainer() == RuntimeType.KARAF) {\n                    OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                    builder.addBundleManifestVersion(2);\n                    builder.addBundleSymbolicName(archive.getName());\n                    builder.addBundleVersion(\"1.0.0\");\n                    builder.addManifestHeader(Constants.GRAVIA_ENABLED, Boolean.TRUE.toString());\n                    builder.addImportPackages(RuntimeLocator.class, FabricService.class);\n                    return builder.openStream();\n                } else {\n                    ManifestBuilder builder = new ManifestBuilder();\n                    builder.addIdentityCapability(archive.getName(), \"1.0.0\");\n                    builder.addManifestHeader(\"Dependencies\", \"org.jboss.gravia,io.fabric8.api\");\n                    return builder.openStream();\n                }\n            }\n        });\n        return archive.getArchive();\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testZooKeeperClusterBootstrapAvailable() throws Exception {\n        ZooKeeperClusterBootstrap bootstrap = FabricTestSupport.getRequiredService(ZooKeeperClusterBootstrap.class);\n        Assert.assertNotNull(\"ZooKeeperClusterBootstrap not null\", bootstrap);\n    }","id":44268,"modified_method":"@Test\n    public void testZooKeeperClusterBootstrapAvailable() throws Exception {\n        ZooKeeperClusterBootstrap bootstrap = ServiceLocator.getRequiredService(ZooKeeperClusterBootstrap.class);\n        Assert.assertNotNull(\"ZooKeeperClusterBootstrap not null\", bootstrap);\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Execute a command in process by direct lookup/invocation of the associated command service\n     * The osgi.command.scope and osgi.command.function parameter values are derived from\n     * the first commadn string token\n     */\n    public static String executeCommand(String cmdstr, CommandSession session) throws Exception {\n        List<String> tokens = Arrays.asList(cmdstr.split(\"\\\\s\"));\n        String[] header = tokens.get(0).split(\":\");\n        Assert.assertTrue(\"Two tokens\", header.length == 2);\n        String filter = \"(&(osgi.command.scope=\" + header[0] + \")(osgi.command.function=\" + header[1] + \"))\";\n        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();\n        AbstractCommand command = (AbstractCommand) ServiceLocator.awaitService(moduleContext, Function.class, filter);\n        List<Object> args = new ArrayList<Object>(tokens);\n        args.remove(0);\n        Object result = command.execute(session, args);\n        return result != null ? result.toString() : null;\n    }","id":44269,"modified_method":"private static void executeCommand(String cmdstr, CommandSession commandSession) throws Exception {\n\n        // Get the command service\n        List<String> tokens = Arrays.asList(cmdstr.split(\"\\\\s\"));\n        String[] header = tokens.get(0).split(\":\");\n        Assert.assertTrue(\"Two tokens in: \" + tokens.get(0), header.length == 2);\n        String filter = \"(&(osgi.command.scope=\" + header[0] + \")(osgi.command.function=\" + header[1] + \"))\";\n        AbstractCommand command =  (AbstractCommand) ServiceLocator.awaitService(Function.class, filter);\n        commandSession.put(AbstractCommand.class.getName(), command);\n\n        // Execute a command through the CommandSession\n        commandSession.execute(cmdstr);\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static String executeCommands(String... commands) throws Exception {\n        StringBuffer aggregated = new StringBuffer();\n        for (String cmdstr : commands) {\n            String result = executeCommand(cmdstr, new DummyCommandSession());\n            if (result != null) {\n                aggregated.append(result);\n            }\n            return result;\n        }\n        return aggregated.length() > 0 ? aggregated.toString() : null;\n    }","id":44270,"modified_method":"public static String executeCommands(String... commands) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        PrintStream printStream = new PrintStream(baos);\n\n        CommandSession commandSession = getCommandSession(printStream);\n        for (String cmdstr : commands) {\n            System.out.println(cmdstr);\n            executeCommand(cmdstr, commandSession);\n        }\n\n        printStream.flush();\n        String result = baos.toString();\n        System.out.println(result);\n        return result;\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static String executeCommand(String cmdstr) throws Exception {\n        return executeCommand(cmdstr, new DummyCommandSession());\n    }","id":44271,"modified_method":"public static String executeCommand(String cmdstr) throws Exception {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        PrintStream printStream = new PrintStream(baos);\n\n        System.out.println(cmdstr);\n        CommandSession commandSession = getCommandSession(printStream);\n        executeCommand(cmdstr, commandSession);\n\n        printStream.flush();\n        String result = baos.toString();\n        System.out.println(result);\n        return result;\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Deployment\n    @StartLevelAware(autostart = true)\n    public static Archive<?> deployment() {\n        final ArchiveBuilder archive = new ArchiveBuilder(\"container-startup-test\");\n        archive.addClasses(RuntimeType.TOMCAT, AnnotatedContextListener.class);\n        archive.addClasses(FabricTestSupport.class);\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                if (ArchiveBuilder.getTargetContainer() == RuntimeType.KARAF) {\n                    OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                    builder.addBundleManifestVersion(2);\n                    builder.addBundleSymbolicName(archive.getName());\n                    builder.addBundleVersion(\"1.0.0\");\n                    builder.addManifestHeader(Constants.GRAVIA_ENABLED, Boolean.TRUE.toString());\n                    builder.addImportPackages(RuntimeLocator.class, FabricService.class);\n                    builder.addImportPackages(ConfigurationAdmin.class);\n                    return builder.openStream();\n                } else {\n                    ManifestBuilder builder = new ManifestBuilder();\n                    builder.addIdentityCapability(archive.getName(), \"1.0.0\");\n                    builder.addManifestHeader(\"Dependencies\", \"org.jboss.gravia,io.fabric8.api\");\n                    return builder.openStream();\n                }\n            }\n        });\n        return archive.getArchive();\n    }","id":44272,"modified_method":"@Deployment\n    @StartLevelAware(autostart = true)\n    public static Archive<?> deployment() {\n        final ArchiveBuilder archive = new ArchiveBuilder(\"container-startup-test\");\n        archive.addClasses(RuntimeType.TOMCAT, AnnotatedContextListener.class);\n        archive.addPackage(CommandSupport.class.getPackage());\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                if (ArchiveBuilder.getTargetContainer() == RuntimeType.KARAF) {\n                    OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                    builder.addBundleManifestVersion(2);\n                    builder.addBundleSymbolicName(archive.getName());\n                    builder.addBundleVersion(\"1.0.0\");\n                    builder.addManifestHeader(Constants.GRAVIA_ENABLED, Boolean.TRUE.toString());\n                    builder.addImportPackages(RuntimeLocator.class, FabricService.class);\n                    builder.addImportPackages(ConfigurationAdmin.class);\n                    return builder.openStream();\n                } else {\n                    ManifestBuilder builder = new ManifestBuilder();\n                    builder.addIdentityCapability(archive.getName(), \"1.0.0\");\n                    builder.addManifestHeader(\"Dependencies\", \"org.jboss.gravia,io.fabric8.api\");\n                    return builder.openStream();\n                }\n            }\n        });\n        return archive.getArchive();\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testLocalFabricCluster() throws Exception {\n\n        String zkpassword = System.getProperty(CreateEnsembleOptions.ZOOKEEPER_PASSWORD);\n        Assert.assertNotNull(CreateEnsembleOptions.ZOOKEEPER_PASSWORD + \" not null\", zkpassword);\n        Builder<?> builder = CreateEnsembleOptions.builder().agentEnabled(false).clean(true).zookeeperPassword(zkpassword).waitForProvision(false);\n        CreateEnsembleOptions options = builder.build();\n\n        ModuleContext syscontext = RuntimeLocator.getRequiredRuntime().getModuleContext();\n        ZooKeeperClusterBootstrap bootstrap = syscontext.getService(syscontext.getServiceReference(ZooKeeperClusterBootstrap.class));\n        bootstrap.create(options);\n\n        FabricService fabricService = FabricTestSupport.getService(FabricService.class);\n        Container[] containers = fabricService.getContainers();\n        Assert.assertNotNull(\"Containers not null\", containers);\n\n        //Test that a provided by command line password exists\n        ConfigurationAdmin configurationAdmin = FabricTestSupport.getRequiredService(ConfigurationAdmin.class);\n        org.osgi.service.cm.Configuration configuration = configurationAdmin.getConfiguration(io.fabric8.api.Constants.ZOOKEEPER_CLIENT_PID);\n        Dictionary<String, Object> dictionary = configuration.getProperties();\n        Assert.assertEquals(\"Expected provided zookeeper password\", \"systempassword\", dictionary.get(\"zookeeper.password\"));\n    }","id":44273,"modified_method":"@Test\n    public void testLocalFabricCluster() throws Exception {\n\n        Builder<?> builder = CreateEnsembleOptions.builder().agentEnabled(false).clean(true).zookeeperPassword(\"systempassword\").waitForProvision(false);\n        CreateEnsembleOptions options = builder.build();\n\n        ZooKeeperClusterBootstrap bootstrap = ServiceLocator.getRequiredService(ZooKeeperClusterBootstrap.class);\n        bootstrap.create(options);\n\n        FabricService fabricService = ServiceLocator.getRequiredService(FabricService.class);\n        Container[] containers = fabricService.getContainers();\n        Assert.assertNotNull(\"Containers not null\", containers);\n\n        //Test that a provided by command line password exists\n        ConfigurationAdmin configurationAdmin = ServiceLocator.getRequiredService(ConfigurationAdmin.class);\n        org.osgi.service.cm.Configuration configuration = configurationAdmin.getConfiguration(io.fabric8.api.Constants.ZOOKEEPER_CLIENT_PID);\n        Dictionary<String, Object> dictionary = configuration.getProperties();\n        Assert.assertEquals(\"Expected provided zookeeper password\", \"systempassword\", dictionary.get(\"zookeeper.password\"));\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * This tests the simple scenario of\n     * 1. create a child container\n     * 2. create a new version\n     * 3. modify the profile of the new version\n     * 4. upgrade all containers\n     * 5. verify that child is provisioned according to the new version\n     * 6. rollback containers.\n     * 7. verify that the child is provisioned according to the old version.\n     */\n    @Test\n    public void testContainerUpgradeAndRollback() throws Exception {\n        System.out.println(CommandSupport.executeCommand(\"fabric:create -n\"));\n        Set<Container> containers = ContainerBuilder.create().withName(\"camel\").withProfiles(\"feature-camel\").assertProvisioningResult().build();\n        try {\n            System.out.println(CommandSupport.executeCommand(\"fabric:version-create --parent 1.0 1.1\"));\n\n            ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();\n            ServiceProxy<FabricService> fabricProxy = ServiceProxy.createServiceProxy(moduleContext, FabricService.class);\n            try {\n                //Make sure that the profile change has been applied before changing the version\n                CountDownLatch latch = WaitForConfigurationChange.on(fabricProxy.getService());\n                System.out.println(CommandSupport.executeCommand(\"fabric:profile-edit --features camel-hazelcast feature-camel 1.1\"));\n                Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n            } finally {\n                fabricProxy.close();\n            }\n\n            System.out.println(CommandSupport.executeCommand(\"fabric:profile-display --version 1.1 feature-camel\"));\n            System.out.println(CommandSupport.executeCommand(\"fabric:container-upgrade --all 1.1\"));\n            Provision.provisioningSuccess(containers, FabricTestSupport.PROVISION_TIMEOUT);\n            System.out.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n            for (Container container : containers) {\n                Assert.assertEquals(\"Container should have version 1.1\", \"1.1\", container.getVersion().getId());\n                String bundles = CommandSupport.executeCommand(\"container-connect -u admin -p admin \" + container.getId() + \" osgi:list -s | grep camel-hazelcast\");\n                Assert.assertNotNull(bundles);\n                System.out.println(bundles);\n                Assert.assertFalse(\"Expected camel-hazelcast installed on container:\"+container.getId()+\".\", bundles.isEmpty());\n            }\n\n            System.out.println(CommandSupport.executeCommand(\"fabric:container-rollback --all 1.0\"));\n            Provision.provisioningSuccess(containers, FabricTestSupport.PROVISION_TIMEOUT);\n            System.out.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n\n            for (Container container : containers) {\n                Assert.assertEquals(\"Container should have version 1.0\",   \"1.0\", container.getVersion().getId());\n                String bundles = CommandSupport.executeCommand(\"container-connect -u admin -p admin \" + container.getId() + \" osgi:list -s | grep camel-hazelcast\");\n                Assert.assertNotNull(bundles);\n                System.out.println(bundles);\n                Assert.assertTrue(\"Expected no camel-hazelcast installed on container:\"+container.getId()+\".\", bundles.isEmpty());\n            }\n        } finally {\n            ContainerBuilder.destroy(containers);\n        }\n    }","id":44274,"modified_method":"/**\n     * This tests the simple scenario of\n     * 1. create a child container\n     * 2. create a new version\n     * 3. modify the profile of the new version\n     * 4. upgrade all containers\n     * 5. verify that child is provisioned according to the new version\n     * 6. rollback containers.\n     * 7. verify that the child is provisioned according to the old version.\n     */\n    @Test\n    public void testContainerUpgradeAndRollback() throws Exception {\n        CommandSupport.executeCommand(\"fabric:create --clean -n\");\n        Set<Container> containers = ContainerBuilder.create().withName(\"camel\").withProfiles(\"feature-camel\").assertProvisioningResult().build();\n        try {\n            CommandSupport.executeCommand(\"fabric:version-create --parent 1.0 1.1\");\n\n            ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();\n            ServiceProxy<FabricService> fabricProxy = ServiceProxy.createServiceProxy(moduleContext, FabricService.class);\n            try {\n                //Make sure that the profile change has been applied before changing the version\n                CountDownLatch latch = WaitForConfigurationChange.on(fabricProxy.getService());\n                CommandSupport.executeCommand(\"fabric:profile-edit --features camel-hazelcast feature-camel 1.1\");\n                Assert.assertTrue(latch.await(5, TimeUnit.SECONDS));\n            } finally {\n                fabricProxy.close();\n            }\n\n            CommandSupport.executeCommand(\"fabric:profile-display --version 1.1 feature-camel\");\n            CommandSupport.executeCommand(\"fabric:container-upgrade --all 1.1\");\n            Provision.provisioningSuccess(containers, FabricEnsembleSupport.PROVISION_TIMEOUT);\n            CommandSupport.executeCommand(\"fabric:container-list\");\n            for (Container container : containers) {\n                Assert.assertEquals(\"Container should have version 1.1\", \"1.1\", container.getVersion().getId());\n                String bundles = CommandSupport.executeCommand(\"fabric:container-connect -u admin -p admin \" + container.getId() + \" osgi:list -s | grep camel-hazelcast\");\n                Assert.assertNotNull(bundles);\n                System.out.println(bundles);\n                Assert.assertFalse(\"Expected camel-hazelcast installed on container: \" + container.getId(), bundles.isEmpty());\n            }\n\n            CommandSupport.executeCommand(\"fabric:container-rollback --all 1.0\");\n            Provision.provisioningSuccess(containers, FabricEnsembleSupport.PROVISION_TIMEOUT);\n            CommandSupport.executeCommand(\"fabric:container-list\");\n\n            for (Container container : containers) {\n                Assert.assertEquals(\"Container should have version 1.0\", \"1.0\", container.getVersion().getId());\n                String bundles = CommandSupport.executeCommand(\"fabric:container-connect -u admin -p admin \" + container.getId() + \" osgi:list -s | grep camel-hazelcast\");\n                Assert.assertNotNull(bundles);\n                System.out.println(bundles);\n                Assert.assertTrue(\"Expected no camel-hazelcast installed on container: \" + container.getId(), bundles.isEmpty());\n            }\n        } finally {\n            ContainerBuilder.destroy(containers);\n        }\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Deployment\n    @StartLevelAware(autostart = true)\n    public static Archive<?> deployment() {\n        final ArchiveBuilder archive = new ArchiveBuilder(\"container-upgrade-rollback-test\");\n        archive.addClasses(RuntimeType.TOMCAT, AnnotatedContextListener.class);\n        archive.addPackage(FabricTestSupport.class.getPackage());\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                if (ArchiveBuilder.getTargetContainer() == RuntimeType.KARAF) {\n                    OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                    builder.addBundleManifestVersion(2);\n                    builder.addBundleSymbolicName(archive.getName());\n                    builder.addBundleVersion(\"1.0.0\");\n                    builder.addManifestHeader(Constants.GRAVIA_ENABLED, Boolean.TRUE.toString());\n                    builder.addImportPackages(RuntimeLocator.class, FabricService.class);\n                    builder.addImportPackages(AbstractCommand.class, Action.class);\n                    builder.addImportPackage(\"org.apache.felix.service.command;status=provisional\");\n                    builder.addImportPackages(ConfigurationAdmin.class, ServiceTracker.class);\n                    return builder.openStream();\n                } else {\n                    ManifestBuilder builder = new ManifestBuilder();\n                    builder.addIdentityCapability(archive.getName(), \"1.0.0\");\n                    builder.addManifestHeader(\"Dependencies\", \"io.fabric8.api,org.apache.karaf,org.jboss.gravia\");\n                    return builder.openStream();\n                }\n            }\n        });\n        Archive<?> archive2 = archive.getArchive();\n        archive2.toString(true);\n        return archive2;\n    }","id":44275,"modified_method":"@Deployment\n    @StartLevelAware(autostart = true)\n    public static Archive<?> deployment() {\n        final ArchiveBuilder archive = new ArchiveBuilder(\"container-upgrade-rollback-test\");\n        archive.addClasses(RuntimeType.TOMCAT, AnnotatedContextListener.class);\n        archive.addPackage(CommandSupport.class.getPackage());\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                if (ArchiveBuilder.getTargetContainer() == RuntimeType.KARAF) {\n                    OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                    builder.addBundleManifestVersion(2);\n                    builder.addBundleSymbolicName(archive.getName());\n                    builder.addBundleVersion(\"1.0.0\");\n                    builder.addManifestHeader(Constants.GRAVIA_ENABLED, Boolean.TRUE.toString());\n                    builder.addImportPackages(RuntimeLocator.class, FabricService.class);\n                    builder.addImportPackages(AbstractCommand.class, Action.class);\n                    builder.addImportPackage(\"org.apache.felix.service.command;status=provisional\");\n                    builder.addImportPackages(ConfigurationAdmin.class);\n                    return builder.openStream();\n                } else {\n                    ManifestBuilder builder = new ManifestBuilder();\n                    builder.addIdentityCapability(archive.getName(), \"1.0.0\");\n                    builder.addManifestHeader(\"Dependencies\", \"io.fabric8.api,org.apache.karaf,org.jboss.gravia\");\n                    return builder.openStream();\n                }\n            }\n        });\n        return archive.getArchive();\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Deployment\n    @StartLevelAware(autostart = true)\n    public static Archive<?> deployment() {\n        final ArchiveBuilder archive = new ArchiveBuilder(\"create-child-test\");\n        archive.addClasses(RuntimeType.TOMCAT, AnnotatedContextListener.class);\n        archive.addPackage(FabricTestSupport.class.getPackage());\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                if (ArchiveBuilder.getTargetContainer() == RuntimeType.KARAF) {\n                    OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                    builder.addBundleManifestVersion(2);\n                    builder.addBundleSymbolicName(archive.getName());\n                    builder.addBundleVersion(\"1.0.0\");\n                    builder.addManifestHeader(Constants.GRAVIA_ENABLED, Boolean.TRUE.toString());\n                    builder.addImportPackages(RuntimeLocator.class, FabricService.class);\n                    builder.addImportPackages(AbstractCommand.class, Action.class);\n                    builder.addImportPackage(\"org.apache.felix.service.command;status=provisional\");\n                    builder.addImportPackages(ConfigurationAdmin.class, ServiceTracker.class);\n                    return builder.openStream();\n                } else {\n                    ManifestBuilder builder = new ManifestBuilder();\n                    builder.addIdentityCapability(archive.getName(), \"1.0.0\");\n                    builder.addManifestHeader(\"Dependencies\", \"io.fabric8.api,org.apache.karaf,org.jboss.gravia\");\n                    return builder.openStream();\n                }\n            }\n        });\n        Archive<?> archive2 = archive.getArchive();\n        archive2.toString(true);\n        return archive2;\n    }","id":44276,"modified_method":"@Deployment\n    @StartLevelAware(autostart = true)\n    public static Archive<?> deployment() {\n        final ArchiveBuilder archive = new ArchiveBuilder(\"create-child-test\");\n        archive.addClasses(RuntimeType.TOMCAT, AnnotatedContextListener.class);\n        archive.addPackage(CommandSupport.class.getPackage());\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                if (ArchiveBuilder.getTargetContainer() == RuntimeType.KARAF) {\n                    OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                    builder.addBundleManifestVersion(2);\n                    builder.addBundleSymbolicName(archive.getName());\n                    builder.addBundleVersion(\"1.0.0\");\n                    builder.addManifestHeader(Constants.GRAVIA_ENABLED, Boolean.TRUE.toString());\n                    builder.addImportPackages(RuntimeLocator.class, FabricService.class);\n                    builder.addImportPackages(AbstractCommand.class, Action.class);\n                    builder.addImportPackage(\"org.apache.felix.service.command;status=provisional\");\n                    builder.addImportPackages(ConfigurationAdmin.class, ServiceTracker.class);\n                    return builder.openStream();\n                } else {\n                    ManifestBuilder builder = new ManifestBuilder();\n                    builder.addIdentityCapability(archive.getName(), \"1.0.0\");\n                    builder.addManifestHeader(\"Dependencies\", \"io.fabric8.api,org.apache.karaf,org.jboss.gravia\");\n                    return builder.openStream();\n                }\n            }\n        });\n        return archive.getArchive();\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n\t * The purpose of this test is to make sure that everything can be downloaded from the fabric-maven-proxy.\n\t * Also we want to make sure that after artifacts have been downloaded can be properlly used, for example:\n\t * Feature Repositories can be properly resolved.\n\t *\n\t * Note: This test makes sense to run using remote containers that have an empty maven repo.\n\t *\n\t * http://fusesource.com/issues/browse/FABRIC-398\n\t */\n\t@Test\n\tpublic void testFeatureRepoResolution() throws Exception {\n\t\tSystem.out.println(CommandSupport.executeCommand(\"fabric:create -n\"));\n\n\t\t//We are just want to use a feature repository that is not part of the distribution.\n\t\tSystem.out.println(CommandSupport.executeCommand(\"fabric:profile-create --parents feature-camel test-profile\"));\n\t\tSystem.out.println(CommandSupport.executeCommand(\"fabric:version-create --parent 1.0 1.1\"));\n\t\tSystem.out.println(CommandSupport.executeCommand(\"fabric:profile-edit --repositories mvn:org.fusesource.examples.fabric-camel-dosgi/features/\" + System.getProperty(\"fabric.version\") + \"/xml/features test-profile 1.1\"));\n\t\tSystem.out.println(CommandSupport.executeCommand(\"fabric:profile-edit --features fabric-dosgi test-profile 1.1\"));\n\t\t//We remove all repositories from agent config but the maven central to rely on the fabric-maven-proxy.\n\t    //Also remove local repository\n\t\tSystem.out.println(CommandSupport.executeCommand(\"profile-edit --pid io.fabric8.agent/org.ops4j.pax.url.mvn.repositories=http://repo1.maven.org/maven2@id=m2central default 1.1\"));\n\t\tSystem.out.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid test-profile 1.1\"));\n\n        Set<Container> containers = ContainerBuilder.create().withName(\"cnt\").withProfiles(\"test-profile\").assertProvisioningResult().build();\n\t\ttry {\n\t        //We want to remove all repositories from fabric-agent.\n\t        for (Container container : containers) {\n\t            System.out.println(CommandSupport.executeCommand(\"fabric:container-upgrade 1.1 \" + container.getId()));\n\t            System.out.flush();\n\t        }\n\t        Provision.provisioningSuccess(containers, FabricTestSupport.PROVISION_TIMEOUT);\n\t        System.out.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n\n\t        for (Container container : containers) {\n\t            System.out.println(CommandSupport.executeCommand(\"fabric:container-connect -u admin -p admin \" + container.getId() + \" osgi:list\"));\n\t            System.out.println(CommandSupport.executeCommand(\"fabric:container-connect -u admin -p admin \" + container.getId() + \" config:proplist --pid org.ops4j.pax.url.mvn\"));\n\t            System.out.flush();\n\t        }\n\t\t} finally {\n            ContainerBuilder.destroy(containers);\n\t\t}\n\t}","id":44277,"modified_method":"@Test\n\tpublic void testFeatureRepoResolution() throws Exception {\n\t\tCommandSupport.executeCommand(\"fabric:create --clean -n\");\n\n\t\t//We are just want to use a feature repository that is not part of the distribution.\n\t\tCommandSupport.executeCommand(\"fabric:profile-create --parents feature-camel test-profile\");\n\t\tCommandSupport.executeCommand(\"fabric:version-create --parent 1.0 1.1\");\n\t\tCommandSupport.executeCommand(\"fabric:profile-edit --repositories mvn:org.fusesource.examples.fabric-camel-dosgi/features/\" + System.getProperty(\"fabric.version\") + \"/xml/features test-profile 1.1\");\n\t\tCommandSupport.executeCommand(\"fabric:profile-edit --features fabric-dosgi test-profile 1.1\");\n\t\t//We remove all repositories from agent config but the maven central to rely on the fabric-maven-proxy.\n\t    //Also remove local repository\n\t\tCommandSupport.executeCommand(\"fabric:profile-edit --pid io.fabric8.agent/org.ops4j.pax.url.mvn.repositories=http://repo1.maven.org/maven2@id=m2central default 1.1\");\n\t\tCommandSupport.executeCommand(\"fabric:profile-edit --pid test-profile 1.1\");\n\n        Set<Container> containers = ContainerBuilder.create().withName(\"cnt\").withProfiles(\"test-profile\").assertProvisioningResult().build();\n\t\ttry {\n\t        //We want to remove all repositories from fabric-agent.\n\t        for (Container container : containers) {\n\t            CommandSupport.executeCommand(\"fabric:container-upgrade 1.1 \" + container.getId());\n\t            System.out.flush();\n\t        }\n\t        Provision.provisioningSuccess(containers, FabricEnsembleSupport.PROVISION_TIMEOUT);\n\t        CommandSupport.executeCommand(\"fabric:container-list\");\n\n\t        for (Container container : containers) {\n\t            CommandSupport.executeCommand(\"fabric:container-connect -u admin -p admin \" + container.getId() + \" osgi:list\");\n\t            CommandSupport.executeCommand(\"fabric:container-connect -u admin -p admin \" + container.getId() + \" config:proplist --pid org.ops4j.pax.url.mvn\");\n\t            System.out.flush();\n\t        }\n\t\t} finally {\n            ContainerBuilder.destroy(containers);\n\t\t}\n\t}","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testAddAndRemove() throws Exception {\n        System.err.println(CommandSupport.executeCommand(\"fabric:create -n\"));\n        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();\n        ServiceProxy<FabricService> fabricProxy = ServiceProxy.createServiceProxy(moduleContext, FabricService.class);\n        try {\n            FabricService fabricService = fabricProxy.getService();\n            Set<Container> containers = ContainerBuilder.create(2).withName(\"ens\").assertProvisioningResult().build();\n            try {\n                Deque<Container> containerQueue = new LinkedList<Container>(containers);\n                Deque<Container> addedContainers = new LinkedList<Container>();\n\n                for (int e = 0; e < 3 && containerQueue.size() >= 2 && containerQueue.size() % 2 == 0; e++) {\n                    Container cnt1 = containerQueue.removeFirst();\n                    Container cnt2 = containerQueue.removeFirst();\n                    addedContainers.add(cnt1);\n                    addedContainers.add(cnt2);\n                    FabricEnsembleSupport.addToEnsemble(fabricService, cnt1, cnt2);\n                    System.err.println(CommandSupport.executeCommand(\"config:proplist --pid io.fabric8.zookeeper\"));\n\n                    System.err.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n                    System.err.println(CommandSupport.executeCommand(\"fabric:ensemble-list\"));\n                    ZooKeeperClusterService zooKeeperClusterService = ServiceLocator.awaitService(moduleContext, ZooKeeperClusterService.class);\n                    Assert.assertNotNull(zooKeeperClusterService);\n                    List<String> ensembleContainersResult = zooKeeperClusterService.getEnsembleContainers();\n                    Assert.assertTrue(ensembleContainersResult.contains(cnt1.getId()));\n                    Assert.assertTrue(ensembleContainersResult.contains(cnt2.getId()));\n                    Provision.provisioningSuccess(Arrays.asList(fabricService.getContainers()), FabricTestSupport.PROVISION_TIMEOUT);\n                }\n\n                for (int e = 0; e < 3 && addedContainers.size() >= 2 && addedContainers.size() % 2 == 0; e++) {\n                    Container cnt1 = addedContainers.removeFirst();\n                    Container cnt2 = addedContainers.removeFirst();\n                    containerQueue.add(cnt1);\n                    containerQueue.add(cnt2);\n                    FabricEnsembleSupport.removeFromEnsemble(fabricService, cnt1, cnt2);\n                    System.err.println(CommandSupport.executeCommand(\"config:proplist --pid io.fabric8.zookeeper\"));\n\n                    System.err.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n                    System.err.println(CommandSupport.executeCommand(\"fabric:ensemble-list\"));\n                    ZooKeeperClusterService zooKeeperClusterService = ServiceLocator.awaitService(moduleContext, ZooKeeperClusterService.class);\n                    Assert.assertNotNull(zooKeeperClusterService);\n                    List<String> ensembleContainersResult = zooKeeperClusterService.getEnsembleContainers();\n                    Assert.assertFalse(ensembleContainersResult.contains(cnt1.getId()));\n                    Assert.assertFalse(ensembleContainersResult.contains(cnt2.getId()));\n                    Provision.provisioningSuccess(Arrays.asList(fabricService.getContainers()), FabricTestSupport.PROVISION_TIMEOUT);\n                }\n            } finally {\n                ContainerBuilder.destroy(containers);\n            }\n        } finally {\n            fabricProxy.close();\n        }\n    }","id":44278,"modified_method":"@Test\n    public void testAddAndRemove() throws Exception {\n        System.err.println(CommandSupport.executeCommand(\"fabric:create --clean -n\"));\n        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();\n        ServiceProxy<FabricService> fabricProxy = ServiceProxy.createServiceProxy(moduleContext, FabricService.class);\n        try {\n            FabricService fabricService = fabricProxy.getService();\n            Set<Container> containers = ContainerBuilder.create(2).withName(\"ens\").assertProvisioningResult().build();\n            try {\n                Deque<Container> containerQueue = new LinkedList<Container>(containers);\n                Deque<Container> addedContainers = new LinkedList<Container>();\n\n                for (int e = 0; e < 3 && containerQueue.size() >= 2 && containerQueue.size() % 2 == 0; e++) {\n                    Container cnt1 = containerQueue.removeFirst();\n                    Container cnt2 = containerQueue.removeFirst();\n                    addedContainers.add(cnt1);\n                    addedContainers.add(cnt2);\n                    FabricEnsembleSupport.addToEnsemble(fabricService, cnt1, cnt2);\n                    System.err.println(CommandSupport.executeCommand(\"config:proplist --pid io.fabric8.zookeeper\"));\n\n                    System.err.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n                    System.err.println(CommandSupport.executeCommand(\"fabric:ensemble-list\"));\n                    ZooKeeperClusterService zooKeeperClusterService = ServiceLocator.awaitService(moduleContext, ZooKeeperClusterService.class);\n                    Assert.assertNotNull(zooKeeperClusterService);\n                    List<String> ensembleContainersResult = zooKeeperClusterService.getEnsembleContainers();\n                    Assert.assertTrue(ensembleContainersResult.contains(cnt1.getId()));\n                    Assert.assertTrue(ensembleContainersResult.contains(cnt2.getId()));\n                    Provision.provisioningSuccess(Arrays.asList(fabricService.getContainers()), FabricEnsembleSupport.PROVISION_TIMEOUT);\n                }\n\n                for (int e = 0; e < 3 && addedContainers.size() >= 2 && addedContainers.size() % 2 == 0; e++) {\n                    Container cnt1 = addedContainers.removeFirst();\n                    Container cnt2 = addedContainers.removeFirst();\n                    containerQueue.add(cnt1);\n                    containerQueue.add(cnt2);\n                    FabricEnsembleSupport.removeFromEnsemble(fabricService, cnt1, cnt2);\n                    System.err.println(CommandSupport.executeCommand(\"config:proplist --pid io.fabric8.zookeeper\"));\n\n                    System.err.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n                    System.err.println(CommandSupport.executeCommand(\"fabric:ensemble-list\"));\n                    ZooKeeperClusterService zooKeeperClusterService = ServiceLocator.awaitService(moduleContext, ZooKeeperClusterService.class);\n                    Assert.assertNotNull(zooKeeperClusterService);\n                    List<String> ensembleContainersResult = zooKeeperClusterService.getEnsembleContainers();\n                    Assert.assertFalse(ensembleContainersResult.contains(cnt1.getId()));\n                    Assert.assertFalse(ensembleContainersResult.contains(cnt2.getId()));\n                    Provision.provisioningSuccess(Arrays.asList(fabricService.getContainers()), FabricEnsembleSupport.PROVISION_TIMEOUT);\n                }\n            } finally {\n                ContainerBuilder.destroy(containers);\n            }\n        } finally {\n            fabricProxy.close();\n        }\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testFabricCreate() throws Exception {\n        String zkpassword = System.getProperty(CreateEnsembleOptions.ZOOKEEPER_PASSWORD);\n        Assert.assertNotNull(CreateEnsembleOptions.ZOOKEEPER_PASSWORD + \" not null\", zkpassword);\n        Builder<?> builder = CreateEnsembleOptions.builder().agentEnabled(false).clean(true).zookeeperPassword(zkpassword).waitForProvision(false);\n        CreateEnsembleOptions options = builder.build();\n\n        ZooKeeperClusterBootstrap bootstrap = FabricTestSupport.getRequiredService(ZooKeeperClusterBootstrap.class);\n        bootstrap.create(options);\n\n        FabricService fabricService = FabricTestSupport.getRequiredService(FabricService.class);\n        Container[] containers = fabricService.getContainers();\n        Assert.assertNotNull(\"Containers not null\", containers);\n\n        // Verify other required services\n        FabricTestSupport.getRequiredService(CuratorFramework.class);\n        FabricTestSupport.getRequiredService(GitService.class);\n        FabricTestSupport.getRequiredService(DataStore.class);\n        FabricTestSupport.getRequiredService(PortService.class);\n        FabricTestSupport.getRequiredService(ContainerProvider.class);\n\n        // Test that a provided by command line password exists\n        ConfigurationAdmin configAdmin = FabricTestSupport.getRequiredService(ConfigurationAdmin.class);\n        org.osgi.service.cm.Configuration configuration = configAdmin.getConfiguration(io.fabric8.api.Constants.ZOOKEEPER_CLIENT_PID);\n        Dictionary<String, Object> dictionary = configuration.getProperties();\n        Assert.assertEquals(\"Expected provided zookeeper password\", \"systempassword\", dictionary.get(\"zookeeper.password\"));\n\n        assertConfigurations(configAdmin);\n    }","id":44279,"modified_method":"@Test\n    public void testFabricCreate() throws Exception {\n\n        Builder<?> builder = CreateEnsembleOptions.builder().agentEnabled(false).clean(true).zookeeperPassword(\"systempassword\").waitForProvision(false);\n        CreateEnsembleOptions options = builder.build();\n\n        ZooKeeperClusterBootstrap bootstrap = ServiceLocator.getRequiredService(ZooKeeperClusterBootstrap.class);\n        bootstrap.create(options);\n\n        FabricService fabricService = ServiceLocator.getRequiredService(FabricService.class);\n        Container[] containers = fabricService.getContainers();\n        Assert.assertNotNull(\"Containers not null\", containers);\n\n        // Verify other required services\n        ServiceLocator.getRequiredService(CuratorFramework.class);\n        ServiceLocator.getRequiredService(GitService.class);\n        ServiceLocator.getRequiredService(DataStore.class);\n        ServiceLocator.getRequiredService(PortService.class);\n        ServiceLocator.getRequiredService(ContainerProvider.class);\n\n        // Test that a provided by command line password exists\n        ConfigurationAdmin configAdmin = ServiceLocator.getRequiredService(ConfigurationAdmin.class);\n        org.osgi.service.cm.Configuration configuration = configAdmin.getConfiguration(io.fabric8.api.Constants.ZOOKEEPER_CLIENT_PID);\n        Dictionary<String, Object> dictionary = configuration.getProperties();\n        Assert.assertEquals(\"Expected provided zookeeper password\", \"systempassword\", dictionary.get(\"zookeeper.password\"));\n\n        assertConfigurations(configAdmin);\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testLocalFabricCluster() throws Exception {\n\n        System.out.println(CommandSupport.executeCommand(\"fabric:create --clean -n\"));\n\n        FabricService fabricService = FabricTestSupport.getService(FabricService.class);\n        Container[] containers = fabricService.getContainers();\n        Assert.assertNotNull(\"Containers not null\", containers);\n\n        //Test that a provided by command line password exists\n        ConfigurationAdmin configurationAdmin = FabricTestSupport.getRequiredService(ConfigurationAdmin.class);\n        org.osgi.service.cm.Configuration configuration = configurationAdmin.getConfiguration(io.fabric8.api.Constants.ZOOKEEPER_CLIENT_PID);\n        Dictionary<String, Object> dictionary = configuration.getProperties();\n        Assert.assertEquals(\"Expected provided zookeeper password\", \"systempassword\", dictionary.get(\"zookeeper.password\"));\n    }","id":44280,"modified_method":"@Test\n    public void testLocalFabricCluster() throws Exception {\n\n        CommandSupport.executeCommand(\"fabric:create --clean -n\");\n\n        FabricService fabricService = ServiceLocator.getRequiredService(FabricService.class);\n        Container[] containers = fabricService.getContainers();\n        Assert.assertNotNull(\"Containers not null\", containers);\n\n        //Test that a provided by command line password exists\n        ConfigurationAdmin configurationAdmin = ServiceLocator.getRequiredService(ConfigurationAdmin.class);\n        org.osgi.service.cm.Configuration configuration = configurationAdmin.getConfiguration(io.fabric8.api.Constants.ZOOKEEPER_CLIENT_PID);\n        Dictionary<String, Object> dictionary = configuration.getProperties();\n        Assert.assertEquals(\"Expected provided zookeeper password\", \"admin\", dictionary.get(\"zookeeper.password\"));\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Deployment\n    @StartLevelAware(autostart = true)\n    public static Archive<?> deployment() {\n        final ArchiveBuilder archive = new ArchiveBuilder(\"create-command-test\");\n        archive.addClasses(RuntimeType.TOMCAT, AnnotatedContextListener.class);\n        archive.addPackage(FabricTestSupport.class.getPackage());\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                if (ArchiveBuilder.getTargetContainer() == RuntimeType.KARAF) {\n                    OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                    builder.addBundleManifestVersion(2);\n                    builder.addBundleSymbolicName(archive.getName());\n                    builder.addBundleVersion(\"1.0.0\");\n                    builder.addManifestHeader(Constants.GRAVIA_ENABLED, Boolean.TRUE.toString());\n                    builder.addImportPackages(RuntimeLocator.class, FabricService.class);\n                    builder.addImportPackages(AbstractCommand.class, Action.class);\n                    builder.addImportPackage(\"org.apache.felix.service.command;status=provisional\");\n                    builder.addImportPackages(ConfigurationAdmin.class);\n                    return builder.openStream();\n                } else {\n                    ManifestBuilder builder = new ManifestBuilder();\n                    builder.addIdentityCapability(archive.getName(), \"1.0.0\");\n                    builder.addManifestHeader(\"Dependencies\", \"io.fabric8.api,org.apache.karaf,org.jboss.gravia\");\n                    return builder.openStream();\n                }\n            }\n        });\n        return archive.getArchive();\n    }","id":44281,"modified_method":"@Deployment\n    @StartLevelAware(autostart = true)\n    public static Archive<?> deployment() {\n        final ArchiveBuilder archive = new ArchiveBuilder(\"create-command-test\");\n        archive.addClasses(RuntimeType.TOMCAT, AnnotatedContextListener.class);\n        archive.addPackage(CommandSupport.class.getPackage());\n        archive.setManifest(new Asset() {\n            @Override\n            public InputStream openStream() {\n                if (ArchiveBuilder.getTargetContainer() == RuntimeType.KARAF) {\n                    OSGiManifestBuilder builder = OSGiManifestBuilder.newInstance();\n                    builder.addBundleManifestVersion(2);\n                    builder.addBundleSymbolicName(archive.getName());\n                    builder.addBundleVersion(\"1.0.0\");\n                    builder.addManifestHeader(Constants.GRAVIA_ENABLED, Boolean.TRUE.toString());\n                    builder.addImportPackages(RuntimeLocator.class, FabricService.class);\n                    builder.addImportPackages(AbstractCommand.class, Action.class);\n                    builder.addImportPackage(\"org.apache.felix.service.command;status=provisional\");\n                    builder.addImportPackages(ConfigurationAdmin.class);\n                    return builder.openStream();\n                } else {\n                    ManifestBuilder builder = new ManifestBuilder();\n                    builder.addIdentityCapability(archive.getName(), \"1.0.0\");\n                    builder.addManifestHeader(\"Dependencies\", \"io.fabric8.api,org.apache.karaf,org.jboss.gravia\");\n                    return builder.openStream();\n                }\n            }\n        });\n        return archive.getArchive();\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"private static void doWithEnsemble(FabricService fabricService, String command) throws Exception {\n        long start = System.currentTimeMillis();\n        long now = System.currentTimeMillis();\n        boolean keepRunning = true;\n\n        while (!Thread.currentThread().isInterrupted() && keepRunning &&  now - start <= 30000L) {\n            try {\n                System.err.println(CommandSupport.executeCommand(command));\n                keepRunning = false;\n            } catch (Exception ex) {\n                if (isRetriable(ex)) {\n                    System.err.println(\"Not ready for ensemble modification! Retrying...\");\n                    Provision.provisioningSuccess(Arrays.asList(fabricService.getContainers()), FabricTestSupport.PROVISION_TIMEOUT);\n                    now = System.currentTimeMillis();\n                } else {\n                    throw ex;\n                }\n            }\n        }\n    }","id":44282,"modified_method":"private static void doWithEnsemble(FabricService fabricService, String command) throws Exception {\n        long start = System.currentTimeMillis();\n        long now = System.currentTimeMillis();\n        boolean keepRunning = true;\n\n        while (!Thread.currentThread().isInterrupted() && keepRunning && now - start <= 30000L) {\n            try {\n                System.err.println(CommandSupport.executeCommand(command));\n                keepRunning = false;\n            } catch (Exception ex) {\n                if (isRetriable(ex)) {\n                    System.err.println(\"Not ready for ensemble modification! Retrying...\");\n                    Provision.provisioningSuccess(Arrays.asList(fabricService.getContainers()), PROVISION_TIMEOUT);\n                    now = System.currentTimeMillis();\n                } else {\n                    throw ex;\n                }\n            }\n        }\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n\tpublic void testJoin() throws Exception {\n        System.err.println(CommandSupport.executeCommand(\"fabric:create -n\"));\n        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();;\n        ServiceProxy<FabricService> fabricProxy = ServiceProxy.createServiceProxy(moduleContext, FabricService.class);\n        try {\n            FabricService fabricService = fabricProxy.getService();\n\n            AdminService adminService = ServiceLocator.awaitService(moduleContext, AdminService.class);\n            String version = System.getProperty(\"fabric.version\");\n            System.err.println(CommandSupport.executeCommand(\"admin:create --featureURL mvn:io.fabric8/fabric8-karaf/\" + version + \"/xml/features --feature fabric-git --feature fabric-agent --feature fabric-boot-commands child1\"));\n            try {\n                System.err.println(CommandSupport.executeCommand(\"admin:start child1\"));\n                Provision.instanceStarted(Arrays.asList(\"child1\"), FabricTestSupport.PROVISION_TIMEOUT);\n                System.err.println(CommandSupport.executeCommand(\"admin:list\"));\n                String joinCommand = \"fabric:join -f --zookeeper-password \"+ fabricService.getZookeeperPassword() +\" \" + fabricService.getZookeeperUrl();\n                String response = \"\";\n                for (int i = 0; i < 10 && !response.contains(\"true\"); i++) {\n                    response = CommandSupport.executeCommand(\"ssh -l admin -P admin -p \" + adminService.getInstance(\"child1\").getSshPort() + \" localhost \" + WAIT_FOR_JOIN_SERVICE);\n                    Thread.sleep(1000);\n                }\n\n                System.err.println(CommandSupport.executeCommand(\"ssh -l admin -P admin -p \" + adminService.getInstance(\"child1\").getSshPort() + \" localhost \" + joinCommand));\n                Provision.containersExist(Arrays.asList(\"child1\"), FabricTestSupport.PROVISION_TIMEOUT);\n                Container child1 = fabricService.getContainer(\"child1\");\n                System.err.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n                Provision.containersStatus(Arrays.asList(child1), \"success\", FabricTestSupport.PROVISION_TIMEOUT);\n                System.err.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n            } finally {\n                System.err.println(CommandSupport.executeCommand(\"admin:stop child1\"));\n            }\n        } finally {\n            fabricProxy.close();\n        }\n\t}","id":44283,"modified_method":"@Test\n\tpublic void testJoin() throws Exception {\n        System.err.println(CommandSupport.executeCommand(\"fabric:create -n\"));\n        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();;\n        ServiceProxy<FabricService> fabricProxy = ServiceProxy.createServiceProxy(moduleContext, FabricService.class);\n        try {\n            FabricService fabricService = fabricProxy.getService();\n\n            AdminService adminService = ServiceLocator.awaitService(moduleContext, AdminService.class);\n            String version = System.getProperty(\"fabric.version\");\n            System.err.println(CommandSupport.executeCommand(\"admin:create --featureURL mvn:io.fabric8/fabric8-karaf/\" + version + \"/xml/features --feature fabric-git --feature fabric-agent --feature fabric-boot-commands child1\"));\n\n            try {\n                System.err.println(CommandSupport.executeCommand(\"admin:start child1\"));\n                Provision.instanceStarted(Arrays.asList(\"child1\"), FabricEnsembleSupport.PROVISION_TIMEOUT);\n                System.err.println(CommandSupport.executeCommand(\"admin:list\"));\n                String joinCommand = \"fabric:join -f --zookeeper-password \"+ fabricService.getZookeeperPassword() +\" \" + fabricService.getZookeeperUrl();\n                String response = \"\";\n                for (int i = 0; i < 10 && !response.contains(\"true\"); i++) {\n                    response = CommandSupport.executeCommand(\"ssh:ssh -l admin -P admin -p \" + adminService.getInstance(\"child1\").getSshPort() + \" localhost \" + WAIT_FOR_JOIN_SERVICE);\n                    Thread.sleep(1000);\n                }\n\n                System.err.println(CommandSupport.executeCommand(\"ssh:ssh -l admin -P admin -p \" + adminService.getInstance(\"child1\").getSshPort() + \" localhost \" + joinCommand));\n                Provision.containersExist(Arrays.asList(\"child1\"), FabricEnsembleSupport.PROVISION_TIMEOUT);\n                Container child1 = fabricService.getContainer(\"child1\");\n                System.err.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n                Provision.containersStatus(Arrays.asList(child1), \"success\", FabricEnsembleSupport.PROVISION_TIMEOUT);\n                System.err.println(CommandSupport.executeCommand(\"fabric:container-list\"));\n            } finally {\n                System.err.println(CommandSupport.executeCommand(\"admin:stop child1\"));\n            }\n        } finally {\n            fabricProxy.close();\n        }\n\t}","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testManipulatePid() throws Exception {\n        System.err.println(CommandSupport.executeCommand(\"fabric:create -n\"));\n        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();\n        ServiceProxy<FabricService> fabricProxy = ServiceProxy.createServiceProxy(moduleContext, FabricService.class);\n        try {\n            FabricService fabricService = fabricProxy.getService();\n\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid/key=value default\"));\n\n            //Check that my.pid has been added to the default profile\n            Profile profile = fabricService.getDefaultVersion().getProfile(\"default\");\n            Assert.assertNotNull(profile);\n            Map<String, Map<String, String>> configurations = profile.getConfigurations();\n            Assert.assertNotNull(configurations);\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            Map<String, String> myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key\"));\n            Assert.assertEquals(\"value\", myPid.get(\"key\"));\n\n            //Check append options for a pid.\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --append --pid my.pid/key=othervalue default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key\"));\n            Assert.assertEquals(\"value,othervalue\", myPid.get(\"key\"));\n\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --remove --pid my.pid/key=value default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key\"));\n            Assert.assertEquals(\"othervalue\", myPid.get(\"key\"));\n\n            //Check append options for a pid.\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --remove --pid my.pid/key=othervalue default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key\"));\n            Assert.assertEquals(\"\", myPid.get(\"key\"));\n\n            //Check assign option with '='.\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid/key=prop1=value1 default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key\"));\n            Assert.assertEquals(\"prop1=value1\", myPid.get(\"key\"));\n\n            //Check multiple properties\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid/key1=value1 --pid my.pid/key2=value2 default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key1\"));\n            Assert.assertEquals(\"value1\", myPid.get(\"key1\"));\n            Assert.assertTrue(myPid.containsKey(\"key2\"));\n            Assert.assertEquals(\"value2\", myPid.get(\"key2\"));\n\n            //Check import pid\n            System.err.println(CommandSupport.executeCommands(\"config:edit my.pid2\", \"config:propset key1 value1\", \"config:propset key2 value2\", \"config:update\"));\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid2 --import-pid default\"));\n\n            //Check that my.pid has been added to the default profile\n            profile = fabricService.getDefaultVersion().getProfile(\"default\");\n            Assert.assertNotNull(profile);\n            configurations = profile.getConfigurations();\n            Assert.assertNotNull(configurations);\n            Assert.assertTrue(configurations.containsKey(\"my.pid2\"));\n            Map<String, String> myPid2 = configurations.get(\"my.pid2\");\n            Assert.assertNotNull(myPid2);\n            Assert.assertTrue(myPid2.containsKey(\"key1\"));\n            Assert.assertEquals(\"value1\", myPid2.get(\"key1\"));\n            Assert.assertTrue(myPid2.containsKey(\"key2\"));\n            Assert.assertEquals(\"value2\", myPid2.get(\"key2\"));\n\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid2/key1 --delete default\"));\n            Map<String, String> configuration = profile.getConfiguration(\"my.pid2\");\n            Assert.assertFalse(configuration.containsKey(\"key1\"));\n\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid2 --delete default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertFalse(configurations.containsKey(\"my.pid2\"));\n        } finally {\n            fabricProxy.close();\n        }\n    }","id":44284,"modified_method":"@Test\n    public void testManipulatePid() throws Exception {\n        System.err.println(CommandSupport.executeCommand(\"fabric:create --clean -n\"));\n        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();\n        ServiceProxy<FabricService> fabricProxy = ServiceProxy.createServiceProxy(moduleContext, FabricService.class);\n        try {\n            FabricService fabricService = fabricProxy.getService();\n\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid/key=value default\"));\n\n            //Check that my.pid has been added to the default profile\n            Profile profile = fabricService.getDefaultVersion().getProfile(\"default\");\n            Assert.assertNotNull(profile);\n            Map<String, Map<String, String>> configurations = profile.getConfigurations();\n            Assert.assertNotNull(configurations);\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            Map<String, String> myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key\"));\n            Assert.assertEquals(\"value\", myPid.get(\"key\"));\n\n            //Check append options for a pid.\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --append --pid my.pid/key=othervalue default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key\"));\n            Assert.assertEquals(\"value,othervalue\", myPid.get(\"key\"));\n\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --remove --pid my.pid/key=value default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key\"));\n            Assert.assertEquals(\"othervalue\", myPid.get(\"key\"));\n\n            //Check append options for a pid.\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --remove --pid my.pid/key=othervalue default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key\"));\n            Assert.assertEquals(\"\", myPid.get(\"key\"));\n\n            //Check assign option with '='.\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid/key=prop1=value1 default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key\"));\n            Assert.assertEquals(\"prop1=value1\", myPid.get(\"key\"));\n\n            //Check multiple properties\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid/key1=value1 --pid my.pid/key2=value2 default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertTrue(configurations.containsKey(\"my.pid\"));\n            myPid = configurations.get(\"my.pid\");\n            Assert.assertNotNull(myPid);\n            Assert.assertTrue(myPid.containsKey(\"key1\"));\n            Assert.assertEquals(\"value1\", myPid.get(\"key1\"));\n            Assert.assertTrue(myPid.containsKey(\"key2\"));\n            Assert.assertEquals(\"value2\", myPid.get(\"key2\"));\n\n            //Check import pid\n            System.err.println(CommandSupport.executeCommands(\"config:edit my.pid2\", \"config:propset key1 value1\", \"config:propset key2 value2\", \"config:update\"));\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid2 --import-pid default\"));\n\n            //Check that my.pid has been added to the default profile\n            profile = fabricService.getDefaultVersion().getProfile(\"default\");\n            Assert.assertNotNull(profile);\n            configurations = profile.getConfigurations();\n            Assert.assertNotNull(configurations);\n            Assert.assertTrue(configurations.containsKey(\"my.pid2\"));\n            Map<String, String> myPid2 = configurations.get(\"my.pid2\");\n            System.out.println(\"my.pid2 => \" + myPid2);\n            Assert.assertNotNull(myPid2);\n            Assert.assertTrue(myPid2.containsKey(\"key1\"));\n            Assert.assertEquals(\"value1\", myPid2.get(\"key1\"));\n            Assert.assertTrue(myPid2.containsKey(\"key2\"));\n            Assert.assertEquals(\"value2\", myPid2.get(\"key2\"));\n\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid2/key1 --delete default\"));\n            Map<String, String> configuration = profile.getConfiguration(\"my.pid2\");\n            Assert.assertFalse(configuration.containsKey(\"key1\"));\n\n            System.err.println(CommandSupport.executeCommand(\"fabric:profile-edit --pid my.pid2 --delete default\"));\n            configurations = profile.getConfigurations();\n            Assert.assertFalse(configurations.containsKey(\"my.pid2\"));\n        } finally {\n            fabricProxy.close();\n        }\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static <T> T awaitService(ModuleContext moduleContext, Class<T> type, long timeout, TimeUnit unit) {\n\t\treturn awaitService(moduleContext, type, null, timeout, unit);\n\t}","id":44285,"modified_method":"public static <T> T awaitService(Class<T> type, String filterspec, long timeout, TimeUnit unit) {\n        ModuleContext moduleContext = RuntimeLocator.getRequiredRuntime().getModuleContext();\n        return awaitService(moduleContext, type, filterspec, timeout, unit);\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public static <T> T awaitService(ModuleContext moduleContext, Class<T> type, String filter) {\n        return awaitService(moduleContext, type, filter, DEFAULT_TIMEOUT, TimeUnit.MILLISECONDS);\n    }","id":44286,"modified_method":"public static <T> T getService(ModuleContext moduleContext, Class<T> type) {\n        ServiceReference<T> sref = moduleContext.getServiceReference(type);\n        return sref != null ? moduleContext.getService(sref) : null;\n    }","commit_id":"9c5cd07557fd0d91b7ea69271dffe9453bb476d4","url":"https://github.com/fabric8io/fabric8"},{"original_method":"/**\n     * Persistently adds a subscription for the presence status of the\n     * contact corresponding to the specified contactIdentifier and indicates\n     * that it should be added to the specified group of the server stored\n     * contact list.\n     *\n     * @param parent the parent group of the server stored contact list\n     *   where the contact should be added. <p>\n     * @param contactIdentifier the contact whose status updates we are\n     *   subscribing for.\n     * @throws IllegalArgumentException if <tt>contact<\/tt> or\n     *   <tt>parent<\/tt> are not a contact known to the underlying protocol\n     *   provider.\n     * @throws IllegalStateException if the underlying protocol provider is\n     *   not registered/signed on a public service.\n     * @throws OperationFailedException with code NETWORK_FAILURE if\n     *   subscribing fails due to errors experienced during network\n     *   communication\n     */\n    public void subscribe(ContactGroup parent, String contactIdentifier) throws\n        IllegalArgumentException, IllegalStateException,\n        OperationFailedException\n    {\n        ContactGibberishImpl contact = new ContactGibberishImpl(contactIdentifier\n                                              , parentProvider);\n\n        if(authorizationHandler != null)\n        {\n            //first pretend that an authorization is necessary\n            AuthorizationRequest request\n                = authorizationHandler.createAuthorizationRequest(contact);\n\n            //now pretend that the remote contact is asking for authorization\n            authorizationHandler.processAuthorisationRequest(\n                request, contact);\n\n            //and finally pretend that the remote contact has granted us\n            //authorization\n            AuthorizationResponse response\n                = new AuthorizationResponse(AuthorizationResponse.ACCEPT\n                                            , \"You are welcome!\");\n            authorizationHandler.processAuthorizationResponse(\n                response, contact);\n        }\n        ((ContactGroupGibberishImpl)parent).addContact(contact);\n\n        fireSubscriptionEvent(contact,\n                              parent,\n                              SubscriptionEvent.SUBSCRIPTION_CREATED);\n\n        //since we are not a real protocol, we set the contact presence status\n        //ourselves\n        changePresenceStatusForContact( contact, getPresenceStatus());\n    }","id":44287,"modified_method":"/**\n     * Persistently adds a subscription for the presence status of the\n     * contact corresponding to the specified contactIdentifier and indicates\n     * that it should be added to the specified group of the server stored\n     * contact list.\n     *\n     * @param parent the parent group of the server stored contact list\n     *   where the contact should be added. <p>\n     * @param contactIdentifier the contact whose status updates we are\n     *   subscribing for.\n     * @throws IllegalArgumentException if <tt>contact<\/tt> or\n     *   <tt>parent<\/tt> are not a contact known to the underlying protocol\n     *   provider.\n     * @throws IllegalStateException if the underlying protocol provider is\n     *   not registered/signed on a public service.\n     * @throws OperationFailedException with code NETWORK_FAILURE if\n     *   subscribing fails due to errors experienced during network\n     *   communication\n     */\n    public void subscribe(ContactGroup parent, String contactIdentifier) throws\n        IllegalArgumentException, IllegalStateException,\n        OperationFailedException\n    {\n        ContactGibberishImpl contact = new ContactGibberishImpl(\n            contactIdentifier\n            , parentProvider);\n\n        if(authorizationHandler != null)\n        {\n            //we require authorizations in gibberish\n            AuthorizationRequest request\n                = authorizationHandler.createAuthorizationRequest(contact);\n\n\n            //and finally pretend that the remote contact has granted us\n            //authorization\n            AuthorizationResponse response\n                = deliverAuthorizationRequest(request, contact);\n\n            authorizationHandler.processAuthorizationResponse(\n                response, contact);\n\n            //if the request was not accepted - return the contact.\n            if(response.getResponseCode() == AuthorizationResponse.REJECT)\n                return;\n        }\n        ((ContactGroupGibberishImpl)parent).addContact(contact);\n\n        fireSubscriptionEvent(contact,\n                              parent,\n                              SubscriptionEvent.SUBSCRIPTION_CREATED);\n        //if the newly added contact corresponds to another provider - set their\n        //status accordingly\n        ProtocolProviderServiceGibberishImpl gibProvider\n            = findProviderForGibberishUserID(contactIdentifier);\n        if(gibProvider != null)\n        {\n            OperationSetPersistentPresence opSetPresence\n                = (OperationSetPersistentPresence)gibProvider.getOperationSet(\n                    OperationSetPersistentPresence.class);\n\n            changePresenceStatusForContact(\n                contact\n                , (GibberishStatusEnum)opSetPresence.getPresenceStatus());\n        }\n        else\n        {\n            //otherwise - since we are not a real protocol, we set the contact\n            //presence status ourselves\n            changePresenceStatusForContact(contact, getPresenceStatus());\n        }\n\n        //notify presence listeners for the status change.\n        fireContactPresenceStatusChangeEvent(contact\n                                             , parent\n                                             , GibberishStatusEnum.OFFLINE);\n    }","commit_id":"739adad73f1860303a2a5397f553268f9eff21d2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Removes the specified contact from its current parent and places it\n     * under <tt>newParent<\/tt>.\n     *\n     * @param contactToMove the <tt>Contact<\/tt> to move\n     * @param newParent the <tt>ContactGroup<\/tt> where <tt>Contact<\/tt>\n     *   would be placed.\n     */\n    public void moveContactToGroup(Contact contactToMove,\n                                   ContactGroup newParent)\n    {\n        ContactGibberishImpl gibberishContact\n            = (ContactGibberishImpl)contactToMove;\n\n        ContactGroupGibberishImpl parentGibberishGroup\n            = findContactParent(gibberishContact);\n\n        parentGibberishGroup.removeContact(gibberishContact);\n\n        ((ContactGroupGibberishImpl)newParent).addContact(gibberishContact);\n\n        fireSubscriptionMovedEvent(contactToMove\n                                   , parentGibberishGroup\n                                   , newParent);\n    }","id":44288,"modified_method":"/**\n     * Removes the specified contact from its current parent and places it\n     * under <tt>newParent<\/tt>.\n     *\n     * @param contactToMove the <tt>Contact<\/tt> to move\n     * @param newParent the <tt>ContactGroup<\/tt> where <tt>Contact<\/tt>\n     *   would be placed.\n     */\n    public void moveContactToGroup(Contact contactToMove,\n                                   ContactGroup newParent)\n    {\n        ContactGibberishImpl gibberishContact\n            = (ContactGibberishImpl)contactToMove;\n\n        ContactGroupGibberishImpl parentGibberishGroup\n            = findContactParent(gibberishContact);\n\n        parentGibberishGroup.removeContact(gibberishContact);\n\n        //if this is a volatile contact then we haven't really subscribed to\n        //them so we'd need to do so here\n        if(!gibberishContact.isPersistent())\n        {\n            //first tell everyone that the volatile contact was removed\n            fireSubscriptionEvent(gibberishContact\n                                  , parentGibberishGroup\n                                  , SubscriptionEvent.SUBSCRIPTION_REMOVED);\n\n            try\n            {\n                //now subscribe\n                this.subscribe(newParent, contactToMove.getAddress());\n\n                //now tell everyone that we've added the contact\n                fireSubscriptionEvent(gibberishContact\n                                      , newParent\n                                      , SubscriptionEvent.SUBSCRIPTION_CREATED);\n            }\n            catch (Exception ex)\n            {\n                logger.error(\"Failed to move contact \"\n                             + gibberishContact.getAddress()\n                             , ex);\n            }\n        }\n        else\n        {\n            ( (ContactGroupGibberishImpl) newParent)\n                    .addContact(gibberishContact);\n\n            fireSubscriptionMovedEvent(contactToMove\n                                      , parentGibberishGroup\n                                       , newParent);\n        }\n    }","commit_id":"739adad73f1860303a2a5397f553268f9eff21d2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of this operation set keeping a reference to the\n     * specified parent <tt>provider<\/tt>.\n     * @param provider the ProtocolProviderServiceGibberishImpl instance that\n     * created us.\n     */\n    public OperationSetPersistentPresenceGibberishImpl(\n            ProtocolProviderServiceGibberishImpl        provider)\n    {\n        this.parentProvider = provider;\n        contactListRoot = new ContactGroupGibberishImpl(\"RootGroup\", provider);\n    }","id":44289,"modified_method":"/**\n     * Creates an instance of this operation set keeping a reference to the\n     * specified parent <tt>provider<\/tt>.\n     * @param provider the ProtocolProviderServiceGibberishImpl instance that\n     * created us.\n     */\n    public OperationSetPersistentPresenceGibberishImpl(\n            ProtocolProviderServiceGibberishImpl        provider)\n    {\n        this.parentProvider = provider;\n        contactListRoot = new ContactGroupGibberishImpl(\"RootGroup\", provider);\n\n        //add our unregistration listener\n        parentProvider.addRegistrationStateChangeListener(\n            new UnregistrationListener());\n    }","commit_id":"739adad73f1860303a2a5397f553268f9eff21d2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the presence status of all <tt>contact<\/tt>s that we have currently\n     * in our contact list and sets their new status to <tt>newStatus<\/tt>.\n     *\n     * @param newStatus the new status we'd like to set to <tt>contact<\/tt>.\n     * @param parent the group in which we'd have to update the status of all\n     * direct and indirect child contacts.\n     */\n    private void changePresenceStatusForAllContacts(ContactGroup   parent,\n                                                    PresenceStatus newStatus)\n    {\n        //first set the status for contacts in this group\n        Iterator childContacts = parent.contacts();\n\n        while(childContacts.hasNext())\n        {\n            ContactGibberishImpl contact\n                = (ContactGibberishImpl)childContacts.next();\n\n            PresenceStatus oldStatus = contact.getPresenceStatus();\n            contact.setPresenceStatus(newStatus);\n\n            fireContactPresenceStatusChangeEvent(\n                contact, parent, oldStatus);\n        }\n\n        //now call this method recursively for all subgroups\n        Iterator subgroups = parent.subgroups();\n\n        while(subgroups.hasNext())\n        {\n            ContactGroup subgroup = (ContactGroup)subgroups.next();\n            changePresenceStatusForAllContacts(subgroup, newStatus);\n        }\n    }","id":44290,"modified_method":"/**\n     * Sets the presence status of all <tt>contact<\/tt>s in our contact list\n     * (except those that  correspond to another provider registered with SC)\n     * to <tt>newStatus<\/tt>.\n     *\n     * @param newStatus the new status we'd like to set to <tt>contact<\/tt>.\n     * @param parent the group in which we'd have to update the status of all\n     * direct and indirect child contacts.\n     */\n    private void changePresenceStatusForAllContacts(ContactGroup   parent,\n                                                    PresenceStatus newStatus)\n    {\n        //first set the status for contacts in this group\n        Iterator childContacts = parent.contacts();\n\n        while(childContacts.hasNext())\n        {\n            ContactGibberishImpl contact\n                = (ContactGibberishImpl)childContacts.next();\n\n            if(findProviderForGibberishUserID(contact.getAddress()) != null)\n            {\n                //this is a contact corresponding to another SIP Communicator\n                //provider so we won't change it's status here.\n                continue;\n            }\n            PresenceStatus oldStatus = contact.getPresenceStatus();\n            contact.setPresenceStatus(newStatus);\n\n            fireContactPresenceStatusChangeEvent(\n                contact, parent, oldStatus);\n        }\n\n        //now call this method recursively for all subgroups\n        Iterator subgroups = parent.subgroups();\n\n        while(subgroups.hasNext())\n        {\n            ContactGroup subgroup = (ContactGroup)subgroups.next();\n            changePresenceStatusForAllContacts(subgroup, newStatus);\n        }\n    }","commit_id":"739adad73f1860303a2a5397f553268f9eff21d2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Requests the provider to enter into a status corresponding to the\n     * specified paramters.\n     *\n     * @param status the PresenceStatus as returned by\n     *   getRequestableStatusSet\n     * @param statusMessage the message that should be set as the reason to\n     *   enter that status\n     * @throws IllegalArgumentException if the status requested is not a\n     *   valid PresenceStatus supported by this provider.\n     * @throws IllegalStateException if the provider is not currently\n     *   registered.\n     * @throws OperationFailedException with code NETWORK_FAILURE if\n     *   publishing the status fails due to a network error.\n     */\n    public void publishPresenceStatus(PresenceStatus status,\n                                      String statusMessage) throws\n        IllegalArgumentException, IllegalStateException,\n        OperationFailedException\n    {\n        PresenceStatus oldPresenceStatus = this.presenceStatus;\n        this.presenceStatus = status;\n        this.statusMessage = statusMessage;\n\n        this.fireProviderStatusChangeEvent(oldPresenceStatus);\n\n        //since we are not a real protocol, we set the contact presence status\n        //ourselves and make them have the same status as ours.\n        changePresenceStatusForAllContacts( getServerStoredContactListRoot()\n                                            , getPresenceStatus());\n\n    }","id":44291,"modified_method":"/**\n     * Requests the provider to enter into a status corresponding to the\n     * specified paramters.\n     *\n     * @param status the PresenceStatus as returned by\n     *   getRequestableStatusSet\n     * @param statusMessage the message that should be set as the reason to\n     *   enter that status\n     * @throws IllegalArgumentException if the status requested is not a\n     *   valid PresenceStatus supported by this provider.\n     * @throws IllegalStateException if the provider is not currently\n     *   registered.\n     * @throws OperationFailedException with code NETWORK_FAILURE if\n     *   publishing the status fails due to a network error.\n     */\n    public void publishPresenceStatus(PresenceStatus status,\n                                      String statusMessage) throws\n        IllegalArgumentException, IllegalStateException,\n        OperationFailedException\n    {\n        PresenceStatus oldPresenceStatus = this.presenceStatus;\n        this.presenceStatus = status;\n        this.statusMessage = statusMessage;\n\n        this.fireProviderStatusChangeEvent(oldPresenceStatus);\n\n        //since we are not a real protocol, we set the contact presence status\n        //ourselves and make them have the same status as ours.\n        changePresenceStatusForAllContacts( getServerStoredContactListRoot()\n                                            , getPresenceStatus());\n\n        //now check whether we are in someone else's contact list and modify\n        //our status there\n        List contacts = findContactsPointingToUs();\n\n        Iterator contactsIter = contacts.iterator();\n        while (contactsIter.hasNext())\n        {\n            ContactGibberishImpl contact\n                = (ContactGibberishImpl) contactsIter.next();\n\n            PresenceStatus oldStatus = contact.getPresenceStatus();\n            contact.setPresenceStatus(status);\n            contact.getParentPresenceOperationSet()\n                .fireContactPresenceStatusChangeEvent(\n                    contact\n                    , contact.getParentContactGroup()\n                    , oldStatus);\n\n        }\n    }","commit_id":"739adad73f1860303a2a5397f553268f9eff21d2","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Updates the current contact list view to match the given\n     * <tt>filterString<\/tt>. If the <tt>filterString<\/tt> is null or\n     * empty we reset the presence filter.\n     * @param filterString the current filter string entered in\n     * this search field\n     */\n    public void updateContactListView(String filterString)\n    {\n        TreeContactList contactList = GuiActivator.getContactList();\n\n        if (filterString != null && filterString.length() > 0)\n        {\n            boolean hasMatching\n                = contactList.applyFilter(TreeContactList.searchFilter);\n\n            // If don't have matching contacts we enter the unknown contact\n            // view.\n            if (!hasMatching)\n            {\n                enableUnknownContactView(true);\n            }\n            // If the unknown contact view was previously enabled, but we\n            // have found matching contacts we enter the normal view.\n            else\n            {\n                if (!lastHasMatching)\n                    enableUnknownContactView(false);\n\n                contactList.selectFirstContact();\n            }\n\n            lastHasMatching = hasMatching;\n        }\n        else\n        {\n            contactList.applyDefaultFilter();\n\n            enableUnknownContactView(false);\n        }\n    }","id":44292,"modified_method":"/**\n     * Updates the current contact list view to match the given\n     * <tt>filterString<\/tt>. If the <tt>filterString<\/tt> is null or\n     * empty we reset the presence filter.\n     * @param filterString the current filter string entered in\n     * this search field\n     */\n    public void updateContactListView(String filterString)\n    {\n        TreeContactList contactList = GuiActivator.getContactList();\n\n        if (filterString != null && filterString.length() > 0)\n        {\n            FilterQuery filterQuery\n                = contactList.applyFilter(TreeContactList.searchFilter);\n\n            if (filterQuery != null)\n                filterQuery.setQueryListener(this);\n        }\n        else\n        {\n            contactList.applyDefaultFilter();\n\n            enableUnknownContactView(false);\n        }\n    }","commit_id":"32656edcfc7b5cdacc642a3f333741eb135e2419","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds the list of <tt>sourceContacts<\/tt> in the current result tree model.\n     * @param sourceContacts the list of <tt>SourceContact<\/tt>s to add\n     */\n    private void addMatching(List<SourceContact> sourceContacts)\n    {\n        Iterator<SourceContact> contactsIter = sourceContacts.iterator();\n        while (contactsIter.hasNext())\n        {\n            addSourceContact(contactsIter.next());\n        }\n    }","id":44293,"modified_method":"/**\n     * Adds the list of <tt>sourceContacts<\/tt> in the given <tt>treeModel<\/tt>.\n     * @param sourceContacts the list of <tt>SourceContact<\/tt>s to add\n     * @param treeModel the <tt>ContactListTreeModel<\/tt>, where the contacts\n     * are added\n     */\n    private void addMatching(   List<SourceContact> sourceContacts,\n                                ContactListTreeModel treeModel)\n    {\n        Iterator<SourceContact> contactsIter = sourceContacts.iterator();\n        while (contactsIter.hasNext())\n        {\n            addSourceContact(contactsIter.next(), treeModel);\n        }\n    }","commit_id":"32656edcfc7b5cdacc642a3f333741eb135e2419","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Adds the given <tt>sourceContact<\/tt> to the result tree model.\n     * @param sourceContact the <tt>SourceContact<\/tt> to add\n     */\n    private void addSourceContact(SourceContact sourceContact)\n    {\n        ContactSourceService contactSource\n            = sourceContact.getContactSource();\n\n        ExternalContactSource sourceUI\n            = TreeContactList.getContactSource(contactSource);\n\n        if (sourceUI != null\n            // ExtendedContactSourceService has already matched the\n            // SourceContact over the pattern\n            && (contactSource instanceof ExtendedContactSourceService)\n                || isMatching(sourceContact))\n            GuiActivator.getContactList().addContact(\n                resultTreeModel,\n                sourceUI.getUIContact(sourceContact),\n                sourceUI.getUIGroup(),\n                true,\n                false);\n    }","id":44294,"modified_method":"/**\n     * Adds the given <tt>sourceContact<\/tt> to the result tree model.\n     * @param sourceContact the <tt>SourceContact<\/tt> to add\n     * @param treeModel the <tt>ContactListTreeModel<\/tt> storing the result\n     */\n    private void addSourceContact(  SourceContact sourceContact,\n                                    ContactListTreeModel treeModel)\n    {\n        ContactSourceService contactSource\n            = sourceContact.getContactSource();\n\n        ExternalContactSource sourceUI\n            = TreeContactList.getContactSource(contactSource);\n\n        if (sourceUI != null\n            // ExtendedContactSourceService has already matched the\n            // SourceContact over the pattern\n            && (contactSource instanceof ExtendedContactSourceService)\n                || isMatching(sourceContact))\n        {\n            GuiActivator.getContactList().addContact(\n                treeModel,\n                sourceUI.getUIContact(sourceContact),\n                sourceUI.getUIGroup(),\n                false,\n                false);\n        }\n    }","commit_id":"32656edcfc7b5cdacc642a3f333741eb135e2419","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Applies this filter and stores the result in the given <tt>treeModel<\/tt>.\n     * @param treeModel the <tt>ContactListTreeModel<\/tt>, in which we store\n     * results\n     */\n    public void applyFilter(ContactListTreeModel treeModel)\n    {\n        resultTreeModel = treeModel;\n\n        if (contactSources == null)\n            contactSources = TreeContactList.getContactSources();\n\n        if (searchSourceType == DEFAULT_SOURCE)\n            // First add the MetaContactListSource\n            mclSource.filter(filterPattern, treeModel);\n\n        for (ExternalContactSource contactSource : contactSources)\n        {\n            ContactSourceService sourceService\n                = contactSource.getContactSourceService();\n            if (sourceService instanceof ExtendedContactSourceService)\n                currentQuery\n                    = ((ExtendedContactSourceService) sourceService)\n                        .queryContactSource(filterPattern);\n            else\n                currentQuery = sourceService.queryContactSource(filterString);\n\n            // Add first available results.\n            this.addMatching(currentQuery.getQueryResults());\n\n            currentQuery.addContactQueryListener(this);\n        }\n    }","id":44295,"modified_method":"/**\n     * Applies this filter and stores the result in the given <tt>treeModel<\/tt>.\n     * @param treeModel the <tt>ContactListTreeModel<\/tt>, in which we store\n     * results\n     */\n    public void applyFilter(ContactListTreeModel treeModel)\n    {\n        if (searchSourceType == DEFAULT_SOURCE)\n            // First add the MetaContactListSource\n            mclSource.filter(filterPattern, treeModel);\n    }","commit_id":"32656edcfc7b5cdacc642a3f333741eb135e2419","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Stops the current filtering if there's one active.\n     */\n    public void stopFiltering()\n    {\n        currentFilter.stopFilter();\n        this.isFiltering = false;\n    }","id":44296,"modified_method":"/**\n     * Stops the current filtering if there's one active.\n     */\n    public void stopFiltering()\n    {\n        currentFilter.stopFilter();\n        this.isFiltering = false;\n\n        if (filterQuery != null)\n            filterQuery.cancel();\n    }","commit_id":"32656edcfc7b5cdacc642a3f333741eb135e2419","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Applies the default filter.\n     * @return <tt>true<\/tt> to indicate that the filter has found a match, \n     * <tt>false<\/tt> if no matches were found and the contact list is then\n     * empty.\n     */\n    public boolean applyDefaultFilter()\n    {\n        return applyFilter(defaultFilter);\n    }","id":44297,"modified_method":"/**\n     * Applies the default filter.\n     * @return <tt>true<\/tt> to indicate that the filter has found a match, \n     * <tt>false<\/tt> if no matches were found and the contact list is then\n     * empty.\n     */\n    public boolean applyDefaultFilter()\n    {\n        return applyFilter(defaultFilter, new ContactListTreeModel(), null);\n    }","commit_id":"32656edcfc7b5cdacc642a3f333741eb135e2419","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Applies the given <tt>filter<\/tt> and changes the content of the\n     * contact list according to it.\n     * @param filter the new filter to set\n     * @return <tt>true<\/tt> to indicate that the filter has found a match, \n     * <tt>false<\/tt> if no matches were found and the contact list is then\n     * empty.\n     */\n    public boolean applyFilter(ContactListFilter filter)\n    {\n        // We set the isFiltering to true to indicate that we're currently\n        // filtering.\n        isFiltering = true;\n\n        if (currentFilter == null || !currentFilter.equals(filter))\n            this.currentFilter = filter;\n\n        tempTreeModel = new ContactListTreeModel();\n\n        // We synchronize the matching and all MetaContactListener events on\n        // the searchTreeModel in order to prevent modification to be done on\n        // the actual treeModel while we're working with the temporary model.\n        synchronized (filterLock)\n        {\n            treeModel.clearDependencies();\n\n            currentFilter.applyFilter(tempTreeModel);\n\n            treeModel = tempTreeModel;\n        }\n\n        // If in the mean time someone has stopped filtering we return here.\n        if (!isFiltering)\n        {\n            return (treeModel.getChildCount(treeModel.getRoot()) > 0);\n        }\n\n        SwingUtilities.invokeLater(new Runnable()\n        {\n            public void run()\n            {\n                // Set the updated treeModel to the tree component.\n                setTreeModel(treeModel);\n\n                // Refresh the view.\n                treeModel.reload();\n\n                // Expand all rows. Should be done only after the new model\n                // is visible to have effect.\n                expandAllRows();\n\n                // We should explicitly re-validate the whole tree as we\n                // changed its model.\n                revalidate();\n                repaint();\n            }\n        });\n\n        // We set the isFiltering to false to indicate that we finished\n        // filtering.\n        isFiltering = false;\n\n        boolean hasResults = false;\n\n        // As we update the tree in the swing thread, we should check the\n        // temporary model here in order to given correct results.\n        if (tempTreeModel.getChildCount(tempTreeModel.getRoot()) > 0)\n            hasResults = true;\n\n        tempTreeModel = null;\n\n        return hasResults;\n    }","id":44298,"modified_method":"/**\n     * Applies the given <tt>filter<\/tt>.\n     * @param filter the <tt>ContactListFilter<\/tt> to apply.\n     * @return <tt>true<\/tt> if the filter has any matches, <tt>false<\/tt>\n     * otherwise\n     */\n    public boolean applyFilter(ContactListFilter filter)\n    {\n        return applyFilter(filter, new ContactListTreeModel(), null);\n    }","commit_id":"32656edcfc7b5cdacc642a3f333741eb135e2419","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void serviceChanged(ServiceEvent event)\n        {\n            ServiceReference serviceRef = event.getServiceReference();\n\n            // if the event is caused by a bundle being stopped, we don't want\n            // to know\n            if (serviceRef.getBundle().getState() == Bundle.STOPPING)\n                return;\n\n            Object service = GuiActivator.bundleContext.getService(serviceRef);\n\n            // we don't care if the source service is\n            // not a contact source service\n            if (!(service instanceof ContactSourceService))\n                return;\n\n            switch (event.getType())\n            {\n            case ServiceEvent.REGISTERED:\n                contactSources.add(\n                    new ExternalContactSource((ContactSourceService) service));\n                break;\n            case ServiceEvent.UNREGISTERING:\n                ExternalContactSource cSource\n                    = getContactSource((ContactSourceService) service);\n                if (cSource != null)\n                    contactSources.remove(cSource);\n                break;\n            }\n        }","id":44299,"modified_method":"public void serviceChanged(ServiceEvent event)\n        {\n            ServiceReference serviceRef = event.getServiceReference();\n\n            // if the event is caused by a bundle being stopped, we don't want\n            // to know\n            if (serviceRef.getBundle().getState() == Bundle.STOPPING)\n                return;\n\n            Object service = GuiActivator.bundleContext.getService(serviceRef);\n\n            // we don't care if the source service is\n            // not a contact source service\n            if (!(service instanceof ContactSourceService))\n                return;\n\n            switch (event.getType())\n            {\n            case ServiceEvent.REGISTERED:\n                ExternalContactSource contactSource\n                    = new ExternalContactSource((ContactSourceService) service);\n                contactSources.add(contactSource);\n                break;\n            case ServiceEvent.UNREGISTERING:\n                ExternalContactSource cSource\n                    = getContactSource((ContactSourceService) service);\n                if (cSource != null)\n                    contactSources.remove(cSource);\n                break;\n            }\n        }","commit_id":"32656edcfc7b5cdacc642a3f333741eb135e2419","url":"https://github.com/jitsi/jitsi"},{"original_method":"public CallPanel(){\n\t\t\n\t\tsuper(new BorderLayout());\n\t\t\n\t\tcallButton \t\t= new SIPCommButton(callButtonBG,\n\t\t\t\t\t\t\t\t\t\t\tcallButtonRolloverBG, \n\t\t\t\t\t\t\t\t\t\t\tcallButtonIcon);\n\t\thangupButton \t= new SIPCommButton(hangupButtonBG,\n\t\t\t\t\t\t\t\t\t\t\thangupButtonRolloverBG, \n\t\t\t\t\t\t\t\t\t\t\thangupButtonIcon);\n\t\t\t\t\n\t\tthis.setBorder(BorderFactory.createEmptyBorder(10, 5, 10, 5));\n\t\tthis.init();\n\t}","id":44300,"modified_method":"public CallPanel(){\n\t\t\n\t\tsuper(new BorderLayout());\n\t\t/*\n\t\tcallButton \t\t= new SIPCommButton(callButtonBG,\n\t\t\t\t\t\t\t\t\t\t\tcallButtonRolloverBG, \n\t\t\t\t\t\t\t\t\t\t\tcallButtonIcon);\n\t\thangupButton \t= new SIPCommButton(hangupButtonBG,\n\t\t\t\t\t\t\t\t\t\t\thangupButtonRolloverBG, \n\t\t\t\t\t\t\t\t\t\t\thangupButtonIcon);\n\t\t*/\t\t\n\t\t\n\t\tcallButton \t\t= new SIPCommButton(callButtonBG,\n\t\t\t\t\t\t\t\t\t\t\tcallButtonRolloverBG,\n\t\t\t\t\t\t\t\t\t\t\tcallButtonPressedIcon,\n\t\t\t\t\t\t\t\t\t\t\tnull);\n\t\t\n\t\thangupButton \t= new SIPCommButton(hangupButtonBG,\n\t\t\t\t\t\t\t\t\t\t\thangupButtonRolloverBG,\n\t\t\t\t\t\t\t\t\t\t\thangupButtonPressedIcon,\n\t\t\t\t\t\t\t\t\t\t\tnull);\n\n\t\tthis.setBorder(BorderFactory.createEmptyBorder(10, 5, 10, 5));\n\t\tthis.init();\n\t}","commit_id":"2605a4c01f519aebe9cea15b1e755c433d2b849c","url":"https://github.com/jitsi/jitsi"},{"original_method":"public static void main(String[] args){\n\t\t\n\t\ttry {\n\t\t\t//the theme could be passed as a parameter\n\t\t\tif (args.length > 0) {\n\t\t\t\tString themepack = args[0];\n\t\t\t\tif (themepack.endsWith(\".xml\")) {\t\t\t    \t  \n\t\t\t\t\tSkinLookAndFeel.setSkin(\n\t\t\t\t\t\t\tSkinLookAndFeel.loadThemePackDefinition(new File(args[0]).toURL()));\n\t\t\t\t\tUIManager.setLookAndFeel(\"com.l2fprod.gui.plaf.skin.SkinLookAndFeel\");\n\t\t\t\t} else if (themepack.startsWith(\"class:\")) {\n\t\t\t\t\tString classname = themepack.substring(\"class:\".length());\n\t\t\t\t\tSkinLookAndFeel.setSkin((Skin)Class.forName(classname).newInstance());\t\n\t\t\t\t\tUIManager.setLookAndFeel(\"com.l2fprod.gui.plaf.skin.SkinLookAndFeel\");\n\t\t\t\t} else if (themepack.startsWith(\"theme:\")) {\n\t\t\t\t\tString classname = themepack.substring(\"theme:\".length());\n\t\t\t\t\tMetalTheme theme = (MetalTheme)Class.forName(classname).newInstance();\n\t\t\t\t    MetalLookAndFeel metal = new MetalLookAndFeel();\t\n\t\t\t\t    MetalLookAndFeel.setCurrentTheme(theme);\n\t\t\t\t    UIManager.setLookAndFeel(metal);\n\t\t\t\t} else {\n\t\t\t\t\tSkinLookAndFeel.setSkin(SkinLookAndFeel.loadThemePack(args[0]));\n\t\t\t\t\tUIManager.setLookAndFeel(\"com.l2fprod.gui.plaf.skin.SkinLookAndFeel\");\t\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\t//the default theme is set if no theme is specified\n\t\t\telse{\n\t\t\t\tSkinLookAndFeel.setSkin(\n\t\t\t\t\t\tSkinLookAndFeel.loadThemePackDefinition(new File(\"src/net/java/sip/communicator/impl/gui/themepacks/aquathemepack/skinlf-themepack.xml\").toURL()));\n\t\t\t\tUIManager.setLookAndFeel(\"com.l2fprod.gui.plaf.skin.SkinLookAndFeel\");\n\t\t\t}\n\t\t\t\t\n\t\t\t//Decorates the frames and dialogs if we are running with jdk1.4 +\n\t\t\t/*\n\t\t\tif (OS.isOneDotFourOrMore()) {\n\t\t\t\tjava.lang.reflect.Method method = JFrame.class.getMethod(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"setDefaultLookAndFeelDecorated\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Class[] { boolean.class });\n\t\t\t\tmethod.invoke(null, new Object[] { Boolean.TRUE });\n\n\t\t\t\tmethod = JDialog.class.getMethod(\n\t\t\t\t\t\t\"setDefaultLookAndFeelDecorated\",\n\t\t\t\t\t\tnew Class[] { boolean.class });\n\t\t\t\tmethod.invoke(null, new Object[] { Boolean.TRUE });\n\t\t    }*/\n\t\t    \n\t\t\t\n\t    } catch (Exception e) { }\n\t    \n\t    //Image frameIcon = \n\t      //new ImageIcon(demo.class.getResource(\"windowicon.gif\")).getImage();\n\t    // so option pane as same icon as us\n\t    //JOptionPane.getRootFrame().setIconImage(frameIcon);\n\n\t    //TODO: To be removed when the contact list service is ready\n\t    ContactList clist = new ContactList();\n\t    \n\t    clist.addContact(new ContactItem(\"user1\"));\n\t\tclist.addContact(new ContactItem(\"user2\"));\n\t\tclist.addContact(new ContactItem(\"user3\"));\n\t\t\n\t\tUser user = new User();\n\t\t\n\t\tuser.setProtocols(new String[]{\"SIP\", \"ICQ\", \"MSN\"});\n\t\t\t\t\n\t    MainFrame mainFrame = new MainFrame(clist, user);\n\t    \t        \n\t    mainFrame.setTitle(\"SIP Communicator\");\n\t    \n\t    // There is a problem with the quality of the title bar icon. It's not solved.\n\t    BufferedImage iconImage = new BufferedImage(LookAndFeelConstants.SIP_LOGO.getWidth(null),\n\t\t\t\tLookAndFeelConstants.ICQ_LOGO.getHeight(null),\n\t\t\t\tBufferedImage.TYPE_3BYTE_BGR);\n\t    \n\t    iconImage.getGraphics().drawImage(LookAndFeelConstants.SIP_LOGO, 0, 0, mainFrame);\n\t    \n\t    mainFrame.setIconImage(iconImage);\n\t    \n\t    \t    \n\t    mainFrame.pack();\n\t    \n\t    mainFrame.setVisible(true);\t    \t\t\t\n\t}","id":44301,"modified_method":"public static void main(String[] args){\n\t\t\n\t\ttry {\n\t\t\t//the theme could be passed as a parameter\n\t\t\tif (args.length > 0) {\n\t\t\t\tString themepack = args[0];\n\t\t\t\tif (themepack.endsWith(\".xml\")) {\t\t\t    \t  \n\t\t\t\t\tSkinLookAndFeel.setSkin(\n\t\t\t\t\t\t\tSkinLookAndFeel.loadThemePackDefinition(new File(args[0]).toURL()));\n\t\t\t\t\tUIManager.setLookAndFeel(\"com.l2fprod.gui.plaf.skin.SkinLookAndFeel\");\n\t\t\t\t} else if (themepack.startsWith(\"class:\")) {\n\t\t\t\t\tString classname = themepack.substring(\"class:\".length());\n\t\t\t\t\tSkinLookAndFeel.setSkin((Skin)Class.forName(classname).newInstance());\t\n\t\t\t\t\tUIManager.setLookAndFeel(\"com.l2fprod.gui.plaf.skin.SkinLookAndFeel\");\n\t\t\t\t} else if (themepack.startsWith(\"theme:\")) {\n\t\t\t\t\tString classname = themepack.substring(\"theme:\".length());\n\t\t\t\t\tMetalTheme theme = (MetalTheme)Class.forName(classname).newInstance();\n\t\t\t\t    MetalLookAndFeel metal = new MetalLookAndFeel();\t\n\t\t\t\t    MetalLookAndFeel.setCurrentTheme(theme);\n\t\t\t\t    UIManager.setLookAndFeel(metal);\n\t\t\t\t} else {\n\t\t\t\t\tSkinLookAndFeel.setSkin(SkinLookAndFeel.loadThemePack(args[0]));\n\t\t\t\t\tUIManager.setLookAndFeel(\"com.l2fprod.gui.plaf.skin.SkinLookAndFeel\");\t\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t\t//the default theme is set if no theme is specified\n\t\t\telse{\n\t\t\t\tSkinLookAndFeel.setSkin(\n\t\t\t\t\t\tSkinLookAndFeel.loadThemePackDefinition(new File(\"src/net/java/sip/communicator/impl/gui/themepacks/aquathemepack/skinlf-themepack.xml\").toURL()));\n\t\t\t\tUIManager.setLookAndFeel(\"com.l2fprod.gui.plaf.skin.SkinLookAndFeel\");\n\t\t\t}\n\t\t\t\t\n\t\t\t//Decorates the frames and dialogs if we are running with jdk1.4 +\n\t\t\t/*\n\t\t\tif (OS.isOneDotFourOrMore()) {\n\t\t\t\tjava.lang.reflect.Method method = JFrame.class.getMethod(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"setDefaultLookAndFeelDecorated\",\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Class[] { boolean.class });\n\t\t\t\tmethod.invoke(null, new Object[] { Boolean.TRUE });\n\n\t\t\t\tmethod = JDialog.class.getMethod(\n\t\t\t\t\t\t\"setDefaultLookAndFeelDecorated\",\n\t\t\t\t\t\tnew Class[] { boolean.class });\n\t\t\t\tmethod.invoke(null, new Object[] { Boolean.TRUE });\n\t\t    }*/\n\t\t    \n\t\t\t\n\t    } catch (Exception e) { }\n\t    \n\t    //TODO: To be removed when the contact list service is ready\n\t    ContactList clist = new ContactList();\n\t    \n\t    ContactItem citem1 = new ContactItem(\"Ivancho\");\n\t    ContactItem citem2 = new ContactItem(\"Traiancho\");\n\t    ContactItem citem3 = new ContactItem(\"Glupancho\");\n\t    \n\t    citem1.setUserIcon(new ImageIcon(LookAndFeelConstants.USER_ONLINE_ICON));\n\t    citem2.setUserIcon(new ImageIcon(LookAndFeelConstants.USER_ONLINE_ICON));\n\t    citem3.setUserIcon(new ImageIcon(LookAndFeelConstants.USER_ONLINE_ICON));\n\t    \n\t    clist.addContact(citem1);\n\t\tclist.addContact(citem2);\n\t\tclist.addContact(citem3);\n\t\t\n\t\tUser user = new User();\n\t\t\n\t\tuser.setProtocols(new String[]{\"SIP\", \"ICQ\", \"MSN\"});\n\t\t\n\t\t//////////////////////////////////////////////////////////////////////\n\t\t\n\t    MainFrame mainFrame = new MainFrame(clist, user);\n\t    \t    \n\t    mainFrame.setTitle(\"Communicator\");\n\t    \t    \n\t    mainFrame.setIconImage(LookAndFeelConstants.SIP_LOGO);\n\t    \n\t    //In order to have the same icon when using option panes\n\t    JOptionPane.getRootFrame().setIconImage(LookAndFeelConstants.SIP_LOGO);\n\t    \n\t    mainFrame.pack();\n\t    \n\t    mainFrame.setVisible(true);\t    \t\t\t\n\t}","commit_id":"2605a4c01f519aebe9cea15b1e755c433d2b849c","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void setUserData(){\n\t\tnicknameLabel.setText(this.contactItem.getNickName());\n\t}","id":44302,"modified_method":"public void setUserData(){\n\t\tthis.nicknameLabel.setText(this.contactItem.getNickName());\n\t\tthis.nicknameLabel.setIcon(this.contactItem.getUserIcon());\n\t\tthis.nicknameLabel.setIconTextGap(0);\n\t}","commit_id":"2605a4c01f519aebe9cea15b1e755c433d2b849c","url":"https://github.com/jitsi/jitsi"},{"original_method":"private void init(){\n\t\t\n\t\tnicknameLabel.setFont(this.getFont().deriveFont(Font.BOLD));\n\t\t\n\t\tthis.setUserData();\n\t\t\n\t\tthis.add(nicknameLabel, BorderLayout.WEST);\n\t\t\n\t}","id":44303,"modified_method":"private void init(){\n\t\t\n\t\tthis.nicknameLabel.setFont(this.getFont().deriveFont(Font.BOLD));\n\t\t\n\t\tthis.setUserData();\n\t\t\t\t\n\t\tthis.add(nicknameLabel, BorderLayout.CENTER);\n\t\t\n\t}","commit_id":"2605a4c01f519aebe9cea15b1e755c433d2b849c","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Process LDAP event.\n     *\n     * @param evt LDAP event\n     */\n    private void processLdapResponse(LdapEvent evt)\n    {\n        if(evt.getCause() == LdapEvent.LdapEventCause.SEARCH_ACHIEVED ||\n                evt.getCause() == LdapEvent.LdapEventCause.SEARCH_CANCELLED)\n        {\n            synchronized(objLock)\n            {\n                objLock.notify();\n            }\n        }\n\n        if(evt.getCause() == LdapEvent.LdapEventCause.NEW_SEARCH_RESULT)\n        {\n            LdapPersonFound person = (LdapPersonFound) evt.getContent();\n            String displayName = null;\n\n            if(person == null)\n            {\n                return;\n            }\n\n            if(person.getDisplayName() != null)\n            {\n                displayName = person.getDisplayName();\n            }\n            else\n            {\n                displayName = person.getFirstName() + \" \" + person.getSurname();\n            }\n\n            List<ContactDetail> contactDetails = getContactDetails(person);\n\n            if (!contactDetails.isEmpty())\n            {\n                GenericSourceContact sourceContact\n                    = new GenericSourceContact(\n                            getContactSource(),\n                            displayName,\n                            contactDetails);\n\n                try\n                {\n                    sourceContact.setImage(person.fetchPhoto());\n                }\n                catch (OutOfMemoryError oome)\n                {\n                    // Ignore it, the image is not vital.\n                }\n\n                if (person.getOrganization() != null)\n                {\n                    sourceContact.setDisplayDetails(person.getOrganization());\n                }\n\n                addQueryResult(sourceContact);\n            }\n        }\n        else if(evt.getCause() == LdapEvent.LdapEventCause.SEARCH_AUTH_ERROR)\n        {\n            synchronized(objLock)\n            {\n                objLock.notify();\n            }\n\n            /* show authentication window to obtain new credentials */\n            new Thread()\n            {\n                public void run()\n                {\n                    LdapDirectorySettingsImpl ldapSettings =\n                        (LdapDirectorySettingsImpl) getContactSource()\n                            .getLdapDirectory().getSettings();\n\n                    AuthenticationWindow authWindow\n                        = new AuthenticationWindow(ldapSettings.getUserName(),\n                            ldapSettings.getPassword().toCharArray(),\n                            ldapSettings.getName(),\n                            false,\n                            LdapActivator.getResourceService().getImage(\n                                \"service.gui.icons.AUTHORIZATION_ICON\"),\n                            LdapActivator.getResourceService().getI18NString(\n                                \"impl.ldap.WRONG_CREDENTIALS\",\n                                new String[]{ldapSettings.getName()}));\n\n                    authWindow.setVisible(true);\n\n                    if(!authWindow.isCanceled())\n                    {\n                        LdapDirectorySettings newSettings\n                            = new LdapDirectorySettingsImpl(ldapSettings);\n\n                        // Remove old server.\n                        LdapService ldapService\n                            = LdapActivator.getLdapService();\n\n                        LdapFactory factory = ldapService.getFactory();\n                        LdapDirectory ldapDir\n                            = getContactSource().getLdapDirectory();\n                        LdapActivator.unregisterContactSource(ldapDir);\n                        ldapService.getServerSet().removeServerWithName(\n                                ldapSettings.getName());\n\n                        // Add new server.\n                        newSettings.setPassword(\n                            new String(authWindow.getPassword()));\n\n                        ldapDir = factory.createServer(newSettings);\n                        ldapService.getServerSet().addServer(ldapDir);\n\n                        LdapActivator.registerContactSource(ldapDir);\n                    }\n                }\n            }.start();\n        }\n    }","id":44304,"modified_method":"/**\n     * Process LDAP event.\n     *\n     * @param evt LDAP event\n     */\n    private void processLdapResponse(LdapEvent evt)\n    {\n        if(evt.getCause() == LdapEvent.LdapEventCause.SEARCH_ACHIEVED ||\n                evt.getCause() == LdapEvent.LdapEventCause.SEARCH_CANCELLED)\n        {\n            synchronized(objLock)\n            {\n                objLock.notify();\n            }\n        }\n\n        if (evt.getCause() == LdapEvent.LdapEventCause.SEARCH_ERROR)\n        {\n            // The status must be set to QUERY_ERROR and the thread allowed to\n            // continue, otherwise the query will still appear to be in\n            // progress.\n            setStatus(ContactQuery.QUERY_ERROR);\n\n            synchronized(objLock)\n            {\n                objLock.notify();\n            }\n        }\n\n        if(evt.getCause() == LdapEvent.LdapEventCause.NEW_SEARCH_RESULT)\n        {\n            LdapPersonFound person = (LdapPersonFound) evt.getContent();\n            String displayName = null;\n\n            if(person == null)\n            {\n                return;\n            }\n\n            if(person.getDisplayName() != null)\n            {\n                displayName = person.getDisplayName();\n            }\n            else\n            {\n                displayName = person.getFirstName() + \" \" + person.getSurname();\n            }\n\n            List<ContactDetail> contactDetails = getContactDetails(person);\n\n            if (!contactDetails.isEmpty())\n            {\n                GenericSourceContact sourceContact\n                    = new GenericSourceContact(\n                            getContactSource(),\n                            displayName,\n                            contactDetails);\n\n                try\n                {\n                    sourceContact.setImage(person.fetchPhoto());\n                }\n                catch (OutOfMemoryError oome)\n                {\n                    // Ignore it, the image is not vital.\n                }\n\n                if (person.getOrganization() != null)\n                {\n                    sourceContact.setDisplayDetails(person.getOrganization());\n                }\n\n                addQueryResult(sourceContact);\n            }\n        }\n        else if(evt.getCause() == LdapEvent.LdapEventCause.SEARCH_AUTH_ERROR)\n        {\n            synchronized(objLock)\n            {\n                objLock.notify();\n            }\n\n            /* show authentication window to obtain new credentials */\n            new Thread()\n            {\n                public void run()\n                {\n                    LdapDirectorySettingsImpl ldapSettings =\n                        (LdapDirectorySettingsImpl) getContactSource()\n                            .getLdapDirectory().getSettings();\n\n                    AuthenticationWindow authWindow\n                        = new AuthenticationWindow(ldapSettings.getUserName(),\n                            ldapSettings.getPassword().toCharArray(),\n                            ldapSettings.getName(),\n                            false,\n                            LdapActivator.getResourceService().getImage(\n                                \"service.gui.icons.AUTHORIZATION_ICON\"),\n                            LdapActivator.getResourceService().getI18NString(\n                                \"impl.ldap.WRONG_CREDENTIALS\",\n                                new String[]{ldapSettings.getName()}));\n\n                    authWindow.setVisible(true);\n\n                    if(!authWindow.isCanceled())\n                    {\n                        LdapDirectorySettings newSettings\n                            = new LdapDirectorySettingsImpl(ldapSettings);\n\n                        // Remove old server.\n                        LdapService ldapService\n                            = LdapActivator.getLdapService();\n\n                        LdapFactory factory = ldapService.getFactory();\n                        LdapDirectory ldapDir\n                            = getContactSource().getLdapDirectory();\n                        LdapActivator.unregisterContactSource(ldapDir);\n                        ldapService.getServerSet().removeServerWithName(\n                                ldapSettings.getName());\n\n                        // Add new server.\n                        newSettings.setPassword(\n                            new String(authWindow.getPassword()));\n\n                        ldapDir = factory.createServer(newSettings);\n                        ldapService.getServerSet().addServer(ldapDir);\n\n                        LdapActivator.registerContactSource(ldapDir);\n                    }\n                }\n            }.start();\n        }\n    }","commit_id":"75fef62f934b63b931a3e0721b90d056dcf3c9b4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Creates an instance of <tt>MoreInfoContact<\/tt>.\n     *\n     * @param contactQuery the contact query\n     * @param queryResults the result list\n     * @param maxResultCount the maximum result count\n     */\n    public ShowMoreContact( ContactQuery contactQuery,\n                            List<SourceContact> queryResults,\n                            int maxResultCount)\n    {\n        this.contactQuery = contactQuery;\n        this.queryResults = queryResults;\n        this.maxResultCount = maxResultCount;\n\n        GuiActivator.getContactList().addContactListListener(this);\n    }","id":44305,"modified_method":"/**\n     * Creates an instance of <tt>MoreInfoContact<\/tt>.\n     *\n     * @param contactQuery the contact query\n     * @param queryResults the result list\n     * @param maxResultCount the maximum result count\n     */\n    public ShowMoreContact( ContactQuery contactQuery,\n                            List<SourceContact> queryResults,\n                            int maxResultCount)\n    {\n        this.contactQuery = contactQuery;\n        this.queryResults = queryResults;\n        this.maxResultCount = maxResultCount;\n\n        // The contact list is already showing a number of results.\n        this.shownResultsCount = maxResultCount;\n\n        GuiActivator.getContactList().addContactListListener(this);\n    }","commit_id":"75fef62f934b63b931a3e0721b90d056dcf3c9b4","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Indicates that a contact has been clicked in the contact list. Show some\n     * more contacts after the \"show more\" has been clicked\n     *\n     * @param evt the <tt>ContactListEvent<\/tt> that notified us\n     */\n    public void contactClicked(ContactListEvent evt)\n    {\n        if (evt.getSourceContact().equals(this))\n        {\n            List<SourceContact> contacts\n                = new ArrayList<SourceContact>(queryResults);\n\n            int newCount\n                = shownResultsCount + maxResultCount;\n\n            int resultSize = contacts.size();\n\n            int maxCount = (resultSize > newCount) ? newCount : resultSize;\n\n            GuiActivator.getContactList().removeContact(this);\n\n            for (int i = shownResultsCount; i < maxCount; i++)\n            {\n                GuiActivator.getContactList().contactReceived(\n                    new ContactReceivedEvent(contactQuery, contacts.get(i)));\n            }\n\n            shownResultsCount = maxCount;\n\n            if (shownResultsCount < resultSize\n                || contactQuery.getStatus() != ContactQuery.QUERY_COMPLETED)\n                GuiActivator.getContactList().addContact(\n                    contactQuery,\n                    this,\n                    GuiActivator.getContactList().getContactSource(\n                        contactQuery.getContactSource()).getUIGroup(),\n                    false);\n\n        }\n    }","id":44306,"modified_method":"/**\n     * Indicates that a contact has been clicked in the contact list. Show some\n     * more contacts after the \"show more\" has been clicked\n     *\n     * @param evt the <tt>ContactListEvent<\/tt> that notified us\n     */\n    public void contactClicked(ContactListEvent evt)\n    {\n        if (evt.getSourceContact().equals(this))\n        {\n            List<SourceContact> contacts\n                = new ArrayList<SourceContact>(queryResults);\n\n            int newCount\n                = shownResultsCount + maxResultCount;\n\n            int resultSize = contacts.size();\n\n            int maxCount = (resultSize > newCount) ? newCount : resultSize;\n\n            GuiActivator.getContactList().removeContact(this);\n\n            for (int i = shownResultsCount; i < maxCount; i++)\n            {\n                GuiActivator.getContactList().contactReceived(\n                    new ContactReceivedEvent(contactQuery, contacts.get(i)));\n            }\n\n            shownResultsCount = maxCount;\n\n            if (shownResultsCount < resultSize\n                || (contactQuery.getStatus() != ContactQuery.QUERY_COMPLETED\n                && contactQuery.getStatus() != ContactQuery.QUERY_ERROR))\n            {\n                GuiActivator.getContactList().addContact(\n                    contactQuery,\n                    this,\n                    GuiActivator.getContactList().getContactSource(\n                        contactQuery.getContactSource()).getUIGroup(),\n                    false);\n\n                // The ContactListListener was removed when the ShowMoreContact\n                // was removed from the contact list, so we need to add it\n                // again.\n                GuiActivator.getContactList().addContactListListener(this);\n            }\n        }\n    }","commit_id":"75fef62f934b63b931a3e0721b90d056dcf3c9b4","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n  public void doLog(@NotNull File path,\n                    @NotNull SVNRevision startRevision,\n                    @NotNull SVNRevision endRevision,\n                    @Nullable SVNRevision pegRevision,\n                    boolean stopOnCopy,\n                    boolean discoverChangedPaths,\n                    boolean includeMergedRevisions,\n                    long limit,\n                    @Nullable String[] revisionProperties,\n                    @Nullable ISVNLogEntryHandler handler) throws VcsException {\n    // TODO: add revision properties parameter if necessary\n\n    List<String> parameters =\n      prepareCommand(path, startRevision, endRevision, pegRevision, stopOnCopy, discoverChangedPaths, includeMergedRevisions, limit);\n\n    try {\n      CommandExecutor command = CommandUtil.execute(myVcs, SvnTarget.fromFile(path, pegRevision), SvnCommandName.log, parameters, null);\n      // TODO: handler should be called in parallel with command execution, but this will be in other thread\n      // TODO: check if that is ok for current handler implementation\n      parseOutput(command, handler);\n    }\n    catch (SVNException e) {\n      throw new VcsException(e);\n    }\n  }","id":44307,"modified_method":"@Override\n  public void doLog(@NotNull SvnTarget target,\n                    @NotNull SVNRevision startRevision,\n                    @NotNull SVNRevision endRevision,\n                    boolean stopOnCopy,\n                    boolean discoverChangedPaths,\n                    boolean includeMergedRevisions,\n                    long limit,\n                    @Nullable String[] revisionProperties,\n                    @Nullable ISVNLogEntryHandler handler) throws VcsException {\n    // TODO: add revision properties parameter if necessary\n\n    List<String> parameters =\n      prepareCommand(target, startRevision, endRevision, stopOnCopy, discoverChangedPaths, includeMergedRevisions, limit);\n\n    try {\n      CommandExecutor command = CommandUtil.execute(myVcs, target, SvnCommandName.log, parameters, null);\n      // TODO: handler should be called in parallel with command execution, but this will be in other thread\n      // TODO: check if that is ok for current handler implementation\n      parseOutput(command, handler);\n    }\n    catch (SVNException e) {\n      throw new VcsException(e);\n    }\n  }","commit_id":"4b02b95c76661960e622870f54ed22d784f11660","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static List<String> prepareCommand(@NotNull File path,\n                                             @NotNull SVNRevision startRevision,\n                                             @NotNull SVNRevision endRevision,\n                                             @Nullable SVNRevision pegRevision,\n                                             boolean stopOnCopy, boolean discoverChangedPaths, boolean includeMergedRevisions, long limit) {\n    List<String> parameters = new ArrayList<String>();\n\n    CommandUtil.put(parameters, path, pegRevision);\n    parameters.add(\"--revision\");\n    parameters.add(startRevision + \":\" + endRevision);\n\n    CommandUtil.put(parameters, stopOnCopy, \"--stop-on-copy\");\n    CommandUtil.put(parameters, discoverChangedPaths, \"--verbose\");\n    CommandUtil.put(parameters, includeMergedRevisions, \"--use-merge-history\");\n    if (limit > 0) {\n      parameters.add(\"--limit\");\n      parameters.add(String.valueOf(limit));\n    }\n    parameters.add(\"--xml\");\n\n    return parameters;\n  }","id":44308,"modified_method":"private static List<String> prepareCommand(@NotNull SvnTarget target,\n                                             @NotNull SVNRevision startRevision,\n                                             @NotNull SVNRevision endRevision,\n                                             boolean stopOnCopy, boolean discoverChangedPaths, boolean includeMergedRevisions, long limit) {\n    List<String> parameters = new ArrayList<String>();\n\n    CommandUtil.put(parameters, target);\n    parameters.add(\"--revision\");\n    parameters.add(startRevision + \":\" + endRevision);\n\n    CommandUtil.put(parameters, stopOnCopy, \"--stop-on-copy\");\n    CommandUtil.put(parameters, discoverChangedPaths, \"--verbose\");\n    CommandUtil.put(parameters, includeMergedRevisions, \"--use-merge-history\");\n    if (limit > 0) {\n      parameters.add(\"--limit\");\n      parameters.add(String.valueOf(limit));\n    }\n    parameters.add(\"--xml\");\n\n    return parameters;\n  }","commit_id":"4b02b95c76661960e622870f54ed22d784f11660","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doLog(final boolean includeMerged, final SVNRevision truncateTo, final int max) throws VcsException {\n      myClient.doLog(myIoFile, myEndRevision, truncateTo == null ? SVNRevision.create(1L) : truncateTo,\n                     SVNRevision.UNDEFINED, false, false, includeMerged, max, null,\n                     new ISVNLogEntryHandler() {\n                       public void handleLogEntry(SVNLogEntry logEntry) {\n                         if (SVNRevision.UNDEFINED.getNumber() == logEntry.getRevision()) {\n                           return;\n                         }\n\n                         if (myProgress != null) {\n                           myProgress.checkCanceled();\n                           myProgress.setText2(SvnBundle.message(\"progress.text2.revision.processed\", logEntry.getRevision()));\n                         }\n                         myResult.setRevision(logEntry.getRevision(), new SvnFileRevision(myVcs, SVNRevision.UNDEFINED, logEntry, myUrl, \"\", myCharset));\n                       }\n                     });\n    }","id":44309,"modified_method":"private void doLog(final boolean includeMerged, final SVNRevision truncateTo, final int max) throws VcsException {\n      myClient.doLog(SvnTarget.fromFile(myIoFile), myEndRevision, truncateTo == null ? SVNRevision.create(1L) : truncateTo,\n                     false, false, includeMerged, max, null,\n                     new ISVNLogEntryHandler() {\n                       public void handleLogEntry(SVNLogEntry logEntry) {\n                         if (SVNRevision.UNDEFINED.getNumber() == logEntry.getRevision()) {\n                           return;\n                         }\n\n                         if (myProgress != null) {\n                           myProgress.checkCanceled();\n                           myProgress.setText2(SvnBundle.message(\"progress.text2.revision.processed\", logEntry.getRevision()));\n                         }\n                         myResult.setRevision(logEntry.getRevision(), new SvnFileRevision(myVcs, SVNRevision.UNDEFINED, logEntry, myUrl, \"\", myCharset));\n                       }\n                     });\n    }","commit_id":"4b02b95c76661960e622870f54ed22d784f11660","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    protected void load() {\n      String relativeUrl = myUrl;\n      final SVNURL repoRootURL = myInfo.getRepositoryRootURL();\n\n      final String root = repoRootURL.toString();\n      if (myUrl != null && myUrl.startsWith(root)) {\n        relativeUrl = myUrl.substring(root.length());\n      }\n      if (myPI != null) {\n        myPI.setText2(SvnBundle.message(\"progress.text2.changes.establishing.connection\", myUrl));\n      }\n      final SVNRevision pegRevision = myInfo.getRevision();\n      try {\n        myVcs.getFactory(myFile.getIOFile()).createHistoryClient().doLog(\n          myFile.getIOFile(),\n          myFrom == null ? SVNRevision.HEAD : myFrom,\n          myTo == null ? SVNRevision.create(1) : myTo, myPeg,\n          false, true, myShowMergeSources && mySupport15, myLimit + 1, null,\n          new MyLogEntryHandler(myVcs, myUrl, pegRevision, relativeUrl,\n                                createConsumerAdapter(myConsumer),\n                                repoRootURL, myFile.getCharset()));\n      }\n      catch (SVNCancelException e) {\n        //\n      }\n      catch (SVNException e) {\n        myException = new VcsException(e);\n      }\n      catch (VcsException e) {\n        myException = e;\n      }\n    }","id":44310,"modified_method":"@Override\n    protected void load() {\n      String relativeUrl = myUrl;\n      final SVNURL repoRootURL = myInfo.getRepositoryRootURL();\n\n      final String root = repoRootURL.toString();\n      if (myUrl != null && myUrl.startsWith(root)) {\n        relativeUrl = myUrl.substring(root.length());\n      }\n      if (myPI != null) {\n        myPI.setText2(SvnBundle.message(\"progress.text2.changes.establishing.connection\", myUrl));\n      }\n      final SVNRevision pegRevision = myInfo.getRevision();\n      final SvnTarget target = SvnTarget.fromFile(myFile.getIOFile(), myPeg);\n      try {\n        myVcs.getFactory(target).createHistoryClient().doLog(\n          target,\n          myFrom == null ? SVNRevision.HEAD : myFrom,\n          myTo == null ? SVNRevision.create(1) : myTo,\n          false, true, myShowMergeSources && mySupport15, myLimit + 1, null,\n          new MyLogEntryHandler(myVcs, myUrl, pegRevision, relativeUrl,\n                                createConsumerAdapter(myConsumer),\n                                repoRootURL, myFile.getCharset()));\n      }\n      catch (SVNCancelException e) {\n        //\n      }\n      catch (SVNException e) {\n        myException = new VcsException(e);\n      }\n      catch (VcsException e) {\n        myException = e;\n      }\n    }","commit_id":"4b02b95c76661960e622870f54ed22d784f11660","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void doLog(@NotNull File path,\n                    @NotNull SVNRevision startRevision,\n                    @NotNull SVNRevision endRevision,\n                    @Nullable SVNRevision pegRevision,\n                    boolean stopOnCopy,\n                    boolean discoverChangedPaths,\n                    boolean includeMergedRevisions,\n                    long limit,\n                    @Nullable String[] revisionProperties,\n                    @Nullable ISVNLogEntryHandler handler) throws VcsException {\n    try {\n      // TODO: a bug noticed when testing: we should pass \"limit + 1\" to get \"limit\" rows\n      SVNLogClient client = myVcs.createLogClient();\n\n      client.doLog(new File[]{path}, startRevision, endRevision, pegRevision, stopOnCopy, discoverChangedPaths, includeMergedRevisions,\n                   limit, revisionProperties, handler);\n    }\n    catch (SVNException e) {\n      throw new VcsException(e);\n    }\n  }","id":44311,"modified_method":"@Override\n  public void doLog(@NotNull SvnTarget target,\n                    @NotNull SVNRevision startRevision,\n                    @NotNull SVNRevision endRevision,\n                    boolean stopOnCopy,\n                    boolean discoverChangedPaths,\n                    boolean includeMergedRevisions,\n                    long limit,\n                    @Nullable String[] revisionProperties,\n                    @Nullable ISVNLogEntryHandler handler) throws VcsException {\n    try {\n      // TODO: a bug noticed when testing: we should pass \"limit + 1\" to get \"limit\" rows\n      SVNLogClient client = myVcs.createLogClient();\n\n      if (target.isFile()) {\n        client.doLog(new File[]{target.getFile()}, startRevision, endRevision, target.getPegRevision(), stopOnCopy, discoverChangedPaths,\n                     includeMergedRevisions, limit, revisionProperties, handler);\n      }\n      else {\n        client.doLog(target.getURL(), ArrayUtil.EMPTY_STRING_ARRAY, target.getPegRevision(), startRevision, endRevision, stopOnCopy,\n                     discoverChangedPaths, includeMergedRevisions, limit, revisionProperties, handler);\n      }\n    }\n    catch (SVNException e) {\n      throw new VcsException(e);\n    }\n  }","commit_id":"4b02b95c76661960e622870f54ed22d784f11660","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Pair<SvnChangeList, FilePath> getOneList(final VirtualFile file, VcsRevisionNumber number) throws VcsException {\n    final RootUrlInfo rootUrlInfo = myVcs.getSvnFileUrlMapping().getWcRootForFilePath(new File(file.getPath()));\n    if (rootUrlInfo == null) return null;\n    final VirtualFile root = rootUrlInfo.getVirtualFile();\n    final SvnRepositoryLocation svnRootLocation = (SvnRepositoryLocation)getLocationFor(new FilePathImpl(root));\n    if (svnRootLocation == null) return null;\n    final String url = svnRootLocation.getURL();\n    final long revision;\n    try {\n      revision = Long.parseLong(number.asString());\n    } catch (NumberFormatException e) {\n      throw new VcsException(e);\n    }\n\n    final SvnChangeList[] result = new SvnChangeList[1];\n    final SVNLogClient logger;\n    final SVNRevision revisionBefore;\n    final SVNURL repositoryUrl;\n    final SVNURL svnurl;\n    final SVNInfo targetInfo;\n    try {\n      logger = myVcs.createLogClient();\n      revisionBefore = SVNRevision.create(revision);\n\n      svnurl = SVNURL.parseURIEncoded(url);\n      final SVNInfo info = myVcs.getInfo(svnurl, SVNRevision.HEAD);\n      targetInfo = myVcs.getInfo(new File(file.getPath()));\n      if (info == null) {\n        throw new VcsException(\"Can not get repository URL\");\n      }\n      repositoryUrl = info.getRepositoryRootURL();\n    }\n    catch (SVNException e) {\n      LOG.info(e);\n      throw new VcsException(e);\n    }\n\n    tryExactHit(svnRootLocation, result, logger, revisionBefore, repositoryUrl, svnurl);\n    if (result[0] == null) {\n      tryByRoot(result, logger, revisionBefore, repositoryUrl);\n      if (result[0] == null) {\n        FilePath path = tryStepByStep(svnRootLocation, result, logger, revisionBefore, targetInfo, svnurl);\n        path = path == null ? new FilePathImpl(file) : path;\n        // and pass & take rename context there\n        return new Pair<SvnChangeList, FilePath>(result[0], path);\n      }\n    }\n    if (result[0].getChanges().size() == 1) {\n      final Collection<Change> changes = result[0].getChanges();\n      final Change change = changes.iterator().next();\n      final ContentRevision afterRevision = change.getAfterRevision();\n      if (afterRevision != null) {\n        return new Pair<SvnChangeList, FilePath>(result[0], afterRevision.getFile());\n      } else {\n        return new Pair<SvnChangeList, FilePath>(result[0], new FilePathImpl(file));\n      }\n    }\n    String relativePath = SVNPathUtil.getRelativePath(targetInfo.getRepositoryRootURL().toString(), targetInfo.getURL().toString());\n    relativePath = relativePath.startsWith(\"/\") ? relativePath : \"/\" + relativePath;\n    final Change targetChange = result[0].getByPath(relativePath);\n    if (targetChange == null) {\n      FilePath path = tryStepByStep(svnRootLocation, result, logger, revisionBefore, targetInfo, svnurl);\n      path = path == null ? new FilePathImpl(file) : path;\n      // and pass & take rename context there\n      return new Pair<SvnChangeList, FilePath>(result[0], path);\n    }\n    return new Pair<SvnChangeList, FilePath>(result[0], new FilePathImpl(file));\n  }","id":44312,"modified_method":"@Override\n  public Pair<SvnChangeList, FilePath> getOneList(final VirtualFile file, VcsRevisionNumber number) throws VcsException {\n    final RootUrlInfo rootUrlInfo = myVcs.getSvnFileUrlMapping().getWcRootForFilePath(new File(file.getPath()));\n    if (rootUrlInfo == null) return null;\n    final VirtualFile root = rootUrlInfo.getVirtualFile();\n    final SvnRepositoryLocation svnRootLocation = (SvnRepositoryLocation)getLocationFor(new FilePathImpl(root));\n    if (svnRootLocation == null) return null;\n    final String url = svnRootLocation.getURL();\n    final long revision;\n    try {\n      revision = Long.parseLong(number.asString());\n    } catch (NumberFormatException e) {\n      throw new VcsException(e);\n    }\n\n    final SvnChangeList[] result = new SvnChangeList[1];\n    final SVNLogClient logger;\n    final SVNRevision revisionBefore;\n    final SVNURL repositoryUrl;\n    final SVNURL svnurl;\n    final SVNInfo targetInfo;\n    try {\n      logger = myVcs.createLogClient();\n      revisionBefore = SVNRevision.create(revision);\n\n      svnurl = SVNURL.parseURIEncoded(url);\n      final SVNInfo info = myVcs.getInfo(svnurl, SVNRevision.HEAD);\n      targetInfo = myVcs.getInfo(new File(file.getPath()));\n      if (info == null) {\n        throw new VcsException(\"Can not get repository URL\");\n      }\n      repositoryUrl = info.getRepositoryRootURL();\n    }\n    catch (SVNException e) {\n      LOG.info(e);\n      throw new VcsException(e);\n    }\n\n    FilePath filePath = VcsUtil.getFilePath(file);\n\n    if (!tryExactHit(svnRootLocation, result, logger, revisionBefore, repositoryUrl, svnurl) &&\n        !tryByRoot(result, logger, revisionBefore, repositoryUrl)) {\n      filePath = getOneListStepByStep(svnRootLocation, result, logger, revisionBefore, svnurl, targetInfo, filePath);\n    }\n    else {\n      Change change = ContainerUtil.getFirstItem(result[0].getChanges());\n      if (change != null) {\n        final ContentRevision afterRevision = change.getAfterRevision();\n\n        filePath = afterRevision != null ? afterRevision.getFile() : filePath;\n      }\n      else {\n        String relativePath = SVNPathUtil.getRelativePath(targetInfo.getRepositoryRootURL().toString(), targetInfo.getURL().toString());\n        relativePath = relativePath.startsWith(\"/\") ? relativePath : \"/\" + relativePath;\n        final Change targetChange = result[0].getByPath(relativePath);\n\n        filePath = targetChange == null\n                   ? getOneListStepByStep(svnRootLocation, result, logger, revisionBefore, svnurl, targetInfo, filePath)\n                   : filePath;\n      }\n    }\n\n    return Pair.create(result[0], filePath);\n  }","commit_id":"0c9d76ee0915eaf9fe74434589fe458f13609989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void tryExactHit(final SvnRepositoryLocation location,\n                           final SvnChangeList[] result,\n                           SVNLogClient logger,\n                           SVNRevision revisionBefore,\n                           final SVNURL repositoryUrl, SVNURL svnurl) throws VcsException {\n    try {\n      // TODO: Implement this with command line\n      logger.doLog(svnurl, null, SVNRevision.UNDEFINED, revisionBefore, revisionBefore,\n                   false, true, false, 1, null,\n                   new ISVNLogEntryHandler() {\n                     public void handleLogEntry(SVNLogEntry logEntry) {\n                       if (myProject.isDisposed()) throw new ProcessCanceledException();\n                       if (logEntry.getDate() == null) {\n                         // do not add lists without info - this situation is possible for lists where there are paths that user has no rights to observe\n                         return;\n                       }\n                       result[0] = new SvnChangeList(myVcs, location, logEntry, repositoryUrl.toString());\n                     }\n                   });\n    }\n    catch (SVNException e) {\n      LOG.info(e);\n      if (SVNErrorCode.FS_CATEGORY == e.getErrorMessage().getErrorCode().getCategory()) {\n        // pass to step by step looking for revision\n        return;\n      }\n      throw new VcsException(e);\n    }\n  }","id":44313,"modified_method":"private boolean tryExactHit(final SvnRepositoryLocation location,\n                              final SvnChangeList[] result,\n                           SVNLogClient logger,\n                           SVNRevision revisionBefore,\n                           final SVNURL repositoryUrl, SVNURL svnurl) throws VcsException {\n\n    ISVNLogEntryHandler handler = new ISVNLogEntryHandler() {\n      public void handleLogEntry(SVNLogEntry logEntry) {\n        if (myProject.isDisposed()) throw new ProcessCanceledException();\n        if (logEntry.getDate() == null) {\n          // do not add lists without info - this situation is possible for lists where there are paths that user has no rights to observe\n          return;\n        }\n        result[0] = new SvnChangeList(myVcs, location, logEntry, repositoryUrl.toString());\n      }\n    };\n    try {\n      // TODO: Implement this with command line\n      logger.doLog(svnurl, null, SVNRevision.UNDEFINED, revisionBefore, revisionBefore, false, true, false, 1, null, handler);\n    }\n    catch (SVNException e) {\n      LOG.info(e);\n      if (SVNErrorCode.FS_CATEGORY != e.getErrorMessage().getErrorCode().getCategory()) {\n        throw new VcsException(e);\n      }\n    }\n    return result[0] != null;\n  }","commit_id":"0c9d76ee0915eaf9fe74434589fe458f13609989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void tryByRoot(SvnChangeList[] result, SVNLogClient logger, SVNRevision revisionBefore, SVNURL repositoryUrl) throws VcsException {\n    final boolean authorized = SvnAuthenticationNotifier.passiveValidation(myProject, repositoryUrl);\n    if (! authorized) return;\n    tryExactHit(new SvnRepositoryLocation(repositoryUrl.toString()), result, logger, revisionBefore, repositoryUrl, repositoryUrl);\n  }","id":44314,"modified_method":"private boolean tryByRoot(SvnChangeList[] result, SVNLogClient logger, SVNRevision revisionBefore, SVNURL repositoryUrl)\n    throws VcsException {\n    final boolean authorized = SvnAuthenticationNotifier.passiveValidation(myProject, repositoryUrl);\n\n    return authorized &&\n           tryExactHit(new SvnRepositoryLocation(repositoryUrl.toString()), result, logger, revisionBefore, repositoryUrl, repositoryUrl);\n  }","commit_id":"0c9d76ee0915eaf9fe74434589fe458f13609989","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void getCommittedChangesWithMergedRevisons(final ChangeBrowserSettings settings,\n                                                                   final RepositoryLocation location, final int maxCount,\n                                                                   final PairConsumer<SvnChangeList, TreeStructureNode<SVNLogEntry>> finalConsumer)\n    throws VcsException {\n    final SvnRepositoryLocation svnLocation = (SvnRepositoryLocation) location;\n    final String repositoryRoot = getRepositoryRoot(svnLocation);\n\n    final MergeTrackerProxy proxy = new MergeTrackerProxy(new Consumer<TreeStructureNode<SVNLogEntry>>() {\n      public void consume(TreeStructureNode<SVNLogEntry> node) {\n        finalConsumer.consume(new SvnChangeList(myVcs, svnLocation, node.getMe(), repositoryRoot), node);\n      }\n    });\n    final SvnMergeSourceTracker mergeSourceTracker = new SvnMergeSourceTracker(new ThrowableConsumer<Pair<SVNLogEntry, Integer>, SVNException>() {\n      public void consume(Pair<SVNLogEntry, Integer> svnLogEntryIntegerPair) throws SVNException {\n        proxy.consume(svnLogEntryIntegerPair);\n      }\n    });\n\n    getCommittedChangesImpl(settings, svnLocation.getURL(), new String[]{\"\"}, maxCount, new Consumer<SVNLogEntry>() {\n      public void consume(final SVNLogEntry svnLogEntry) {\n        try {\n          mergeSourceTracker.consume(svnLogEntry);\n        }\n        catch (SVNException e) {\n          throw new RuntimeException(e);\n          // will not occur actually but anyway never eat them\n        }\n      }\n    }, true, false);\n\n    proxy.finish();\n  }","id":44315,"modified_method":"public void getCommittedChangesWithMergedRevisons(final ChangeBrowserSettings settings,\n                                                                   final RepositoryLocation location, final int maxCount,\n                                                                   final PairConsumer<SvnChangeList, TreeStructureNode<SVNLogEntry>> finalConsumer)\n    throws VcsException {\n    final SvnRepositoryLocation svnLocation = (SvnRepositoryLocation) location;\n    final String repositoryRoot = getRepositoryRoot(svnLocation);\n\n    final MergeTrackerProxy proxy = new MergeTrackerProxy(new Consumer<TreeStructureNode<SVNLogEntry>>() {\n      public void consume(TreeStructureNode<SVNLogEntry> node) {\n        finalConsumer.consume(new SvnChangeList(myVcs, svnLocation, node.getMe(), repositoryRoot), node);\n      }\n    });\n    final SvnMergeSourceTracker mergeSourceTracker = new SvnMergeSourceTracker(new ThrowableConsumer<Pair<SVNLogEntry, Integer>, SVNException>() {\n      public void consume(Pair<SVNLogEntry, Integer> svnLogEntryIntegerPair) throws SVNException {\n        proxy.consume(svnLogEntryIntegerPair);\n      }\n    });\n\n    getCommittedChangesImpl(settings, svnLocation, new String[]{\"\"}, maxCount, new Consumer<SVNLogEntry>() {\n      public void consume(final SVNLogEntry svnLogEntry) {\n        try {\n          mergeSourceTracker.consume(svnLogEntry);\n        }\n        catch (SVNException e) {\n          throw new RuntimeException(e);\n          // will not occur actually but anyway never eat them\n        }\n      }\n    }, true, false);\n\n    proxy.finish();\n  }","commit_id":"0a1c3bbf1e7f4cf0ba04c3b0aa7e8489a764ca8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void loadCommittedChanges(ChangeBrowserSettings settings,\n                                   RepositoryLocation location,\n                                   int maxCount,\n                                   final AsynchConsumer<CommittedChangeList> consumer)\n    throws VcsException {\n    try {\n      final SvnRepositoryLocation svnLocation = (SvnRepositoryLocation) location;\n      final String repositoryRoot = getRepositoryRoot(svnLocation);\n      final ChangeBrowserSettings.Filter filter = settings.createFilter();\n\n      getCommittedChangesImpl(settings, svnLocation.getURL(), new String[]{\"\"}, maxCount, new Consumer<SVNLogEntry>() {\n        public void consume(final SVNLogEntry svnLogEntry) {\n          final SvnChangeList cl = new SvnChangeList(myVcs, svnLocation, svnLogEntry, repositoryRoot);\n          if (filter.accepts(cl)) {\n            consumer.consume(cl);\n          }\n        }\n      }, false, true);\n    }\n    finally {\n      consumer.finished();\n    }\n  }","id":44316,"modified_method":"public void loadCommittedChanges(ChangeBrowserSettings settings,\n                                   RepositoryLocation location,\n                                   int maxCount,\n                                   final AsynchConsumer<CommittedChangeList> consumer)\n    throws VcsException {\n    try {\n      final SvnRepositoryLocation svnLocation = (SvnRepositoryLocation) location;\n      final String repositoryRoot = getRepositoryRoot(svnLocation);\n      final ChangeBrowserSettings.Filter filter = settings.createFilter();\n\n      getCommittedChangesImpl(settings, svnLocation, new String[]{\"\"}, maxCount, new Consumer<SVNLogEntry>() {\n        public void consume(final SVNLogEntry svnLogEntry) {\n          final SvnChangeList cl = new SvnChangeList(myVcs, svnLocation, svnLogEntry, repositoryRoot);\n          if (filter.accepts(cl)) {\n            consumer.consume(cl);\n          }\n        }\n      }, false, true);\n    }\n    finally {\n      consumer.finished();\n    }\n  }","commit_id":"0a1c3bbf1e7f4cf0ba04c3b0aa7e8489a764ca8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Pair<SvnChangeList, FilePath> getOneList(final VirtualFile file, VcsRevisionNumber number) throws VcsException {\n    final RootUrlInfo rootUrlInfo = myVcs.getSvnFileUrlMapping().getWcRootForFilePath(new File(file.getPath()));\n    if (rootUrlInfo == null) return null;\n    final VirtualFile root = rootUrlInfo.getVirtualFile();\n    if (root == null) return null;\n    final SvnRepositoryLocation svnRootLocation = (SvnRepositoryLocation)getLocationFor(new FilePathImpl(root));\n    if (svnRootLocation == null) return null;\n    final String url = svnRootLocation.getURL();\n    final long revision;\n    try {\n      revision = Long.parseLong(number.asString());\n    } catch (NumberFormatException e) {\n      throw new VcsException(e);\n    }\n\n    final SvnChangeList[] result = new SvnChangeList[1];\n    final SVNLogClient logger;\n    final SVNRevision revisionBefore;\n    final SVNURL repositoryUrl;\n    final SVNURL svnurl;\n    final SVNInfo targetInfo;\n    try {\n      logger = myVcs.createLogClient();\n      revisionBefore = SVNRevision.create(revision);\n\n      svnurl = SVNURL.parseURIEncoded(url);\n      final SVNInfo info = myVcs.getInfo(svnurl, SVNRevision.HEAD);\n      targetInfo = myVcs.getInfo(new File(file.getPath()));\n      if (info == null) {\n        throw new VcsException(\"Can not get repository URL\");\n      }\n      repositoryUrl = info.getRepositoryRootURL();\n    }\n    catch (SVNException e) {\n      LOG.info(e);\n      throw new VcsException(e);\n    }\n\n    tryExactHit(svnRootLocation, result, logger, revisionBefore, repositoryUrl, svnurl);\n    if (result[0] == null) {\n      tryByRoot(result, logger, revisionBefore, repositoryUrl);\n      if (result[0] == null) {\n        FilePath path = tryStepByStep(svnRootLocation, result, logger, revisionBefore, targetInfo, svnurl);\n        path = path == null ? new FilePathImpl(file) : path;\n        // and pass & take rename context there\n        return new Pair<SvnChangeList, FilePath>(result[0], path);\n      }\n    }\n    if (result[0].getChanges().size() == 1) {\n      final Collection<Change> changes = result[0].getChanges();\n      final Change change = changes.iterator().next();\n      final ContentRevision afterRevision = change.getAfterRevision();\n      if (afterRevision != null) {\n        return new Pair<SvnChangeList, FilePath>(result[0], afterRevision.getFile());\n      } else {\n        return new Pair<SvnChangeList, FilePath>(result[0], new FilePathImpl(file));\n      }\n    }\n    String relativePath = SVNPathUtil.getRelativePath(targetInfo.getRepositoryRootURL().toString(), targetInfo.getURL().toString());\n    relativePath = relativePath.startsWith(\"/\") ? relativePath : \"/\" + relativePath;\n    final Change targetChange = result[0].getByPath(relativePath);\n    if (targetChange == null) {\n      FilePath path = tryStepByStep(svnRootLocation, result, logger, revisionBefore, targetInfo, svnurl);\n      path = path == null ? new FilePathImpl(file) : path;\n      // and pass & take rename context there\n      return new Pair<SvnChangeList, FilePath>(result[0], path);\n    }\n    return new Pair<SvnChangeList, FilePath>(result[0], new FilePathImpl(file));\n  }","id":44317,"modified_method":"@Override\n  public Pair<SvnChangeList, FilePath> getOneList(final VirtualFile file, VcsRevisionNumber number) throws VcsException {\n    final RootUrlInfo rootUrlInfo = myVcs.getSvnFileUrlMapping().getWcRootForFilePath(new File(file.getPath()));\n    if (rootUrlInfo == null) return null;\n    final VirtualFile root = rootUrlInfo.getVirtualFile();\n    final SvnRepositoryLocation svnRootLocation = (SvnRepositoryLocation)getLocationFor(new FilePathImpl(root));\n    if (svnRootLocation == null) return null;\n    final String url = svnRootLocation.getURL();\n    final long revision;\n    try {\n      revision = Long.parseLong(number.asString());\n    } catch (NumberFormatException e) {\n      throw new VcsException(e);\n    }\n\n    final SvnChangeList[] result = new SvnChangeList[1];\n    final SVNLogClient logger;\n    final SVNRevision revisionBefore;\n    final SVNURL repositoryUrl;\n    final SVNURL svnurl;\n    final SVNInfo targetInfo;\n    try {\n      logger = myVcs.createLogClient();\n      revisionBefore = SVNRevision.create(revision);\n\n      svnurl = SVNURL.parseURIEncoded(url);\n      final SVNInfo info = myVcs.getInfo(svnurl, SVNRevision.HEAD);\n      targetInfo = myVcs.getInfo(new File(file.getPath()));\n      if (info == null) {\n        throw new VcsException(\"Can not get repository URL\");\n      }\n      repositoryUrl = info.getRepositoryRootURL();\n    }\n    catch (SVNException e) {\n      LOG.info(e);\n      throw new VcsException(e);\n    }\n\n    tryExactHit(svnRootLocation, result, logger, revisionBefore, repositoryUrl, svnurl);\n    if (result[0] == null) {\n      tryByRoot(result, logger, revisionBefore, repositoryUrl);\n      if (result[0] == null) {\n        FilePath path = tryStepByStep(svnRootLocation, result, logger, revisionBefore, targetInfo, svnurl);\n        path = path == null ? new FilePathImpl(file) : path;\n        // and pass & take rename context there\n        return new Pair<SvnChangeList, FilePath>(result[0], path);\n      }\n    }\n    if (result[0].getChanges().size() == 1) {\n      final Collection<Change> changes = result[0].getChanges();\n      final Change change = changes.iterator().next();\n      final ContentRevision afterRevision = change.getAfterRevision();\n      if (afterRevision != null) {\n        return new Pair<SvnChangeList, FilePath>(result[0], afterRevision.getFile());\n      } else {\n        return new Pair<SvnChangeList, FilePath>(result[0], new FilePathImpl(file));\n      }\n    }\n    String relativePath = SVNPathUtil.getRelativePath(targetInfo.getRepositoryRootURL().toString(), targetInfo.getURL().toString());\n    relativePath = relativePath.startsWith(\"/\") ? relativePath : \"/\" + relativePath;\n    final Change targetChange = result[0].getByPath(relativePath);\n    if (targetChange == null) {\n      FilePath path = tryStepByStep(svnRootLocation, result, logger, revisionBefore, targetInfo, svnurl);\n      path = path == null ? new FilePathImpl(file) : path;\n      // and pass & take rename context there\n      return new Pair<SvnChangeList, FilePath>(result[0], path);\n    }\n    return new Pair<SvnChangeList, FilePath>(result[0], new FilePathImpl(file));\n  }","commit_id":"0a1c3bbf1e7f4cf0ba04c3b0aa7e8489a764ca8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<SvnChangeList> getCommittedChanges(ChangeBrowserSettings settings, final RepositoryLocation location, final int maxCount) throws VcsException {\n    final SvnRepositoryLocation svnLocation = (SvnRepositoryLocation) location;\n    final ArrayList<SvnChangeList> result = new ArrayList<SvnChangeList>();\n    final String repositoryRoot = getRepositoryRoot(svnLocation);\n\n    getCommittedChangesImpl(settings, svnLocation.getURL(), new String[]{\"\"}, maxCount, new Consumer<SVNLogEntry>() {\n      public void consume(final SVNLogEntry svnLogEntry) {\n        result.add(new SvnChangeList(myVcs, svnLocation, svnLogEntry, repositoryRoot));\n      }\n    }, false, true);\n    settings.filterChanges(result);\n    return result;\n  }","id":44318,"modified_method":"public List<SvnChangeList> getCommittedChanges(ChangeBrowserSettings settings, final RepositoryLocation location, final int maxCount) throws VcsException {\n    final SvnRepositoryLocation svnLocation = (SvnRepositoryLocation) location;\n    final ArrayList<SvnChangeList> result = new ArrayList<SvnChangeList>();\n    final String repositoryRoot = getRepositoryRoot(svnLocation);\n\n    getCommittedChangesImpl(settings, svnLocation, new String[]{\"\"}, maxCount, new Consumer<SVNLogEntry>() {\n      public void consume(final SVNLogEntry svnLogEntry) {\n        result.add(new SvnChangeList(myVcs, svnLocation, svnLogEntry, repositoryRoot));\n      }\n    }, false, true);\n    settings.filterChanges(result);\n    return result;\n  }","commit_id":"0a1c3bbf1e7f4cf0ba04c3b0aa7e8489a764ca8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void getCommittedChangesImpl(ChangeBrowserSettings settings, final String url, final String[] filterUrls,\n                                       final int maxCount, final Consumer<SVNLogEntry> resultConsumer, final boolean includeMergedRevisions,\n                                       final boolean filterOutByDate) throws VcsException {\n    setCollectingChangesProgress(url);\n\n    try {\n      SVNLogClient logger = myVcs.createLogClient();\n\n      final String author = settings.getUserFilter();\n      final Date dateFrom = settings.getDateAfterFilter();\n      final Long changeFrom = settings.getChangeAfterFilter();\n      final Date dateTo = settings.getDateBeforeFilter();\n      final Long changeTo = settings.getChangeBeforeFilter();\n\n      final SVNRevision revisionBefore;\n      if (dateTo != null) {\n        revisionBefore = SVNRevision.create(dateTo);\n      }\n      else if (changeTo != null) {\n        revisionBefore = SVNRevision.create(changeTo.longValue());\n      }\n      else {\n        // TODO: Implement this with command line\n        SVNRepository repository = null;\n        final long revision;\n        try {\n          repository = myVcs.createRepository(url);\n          revision = repository.getLatestRevision();\n        } finally {\n          if (repository != null) {\n            repository.closeSession();\n          }\n        }\n        revisionBefore = SVNRevision.create(revision);\n      }\n      final SVNRevision revisionAfter;\n      if (dateFrom != null) {\n        revisionAfter = SVNRevision.create(dateFrom);\n      }\n      else if (changeFrom != null) {\n        revisionAfter = SVNRevision.create(changeFrom.longValue());\n      }\n      else {\n        revisionAfter = SVNRevision.create(1);\n      }\n\n      // TODO: Implement this with command line\n      logger.doLog(SVNURL.parseURIEncoded(url), filterUrls, revisionBefore, revisionBefore, revisionAfter,\n                   settings.STOP_ON_COPY, true, includeMergedRevisions, maxCount, null,\n                   new ISVNLogEntryHandler() {\n                     public void handleLogEntry(SVNLogEntry logEntry) {\n                       if (myProject.isDisposed()) throw new ProcessCanceledException();\n\n                       ProgressManager.progress2(SvnBundle.message(\"progress.text2.processing.revision\", logEntry.getRevision()));\n                       if (filterOutByDate && logEntry.getDate() == null) {\n                         // do not add lists without info - this situation is possible for lists where there are paths that user has no rights to observe\n                         return;\n                       }\n                       if (author == null || author.equalsIgnoreCase(logEntry.getAuthor())) {\n                         resultConsumer.consume(logEntry);\n                       }\n                     }\n                   });\n    }\n    catch (SVNException e) {\n      throw new VcsException(e);\n    }\n  }","id":44319,"modified_method":"private void getCommittedChangesImpl(ChangeBrowserSettings settings, final SvnRepositoryLocation location, final String[] filterUrls,\n                                       final int maxCount, final Consumer<SVNLogEntry> resultConsumer, final boolean includeMergedRevisions,\n                                       final boolean filterOutByDate) throws VcsException {\n    setCollectingChangesProgress(location);\n\n    try {\n      final String author = settings.getUserFilter();\n      final Date dateFrom = settings.getDateAfterFilter();\n      final Long changeFrom = settings.getChangeAfterFilter();\n      final Date dateTo = settings.getDateBeforeFilter();\n      final Long changeTo = settings.getChangeBeforeFilter();\n\n      final SVNRevision revisionBefore = createRevisionBefore(location, dateTo, changeTo);\n      final SVNRevision revisionAfter = createRevisionAfter(dateFrom, changeFrom);\n\n      // TODO: Implement this with command line\n      SVNLogClient logger = myVcs.createLogClient();\n      logger.doLog(location.toSvnUrl(), filterUrls, revisionBefore, revisionBefore, revisionAfter, settings.STOP_ON_COPY, true,\n                   includeMergedRevisions, maxCount, null, createLogHandler(resultConsumer, filterOutByDate, author));\n    }\n    catch (SVNException e) {\n      throw new VcsException(e);\n    }\n  }","commit_id":"0a1c3bbf1e7f4cf0ba04c3b0aa7e8489a764ca8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public long getDeletionRevision() {\n    if (! detectStartRevision()) return -1;\n\n    final Ref<Long> latest = new Ref<Long>(myStartNumber);\n    SVNRepository repository = null;\n    try {\n      repository = myVcs.createRepository(myUrl.toString());\n      final SVNURL repRoot = repository.getRepositoryRoot(true);\n      if (repRoot != null) {\n        if (myEndNumber == -1) {\n          myEndNumber = repository.getLatestRevision();\n        }\n\n        final SVNURL existingParent = getExistingParent(myUrl, repository, repRoot.toString().length());\n        if (existingParent == null) {\n          return myStartNumber;\n        }\n\n        final String urlRelativeString = myUrl.toString().substring(repRoot.toString().length());\n        final SVNRevision startRevision = SVNRevision.create(myStartNumber);\n        myVcs.createLogClient().doLog(existingParent, new String[]{\"\"}, startRevision, startRevision, SVNRevision.HEAD, false, true, 0,\n                       new ISVNLogEntryHandler() {\n                         public void handleLogEntry(final SVNLogEntry logEntry) throws SVNException {\n                           final Map changedPaths = logEntry.getChangedPaths();\n                           for (Object o : changedPaths.values()) {\n                             final SVNLogEntryPath path = (SVNLogEntryPath) o;\n                             if ((path.getType() == 'D') && (urlRelativeString.equals(path.getPath()))) {\n                               latest.set(logEntry.getRevision());\n                               throw new SVNException(SVNErrorMessage.UNKNOWN_ERROR_MESSAGE);\n                             }\n                           }\n                         }\n                       });\n      }\n    }\n    catch (SVNException e) {\n      //\n    } finally {\n      if (repository != null) {\n        repository.closeSession();\n      }\n    }\n\n    return latest.get().longValue();\n  }","id":44320,"modified_method":"public long getDeletionRevision() {\n    if (! detectStartRevision()) return -1;\n\n    final Ref<Long> latest = new Ref<Long>(myStartNumber);\n    SVNRepository repository = null;\n    try {\n      repository = myVcs.createRepository(myUrl.toString());\n      final SVNURL repRoot = repository.getRepositoryRoot(true);\n      if (repRoot != null) {\n        if (myEndNumber == -1) {\n          myEndNumber = repository.getLatestRevision();\n        }\n\n        final SVNURL existingParent = getExistingParent(myUrl, repository, repRoot.toString().length());\n        if (existingParent == null) {\n          return myStartNumber;\n        }\n\n        final String urlRelativeString = myUrl.toString().substring(repRoot.toString().length());\n        final SVNRevision startRevision = SVNRevision.create(myStartNumber);\n        SvnTarget target = SvnTarget.fromURL(existingParent, startRevision);\n        myVcs.getFactory(target).createHistoryClient()\n          .doLog(target, startRevision, SVNRevision.HEAD, false, true, false, 0, null, createHandler(latest, urlRelativeString));\n      }\n    }\n    catch (SVNException e) {\n      LOG.info(e);\n    }\n    catch (VcsException e) {\n      LOG.info(e);\n    }\n    finally {\n      if (repository != null) {\n        repository.closeSession();\n      }\n    }\n\n    return latest.get().longValue();\n  }","commit_id":"482733a382071a60b4fd725d7884bf050784b836","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@org.ops4j.pax.exam.Configuration\n    public Option[] config() {\n        final String localRepo = System.getProperty(\"maven.repo.local\", \"\");\n\n        final String bundleFileName = System.getProperty(\"bundle.file.name\", \"BUNDLE_FILE_NOT_SET\");\n        final File bundleFile = new File(bundleFileName);\n        if (!bundleFile.canRead()) {\n            throw new IllegalArgumentException(\"Cannot read from bundle file \" + bundleFile.getAbsolutePath());\n        }\n\n        return options(\n                when(localRepo.length() > 0).useOptions(\n                        systemProperty(\"org.ops4j.pax.url.mvn.localRepository\").value(localRepo)\n                ),\n                provision(\n                        bundle(bundleFile.toURI().toString()),\n                        mavenBundle(\"org.apache.felix\", \"org.apache.felix.scr\", \"1.6.2\"),\n                        mavenBundle(\"org.apache.felix\", \"org.apache.felix.eventadmin\", \"1.3.2\"),\n                        mavenBundle(maven().groupId(FELIX_GID).artifactId(\"org.apache.felix.webconsole\").versionAsInProject()),\n\n                        mavenBundle(maven().groupId(SLING_GID).artifactId(\"org.apache.sling.scripting.api\").versionAsInProject()),\n\n                        mavenBundle(maven().groupId(SLING_GID).artifactId(\"org.apache.sling.commons.threads\").versionAsInProject()),\n                        mavenBundle(maven().groupId(SLING_GID).artifactId(\"org.apache.sling.api\").versionAsInProject()),\n                        mavenBundle(maven().groupId(SLING_GID).artifactId(\"org.apache.sling.commons.mime\").versionAsInProject()),\n                        mavenBundle(maven().groupId(SLING_GID).artifactId(\"org.apache.sling.commons.osgi\").versionAsInProject()),\n\n                        mavenBundle(\"org.mortbay.jetty\", \"servlet-api-2.5\", \"6.1.14\"),\n                        mavenBundle(maven().groupId(\"commons-io\").artifactId(\"commons-io\").versionAsInProject()),\n                        mavenBundle(maven().groupId(\"commons-lang\").artifactId(\"commons-lang\").versionAsInProject())\n                ),\n                junitBundles()\n        );\n    }","id":44321,"modified_method":"@org.ops4j.pax.exam.Configuration\n    public Option[] config() {\n        final String localRepo = System.getProperty(\"maven.repo.local\", \"\");\n\n        final String bundleFileName = System.getProperty(\"bundle.file.name\", \"BUNDLE_FILE_NOT_SET\");\n        final File bundleFile = new File(bundleFileName);\n        if (!bundleFile.canRead()) {\n            throw new IllegalArgumentException(\"Cannot read from bundle file \" + bundleFile.getAbsolutePath());\n        }\n\n        return options(\n                when(localRepo.length() > 0).useOptions(\n                        systemProperty(\"org.ops4j.pax.url.mvn.localRepository\").value(localRepo)\n                ),\n                provision(\n                        bundle(bundleFile.toURI().toString()),\n                        mavenBundle().groupId(FELIX_GID).artifactId(\"org.apache.felix.scr\").versionAsInProject(),\n                        mavenBundle().groupId(FELIX_GID).artifactId(\"org.apache.felix.eventadmin\").versionAsInProject(),\n                        mavenBundle().groupId(FELIX_GID).artifactId(\"org.apache.felix.webconsole\").versionAsInProject(),\n\n                        mavenBundle().groupId(SLING_GID).artifactId(\"org.apache.sling.scripting.api\").versionAsInProject(),\n\n                        mavenBundle().groupId(SLING_GID).artifactId(\"org.apache.sling.commons.threads\").versionAsInProject(),\n                        mavenBundle().groupId(SLING_GID).artifactId(\"org.apache.sling.api\").versionAsInProject(),\n                        mavenBundle().groupId(SLING_GID).artifactId(\"org.apache.sling.commons.mime\").versionAsInProject(),\n                        mavenBundle().groupId(SLING_GID).artifactId(\"org.apache.sling.commons.osgi\").versionAsInProject(),\n\n                        mavenBundle().groupId(\"javax.servlet\").artifactId(\"javax.servlet-api\").versionAsInProject(),\n                        mavenBundle().groupId(\"commons-io\").artifactId(\"commons-io\").versionAsInProject(),\n                        mavenBundle().groupId(\"commons-lang\").artifactId(\"commons-lang\").versionAsInProject()\n                ),\n                junitBundles()\n        );\n    }","commit_id":"410ae429949f47971c911d1598056120d220a8ad","url":"https://github.com/apache/sling"},{"original_method":"protected void selectElement(Object element, String selectedText) {\n    final TreePath treePath = (TreePath)element;\n    TableUtil.selectRows(myComponent, new int[] {myComponent.convertRowIndexToView(myComponent.getTree().getRowForPath(treePath))});\n    TableUtil.scrollSelectionToVisible(myComponent);\n  }","id":44322,"modified_method":"protected void selectElement(Object element, String selectedText) {\n    final TreePath treePath = (TreePath)element;\n    final int row = myComponent.getTree().getRowForPath(treePath);\n    TableUtil.selectRows(myComponent, new int[] {\n      myComponent.convertRowIndexToView(row)\n    });\n    TableUtil.scrollSelectionToVisible(myComponent);\n  }","commit_id":"059e3a09deef7af10c8a74567cc5a2c8d68356f1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void selectInspectionTool(String name) {\n    final InspectionConfigTreeNode node = findNodeByKey(name, myRoot);\n    if (node != null) {\n      TreeUtil.showRowCentered(myTreeTable.getTree(), myTreeTable.getTree().getRowForPath(new TreePath(node.getPath())) - 1, true);//myTree.isRootVisible ? 0 : 1;\n      TreeUtil.selectNode(myTreeTable.getTree(), node);\n    }\n  }","id":44323,"modified_method":"public void selectInspectionTool(String name) {\n    final InspectionConfigTreeNode node = findNodeByKey(name, myRoot);\n    if (node != null) {\n      TreeUtil.selectNode(myTreeTable.getTree(), node);\n      final int rowForPath = myTreeTable.getTree().getRowForPath(new TreePath(node.getPath()));\n      TableUtil.selectRows(myTreeTable, new int[]{rowForPath});\n      scrollToCenter();\n    }\n  }","commit_id":"2206353c5031189a5c211a1f681b626f4d8739e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void updateSelection() {\n    if (myTreeTable != null) {\n      final TreePath selectionPath = myTreeTable.getTree().getSelectionPath();\n      if (selectionPath != null) {\n        TreeUtil.selectNode(myTreeTable.getTree(), (TreeNode)selectionPath.getLastPathComponent());\n        TreeUtil.showRowCentered(myTreeTable.getTree(), myTreeTable.getTree().getRowForPath(selectionPath), false);\n      }\n    }\n  }","id":44324,"modified_method":"public void updateSelection() {\n    if (myTreeTable != null) {\n      final TreePath selectionPath = myTreeTable.getTree().getSelectionPath();\n      if (selectionPath != null) {\n        TreeUtil.selectNode(myTreeTable.getTree(), (TreeNode) selectionPath.getLastPathComponent());\n        final int rowForPath = myTreeTable.getTree().getRowForPath(selectionPath);\n        TableUtil.selectRows(myTreeTable, new int[]{rowForPath});\n        scrollToCenter();\n      }\n    }\n  }","commit_id":"2206353c5031189a5c211a1f681b626f4d8739e8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void imageAct(LWImage im, Object actionKey) {\n            final int newDim;\n\n            //Log.debug(this + \" on \" + im);\n\n            if (actionKey == IMAGE_SHOW) {\n                if (im.isHidden(HideCause.IMAGE_ICON_OFF)) {\n                    im.clearHidden(HideCause.IMAGE_ICON_OFF);\n                    im.getParent().layout(\"imageIconShow\");\n                }\n                return;\n            }\n            \n            if (actionKey == IMAGE_HIDE)\n                newDim = Integer.MIN_VALUE;\n            else if (actionKey == IMAGE_BIGGER)\n                newDim = getBiggerSize(im); // will return same size if is currently OFF\n            else if (actionKey == IMAGE_SMALLER)\n                newDim = getSmallerSize(im);\n            else // actionKey is an Integer representing the new desired size\n                newDim = (Integer) actionKey;\n            \n            if (DEBUG.IMAGE) Log.debug(\"NEWDIM \" + newDim);\n            \n            if (newDim == Integer.MIN_VALUE) {\n                // hide\n                if (im.isNodeIcon()) {\n                    im.setHidden(HideCause.IMAGE_ICON_OFF);\n                    im.getParent().layout(\"imageIconHide\");\n                }\n            } else if (newDim == Integer.MAX_VALUE) {\n                // make natural size\n                im.setToNaturalSize();\n                if (im.isNodeIcon()) {\n                    im.clearHidden(HideCause.IMAGE_ICON_OFF);\n                    im.getParent().layout(\"imageIconShow\");\n                }\n            } else {\n                // adjust size\n                im.setMaxDimension(newDim);\n                if (im.isNodeIcon()) {\n                    im.clearHidden(HideCause.IMAGE_ICON_OFF);\n                    im.getParent().layout(\"imageIconShow\");\n                }\n            }\n        }","id":44325,"modified_method":"protected void imageAct(LWImage im, Object actionKey) {\n            final int newDim;\n\n            //Log.debug(this + \" on \" + im);\n\n            if (actionKey == IMAGE_SHOW) {\n                if (im.isHidden(HideCause.IMAGE_ICON_OFF)) {\n                    im.clearHidden(HideCause.IMAGE_ICON_OFF);\n                    im.getParent().layout(\"imageIconShow\");\n                }\n                return;\n            }\n            \n            if (actionKey == IMAGE_HIDE)\n                newDim = Integer.MIN_VALUE;\n            else if (actionKey == IMAGE_BIGGER)\n                newDim = getBiggerSize(im); // will return same size if is currently OFF\n            else if (actionKey == IMAGE_SMALLER)\n                newDim = getSmallerSize(im);\n            else // actionKey is an Integer representing the new desired size\n                newDim = (Integer) actionKey;\n            \n            if (DEBUG.IMAGE) Log.debug(\"NEWDIM \" + newDim);\n            \n            if (newDim == Integer.MIN_VALUE) {\n                // hide\n                if (im.isNodeIcon() || im.getParent() instanceof LWNode) {\n                    im.setHidden(HideCause.IMAGE_ICON_OFF);\n                    im.getParent().layout(\"imageIconHide\");\n                }\n            } else if (newDim == Integer.MAX_VALUE) {\n                // make natural size\n                im.setToNaturalSize();\n                if (im.isNodeIcon()) {\n                    im.clearHidden(HideCause.IMAGE_ICON_OFF);\n                    im.getParent().layout(\"imageIconShow\");\n                }\n            } else {\n                // adjust size\n                im.setMaxDimension(newDim);\n                if (im.isNodeIcon()) {\n                    im.clearHidden(HideCause.IMAGE_ICON_OFF);\n                    im.getParent().layout(\"imageIconShow\");\n                }\n            }\n        }","commit_id":"26c453a446f514febfbd179b9d5069ac8702271f","url":"https://github.com/VUE/VUE"},{"original_method":"/** This currently makes LWImages invisible to selection (they're locked in their parent node */\n    //@Override\n    protected LWComponent defaultPick(PickContext pc) {\n        if (getClass().isAssignableFrom(LWNode.class))\n            return super.defaultPick(pc);\n        else\n            return isNodeIcon() ? getParent() : this;\n            //return (pc.pickDepth > 0 || getParent() instanceof LWMap) ? this : getParent();\n        // todo: checking the map is a hack -- PickContext should tell us all we need\n    }","id":44326,"modified_method":"/** This currently makes LWImages invisible to selection (they're locked in their parent node */\n    //@Override\n    protected LWComponent defaultPick(PickContext pc) {\n        if (getClass().isAssignableFrom(LWNode.class)) {\n            return super.defaultPick(pc);\n        } else {\n            if (isNodeIcon())\n                return pc.pickDepth > 0 ? this : getParent();\n            else\n                return this;\n        }\n    }","commit_id":"ae59d6b0179dac01b030bc80feb81d09ae562059","url":"https://github.com/VUE/VUE"},{"original_method":"private void bindSingletons() {\n        bind(Configuration.class).toInstance(configuration);\n        bind(BaseConfiguration.class).toInstance(configuration);\n\n        bind(MongoConnection.class).toProvider(MongoConnectionProvider.class);\n\n        Multibinder<ServerStatus.Capability> capabilityBinder = Multibinder.newSetBinder(binder(), ServerStatus.Capability.class);\n        for (ServerStatus.Capability capability : capabilities) {\n            capabilityBinder.addBinding().toInstance(capability);\n        }\n\n        bind(ServerStatus.class).in(Scopes.SINGLETON);\n\n        if (configuration.isMessageJournalEnabled()) {\n            install(new KafkaJournalModule());\n            install(new JournalReaderModule());\n        } else {\n            install(new NoopJournalModule());\n        }\n        bind(Node.class).toProvider(EsNodeProvider.class).asEagerSingleton();\n        bind(Client.class).toProvider(EsClientProvider.class).asEagerSingleton();\n        bind(SystemJobManager.class).toProvider(SystemJobManagerProvider.class);\n        bind(RulesEngine.class).toProvider(RulesEngineProvider.class);\n        bind(LdapConnector.class).toProvider(LdapConnectorProvider.class);\n        bind(LdapUserAuthenticator.class).toProvider(LdapUserAuthenticatorProvider.class);\n        bind(DefaultSecurityManager.class).toProvider(DefaultSecurityManagerProvider.class);\n        bind(SystemJobFactory.class).toProvider(SystemJobFactoryProvider.class);\n        bind(GracefulShutdown.class).in(Scopes.SINGLETON);\n        bind(BundleService.class).in(Scopes.SINGLETON);\n        bind(BundleImporterProvider.class).in(Scopes.SINGLETON);\n        bind(BundleExporterProvider.class).in(Scopes.SINGLETON);\n        bind(ClusterStatsModule.class).asEagerSingleton();\n        bind(ClusterConfigService.class).to(ClusterConfigServiceImpl.class).asEagerSingleton();\n\n        bind(String[].class).annotatedWith(named(\"RestControllerPackages\")).toInstance(new String[]{\n                \"org.graylog2.rest.resources\",\n                \"org.graylog2.shared.rest.resources\"\n        });\n    }","id":44327,"modified_method":"private void bindSingletons() {\n        bind(Configuration.class).toInstance(configuration);\n        bind(BaseConfiguration.class).toInstance(configuration);\n\n        bind(MongoConnection.class).toProvider(MongoConnectionProvider.class);\n\n        Multibinder<ServerStatus.Capability> capabilityBinder = Multibinder.newSetBinder(binder(), ServerStatus.Capability.class);\n        for (ServerStatus.Capability capability : capabilities) {\n            capabilityBinder.addBinding().toInstance(capability);\n        }\n\n        bind(ServerStatus.class).in(Scopes.SINGLETON);\n\n        if (configuration.isMessageJournalEnabled()) {\n            install(new KafkaJournalModule());\n            install(new JournalReaderModule());\n        } else {\n            install(new NoopJournalModule());\n        }\n        bind(Node.class).toProvider(EsNodeProvider.class).asEagerSingleton();\n        bind(Client.class).toProvider(EsClientProvider.class).asEagerSingleton();\n        bind(SystemJobManager.class).toProvider(SystemJobManagerProvider.class);\n        bind(RulesEngine.class).toProvider(RulesEngineProvider.class);\n        bind(LdapConnector.class).toProvider(LdapConnectorProvider.class);\n        bind(LdapUserAuthenticator.class).toProvider(LdapUserAuthenticatorProvider.class);\n        bind(DefaultSecurityManager.class).toProvider(DefaultSecurityManagerProvider.class).asEagerSingleton();\n        bind(SystemJobFactory.class).toProvider(SystemJobFactoryProvider.class);\n        bind(GracefulShutdown.class).in(Scopes.SINGLETON);\n        bind(BundleService.class).in(Scopes.SINGLETON);\n        bind(BundleImporterProvider.class).in(Scopes.SINGLETON);\n        bind(BundleExporterProvider.class).in(Scopes.SINGLETON);\n        bind(ClusterStatsModule.class).asEagerSingleton();\n        bind(ClusterConfigService.class).to(ClusterConfigServiceImpl.class).asEagerSingleton();\n\n        bind(String[].class).annotatedWith(named(\"RestControllerPackages\")).toInstance(new String[]{\n                \"org.graylog2.rest.resources\",\n                \"org.graylog2.shared.rest.resources\"\n        });\n    }","commit_id":"9d033d70e9a87208372acfcb4bfb1963837fb688","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected void configure() {\n        // This is holding all our metrics.\n        bind(MetricRegistry.class).toInstance(new MetricRegistry());\n        bind(ThroughputStats.class).toInstance(new ThroughputStats());\n        bind(ProcessBufferWatermark.class).toInstance(new ProcessBufferWatermark());\n\n        bind(InstantiationService.class).toInstance(instantiationService);\n\n        install(new FactoryModuleBuilder().build(ProcessBuffer.Factory.class));\n\n        bind(ProcessBuffer.class).toProvider(ProcessBufferProvider.class);\n        bind(GELFChunkManager.class).toProvider(GELFChunkManagerProvider.class);\n        bind(NodeId.class).toProvider(NodeIdProvider.class);\n\n        bind(ServiceManager.class).toProvider(ServiceManagerProvider.class);\n\n        bind(HashedWheelTimer.class).toInstance(new HashedWheelTimer());\n        bind(ThroughputCounter.class);\n\n        bind(EventBus.class).toProvider(EventBusProvider.class).in(Scopes.SINGLETON);\n    }","id":44328,"modified_method":"@Override\n    protected void configure() {\n        // This is holding all our metrics.\n        bind(MetricRegistry.class).toInstance(new MetricRegistry());\n        bind(ThroughputStats.class).toInstance(new ThroughputStats());\n        bind(ProcessBufferWatermark.class).toInstance(new ProcessBufferWatermark());\n\n        bind(InstantiationService.class).toInstance(instantiationService);\n\n        install(new FactoryModuleBuilder().build(ProcessBuffer.Factory.class));\n\n        bind(ProcessBuffer.class).toProvider(ProcessBufferProvider.class);\n        bind(GELFChunkManager.class).toProvider(GELFChunkManagerProvider.class);\n        bind(NodeId.class).toProvider(NodeIdProvider.class);\n\n        bind(ServiceManager.class).toProvider(ServiceManagerProvider.class).asEagerSingleton();\n\n        bind(HashedWheelTimer.class).toInstance(new HashedWheelTimer());\n        bind(ThroughputCounter.class);\n\n        bind(EventBus.class).toProvider(EventBusProvider.class).in(Scopes.SINGLETON);\n    }","commit_id":"efd2674f4839a63378bdcba42a1b7aa9cb286563","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@POST @Timed\n    public Response launch(String body) {\n\n        InputLaunchRequest lr;\n        try {\n            lr = objectMapper.readValue(body, InputLaunchRequest.class);\n        } catch(IOException e) {\n            LOG.error(\"Error while parsing JSON\", e);\n            throw new WebApplicationException(e, Response.Status.BAD_REQUEST);\n        }\n\n        // Build a proper configuration from POST data.\n        Configuration inputConfig = new Configuration(lr.configuration);\n\n        // Build input.\n        DateTime createdAt = new DateTime(DateTimeZone.UTC);\n        MessageInput input;\n        try {\n            input = inputRegistry.create(lr.type);\n            input.setTitle(lr.title);\n            input.setCreatorUserId(lr.creatorUserId);\n            input.setCreatedAt(createdAt);\n            input.setGlobal(lr.global);\n\n            input.checkConfiguration(inputConfig);\n        } catch (NoSuchInputTypeException e) {\n            LOG.error(\"There is no such input type registered.\", e);\n            throw new WebApplicationException(e, Response.Status.NOT_FOUND);\n        } catch (ConfigurationException e) {\n            LOG.error(\"Missing or invalid input configuration.\", e);\n            throw new WebApplicationException(e, Response.Status.BAD_REQUEST);\n        }\n\n        String inputId = UUID.randomUUID().toString();\n        //input.setPersistId(inputId);\n\n        // Don't run if exclusive and another instance is already running.\n        if (input.isExclusive() && inputRegistry.hasTypeRunning(input.getClass())) {\n            LOG.error(\"Type is exclusive and already has input running.\");\n            throw new WebApplicationException(Response.Status.BAD_REQUEST);\n        }\n\n        input.initialize(inputConfig);\n\n        // Launch input. (this will run async and clean up itself in case of an error.)\n        inputRegistry.launch(input, inputId, true);\n\n        Map<String, Object> result = Maps.newHashMap();\n        result.put(\"input_id\", inputId);\n        result.put(\"persist_id\", inputId);\n\n        return Response.status(Response.Status.ACCEPTED).entity(json(result)).build();\n    }","id":44329,"modified_method":"@POST @Timed\n    public Response launch(String body) {\n\n        InputLaunchRequest lr;\n        try {\n            lr = objectMapper.readValue(body, InputLaunchRequest.class);\n        } catch(IOException e) {\n            LOG.error(\"Error while parsing JSON\", e);\n            throw new WebApplicationException(e, Response.Status.BAD_REQUEST);\n        }\n\n        // Build a proper configuration from POST data.\n        Configuration inputConfig = new Configuration(lr.configuration);\n\n        // Build input.\n        DateTime createdAt = new DateTime(DateTimeZone.UTC);\n        MessageInput input;\n        try {\n            input = inputRegistry.create(lr.type);\n            input.setTitle(lr.title);\n            input.setCreatorUserId(lr.creatorUserId);\n            input.setCreatedAt(createdAt);\n            input.setGlobal(lr.global);\n\n            input.checkConfiguration(inputConfig);\n        } catch (NoSuchInputTypeException e) {\n            LOG.error(\"There is no such input type registered.\", e);\n            throw new WebApplicationException(e, Response.Status.NOT_FOUND);\n        } catch (ConfigurationException e) {\n            LOG.error(\"Missing or invalid input configuration.\", e);\n            throw new WebApplicationException(e, Response.Status.BAD_REQUEST);\n        }\n\n        String inputId = UUID.randomUUID().toString();\n        input.setPersistId(inputId);\n\n        // Don't run if exclusive and another instance is already running.\n        if (input.isExclusive() && inputRegistry.hasTypeRunning(input.getClass())) {\n            LOG.error(\"Type is exclusive and already has input running.\");\n            throw new WebApplicationException(Response.Status.BAD_REQUEST);\n        }\n\n        input.initialize(inputConfig);\n\n        // Launch input. (this will run async and clean up itself in case of an error.)\n        inputRegistry.launch(input, inputId, true);\n\n        Map<String, Object> result = Maps.newHashMap();\n        result.put(\"input_id\", inputId);\n        result.put(\"persist_id\", inputId);\n\n        return Response.status(Response.Status.ACCEPTED).entity(json(result)).build();\n    }","commit_id":"251d7bb7b83a1a6b5bba2a07297ec9f179f056b7","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@GET @Timed\n    public String list() {\n        List<Map<String, Object>> inputStates = Lists.newArrayList();\n\n        for (InputState inputState : inputRegistry.getInputStates()) {\n            inputStates.add(inputState.asMap());\n        }\n\n        Map<String, Object> result = Maps.newHashMap();\n        result.put(\"inputs\", inputStates);\n        result.put(\"total\", inputStates.size());\n\n        return json(result);\n    }","id":44330,"modified_method":"@Inject\n    public InputsResource(InputRegistry inputRegistry, InputService inputService) {\n        this.inputRegistry = inputRegistry;\n        this.inputService = inputService;\n    }","commit_id":"251d7bb7b83a1a6b5bba2a07297ec9f179f056b7","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void bindSingletons() {\n        bind(Configuration.class).toInstance(configuration);\n        bind(BaseConfiguration.class).toInstance(configuration);\n\n        Multibinder<ServerStatus.Capability> capabilityBinder =\n                Multibinder.newSetBinder(binder(), ServerStatus.Capability.class);\n        capabilityBinder.addBinding().toInstance(ServerStatus.Capability.RADIO);\n\n        bind(ServerStatus.class).in(Scopes.SINGLETON);\n        bind(InputRegistry.class).toProvider(RadioInputRegistryProvider.class);\n\n        bind(URI.class).annotatedWith(Names.named(\"ServerUri\")).toInstance(configuration.getGraylog2ServerUri());\n        bind(URI.class).annotatedWith(Names.named(\"OurRadioUri\")).toInstance(configuration.getRestTransportUri());\n\n        bind(InputCache.class).to(BasicCache.class).in(Scopes.SINGLETON);\n    }","id":44331,"modified_method":"private void bindSingletons() {\n        bind(Configuration.class).toInstance(configuration);\n        bind(BaseConfiguration.class).toInstance(configuration);\n\n        Multibinder<ServerStatus.Capability> capabilityBinder =\n                Multibinder.newSetBinder(binder(), ServerStatus.Capability.class);\n        capabilityBinder.addBinding().toInstance(ServerStatus.Capability.RADIO);\n\n        bind(ServerStatus.class).in(Scopes.SINGLETON);\n        bind(InputRegistry.class).toProvider(RadioInputRegistryProvider.class).asEagerSingleton();\n\n        bind(URI.class).annotatedWith(Names.named(\"ServerUri\")).toInstance(configuration.getGraylog2ServerUri());\n        bind(URI.class).annotatedWith(Names.named(\"OurRadioUri\")).toInstance(configuration.getRestTransportUri());\n\n        bind(InputCache.class).to(BasicCache.class).in(Scopes.SINGLETON);\n    }","commit_id":"251d7bb7b83a1a6b5bba2a07297ec9f179f056b7","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"protected MessageInput getMessageInput(InputSummaryResponse isr) {\n        MessageInput input;\n        try {\n            input = this.create(isr.type);\n\n            Configuration inputConfig = new Configuration(isr.configuration);\n            // Add all standard fields.\n            input.setTitle(isr.title);\n            input.setCreatorUserId(isr.creatorUserId);\n            input.setPersistId(isr.id);\n            input.setCreatedAt(new DateTime(isr.createdAt));\n            input.setGlobal(isr.global);\n\n            input.checkConfiguration(inputConfig);\n            // initialize must run after all fields have been set. Why oh why isn't this done in the constructor/factory method?\n            input.initialize(inputConfig);\n        } catch (NoSuchInputTypeException e) {\n            LOG.warn(\"Cannot launch persisted input. No such type [{}]. Error: {}\", isr.type, e);\n            return null;\n        } catch (ConfigurationException e) {\n            LOG.error(\"Missing or invalid input input configuration.\", e);\n            return null;\n        }\n        return input;\n    }","id":44332,"modified_method":"private MessageInput getMessageInput(InputSummaryResponse isr) {\n        MessageInput input;\n        try {\n            input = this.create(isr.type);\n\n            Configuration inputConfig = new Configuration(isr.configuration);\n            // Add all standard fields.\n            input.setTitle(isr.title);\n            input.setCreatorUserId(isr.creatorUserId);\n            input.setPersistId(isr.id);\n            input.setCreatedAt(new DateTime(isr.createdAt));\n            input.setGlobal(isr.global);\n\n            input.checkConfiguration(inputConfig);\n            // initialize must run after all fields have been set. Why oh why isn't this done in the constructor/factory method?\n            input.initialize(inputConfig);\n        } catch (NoSuchInputTypeException e) {\n            LOG.warn(\"Cannot launch persisted input. No such type [{}]. Error: {}\", isr.type, e);\n            return null;\n        } catch (ConfigurationException e) {\n            LOG.error(\"Missing or invalid input input configuration.\", e);\n            return null;\n        }\n        return input;\n    }","commit_id":"251d7bb7b83a1a6b5bba2a07297ec9f179f056b7","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public List<MessageInput> getAllPersisted() {\n        final List<MessageInput> result = Lists.newArrayList();\n        final UriBuilder uriBuilder = UriBuilder.fromUri(serverUrl);\n        uriBuilder.path(\"/system/radios/\" + serverStatus.getNodeId().toString() + \"/inputs\");\n\n        List<InputSummaryResponse> response;\n        try {\n            Request request = httpclient.prepareGet(uriBuilder.build().toString()).build();\n            LOG.debug(\"API Request {} {}\", request.getMethod(), request.getUrl());\n            Future<Response> f = httpclient.executeRequest(request);\n\n            Response r = f.get();\n\n            if (r.getStatusCode() != 200) {\n                throw new RuntimeException(\"Expected HTTP response [200] for list of persisted input but got [\" + r.getStatusCode() + \"].\");\n            }\n            String responseBody = r.getResponseBody();\n            PersistedInputsResponse persistedInputsResponse = mapper.readValue(responseBody,\n                                                                               PersistedInputsResponse.class);\n            response = persistedInputsResponse.inputs;\n        } catch (IOException e) {\n            LOG.error(\"Unable to get persisted inputs: \", e);\n            return result;\n        } catch (InterruptedException e) {\n            LOG.error(\"Unable to get persisted inputs: \", e);\n            return result;\n        } catch (ExecutionException e) {\n            LOG.error(\"Unable to get persisted inputs: \", e);\n            return result;\n        }\n\n        for (InputSummaryResponse isr : response) {\n            final MessageInput messageInput = getMessageInput(isr);\n            if (messageInput != null) {\n                LOG.debug(\"Loaded message input {}\", messageInput);\n                result.add(messageInput);\n            }\n        }\n\n        return result;\n    }","id":44333,"modified_method":"@Override\n    public List<MessageInput> getAllPersisted() {\n        final List<MessageInput> result = Lists.newArrayList();\n\n        List<InputSummaryResponse> response;\n        try {\n            response = inputService.getPersistedInputs();\n        } catch (IOException e) {\n            LOG.error(\"Unable to get persisted inputs: \", e);\n            return result;\n        }\n\n        for (InputSummaryResponse isr : response) {\n            final MessageInput messageInput = getMessageInput(isr);\n            if (messageInput != null) {\n                LOG.debug(\"Loaded message input {}\", messageInput);\n                result.add(messageInput);\n            }\n        }\n\n        return result;\n    }","commit_id":"251d7bb7b83a1a6b5bba2a07297ec9f179f056b7","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public RadioInputRegistry(MessageInputFactory messageInputFactory,\n                              ProcessBuffer processBuffer,\n                              AsyncHttpClient httpclient,\n                              URI serverUrl,\n                              ServerStatus serverStatus) {\n        super(messageInputFactory, processBuffer);\n        this.httpclient = httpclient;\n        this.serverUrl = serverUrl;\n        this.serverStatus = serverStatus;\n    }","id":44334,"modified_method":"public RadioInputRegistry(MessageInputFactory messageInputFactory,\n                              ProcessBuffer processBuffer,\n                              AsyncHttpClient httpclient,\n                              URI serverUrl,\n                              ServerStatus serverStatus,\n                              InputService inputService) {\n        super(messageInputFactory, processBuffer);\n        this.httpclient = httpclient;\n        this.serverUrl = serverUrl;\n        this.serverStatus = serverStatus;\n        this.inputService = inputService;\n    }","commit_id":"251d7bb7b83a1a6b5bba2a07297ec9f179f056b7","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public InputState launch(MessageInput input, String id, boolean register) {\n        if (register) {\n            try {\n                final RegisterInputResponse response = registerInCluster(input);\n                if (response != null)\n                    input.setPersistId(response.persistId);\n            } catch (Exception e) {\n                LOG.error(\"Could not register input in Graylog2 cluster. It will be lost on next restart of this radio node.\", e);\n                return null;\n            }\n        }\n        return super.launch(input, id, register);\n    }","id":44335,"modified_method":"@Override\n    public InputState launch(MessageInput input, String id, boolean register) {\n        if (register) {\n            try {\n                final RegisterInputResponse response = inputService.registerInCluster(input);\n                if (response != null)\n                    input.setPersistId(response.persistId);\n            } catch (Exception e) {\n                LOG.error(\"Could not register input in Graylog2 cluster. It will be lost on next restart of this radio node.\", e);\n                return null;\n            }\n        }\n        return super.launch(input, id, register);\n    }","commit_id":"251d7bb7b83a1a6b5bba2a07297ec9f179f056b7","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    protected void finishedTermination(InputState state) {\n        MessageInput input = state.getMessageInput();\n        try {\n            if (!state.getMessageInput().getGlobal())\n                unregisterInCluster(input);\n        } catch (Exception e) {\n            LOG.error(\"Could not unregister input [{}], id <{}> on server cluster: {}\", input.getName(), input.getId(), e);\n            return;\n        }\n\n        LOG.info(\"Unregistered input [{}], id <{}> on server cluster.\", input.getName(), input.getId());\n\n        removeFromRunning(state);\n    }","id":44336,"modified_method":"@Override\n    protected void finishedTermination(InputState state) {\n        MessageInput input = state.getMessageInput();\n        try {\n            if (!state.getMessageInput().getGlobal())\n                inputService.unregisterInCluster(input);\n        } catch (Exception e) {\n            LOG.error(\"Could not unregister input [{}], id <{}> on server cluster: {}\", input.getName(), input.getId(), e);\n            return;\n        }\n\n        LOG.info(\"Unregistered input [{}], id <{}> on server cluster.\", input.getName(), input.getId());\n\n        removeFromRunning(state);\n    }","commit_id":"251d7bb7b83a1a6b5bba2a07297ec9f179f056b7","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Inject\n    public RadioInputRegistryProvider(MessageInputFactory messageInputFactory,\n                                      ProcessBuffer processBuffer,\n                                      AsyncHttpClient httpClient,\n                                      Configuration configuration,\n                                      ServerStatus serverStatus) {\n        if (radioInputRegistry == null)\n            radioInputRegistry = new RadioInputRegistry(messageInputFactory,\n                    processBuffer,\n                    httpClient,\n                    configuration.getGraylog2ServerUri(),\n                    serverStatus);\n    }","id":44337,"modified_method":"@Inject\n    public RadioInputRegistryProvider(MessageInputFactory messageInputFactory,\n                                      ProcessBuffer processBuffer,\n                                      AsyncHttpClient httpClient,\n                                      Configuration configuration,\n                                      ServerStatus serverStatus,\n                                      InputService inputService) {\n        if (radioInputRegistry == null)\n            radioInputRegistry = new RadioInputRegistry(messageInputFactory,\n                    processBuffer,\n                    httpClient,\n                    configuration.getGraylog2ServerUri(),\n                    serverStatus,\n                    inputService);\n    }","commit_id":"251d7bb7b83a1a6b5bba2a07297ec9f179f056b7","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void bindSingletons() {\n        bind(Configuration.class).toInstance(configuration);\n        bind(BaseConfiguration.class).toInstance(configuration);\n\n        bind(MongoConnection.class).toProvider(MongoConnectionProvider.class);\n\n        Multibinder<ServerStatus.Capability> capabilityBinder =\n                Multibinder.newSetBinder(binder(), ServerStatus.Capability.class);\n        capabilityBinder.addBinding().toInstance(ServerStatus.Capability.SERVER);\n        if (configuration.isMaster())\n            capabilityBinder.addBinding().toInstance(ServerStatus.Capability.MASTER);\n        bind(ServerStatus.class).in(Scopes.SINGLETON);\n\n        bind(OutputBufferWatermark.class).toInstance(new OutputBufferWatermark());\n        bind(Indexer.class).toProvider(IndexerProvider.class);\n        bind(SystemJobManager.class).toProvider(SystemJobManagerProvider.class);\n        bind(InputRegistry.class).toProvider(ServerInputRegistryProvider.class);\n        bind(RulesEngine.class).toProvider(RulesEngineProvider.class);\n        bind(LdapConnector.class).toProvider(LdapConnectorProvider.class);\n        bind(LdapUserAuthenticator.class).toProvider(LdapUserAuthenticatorProvider.class);\n        bind(DefaultSecurityManager.class).toProvider(DefaultSecurityManagerProvider.class);\n        bind(SystemJobFactory.class).toProvider(SystemJobFactoryProvider.class);\n        bind(AsyncHttpClient.class).toProvider(AsyncHttpClientProvider.class);\n        bind(GracefulShutdown.class).in(Scopes.SINGLETON);\n\n        if (configuration.isMessageCacheOffHeap()) {\n            bind(InputCache.class).toProvider(InputCacheProvider.class).asEagerSingleton();\n            bind(OutputCache.class).toProvider(OutputCacheProvider.class).asEagerSingleton();\n        } else {\n            bind(InputCache.class).to(BasicCache.class).in(Scopes.SINGLETON);\n            bind(OutputCache.class).to(BasicCache.class).in(Scopes.SINGLETON);\n        }\n    }","id":44338,"modified_method":"private void bindSingletons() {\n        bind(Configuration.class).toInstance(configuration);\n        bind(BaseConfiguration.class).toInstance(configuration);\n\n        bind(MongoConnection.class).toProvider(MongoConnectionProvider.class);\n\n        Multibinder<ServerStatus.Capability> capabilityBinder =\n                Multibinder.newSetBinder(binder(), ServerStatus.Capability.class);\n        capabilityBinder.addBinding().toInstance(ServerStatus.Capability.SERVER);\n        if (configuration.isMaster())\n            capabilityBinder.addBinding().toInstance(ServerStatus.Capability.MASTER);\n        bind(ServerStatus.class).in(Scopes.SINGLETON);\n\n        bind(OutputBufferWatermark.class).toInstance(new OutputBufferWatermark());\n        bind(Indexer.class).toProvider(IndexerProvider.class);\n        bind(SystemJobManager.class).toProvider(SystemJobManagerProvider.class);\n        bind(InputRegistry.class).toProvider(ServerInputRegistryProvider.class).asEagerSingleton();\n        bind(RulesEngine.class).toProvider(RulesEngineProvider.class);\n        bind(LdapConnector.class).toProvider(LdapConnectorProvider.class);\n        bind(LdapUserAuthenticator.class).toProvider(LdapUserAuthenticatorProvider.class);\n        bind(DefaultSecurityManager.class).toProvider(DefaultSecurityManagerProvider.class);\n        bind(SystemJobFactory.class).toProvider(SystemJobFactoryProvider.class);\n        bind(AsyncHttpClient.class).toProvider(AsyncHttpClientProvider.class);\n        bind(GracefulShutdown.class).in(Scopes.SINGLETON);\n\n        if (configuration.isMessageCacheOffHeap()) {\n            bind(InputCache.class).toProvider(InputCacheProvider.class).asEagerSingleton();\n            bind(OutputCache.class).toProvider(OutputCacheProvider.class).asEagerSingleton();\n        } else {\n            bind(InputCache.class).to(BasicCache.class).in(Scopes.SINGLETON);\n            bind(OutputCache.class).to(BasicCache.class).in(Scopes.SINGLETON);\n        }\n    }","commit_id":"251d7bb7b83a1a6b5bba2a07297ec9f179f056b7","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void bindProviders() {\n        bind(AsyncHttpClient.class).toProvider(AsyncHttpClientProvider.class);\n        bind(ObjectMapper.class).toProvider(ObjectMapperProvider.class);\n    }","id":44339,"modified_method":"private void bindProviders() {\n        bind(AsyncHttpClient.class).toProvider(AsyncHttpClientProvider.class);\n        bind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).asEagerSingleton();\n    }","commit_id":"fcd587006f330a1aeb439221256967f5f791e0aa","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void bindProviders() {\n        bind(ObjectMapper.class).toProvider(ServerObjectMapperProvider.class);\n        bind(RotationStrategy.class).toProvider(RotationStrategyProvider.class);\n    }","id":44340,"modified_method":"private void bindProviders() {\n        bind(ObjectMapper.class).toProvider(ServerObjectMapperProvider.class).asEagerSingleton();\n        bind(RotationStrategy.class).toProvider(RotationStrategyProvider.class);\n    }","commit_id":"fcd587006f330a1aeb439221256967f5f791e0aa","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public DefaultBuildInvocations buildAll(String modelName, Project project, boolean implicitProject) {\n        if (implicitProject) {\n            return new DefaultBuildInvocations().setSelectors(buildRecursively(modelName, project.getRootProject()));\n        } else {\n            return buildAll(modelName, project);\n        }\n    }","id":44341,"modified_method":"public DefaultBuildInvocations buildAll(String modelName, Project project, boolean implicitProject) {\n        if (implicitProject) {\n            DefaultGradleProject gradleProject = gradleProjectBuilder.buildAll(project);\n            List<DefaultGradleTask> tasks = new ArrayList<DefaultGradleTask>();\n            fillTaskList(gradleProject, tasks);\n            return new DefaultBuildInvocations()\n                    .setSelectors(buildRecursively(modelName, project.getRootProject()))\n                    .setTasks(tasks);\n        } else {\n            return buildAll(modelName, project);\n        }\n    }","commit_id":"4146207630579ca169126489b0f4d12d95dab8f5","url":"https://github.com/gradle/gradle"},{"original_method":"private List<DefaultGradleTaskSelector> buildRecursively(GradleProject project) {\n        List<DefaultGradleTaskSelector> selectors = Lists.newArrayList();\n        for (GradleProject childProject : project.getChildren()) {\n            selectors.addAll(buildRecursively(childProject));\n        }\n        Multimap<String, String> aggregatedTasks = ArrayListMultimap.create();\n        for (DefaultGradleTaskSelector childSelector : selectors) {\n            aggregatedTasks.putAll(childSelector.getName(), childSelector.getTasks());\n        }\n        for (GradleTask task : project.getTasks()) {\n            aggregatedTasks.put(task.getName(), task.getPath());\n        }\n        for (String selectorName : aggregatedTasks.keySet()) {\n            selectors.add(new DefaultGradleTaskSelector().\n                    setName(selectorName).\n                    setTaskNames(Sets.newHashSet(aggregatedTasks.get(selectorName))).\n                    setDescription(project.getParent() != null\n                            ? String.format(\"%s:%s task selector\", project.getPath(), selectorName)\n                            : String.format(\"%s task selector\", selectorName)).\n                    setDisplayName(String.format(\"%s built in %s and subprojects.\", selectorName, project.getName())));\n        }\n        return selectors;\n    }","id":44342,"modified_method":"private void buildRecursively(GradleProject project, List<DefaultGradleTaskSelector> selectors, List<GradleTask> tasks) {\n        for (GradleProject childProject : project.getChildren()) {\n            buildRecursively(childProject, selectors, tasks);\n        }\n        Multimap<String, String> aggregatedTasks = ArrayListMultimap.create();\n        for (DefaultGradleTaskSelector childSelector : selectors) {\n            aggregatedTasks.putAll(childSelector.getName(), childSelector.getTasks());\n        }\n        for (GradleTask task : project.getTasks()) {\n            aggregatedTasks.put(task.getName(), task.getPath());\n            tasks.add(task);\n        }\n        for (String selectorName : aggregatedTasks.keySet()) {\n            selectors.add(new DefaultGradleTaskSelector().\n                    setName(selectorName).\n                    setTaskNames(Sets.newHashSet(aggregatedTasks.get(selectorName))).\n                    setDescription(project.getParent() != null\n                            ? String.format(\"%s:%s task selector\", project.getPath(), selectorName)\n                            : String.format(\"%s task selector\", selectorName)).\n                    setDisplayName(String.format(\"%s built in %s and subprojects.\", selectorName, project.getName())));\n        }\n    }","commit_id":"4146207630579ca169126489b0f4d12d95dab8f5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultBuildInvocations convert(GradleProject project) {\n        return new DefaultBuildInvocations().setSelectors(buildRecursively(project));\n    }","id":44343,"modified_method":"public DefaultBuildInvocations convert(GradleProject project) {\n        List<DefaultGradleTaskSelector> selectors = Lists.newArrayList();\n        List<GradleTask> tasks = Lists.newArrayList();\n        buildRecursively(project, selectors, tasks);\n        return new DefaultBuildInvocations().setSelectors(selectors).setTasks(tasks);\n    }","commit_id":"4146207630579ca169126489b0f4d12d95dab8f5","url":"https://github.com/gradle/gradle"},{"original_method":"public List<DefaultGradleTask> getTasks() {\n        return tasks;\n    }","id":44344,"modified_method":"public List<T> getTasks() {\n        return tasks;\n    }","commit_id":"4146207630579ca169126489b0f4d12d95dab8f5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultBuildInvocations setTasks(List<DefaultGradleTask> tasks) {\n        this.tasks = tasks;\n        return this;\n    }","id":44345,"modified_method":"public DefaultBuildInvocations setTasks(List<T> tasks) {\n        this.tasks = tasks;\n        return this;\n    }","commit_id":"4146207630579ca169126489b0f4d12d95dab8f5","url":"https://github.com/gradle/gradle"},{"original_method":"public boolean canBuild(String modelName) {\n        return modelName.equals(\"org.gradle.tooling.model.gradle.BuildInvocations\");\n    }","id":44346,"modified_method":"public BuildInvocationsBuilder(GradleProjectBuilder gradleProjectBuilder) {\n        this.gradleProjectBuilder = gradleProjectBuilder;\n    }","commit_id":"16f4a270698edae6bf8f44938d9c0fdeb95edcae","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultBuildInvocations buildAll(String modelName, Project project) {\n        if (!canBuild(modelName)) {\n            throw new GradleException(\"Unknown model name \" + modelName);\n        }\n        List<DefaultGradleTaskSelector> selectors = Lists.newArrayList();\n        Multimap<String, String> aggregatedTasks = findTasks(project);\n        for (String selectorName : aggregatedTasks.keySet()) {\n            selectors.add(new DefaultGradleTaskSelector().\n                    setName(selectorName).\n                    setTaskNames(Sets.newHashSet(aggregatedTasks.get(selectorName))).\n                    setDescription(project.getParent() != null\n                            ? String.format(\"%s:%s task selector\", project.getPath(), selectorName)\n                            : String.format(\"%s task selector\", selectorName)).\n                    setDisplayName(String.format(\"%s built in %s and subprojects.\", selectorName, project.getName())));\n        }\n        return new DefaultBuildInvocations().setSelectors(selectors);\n    }","id":44347,"modified_method":"public DefaultBuildInvocations buildAll(String modelName, Project project) {\n        if (!canBuild(modelName)) {\n            throw new GradleException(\"Unknown model name \" + modelName);\n        }\n        List<DefaultGradleTaskSelector> selectors = Lists.newArrayList();\n        Multimap<String, String> aggregatedTasks = findTasks(project);\n        for (String selectorName : aggregatedTasks.keySet()) {\n            selectors.add(new DefaultGradleTaskSelector().\n                    setName(selectorName).\n                    setTaskNames(Sets.newHashSet(aggregatedTasks.get(selectorName))).\n                    setDescription(project.getParent() != null\n                            ? String.format(\"%s:%s task selector\", project.getPath(), selectorName)\n                            : String.format(\"%s task selector\", selectorName)).\n                    setDisplayName(String.format(\"%s built in %s and subprojects.\", selectorName, project.getName())));\n        }\n        return new DefaultBuildInvocations()\n                .setSelectors(selectors)\n                .setTasks(new ArrayList(gradleProjectBuilder.buildAll(project).findByPath(project.getPath()).getTasks()));\n    }","commit_id":"16f4a270698edae6bf8f44938d9c0fdeb95edcae","url":"https://github.com/gradle/gradle"},{"original_method":"public void execute(ProjectInternal project) {\n        ToolingModelBuilderRegistry modelBuilderRegistry = project.getServices().get(ToolingModelBuilderRegistry.class);\n        ProjectPublicationRegistry projectPublicationRegistry = project.getServices().get(ProjectPublicationRegistry.class);\n\n        GradleProjectBuilder gradleProjectBuilder  = new GradleProjectBuilder(projectPublicationRegistry);\n        IdeaModelBuilder ideaModelBuilder = new IdeaModelBuilder(gradleProjectBuilder);\n        modelBuilderRegistry.register(new EclipseModelBuilder(gradleProjectBuilder));\n        modelBuilderRegistry.register(ideaModelBuilder);\n        modelBuilderRegistry.register(gradleProjectBuilder);\n        modelBuilderRegistry.register(new GradleBuildBuilder());\n        modelBuilderRegistry.register(new BasicIdeaModelBuilder(ideaModelBuilder));\n        modelBuilderRegistry.register(new BuildInvocationsBuilder());\n    }","id":44348,"modified_method":"public void execute(ProjectInternal project) {\n        ToolingModelBuilderRegistry modelBuilderRegistry = project.getServices().get(ToolingModelBuilderRegistry.class);\n        ProjectPublicationRegistry projectPublicationRegistry = project.getServices().get(ProjectPublicationRegistry.class);\n\n        GradleProjectBuilder gradleProjectBuilder  = new GradleProjectBuilder(projectPublicationRegistry);\n        IdeaModelBuilder ideaModelBuilder = new IdeaModelBuilder(gradleProjectBuilder);\n        modelBuilderRegistry.register(new EclipseModelBuilder(gradleProjectBuilder));\n        modelBuilderRegistry.register(ideaModelBuilder);\n        modelBuilderRegistry.register(gradleProjectBuilder);\n        modelBuilderRegistry.register(new GradleBuildBuilder());\n        modelBuilderRegistry.register(new BasicIdeaModelBuilder(ideaModelBuilder));\n        modelBuilderRegistry.register(new BuildInvocationsBuilder(gradleProjectBuilder));\n    }","commit_id":"16f4a270698edae6bf8f44938d9c0fdeb95edcae","url":"https://github.com/gradle/gradle"},{"original_method":"/** {@inheritDoc} */\n    @Transactional(readOnly=true)\n    @Override\n    public PollerConfiguration getPollerConfiguration(final String locationMonitorId) {\n        try {\n\t\t\tfinal OnmsLocationMonitor mon = m_locMonDao.get(locationMonitorId);\n\t\t\tif (mon == null) {\n\t\t\t    // the monitor has been deleted we'll pick this in up on the next config check\n\t\t\t    return new EmptyPollerConfiguration();\n\t\t\t}\n\t\t\t\n            List<String> pollingPackageNames = getPackageName(mon);\n\n            List<SimplePollerConfiguration> addMe = new ArrayList<SimplePollerConfiguration>();\n            for (String pollingPackageName : pollingPackageNames) {\n                ConcurrentHashMap<String, SimplePollerConfiguration> cache = m_configCache.get();\n                SimplePollerConfiguration pollerConfiguration = cache.get(pollingPackageName);\n                if (pollerConfiguration == null) {\n                    pollerConfiguration = createPollerConfiguration(mon, pollingPackageName);\n                    SimplePollerConfiguration configInCache = cache.putIfAbsent(pollingPackageName, pollerConfiguration);\n                    // Make sure that we get the up-to-date value out of the ConcurrentHashMap\n                    if (configInCache != null) {\n                        pollerConfiguration = configInCache;\n                    }\n                }\n                addMe.add(pollerConfiguration);\n            }\n\n            // construct a copy so the serverTime gets updated (and avoid threading issues)\n            return new SimplePollerConfiguration(addMe.toArray(new SimplePollerConfiguration[0]));\n\t\t} catch (final Exception e) {\n\t\t\tLOG.warn(\"An error occurred retrieving the poller configuration for location monitor ID {}\", locationMonitorId, e);\n\t\t\treturn new EmptyPollerConfiguration();\n\t\t}\n    }","id":44349,"modified_method":"/** {@inheritDoc} */\n    @Transactional(readOnly=true)\n    @Override\n    public PollerConfiguration getPollerConfiguration(final String locationMonitorId) {\n        try {\n\t\t\tfinal OnmsLocationMonitor mon = m_locMonDao.get(locationMonitorId);\n\t\t\tif (mon == null) {\n\t\t\t    LOG.warn(\"No location monitor found for location monitor ID {}\", locationMonitorId);\n\t\t\t    // the monitor has been deleted we'll pick this in up on the next config check\n\t\t\t    return new EmptyPollerConfiguration();\n\t\t\t}\n\n            List<String> pollingPackageNames = getPackageName(mon);\n            LOG.debug(\"Location monitor ID {} has polling packages: {}\", locationMonitorId, pollingPackageNames);\n\n            List<SimplePollerConfiguration> addMe = new ArrayList<SimplePollerConfiguration>();\n            for (String pollingPackageName : pollingPackageNames) {\n                ConcurrentHashMap<String, SimplePollerConfiguration> cache = m_configCache.get();\n                SimplePollerConfiguration pollerConfiguration = cache.get(pollingPackageName);\n                if (pollerConfiguration == null) {\n                    pollerConfiguration = createPollerConfiguration(mon, pollingPackageName);\n                    SimplePollerConfiguration configInCache = cache.putIfAbsent(pollingPackageName, pollerConfiguration);\n                    // Make sure that we get the up-to-date value out of the ConcurrentHashMap\n                    if (configInCache != null) {\n                        pollerConfiguration = configInCache;\n                    }\n                }\n                addMe.add(pollerConfiguration);\n            }\n\n            // construct a copy so the serverTime gets updated (and avoid threading issues)\n            return new SimplePollerConfiguration(addMe.toArray(new SimplePollerConfiguration[0]));\n\t\t} catch (final Exception e) {\n\t\t\tLOG.warn(\"An error occurred retrieving the poller configuration for location monitor ID {}\", locationMonitorId, e);\n\t\t\treturn new EmptyPollerConfiguration();\n\t\t}\n    }","commit_id":"8fdc6ce598eb38e821ab7f01f28f7bc4569db417","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private SimplePollerConfiguration createPollerConfiguration(\n            final OnmsLocationMonitor mon, String pollingPackageName) {\n        final Package pkg = getPollingPackage(pollingPackageName, mon.getLocation());\n        \n        final ServiceSelector selector = m_pollerConfig.getServiceSelectorForPackage(pkg);\n        final Collection<OnmsMonitoredService> services = m_monSvcDao.findMatchingServices(selector);\n        final List<PolledService> configs = new ArrayList<PolledService>(services.size());\n\n        LOG.debug(\"found {} services\", services.size());\n\n        for (final OnmsMonitoredService monSvc : services) {\n            final Service serviceConfig = m_pollerConfig.getServiceInPackage(monSvc.getServiceName(), pkg);\n            final long interval = serviceConfig.getInterval();\n            final Map<String, Object> parameters = getParameterMap(serviceConfig);\n            configs.add(new PolledService(monSvc, parameters, new OnmsPollModel(interval)));\n        }\n\n        Collections.sort(configs);\n        return new SimplePollerConfiguration(getConfigurationTimestamp(), configs.toArray(new PolledService[configs.size()]));\n    }","id":44350,"modified_method":"private SimplePollerConfiguration createPollerConfiguration(\n            final OnmsLocationMonitor mon, String pollingPackageName) {\n        final Package pkg = getPollingPackage(pollingPackageName, mon.getLocation());\n        \n        final ServiceSelector selector = m_pollerConfig.getServiceSelectorForPackage(pkg);\n        final Collection<OnmsMonitoredService> services = m_monSvcDao.findMatchingServices(selector);\n        final List<PolledService> configs = new ArrayList<PolledService>(services.size());\n\n        LOG.debug(\"Found {} services for monitor {} in polling package {}\", services.size(), mon, pollingPackageName);\n\n        for (final OnmsMonitoredService monSvc : services) {\n            final Service serviceConfig = m_pollerConfig.getServiceInPackage(monSvc.getServiceName(), pkg);\n            final long interval = serviceConfig.getInterval();\n            final Map<String, Object> parameters = getParameterMap(serviceConfig);\n\n            if (LOG.isTraceEnabled()) {\n                for (Map.Entry<String, Object> entry : parameters.entrySet()) {\n                    LOG.trace(\"Service {} has parameter {} with type {} and value: {}\",\n                            monSvc.getServiceName(), entry.getKey(), entry.getValue() != null ? entry.getValue().getClass().getCanonicalName() : \"null\", entry.getValue());\n                }\n            }\n\n            configs.add(new PolledService(monSvc, parameters, new OnmsPollModel(interval)));\n        }\n\n        Collections.sort(configs);\n        return new SimplePollerConfiguration(getConfigurationTimestamp(), configs.toArray(new PolledService[configs.size()]));\n    }","commit_id":"8fdc6ce598eb38e821ab7f01f28f7bc4569db417","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private Map<String, Object> getParameterMap(final Service serviceConfig) {\n        final Map<String, Object> paramMap = new HashMap<String, Object>();\n        for (final Parameter serviceParm : serviceConfig.getParameters()) {\n            String value = serviceParm.getValue();\n            if (value == null) {\n                value = (serviceParm.getAnyObject() == null ? \"\" : serviceParm.getAnyObject().toString());\n            }\n\n            paramMap.put(serviceParm.getKey(), value);\n        }\n        return paramMap;\n    }","id":44351,"modified_method":"protected static Map<String, Object> getParameterMap(final Service serviceConfig) {\n        final Map<String, Object> paramMap = new HashMap<String, Object>();\n        for (final Parameter serviceParm : serviceConfig.getParameters()) {\n            String value = serviceParm.getValue();\n            if (value == null) {\n                final Object o = serviceParm.getAnyObject();\n                if (o == null) {\n                    value = \"\";\n                } else if (o instanceof PageSequence) {\n                    // The PageSequenceMonitor uses PageSequence type parameters in the service definition\n                    // These need to be marshalled to XML before being sent to the PollerFrontEnd\n                    value = JaxbUtils.marshal(o);\n                } else {\n                    value = o.toString();\n                }\n            }\n\n            paramMap.put(serviceParm.getKey(), value);\n        }\n        return paramMap;\n    }","commit_id":"8fdc6ce598eb38e821ab7f01f28f7bc4569db417","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Get the content of the editor.\n     * \n     * @return The editor text.\n     */\n    public String getText()\n    {\n        return textArea.getText();\n    }","id":44352,"modified_method":"/**\n     * Get the TextArea of the editor.\n     * \n     * @return The TextArea for this editor.\n     */\n    public TextArea getTextArea()\n    {\n        return textArea;\n    }","commit_id":"3cfc62ed5596f286f07eff4d85cf16ad040f14c3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\r\n     * Initialization of the WYSIWYG editors.\r\n     */\r\n    private void init()\r\n    {        \r\n        loadConfigurations();\r\n        loadEditors();\r\n    }","id":44353,"modified_method":"/**\r\n     * Initialization of the WYSIWYG editors.\r\n     */\r\n    private void init()\r\n    {        \r\n        createController(this);\r\n        loadConfigurations();\r\n        loadEditors();\r\n    }","commit_id":"3cfc62ed5596f286f07eff4d85cf16ad040f14c3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n         * {@inheritDoc}\n         */\n        public void onSuccess(String result)\n        {\n            editor.setLoading(false);\n            // Disable the rich text area to avoid submitting its content.\n            editor.getRichTextEditor().getTextArea().getCommandManager().execute(WysiwygEditorListener.ENABLE, false);\n            editor.getPlainTextEditor().setText(result);\n        }","id":44354,"modified_method":"/**\n         * {@inheritDoc}\n         */\n        public void onSuccess(String result)\n        {\n            editor.setLoading(false);\n            // Disable the rich text area to avoid submitting its content.\n            editor.getRichTextEditor().getTextArea().getCommandManager().execute(WysiwygEditorListener.ENABLE, false);\n            editor.getPlainTextEditor().getTextArea().setText(result);\n        }","commit_id":"3cfc62ed5596f286f07eff4d85cf16ad040f14c3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void onTabSelected(SourcesTabEvents sender, int index)\n    {\n        editor.setLoading(true);\n        if (index == WysiwygEditor.WYSIWYG_TAB_INDEX) {\n            WysiwygServiceAsync wysiwygService = WysiwygService.Singleton.getInstance();\n            wysiwygService.toHTML(editor.getPlainTextEditor().getText(), editor.getConfig().getParameter(\n                SYNTAX_CONFIG_PARAMETER, WysiwygEditor.DEFAULT_SYNTAX), new SwitchToWysiwygCallback(editor));\n        } else {\n            WysiwygServiceAsync wysiwygService = WysiwygService.Singleton.getInstance();\n            // Notify the plug-ins that the content of the rich text area is about to be submitted.\n            editor.getRichTextEditor().getTextArea().getCommandManager().execute(SUBMIT);\n            // At this point we should have the HTML, adjusted by plug-ins, in the hidden plain text area.\n            // Make the request to convert the HTML to Wiki syntax.\n            wysiwygService.fromHTML(editor.getPlainTextEditor().getText(), editor.getConfig().getParameter(\n                SYNTAX_CONFIG_PARAMETER, WysiwygEditor.DEFAULT_SYNTAX), new SwitchToWikiCallback(editor));\n        }\n    }","id":44355,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void onTabSelected(SourcesTabEvents sender, int index)\n    {\n        editor.setLoading(true);\n        WysiwygServiceAsync wysiwygService = WysiwygService.Singleton.getInstance();\n        // We test if the RTE textarea is disabled to be sure that the editor is not already being switched.\n        if (index == WysiwygEditor.WYSIWYG_TAB_INDEX && !editor.getRichTextEditor().getTextArea().isEnabled()) {\n            wysiwygService.toHTML(editor.getPlainTextEditor().getTextArea().getText(), editor.getConfig().getParameter(\n                SYNTAX_CONFIG_PARAMETER, WysiwygEditor.DEFAULT_SYNTAX), new SwitchToWysiwygCallback(editor));\n        } else {\n            // We test if the RTE textarea is enabled to be sure that the editor is not already being switched.  \n            if (index == WysiwygEditor.WIKI_TAB_INDEX && editor.getRichTextEditor().getTextArea().isEnabled()) {\n                // Notify the plug-ins that the content of the rich text area is about to be submitted.\n                editor.getRichTextEditor().getTextArea().getCommandManager().execute(SUBMIT);\n                // At this point we should have the HTML, adjusted by plug-ins, in the hidden plain text area.\n                // Make the request to convert the HTML to Wiki syntax.\n                wysiwygService.fromHTML(editor.getPlainTextEditor().getTextArea().getText(), \n                    editor.getConfig().getParameter(SYNTAX_CONFIG_PARAMETER, WysiwygEditor.DEFAULT_SYNTAX), \n                    new SwitchToWikiCallback(editor));\n            }\n        }\n    }","commit_id":"3cfc62ed5596f286f07eff4d85cf16ad040f14c3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n   * @param  anchor should never be null or null will be returned\n   */\n  @NotNull\n  public static ParseResult parse(@Nullable final PsiElement anchor, @NotNull String type) {\n    if (anchor == null || !anchor.isValid()) {\n      return EMPTY_RESULT;\n    }\n\n    final ForwardDeclaration<ParseResult, PyElementType> typeExpr = ForwardDeclaration.create();\n\n    final FunctionalParser<ParseResult, PyElementType> classType =\n      token(IDENTIFIER).then(many(op(\".\").skipThen(token(IDENTIFIER))))\n        .map(new MakeSimpleType(anchor))\n        .cached()\n        .named(\"class-type\");\n\n    final FunctionalParser<ParseResult, PyElementType> tupleType =\n      op(\"(\").skipThen(typeExpr).then(many(op(\",\").skipThen(typeExpr))).thenSkip(op(\")\"))\n        .map(new Function<Pair<ParseResult, List<ParseResult>>, ParseResult>() {\n          @Override\n          public ParseResult fun(Pair<ParseResult, List<ParseResult>> value) {\n            ParseResult result = value.getFirst();\n            final List<ParseResult> rest = value.getSecond();\n            if (rest.isEmpty()) {\n              return result;\n            }\n            final List<PyType> types = new ArrayList<PyType>();\n            types.add(result.getType());\n            for (ParseResult r : rest) {\n              result = result.merge(r);\n              types.add(r.getType());\n            }\n            return result.withType(PyTupleType.create(anchor, types.toArray(new PyType[types.size()])));\n          }\n        })\n        .named(\"tuple-type\");\n\n    final FunctionalParser<ParseResult, PyElementType> typeParameter =\n      token(PARAMETER).then(maybe(op(\"<=\").skipThen(typeExpr)))\n        .map(new Function<Pair<Token<PyElementType>, ParseResult>, ParseResult>() {\n          @Override\n          public ParseResult fun(Pair<Token<PyElementType>, ParseResult> value) {\n            final Token<PyElementType> token = value.getFirst();\n            final String name = token.getText().toString();\n            final TextRange range = token.getRange();\n            final ParseResult boundResult = value.getSecond();\n            if (boundResult != null) {\n              final PyGenericType type = new PyGenericType(name, boundResult.getType());\n              final ParseResult result = new ParseResult(null, type, range);\n              return result.merge(boundResult).withType(type);\n            }\n            return new ParseResult(null, new PyGenericType(name, null), range);\n          }\n        })\n        .named(\"type-parameter\");\n\n    final FunctionalParser<ParseResult, PyElementType> simpleExpr =\n      classType\n        .or(tupleType)\n        .or(typeParameter)\n        .named(\"simple-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> paramExpr =\n      classType.thenSkip(op(\"[\")).then(typeExpr).then(many(op(\",\").skipThen(typeExpr))).thenSkip(op(\"]\"))\n        .map(new Function<Pair<Pair<ParseResult, ParseResult>, List<ParseResult>>, ParseResult>() {\n          @Override\n          public ParseResult fun(Pair<Pair<ParseResult, ParseResult>, List<ParseResult>> value) {\n            final Pair<ParseResult, ParseResult> firstPair = value.getFirst();\n            final ParseResult first = firstPair.getFirst();\n            final ParseResult second = firstPair.getSecond();\n            final List<ParseResult> third = value.getSecond();\n            final PyType firstType = first.getType();\n            final List<PyType> typesInBrackets = new ArrayList<PyType>();\n            typesInBrackets.add(second.getType());\n            ParseResult result = first;\n            result = result.merge(second);\n            for (ParseResult r : third) {\n              typesInBrackets.add(r.getType());\n              result = result.merge(r);\n            }\n            final List<PyType> elementTypes = third.isEmpty() ? Collections.singletonList(second.getType()) : typesInBrackets;\n            final PsiElement resolved = first.getElement();\n            if (resolved != null) {\n              final PyType typingType = PyTypingTypeProvider.getType(resolved, elementTypes);\n              if (typingType != null) {\n                return result.withType(typingType);\n              }\n            }\n            if (firstType instanceof PyClassType) {\n              final PyType type = new PyCollectionTypeImpl(((PyClassType)firstType).getPyClass(), false, elementTypes);\n              return result.withType(type);\n            }\n            return EMPTY_RESULT;\n          }\n        })\n        .or(classType.thenSkip(op(\"of\")).then(simpleExpr)\n              .map(new Function<Pair<ParseResult, ParseResult>, ParseResult>() {\n                @Override\n                public ParseResult fun(Pair<ParseResult, ParseResult> value) {\n                  final ParseResult firstResult = value.getFirst();\n                  final ParseResult secondResult = value.getSecond();\n                  final ParseResult result = firstResult.merge(secondResult);\n                  final PyType firstType = firstResult.getType();\n                  final PyType secondType = secondResult.getType();\n                  if (firstType != null) {\n                    if (firstType instanceof PyClassType && secondType != null) {\n                      return result.withType(new PyCollectionTypeImpl(((PyClassType)firstType).getPyClass(), false,\n                                                                      Collections.singletonList(secondType)));\n                    }\n                    return result.withType(firstType);\n                  }\n                  return EMPTY_RESULT;\n                }\n              }))\n        .or(classType.thenSkip(op(\"from\")).then(simpleExpr).thenSkip(op(\"to\")).then(simpleExpr)\n              .map(new Function<Pair<Pair<ParseResult, ParseResult>, ParseResult>, ParseResult>() {\n                @Override\n                public ParseResult fun(Pair<Pair<ParseResult, ParseResult>, ParseResult> value) {\n                  final Pair<ParseResult, ParseResult> firstPair = value.getFirst();\n                  final ParseResult first = firstPair.getFirst();\n                  final ParseResult second = firstPair.getSecond();\n                  final ParseResult third = value.getSecond();\n                  final PyType firstType = first.getType();\n                  if (firstType instanceof PyClassType) {\n                    final List<PyType> elementTypes = Arrays.asList(second.getType(), third.getType());\n                    final PyCollectionTypeImpl type = new PyCollectionTypeImpl(((PyClassType)firstType).getPyClass(), false,\n                                                                               elementTypes);\n                    return first.merge(second).merge(third).withType(type);\n                  }\n                  return EMPTY_RESULT;\n                }\n              }))\n        .named(\"param-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> callableExpr =\n      op(\"(\").skipThen(maybe(typeExpr.then(many(op(\",\").skipThen(typeExpr))))).thenSkip(op(\")\")).thenSkip(op(\"->\")).then(typeExpr)\n        .map(\n          new Function<Pair<Pair<ParseResult, List<ParseResult>>, ParseResult>, ParseResult>() {\n            @Override\n            public ParseResult fun(Pair<Pair<ParseResult, List<ParseResult>>, ParseResult> value) {\n              final List<PyCallableParameter> parameters = new ArrayList<PyCallableParameter>();\n              final ParseResult returnResult = value.getSecond();\n              ParseResult result;\n              final Pair<ParseResult, List<ParseResult>> firstPair = value.getFirst();\n              if (firstPair != null) {\n                final ParseResult first = firstPair.getFirst();\n                final List<ParseResult> second = firstPair.getSecond();\n                result = first;\n                parameters.add(new PyCallableParameterImpl(null, first.getType()));\n                for (ParseResult r : second) {\n                  result = result.merge(r);\n                  parameters.add(new PyCallableParameterImpl(null, r.getType()));\n                }\n                result = result.merge(returnResult);\n              }\n              else {\n                result = returnResult;\n              }\n              return result.withType(new PyCallableTypeImpl(parameters, returnResult.getType()));\n            }\n          })\n        .named(\"callable-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> singleExpr =\n      paramExpr\n        .or(callableExpr)\n        .or(simpleExpr)\n        .named(\"single-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> unionExpr =\n      singleExpr.then(many(op(\"or\").or(op(\"|\")).skipThen(singleExpr)))\n        .map(new Function<Pair<ParseResult, List<ParseResult>>, ParseResult>() {\n          @Override\n          public ParseResult fun(Pair<ParseResult, List<ParseResult>> value) {\n            final ParseResult first = value.getFirst();\n            final List<ParseResult> rest = value.getSecond();\n            if (rest.isEmpty()) {\n              return first;\n            }\n            final List<PyType> types = new ArrayList<PyType>();\n            types.add(first.getType());\n            ParseResult result = first;\n            for (ParseResult r : rest) {\n              types.add(r.getType());\n              result = result.merge(r);\n            }\n            return result.withType(PyUnionType.union(types));\n          }\n        })\n        .named(\"union-expr\");\n\n    typeExpr\n      .define(unionExpr)\n      .named(\"type-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> typeFile =\n      typeExpr\n        .endOfInput()\n        .named(\"type-file\");\n\n    try {\n      return typeFile.parse(tokenize(type));\n    }\n    catch (ParserException e) {\n      return EMPTY_RESULT;\n    }\n  }","id":44356,"modified_method":"/**\n   * @param  anchor should never be null or null will be returned\n   */\n  @NotNull\n  public static ParseResult parse(@Nullable final PsiElement anchor, @NotNull String type) {\n    if (anchor == null || !anchor.isValid()) {\n      return EMPTY_RESULT;\n    }\n\n    final ForwardDeclaration<ParseResult, PyElementType> typeExpr = ForwardDeclaration.create();\n\n    final FunctionalParser<ParseResult, PyElementType> classType =\n      token(IDENTIFIER).then(many(op(\".\").skipThen(token(IDENTIFIER))))\n        .map(new MakeSimpleType(anchor))\n        .cached()\n        .named(\"class-type\");\n\n    final FunctionalParser<ParseResult, PyElementType> tupleType =\n      op(\"(\").skipThen(typeExpr).then(many(op(\",\").skipThen(typeExpr))).thenSkip(op(\")\"))\n        .map(value -> {\n          ParseResult result = value.getFirst();\n          final List<ParseResult> rest = value.getSecond();\n          if (rest.isEmpty()) {\n            return result;\n          }\n          final List<PyType> types = new ArrayList<PyType>();\n          types.add(result.getType());\n          for (ParseResult r : rest) {\n            result = result.merge(r);\n            types.add(r.getType());\n          }\n          return result.withType(PyTupleType.create(anchor, types.toArray(new PyType[types.size()])));\n        })\n        .named(\"tuple-type\");\n\n    final FunctionalParser<ParseResult, PyElementType> typeParameter =\n      token(PARAMETER).then(maybe(op(\"<=\").skipThen(typeExpr)))\n        .map(value -> {\n          final Token<PyElementType> token = value.getFirst();\n          final String name = token.getText().toString();\n          final TextRange range = token.getRange();\n          final ParseResult boundResult = value.getSecond();\n          if (boundResult != null) {\n            final PyGenericType type1 = new PyGenericType(name, boundResult.getType());\n            final ParseResult result = new ParseResult(null, type1, range);\n            return result.merge(boundResult).withType(type1);\n          }\n          return new ParseResult(null, new PyGenericType(name, null), range);\n        })\n        .named(\"type-parameter\");\n\n    final FunctionalParser<ParseResult, PyElementType> simpleExpr =\n      classType\n        .or(tupleType)\n        .or(typeParameter)\n        .named(\"simple-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> paramExpr =\n      classType.thenSkip(op(\"[\")).then(typeExpr).then(many(op(\",\").skipThen(typeExpr))).thenSkip(op(\"]\"))\n        .map(value -> {\n          final Pair<ParseResult, ParseResult> firstPair = value.getFirst();\n          final ParseResult first = firstPair.getFirst();\n          final ParseResult second = firstPair.getSecond();\n          final List<ParseResult> third = value.getSecond();\n          final PyType firstType = first.getType();\n          final List<PyType> typesInBrackets = new ArrayList<PyType>();\n          typesInBrackets.add(second.getType());\n          ParseResult result = first;\n          result = result.merge(second);\n          for (ParseResult r : third) {\n            typesInBrackets.add(r.getType());\n            result = result.merge(r);\n          }\n          final List<PyType> elementTypes = third.isEmpty() ? Collections.singletonList(second.getType()) : typesInBrackets;\n          final PsiElement resolved = first.getElement();\n          if (resolved != null) {\n            final PyType typingType = PyTypingTypeProvider.getType(resolved, elementTypes);\n            if (typingType != null) {\n              return result.withType(typingType);\n            }\n          }\n          if (firstType instanceof PyClassType) {\n            final PyType type1 = new PyCollectionTypeImpl(((PyClassType)firstType).getPyClass(), false, elementTypes);\n            return result.withType(type1);\n          }\n          return EMPTY_RESULT;\n        })\n        .or(classType.thenSkip(op(\"of\")).then(simpleExpr)\n              .map(value -> {\n                final ParseResult firstResult = value.getFirst();\n                final ParseResult secondResult = value.getSecond();\n                final ParseResult result = firstResult.merge(secondResult);\n                final PyType firstType = firstResult.getType();\n                final PyType secondType = secondResult.getType();\n                if (firstType != null) {\n                  if (firstType instanceof PyClassType && secondType != null) {\n                    return result.withType(new PyCollectionTypeImpl(((PyClassType)firstType).getPyClass(), false,\n                                                                    Collections.singletonList(secondType)));\n                  }\n                  return result.withType(firstType);\n                }\n                return EMPTY_RESULT;\n              }))\n        .or(classType.thenSkip(op(\"from\")).then(simpleExpr).thenSkip(op(\"to\")).then(simpleExpr)\n              .map(value -> {\n                final Pair<ParseResult, ParseResult> firstPair = value.getFirst();\n                final ParseResult first = firstPair.getFirst();\n                final ParseResult second = firstPair.getSecond();\n                final ParseResult third = value.getSecond();\n                final PyType firstType = first.getType();\n                if (firstType instanceof PyClassType) {\n                  final List<PyType> elementTypes = Arrays.asList(second.getType(), third.getType());\n                  final PyCollectionTypeImpl type1 = new PyCollectionTypeImpl(((PyClassType)firstType).getPyClass(), false,\n                                                                              elementTypes);\n                  return first.merge(second).merge(third).withType(type1);\n                }\n                return EMPTY_RESULT;\n              }))\n        .named(\"param-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> callableExpr =\n      op(\"(\").skipThen(maybe(typeExpr.then(many(op(\",\").skipThen(typeExpr))))).thenSkip(op(\")\")).thenSkip(op(\"->\")).then(typeExpr)\n        .map(\n          value -> {\n            final List<PyCallableParameter> parameters = new ArrayList<PyCallableParameter>();\n            final ParseResult returnResult = value.getSecond();\n            ParseResult result;\n            final Pair<ParseResult, List<ParseResult>> firstPair = value.getFirst();\n            if (firstPair != null) {\n              final ParseResult first = firstPair.getFirst();\n              final List<ParseResult> second = firstPair.getSecond();\n              result = first;\n              parameters.add(new PyCallableParameterImpl(null, first.getType()));\n              for (ParseResult r : second) {\n                result = result.merge(r);\n                parameters.add(new PyCallableParameterImpl(null, r.getType()));\n              }\n              result = result.merge(returnResult);\n            }\n            else {\n              result = returnResult;\n            }\n            return result.withType(new PyCallableTypeImpl(parameters, returnResult.getType()));\n          })\n        .named(\"callable-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> singleExpr =\n      paramExpr\n        .or(callableExpr)\n        .or(simpleExpr)\n        .named(\"single-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> unionExpr =\n      singleExpr.then(many(op(\"or\").or(op(\"|\")).skipThen(singleExpr)))\n        .map(value -> {\n          final ParseResult first = value.getFirst();\n          final List<ParseResult> rest = value.getSecond();\n          if (rest.isEmpty()) {\n            return first;\n          }\n          final List<PyType> types = new ArrayList<PyType>();\n          types.add(first.getType());\n          ParseResult result = first;\n          for (ParseResult r : rest) {\n            types.add(r.getType());\n            result = result.merge(r);\n          }\n          return result.withType(PyUnionType.union(types));\n        })\n        .named(\"union-expr\");\n\n    typeExpr\n      .define(unionExpr)\n      .named(\"type-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> typeFile =\n      typeExpr\n        .endOfInput()\n        .named(\"type-file\");\n\n    try {\n      return typeFile.parse(tokenize(type));\n    }\n    catch (ParserException e) {\n      return EMPTY_RESULT;\n    }\n  }","commit_id":"6ee2663efeabe38775417c3b7decf8f48d5653b7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static ParseResult parsePep484FunctionTypeComment(@NotNull final PsiElement anchor, @NotNull String text) {\n    final ForwardDeclaration<ParseResult, PyElementType> typeExpr = ForwardDeclaration.create();\n\n    final FunctionalParser<ParseResult, PyElementType> classType =\n      token(IDENTIFIER).then(many(op(\".\").skipThen(token(IDENTIFIER))))\n                       .map(new MakeSimpleType(anchor))\n                       .cached()\n                       .named(\"class-type\");\n\n    final FunctionalParser<ParseResult, PyElementType> paramExpr =\n      classType.thenSkip(op(\"[\")).then(typeExpr).then(many(op(\",\").skipThen(typeExpr))).thenSkip(op(\"]\"))\n               .map(new Function<Pair<Pair<ParseResult, ParseResult>, List<ParseResult>>, ParseResult>() {\n                 @Override\n                 public ParseResult fun(Pair<Pair<ParseResult, ParseResult>, List<ParseResult>> value) {\n                   final Pair<ParseResult, ParseResult> firstPair = value.getFirst();\n                   final ParseResult first = firstPair.getFirst();\n                   final ParseResult second = firstPair.getSecond();\n                   final List<ParseResult> third = value.getSecond();\n                   final List<PyType> typesInBrackets = new ArrayList<PyType>();\n                   typesInBrackets.add(second.getType());\n                   ParseResult result = first;\n                   result = result.merge(second);\n                   for (ParseResult r : third) {\n                     typesInBrackets.add(r.getType());\n                     result = result.merge(r);\n                   }\n                   final List<PyType> elementTypes = third.isEmpty() ? Collections.singletonList(second.getType()) : typesInBrackets;\n                   final PsiElement resolved = first.getElement();\n                   if (resolved != null) {\n                     final PyType typingType = PyTypingTypeProvider.getType(resolved, elementTypes);\n                     if (typingType != null) {\n                       return result.withType(typingType);\n                     }\n                   }\n                   return EMPTY_RESULT;\n                 }\n               })\n               .named(\"param-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> singleExpr =\n      paramExpr\n        .or(classType)\n        .named(\"single-expr\");\n\n    typeExpr\n      .define(singleExpr)\n      .named(\"type-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> argExpr =\n      maybe(op(\"*\")).then(maybe(op(\"*\"))).then(typeExpr)\n        .map(new Function<Pair<Pair<Token<PyElementType>, Token<PyElementType>>, ParseResult>, ParseResult>() {\n          @Override\n          public ParseResult fun(Pair<Pair<Token<PyElementType>, Token<PyElementType>>, ParseResult> pair) {\n            final ParseResult paramResult = pair.getSecond();\n            final PyType paramType = paramResult.getType();\n            int starCount = 0;\n            if (pair.getFirst().getFirst() != null) {\n              starCount++;\n            }\n            if (pair.getFirst().getSecond() != null) {\n              starCount++;\n            }\n            if (starCount == 0) {\n              return paramResult;\n            }\n            else if (starCount == 1) {\n              final PyClassType tupleType = PyBuiltinCache.getInstance(anchor).getTupleType();;\n              // TODO How to represent unbound homogeneous tuple?\n              if (tupleType != null) {\n                return paramResult.withType(tupleType);\n              }\n              return EMPTY_RESULT;\n            }\n            else if (starCount == 2) {\n              final PyBuiltinCache builtinCache = PyBuiltinCache.getInstance(anchor);\n              final PyClassType type = builtinCache.getDictType();\n              if (type != null) {\n                final PyClass pyClass = type.getPyClass();\n                return paramResult.withType(new PyCollectionTypeImpl(pyClass, false,\n                                                                     Arrays.asList(builtinCache.getStrType(), paramType)));\n              }\n              return EMPTY_RESULT;\n            }\n            return EMPTY_RESULT;\n          }\n        })\n        .named(\"param-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> funcExpr =\n      op(\"(\").skipThen(maybe(argExpr.then(many(op(\",\").skipThen(argExpr))))).thenSkip(op(\")\")).thenSkip(op(\"->\")).then(typeExpr)\n             .map(new Function<Pair<Pair<ParseResult, List<ParseResult>>, ParseResult>, ParseResult>() {\n               @Override\n               public ParseResult fun(Pair<Pair<ParseResult, List<ParseResult>>, ParseResult> value) {\n                 final List<PyCallableParameter> parameters = new ArrayList<PyCallableParameter>();\n                 final ParseResult returnResult = value.getSecond();\n                 ParseResult result;\n                 final Pair<ParseResult, List<ParseResult>> firstPair = value.getFirst();\n                 if (firstPair != null) {\n                   final ParseResult first = firstPair.getFirst();\n                   final List<ParseResult> second = firstPair.getSecond();\n                   result = first;\n                   parameters.add(new PyCallableParameterImpl(null, first.getType()));\n                   for (ParseResult r : second) {\n                     result = result.merge(r);\n                     parameters.add(new PyCallableParameterImpl(null, r.getType()));\n                   }\n                   result = result.merge(returnResult);\n                 }\n                 else {\n                   result = returnResult;\n                 }\n                 return result.withType(new PyCallableTypeImpl(parameters, returnResult.getType()));\n               }\n             })\n             .named(\"func-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> typeFile =\n      funcExpr\n        .endOfInput()\n        .named(\"type-file\");\n\n    try {\n      return typeFile.parse(tokenize(text));\n    }\n    catch (ParserException e) {\n      return EMPTY_RESULT;\n    }\n  }","id":44357,"modified_method":"@NotNull\n  public static ParseResult parsePep484FunctionTypeComment(@NotNull final PsiElement anchor, @NotNull String text) {\n    final ForwardDeclaration<ParseResult, PyElementType> typeExpr = ForwardDeclaration.create();\n\n    final FunctionalParser<ParseResult, PyElementType> classType =\n      token(IDENTIFIER).then(many(op(\".\").skipThen(token(IDENTIFIER))))\n                       .map(new MakeSimpleType(anchor))\n                       .cached()\n                       .named(\"class-type\");\n\n    final FunctionalParser<ParseResult, PyElementType> paramExpr =\n      classType.thenSkip(op(\"[\")).then(typeExpr).then(many(op(\",\").skipThen(typeExpr))).thenSkip(op(\"]\"))\n               .map(value -> {\n                 final Pair<ParseResult, ParseResult> firstPair = value.getFirst();\n                 final ParseResult first = firstPair.getFirst();\n                 final ParseResult second = firstPair.getSecond();\n                 final List<ParseResult> third = value.getSecond();\n                 final List<PyType> typesInBrackets = new ArrayList<PyType>();\n                 typesInBrackets.add(second.getType());\n                 ParseResult result = first;\n                 result = result.merge(second);\n                 for (ParseResult r : third) {\n                   typesInBrackets.add(r.getType());\n                   result = result.merge(r);\n                 }\n                 final List<PyType> elementTypes = third.isEmpty() ? Collections.singletonList(second.getType()) : typesInBrackets;\n                 final PsiElement resolved = first.getElement();\n                 if (resolved != null) {\n                   final PyType typingType = PyTypingTypeProvider.getType(resolved, elementTypes);\n                   if (typingType != null) {\n                     return result.withType(typingType);\n                   }\n                 }\n                 return EMPTY_RESULT;\n               })\n               .named(\"param-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> singleExpr =\n      paramExpr\n        .or(classType)\n        .named(\"single-expr\");\n\n    typeExpr\n      .define(singleExpr)\n      .named(\"type-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> argExpr =\n      maybe(op(\"*\")).then(maybe(op(\"*\"))).then(typeExpr)\n        .map(pair -> {\n          final ParseResult paramResult = pair.getSecond();\n          final PyType paramType = paramResult.getType();\n          int starCount = 0;\n          if (pair.getFirst().getFirst() != null) {\n            starCount++;\n          }\n          if (pair.getFirst().getSecond() != null) {\n            starCount++;\n          }\n          if (starCount == 0) {\n            return paramResult;\n          }\n          else if (starCount == 1) {\n            final PyClassType tupleType = PyBuiltinCache.getInstance(anchor).getTupleType();;\n            // TODO How to represent unbound homogeneous tuple?\n            if (tupleType != null) {\n              return paramResult.withType(tupleType);\n            }\n            return EMPTY_RESULT;\n          }\n          else if (starCount == 2) {\n            final PyBuiltinCache builtinCache = PyBuiltinCache.getInstance(anchor);\n            final PyClassType type = builtinCache.getDictType();\n            if (type != null) {\n              final PyClass pyClass = type.getPyClass();\n              return paramResult.withType(new PyCollectionTypeImpl(pyClass, false,\n                                                                   Arrays.asList(builtinCache.getStrType(), paramType)));\n            }\n            return EMPTY_RESULT;\n          }\n          return EMPTY_RESULT;\n        })\n        .named(\"param-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> funcExpr =\n      op(\"(\").skipThen(maybe(argExpr.then(many(op(\",\").skipThen(argExpr))))).thenSkip(op(\")\")).thenSkip(op(\"->\")).then(typeExpr)\n             .map(value -> {\n               final List<PyCallableParameter> parameters = new ArrayList<PyCallableParameter>();\n               final ParseResult returnResult = value.getSecond();\n               ParseResult result;\n               final Pair<ParseResult, List<ParseResult>> firstPair = value.getFirst();\n               if (firstPair != null) {\n                 final ParseResult first = firstPair.getFirst();\n                 final List<ParseResult> second = firstPair.getSecond();\n                 result = first;\n                 parameters.add(new PyCallableParameterImpl(null, first.getType()));\n                 for (ParseResult r : second) {\n                   result = result.merge(r);\n                   parameters.add(new PyCallableParameterImpl(null, r.getType()));\n                 }\n                 result = result.merge(returnResult);\n               }\n               else {\n                 result = returnResult;\n               }\n               return result.withType(new PyCallableTypeImpl(parameters, returnResult.getType()));\n             })\n             .named(\"func-expr\");\n\n    final FunctionalParser<ParseResult, PyElementType> typeFile =\n      funcExpr\n        .endOfInput()\n        .named(\"type-file\");\n\n    try {\n      return typeFile.parse(tokenize(text));\n    }\n    catch (ParserException e) {\n      return EMPTY_RESULT;\n    }\n  }","commit_id":"6ee2663efeabe38775417c3b7decf8f48d5653b7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected synchronized void onServerPoolMemberChanged(Entity member) {\n        if (log.isTraceEnabled()) log.trace(\"For {}, considering membership of {} which is in locations {}\",\n                new Object[]{this, member, member.getLocations()});\n\n        Map<Entity, String> nodes = getAttribute(RIAK_CLUSTER_NODES);\n        if (belongsInServerPool(member)) {\n            // TODO can we discover the nodes by asking the riak cluster, rather than assuming what we add will be in there?\n            // TODO and can we do join as part of node starting?\n\n            if (nodes == null) nodes = Maps.newLinkedHashMap();\n            String riakName = getRiakName(member);\n\n            if (riakName == null) {\n                log.error(\"Unable to get riak name for node: {}\", member.getId());\n            } else {\n                //flag a first node to be the first node in the riak cluster.\n                if (!isFirstNodeSet.get()) {\n                    nodes.put(member, riakName);\n                    setAttribute(RIAK_CLUSTER_NODES, nodes);\n\n                    ((EntityInternal) member).setAttribute(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, Boolean.TRUE);\n                    isFirstNodeSet.set(true);\n\n                    log.info(\"Adding riak node {}: {}; {} to cluster\", new Object[]{this, member, getRiakName(member)});\n\n                } else {\n\n                    //TODO: be wary of erreneous nodes but are still flagged 'in cluster'\n                    //add the new node to be part of the riak cluster.\n                    Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), new Predicate<Entity>() {\n                        @Override\n                        public boolean apply(@Nullable Entity node) {\n                            return (node instanceof RiakNode && hasMemberJoinedCluster(node));\n                        }\n                    });\n\n                    if (anyNodeInCluster.isPresent()) {\n                        if (!nodes.containsKey(member) && !hasMemberJoinedCluster(member)) {\n\n\n                            String anyNodeName = anyNodeInCluster.get().getAttribute(RiakNode.RIAK_NODE_NAME);\n                            Entities.invokeEffectorWithArgs(this, member, RiakNode.JOIN_RIAK_CLUSTER, anyNodeName);\n                            if (getAttribute(IS_CLUSTER_INIT)) {\n                                Entities.invokeEffector(RiakClusterImpl.this, anyNodeInCluster.get(), RiakNode.COMMIT_RIAK_CLUSTER);\n                            }\n                            nodes.put(member, riakName);\n                            setAttribute(RIAK_CLUSTER_NODES, nodes);\n                            log.info(\"Adding riak node {}: {}; {} to cluster\", new Object[]{this, member, getRiakName(member)});\n                        }\n                    } else {\n                        log.error(\"entity {}: is not present\", member.getId());\n                    }\n                }\n            }\n        } else {\n            if (nodes != null && nodes.containsKey(member)) {\n                final Entity memberToBeRemoved = member;\n\n                Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), new Predicate<Entity>() {\n\n                    @Override\n                    public boolean apply(@Nullable Entity node) {\n                        return (node instanceof RiakNode && hasMemberJoinedCluster(node) && !node.equals(memberToBeRemoved));\n                    }\n                });\n                if (anyNodeInCluster.isPresent()) {\n                    Entities.invokeEffectorWithArgs(this, anyNodeInCluster.get(), RiakNode.LEAVE_RIAK_CLUSTER, getRiakName(memberToBeRemoved));\n                }\n\n                nodes.remove(member);\n                setAttribute(RIAK_CLUSTER_NODES, nodes);\n                log.info(\"Removing riak node {}: {}; {} from cluster\", new Object[]{this, member, getRiakName(member)});\n\n            }\n        }\n        \n        ServiceNotUpLogic.updateNotUpIndicatorRequiringNonEmptyMap(this, RIAK_CLUSTER_NODES);\n        if (log.isTraceEnabled()) log.trace(\"Done {} checkEntity {}\", this, member);\n    }","id":44358,"modified_method":"protected synchronized void onServerPoolMemberChanged(Entity member) {\n        if (log.isTraceEnabled()) log.trace(\"For {}, considering membership of {} which is in locations {}\",\n                new Object[]{this, member, member.getLocations()});\n\n        Map<Entity, String> nodes = getAttribute(RIAK_CLUSTER_NODES);\n        if (belongsInServerPool(member)) {\n            // TODO can we discover the nodes by asking the riak cluster, rather than assuming what we add will be in there?\n            // TODO and can we do join as part of node starting?\n\n            if (nodes == null) {\n                nodes = Maps.newLinkedHashMap();\n            }\n            \n            String riakName = getRiakName(member);\n            Preconditions.checkNotNull(riakName);\n\n            // flag a first node to be the first node in the riak cluster.\n            if (!isFirstNodeSet.getAndSet(true)) {\n                nodes.put(member, riakName);\n                setAttribute(RIAK_CLUSTER_NODES, nodes);\n\n                ((EntityInternal) member).setAttribute(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, Boolean.TRUE);\n\n                log.info(\"Adding riak node {}: {}; {} to cluster\", new Object[] { this, member, getRiakName(member) });\n            } else {\n                // TODO: be wary of erroneous nodes but are still flagged 'in cluster'\n                // add the new node to be part of the riak cluster.\n                Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), new Predicate<Entity>() {\n                    @Override\n                    public boolean apply(@Nullable Entity node) {\n                        return (node instanceof RiakNode && hasMemberJoinedCluster(node));\n                    }\n                });\n\n                if (anyNodeInCluster.isPresent()) {\n                    if (!nodes.containsKey(member) && !hasMemberJoinedCluster(member)) {\n\n                        String anyNodeName = anyNodeInCluster.get().getAttribute(RiakNode.RIAK_NODE_NAME);\n                        Entities.invokeEffectorWithArgs(this, member, RiakNode.JOIN_RIAK_CLUSTER, anyNodeName);\n                        if (getAttribute(IS_CLUSTER_INIT)) {\n                            Entities.invokeEffector(RiakClusterImpl.this, anyNodeInCluster.get(), RiakNode.COMMIT_RIAK_CLUSTER);\n                        }\n                        nodes.put(member, riakName);\n                        setAttribute(RIAK_CLUSTER_NODES, nodes);\n                        log.info(\"Adding riak node {}: {}; {} to cluster\", new Object[] { this, member, getRiakName(member) });\n                    }\n                } else {\n                    log.error(\"isFirstNodeSet , but no cluster members found to add {}\", member.getId());\n                }\n            }\n        } else {\n            if (nodes != null && nodes.containsKey(member)) {\n                final Entity memberToBeRemoved = member;\n\n                Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), new Predicate<Entity>() {\n\n                    @Override\n                    public boolean apply(@Nullable Entity node) {\n                        return (node instanceof RiakNode && hasMemberJoinedCluster(node) && !node.equals(memberToBeRemoved));\n                    }\n                });\n                if (anyNodeInCluster.isPresent()) {\n                    Entities.invokeEffectorWithArgs(this, anyNodeInCluster.get(), RiakNode.LEAVE_RIAK_CLUSTER, getRiakName(memberToBeRemoved));\n                }\n\n                nodes.remove(member);\n                setAttribute(RIAK_CLUSTER_NODES, nodes);\n                log.info(\"Removing riak node {}: {}; {} from cluster\", new Object[]{this, member, getRiakName(member)});\n\n            }\n        }\n        \n        ServiceNotUpLogic.updateNotUpIndicatorRequiringNonEmptyMap(this, RIAK_CLUSTER_NODES);\n        if (log.isTraceEnabled()) log.trace(\"Done {} checkEntity {}\", this, member);\n    }","commit_id":"629923bf0288f381a6d89b8249ce0e081333e3e9","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  protected void addCompletions(@NotNull CompletionParameters parameters,\n                                ProcessingContext context,\n                                @NotNull CompletionResultSet result) {\n    if (!isAvailable(parameters)) {\n      return;\n    }\n\n    final ZenCodingGenerator generator = getGenerator();\n    if (!generator.isMyContext(parameters.getPosition(), false) || !generator.isAppliedByDefault(parameters.getPosition())) {\n      return;\n    }\n\n    ZenCodingTemplate zenCodingTemplate = CustomLiveTemplate.EP_NAME.findExtension(ZenCodingTemplate.class);\n    if (zenCodingTemplate == null) {\n      return;\n    }\n\n    final PsiFile file = parameters.getPosition().getContainingFile();\n    final Editor editor = parameters.getEditor();\n\n    final String completionPrefix = result.getPrefixMatcher().getPrefix();\n    final String templatePrefix = LiveTemplateCompletionContributor.findLiveTemplatePrefix(file, editor, completionPrefix);\n\n    if (LiveTemplateCompletionContributor.findApplicableTemplate(file, parameters.getOffset(), templatePrefix) != null) {\n      // exclude perfect matches with existing templates because LiveTemplateCompletionContributor handles it\n      result.restartCompletionOnPrefixChange(StandardPatterns.string().startsWith(templatePrefix));\n      return;\n    }\n\n    final Ref<TemplateImpl> generatedTemplate = new Ref<TemplateImpl>();\n    final CustomTemplateCallback callback = new CustomTemplateCallback(editor, file, false) {\n      @Override\n      public void deleteTemplateKey(String key) {\n      }\n\n      @Override\n      public void startTemplate(Template template, Map<String, String> predefinedValues, TemplateEditingListener listener) {\n        if (template instanceof TemplateImpl && !((TemplateImpl)template).isDeactivated()) {\n          generatedTemplate.set((TemplateImpl)template);\n        }\n      }\n    };\n\n    final Collection<SingleLineEmmetFilter> extraFilters = ContainerUtil.newLinkedList(new SingleLineEmmetFilter());\n    ZenCodingTemplate.expand(templatePrefix, callback, null, generator, extraFilters, false);\n    if (!generatedTemplate.isNull()) {\n      result = result.withPrefixMatcher(templatePrefix);\n      final TemplateImpl template = generatedTemplate.get();\n      template.setKey(templatePrefix);\n      template.setDescription(template.getTemplateText());\n      result.addElement(createLookupElement(zenCodingTemplate, template));\n      result.restartCompletionOnPrefixChange(StandardPatterns.string().startsWith(templatePrefix));\n    }\n  }","id":44359,"modified_method":"@Override\n  protected void addCompletions(@NotNull CompletionParameters parameters,\n                                ProcessingContext context,\n                                @NotNull CompletionResultSet result) {\n    if (LiveTemplateCompletionContributor.shouldShowAllTemplates() || !parameters.isAutoPopup()) {\n      /**\n       * covered with {@link com.intellij.codeInsight.template.impl.LiveTemplateCompletionContributor}\n       */\n      return;\n    }\n\n    ZenCodingTemplate zenCodingTemplate = CustomLiveTemplate.EP_NAME.findExtension(ZenCodingTemplate.class);\n    if (zenCodingTemplate != null) {\n      zenCodingTemplate.addCompletions(parameters, result);\n    }\n  }","commit_id":"312acda27e863307e7eadf86ac7dc78be336e164","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static MultiMap<String, CustomLiveTemplateLookupElement> listApplicableCustomTemplates(@NotNull Editor editor, @NotNull PsiFile file, int offset) {\n    final MultiMap<String, CustomLiveTemplateLookupElement> result = MultiMap.create();\n    CustomTemplateCallback customTemplateCallback = new CustomTemplateCallback(editor, file, false);\n    for (CustomLiveTemplate customLiveTemplate : CustomLiveTemplate.EP_NAME.getExtensions()) {\n      if (customLiveTemplate instanceof CustomLiveTemplateBase && TemplateManagerImpl.isApplicable(customLiveTemplate, editor, file)) {\n        String customTemplatePrefix = ((CustomLiveTemplateBase)customLiveTemplate).computeTemplateKeyWithoutContextChecking(customTemplateCallback);\n        if (customTemplatePrefix != null) {\n          result.putValues(customTemplatePrefix, ((CustomLiveTemplateBase)customLiveTemplate).getLookupElements(file, editor, offset));\n        }\n      }\n    }\n    return result;\n  }","id":44360,"modified_method":"private static MultiMap<String, CustomLiveTemplateLookupElement> listApplicableCustomTemplates(@NotNull Editor editor, @NotNull PsiFile file, int offset) {\n    final MultiMap<String, CustomLiveTemplateLookupElement> result = MultiMap.create();\n    CustomTemplateCallback customTemplateCallback = new CustomTemplateCallback(editor, file, false);\n    for (CustomLiveTemplate customLiveTemplate : CustomLiveTemplate.EP_NAME.getExtensions()) {\n      if (customLiveTemplate instanceof CustomLiveTemplateBase && TemplateManagerImpl.isApplicable(customLiveTemplate, editor, file)) {\n        String customTemplatePrefix = ((CustomLiveTemplateBase)customLiveTemplate).computeTemplateKeyWithoutContextChecking(customTemplateCallback);\n        if (customTemplatePrefix != null) {\n          result.putValues(customTemplatePrefix, ((CustomLiveTemplateBase)customLiveTemplate).getLookupElements(file, editor, offset));\n        }\n      }\n    }\n    return result;\n  }","commit_id":"312acda27e863307e7eadf86ac7dc78be336e164","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LiveTemplateCompletionContributor() {\n    extend(CompletionType.BASIC, PlatformPatterns.psiElement(), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull final CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        final PsiFile file = parameters.getPosition().getContainingFile();\n        if (file instanceof PsiPlainTextFile &&\n            parameters.getEditor().getComponent().getParent() instanceof EditorTextField) {\n          return;\n        }\n\n        final int offset = parameters.getOffset();\n        final List<TemplateImpl> templates = listApplicableTemplates(file, offset);\n        Editor editor = parameters.getEditor();\n        if (showAllTemplates()) {\n          final MultiMap<String, CustomLiveTemplateLookupElement> customTemplates = listApplicableCustomTemplates(editor, file, offset);\n          final Ref<Boolean> templatesShown = Ref.create(false);\n          final CompletionResultSet finalResult = result;\n          result.runRemainingContributors(parameters, new Consumer<CompletionResult>() {\n            @Override\n            public void consume(CompletionResult completionResult) {\n              finalResult.passResult(completionResult);\n              ensureTemplatesShown(templatesShown, templates, customTemplates, finalResult);\n            }\n          });\n\n          ensureTemplatesShown(templatesShown, templates, customTemplates, result);\n          return;\n        }\n\n        if (parameters.getInvocationCount() > 0) return; //only in autopopups for now\n\n        String templatePrefix = findLiveTemplatePrefix(file, editor, result.getPrefixMatcher().getPrefix());\n        final TemplateImpl template = findApplicableTemplate(file, offset, templatePrefix);\n        if (template != null) {\n          result = result.withPrefixMatcher(template.getKey());\n          result.addElement(new LiveTemplateLookupElementImpl(template, true));\n        }\n        for (final TemplateImpl possible : templates) {\n          result.restartCompletionOnPrefixChange(possible.getKey());\n        }\n      }\n    });\n  }","id":44361,"modified_method":"public LiveTemplateCompletionContributor() {\n    extend(CompletionType.BASIC, PlatformPatterns.psiElement(), new CompletionProvider<CompletionParameters>() {\n      @Override\n      protected void addCompletions(@NotNull final CompletionParameters parameters,\n                                    ProcessingContext context,\n                                    @NotNull CompletionResultSet result) {\n        final PsiFile file = parameters.getPosition().getContainingFile();\n        if (file instanceof PsiPlainTextFile &&\n            parameters.getEditor().getComponent().getParent() instanceof EditorTextField) {\n          return;\n        }\n\n        final int offset = parameters.getOffset();\n        final List<TemplateImpl> templates = listApplicableTemplates(file, offset);\n        Editor editor = parameters.getEditor();\n        if (showAllTemplates()) {\n          final AtomicBoolean templatesShown = new AtomicBoolean(false);\n          final CompletionResultSet finalResult = result;\n          result.runRemainingContributors(parameters, new Consumer<CompletionResult>() {\n            @Override\n            public void consume(CompletionResult completionResult) {\n              finalResult.passResult(completionResult);\n              ensureTemplatesShown(templatesShown, templates, parameters, finalResult);\n            }\n          });\n\n          ensureTemplatesShown(templatesShown, templates, parameters, result);\n          return;\n        }\n\n        if (parameters.getInvocationCount() > 0) return; //only in autopopups for now\n\n        String templatePrefix = findLiveTemplatePrefix(file, editor, result.getPrefixMatcher().getPrefix());\n        final TemplateImpl template = findApplicableTemplate(file, offset, templatePrefix);\n        if (template != null) {\n          result = result.withPrefixMatcher(template.getKey());\n          result.addElement(new LiveTemplateLookupElementImpl(template, true));\n        }\n        for (final TemplateImpl possible : templates) {\n          result.restartCompletionOnPrefixChange(possible.getKey());\n        }\n      }\n    });\n  }","commit_id":"312acda27e863307e7eadf86ac7dc78be336e164","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void ensureTemplatesShown(Ref<Boolean> templatesShown,\n                                           List<TemplateImpl> templates,\n                                           MultiMap<String, CustomLiveTemplateLookupElement> customTemplates,\n                                           CompletionResultSet result) {\n    if (!templatesShown.get()) {\n      templatesShown.set(true);\n      for (final TemplateImpl possible : templates) {\n        result.addElement(new LiveTemplateLookupElementImpl(possible, false));\n      }\n\n      for (Map.Entry<String, Collection<CustomLiveTemplateLookupElement>> entry : customTemplates.entrySet()) {\n        Collection<CustomLiveTemplateLookupElement> value = entry.getValue();\n        if (!value.isEmpty()) {\n          result.withPrefixMatcher(entry.getKey()).addAllElements(value);\n        }\n      }\n    }\n  }","id":44362,"modified_method":"private static void ensureTemplatesShown(AtomicBoolean templatesShown,\n                                           List<TemplateImpl> templates,\n                                           CompletionParameters parameters, \n                                           CompletionResultSet result) {\n    if (!templatesShown.getAndSet(true)) {\n      for (final TemplateImpl possible : templates) {\n        result.addElement(new LiveTemplateLookupElementImpl(possible, false));\n      }\n\n      PsiFile file = parameters.getPosition().getContainingFile();\n      Editor editor = parameters.getEditor();\n      for (CustomLiveTemplate customLiveTemplate : CustomLiveTemplate.EP_NAME.getExtensions()) {\n        if (customLiveTemplate instanceof CustomLiveTemplateBase && TemplateManagerImpl.isApplicable(customLiveTemplate, editor, file)) {\n          ((CustomLiveTemplateBase)customLiveTemplate).addCompletions(parameters, result);\n        }\n      }\n    }\n  }","commit_id":"312acda27e863307e7eadf86ac7dc78be336e164","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Collection<? extends CustomLiveTemplateLookupElement> getLookupElements(@NotNull PsiFile file, @NotNull Editor editor, int offset) {\n    String key = computeTemplateKeyWithoutContextChecking(editor.getDocument().getCharsSequence(), offset);\n    if (key != null && editor.getCaretModel().getCaretCount() == 1) {\n      Map<String, CustomLiveTemplateLookupElement> result = ContainerUtil.newHashMap();\n      Condition<PostfixTemplate> isApplicationTemplateFunction = createIsApplicationTemplateFunction(key, file, editor);\n      for (Map.Entry<String, PostfixTemplate> entry : myTemplates.entrySet()) {\n        PostfixTemplate postfixTemplate = entry.getValue();\n        if (entry.getKey().startsWith(key) && isApplicationTemplateFunction.value(postfixTemplate)) {\n          result.put(postfixTemplate.getKey(), new PostfixTemplateLookupElement(this, postfixTemplate, postfixTemplate.getKey(), false));\n        }\n      }\n      return result.values();\n    }\n    return super.getLookupElements(file, editor, offset);\n  }","id":44363,"modified_method":"@NotNull\n  @Override\n  public Collection<? extends CustomLiveTemplateLookupElement> getLookupElements(@NotNull PsiFile file, @NotNull Editor editor, int offset) {\n    String key = computeTemplateKeyWithoutContextChecking(editor.getDocument().getCharsSequence(), offset);\n    if (key != null && editor.getCaretModel().getCaretCount() == 1) {\n      Map<String, CustomLiveTemplateLookupElement> result = ContainerUtil.newHashMap();\n      Condition<PostfixTemplate> isApplicationTemplateFunction = createIsApplicationTemplateFunction(key, file, editor);\n      for (Map.Entry<String, PostfixTemplate> entry : myTemplates.entrySet()) {\n        PostfixTemplate postfixTemplate = entry.getValue();\n        if (entry.getKey().startsWith(key) && isApplicationTemplateFunction.value(postfixTemplate)) {\n          result.put(postfixTemplate.getKey(), new PostfixTemplateLookupElement(this, postfixTemplate, entry.getKey(), false));\n        }\n      }\n      return result.values();\n    }\n    return super.getLookupElements(file, editor, offset);\n  }","commit_id":"312acda27e863307e7eadf86ac7dc78be336e164","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void addCompletions(@NotNull CompletionParameters parameters, ProcessingContext context, @NotNull CompletionResultSet result) {\n    if (!isCompletionEnabled(parameters) || LiveTemplateCompletionContributor.shouldShowAllTemplates() ||\n        parameters.getEditor().getCaretModel().getCaretCount() != 1) {\n      /**\n       * disabled or covered with {@link com.intellij.codeInsight.template.impl.LiveTemplateCompletionContributor}\n       */\n      return;\n    }\n\n    PostfixLiveTemplate postfixLiveTemplate = getPostfixLiveTemplate(parameters.getOriginalFile(), parameters.getEditor());\n    if (postfixLiveTemplate != null) {\n      PsiFile file = parameters.getPosition().getContainingFile();\n      final CustomTemplateCallback callback = new CustomTemplateCallback(parameters.getEditor(), file, false);\n      String computedKey = postfixLiveTemplate.computeTemplateKey(callback);\n      if (computedKey != null) {\n        PostfixTemplate template = postfixLiveTemplate.getTemplateByKey(computedKey);\n        if (template != null) {\n          result = result.withPrefixMatcher(computedKey);\n          result.addElement(new PostfixTemplateLookupElement(postfixLiveTemplate, template, computedKey, true));\n        }\n      }\n\n      CharSequence documentContent = parameters.getEditor().getDocument().getCharsSequence();\n      String possibleKey = postfixLiveTemplate.computeTemplateKeyWithoutContextChecking(documentContent, parameters.getOffset());\n      if (possibleKey != null) {\n        result = result.withPrefixMatcher(possibleKey);\n        result.restartCompletionOnPrefixChange(StandardPatterns.string().oneOf(postfixLiveTemplate.getAllTemplateKeys()));\n      }\n    }\n  }","id":44364,"modified_method":"@Override\n  protected void addCompletions(@NotNull CompletionParameters parameters, ProcessingContext context, @NotNull CompletionResultSet result) {\n    if (!isCompletionEnabled(parameters) || LiveTemplateCompletionContributor.shouldShowAllTemplates() ||\n        parameters.getEditor().getCaretModel().getCaretCount() != 1) {\n      /**\n       * disabled or covered with {@link com.intellij.codeInsight.template.impl.LiveTemplateCompletionContributor}\n       */\n      return;\n    }\n\n    PostfixLiveTemplate postfixLiveTemplate = getPostfixLiveTemplate(parameters.getOriginalFile(), parameters.getEditor());\n    if (postfixLiveTemplate != null) {\n      postfixLiveTemplate.addCompletions(parameters, result.withPrefixMatcher(new MyPrefixMatcher(result.getPrefixMatcher().getPrefix())));\n      CharSequence documentContent = parameters.getEditor().getDocument().getCharsSequence();\n      String possibleKey = postfixLiveTemplate.computeTemplateKeyWithoutContextChecking(documentContent, parameters.getOffset());\n      if (possibleKey != null) {\n        result = result.withPrefixMatcher(possibleKey);\n        result.restartCompletionOnPrefixChange(StandardPatterns.string().oneOf(postfixLiveTemplate.getAllTemplateKeys()));\n      }\n    }\n  }","commit_id":"312acda27e863307e7eadf86ac7dc78be336e164","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public XmlCompletionContributor() {\n    extend(CompletionType.BASIC, psiElement().inside(XmlPatterns.xmlFile()), new XmlEmmetAbbreviationCompletionProvider());\n    extend(CompletionType.BASIC,\n           psiElement().inside(XmlPatterns.xmlAttributeValue()),\n           new CompletionProvider<CompletionParameters>() {\n             @Override\n             protected void addCompletions(@NotNull CompletionParameters parameters,\n                                           ProcessingContext context,\n                                           @NotNull final CompletionResultSet result) {\n               final XmlAttributeValue attributeValue = PsiTreeUtil.getParentOfType(parameters.getPosition(), XmlAttributeValue.class, false);\n               if (attributeValue == null) {\n                 // we are injected, only getContext() returns attribute value\n                 return;\n               }\n\n               final Set<String> usedWords = new THashSet<String>();\n               final Ref<Boolean> addWordVariants = Ref.create(true);\n               result.runRemainingContributors(parameters, new Consumer<CompletionResult>() {\n                 public void consume(CompletionResult r) {\n                   if (r.getLookupElement().getUserData(WORD_COMPLETION_COMPATIBLE) == null) {\n                     addWordVariants.set(false);\n                   }\n                   usedWords.add(r.getLookupElement().getLookupString());\n                   result.passResult(r.withLookupElement(LookupElementDecorator.withInsertHandler(r.getLookupElement(), QUOTE_EATER)));\n                 }\n               });\n               if (addWordVariants.get().booleanValue()) {\n                 addWordVariants.set(attributeValue.getReferences().length == 0);\n               }\n\n               if (addWordVariants.get().booleanValue() && parameters.getInvocationCount() > 0) {\n                 WordCompletionContributor.addWordCompletionVariants(result, parameters, usedWords);\n               }\n             }\n           });\n  }","id":44365,"modified_method":"public XmlCompletionContributor() {\n    extend(CompletionType.BASIC, psiElement().inside(XmlPatterns.xmlFile()), new EmmetAbbreviationCompletionProvider());\n    extend(CompletionType.BASIC,\n           psiElement().inside(XmlPatterns.xmlAttributeValue()),\n           new CompletionProvider<CompletionParameters>() {\n             @Override\n             protected void addCompletions(@NotNull CompletionParameters parameters,\n                                           ProcessingContext context,\n                                           @NotNull final CompletionResultSet result) {\n               final XmlAttributeValue attributeValue = PsiTreeUtil.getParentOfType(parameters.getPosition(), XmlAttributeValue.class, false);\n               if (attributeValue == null) {\n                 // we are injected, only getContext() returns attribute value\n                 return;\n               }\n\n               final Set<String> usedWords = new THashSet<String>();\n               final Ref<Boolean> addWordVariants = Ref.create(true);\n               result.runRemainingContributors(parameters, new Consumer<CompletionResult>() {\n                 public void consume(CompletionResult r) {\n                   if (r.getLookupElement().getUserData(WORD_COMPLETION_COMPATIBLE) == null) {\n                     addWordVariants.set(false);\n                   }\n                   usedWords.add(r.getLookupElement().getLookupString());\n                   result.passResult(r.withLookupElement(LookupElementDecorator.withInsertHandler(r.getLookupElement(), QUOTE_EATER)));\n                 }\n               });\n               if (addWordVariants.get().booleanValue()) {\n                 addWordVariants.set(attributeValue.getReferences().length == 0);\n               }\n\n               if (addWordVariants.get().booleanValue() && parameters.getInvocationCount() > 0) {\n                 WordCompletionContributor.addWordCompletionVariants(result, parameters, usedWords);\n               }\n             }\n           });\n  }","commit_id":"312acda27e863307e7eadf86ac7dc78be336e164","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n        public void run() {\n            MsgData msg;\n            _alive=true;\n            while (_alive) {\n                try {\n                    msg = _msgs.take();\n                } catch (InterruptedException ie) {\n                    _log.debug(\"I2PSessionMuxedImpl.run() InterruptedException \" + String.valueOf(_msgs.size()) + \" Messages, Alive \" + _alive.toString());\n                    continue;\n                }\n                if (msg.size == POISON_SIZE) {\n                    // System.out.println(\"I2PSessionMuxedImpl.run() POISONED\");\n                    break;\n                }\n                try {\n                    _demultiplexer.messageAvailable(I2PSessionMuxedImpl.this,\n                        msg.id, msg.size, msg.proto, msg.fromPort, msg.toPort);\n                } catch (Exception e) {\n                    _log.error(\"Error notifying app of message availability\");\n                }\n            }\n        }","id":44366,"modified_method":"@Override\n        public void run() {\n            MsgData msg;\n            _alive=true;\n            while (_alive) {\n                try {\n                    msg = _msgs.take();\n                } catch (InterruptedException ie) {\n                    _log.debug(\"I2PSessionMuxedImpl.run() InterruptedException \" + String.valueOf(_msgs.size()) + \" Messages, Alive \" + _alive);\n                    continue;\n                }\n                if (msg.size == POISON_SIZE) {\n                    // System.out.println(\"I2PSessionMuxedImpl.run() POISONED\");\n                    break;\n                }\n                try {\n                    _demultiplexer.messageAvailable(I2PSessionMuxedImpl.this,\n                        msg.id, msg.size, msg.proto, msg.fromPort, msg.toPort);\n                } catch (Exception e) {\n                    _log.error(\"Error notifying app of message availability\");\n                }\n            }\n        }","commit_id":"66a292a9c6c8a083794db9a839a50a598cd407ce","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"@Override\n        public void stopNotifying() {\n            boolean again = true;\n            synchronized (stopping) {\n                if(!stopping.get()) {\n                    stopping.set(true);\n                    if (_alive.equals(true)) {\n                        // System.out.println(\"I2PSessionMuxedImpl.stopNotifying()\");\n                        _msgs.clear();\n                        while(again) {\n                            try {\n                                _msgs.put(new MsgData(0, POISON_SIZE, 0, 0, 0));\n                                again = false;\n                                // System.out.println(\"I2PSessionMuxedImpl.stopNotifying() success.\");\n                            } catch (InterruptedException ie) {\n                                continue;\n                            }\n                        }\n                    }\n                    _alive = false;\n                    stopping.set(false);\n                }\n                stopping.notifyAll();\n            }\n        }","id":44367,"modified_method":"@Override\n        public void stopNotifying() {\n            boolean again = true;\n            synchronized (stopping) {\n                if( !stopping.getAndSet(true)) {\n                    if (_alive == true) {\n                        // System.out.println(\"I2PSessionMuxedImpl.stopNotifying()\");\n                        _msgs.clear();\n                        while(again) {\n                            try {\n                                _msgs.put(new MsgData(0, POISON_SIZE, 0, 0, 0));\n                                again = false;\n                                // System.out.println(\"I2PSessionMuxedImpl.stopNotifying() success.\");\n                            } catch (InterruptedException ie) {\n                                continue;\n                            }\n                        }\n                    }\n                    _alive = false;\n                    stopping.set(false);\n                }\n                // stopping.notifyAll();\n            }\n        }","commit_id":"66a292a9c6c8a083794db9a839a50a598cd407ce","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n\t * MUX sockets, fire off a thread to connect, get destination info, and do I/O\n\t *\n\t */\n\tpublic void run() {\n\t\tI2PServerSocket SS = null;\n\t\tThread t = null;\n\t\tThread q = null;\n\t\ttry {\n\t\t\ttry {\n\t\t\t\twlock();\n\t\t\t\ttry {\n\t\t\t\t\tinfo.add(\"RUNNING\", new Boolean(true));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\twunlock();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\twunlock();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n//\t\tsocketManager.addDisconnectListener(new DisconnectListener());\n\n\t\t\tquit:\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\ttg = new ThreadGroup(N);\n\t\t\t\t\tdie:\n\t\t\t\t\t{\n\t\t\t\t\t\t// toss the connections to a new threads.\n\t\t\t\t\t\t// will wrap with TCP and UDP when UDP works\n\n\t\t\t\t\t\tif (go_out) {\n\t\t\t\t\t\t\t// I2P -> TCP\n\t\t\t\t\t\t\tSS = socketManager.getServerSocket();\n\t\t\t\t\t\t\tI2Plistener conn = new I2Plistener(SS, socketManager, info, database, _log);\n\t\t\t\t\t\t\tt = new Thread(tg, conn, \"BOBI2Plistener \" + N);\n\t\t\t\t\t\t\tt.start();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (come_in) {\n\t\t\t\t\t\t\t// TCP -> I2P\n\t\t\t\t\t\t\tTCPlistener conn = new TCPlistener(listener, socketManager, info, database, _log);\n\t\t\t\t\t\t\tq = new Thread(tg, conn, \"BOBTCPlistener \" + N);\n\t\t\t\t\t\t\tq.start();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tinfo.add(\"STARTING\", new Boolean(false));\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tboolean spin = true;\n\t\t\t\t\t\twhile (spin) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tThread.sleep(1000); //sleep for 1 second\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tspin = info.get(\"STOPPING\").equals(Boolean.FALSE);\n\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tinfo.add(\"RUNNING\", new Boolean(false));\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // die\n\n\t\t\t\t// I2PSession session = socketManager.getSession();\n\t\t\t\t// if (session != null) {\n\t\t\t\t// System.out.println(\"I2Plistener: destroySession\");\n\t\t\t\t//\ttry {\n\t\t\t\t//\t\tsession.destroySession();\n\t\t\t\t//\t} catch (I2PSessionException ex) {\n\t\t\t\t// nop\n\t\t\t\t//\t}\n\t\t\t\t// }\n\t\t\t\t// try {\n\t\t\t\t//\tsocketManager.destroySocketManager();\n\t\t\t\t//} catch (Exception e) {\n\t\t\t\t// nop\n\t\t\t\t//}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// System.out.println(\"MUXlisten: Caught an exception\" + e);\n\t\t\t\t\tbreak quit;\n\t\t\t\t}\n\t\t\t} // quit\n\t\t} finally {\n\t\t\t// allow threads above this one to catch the stop signal.\n\t\t\ttry {\n\t\t\t\tThread.sleep(250);\n\t\t\t} catch (InterruptedException ex) {\n\t\t\t}\n\t\t\t// zero out everything.\n\t\t\ttry {\n\t\t\t\twlock();\n\t\t\t\ttry {\n\t\t\t\t\tinfo.add(\"STARTING\", new Boolean(false));\n\t\t\t\t\tinfo.add(\"STOPPING\", new Boolean(false));\n\t\t\t\t\tinfo.add(\"RUNNING\", new Boolean(false));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\twunlock();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twunlock();\n\t\t\t} catch (Exception e) {\n\t\t\t}\n\n\t\t\t//try {\n\t\t\t//\tThread.sleep(1000 * 20); // how long?? is this even needed??\n\t\t\t//} catch (InterruptedException ex) {\n\t\t\t//}\n\n\t\t\tif (SS != null) {\n\t\t\t\ttry {\n\t\t\t\t\tSS.close();\n\t\t\t\t} catch (I2PException ex) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (listener != null) {\n\t\t\t\ttry {\n\t\t\t\t\tlistener.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tsocketManager.destroySocketManager();\n\t\t\t} catch (Exception e) {\n\t\t\t\t// nop\n\t\t\t\t}\n\t\t\t// This is here to catch when something fucks up REALLY bad, like those annoying stuck threads!\n\t\t\tif (tg != null) {\n\t\t\t\tString boner = tg.getName();\n\t\t\t\t// tg.interrupt(); // give my stuff a small smack again.\n\t\t\t\tif (tg.activeCount() + tg.activeGroupCount() != 0) {\n\t\t\t\t\tint foo = tg.activeCount() + tg.activeGroupCount();\n\t\t\t\t\tint bar = foo;\n\t\t\t\t\t// hopefully no longer needed!\n\t\t\t\t\t// System.out.println(\"BOB: MUXlisten: Waiting on threads for \" + boner);\n\t\t\t\t\t// System.out.println(\"\\n\\nBOB: MUXlisten: ThreadGroup dump BEGIN \" + boner);\n\t\t\t\t\t// visit(tg, 0, boner);\n\t\t\t\t\t// System.out.println(\"BOB: MUXlisten: ThreadGroup dump END \" + boner + \"\\n\\n\");\n\t\t\t\t\t// Happily spin forever :-(\n\t\t\t\t\twhile ((tg.activeCount() + tg.activeGroupCount() != 0)) {\n\t\t\t\t\t\tfoo = tg.activeCount() + tg.activeGroupCount();\n\t\t\t\t\t\t//\tif (foo != bar) {\n\t\t\t\t\t\t//\t\tSystem.out.println(\"\\n\\nBOB: MUXlisten: ThreadGroup dump BEGIN \" + boner);\n\t\t\t\t\t\t//\t\tvisit(tg, 0, boner);\n\t\t\t\t\t\t//\t\tSystem.out.println(\"BOB: MUXlisten: ThreadGroup dump END \" + boner + \"\\n\\n\");\n\t\t\t\t\t\t//\t}\n\t\t\t\t\t\tbar = foo;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(100); //sleep for 100 ms (One tenth second)\n\t\t\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\t\t\t// nop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"BOB: MUXlisten: Threads went away. Success: \" + boner);\n\t\t\t\ttg.destroy();\n\t\t\t\t// Zap reference to the ThreadGroup so the JVM can GC it.\n\t\t\t\ttg = null;\n\t\t\t}\n\t\t}\n\t}","id":44368,"modified_method":"/**\n\t * MUX sockets, fire off a thread to connect, get destination info, and do I/O\n\t *\n\t */\n\tpublic void run() {\n\t\tI2PServerSocket SS = null;\n\t\tThread t = null;\n\t\tThread q = null;\n\t\ttry {\n\t\t\ttry {\n\t\t\t\twlock();\n\t\t\t\ttry {\n\t\t\t\t\tinfo.add(\"RUNNING\", new Boolean(true));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\twunlock();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\twunlock();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn;\n\t\t\t}\n//\t\tsocketManager.addDisconnectListener(new DisconnectListener());\n\n\t\t\tquit:\n\t\t\t{\n\t\t\t\ttry {\n\t\t\t\t\ttg = new ThreadGroup(N);\n\t\t\t\t\tdie:\n\t\t\t\t\t{\n\t\t\t\t\t\t// toss the connections to a new threads.\n\t\t\t\t\t\t// will wrap with TCP and UDP when UDP works\n\n\t\t\t\t\t\tif (go_out) {\n\t\t\t\t\t\t\t// I2P -> TCP\n\t\t\t\t\t\t\tSS = socketManager.getServerSocket();\n\t\t\t\t\t\t\tI2Plistener conn = new I2Plistener(SS, socketManager, info, database, _log);\n\t\t\t\t\t\t\tt = new Thread(tg, conn, \"BOBI2Plistener \" + N);\n\t\t\t\t\t\t\tt.start();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (come_in) {\n\t\t\t\t\t\t\t// TCP -> I2P\n\t\t\t\t\t\t\tTCPlistener conn = new TCPlistener(listener, socketManager, info, database, _log);\n\t\t\t\t\t\t\tq = new Thread(tg, conn, \"BOBTCPlistener \" + N);\n\t\t\t\t\t\t\tq.start();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tinfo.add(\"STARTING\", new Boolean(false));\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tboolean spin = true;\n\t\t\t\t\t\twhile (spin) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tThread.sleep(1000); //sleep for 1 second\n\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\trlock();\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tspin = info.get(\"STOPPING\").equals(Boolean.FALSE);\n\t\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\trunlock();\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twlock();\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tinfo.add(\"RUNNING\", new Boolean(false));\n\t\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twunlock();\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tbreak die;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // die\n\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// System.out.println(\"MUXlisten: Caught an exception\" + e);\n\t\t\t\t\tbreak quit;\n\t\t\t\t}\n\t\t\t} // quit\n\t\t} finally {\n\t\t\t// Start cleanup. Allow threads above this one to catch the stop signal.\n\t\t\ttry {\n\t\t\t\tThread.sleep(250);\n\t\t\t} catch (InterruptedException ex) {\n\t\t\t}\n\t\t\t// zero out everything.\n\t\t\ttry {\n\t\t\t\twlock();\n\t\t\t\ttry {\n\t\t\t\t\tinfo.add(\"STARTING\", new Boolean(false));\n\t\t\t\t\tinfo.add(\"STOPPING\", new Boolean(false));\n\t\t\t\t\tinfo.add(\"RUNNING\", new Boolean(false));\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\twunlock();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twunlock();\n\t\t\t} catch (Exception e) {\n\t\t\t}\n\n\n\t\t\tif (SS != null) {\n\t\t\t\ttry {\n\t\t\t\t\tSS.close();\n\t\t\t\t} catch (I2PException ex) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (listener != null) {\n\t\t\t\ttry {\n\t\t\t\t\tlistener.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tsocketManager.destroySocketManager();\n\t\t\t} catch (Exception e) {\n\t\t\t\t// nop\n\t\t\t\t}\n\t\t\t// Wait around till all threads are collected.\n\t\t\tif (tg != null) {\n\t\t\t\tString boner = tg.getName();\n\t\t\t\t_log.warn(\"BOB: MUXlisten: Starting thread collection for: \" + boner);\n\t\t\t\t// tg.interrupt(); // give my stuff a small smack again.\n\t\t\t\tif (tg.activeCount() + tg.activeGroupCount() != 0) {\n\t\t\t\t\tint foo = tg.activeCount() + tg.activeGroupCount();\n\t\t\t\t\t// hopefully no longer needed!\n\t\t\t\t\t// int bar = foo;\n\t\t\t\t\t// System.out.println(\"BOB: MUXlisten: Waiting on threads for \" + boner);\n\t\t\t\t\t// System.out.println(\"\\nBOB: MUXlisten: ThreadGroup dump BEGIN \" + boner);\n\t\t\t\t\t// visit(tg, 0, boner);\n\t\t\t\t\t// System.out.println(\"BOB: MUXlisten: ThreadGroup dump END \" + boner + \"\\n\");\n\t\t\t\t\t// Happily spin forever :-(\n\t\t\t\t\twhile (foo != 0) {\n\t\t\t\t\t\tfoo = tg.activeCount() + tg.activeGroupCount();\n\t\t\t\t\t\t//\tif (foo != bar) {\n\t\t\t\t\t\t//\t\tSystem.out.println(\"\\nBOB: MUXlisten: ThreadGroup dump BEGIN \" + boner);\n\t\t\t\t\t\t//\t\tvisit(tg, 0, boner);\n\t\t\t\t\t\t//\t\tSystem.out.println(\"BOB: MUXlisten: ThreadGroup dump END \" + boner + \"\\n\");\n\t\t\t\t\t\t//\t}\n\t\t\t\t\t\t// bar = foo;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tThread.sleep(100); //sleep for 100 ms (One tenth second)\n\t\t\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\t\t\t// nop\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_log.warn(\"BOB: MUXlisten: Threads went away. Success: \" + boner);\n\t\t\t\ttg.destroy();\n\t\t\t\t// Zap reference to the ThreadGroup so the JVM can GC it.\n\t\t\t\ttg = null;\n\t\t\t}\n\t\t}\n\t}","commit_id":"66a292a9c6c8a083794db9a839a50a598cd407ce","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * This test should remove the specific 192.168.0.5 from the first definition and\n     * replace it with a range 192.168.0.5 - 192.168.0.7.\n     * \n     * @throws UnknownHostException\n     */\n    public void testSnmpEventInfoClassWithRangeReplacingSpecific() throws UnknownHostException {\n        final String addr1 = \"192.168.0.5\";\n        final String addr2 = \"192.168.0.7\";\n        \n        SnmpAgentConfig agent = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(addr1));\n        assertEquals(SnmpAgentConfig.VERSION2C, agent.getVersion());\n        \n        Event event = createConfigureSnmpEvent(addr1, addr2);\n        SnmpEventInfo info = new SnmpEventInfo(event);\n        info.setVersion(\"v2c\");\n        \n        SnmpConfigManager mgr = new SnmpConfigManager(SnmpPeerFactory.getSnmpConfig());\n        mgr.mergeIntoConfig(info.createDef());\n        \n        agent = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(addr1));\n        assertEquals(agent.getAddress().getHostAddress(), addr1);\n        assertEquals(SnmpAgentConfig.VERSION2C, agent.getVersion());\n        assertEquals(m_startingDefCount, SnmpPeerFactory.getSnmpConfig().getDefinitionCount());\n    }","id":44369,"modified_method":"/**\n     * This test should remove the specific 192.168.0.5 from the first definition and\n     * replace it with a range 192.168.0.5 - 192.168.0.7.\n     * \n     * @throws UnknownHostException\n     */\n    public void testSnmpEventInfoClassWithRangeReplacingSpecific() throws UnknownHostException {\n        final String addr1 = \"192.168.0.5\";\n        final String addr2 = \"192.168.0.7\";\n        \n        SnmpAgentConfig agent = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(addr1));\n        assertEquals(SnmpAgentConfig.VERSION2C, agent.getVersion());\n        \n        Event event = createConfigureSnmpEvent(addr1, addr2);\n        SnmpEventInfo info = new SnmpEventInfo(event);\n        info.setVersion(\"v2c\");\n        \n        SnmpConfigManager.mergeIntoConfig(SnmpPeerFactory.getSnmpConfig(), info.createDef());\n        \n        agent = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(addr1));\n        assertEquals(agent.getAddress().getHostAddress(), addr1);\n        assertEquals(SnmpAgentConfig.VERSION2C, agent.getVersion());\n        assertEquals(m_startingDefCount, SnmpPeerFactory.getSnmpConfig().getDefinitionCount());\n    }","commit_id":"eecf4ae2ff4e6c9affccc0f07276c4fba32305e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This test should show that a specific is added to the definition and the current\n     * single definition should become the beginning address in the adjacent range.\n     * \n     * @throws UnknownHostException\n     */\n    public void testSplice2() throws UnknownHostException {\n        assertEquals(3, SnmpPeerFactory.getSnmpConfig().getDefinition(3).getRangeCount());\n        assertEquals(1, SnmpPeerFactory.getSnmpConfig().getDefinition(3).getSpecificCount());\n        assertEquals(\"10.1.1.10\", SnmpPeerFactory.getSnmpConfig().getDefinition(3).getSpecific(0));\n        assertEquals(\"10.1.1.11\", SnmpPeerFactory.getSnmpConfig().getDefinition(3).getRange(0).getBegin());\n        \n        final String specificAddr = \"10.1.1.7\";\n        final Event event = createConfigureSnmpEvent(specificAddr, null);\n        final SnmpEventInfo info = new SnmpEventInfo(event);\n        info.setCommunityString(\"splice2-test\");\n\n        SnmpConfigManager mgr = new SnmpConfigManager(SnmpPeerFactory.getSnmpConfig());\n        mgr.mergeIntoConfig(info.createDef());\n        \n        assertEquals(3, SnmpPeerFactory.getSnmpConfig().getDefinition(3).getRangeCount());\n        assertEquals(1, SnmpPeerFactory.getSnmpConfig().getDefinition(3).getSpecificCount());\n        assertEquals(\"10.1.1.7\", SnmpPeerFactory.getSnmpConfig().getDefinition(3).getSpecific(0));\n        assertEquals(\"10.1.1.10\", SnmpPeerFactory.getSnmpConfig().getDefinition(3).getRange(0).getBegin());\n\n        String marshalledConfig = SnmpPeerFactory.marshallConfig();\n        assertNotNull(marshalledConfig);\n        \n    }","id":44370,"modified_method":"/**\n     * This test should show that a specific is added to the definition and the current\n     * single definition should become the beginning address in the adjacent range.\n     * \n     * @throws UnknownHostException\n     */\n    public void testSplice2() throws UnknownHostException {\n        assertEquals(3, SnmpPeerFactory.getSnmpConfig().getDefinition(3).getRangeCount());\n        assertEquals(1, SnmpPeerFactory.getSnmpConfig().getDefinition(3).getSpecificCount());\n        assertEquals(\"10.1.1.10\", SnmpPeerFactory.getSnmpConfig().getDefinition(3).getSpecific(0));\n        assertEquals(\"10.1.1.11\", SnmpPeerFactory.getSnmpConfig().getDefinition(3).getRange(0).getBegin());\n        \n        final String specificAddr = \"10.1.1.7\";\n        final Event event = createConfigureSnmpEvent(specificAddr, null);\n        final SnmpEventInfo info = new SnmpEventInfo(event);\n        info.setCommunityString(\"splice2-test\");\n\n        SnmpConfigManager.mergeIntoConfig(SnmpPeerFactory.getSnmpConfig(), info.createDef());\n        \n        assertEquals(3, SnmpPeerFactory.getSnmpConfig().getDefinition(3).getRangeCount());\n        assertEquals(1, SnmpPeerFactory.getSnmpConfig().getDefinition(3).getSpecificCount());\n        assertEquals(\"10.1.1.7\", SnmpPeerFactory.getSnmpConfig().getDefinition(3).getSpecific(0));\n        assertEquals(\"10.1.1.10\", SnmpPeerFactory.getSnmpConfig().getDefinition(3).getRange(0).getBegin());\n\n        String marshalledConfig = SnmpPeerFactory.marshallConfig();\n        assertNotNull(marshalledConfig);\n        \n    }","commit_id":"eecf4ae2ff4e6c9affccc0f07276c4fba32305e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Tests getting the correct SNMP Peer after receiving a configureSNMP event that moves a\n     * specific from one definition into another.\n     * \n     * @throws UnknownHostException\n     */\n    public void testSplicingSpecificsIntoRanges() throws UnknownHostException {\n        assertEquals(3, SnmpPeerFactory.getSnmpConfig().getDefinition(2).getRangeCount());\n        assertEquals(6, SnmpPeerFactory.getSnmpConfig().getDefinition(2).getSpecificCount());\n        \n        final String specificAddr = \"10.1.1.7\";\n        final Event event = createConfigureSnmpEvent(specificAddr, null);\n        final SnmpEventInfo info = new SnmpEventInfo(event);\n        info.setCommunityString(\"splice-test\");\n        info.setVersion(\"v2c\");\n        \n        SnmpConfigManager mgr = new SnmpConfigManager(SnmpPeerFactory.getSnmpConfig());\n        mgr.mergeIntoConfig(info.createDef());\n        \n        assertEquals(5, SnmpPeerFactory.getSnmpConfig().getDefinition(2).getRangeCount());\n        \n        assertEquals(\"10.1.1.10\", SnmpPeerFactory.getSnmpConfig().getDefinition(2).getSpecific(0));\n        assertEquals(1, SnmpPeerFactory.getSnmpConfig().getDefinition(2).getSpecificCount());\n        assertEquals(m_startingDefCount, SnmpPeerFactory.getSnmpConfig().getDefinitionCount());\n    }","id":44371,"modified_method":"/**\n     * Tests getting the correct SNMP Peer after receiving a configureSNMP event that moves a\n     * specific from one definition into another.\n     * \n     * @throws UnknownHostException\n     */\n    public void testSplicingSpecificsIntoRanges() throws UnknownHostException {\n        assertEquals(3, SnmpPeerFactory.getSnmpConfig().getDefinition(2).getRangeCount());\n        assertEquals(6, SnmpPeerFactory.getSnmpConfig().getDefinition(2).getSpecificCount());\n        \n        final String specificAddr = \"10.1.1.7\";\n        final Event event = createConfigureSnmpEvent(specificAddr, null);\n        final SnmpEventInfo info = new SnmpEventInfo(event);\n        info.setCommunityString(\"splice-test\");\n        info.setVersion(\"v2c\");\n        \n        SnmpConfigManager.mergeIntoConfig(SnmpPeerFactory.getSnmpConfig(), info.createDef());\n        \n        assertEquals(5, SnmpPeerFactory.getSnmpConfig().getDefinition(2).getRangeCount());\n        \n        assertEquals(\"10.1.1.10\", SnmpPeerFactory.getSnmpConfig().getDefinition(2).getSpecific(0));\n        assertEquals(1, SnmpPeerFactory.getSnmpConfig().getDefinition(2).getSpecificCount());\n        assertEquals(m_startingDefCount, SnmpPeerFactory.getSnmpConfig().getDefinitionCount());\n    }","commit_id":"eecf4ae2ff4e6c9affccc0f07276c4fba32305e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Tests getting the correct SNMP Peer after a configureSNMP event and merge to the running config.\n     * @throws UnknownHostException\n     */\n    public void testSnmpEventInfoClassWithSpecific() throws UnknownHostException {\n        final String addr = \"192.168.0.5\";\n        Event event = createConfigureSnmpEvent(addr, null);\n        addCommunityStringToEvent(event, \"abc\");\n        SnmpEventInfo info = new SnmpEventInfo(event);\n        \n        SnmpConfigManager mgr = new SnmpConfigManager(SnmpPeerFactory.getSnmpConfig());\n        mgr.mergeIntoConfig(info.createDef());\n\n        SnmpAgentConfig agent = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(addr));\n        assertEquals(agent.getAddress().getHostAddress(), addr);\n        assertEquals(\"abc\", agent.getReadCommunity());\n    }","id":44372,"modified_method":"/**\n     * Tests getting the correct SNMP Peer after a configureSNMP event and merge to the running config.\n     * @throws UnknownHostException\n     */\n    public void testSnmpEventInfoClassWithSpecific() throws UnknownHostException {\n        final String addr = \"192.168.0.5\";\n        Event event = createConfigureSnmpEvent(addr, null);\n        addCommunityStringToEvent(event, \"abc\");\n        SnmpEventInfo info = new SnmpEventInfo(event);\n        \n        SnmpConfigManager.mergeIntoConfig(SnmpPeerFactory.getSnmpConfig(), info.createDef());\n\n        SnmpAgentConfig agent = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(addr));\n        assertEquals(agent.getAddress().getHostAddress(), addr);\n        assertEquals(\"abc\", agent.getReadCommunity());\n    }","commit_id":"eecf4ae2ff4e6c9affccc0f07276c4fba32305e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Tests getting the correct SNMP Peer after merging a new range that super sets a current range.\n     * \n     * @throws UnknownHostException\n     */\n    public void testSnmpEventInfoClassWithRangeSuperSettingDefRanges() throws UnknownHostException {\n        final String addr1 = \"192.168.99.1\";\n        final String addr2 = \"192.168.108.254\";\n        \n        SnmpAgentConfig agent = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(addr1));\n        assertEquals(SnmpAgentConfig.VERSION1, agent.getVersion());\n        \n        Event event = createConfigureSnmpEvent(addr1, addr2);\n        SnmpEventInfo info = new SnmpEventInfo(event);\n        info.setCommunityString(\"opennmsrules\");\n        \n        SnmpConfigManager mgr = new SnmpConfigManager(SnmpPeerFactory.getSnmpConfig());\n        mgr.mergeIntoConfig(info.createDef());\n        \n        agent = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(addr1));\n        assertEquals(agent.getAddress().getHostAddress(), addr1);\n        assertEquals(SnmpAgentConfig.VERSION1, agent.getVersion());\n        assertEquals(m_startingDefCount, SnmpPeerFactory.getSnmpConfig().getDefinitionCount());\n    }","id":44373,"modified_method":"/**\n     * Tests getting the correct SNMP Peer after merging a new range that super sets a current range.\n     * \n     * @throws UnknownHostException\n     */\n    public void testSnmpEventInfoClassWithRangeSuperSettingDefRanges() throws UnknownHostException {\n        final String addr1 = \"192.168.99.1\";\n        final String addr2 = \"192.168.108.254\";\n        \n        SnmpAgentConfig agent = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(addr1));\n        assertEquals(SnmpAgentConfig.VERSION1, agent.getVersion());\n        \n        Event event = createConfigureSnmpEvent(addr1, addr2);\n        SnmpEventInfo info = new SnmpEventInfo(event);\n        info.setCommunityString(\"opennmsrules\");\n        \n        SnmpConfigManager.mergeIntoConfig(SnmpPeerFactory.getSnmpConfig(), info.createDef());\n        \n        agent = SnmpPeerFactory.getInstance().getAgentConfig(InetAddress.getByName(addr1));\n        assertEquals(agent.getAddress().getHostAddress(), addr1);\n        assertEquals(SnmpAgentConfig.VERSION1, agent.getVersion());\n        assertEquals(m_startingDefCount, SnmpPeerFactory.getSnmpConfig().getDefinitionCount());\n    }","commit_id":"eecf4ae2ff4e6c9affccc0f07276c4fba32305e7","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode opAddr = operation.require(OP_ADDR);\n        final PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n\n        for(final AttributeDefinition attribute : JMSServices.POOLED_CONNECTION_FACTORY_ATTRS) {\n            attribute.resolveModelAttribute(context, model);\n        }\n\n        // We validated that jndiName part of the model in populateModel\n        // TODO we only use a single jndi name here but the xsd indicates support for many\n        final String jndiName = model.get(CommonAttributes.ENTRIES.getName()).asList().get(0).asString();\n\n        final int minPoolSize = model.hasDefined(MIN_POOL_SIZE.getName()) ? model.get(MIN_POOL_SIZE.getName()).asInt() : MIN_POOL_SIZE.getDefaultValue().asInt();\n        final int maxPoolSize = model.hasDefined(MAX_POOL_SIZE.getName()) ? model.get(MAX_POOL_SIZE.getName()).asInt() : MAX_POOL_SIZE.getDefaultValue().asInt();\n\n        final String txSupport;\n        if(model.hasDefined(TRANSACTION)) {\n            String txType = model.get(TRANSACTION).asString();\n            if(LOCAL.equals(txType)) {\n                txSupport = LOCAL_TX;\n            } else if (NONE.equals(txType)) {\n                 txSupport = NO_TX;\n            } else {\n                txSupport = XA_TX;\n            }\n        } else {\n            txSupport = XA_TX;\n        }\n\n        ServiceTarget serviceTarget = context.getServiceTarget();\n\n        List<String> connectors = getConnectors(model);\n\n        String discoveryGroupName = getDiscoveryGroup(model);\n\n        List<PooledConnectionFactoryConfigProperties> adapterParams = getAdapterParams(model, context);\n\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(PathAddress.pathAddress(opAddr));\n        ServiceName hornetQResourceAdapterService = JMSServices.getPooledConnectionFactoryBaseServiceName(hqServiceName).append(name);\n        PooledConnectionFactoryService resourceAdapterService = new PooledConnectionFactoryService(name, connectors, discoveryGroupName, adapterParams, jndiName, txSupport, minPoolSize, maxPoolSize);\n        ServiceBuilder serviceBuilder = serviceTarget\n                .addService(hornetQResourceAdapterService, resourceAdapterService)\n                .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, resourceAdapterService.getTransactionManager())\n                .addDependency(hqServiceName, HornetQServer.class, resourceAdapterService.getHornetQService())\n                .addDependency(JMSServices.getJmsManagerBaseServiceName(hqServiceName))\n                .addListener(verificationHandler);\n\n        newControllers.add(serviceBuilder.setInitialMode(Mode.ACTIVE).install());\n    }","id":44374,"modified_method":"protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n                                  List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode opAddr = operation.require(OP_ADDR);\n        final PathAddress address = PathAddress.pathAddress(opAddr);\n        final String name = address.getLastElement().getValue();\n\n        final ModelNode resolvedModel = model.clone();\n        for(final AttributeDefinition attribute : JMSServices.POOLED_CONNECTION_FACTORY_ATTRS) {\n            resolvedModel.get(attribute.getName()).set(attribute.resolveModelAttribute(context, resolvedModel ));\n        }\n\n        // We validated that jndiName part of the model in populateModel\n        // TODO we only use a single jndi name here but the xsd indicates support for many\n        final String jndiName = resolvedModel.get(CommonAttributes.ENTRIES.getName()).asList().get(0).asString();\n\n        final int minPoolSize = resolvedModel.get(MIN_POOL_SIZE.getName()).asInt();\n        final int maxPoolSize = resolvedModel.get(MAX_POOL_SIZE.getName()).asInt();\n\n        final String txSupport;\n        if(resolvedModel.hasDefined(TRANSACTION)) {\n            String txType = resolvedModel.get(TRANSACTION).asString();\n            if(LOCAL.equals(txType)) {\n                txSupport = LOCAL_TX;\n            } else if (NONE.equals(txType)) {\n                 txSupport = NO_TX;\n            } else {\n                txSupport = XA_TX;\n            }\n        } else {\n            txSupport = XA_TX;\n        }\n\n        ServiceTarget serviceTarget = context.getServiceTarget();\n\n        List<String> connectors = getConnectors(resolvedModel);\n\n        String discoveryGroupName = getDiscoveryGroup(resolvedModel);\n\n        List<PooledConnectionFactoryConfigProperties> adapterParams = getAdapterParams(resolvedModel, context);\n\n        final ServiceName hqServiceName = MessagingServices.getHornetQServiceName(address);\n        ServiceName hornetQResourceAdapterService = JMSServices.getPooledConnectionFactoryBaseServiceName(hqServiceName).append(name);\n        PooledConnectionFactoryService resourceAdapterService = new PooledConnectionFactoryService(name, connectors, discoveryGroupName, adapterParams, jndiName, txSupport, minPoolSize, maxPoolSize);\n        ServiceBuilder serviceBuilder = serviceTarget\n                .addService(hornetQResourceAdapterService, resourceAdapterService)\n                .addDependency(TxnServices.JBOSS_TXN_TRANSACTION_MANAGER, resourceAdapterService.getTransactionManager())\n                .addDependency(hqServiceName, HornetQServer.class, resourceAdapterService.getHornetQService())\n                .addDependency(JMSServices.getJmsManagerBaseServiceName(hqServiceName))\n                .addListener(verificationHandler);\n\n        newControllers.add(serviceBuilder.setInitialMode(Mode.ACTIVE).install());\n    }","commit_id":"961d226cd618676f2a6af8b2f59cc4f15464b080","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performRuntime(final OperationContext context, ModelNode operation, ModelNode model, final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> controllers) throws OperationFailedException {\n        final ModelNode address = operation.require(OP_ADDR);\n        final String dsName = PathAddress.pathAddress(address).getLastElement().getValue();\n        final String jndiName = operation.hasDefined(JNDINAME.getName()) ? operation.get(JNDINAME.getName()).asString() : dsName;\n\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        boolean enabled = false;\n                //!operation.hasDefined(ENABLED.getName()) || operation.get(ENABLED.getName()).asBoolean();\n\n        ModelNode node = operation.require(DATASOURCE_DRIVER.getName());\n\n\n        AbstractDataSourceService dataSourceService = createDataSourceService(dsName);\n\n        final ManagementResourceRegistration registration = context.getResourceRegistrationForUpdate();\n\n        final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n        final ServiceBuilder<?> dataSourceServiceBuilder = serviceTarget\n                .addService(dataSourceServiceName, dataSourceService)\n                .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                        dataSourceService.getTransactionIntegrationInjector())\n                .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class,\n                        dataSourceService.getmanagementRepositoryInjector())\n                .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                        dataSourceService.getSubjectFactoryInjector())\n                .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class,\n                        dataSourceService.getDriverRegistryInjector())\n                .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class,\n                        dataSourceService.getCcmInjector())\n                .addDependency(ConnectorServices.IDLE_REMOVER_SERVICE)\n                .addDependency(ConnectorServices.CONNECTION_VALIDATOR_SERVICE)\n                .addDependency(NamingService.SERVICE_NAME);\n\n        dataSourceServiceBuilder.addListener(new DataSourceStatisticsListener(registration, dsName));\n        startConfigAndAddDependency(dataSourceServiceBuilder, dataSourceService, dsName, serviceTarget, operation, verificationHandler);\n\n        final String driverName = node.asString();\n        final ServiceName driverServiceName = ServiceName.JBOSS.append(\"jdbc-driver\", driverName.replaceAll(\"\\\\.\", \"_\"));\n        if (!context.isBooting()) {\n            final ServiceRegistry registry = context.getServiceRegistry(true);\n            final ServiceController<?> dataSourceController = registry.getService(driverServiceName);\n\n            if (driverServiceName != null && dataSourceController != null) {\n                dataSourceServiceBuilder.addDependency(driverServiceName, Driver.class,\n                        dataSourceService.getDriverInjector());\n            } else {\n                throw new OperationFailedException(MESSAGES.driverNotPresent(driverName));\n            }\n        } else {\n            dataSourceServiceBuilder.addDependency(driverServiceName, Driver.class,\n                    dataSourceService.getDriverInjector());\n        }\n\n        dataSourceServiceBuilder.setInitialMode(ServiceController.Mode.NEVER);\n\n        controllers.add(dataSourceServiceBuilder.install());\n\n    }","id":44375,"modified_method":"protected void performRuntime(final OperationContext context, ModelNode operation, ModelNode model, final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> controllers) throws OperationFailedException {\n        final ModelNode address = operation.require(OP_ADDR);\n        final String dsName = PathAddress.pathAddress(address).getLastElement().getValue();\n        final String jndiName = model.get(JNDINAME.getName()).asString();\n\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        boolean enabled = false;\n                //!operation.hasDefined(ENABLED.getName()) || operation.get(ENABLED.getName()).asBoolean();\n\n        ModelNode node = operation.require(DATASOURCE_DRIVER.getName());\n\n\n        AbstractDataSourceService dataSourceService = createDataSourceService(dsName);\n\n        final ManagementResourceRegistration registration = context.getResourceRegistrationForUpdate();\n\n        final ServiceName dataSourceServiceName = AbstractDataSourceService.SERVICE_NAME_BASE.append(jndiName);\n        final ServiceBuilder<?> dataSourceServiceBuilder = serviceTarget\n                .addService(dataSourceServiceName, dataSourceService)\n                .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                        dataSourceService.getTransactionIntegrationInjector())\n                .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class,\n                        dataSourceService.getmanagementRepositoryInjector())\n                .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                        dataSourceService.getSubjectFactoryInjector())\n                .addDependency(ConnectorServices.JDBC_DRIVER_REGISTRY_SERVICE, DriverRegistry.class,\n                        dataSourceService.getDriverRegistryInjector())\n                .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class,\n                        dataSourceService.getCcmInjector())\n                .addDependency(ConnectorServices.IDLE_REMOVER_SERVICE)\n                .addDependency(ConnectorServices.CONNECTION_VALIDATOR_SERVICE)\n                .addDependency(NamingService.SERVICE_NAME);\n\n        dataSourceServiceBuilder.addListener(new DataSourceStatisticsListener(registration, dsName));\n        startConfigAndAddDependency(dataSourceServiceBuilder, dataSourceService, dsName, serviceTarget, operation, verificationHandler);\n\n        final String driverName = node.asString();\n        final ServiceName driverServiceName = ServiceName.JBOSS.append(\"jdbc-driver\", driverName.replaceAll(\"\\\\.\", \"_\"));\n        if (!context.isBooting()) {\n            final ServiceRegistry registry = context.getServiceRegistry(true);\n            final ServiceController<?> dataSourceController = registry.getService(driverServiceName);\n\n            if (driverServiceName != null && dataSourceController != null) {\n                dataSourceServiceBuilder.addDependency(driverServiceName, Driver.class,\n                        dataSourceService.getDriverInjector());\n            } else {\n                throw new OperationFailedException(MESSAGES.driverNotPresent(driverName));\n            }\n        } else {\n            dataSourceServiceBuilder.addDependency(driverServiceName, Driver.class,\n                    dataSourceService.getDriverInjector());\n        }\n\n        dataSourceServiceBuilder.setInitialMode(ServiceController.Mode.NEVER);\n\n        controllers.add(dataSourceServiceBuilder.install());\n\n    }","commit_id":"661d0a3aa8034dc219d952668618e64425700151","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testAddDataSource() throws Exception {\n\n        // add data source\n        cli.sendLine(\"data-source add --name=java:jboss/datasources/TestDS --driver-name=h2 --connection-url=jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\");\n\n        // check the data source is listed\n        cli.sendLine(\"cd /subsystem=datasources/data-source\");\n        cli.sendLine(\"ls\");\n        String ls = cli.readAllUnformated(WAIT_TIMEOUT, WAIT_LINETIMEOUT);\n        assertTrue(ls.contains(\"java:jboss/datasources/TestDS\"));\n\n        // check that it is available through JNDI\n        // TODO implement when @ArquillianResource InitialContext is done\n\n    }","id":44376,"modified_method":"private void testAddDataSource() throws Exception {\n\n        // add data source\n        cli.sendLine(\"data-source add --jndi-name=java:jboss/datasources/TestDS --name=java:jboss/datasources/TestDS --driver-name=h2 --connection-url=jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\");\n\n        // check the data source is listed\n        cli.sendLine(\"cd /subsystem=datasources/data-source\");\n        cli.sendLine(\"ls\");\n        String ls = cli.readAllUnformated(WAIT_TIMEOUT, WAIT_LINETIMEOUT);\n        assertTrue(ls.contains(\"java:jboss/datasources/TestDS\"));\n\n        // check that it is available through JNDI\n        // TODO implement when @ArquillianResource InitialContext is done\n\n    }","commit_id":"661d0a3aa8034dc219d952668618e64425700151","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testAddXaDataSource() throws Exception {\n\n        // add data source\n        cli.sendLine(\"xa-data-source add --name=java:jboss/datasources/TestXADS --driver-name=h2\");\n\n        //check the data source is listed\n        cli.sendLine(\"cd /subsystem=datasources/xa-data-source\");\n        cli.sendLine(\"ls\");\n        String ls = cli.readAllUnformated(WAIT_TIMEOUT, WAIT_LINETIMEOUT);\n        assertTrue(ls.contains(\"java:jboss/datasources/TestXADS\"));\n\n    }","id":44377,"modified_method":"private void testAddXaDataSource() throws Exception {\n\n        // add data source\n        cli.sendLine(\"xa-data-source add --jndi-name=java:jboss/datasources/TestXADS --name=java:jboss/datasources/TestXADS --driver-name=h2\");\n\n        //check the data source is listed\n        cli.sendLine(\"cd /subsystem=datasources/xa-data-source\");\n        cli.sendLine(\"ls\");\n        String ls = cli.readAllUnformated(WAIT_TIMEOUT, WAIT_LINETIMEOUT);\n        assertTrue(ls.contains(\"java:jboss/datasources/TestXADS\"));\n\n    }","commit_id":"661d0a3aa8034dc219d952668618e64425700151","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testAddDataSource() throws Exception {\n\n        // add data source\n        cli.sendLine(\"data-source add --profile=\" + profileNames[0] + \" --name=java:jboss/datasources/TestDS --driver-name=h2 --connection-url=jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\");\n\n        // check the data source is listed\n        cli.sendLine(\"cd /profile=\" + profileNames[0] + \"/subsystem=datasources/data-source\");\n        cli.sendLine(\"ls\");\n        String ls = cli.readAllUnformated(WAIT_TIMEOUT, WAIT_LINETIMEOUT);\n        assertTrue(\"Datasource not found: \" + ls, ls.contains(\"java:jboss/datasources/TestDS\"));\n\n        // check that it is available through JNDI\n        // TODO implement when @ArquillianResource InitialContext is done\n\n    }","id":44378,"modified_method":"private void testAddDataSource() throws Exception {\n\n        // add data source\n        cli.sendLine(\"data-source add --profile=\" + profileNames[0] + \" --jndi-name=java:jboss/datasources/TestDS --name=java:jboss/datasources/TestDS --driver-name=h2 --connection-url=jdbc:h2:mem:test;DB_CLOSE_DELAY=-1\");\n\n        // check the data source is listed\n        cli.sendLine(\"cd /profile=\" + profileNames[0] + \"/subsystem=datasources/data-source\");\n        cli.sendLine(\"ls\");\n        String ls = cli.readAllUnformated(WAIT_TIMEOUT, WAIT_LINETIMEOUT);\n        assertTrue(\"Datasource not found: \" + ls, ls.contains(\"java:jboss/datasources/TestDS\"));\n\n        // check that it is available through JNDI\n        // TODO implement when @ArquillianResource InitialContext is done\n\n    }","commit_id":"661d0a3aa8034dc219d952668618e64425700151","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void testAddXaDataSource() throws Exception {\n\n        // add data source\n        cli.sendLine(\"xa-data-source add --profile=\" + profileNames[0] +\n                \" --name=java:jboss/datasources/TestXADS --driver-name=h2\");\n\n        //check the data source is listed\n        cli.sendLine(\"cd /profile=\" + profileNames[0] + \"/subsystem=datasources/xa-data-source\");\n        cli.sendLine(\"ls\");\n        String ls = cli.readAllUnformated(WAIT_TIMEOUT, WAIT_LINETIMEOUT);\n        assertTrue(ls.contains(\"java:jboss/datasources/TestXADS\"));\n\n    }","id":44379,"modified_method":"private void testAddXaDataSource() throws Exception {\n\n        // add data source\n        cli.sendLine(\"xa-data-source add --profile=\" + profileNames[0] +\n                \" --jndi-name=java:jboss/datasources/TestXADS --name=java:jboss/datasources/TestXADS --driver-name=h2\");\n\n        //check the data source is listed\n        cli.sendLine(\"cd /profile=\" + profileNames[0] + \"/subsystem=datasources/xa-data-source\");\n        cli.sendLine(\"ls\");\n        String ls = cli.readAllUnformated(WAIT_TIMEOUT, WAIT_LINETIMEOUT);\n        assertTrue(ls.contains(\"java:jboss/datasources/TestXADS\"));\n\n    }","commit_id":"661d0a3aa8034dc219d952668618e64425700151","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeDomainController(final XMLExtendedStreamWriter writer, final ModelNode modelNode)\n            throws XMLStreamException {\n        writer.writeStartElement(Element.DOMAIN_CONTROLLER.getLocalName());\n        if (modelNode.hasDefined(LOCAL)) {\n            writer.writeEmptyElement(Element.LOCAL.getLocalName());\n        } else if (modelNode.hasDefined(REMOTE)) {\n            writer.writeStartElement(Element.REMOTE.getLocalName());\n            final ModelNode remote = modelNode.get(REMOTE);\n            if (remote.has(HOST)) {\n                writeAttribute(writer, Attribute.HOST, remote.get(HOST).asString());\n            }\n            if (remote.has(PORT)) {\n                writeAttribute(writer, Attribute.PORT, remote.get(PORT).asString());\n            }\n            if (remote.hasDefined(SECURITY_REALM)) {\n                writeAttribute(writer, Attribute.SECURITY_REALM, remote.require(SECURITY_REALM).asString());\n            }\n            if (modelNode.hasDefined(CORE_SERVICE) && modelNode.get(CORE_SERVICE).hasDefined(IGNORED_RESOURCES)) {\n                writeIgnoredResources(writer, modelNode.get(CORE_SERVICE, IGNORED_RESOURCES));\n            }\n            writer.writeEndElement();\n        }\n        writer.writeEndElement();\n    }","id":44380,"modified_method":"private void writeDomainController(final XMLExtendedStreamWriter writer, final ModelNode modelNode, ModelNode ignoredResources)\n            throws XMLStreamException {\n        writer.writeStartElement(Element.DOMAIN_CONTROLLER.getLocalName());\n        if (modelNode.hasDefined(LOCAL)) {\n            writer.writeEmptyElement(Element.LOCAL.getLocalName());\n        } else if (modelNode.hasDefined(REMOTE)) {\n            writer.writeStartElement(Element.REMOTE.getLocalName());\n            final ModelNode remote = modelNode.get(REMOTE);\n            if (remote.has(HOST)) {\n                writeAttribute(writer, Attribute.HOST, remote.get(HOST).asString());\n            }\n            if (remote.has(PORT)) {\n                writeAttribute(writer, Attribute.PORT, remote.get(PORT).asString());\n            }\n            if (remote.hasDefined(SECURITY_REALM)) {\n                writeAttribute(writer, Attribute.SECURITY_REALM, remote.require(SECURITY_REALM).asString());\n            }\n            if (ignoredResources != null) {\n                writeIgnoredResources(writer, ignoredResources);\n            }\n            writer.writeEndElement();\n        }\n        writer.writeEndElement();\n    }","commit_id":"0f0575947b6cfb9899945f7826369db59c886f9d","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void writeContent(final XMLExtendedStreamWriter writer, final ModelMarshallingContext context)\n            throws XMLStreamException {\n\n        final ModelNode modelNode = context.getModelNode();\n\n        writer.writeStartDocument();\n        writer.writeStartElement(Element.HOST.getLocalName());\n\n        if (modelNode.hasDefined(NAME)) {\n            writeAttribute(writer, Attribute.NAME, modelNode.get(NAME).asString());\n        }\n\n        writer.writeDefaultNamespace(Namespace.CURRENT.getUriString());\n        writeNamespaces(writer, modelNode);\n        writeSchemaLocation(writer, modelNode);\n\n        writeNewLine(writer);\n\n        if (modelNode.hasDefined(SYSTEM_PROPERTY)) {\n            writeProperties(writer, modelNode.get(SYSTEM_PROPERTY), Element.SYSTEM_PROPERTIES, false);\n            writeNewLine(writer);\n        }\n\n        if (modelNode.hasDefined(PATH)) {\n            writePaths(writer, modelNode.get(PATH));\n            writeNewLine(writer);\n        }\n\n        if (modelNode.hasDefined(CORE_SERVICE) && modelNode.get(CORE_SERVICE).hasDefined(VAULT)) {\n            writeVault(writer, modelNode.get(CORE_SERVICE, VAULT));\n            writeNewLine(writer);\n        }\n\n        if (modelNode.hasDefined(CORE_SERVICE) && modelNode.get(CORE_SERVICE).hasDefined(MANAGEMENT)) {\n            ManagementXml managementXml = new ManagementXml(this);\n            managementXml.writeManagement(writer, modelNode.get(CORE_SERVICE, MANAGEMENT), true);\n            writeNewLine(writer);\n        }\n\n        if (modelNode.hasDefined(DOMAIN_CONTROLLER)) {\n            writeDomainController(writer, modelNode.get(DOMAIN_CONTROLLER));\n            writeNewLine(writer);\n        }\n\n        if (modelNode.hasDefined(INTERFACE)) {\n            writeInterfaces(writer, modelNode.get(INTERFACE));\n            writeNewLine(writer);\n        }\n        if (modelNode.hasDefined(JVM)) {\n            writer.writeStartElement(Element.JVMS.getLocalName());\n            for (final Property jvm : modelNode.get(JVM).asPropertyList()) {\n                writeJVMElement(writer, jvm.getName(), jvm.getValue());\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n\n        if (modelNode.hasDefined(SERVER_CONFIG)) {\n            writeServers(writer, modelNode.get(SERVER_CONFIG));\n            writeNewLine(writer);\n        }\n\n        writer.writeEndElement();\n        writeNewLine(writer);\n        writer.writeEndDocument();\n    }","id":44381,"modified_method":"@Override\n    public void writeContent(final XMLExtendedStreamWriter writer, final ModelMarshallingContext context)\n            throws XMLStreamException {\n\n        final ModelNode modelNode = context.getModelNode();\n\n        writer.writeStartDocument();\n        writer.writeStartElement(Element.HOST.getLocalName());\n\n        if (modelNode.hasDefined(NAME)) {\n            writeAttribute(writer, Attribute.NAME, modelNode.get(NAME).asString());\n        }\n\n        writer.writeDefaultNamespace(Namespace.CURRENT.getUriString());\n        writeNamespaces(writer, modelNode);\n        writeSchemaLocation(writer, modelNode);\n\n        writeNewLine(writer);\n\n        if (modelNode.hasDefined(SYSTEM_PROPERTY)) {\n            writeProperties(writer, modelNode.get(SYSTEM_PROPERTY), Element.SYSTEM_PROPERTIES, false);\n            writeNewLine(writer);\n        }\n\n        if (modelNode.hasDefined(PATH)) {\n            writePaths(writer, modelNode.get(PATH));\n            writeNewLine(writer);\n        }\n\n        boolean hasCoreServices = modelNode.hasDefined(CORE_SERVICE);\n        if (hasCoreServices && modelNode.get(CORE_SERVICE).hasDefined(VAULT)) {\n            writeVault(writer, modelNode.get(CORE_SERVICE, VAULT));\n            writeNewLine(writer);\n        }\n\n        if (hasCoreServices && modelNode.get(CORE_SERVICE).hasDefined(MANAGEMENT)) {\n            ManagementXml managementXml = new ManagementXml(this);\n            managementXml.writeManagement(writer, modelNode.get(CORE_SERVICE, MANAGEMENT), true);\n            writeNewLine(writer);\n        }\n\n        if (modelNode.hasDefined(DOMAIN_CONTROLLER)) {\n            ModelNode ignoredResources = null;\n            if (hasCoreServices && modelNode.get(CORE_SERVICE).hasDefined(IGNORED_RESOURCES)) {\n                ignoredResources = modelNode.get(CORE_SERVICE, IGNORED_RESOURCES);\n            }\n            writeDomainController(writer, modelNode.get(DOMAIN_CONTROLLER), ignoredResources);\n            writeNewLine(writer);\n        }\n\n        if (modelNode.hasDefined(INTERFACE)) {\n            writeInterfaces(writer, modelNode.get(INTERFACE));\n            writeNewLine(writer);\n        }\n        if (modelNode.hasDefined(JVM)) {\n            writer.writeStartElement(Element.JVMS.getLocalName());\n            for (final Property jvm : modelNode.get(JVM).asPropertyList()) {\n                writeJVMElement(writer, jvm.getName(), jvm.getValue());\n            }\n            writer.writeEndElement();\n            writeNewLine(writer);\n        }\n\n        if (modelNode.hasDefined(SERVER_CONFIG)) {\n            writeServers(writer, modelNode.get(SERVER_CONFIG));\n            writeNewLine(writer);\n        }\n\n        writer.writeEndElement();\n        writeNewLine(writer);\n        writer.writeEndDocument();\n    }","commit_id":"0f0575947b6cfb9899945f7826369db59c886f9d","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n\n        writeAttribute(writer, Attribute.NATIVE.getLocalName(), node);\n        writeAttribute(writer, Attribute.DEFAULT_VIRTUAL_SERVER.getLocalName(), node);\n        writeAttribute(writer, Attribute.INSTANCE_ID.getLocalName(), node);\n        if(node.hasDefined(CONTAINER_CONFIG)) {\n            writeContainerConfig(writer, node.get(CONTAINER_CONFIG));\n        }\n        if(node.hasDefined(CONNECTOR)) {\n            for(final Property connector : node.get(CONNECTOR).asPropertyList()) {\n                final ModelNode config = connector.getValue();\n                writer.writeStartElement(Element.CONNECTOR.getLocalName());\n                writer.writeAttribute(NAME, connector.getName());\n                writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), config);\n                writeAttribute(writer, Attribute.SOCKET_BINDING.getLocalName(), config);\n                writeAttribute(writer, Attribute.SCHEME.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLED.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLE_LOOKUPS.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_NAME.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_PORT.getLocalName(), config);\n                writeAttribute(writer, Attribute.SECURE.getLocalName(), config);\n                writeAttribute(writer, Attribute.EXECUTOR.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_SAVE_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_CONNECTIONS.getLocalName(), config);\n                writeAttribute(writer, Attribute.REDIRECT_PORT.getLocalName(), config);\n                if (config.hasDefined(SSL)) {\n                    writer.writeStartElement(Element.SSL.getLocalName());\n                    final ModelNode sslConfig = config.get(SSL);\n                    writeAttribute(writer, Attribute.NAME.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.KEY_ALIAS.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PASSWORD.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_KEY_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CIPHER_SUITE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_CLIENT.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_DEPTH.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_REVOCATION_URL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_CACHE_SIZE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_TIMEOUT.getLocalName(), sslConfig);\n                    writer.writeEndElement();\n                }\n                if (config.hasDefined(VIRTUAL_SERVER)) {\n                    for(final ModelNode virtualServer : config.get(VIRTUAL_SERVER).asList()) {\n                        writer.writeEmptyElement(VIRTUAL_SERVER);\n                        writer.writeAttribute(NAME, virtualServer.asString());\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        if(node.hasDefined(VIRTUAL_SERVER)) {\n            for(final Property host : node.get(VIRTUAL_SERVER).asPropertyList()) {\n                final ModelNode config = host.getValue();\n                writer.writeStartElement(Element.VIRTUAL_SERVER.getLocalName());\n                writer.writeAttribute(NAME, host.getName());\n                writeAttribute(writer, Attribute.DEFAULT_WEB_MODULE.getLocalName(), config);\n                if (config.hasDefined(ENABLE_WELCOME_ROOT) && config.get(ENABLE_WELCOME_ROOT).asBoolean())\n                    writer.writeAttribute(ENABLE_WELCOME_ROOT, \"true\");\n\n                if(config.hasDefined(ALIAS)) {\n                    for(final ModelNode alias : config.get(ALIAS).asList()) {\n                        writer.writeEmptyElement(ALIAS);\n                        writer.writeAttribute(NAME, alias.asString());\n                    }\n                }\n                ModelNode accessLog;\n                if (config.get(ACCESS_LOG).isDefined() && config.get(ACCESS_LOG).has(\"configuration\")) {\n                    accessLog = config.get(ACCESS_LOG).get(\"configuration\");\n                } else {\n                    accessLog = config.get(ACCESS_LOG);\n                }\n                if (accessLog.isDefined() && !accessLog.keys().isEmpty()) {\n                    writer.writeStartElement(Element.ACCESS_LOG.getLocalName());\n                    final ModelNode accessLog = config.get(ACCESS_LOG);\n                    writeAttribute(writer, Attribute.PATTERN.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.RESOLVE_HOSTS.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.EXTENDED.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.PREFIX.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.ROTATE.getLocalName(), accessLog);\n                    if(accessLog.has(DIRECTORY)) {\n                        ModelNode directory;\n                        if (accessLog.get(DIRECTORY).has(\"configuration\"))\n                            directory = accessLog.get(DIRECTORY).get(\"configuration\");\n                        else\n                            directory = accessLog.get(DIRECTORY);\n                        if (directory.isDefined()) {\n                            writer.writeStartElement(Element.DIRECTORY.getLocalName());\n                            writeAttribute(writer, Attribute.PATH.getLocalName(), directory);\n                            writeAttribute(writer, Attribute.RELATIVE_TO.getLocalName(), directory);\n                            writer.writeEndElement();\n                        }\n                    }\n                    writer.writeEndElement();\n                }\n\n                if (config.hasDefined(REWRITE)) {\n                    for (final ModelNode rewritenode : config.get(REWRITE).asList()) {\n                        String name = getAddedRule(rewritenode);\n                        ModelNode rewrite;\n                        if (rewritenode.hasDefined(name))\n                            rewrite = rewritenode.get(name);\n                        else\n                            rewrite = rewritenode;\n                        writer.writeStartElement(REWRITE);\n                        writeAttribute(writer, Attribute.PATTERN.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.SUBSTITUTION.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.FLAGS.getLocalName(), rewrite);\n\n                        if (rewrite.hasDefined(CONDITION)) {\n                            for (final ModelNode conditionnode : rewrite.get(CONDITION).asList()) {\n                                String condname = getAddedConditionName(conditionnode);\n                                ModelNode condition;\n                                if (conditionnode.hasDefined(condname))\n                                    condition = conditionnode.get(condname);\n                                else\n                                    condition = conditionnode;\n                                writer.writeStartElement(CONDITION);\n                                writeAttribute(writer, Attribute.TEST.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.PATTERN.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.FLAGS.getLocalName(), condition);\n                            }\n                        }\n                        writer.writeEndElement();\n                    }\n                }\n                if(config.hasDefined(SSO)) {\n                    final ModelNode sso;\n                    if (config.get(SSO).has(\"configuration\"))\n                        sso = config.get(SSO).get(\"configuration\");\n                    else\n                        sso = config.get(SSO);\n                    if (sso.isDefined()) {\n                        writer.writeStartElement(SSO);\n                        writeAttribute(writer, Attribute.CACHE_CONTAINER.getLocalName(), sso);\n                        writeAttribute(writer, Attribute.DOMAIN.getLocalName(), sso);\n                        writeAttribute(writer, Attribute.REAUTHENTICATE.getLocalName(), sso);\n                        writer.writeEndElement();\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        writer.writeEndElement();\n    }","id":44382,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void writeContent(XMLExtendedStreamWriter writer, SubsystemMarshallingContext context) throws XMLStreamException {\n\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n\n        ModelNode node = context.getModelNode();\n\n        writeAttribute(writer, Attribute.NATIVE.getLocalName(), node);\n        writeAttribute(writer, Attribute.DEFAULT_VIRTUAL_SERVER.getLocalName(), node);\n        writeAttribute(writer, Attribute.INSTANCE_ID.getLocalName(), node);\n        if(node.hasDefined(CONTAINER_CONFIG)) {\n            writeContainerConfig(writer, node.get(CONTAINER_CONFIG));\n        }\n        if(node.hasDefined(CONNECTOR)) {\n            for(final Property connector : node.get(CONNECTOR).asPropertyList()) {\n                final ModelNode config = connector.getValue();\n                writer.writeStartElement(Element.CONNECTOR.getLocalName());\n                writer.writeAttribute(NAME, connector.getName());\n                writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), config);\n                writeAttribute(writer, Attribute.SOCKET_BINDING.getLocalName(), config);\n                writeAttribute(writer, Attribute.SCHEME.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLED.getLocalName(), config);\n                writeAttribute(writer, Attribute.ENABLE_LOOKUPS.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_NAME.getLocalName(), config);\n                writeAttribute(writer, Attribute.PROXY_PORT.getLocalName(), config);\n                writeAttribute(writer, Attribute.SECURE.getLocalName(), config);\n                writeAttribute(writer, Attribute.EXECUTOR.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_SAVE_POST_SIZE.getLocalName(), config);\n                writeAttribute(writer, Attribute.MAX_CONNECTIONS.getLocalName(), config);\n                writeAttribute(writer, Attribute.REDIRECT_PORT.getLocalName(), config);\n\n                ModelNode sslConfig;\n                if (config.get(SSL).isDefined() && config.get(SSL).has(\"configuration\")) {\n                    sslConfig = config.get(SSL).get(\"configuration\");\n                } else {\n                    sslConfig = config.get(SSL);\n                }\n                if (sslConfig.isDefined() && !sslConfig.keys().isEmpty()) {\n                    writer.writeStartElement(Element.SSL.getLocalName());\n                    writeAttribute(writer, Attribute.NAME.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.KEY_ALIAS.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PASSWORD.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_KEY_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CIPHER_SUITE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.PROTOCOL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_CLIENT.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.VERIFY_DEPTH.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_CERTIFICATE_FILE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.CA_REVOCATION_URL.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_CACHE_SIZE.getLocalName(), sslConfig);\n                    writeAttribute(writer, Attribute.SESSION_TIMEOUT.getLocalName(), sslConfig);\n                    writer.writeEndElement();\n                }\n                if (config.hasDefined(VIRTUAL_SERVER)) {\n                    for(final ModelNode virtualServer : config.get(VIRTUAL_SERVER).asList()) {\n                        writer.writeEmptyElement(VIRTUAL_SERVER);\n                        writer.writeAttribute(NAME, virtualServer.asString());\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        if(node.hasDefined(VIRTUAL_SERVER)) {\n            for(final Property host : node.get(VIRTUAL_SERVER).asPropertyList()) {\n                final ModelNode config = host.getValue();\n                writer.writeStartElement(Element.VIRTUAL_SERVER.getLocalName());\n                writer.writeAttribute(NAME, host.getName());\n                writeAttribute(writer, Attribute.DEFAULT_WEB_MODULE.getLocalName(), config);\n                if (config.hasDefined(ENABLE_WELCOME_ROOT) && config.get(ENABLE_WELCOME_ROOT).asBoolean())\n                    writer.writeAttribute(ENABLE_WELCOME_ROOT, \"true\");\n\n                if(config.hasDefined(ALIAS)) {\n                    for(final ModelNode alias : config.get(ALIAS).asList()) {\n                        writer.writeEmptyElement(ALIAS);\n                        writer.writeAttribute(NAME, alias.asString());\n                    }\n                }\n                ModelNode accessLog;\n                if (config.get(ACCESS_LOG).isDefined() && config.get(ACCESS_LOG).has(\"configuration\")) {\n                    accessLog = config.get(ACCESS_LOG).get(\"configuration\");\n                } else {\n                    accessLog = config.get(ACCESS_LOG);\n                }\n                if (accessLog.isDefined() && !accessLog.keys().isEmpty()) {\n                    writer.writeStartElement(Element.ACCESS_LOG.getLocalName());\n                    final ModelNode accessLog = config.get(ACCESS_LOG);\n                    writeAttribute(writer, Attribute.PATTERN.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.RESOLVE_HOSTS.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.EXTENDED.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.PREFIX.getLocalName(), accessLog);\n                    writeAttribute(writer, Attribute.ROTATE.getLocalName(), accessLog);\n                    if(accessLog.has(DIRECTORY)) {\n                        ModelNode directory;\n                        if (accessLog.get(DIRECTORY).has(\"configuration\"))\n                            directory = accessLog.get(DIRECTORY).get(\"configuration\");\n                        else\n                            directory = accessLog.get(DIRECTORY);\n                        if (directory.isDefined()) {\n                            writer.writeStartElement(Element.DIRECTORY.getLocalName());\n                            writeAttribute(writer, Attribute.PATH.getLocalName(), directory);\n                            writeAttribute(writer, Attribute.RELATIVE_TO.getLocalName(), directory);\n                            writer.writeEndElement();\n                        }\n                    }\n                    writer.writeEndElement();\n                }\n\n                if (config.hasDefined(REWRITE)) {\n                    for (final ModelNode rewritenode : config.get(REWRITE).asList()) {\n                        String name = getAddedRule(rewritenode);\n                        ModelNode rewrite;\n                        if (rewritenode.hasDefined(name))\n                            rewrite = rewritenode.get(name);\n                        else\n                            rewrite = rewritenode;\n                        writer.writeStartElement(REWRITE);\n                        writeAttribute(writer, Attribute.PATTERN.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.SUBSTITUTION.getLocalName(), rewrite);\n                        writeAttribute(writer, Attribute.FLAGS.getLocalName(), rewrite);\n\n                        if (rewrite.hasDefined(CONDITION)) {\n                            for (final ModelNode conditionnode : rewrite.get(CONDITION).asList()) {\n                                String condname = getAddedConditionName(conditionnode);\n                                ModelNode condition;\n                                if (conditionnode.hasDefined(condname))\n                                    condition = conditionnode.get(condname);\n                                else\n                                    condition = conditionnode;\n                                writer.writeStartElement(CONDITION);\n                                writeAttribute(writer, Attribute.TEST.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.PATTERN.getLocalName(), condition);\n                                writeAttribute(writer, Attribute.FLAGS.getLocalName(), condition);\n                            }\n                        }\n                        writer.writeEndElement();\n                    }\n                }\n                if(config.hasDefined(SSO)) {\n                    final ModelNode sso;\n                    if (config.get(SSO).has(\"configuration\"))\n                        sso = config.get(SSO).get(\"configuration\");\n                    else\n                        sso = config.get(SSO);\n                    if (sso.isDefined()) {\n                        writer.writeStartElement(SSO);\n                        writeAttribute(writer, Attribute.CACHE_CONTAINER.getLocalName(), sso);\n                        writeAttribute(writer, Attribute.DOMAIN.getLocalName(), sso);\n                        writeAttribute(writer, Attribute.REAUTHENTICATE.getLocalName(), sso);\n                        writer.writeEndElement();\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n        writer.writeEndElement();\n    }","commit_id":"4c27df32029ea9025896b5251a5ff10553cf2074","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n   * Check if copying srcName to dst would overwrite an existing \n   * file or directory.\n   * @param srcName File or directory to be copied.\n   * @param dst Destination to copy srcName to.\n   * @param overwrite Whether it's ok to overwrite an existing file. \n   * @throws AccessControlException If access is denied.\n   * @throws IOException If dst is an existing directory, or dst is an \n   * existing file and the overwrite option is not passed.\n   */\n  private void checkDest(String srcName, Path dst, boolean overwrite)\n      throws AccessControlException, IOException {\n    try {\n      FileStatus dstFs = getFileStatus(dst);\n      if (dstFs.isDirectory()) {\n        if (null == srcName) {\n          throw new IOException(\"Target \" + dst + \" is a directory\");\n        }\n        // Recurse to check if dst/srcName exists.\n        checkDest(null, new Path(dst, srcName), overwrite);\n      } else if (!overwrite) {\n        throw new IOException(\"Target \" + dst + \" already exists\");\n      }\n    } catch (FileNotFoundException e) {\n      // dst does not exist - OK to copy.\n    }\n  }","id":44383,"modified_method":"/**\n   * Check if copying srcName to dst would overwrite an existing \n   * file or directory.\n   * @param srcName File or directory to be copied.\n   * @param dst Destination to copy srcName to.\n   * @param overwrite Whether it's ok to overwrite an existing file. \n   * @throws AccessControlException If access is denied.\n   * @throws IOException If dst is an existing directory, or dst is an \n   * existing file and the overwrite option is not passed.\n   */\n  private void checkDest(String srcName, Path dst, boolean overwrite)\n      throws AccessControlException, IOException {\n    try {\n      FileStatus dstFs = getFileStatus(dst);\n      if (dstFs.isDirectory()) {\n        if (null == srcName) {\n          throw new IOException(\"Target \" + dst + \" is a directory\");\n        }\n        // Recurse to check if dst/srcName exists.\n        checkDest(null, new Path(dst, srcName), overwrite);\n      } else if (!overwrite) {\n        throw new IOException(\"Target \" + new Path(dst, srcName)\n            + \" already exists\");\n      }\n    } catch (FileNotFoundException e) {\n      // dst does not exist - OK to copy.\n    }\n  }","commit_id":"ad5306f24ccb42ced48a95419850f41d662fc5ac","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Are qualSrc and qualDst of the same file system?\n   * @param qualPath1 - fully qualified path\n   * @param qualPath2 - fully qualified path\n   * @return\n   */\n  private static boolean isSameFS(Path qualPath1, Path qualPath2) {\n    URI srcUri = qualPath1.toUri();\n    URI dstUri = qualPath2.toUri();\n    return (srcUri.getAuthority().equals(dstUri.getAuthority()) && srcUri\n        .getAuthority().equals(dstUri.getAuthority()));\n  }","id":44384,"modified_method":"/**\n   * Are qualSrc and qualDst of the same file system?\n   * @param qualPath1 - fully qualified path\n   * @param qualPath2 - fully qualified path\n   * @return\n   */\n  private static boolean isSameFS(Path qualPath1, Path qualPath2) {\n    URI srcUri = qualPath1.toUri();\n    URI dstUri = qualPath2.toUri();\n    return (srcUri.getScheme().equals(dstUri.getScheme()) && \n        !(srcUri.getAuthority() != null && dstUri.getAuthority() != null && srcUri\n        .getAuthority().equals(dstUri.getAuthority())));\n  }","commit_id":"ad5306f24ccb42ced48a95419850f41d662fc5ac","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * Copy from src to dst, optionally deleting src and overwriting dst.\n     * @param src\n     * @param dst\n     * @param deleteSource - delete src if true\n     * @param overwrite  overwrite dst if true; throw IOException if dst exists\n     *         and overwrite is false.\n     *\n     * @return true if copy is successful\n     *\n     * @throws AccessControlException If access is denied\n     * @throws FileAlreadyExistsException If <code>dst<\/code> already exists\n     * @throws FileNotFoundException If <code>src<\/code> does not exist\n     * @throws ParentNotDirectoryException If parent of <code>dst<\/code> is not\n     *           a directory\n     * @throws UnsupportedFileSystemException If file system for \n     *         <code>src<\/code> or <code>dst<\/code> is not supported\n     * @throws IOException If an I/O error occurred\n     * \n     * Exceptions applicable to file systems accessed over RPC:\n     * @throws RpcClientException If an exception occurred in the RPC client\n     * @throws RpcServerException If an exception occurred in the RPC server\n     * @throws UnexpectedServerException If server implementation throws \n     *           undeclared exception to RPC server\n     * \n     * RuntimeExceptions:\n     * @throws InvalidPathException If path <code>dst<\/code> is invalid\n     */\n    public boolean copy(final Path src, final Path dst, boolean deleteSource,\n        boolean overwrite) throws AccessControlException,\n        FileAlreadyExistsException, FileNotFoundException,\n        ParentNotDirectoryException, UnsupportedFileSystemException, \n\tIOException {\n      checkNotSchemeWithRelative(src);\n      checkNotSchemeWithRelative(dst);\n      Path qSrc = makeQualified(src);\n      Path qDst = makeQualified(dst);\n      checkDest(qSrc.getName(), qDst, overwrite);\n      FileStatus fs = FileContext.this.getFileStatus(qSrc);\n      if (fs.isDirectory()) {\n        checkDependencies(qSrc, qDst);\n        mkdir(qDst, FsPermission.getDefault(), true);\n        FileStatus[] contents = listStatus(qSrc);\n        for (FileStatus content : contents) {\n          copy(content.getPath(), new Path(qDst, content.getPath()),\n               deleteSource, overwrite);\n        }\n      } else {\n        InputStream in=null;\n        OutputStream out = null;\n        try {\n          in = open(qSrc);\n          out = create(qDst, EnumSet.of(CreateFlag.OVERWRITE));\n          IOUtils.copyBytes(in, out, conf, true);\n        } catch (IOException e) {\n          IOUtils.closeStream(out);\n          IOUtils.closeStream(in);\n          throw e;\n        }\n      }\n      if (deleteSource) {\n        return delete(qSrc, true);\n      } else {\n        return true;\n      }\n    }","id":44385,"modified_method":"/**\n     * Copy from src to dst, optionally deleting src and overwriting dst.\n     * @param src\n     * @param dst\n     * @param deleteSource - delete src if true\n     * @param overwrite  overwrite dst if true; throw IOException if dst exists\n     *         and overwrite is false.\n     *\n     * @return true if copy is successful\n     *\n     * @throws AccessControlException If access is denied\n     * @throws FileAlreadyExistsException If <code>dst<\/code> already exists\n     * @throws FileNotFoundException If <code>src<\/code> does not exist\n     * @throws ParentNotDirectoryException If parent of <code>dst<\/code> is not\n     *           a directory\n     * @throws UnsupportedFileSystemException If file system for \n     *         <code>src<\/code> or <code>dst<\/code> is not supported\n     * @throws IOException If an I/O error occurred\n     * \n     * Exceptions applicable to file systems accessed over RPC:\n     * @throws RpcClientException If an exception occurred in the RPC client\n     * @throws RpcServerException If an exception occurred in the RPC server\n     * @throws UnexpectedServerException If server implementation throws \n     *           undeclared exception to RPC server\n     * \n     * RuntimeExceptions:\n     * @throws InvalidPathException If path <code>dst<\/code> is invalid\n     */\n    public boolean copy(final Path src, final Path dst, boolean deleteSource,\n        boolean overwrite) throws AccessControlException,\n        FileAlreadyExistsException, FileNotFoundException,\n        ParentNotDirectoryException, UnsupportedFileSystemException, \n\tIOException {\n      checkNotSchemeWithRelative(src);\n      checkNotSchemeWithRelative(dst);\n      Path qSrc = makeQualified(src);\n      Path qDst = makeQualified(dst);\n      checkDest(qSrc.getName(), qDst, overwrite);\n      FileStatus fs = FileContext.this.getFileStatus(qSrc);\n      if (fs.isDirectory()) {\n        checkDependencies(qSrc, qDst);\n        mkdir(qDst, FsPermission.getDefault(), true);\n        FileStatus[] contents = listStatus(qSrc);\n        for (FileStatus content : contents) {\n          copy(makeQualified(content.getPath()), makeQualified(new Path(qDst,\n              content.getPath().getName())), deleteSource, overwrite);\n        }\n      } else {\n        InputStream in=null;\n        OutputStream out = null;\n        try {\n          in = open(qSrc);\n          out = create(qDst, EnumSet.of(CreateFlag.OVERWRITE));\n          IOUtils.copyBytes(in, out, conf, true);\n        } catch (IOException e) {\n          IOUtils.closeStream(out);\n          IOUtils.closeStream(in);\n          throw e;\n        }\n      }\n      if (deleteSource) {\n        return delete(qSrc, true);\n      } else {\n        return true;\n      }\n    }","commit_id":"ad5306f24ccb42ced48a95419850f41d662fc5ac","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n    public boolean login() throws LoginException {\n        return LoginModuleUtils.doLogin(this);\n    }","id":44386,"modified_method":"@Override\n    public boolean login() throws LoginException {\n        return LoginModuleUtils.doLogin(this, m_subject, m_sharedState, m_options);\n    }","commit_id":"ce57d9fa4d39020311cad4ac32ea291586d56228","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void initialize(final Subject subject, final CallbackHandler callbackHandler, final Map<String, ?> sharedState, final Map<String, ?> options) {\n        LOG.info(\"OpenNMS Login Module initializing.\");\n        m_subject = subject;\n        m_callbackHandler = callbackHandler;\n    }","id":44387,"modified_method":"@Override\n    public void initialize(final Subject subject, final CallbackHandler callbackHandler, final Map<String, ?> sharedState, final Map<String, ?> options) {\n        LOG.info(\"OpenNMS Login Module initializing.\");\n        m_subject = subject;\n        m_callbackHandler = callbackHandler;\n        m_sharedState = sharedState;\n        m_options = options;\n    }","commit_id":"ce57d9fa4d39020311cad4ac32ea291586d56228","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public boolean login() throws LoginException {\n        return LoginModuleUtils.doLogin(this);\n    }","id":44388,"modified_method":"@Override\n    public boolean login() throws LoginException {\n        return LoginModuleUtils.doLogin(this, m_subject, m_sharedState, m_options);\n    }","commit_id":"ce57d9fa4d39020311cad4ac32ea291586d56228","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void initialize(final Subject subject, final CallbackHandler callbackHandler, final Map<String, ?> sharedState, final Map<String, ?> options) {\n        LOG.info(\"OpenNMS Login Module initializing.\");\n        super.initialize(subject, callbackHandler, options);\n    }","id":44389,"modified_method":"@Override\n    public void initialize(final Subject subject, final CallbackHandler callbackHandler, final Map<String, ?> sharedState, final Map<String, ?> options) {\n        LOG.info(\"OpenNMS Login Module initializing: subject={}, callbackHandler={}, sharedState={}, options={}\", subject, callbackHandler, sharedState, options);\n        m_subject = subject;\n        m_sharedState = sharedState;\n        m_options = options;\n        super.initialize(subject, callbackHandler, options);\n    }","commit_id":"ce57d9fa4d39020311cad4ac32ea291586d56228","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Set<Principal> createPrincipals(final GrantedAuthority authority) {\n        final String role = authority.getAuthority().toLowerCase().replaceFirst(\"^role_\", \"\");\n        final Set<Principal> principals = new HashSet<Principal>();\n        principals.add(new RolePrincipal(role));\n        principals.add(new RolePrincipal(authority.getAuthority()));\n        return principals;\n    }","id":44390,"modified_method":"public Set<Principal> createPrincipals(final GrantedAuthority authority) {\n        final String role = authority.getAuthority().replaceFirst(\"^[Rr][Oo][Ll][Ee]_\", \"\");\n        final Set<Principal> principals = new HashSet<Principal>();\n        principals.add(new RolePrincipal(role));\n        principals.add(new RolePrincipal(role.toLowerCase()));\n        principals.add(new RolePrincipal(authority.getAuthority()));\n        LOG.debug(\"created principals from authority {}: {}\", authority, principals);\n        return principals;\n    }","commit_id":"ce57d9fa4d39020311cad4ac32ea291586d56228","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Parses the magic-users.properties file into two mappings: from magic\n     * username to password, and from magic role to authorized users of that\n     * role.\n     */\n    public void parseMagicUsers() throws DataRetrievalFailureException {\n        HashMap<String, OnmsUser> magicUsers = new HashMap<String, OnmsUser>();\n        Map<String, Collection<? extends GrantedAuthority>> roles = new HashMap<String, Collection<? extends GrantedAuthority>>();\n\n        long lastModified = new File(m_magicUsersConfigurationFile).lastModified();\n\n        // read the file\n        Properties properties = new Properties();\n        try {\n            properties.load(new FileInputStream(m_magicUsersConfigurationFile));\n        } catch (FileNotFoundException e) {\n            throw new DataRetrievalFailureException(\"Magic users configuration file '\" + m_magicUsersConfigurationFile + \"' not found: \" + e.getMessage(), e);\n        } catch (IOException e) {\n            throw new DataRetrievalFailureException(\"Error reading magic users configuration file '\" + m_magicUsersConfigurationFile + \"': \" + e.getMessage(), e);\n        }\n\n        // look up users and their passwords\n        String[] configuredUsers = BundleLists.parseBundleList(properties.getProperty(\"users\"));\n\n        for (String user : configuredUsers) {\n            String username = properties.getProperty(\"user.\" + user + \".username\");\n            String password = properties.getProperty(\"user.\" + user + \".password\");\n\n            OnmsUser newUser = null;\n            try {\n                newUser = m_userManager.getOnmsUser(user);\n            } catch (final Exception ioe) {\n                throw new DataRetrievalFailureException(\"Unable to read user \" + user + \" from users.xml\", ioe);\n            }\n            \n            if (newUser == null) {\n                newUser = new OnmsUser();\n                newUser.setUsername(username);\n                newUser.setPassword(m_userManager.encryptedPassword(password, true));\n                newUser.setPasswordSalted(true);\n            }\n\n            magicUsers.put(username, newUser);\n        }\n\n        String[] configuredRoles = BundleLists.parseBundleList(properties.getProperty(\"roles\"));\n        // Use roles from the groups.xml file if specified in applicationContext-spring-security.xml\n        Map<String, LinkedList<String>> roleMap = m_useGroups ? parseGroupRoles() \n                                                              : new HashMap<String, LinkedList<String>>();\n        Map<String, Boolean> roleAddDefaultMap = new HashMap<String, Boolean>();\n        for (String role : configuredRoles) {\n            String rolename = properties.getProperty(\"role.\" + role + \".name\");\n            if (rolename == null) {\n                  LOG.warn(\"Role configuration for '{}' does not have 'name' parameter.  Expecting a 'role.{}.name' property. The role will not be usable.\", role, role);\n                  continue;\n            }\n\n            String userList = properties.getProperty(\"role.\" + role + \".users\");\n            if (userList == null) {\n                LOG.warn(\"Role configuration for '{}' does not have 'users' parameter.  Expecting a 'role.{}.users' property. The role will not be usable.\", role, role);\n                continue;\n            }\n            String[] authUsers = BundleLists.parseBundleList(userList);\n\n            boolean notInDefaultGroup = \"true\".equals(properties.getProperty(\"role.\" + role + \".notInDefaultGroup\"));\n\n            String securityRole = Authentication.getSpringSecurityRoleFromOldRoleName(rolename);\n            if (securityRole == null) {\n                throw new DataRetrievalFailureException(\"Could not find Spring Security role mapping for old role name '\" + rolename + \"' for role '\" + role + \"'\");\n            }\n\n            for (String authUser : authUsers) {\n                if (roleMap.get(authUser) == null) {\n                    roleMap.put(authUser, new LinkedList<String>());\n                }\n                LinkedList<String> userRoleList = roleMap.get(authUser); \n                userRoleList.add(securityRole);\n            }\n            \n            roleAddDefaultMap.put(securityRole, !notInDefaultGroup);\n        }\n\n        for (final Entry<String, LinkedList<String>> entry : roleMap.entrySet()) {\n            roles.put(entry.getKey(), getAuthorityListFromRoleList(entry.getValue(), roleAddDefaultMap));\n        }\n        \n        LOG.debug(\"Loaded the magic-users.properties file with {} magic users, {} roles, and {} user roles\", magicUsers.size(), configuredRoles.length, roles.size());\n\n\n        m_magicUsersLastModified = lastModified; \n        m_magicUsers = magicUsers;\n        m_roles = roles;\n    }","id":44391,"modified_method":"/**\n     * Parses the magic-users.properties file into two mappings: from magic\n     * username to password, and from magic role to authorized users of that\n     * role.\n     */\n    public void parseMagicUsers() throws DataRetrievalFailureException {\n        HashMap<String, OnmsUser> magicUsers = new HashMap<String, OnmsUser>();\n        Map<String, Collection<? extends GrantedAuthority>> roles = new HashMap<String, Collection<? extends GrantedAuthority>>();\n\n        long lastModified = new File(m_magicUsersConfigurationFile).lastModified();\n\n        // read the file\n        Properties properties = new Properties();\n        try {\n            properties.load(new FileInputStream(m_magicUsersConfigurationFile));\n        } catch (FileNotFoundException e) {\n            throw new DataRetrievalFailureException(\"Magic users configuration file '\" + m_magicUsersConfigurationFile + \"' not found: \" + e.getMessage(), e);\n        } catch (IOException e) {\n            throw new DataRetrievalFailureException(\"Error reading magic users configuration file '\" + m_magicUsersConfigurationFile + \"': \" + e.getMessage(), e);\n        }\n\n        // look up users and their passwords\n        String[] configuredUsers = BundleLists.parseBundleList(properties.getProperty(\"users\"));\n\n        for (String user : configuredUsers) {\n            String username = properties.getProperty(\"user.\" + user + \".username\");\n            String password = properties.getProperty(\"user.\" + user + \".password\");\n\n            OnmsUser newUser = null;\n            try {\n                newUser = m_userManager.getOnmsUser(user);\n            } catch (final Exception ioe) {\n                throw new DataRetrievalFailureException(\"Unable to read user \" + user + \" from users.xml\", ioe);\n            }\n            \n            if (newUser == null) {\n                newUser = new OnmsUser();\n                newUser.setUsername(username);\n                newUser.setPassword(m_userManager.encryptedPassword(password, true));\n                newUser.setPasswordSalted(true);\n            }\n\n            magicUsers.put(username, newUser);\n        }\n\n        String[] configuredRoles = BundleLists.parseBundleList(properties.getProperty(\"roles\"));\n        // Use roles from the groups.xml file if specified in applicationContext-spring-security.xml\n        Map<String, LinkedList<String>> roleMap = m_useGroups ? parseGroupRoles() \n                                                              : new HashMap<String, LinkedList<String>>();\n        Map<String, Boolean> roleAddDefaultMap = new HashMap<String, Boolean>();\n        for (final String role : configuredRoles) {\n            final String rolename = properties.getProperty(\"role.\" + role + \".name\");\n            if (rolename == null) {\n                  LOG.warn(\"Role configuration for '{}' does not have 'name' parameter.  Expecting a 'role.{}.name' property. The role will not be usable.\", role, role);\n                  continue;\n            }\n\n            String userList = properties.getProperty(\"role.\" + role + \".users\");\n            if (userList == null) {\n                LOG.warn(\"Role configuration for '{}' does not have 'users' parameter.  Expecting a 'role.{}.users' property. The role will not be usable.\", role, role);\n                continue;\n            }\n            String[] authUsers = BundleLists.parseBundleList(userList);\n\n            boolean notInDefaultGroup = \"true\".equals(properties.getProperty(\"role.\" + role + \".notInDefaultGroup\"));\n\n            String securityRole = Authentication.getSpringSecurityRoleFromOldRoleName(rolename);\n            if (securityRole == null) {\n                final String newRolename = role.replaceAll(\"[^\\\\p{Alnum}]+\", \"_\");\n                if (newRolename.matches(\"^[Rr][Oo][Ll][Ee]_\")) {\n                    securityRole = newRolename.replaceAll(\"^[Rr][Oo][Ll][Ee]_\", \"ROLE_\");\n                } else {\n                    securityRole = \"ROLE_\" + newRolename;\n                }\n                LOG.warn(\"Role '{}' does not have an old (hardcoded) role name!  Returning '{}'.\", role, securityRole);\n            }\n\n            for (String authUser : authUsers) {\n                if (roleMap.get(authUser) == null) {\n                    roleMap.put(authUser, new LinkedList<String>());\n                }\n                LinkedList<String> userRoleList = roleMap.get(authUser); \n                userRoleList.add(securityRole);\n            }\n            \n            roleAddDefaultMap.put(securityRole, !notInDefaultGroup);\n        }\n\n        for (final Entry<String, LinkedList<String>> entry : roleMap.entrySet()) {\n            roles.put(entry.getKey(), getAuthorityListFromRoleList(entry.getValue(), roleAddDefaultMap));\n        }\n        \n        LOG.debug(\"Loaded the magic-users.properties file with {} magic users, {} roles, and {} user roles\", magicUsers.size(), configuredRoles.length, roles.size());\n\n\n        m_magicUsersLastModified = lastModified; \n        m_magicUsers = magicUsers;\n        m_roles = roles;\n    }","commit_id":"ce57d9fa4d39020311cad4ac32ea291586d56228","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testFindString() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    String text = \"public static class MyClass{\\n/*done*/\\npublic static void main(){}}\";\n    FindResult findResult = findManager.findString(text, 0, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(true);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    findResult = findManager.findString(text, 40, findModel);\n    assertFalse(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(true);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setForward(false);\n\n    findResult = findManager.findString(text, 40, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    findResult = findManager.findString(text, 0, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"don\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    final FindResult[] findResultArr = new FindResult[1];\n    findInNewThread(findModel, findManager, text, 0, findResultArr);\n    new WaitFor(30 *1000){\n      @Override\n      protected boolean condition() {\n        return findResultArr[0] != null;\n      }\n    }.assertCompleted();\n\n    assertFalse(findResultArr[0].isStringFound());\n  }","id":44392,"modified_method":"public void testFindString() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String text = \"public static class MyClass{\\n/*done*/\\npublic static void main(){}}\";\n    FindResult findResult = findManager.findString(text, 0, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(true);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    findResult = findManager.findString(text, 40, findModel);\n    assertFalse(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(true);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setForward(false);\n\n    findResult = findManager.findString(text, 40, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    findResult = findManager.findString(text, 0, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"don\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    final FindResult[] findResultArr = new FindResult[1];\n    findInNewThread(findModel, findManager, text, 0, findResultArr);\n    new WaitFor(30 *1000){\n      @Override\n      protected boolean condition() {\n        return findResultArr[0] != null;\n      }\n    }.assertCompleted();\n\n    assertFalse(findResultArr[0].isStringFound());\n  }","commit_id":"b95a17fcc1077a558d98b97ce302b6e2464db4e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInUserFileType() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    String text = \"\\\"done done\\\"; 'done'; // done\\n\" +\n                  \"/* done\\n\" +\n                  \"done */\";\n\n    runFindInCommentsAndLiterals(findManager, findModel, text, \"cs\");\n  }","id":44393,"modified_method":"public void testFindInUserFileType() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String text = \"\\\"done done\\\"; 'done'; // done\\n\" +\n                  \"/* done\\n\" +\n                  \"done */\";\n\n    FindManagerTestUtils.runFindInCommentsAndLiterals(findManager, findModel, text, \"cs\");\n  }","commit_id":"b95a17fcc1077a558d98b97ce302b6e2464db4e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInCommentsProperlyWorksWithOffsets() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    String prefix = \"/*\";\n    String text = prefix + \"done*/\";\n\n    findModel.setInCommentsOnly(true);\n    LightVirtualFile file = new LightVirtualFile(\"A.java\", text);\n\n    FindResult findResult = findManager.findString(text, prefix.length(), findModel, file);\n    assertTrue(findResult.isStringFound());\n\n    findModel.setRegularExpressions(true);\n    findResult = findManager.findString(text, prefix.length(), findModel, file);\n    assertTrue(findResult.isStringFound());\n  }","id":44394,"modified_method":"public void testFindInCommentsProperlyWorksWithOffsets() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String prefix = \"/*\";\n    String text = prefix + \"done*/\";\n\n    findModel.setInCommentsOnly(true);\n    LightVirtualFile file = new LightVirtualFile(\"A.java\", text);\n\n    FindResult findResult = findManager.findString(text, prefix.length(), findModel, file);\n    assertTrue(findResult.isStringFound());\n\n    findModel.setRegularExpressions(true);\n    findResult = findManager.findString(text, prefix.length(), findModel, file);\n    assertTrue(findResult.isStringFound());\n  }","commit_id":"b95a17fcc1077a558d98b97ce302b6e2464db4e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInCommentsAndLiterals() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    String text = \"\\\"done done done\\\" /* done done done */\";\n\n    runFindInCommentsAndLiterals(findManager, findModel, text);\n\n    findModel.setRegularExpressions(true);\n    runFindInCommentsAndLiterals(findManager, findModel, text);\n  }","id":44395,"modified_method":"public void testFindInCommentsAndLiterals() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String text = \"\\\"done done done\\\" /* done done done */\";\n\n    FindManagerTestUtils.runFindInCommentsAndLiterals(findManager, findModel, text);\n\n    findModel.setRegularExpressions(true);\n    FindManagerTestUtils.runFindInCommentsAndLiterals(findManager, findModel, text);\n  }","commit_id":"b95a17fcc1077a558d98b97ce302b6e2464db4e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInLiteralToSkipQuotes() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"^done$\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setRegularExpressions(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    String text = \"\\\"done\\\"; 'done'; 'done' \\\"done2\\\"\";\n\n    findModel.setInStringLiteralsOnly(true);\n    findModel.setInCommentsOnly(false);\n    runFindForwardAndBackward(findManager, findModel, text, \"java\");\n\n    text = \"def n = \\\"\\\"\\\"done\\\"\\\"\\\"\\n def n = /done/\\n def n = \\\"done\\\"\\n def n = \\\"done2\\\"\";\n\n    runFindForwardAndBackward(findManager, findModel, text, \"groovy\");\n\n    text = \"\\\"\\\"; \\\"done\\\"; 'done'; 'done' \\\"done2\\\"\";\n\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setRegularExpressions(false);\n\n    runFindForwardAndBackward(findManager, findModel, text, \"java\");\n  }","id":44396,"modified_method":"public void testFindInLiteralToSkipQuotes() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"^done$\");\n    findModel.setRegularExpressions(true);\n\n    String text = \"\\\"done\\\"; 'done'; 'done' \\\"done2\\\"\";\n\n    findModel.setInStringLiteralsOnly(true);\n    findModel.setInCommentsOnly(false);\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text, \"java\");\n\n    text = \"def n = \\\"\\\"\\\"done\\\"\\\"\\\"\\n def n = /done/\\n def n = \\\"done\\\"\\n def n = \\\"done2\\\"\";\n\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text, \"groovy\");\n\n    text = \"\\\"\\\"; \\\"done\\\"; 'done'; 'done' \\\"done2\\\"\";\n\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setRegularExpressions(false);\n\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text, \"java\");\n  }","commit_id":"b95a17fcc1077a558d98b97ce302b6e2464db4e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInJavaDocs() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    String text = \"/** done done done */\";\n\n    findModel.setInCommentsOnly(true);\n    runFindForwardAndBackward(findManager, findModel, text);\n\n    findModel.setRegularExpressions(true);\n    runFindForwardAndBackward(findManager, findModel, text);\n  }","id":44397,"modified_method":"public void testFindInJavaDocs() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String text = \"/** done done done */\";\n\n    findModel.setInCommentsOnly(true);\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text);\n\n    findModel.setRegularExpressions(true);\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text);\n  }","commit_id":"b95a17fcc1077a558d98b97ce302b6e2464db4e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected PsiFile configureByText(@NotNull final FileType fileType, @NonNls final String text, @Nullable String _extension) throws Exception {\n    final String extension = _extension == null ? fileType.getDefaultExtension():_extension;\n\n    File dir = createTempDirectory();\n    final File tempFile = FileUtil.createTempFile(dir, \"aaa\", \".\" + extension, true);\n    final FileTypeManager fileTypeManager = FileTypeManager.getInstance();\n    if (fileTypeManager.getFileTypeByExtension(extension) != fileType) {\n      new WriteCommandAction(getProject()) {\n        @Override\n        protected void run(Result result) throws Exception {\n          fileTypeManager.associateExtension(fileType, extension);\n        }\n      }.execute();\n    }\n    final VirtualFile vFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempFile);\n    assert vFile != null;\n    VfsUtil.saveText(vFile, text);\n\n    final VirtualFile vdir = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(dir);\n\n    PsiTestUtil.addSourceRoot(myModule, vdir);\n\n    configureByExistingFile(vFile);\n\n    assertEquals(fileType, myFile.getVirtualFile().getFileType());\n    return myFile;\n  }","id":44398,"modified_method":"protected PsiFile configureByText(@NotNull final FileType fileType, @NonNls final String text, @Nullable String _extension) {\n    try {\n      final String extension = _extension == null ? fileType.getDefaultExtension():_extension;\n\n      File dir = createTempDirectory();\n      final File tempFile = FileUtil.createTempFile(dir, \"aaa\", \".\" + extension, true);\n      final FileTypeManager fileTypeManager = FileTypeManager.getInstance();\n      if (fileTypeManager.getFileTypeByExtension(extension) != fileType) {\n        new WriteCommandAction(getProject()) {\n          @Override\n          protected void run(Result result) throws Exception {\n            fileTypeManager.associateExtension(fileType, extension);\n          }\n        }.execute();\n      }\n      final VirtualFile vFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(tempFile);\n      assert vFile != null;\n      VfsUtil.saveText(vFile, text);\n\n      final VirtualFile vdir = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(dir);\n\n      PsiTestUtil.addSourceRoot(myModule, vdir);\n\n      configureByExistingFile(vFile);\n\n      assertEquals(fileType, myFile.getVirtualFile().getFileType());\n      return myFile;\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInCommentsAndLiterals() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String text = \"\\\"done done done\\\" /* done done done */\";\n\n    FindManagerTestUtils.runFindInCommentsAndLiterals(findManager, findModel, text);\n\n    findModel.setRegularExpressions(true);\n    FindManagerTestUtils.runFindInCommentsAndLiterals(findManager, findModel, text);\n  }","id":44399,"modified_method":"public void testFindInCommentsAndLiterals() {\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String text = \"\\\"done done done\\\" /* done done done */\";\n    FindManagerTestUtils.runFindInCommentsAndLiterals(myFindManager, findModel, text);\n\n    findModel.setRegularExpressions(true);\n    FindManagerTestUtils.runFindInCommentsAndLiterals(myFindManager, findModel, text);\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testReplaceAll() throws Throwable {\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = new FindModel();\n    String toFind = \"xxx\";\n    String toReplace = \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\";\n    findModel.setStringToFind(toFind);\n    findModel.setStringToReplace(toReplace);\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setRegularExpressions(false);\n    findModel.setPromptOnReplace(false);\n\n    findManager.setFindNextModel(null);\n    findManager.getFindInFileModel().copyFrom(findModel);\n\n    String text = StringUtil.repeat(toFind + \"\\n\",6);\n    configureByText(FileTypes.PLAIN_TEXT, text);\n\n    List<Usage> usages = FindUtil.findAll(getProject(), myEditor, findModel);\n    for (Usage usage : usages) {\n      ReplaceInProjectManager.getInstance(getProject()).replaceUsage(usage, findModel, Collections.<Usage>emptySet(), false);\n    }\n    String newText = StringUtil.repeat(toReplace + \"\\n\",6);\n    assertEquals(newText, getEditor().getDocument().getText());\n  }","id":44400,"modified_method":"public void testReplaceAll() throws FindManager.MalformedReplacementStringException {\n    FindModel findModel = new FindModel();\n    String toFind = \"xxx\";\n    @SuppressWarnings(\"SpellCheckingInspection\") String toReplace = \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\";\n    findModel.setStringToFind(toFind);\n    findModel.setStringToReplace(toReplace);\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setRegularExpressions(false);\n    findModel.setPromptOnReplace(false);\n\n    myFindManager.setFindNextModel(null);\n    myFindManager.getFindInFileModel().copyFrom(findModel);\n\n    String text = StringUtil.repeat(toFind + \"\\n\",6);\n    configureByText(FileTypes.PLAIN_TEXT, text);\n\n    List<Usage> usages = FindUtil.findAll(getProject(), myEditor, findModel);\n    assertNotNull(usages);\n    for (Usage usage : usages) {\n      ReplaceInProjectManager.getInstance(getProject()).replaceUsage(usage, findModel, Collections.<Usage>emptySet(), false);\n    }\n    String newText = StringUtil.repeat(toReplace + \"\\n\",6);\n    assertEquals(newText, getEditor().getDocument().getText());\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindUsages() throws Exception{\n    initProject(\"findManager\", \"src\", \"src1\");\n    final String projectDir = (PathManagerEx.getTestDataPath() + \"/find/findManager\").replace('/', File.separatorChar);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(true);\n    findModel.setProjectScope(true);\n    findModel.setDirectoryName(projectDir + File.separatorChar + \"src1\");\n    findModel.setWithSubdirectories(true);\n    checkFindUsages(12, findModel);\n\n    //findModel = new FindModel();\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(true);\n    findModel.setProjectScope(false);\n    findModel.setDirectoryName(projectDir + File.separatorChar + \"src1\");\n    findModel.setWithSubdirectories(true);\n    checkFindUsages(6, findModel);\n\n    findModel.setWholeWordsOnly(true);\n    checkFindUsages(5, findModel);\n//    findModel.setForward(false);\n//    findModel.setCaseSensitive();\n\n\n  }","id":44401,"modified_method":"public void testFindUsages() {\n    initProject(\"findManager\", \"src\", \"src1\");\n    String projectDir = FileUtil.toSystemDependentName(PathManagerEx.getTestDataPath() + \"/find/findManager\");\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(true);\n    findModel.setProjectScope(true);\n    findModel.setDirectoryName(projectDir + File.separatorChar + \"src1\");\n    findModel.setWithSubdirectories(true);\n    checkFindUsages(12, findModel);\n\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(true);\n    findModel.setProjectScope(false);\n    findModel.setDirectoryName(projectDir + File.separatorChar + \"src1\");\n    findModel.setWithSubdirectories(true);\n    checkFindUsages(6, findModel);\n\n    findModel.setWholeWordsOnly(true);\n    checkFindUsages(5, findModel);\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInJavaDoc() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"do ne\");\n    findModel.setWholeWordsOnly(true);\n\n    String text = \"/** do ne do ne do ne */\";\n\n    findModel.setInCommentsOnly(true);\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text, \"java\");\n  }","id":44402,"modified_method":"public void testFindInJavaDoc() {\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"do ne\");\n    findModel.setWholeWordsOnly(true);\n\n    String text = \"/** do ne do ne do ne */\";\n\n    findModel.setInCommentsOnly(true);\n    FindManagerTestUtils.runFindForwardAndBackward(myFindManager, findModel, text, \"java\");\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInJavaDocs() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String text = \"/** done done done */\";\n\n    findModel.setInCommentsOnly(true);\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text);\n\n    findModel.setRegularExpressions(true);\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text);\n\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text, \"groovy\");\n  }","id":44403,"modified_method":"public void testFindInJavaDocs() {\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n    String text = \"/** done done done */\";\n\n    findModel.setInCommentsOnly(true);\n    FindManagerTestUtils.runFindForwardAndBackward(myFindManager, findModel, text);\n\n    findModel.setRegularExpressions(true);\n    FindManagerTestUtils.runFindForwardAndBackward(myFindManager, findModel, text);\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private  void initProject(String folderName, final String... sourceDirs) throws Exception{\n    final String testDir = JavaTestUtil.getJavaTestDataPath() + \"/find/\" + folderName;\n    ApplicationManager.getApplication().runWriteAction(new Runnable(){\n      @Override\n      public void run(){\n        try{\n          mySourceDirs = new VirtualFile[sourceDirs.length];\n          for (int i = 0; i < sourceDirs.length; i++){\n            String sourceDir = sourceDirs[i];\n            mySourceDirs[i] = LocalFileSystem.getInstance().refreshAndFindFileByPath(new File(testDir + File.separatorChar + sourceDir).getCanonicalPath().replace(File.separatorChar, '/'));\n          }\n          VirtualFile projectDir = LocalFileSystem.getInstance().refreshAndFindFileByPath(new File(testDir).getCanonicalPath().replace(File.separatorChar, '/'));\n\n          Sdk jdk = IdeaTestUtil.getMockJdk17();\n          PsiTestUtil.removeAllRoots(myModule, jdk);\n          PsiTestUtil.addContentRoot(myModule, projectDir);\n          for (VirtualFile sourceDir : mySourceDirs) {\n            PsiTestUtil.addSourceRoot(myModule, sourceDir);\n          }\n        }\n        catch (Exception e){\n          throw new RuntimeException(e);\n        }\n      }\n    });\n  }","id":44404,"modified_method":"private  void initProject(String folderName, final String... sourceDirs) {\n    final String testDir = JavaTestUtil.getJavaTestDataPath() + \"/find/\" + folderName;\n    ApplicationManager.getApplication().runWriteAction(new Runnable(){\n      @Override\n      public void run(){\n        try{\n          mySourceDirs = new VirtualFile[sourceDirs.length];\n          for (int i = 0; i < sourceDirs.length; i++){\n            String sourcePath = testDir + \"/\" + sourceDirs[i];\n            mySourceDirs[i] = LocalFileSystem.getInstance().refreshAndFindFileByPath(FileUtil.toSystemIndependentName(sourcePath));\n          }\n\n          VirtualFile projectDir = LocalFileSystem.getInstance().refreshAndFindFileByPath(FileUtil.toSystemIndependentName(testDir));\n          Sdk jdk = IdeaTestUtil.getMockJdk17();\n          PsiTestUtil.removeAllRoots(myModule, jdk);\n          PsiTestUtil.addContentRoot(myModule, projectDir);\n          for (VirtualFile sourceDir : mySourceDirs) {\n            PsiTestUtil.addSourceRoot(myModule, sourceDir);\n          }\n        }\n        catch (Exception e){\n          throw new RuntimeException(e);\n        }\n      }\n    });\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testLocalScopeSearchPerformance() throws Throwable {\n    final int fileCount = 3000;\n    final int lineCount = 500;\n    TempDirTestFixture fixture = new LightTempDirTestFixtureImpl();\n    fixture.setUp();\n\n    try {\n      String sampleText = StringUtil.repeat(\"zoo TargetWord foo bar goo\\n\", lineCount);\n      for (int i = 0; i < fileCount; i++) {\n        fixture.createFile(\"a\" + i + \".txt\", sampleText);\n      }\n      PsiTestUtil.addSourceContentToRoots(myModule, fixture.getFile(\"\"));\n\n      VirtualFile file = fixture.createFile(\"target.txt\", sampleText);\n      PsiFile psiFile = PsiManager.getInstance(myProject).findFile(file);\n      final FindModel findModel = new FindModel();\n      findModel.setStringToFind(\"TargetWord\");\n      findModel.setWholeWordsOnly(true);\n      findModel.setFromCursor(false);\n      findModel.setGlobal(true);\n      findModel.setMultipleFiles(true);\n\n      ThrowableRunnable test = new ThrowableRunnable() {\n        @Override\n        public void run() throws Throwable {\n          assertSize(lineCount, findUsages(findModel));\n        }\n      };\n\n      findModel.setCustomScope(GlobalSearchScope.fileScope(psiFile));\n      PlatformTestUtil.startPerformanceTest(\"slow\", 400, test).attempts(2).cpuBound().usesAllCPUCores().assertTiming();\n\n      findModel.setCustomScope(new LocalSearchScope(psiFile));\n      PlatformTestUtil.startPerformanceTest(\"slow\", 400, test).attempts(2).cpuBound().usesAllCPUCores().assertTiming();\n    }\n    finally {\n      fixture.tearDown();\n    }\n  }","id":44405,"modified_method":"public void testLocalScopeSearchPerformance() throws Exception {\n    final int fileCount = 3000;\n    final int lineCount = 500;\n    TempDirTestFixture fixture = new LightTempDirTestFixtureImpl();\n    fixture.setUp();\n\n    try {\n      String sampleText = StringUtil.repeat(\"zoo TargetWord foo bar goo\\n\", lineCount);\n      for (int i = 0; i < fileCount; i++) {\n        fixture.createFile(\"a\" + i + \".txt\", sampleText);\n      }\n      PsiTestUtil.addSourceContentToRoots(myModule, fixture.getFile(\"\"));\n\n      VirtualFile file = fixture.createFile(\"target.txt\", sampleText);\n      PsiFile psiFile = PsiManager.getInstance(myProject).findFile(file);\n      assertNotNull(psiFile);\n      final FindModel findModel = new FindModel();\n      findModel.setStringToFind(\"TargetWord\");\n      findModel.setWholeWordsOnly(true);\n      findModel.setFromCursor(false);\n      findModel.setGlobal(true);\n      findModel.setMultipleFiles(true);\n\n      ThrowableRunnable test = new ThrowableRunnable() {\n        @Override\n        public void run() throws Throwable {\n          assertSize(lineCount, findUsages(findModel));\n        }\n      };\n\n      findModel.setCustomScope(GlobalSearchScope.fileScope(psiFile));\n      PlatformTestUtil.startPerformanceTest(\"slow\", 400, test).attempts(2).cpuBound().usesAllCPUCores().assertTiming();\n\n      findModel.setCustomScope(new LocalSearchScope(psiFile));\n      PlatformTestUtil.startPerformanceTest(\"slow\", 400, test).attempts(2).cpuBound().usesAllCPUCores().assertTiming();\n    }\n    finally {\n      fixture.tearDown();\n    }\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testReplaceRegexp1() throws Throwable {\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"bug(?=here)\");\n    findModel.setStringToReplace(\"$0\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setRegularExpressions(true);\n    findModel.setPromptOnReplace(false);\n\n    findManager.setFindNextModel(null);\n    findManager.getFindInFileModel().copyFrom(findModel);\n\n    String text = \"bughere\\n\" + \"bughere\";\n    configureByText(FileTypes.PLAIN_TEXT, text);\n    boolean succ = FindUtil.replace(getProject(), getEditor(), 0, findModel);\n    assertTrue(succ);\n\n    assertEquals(text, getEditor().getDocument().getText());\n  }","id":44406,"modified_method":"public void testReplaceRegexp1() {\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"bug_(?=here)\");\n    findModel.setStringToReplace(\"$0\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setRegularExpressions(true);\n    findModel.setPromptOnReplace(false);\n\n    myFindManager.setFindNextModel(null);\n    myFindManager.getFindInFileModel().copyFrom(findModel);\n\n    String text = \"bug_here\\nbug_here\";\n    configureByText(FileTypes.PLAIN_TEXT, text);\n    assertTrue(FindUtil.replace(getProject(), getEditor(), 0, findModel));\n\n    assertEquals(text, getEditor().getDocument().getText());\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInFileUnderLibraryUnderProject() throws Exception {\n    initProject(\"libUnderProject\", \"src\");\n    PsiTestUtil.addLibrary(myModule, \"lib\", JavaTestUtil.getJavaTestDataPath() + \"/find/libUnderProject/lib\", new String[]{\"\"}, ArrayUtil.EMPTY_STRING_ARRAY);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"TargetWord\");\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(true);\n\n    findModel.setWholeWordsOnly(false);\n    assertSize(2, findUsages(findModel));\n\n    findModel.setWholeWordsOnly(true);\n    assertSize(2, findUsages(findModel));\n  }","id":44407,"modified_method":"public void testFindInFileUnderLibraryUnderProject() {\n    initProject(\"libUnderProject\", \"src\");\n    String libDir = JavaTestUtil.getJavaTestDataPath() + \"/find/libUnderProject/lib\";\n    PsiTestUtil.addLibrary(myModule, \"lib\", libDir, new String[]{\"\"}, ArrayUtil.EMPTY_STRING_ARRAY);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"TargetWord\");\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(true);\n\n    findModel.setWholeWordsOnly(false);\n    assertSize(2, findUsages(findModel));\n\n    findModel.setWholeWordsOnly(true);\n    assertSize(2, findUsages(findModel));\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInUserFileType() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String text = \"\\\"done done\\\"; 'done'; // done\\n\" +\n                  \"/* done\\n\" +\n                  \"done */\";\n\n    FindManagerTestUtils.runFindInCommentsAndLiterals(findManager, findModel, text, \"cs\");\n  }","id":44408,"modified_method":"public void testFindInUserFileType() {\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n    String text = \"\\\"done done\\\"; 'done'; // done\\n\" +\n                  \"/* done\\n\" +\n                  \"done */\";\n    FindManagerTestUtils.runFindInCommentsAndLiterals(myFindManager, findModel, text, \"cs\");\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void searchProperty(String query) {\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(query);\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(true);\n    findModel.setProjectScope(true);\n    findModel.setDirectoryName(mySourceDirs[0].getPath());\n    findModel.setWithSubdirectories(true);\n\n    List<UsageInfo> usages = findUsages(findModel);\n    assertEquals(2, usages.size());\n    if (!(usages.get(0).getFile() instanceof PsiJavaFile)) {\n      Collections.swap(usages, 0, 1);\n    }\n    PsiElement element = usages.get(0).getElement();\n    //assertTrue(element instanceof PsiJavaFile);\n    PsiElement refElement = element.findElementAt(usages.get(0).getRangeInElement().getStartOffset()).getParent();\n    assertTrue(refElement instanceof PsiLiteralExpression);\n    assertEquals(\"xx.yy\", ((PsiLiteralExpression)refElement).getValue());\n\n    VirtualFile file = mySourceDirs[0].findFileByRelativePath(\"x/dd.properties\");\n    PropertiesFile propertiesFile = (PropertiesFile)PsiManager.getInstance(myProject).findFile(file);\n    element = usages.get(1).getElement();\n    //assertTrue(element instanceof PropertiesFile);\n    refElement = element.findElementAt(usages.get(1).getRangeInElement().getStartOffset()).getParent();\n    assertTrue(refElement instanceof IProperty);\n    assertSame(propertiesFile.findPropertyByKey(\"xx.yy\"), refElement);\n  }","id":44409,"modified_method":"private void searchProperty(String query) {\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(query);\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(true);\n    findModel.setProjectScope(true);\n    findModel.setDirectoryName(mySourceDirs[0].getPath());\n    findModel.setWithSubdirectories(true);\n\n    List<UsageInfo> usages = findUsages(findModel);\n    assertEquals(2, usages.size());\n    if (!(usages.get(0).getFile() instanceof PsiJavaFile)) {\n      Collections.swap(usages, 0, 1);\n    }\n\n    PsiElement refElement = getParentFromUsage(usages.get(0));\n    assertTrue(refElement instanceof PsiLiteralExpression);\n    assertEquals(\"xx.yy\", ((PsiLiteralExpression)refElement).getValue());\n\n    VirtualFile file = mySourceDirs[0].findFileByRelativePath(\"x/dd.properties\");\n    assertNotNull(file);\n    PropertiesFile propertiesFile = (PropertiesFile)PsiManager.getInstance(myProject).findFile(file);\n    assertNotNull(propertiesFile);\n    refElement = getParentFromUsage(usages.get(1));\n    assertTrue(refElement instanceof IProperty);\n    assertSame(propertiesFile.findPropertyByKey(\"xx.yy\"), refElement);\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInCommentsProperlyWorksWithOffsets() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String prefix = \"/*\";\n    String text = prefix + \"done*/\";\n\n    findModel.setInCommentsOnly(true);\n    LightVirtualFile file = new LightVirtualFile(\"A.java\", text);\n\n    FindResult findResult = findManager.findString(text, prefix.length(), findModel, file);\n    assertTrue(findResult.isStringFound());\n\n    findModel.setRegularExpressions(true);\n    findResult = findManager.findString(text, prefix.length(), findModel, file);\n    assertTrue(findResult.isStringFound());\n  }","id":44410,"modified_method":"public void testFindInCommentsProperlyWorksWithOffsets() {\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String prefix = \"/*\";\n    String text = prefix + \"done*/\";\n\n    findModel.setInCommentsOnly(true);\n    LightVirtualFile file = new LightVirtualFile(\"A.java\", text);\n\n    FindResult findResult = myFindManager.findString(text, prefix.length(), findModel, file);\n    assertTrue(findResult.isStringFound());\n\n    findModel.setRegularExpressions(true);\n    findResult = myFindManager.findString(text, prefix.length(), findModel, file);\n    assertTrue(findResult.isStringFound());\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindString() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String text = \"public static class MyClass{\\n/*done*/\\npublic static void main(){}}\";\n    FindResult findResult = findManager.findString(text, 0, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(true);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    findResult = findManager.findString(text, 40, findModel);\n    assertFalse(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(true);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setForward(false);\n\n    findResult = findManager.findString(text, 40, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    findResult = findManager.findString(text, 0, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"don\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    final FindResult[] findResultArr = new FindResult[1];\n    findInNewThread(findModel, findManager, text, 0, findResultArr);\n    new WaitFor(30 *1000){\n      @Override\n      protected boolean condition() {\n        return findResultArr[0] != null;\n      }\n    }.assertCompleted();\n\n    assertFalse(findResultArr[0].isStringFound());\n  }","id":44411,"modified_method":"public void testFindString() {\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"done\");\n\n    String text = \"public static class MyClass{\\n/*done*/\\npublic static void main(){}}\";\n    FindResult findResult = myFindManager.findString(text, 0, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(true);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    findResult = myFindManager.findString(text, 40, findModel);\n    assertFalse(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(true);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setForward(false);\n\n    findResult = myFindManager.findString(text, 40, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    findResult = myFindManager.findString(text, 0, findModel);\n    assertTrue(findResult.isStringFound());\n\n    findModel = new FindModel();\n    findModel.setStringToFind(\"don\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n\n    final FindResult[] findResultArr = new FindResult[1];\n    findInNewThread(findModel, myFindManager, text, 0, findResultArr);\n    new WaitFor(30 *1000){\n      @Override\n      protected boolean condition() {\n        return findResultArr[0] != null;\n      }\n    }.assertCompleted();\n\n    assertFalse(findResultArr[0].isStringFound());\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFindInLiteralToSkipQuotes() throws Exception{\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"^done$\");\n    findModel.setRegularExpressions(true);\n\n    String text = \"\\\"done\\\"; 'done'; 'done' \\\"done2\\\"\";\n\n    findModel.setInStringLiteralsOnly(true);\n    findModel.setInCommentsOnly(false);\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text, \"java\");\n\n    text = \"def n = \\\"\\\"\\\"done\\\"\\\"\\\"\\n def n = /done/\\n def n = \\\"done\\\"\\n def n = \\\"done2\\\"\";\n\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text, \"groovy\");\n\n    text = \"\\\"\\\"; \\\"done\\\"; 'done'; 'done' \\\"done2\\\"\";\n\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setRegularExpressions(false);\n\n    FindManagerTestUtils.runFindForwardAndBackward(findManager, findModel, text, \"java\");\n  }","id":44412,"modified_method":"public void testFindInLiteralToSkipQuotes() {\n    FindModel findModel = FindManagerTestUtils.configureFindModel(\"^done$\");\n\n    findModel.setRegularExpressions(true);\n    findModel.setInStringLiteralsOnly(true);\n    findModel.setInCommentsOnly(false);\n    String text = \"\\\"done\\\"; 'done'; 'done' \\\"done2\\\"\";\n    FindManagerTestUtils.runFindForwardAndBackward(myFindManager, findModel, text, \"java\");\n\n    findModel.setStringToFind(\"done\");\n    findModel.setWholeWordsOnly(true);\n    findModel.setRegularExpressions(false);\n    text = \"\\\"\\\"; \\\"done\\\"; 'done'; 'done' \\\"done2\\\"\";\n    FindManagerTestUtils.runFindForwardAndBackward(myFindManager, findModel, text, \"java\");\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testReplaceRegexp() throws Throwable {\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"bug(?=here)\");\n    findModel.setStringToReplace(\"x$0y\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setRegularExpressions(true);\n    findModel.setPromptOnReplace(false);\n\n    findManager.setFindNextModel(null);\n    findManager.getFindInFileModel().copyFrom(findModel);\n\n    String text = \"bughere\\n\" + \"bughere\";\n    configureByText(FileTypes.PLAIN_TEXT, text);\n    boolean succ = FindUtil.replace(getProject(), getEditor(), 0, findModel);\n    assertTrue(succ);\n\n    assertEquals(\"xbugyhere\\n\" + \"xbugyhere\", getEditor().getDocument().getText());\n  }","id":44413,"modified_method":"public void testReplaceRegexp() {\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"bug_(?=here)\");\n    findModel.setStringToReplace(\"x_$0t\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setRegularExpressions(true);\n    findModel.setPromptOnReplace(false);\n\n    myFindManager.setFindNextModel(null);\n    myFindManager.getFindInFileModel().copyFrom(findModel);\n\n    String text = \"bug_here\\nbug_here\";\n    configureByText(FileTypes.PLAIN_TEXT, text);\n    assertTrue(FindUtil.replace(getProject(), getEditor(), 0, findModel));\n\n    assertEquals(\"x_bug_there\\nx_bug_there\", getEditor().getDocument().getText());\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testReplaceRegexpWithNewLine() throws Throwable {\n    FindManager findManager = FindManager.getInstance(myProject);\n\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"xxx\");\n    findModel.setStringToReplace(\"xxx\\\\n\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setRegularExpressions(true);\n    findModel.setPromptOnReplace(false);\n\n    findManager.setFindNextModel(null);\n    findManager.getFindInFileModel().copyFrom(findModel);\n\n    String text = \"xxx\";\n    configureByText(FileTypes.PLAIN_TEXT, text);\n    boolean succ = FindUtil.replace(getProject(), getEditor(), 0, findModel);\n    assertTrue(succ);\n\n    assertEquals(text+\"\\n\", getEditor().getDocument().getText());\n  }","id":44414,"modified_method":"public void testReplaceRegexpWithNewLine() {\n    FindModel findModel = new FindModel();\n    findModel.setStringToFind(\"xxx\");\n    findModel.setStringToReplace(\"xxx\\\\n\");\n    findModel.setWholeWordsOnly(false);\n    findModel.setFromCursor(false);\n    findModel.setGlobal(true);\n    findModel.setMultipleFiles(false);\n    findModel.setProjectScope(true);\n    findModel.setRegularExpressions(true);\n    findModel.setPromptOnReplace(false);\n\n    myFindManager.setFindNextModel(null);\n    myFindManager.getFindInFileModel().copyFrom(findModel);\n\n    String text = \"xxx\";\n    configureByText(FileTypes.PLAIN_TEXT, text);\n    assertTrue(FindUtil.replace(getProject(), getEditor(), 0, findModel));\n\n    assertEquals(text+\"\\n\", getEditor().getDocument().getText());\n  }","commit_id":"202e2ae6468f1b9928ec387d23dcc0c209dedea1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CoalGolem(UUID ownerId) {\n        super(ownerId, 193, \"Coal Golem\", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, \"{5}\");\n        this.expansionSetCode = \"ME3\";\n        this.subtype.add(\"Golem\");\n        this.power = new MageInt(3);\n        this.toughness = new MageInt(3);\n\n        // {3}, Sacrifice Coal Golem: Add {R}{R}{R} to your mana pool.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BasicManaEffect(Mana.RedMana(3)),new GenericManaCost(3));\n        ability.addCost(new SacrificeSourceCost());\n        this.addAbility(ability);\n    }","id":44415,"modified_method":"public CoalGolem(UUID ownerId) {\n        super(ownerId, 193, \"Coal Golem\", Rarity.COMMON, new CardType[]{CardType.ARTIFACT, CardType.CREATURE}, \"{5}\");\n        this.expansionSetCode = \"ME3\";\n        this.subtype.add(\"Golem\");\n        this.power = new MageInt(3);\n        this.toughness = new MageInt(3);\n\n        // {3}, Sacrifice Coal Golem: Add {R}{R}{R} to your mana pool.\n        Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.RedMana(3),new GenericManaCost(3));\n        ability.addCost(new SacrificeSourceCost());\n        this.addAbility(ability);\n    }","commit_id":"43fa5ed06d25ac5a185dfc4d57064eb88555b2c9","url":"https://github.com/magefree/mage"},{"original_method":"public SatyrHedonist(UUID ownerId) {\n        super(ownerId, 174, \"Satyr Hedonist\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{G}\");\n        this.expansionSetCode = \"THS\";\n        this.subtype.add(\"Satyr\");\n\n        this.power = new MageInt(2);\n        this.toughness = new MageInt(1);\n\n        // {R}, Sacrifice Satyr Hedonist: Add {R}{R}{R} to your mana pool.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BasicManaEffect(Mana.RedMana(3)),new ManaCostsImpl(\"{R}\"));\n        ability.addCost(new SacrificeSourceCost());\n        this.addAbility(ability);\n\n    }","id":44416,"modified_method":"public SatyrHedonist(UUID ownerId) {\n        super(ownerId, 174, \"Satyr Hedonist\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{1}{G}\");\n        this.expansionSetCode = \"THS\";\n        this.subtype.add(\"Satyr\");\n\n        this.power = new MageInt(2);\n        this.toughness = new MageInt(1);\n\n        // {R}, Sacrifice Satyr Hedonist: Add {R}{R}{R} to your mana pool.\n        SimpleManaAbility ability = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.RedMana(3), new ManaCostsImpl(\"{R}\"));\n        ability .addCost(new SacrificeSourceCost());\n        this.addAbility(ability);\n\n    }","commit_id":"43fa5ed06d25ac5a185dfc4d57064eb88555b2c9","url":"https://github.com/magefree/mage"},{"original_method":"public VesselOfVolatility(UUID ownerId) {\n        super(ownerId, 189, \"Vessel of Volatility\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{1}{R}\");\n        this.expansionSetCode = \"SOI\";\n\n        // {1}{R}, Sacrifice Vessel of Volatility: Add {R}{R}{R}{R} to your mana pool.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BasicManaEffect(Mana.RedMana(4)), new ManaCostsImpl(\"{1}{R}\"));\n        ability.addCost(new SacrificeSourceCost());\n        this.addAbility(ability);\n    }","id":44417,"modified_method":"public VesselOfVolatility(UUID ownerId) {\n        super(ownerId, 189, \"Vessel of Volatility\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{1}{R}\");\n        this.expansionSetCode = \"SOI\";\n\n        // {1}{R}, Sacrifice Vessel of Volatility: Add {R}{R}{R}{R} to your mana pool.\n        Ability ability = new SimpleManaAbility(Zone.BATTLEFIELD, Mana.RedMana(4), new ManaCostsImpl(\"{1}{R}\"));\n        ability.addCost(new SacrificeSourceCost());\n        this.addAbility(ability);\n    }","commit_id":"43fa5ed06d25ac5a185dfc4d57064eb88555b2c9","url":"https://github.com/magefree/mage"},{"original_method":"private void addParentArtifacts( MavenProject project, Set<Artifact> artifacts )\n        throws MojoExecutionException\n    {\n        while ( project.hasParent() )\n        {\n            project = project.getParent();\n\n            if ( artifacts.contains( project.getArtifact() ) )\n            {\n                // artifact already in the set\n                break;\n            }\n            try\n            {\n                ProjectBuildingRequest buildingRequest =\n                    new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n                \n                buildingRequest.setRemoteRepositories( getRemoteRepos() );\n                \n                Artifact resolvedArtifact = artifactResolver.resolveArtifact( buildingRequest, project.getArtifact() );\n                \n                artifacts.add( resolvedArtifact );\n            }\n            catch ( ArtifactResolverException e )\n            {\n                throw new MojoExecutionException( e.getMessage(), e );\n            }\n        }\n    }","id":44418,"modified_method":"private void addParentArtifacts( MavenProject project, Set<Artifact> artifacts )\n        throws MojoExecutionException\n    {\n        while ( project.hasParent() )\n        {\n            project = project.getParent();\n\n            if ( artifacts.contains( project.getArtifact() ) )\n            {\n                // artifact already in the set\n                break;\n            }\n            try\n            {\n                ProjectBuildingRequest buildingRequest =\n                    new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n                \n                buildingRequest.setRemoteRepositories( getRemoteRepos() );\n                \n                Artifact resolvedArtifact =\n                    artifactResolver.resolveArtifact( buildingRequest, project.getArtifact() ).getArtifact();\n                \n                artifacts.add( resolvedArtifact );\n            }\n            catch ( ArtifactResolverException e )\n            {\n                throw new MojoExecutionException( e.getMessage(), e );\n            }\n        }\n    }","commit_id":"01a3ae7f6996cdaa43e82edfcccfb9d5388bd17f","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Resolves the Artifact from the remote repository if necessary. If no version is specified, it will be retrieved\n     * from the dependency list or from the DependencyManagement section of the pom.\n     *\n     * @param artifactItem containing information about artifact from plugin configuration.\n     * @return Artifact object representing the specified file.\n     * @throws MojoExecutionException with a message if the version can't be found in DependencyManagement.\n     */\n    protected Artifact getArtifact( ArtifactItem artifactItem )\n        throws MojoExecutionException\n    {\n        Artifact artifact;\n\n        // Map managedVersions = createManagedVersionMap( factory, project.getId(), project.getDependencyManagement() );\n        VersionRange vr;\n        try\n        {\n            vr = VersionRange.createFromVersionSpec( artifactItem.getVersion() );\n        }\n        catch ( InvalidVersionSpecificationException e1 )\n        {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n            vr = VersionRange.createFromVersion( artifactItem.getVersion() );\n        }\n\n        if ( StringUtils.isEmpty( artifactItem.getClassifier() ) )\n        {\n            artifact =\n                getFactory().createDependencyArtifact( artifactItem.getGroupId(), artifactItem.getArtifactId(), vr,\n                                                       artifactItem.getType(), null, Artifact.SCOPE_COMPILE );\n        }\n        else\n        {\n            artifact =\n                getFactory().createDependencyArtifact( artifactItem.getGroupId(), artifactItem.getArtifactId(), vr,\n                                                       artifactItem.getType(), artifactItem.getClassifier(),\n                                                       Artifact.SCOPE_COMPILE );\n        }\n\n        // Maven 3 will search the reactor for the artifact but Maven 2 does not\n        // to keep consistent behaviour, we search the reactor ourselves.\n        Artifact result = getArtifactFomReactor( artifact );\n        if ( result != null )\n        {\n            return result;\n        }\n\n        try\n        {\n            // mdep-50 - rolledback for now because it's breaking some functionality.\n            /*\n             * List listeners = new ArrayList(); Set theSet = new HashSet(); theSet.add( artifact );\n             * ArtifactResolutionResult artifactResolutionResult = artifactCollector.collect( theSet, project\n             * .getArtifact(), managedVersions, this.local, project.getRemoteArtifactRepositories(),\n             * artifactMetadataSource, null, listeners ); Iterator iter =\n             * artifactResolutionResult.getArtifactResolutionNodes().iterator(); while ( iter.hasNext() ) {\n             * ResolutionNode node = (ResolutionNode) iter.next(); artifact = node.getArtifact(); }\n             */\n            \n            ProjectBuildingRequest buildingRequest;\n            \n            if ( localRepositoryDirectory != null )\n            {\n                buildingRequest =\n                    repositoryManager.setLocalRepositoryBasedir( session.getProjectBuildingRequest(),\n                                                                 localRepositoryDirectory );\n            }\n            else\n            {\n                buildingRequest = new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n            }\n            \n            buildingRequest.setRemoteRepositories( getRemoteRepos() );\n\n            artifact = artifactResolver.resolveArtifact( buildingRequest, artifact );\n        }\n        catch ( ArtifactResolverException e )\n        {\n            throw new MojoExecutionException( \"Unable to find/resolve artifact.\", e );\n        }\n\n        return artifact;\n    }","id":44419,"modified_method":"/**\n     * Resolves the Artifact from the remote repository if necessary. If no version is specified, it will be retrieved\n     * from the dependency list or from the DependencyManagement section of the pom.\n     *\n     * @param artifactItem containing information about artifact from plugin configuration.\n     * @return Artifact object representing the specified file.\n     * @throws MojoExecutionException with a message if the version can't be found in DependencyManagement.\n     */\n    protected Artifact getArtifact( ArtifactItem artifactItem )\n        throws MojoExecutionException\n    {\n        Artifact artifact;\n\n        // Map managedVersions = createManagedVersionMap( factory, project.getId(), project.getDependencyManagement() );\n        VersionRange vr;\n        try\n        {\n            vr = VersionRange.createFromVersionSpec( artifactItem.getVersion() );\n        }\n        catch ( InvalidVersionSpecificationException e1 )\n        {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n            vr = VersionRange.createFromVersion( artifactItem.getVersion() );\n        }\n\n        if ( StringUtils.isEmpty( artifactItem.getClassifier() ) )\n        {\n            artifact =\n                getFactory().createDependencyArtifact( artifactItem.getGroupId(), artifactItem.getArtifactId(), vr,\n                                                       artifactItem.getType(), null, Artifact.SCOPE_COMPILE );\n        }\n        else\n        {\n            artifact =\n                getFactory().createDependencyArtifact( artifactItem.getGroupId(), artifactItem.getArtifactId(), vr,\n                                                       artifactItem.getType(), artifactItem.getClassifier(),\n                                                       Artifact.SCOPE_COMPILE );\n        }\n\n        // Maven 3 will search the reactor for the artifact but Maven 2 does not\n        // to keep consistent behaviour, we search the reactor ourselves.\n        Artifact result = getArtifactFomReactor( artifact );\n        if ( result != null )\n        {\n            return result;\n        }\n\n        try\n        {\n            // mdep-50 - rolledback for now because it's breaking some functionality.\n            /*\n             * List listeners = new ArrayList(); Set theSet = new HashSet(); theSet.add( artifact );\n             * ArtifactResolutionResult artifactResolutionResult = artifactCollector.collect( theSet, project\n             * .getArtifact(), managedVersions, this.local, project.getRemoteArtifactRepositories(),\n             * artifactMetadataSource, null, listeners ); Iterator iter =\n             * artifactResolutionResult.getArtifactResolutionNodes().iterator(); while ( iter.hasNext() ) {\n             * ResolutionNode node = (ResolutionNode) iter.next(); artifact = node.getArtifact(); }\n             */\n            \n            ProjectBuildingRequest buildingRequest;\n            \n            if ( localRepositoryDirectory != null )\n            {\n                buildingRequest =\n                    repositoryManager.setLocalRepositoryBasedir( session.getProjectBuildingRequest(),\n                                                                 localRepositoryDirectory );\n            }\n            else\n            {\n                buildingRequest = new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n            }\n            \n            buildingRequest.setRemoteRepositories( getRemoteRepos() );\n\n            artifact = artifactResolver.resolveArtifact( buildingRequest, artifact ).getArtifact();\n        }\n        catch ( ArtifactResolverException e )\n        {\n            throw new MojoExecutionException( \"Unable to find/resolve artifact.\", e );\n        }\n\n        return artifact;\n    }","commit_id":"01a3ae7f6996cdaa43e82edfcccfb9d5388bd17f","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected Artifact getResolvedPomArtifact( Artifact artifact )\n    {\n        Artifact pomArtifact =\n            this.getFactory().createArtifact( artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(),\n                                              \"\", \"pom\" );\n        // Resolve the pom artifact using repos\n        try\n        {\n            ProjectBuildingRequest buildingRequest =\n                new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n\n            buildingRequest.setRemoteRepositories( getRemoteRepos() );\n            \n            pomArtifact = getArtifactResolver().resolveArtifact( buildingRequest, pomArtifact );\n        }\n        catch ( ArtifactResolverException e )\n        {\n            getLog().info( e.getMessage() );\n        }\n        return pomArtifact;\n    }","id":44420,"modified_method":"protected Artifact getResolvedPomArtifact( Artifact artifact )\n    {\n        Artifact pomArtifact =\n            this.getFactory().createArtifact( artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(),\n                                              \"\", \"pom\" );\n        // Resolve the pom artifact using repos\n        try\n        {\n            ProjectBuildingRequest buildingRequest =\n                new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n\n            buildingRequest.setRemoteRepositories( getRemoteRepos() );\n            \n            pomArtifact = getArtifactResolver().resolveArtifact( buildingRequest, pomArtifact ).getArtifact();\n        }\n        catch ( ArtifactResolverException e )\n        {\n            getLog().info( e.getMessage() );\n        }\n        return pomArtifact;\n    }","commit_id":"01a3ae7f6996cdaa43e82edfcccfb9d5388bd17f","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public Set<Artifact> resolve( Set<Artifact> artifacts, Log log )\n        throws MojoExecutionException\n    {\n\n        Set<Artifact> resolvedArtifacts = new HashSet<Artifact>();\n        for ( Artifact artifact : artifacts )\n        {\n            try\n            {\n                artifact = resolver.resolveArtifact( buildingRequest, artifact );\n                resolvedArtifacts.add( artifact );\n            }\n            catch ( ArtifactResolverException ex )\n            {\n                // an error occurred during resolution, log it an continue\n                log.debug( \"error resolving: \" + artifact.getId() );\n                log.debug( ex );\n                if ( stopOnFailure )\n                {\n                    throw new MojoExecutionException( \"error resolving: \" + artifact.getId(), ex );\n                }\n            }\n        }\n        return resolvedArtifacts;\n    }","id":44421,"modified_method":"@Override\n    public Set<Artifact> resolve( Set<Artifact> artifacts, Log log )\n        throws MojoExecutionException\n    {\n\n        Set<Artifact> resolvedArtifacts = new HashSet<Artifact>();\n        for ( Artifact artifact : artifacts )\n        {\n            try\n            {\n                artifact = resolver.resolveArtifact( buildingRequest, artifact ).getArtifact();\n                resolvedArtifacts.add( artifact );\n            }\n            catch ( ArtifactResolverException ex )\n            {\n                // an error occurred during resolution, log it an continue\n                log.debug( \"error resolving: \" + artifact.getId() );\n                log.debug( ex );\n                if ( stopOnFailure )\n                {\n                    throw new MojoExecutionException( \"error resolving: \" + artifact.getId(), ex );\n                }\n            }\n        }\n        return resolvedArtifacts;\n    }","commit_id":"01a3ae7f6996cdaa43e82edfcccfb9d5388bd17f","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the artifact used to retrieve dependencies\n     * @return resolved set of dependencies\n     * @throws ArtifactResolverException\n     */\n    protected Set<Artifact> resolveArtifactDependencies( final Artifact artifact )\n        throws ArtifactResolverException\n    {\n        ProjectBuildingRequest buildingRequest =\n            new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n\n        Iterable<ArtifactResult> artifactResults =\n            getArtifactResolver().resolveTransitively( buildingRequest,\n                                                       artifact );\n\n        Set<Artifact> artifacts = new HashSet<Artifact>();\n\n        for ( final ArtifactResult artifactResult : artifactResults )\n        {\n            artifacts.add( artifactResult.getArtifact() );\n        }\n\n        return artifacts;\n\n    }","id":44422,"modified_method":"/**\n     * This method resolves all transitive dependencies of an artifact.\n     *\n     * @param artifact the artifact used to retrieve dependencies\n     * @return resolved set of dependencies\n     * @throws ArtifactResolverException\n     */\n    protected Set<Artifact> resolveArtifactDependencies( final ArtifactCoordinate artifact )\n        throws ArtifactResolverException\n    {\n        ProjectBuildingRequest buildingRequest =\n            new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n\n        Iterable<ArtifactResult> artifactResults =\n            getArtifactResolver().resolveDependencies( buildingRequest, artifact, null );\n\n        Set<Artifact> artifacts = new HashSet<Artifact>();\n\n        for ( final ArtifactResult artifactResult : artifactResults )\n        {\n            artifacts.add( artifactResult.getArtifact() );\n        }\n\n        return artifacts;\n\n    }","commit_id":"fb19ccd303215cb2bdbeedf41e7c79022be5eaa3","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( isSkip() )\n        {\n            getLog().info( \"Skipping plugin execution\" );\n            return;\n        }\n\n        if ( artifactId == null && artifact == null )\n        {\n            throw new MojoFailureException( \"You must specify an artifact, \"\n                + \"e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0\" );\n        }\n        if ( artifact != null )\n        {\n            String[] tokens = StringUtils.split( artifact, \":\" );\n            if ( tokens.length < 3 || tokens.length > 5 )\n            {\n                throw new MojoFailureException(\n                    \"Invalid artifact, you must specify groupId:artifactId:version[:packaging[:classifier]] \"\n                        + artifact );\n            }\n            groupId = tokens[0];\n            artifactId = tokens[1];\n            version = tokens[2];\n            if ( tokens.length >= 4 )\n            {\n                packaging = tokens[3];\n            }\n            if ( tokens.length == 5 )\n            {\n                classifier = tokens[4];\n            }\n            else\n            {\n                classifier = null;\n            }\n        }\n\n        Artifact toDownload = classifier == null\n            ? artifactFactory.createBuildArtifact( groupId, artifactId, version, packaging )\n            : artifactFactory.createArtifactWithClassifier( groupId, artifactId, version, packaging, classifier );\n\n        ArtifactRepositoryPolicy always =\n            new ArtifactRepositoryPolicy( true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS,\n                                          ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN );\n\n        List<ArtifactRepository> repoList = new ArrayList<ArtifactRepository>();\n\n        if ( pomRemoteRepositories != null )\n        {\n            repoList.addAll( pomRemoteRepositories );\n        }\n\n        if ( remoteRepositories != null )\n        {\n            // Use the same format as in the deploy plugin id::layout::url\n            List<String> repos = Arrays.asList( StringUtils.split( remoteRepositories, \",\" ) );\n            for ( String repo : repos )\n            {\n                repoList.add( parseRepository( repo, always ) );\n            }\n        }\n\n        try\n        {\n            ProjectBuildingRequest buildingRequest =\n                new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n            \n            buildingRequest.setRemoteRepositories( repoList );\n            \n            if ( transitive )\n            {\n                getLog().info( \"Resolving \" + toDownload + \" with transitive dependencies\" );\n                artifactResolver.resolveTransitively( buildingRequest, toDownload );\n            }\n            else\n            {\n                getLog().info( \"Resolving \" + toDownload );\n                artifactResolver.resolveArtifact( buildingRequest, toDownload );\n            }\n        }\n        catch ( ArtifactResolverException e )\n        {\n            throw new MojoExecutionException( \"Couldn't download artifact: \" + e.getMessage(), e );\n        }\n    }","id":44423,"modified_method":"@Override\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( isSkip() )\n        {\n            getLog().info( \"Skipping plugin execution\" );\n            return;\n        }\n\n        if ( coordinate.getArtifactId() == null && artifact == null )\n        {\n            throw new MojoFailureException( \"You must specify an artifact, \"\n                + \"e.g. -Dartifact=org.apache.maven.plugins:maven-downloader-plugin:1.0\" );\n        }\n        if ( artifact != null )\n        {\n            String[] tokens = StringUtils.split( artifact, \":\" );\n            if ( tokens.length < 3 || tokens.length > 5 )\n            {\n                throw new MojoFailureException(\n                    \"Invalid artifact, you must specify groupId:artifactId:version[:packaging[:classifier]] \"\n                        + artifact );\n            }\n            coordinate.setGroupId( tokens[0] );\n            coordinate.setArtifactId( tokens[1] );\n            coordinate.setVersion( tokens[2] );\n            if ( tokens.length >= 4 )\n            {\n                coordinate.setType( tokens[3] );\n            }\n            if ( tokens.length == 5 )\n            {\n                coordinate.setClassifier( tokens[4] );\n            }\n        }\n\n        ArtifactRepositoryPolicy always =\n            new ArtifactRepositoryPolicy( true, ArtifactRepositoryPolicy.UPDATE_POLICY_ALWAYS,\n                                          ArtifactRepositoryPolicy.CHECKSUM_POLICY_WARN );\n\n        List<ArtifactRepository> repoList = new ArrayList<ArtifactRepository>();\n\n        if ( pomRemoteRepositories != null )\n        {\n            repoList.addAll( pomRemoteRepositories );\n        }\n\n        if ( remoteRepositories != null )\n        {\n            // Use the same format as in the deploy plugin id::layout::url\n            List<String> repos = Arrays.asList( StringUtils.split( remoteRepositories, \",\" ) );\n            for ( String repo : repos )\n            {\n                repoList.add( parseRepository( repo, always ) );\n            }\n        }\n\n        try\n        {\n            ProjectBuildingRequest buildingRequest =\n                new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n            \n            buildingRequest.setRemoteRepositories( repoList );\n            \n            if ( transitive )\n            {\n                getLog().info( \"Resolving \" + coordinate + \" with transitive dependencies\" );\n                artifactResolver.resolveDependencies( buildingRequest, Collections.singletonList( coordinate ), null );\n            }\n            else\n            {\n                getLog().info( \"Resolving \" + coordinate );\n                artifactResolver.resolveArtifact( buildingRequest, coordinate );\n            }\n        }\n        catch ( ArtifactResolverException e )\n        {\n            throw new MojoExecutionException( \"Couldn't download artifact: \" + e.getMessage(), e );\n        }\n    }","commit_id":"fb19ccd303215cb2bdbeedf41e7c79022be5eaa3","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( isSkip() )\n        {\n            getLog().info( \"Skipping plugin execution\" );\n            return;\n        }\n\n        if ( !StringUtils.isEmpty( manualInclude ) )\n        {\n            manualIncludes = this.parseIncludes( manualInclude );\n        }\n        // If it's a manual purge, the only step is to delete from the local repo\n        if ( manualIncludes != null && manualIncludes.size() > 0 )\n        {\n            manualPurge( manualIncludes );\n            return;\n        }\n\n        Set<Artifact> dependencyArtifacts;\n\n        try\n        {\n            dependencyArtifacts = project.createArtifacts( factory, null, null );\n        }\n        catch ( InvalidDependencyVersionException e )\n        {\n            throw new MojoFailureException( \"Unable to purge dependencies due to invalid dependency version \", e );\n        }\n\n        TransformableFilter dependencyFilter = createPurgeArtifactsFilter( dependencyArtifacts );\n\n        Set<Artifact> resolvedArtifactsToPurge =\n            getFilteredResolvedArtifacts( project, dependencyArtifacts, dependencyFilter );\n\n        if ( resolvedArtifactsToPurge.isEmpty() )\n        {\n            getLog().info( \"No artifacts included for purge for project: \" + project.getId() );\n            return;\n        }\n\n        verbose( \"Purging dependencies for project: \" + project.getId() );\n        purgeArtifacts( resolvedArtifactsToPurge );\n\n        if ( reResolve )\n        {\n            ArtifactFilter artifactFilter = dependencyFilter.transform( new ArtifactIncludeFilterTransformer() );\n            try\n            {\n                reResolveArtifacts( project, resolvedArtifactsToPurge, artifactFilter );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                String failureMessage = \"Failed to refresh project dependencies for: \" + project.getId();\n                MojoFailureException failure = new MojoFailureException( failureMessage );\n                failure.initCause( e );\n\n                throw failure;\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                String failureMessage = \"Failed to refresh project dependencies for: \" + project.getId();\n                MojoFailureException failure = new MojoFailureException( failureMessage );\n                failure.initCause( e );\n\n                throw failure;\n            }\n        }\n    }","id":44424,"modified_method":"@Override\n    public void execute()\n        throws MojoExecutionException, MojoFailureException\n    {\n        if ( isSkip() )\n        {\n            getLog().info( \"Skipping plugin execution\" );\n            return;\n        }\n\n        if ( !StringUtils.isEmpty( manualInclude ) )\n        {\n            manualIncludes = this.parseIncludes( manualInclude );\n        }\n        // If it's a manual purge, the only step is to delete from the local repo\n        if ( manualIncludes != null && manualIncludes.size() > 0 )\n        {\n            manualPurge( manualIncludes );\n            return;\n        }\n\n        Set<Artifact> dependencyArtifacts = project.getDependencyArtifacts();\n\n        TransformableFilter dependencyFilter = createPurgeArtifactsFilter( dependencyArtifacts );\n\n        Set<Artifact> resolvedArtifactsToPurge =\n            getFilteredResolvedArtifacts( project, dependencyArtifacts, dependencyFilter );\n\n        if ( resolvedArtifactsToPurge.isEmpty() )\n        {\n            getLog().info( \"No artifacts included for purge for project: \" + project.getId() );\n            return;\n        }\n\n        verbose( \"Purging dependencies for project: \" + project.getId() );\n        purgeArtifacts( resolvedArtifactsToPurge );\n\n        if ( reResolve )\n        {\n            ArtifactFilter artifactFilter = dependencyFilter.transform( new ArtifactIncludeFilterTransformer() );\n            try\n            {\n                reResolveArtifacts( project, resolvedArtifactsToPurge, artifactFilter );\n            }\n            catch ( ArtifactResolutionException e )\n            {\n                String failureMessage = \"Failed to refresh project dependencies for: \" + project.getId();\n                MojoFailureException failure = new MojoFailureException( failureMessage );\n                failure.initCause( e );\n\n                throw failure;\n            }\n            catch ( ArtifactNotFoundException e )\n            {\n                String failureMessage = \"Failed to refresh project dependencies for: \" + project.getId();\n                MojoFailureException failure = new MojoFailureException( failureMessage );\n                failure.initCause( e );\n\n                throw failure;\n            }\n        }\n    }","commit_id":"fb19ccd303215cb2bdbeedf41e7c79022be5eaa3","url":"https://github.com/apache/maven-plugins"},{"original_method":"private Set<Artifact> getFilteredResolvedArtifacts( MavenProject project, Set<Artifact> artifacts,\n                                                        TransformableFilter filter )\n    {\n        try\n        {\n            Iterable<ArtifactResult> results =\n                resolver.resolveTransitively( session.getProjectBuildingRequest(), project.getArtifact(), filter );\n\n            Set<Artifact> resolvedArtifacts = new HashSet<Artifact>();\n            \n            for ( ArtifactResult artResult : results )\n            {\n                resolvedArtifacts.add( artResult.getArtifact() );\n            }\n\n            return resolvedArtifacts;\n        }\n        catch ( ArtifactResolverException e )\n        {\n            getLog().info( \"Unable to resolve all dependencies for : \" + project.getGroupId() + \":\"\n                               + project.getArtifactId() + \":\" + project.getVersion()\n                               + \". Falling back to non-transitive mode for initial artifact resolution.\" );\n        }\n\n        Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>();\n        \n        ArtifactFilter artifactFilter = filter.transform( new ArtifactIncludeFilterTransformer() );\n        \n        // Resolve the only poms here instead of the actual artifacts, because the files will be deleted during the\n        // purge anyway\n        for ( Artifact artifact : artifacts )\n        {\n            if ( artifactFilter.include( artifact ) )\n            {\n                try\n                {\n                    ArtifactResult artifactResult =\n                        resolver.resolveArtifact( session.getProjectBuildingRequest(), artifact );\n                    \n                    resolvedArtifacts.add( artifactResult.getArtifact() );\n                }\n                catch ( ArtifactResolverException e )\n                {\n                    getLog().debug( \"Unable to resolve artifact: \" + artifact );\n                }\n            }\n        }\n        return resolvedArtifacts;\n    }","id":44425,"modified_method":"private Set<Artifact> getFilteredResolvedArtifacts( MavenProject project, Set<Artifact> artifacts,\n                                                        TransformableFilter filter )\n    {\n        try\n        {\n            \n            Iterable<ArtifactResult> results =\n                resolver.resolveDependencies( session.getProjectBuildingRequest(),\n                                              TransferUtils.toArtifactCoordinate( project ), filter );\n\n            Set<Artifact> resolvedArtifacts = new HashSet<Artifact>();\n            \n            for ( ArtifactResult artResult : results )\n            {\n                resolvedArtifacts.add( artResult.getArtifact() );\n            }\n\n            return resolvedArtifacts;\n        }\n        catch ( ArtifactResolverException e )\n        {\n            getLog().info( \"Unable to resolve all dependencies for : \" + project.getGroupId() + \":\"\n                               + project.getArtifactId() + \":\" + project.getVersion()\n                               + \". Falling back to non-transitive mode for initial artifact resolution.\" );\n        }\n\n        Set<Artifact> resolvedArtifacts = new LinkedHashSet<Artifact>();\n        \n        ArtifactFilter artifactFilter = filter.transform( new ArtifactIncludeFilterTransformer() );\n        \n        // Resolve the only poms here instead of the actual artifacts, because the files will be deleted during the\n        // purge anyway\n        for ( Artifact artifact : artifacts )\n        {\n            if ( artifactFilter.include( artifact ) )\n            {\n                try\n                {\n                    ArtifactResult artifactResult =\n                        resolver.resolveArtifact( session.getProjectBuildingRequest(), artifact );\n                    \n                    resolvedArtifacts.add( artifactResult.getArtifact() );\n                }\n                catch ( ArtifactResolverException e )\n                {\n                    getLog().debug( \"Unable to resolve artifact: \" + artifact );\n                }\n            }\n        }\n        return resolvedArtifacts;\n    }","commit_id":"fb19ccd303215cb2bdbeedf41e7c79022be5eaa3","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void reResolveArtifacts( MavenProject project, Set<Artifact> artifacts, ArtifactFilter filter )\n        throws ArtifactResolutionException, ArtifactNotFoundException\n    {\n\n        // Always need to re-resolve the poms in case they were purged along with the artifact\n        // because Maven 2 will not automatically re-resolve them when resolving the artifact\n        for ( Artifact artifact : artifacts )\n        {\n            try\n            {\n                Artifact pomArtifact =\n                    factory.createArtifact( artifact.getGroupId(), artifact.getArtifactId(), artifact.getVersion(),\n                                            null, \"pom\" );\n                resolver.resolveArtifact( session.getProjectBuildingRequest(), pomArtifact );\n            }\n            catch ( ArtifactResolverException e )\n            {\n                verbose( e.getMessage() );\n            }\n        }\n\n        List<Artifact> missingArtifacts = new ArrayList<Artifact>();\n\n        for ( Artifact artifact : artifacts )\n        {\n            verbose( \"Resolving artifact: \" + artifact.getId() );\n\n            try\n            {\n                resolver.resolveArtifact( session.getProjectBuildingRequest(), artifact );\n            }\n            catch ( ArtifactResolverException e )\n            {\n                verbose( e.getMessage() );\n                missingArtifacts.add( artifact );\n            }\n        }\n\n        if ( missingArtifacts.size() > 0 )\n        {\n            StringBuffer message = new StringBuffer( \"required artifacts missing:\\n\" );\n            for ( Artifact missingArtifact : missingArtifacts )\n            {\n                message.append( \"  \" ).append( missingArtifact.getId() ).append( '\\n' );\n            }\n            message.append( \"\\nfor the artifact:\" );\n\n            throw new ArtifactResolutionException( message.toString(), project.getArtifact(),\n                                                   project.getRemoteArtifactRepositories() );\n        }\n    }","id":44426,"modified_method":"private void reResolveArtifacts( MavenProject project, Set<Artifact> artifacts, ArtifactFilter filter )\n        throws ArtifactResolutionException, ArtifactNotFoundException\n    {\n\n        // Always need to re-resolve the poms in case they were purged along with the artifact\n        // because Maven 2 will not automatically re-resolve them when resolving the artifact\n        for ( Artifact artifact : artifacts )\n        {\n            try\n            {\n                resolver.resolveArtifact( session.getProjectBuildingRequest(),\n                                          TransferUtils.toArtifactCoordinate( artifact ) );\n            }\n            catch ( ArtifactResolverException e )\n            {\n                verbose( e.getMessage() );\n            }\n        }\n\n        List<Artifact> missingArtifacts = new ArrayList<Artifact>();\n\n        for ( Artifact artifact : artifacts )\n        {\n            verbose( \"Resolving artifact: \" + artifact.getId() );\n\n            try\n            {\n                resolver.resolveArtifact( session.getProjectBuildingRequest(), artifact );\n            }\n            catch ( ArtifactResolverException e )\n            {\n                verbose( e.getMessage() );\n                missingArtifacts.add( artifact );\n            }\n        }\n\n        if ( missingArtifacts.size() > 0 )\n        {\n            StringBuffer message = new StringBuffer( \"required artifacts missing:\\n\" );\n            for ( Artifact missingArtifact : missingArtifacts )\n            {\n                message.append( \"  \" ).append( missingArtifact.getId() ).append( '\\n' );\n            }\n            message.append( \"\\nfor the artifact:\" );\n\n            throw new ArtifactResolutionException( message.toString(), project.getArtifact(),\n                                                   project.getRemoteArtifactRepositories() );\n        }\n    }","commit_id":"fb19ccd303215cb2bdbeedf41e7c79022be5eaa3","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Main entry into mojo. Gets the list of dependencies and iterates through\n     * displaying the resolved version.\n     *\n     * @throws MojoExecutionException with a message if an error occurs.\n     */\n    @Override\n    protected void doExecute()\n        throws MojoExecutionException\n    {\n        Writer outputWriter = null;\n\n        try\n        {\n            final Set<Artifact> plugins = resolvePluginArtifacts();\n\n            if ( this.outputFile != null )\n            {\n                outputFile.getParentFile()\n                          .mkdirs();\n\n                outputWriter = new FileWriter( outputFile );\n            }\n\n            for ( final Artifact plugin : plugins )\n            {\n                String logStr = \"Plugin Resolved: \" + DependencyUtil.getFormattedFileName( plugin, false );\n                if ( !isSilent() )\n                {\n                    this.getLog().info( logStr );\n                }\n\n                if ( outputWriter != null )\n                {\n                    outputWriter.write( logStr );\n                    outputWriter.write( \"\\n\" );\n                }\n\n                if ( !excludeTransitive )\n                {\n                    for ( final Artifact artifact : resolveArtifactDependencies( plugin ) )\n                    {\n                        logStr =\n                            \"    Plugin Dependency Resolved: \" + DependencyUtil.getFormattedFileName( artifact, false );\n\n                        if ( !isSilent() )\n                        {\n                            this.getLog().info( logStr );\n                        }\n\n                        if ( outputWriter != null )\n                        {\n                            outputWriter.write( logStr );\n                            outputWriter.write( \"\\n\" );\n                        }\n                    }\n                }\n            }\n        }\n        catch ( final IOException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( final ArtifactFilterException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( ArtifactResolverException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        finally\n        {\n            IOUtil.close( outputWriter );\n        }\n\n    }","id":44427,"modified_method":"/**\n     * Main entry into mojo. Gets the list of dependencies and iterates through\n     * displaying the resolved version.\n     *\n     * @throws MojoExecutionException with a message if an error occurs.\n     */\n    @Override\n    protected void doExecute()\n        throws MojoExecutionException\n    {\n        Writer outputWriter = null;\n\n        try\n        {\n            final Set<Artifact> plugins = resolvePluginArtifacts();\n\n            if ( this.outputFile != null )\n            {\n                outputFile.getParentFile()\n                          .mkdirs();\n\n                outputWriter = new FileWriter( outputFile );\n            }\n\n            for ( final Artifact plugin : plugins )\n            {\n                String logStr = \"Plugin Resolved: \" + DependencyUtil.getFormattedFileName( plugin, false );\n                if ( !isSilent() )\n                {\n                    this.getLog().info( logStr );\n                }\n\n                if ( outputWriter != null )\n                {\n                    outputWriter.write( logStr );\n                    outputWriter.write( \"\\n\" );\n                }\n\n                if ( !excludeTransitive )\n                {\n                    ArtifactCoordinate coordinate = TransferUtils.toArtifactCoordinate( plugin );\n                    \n                    for ( final Artifact artifact : resolveArtifactDependencies( coordinate ) )\n                    {\n                        logStr =\n                            \"    Plugin Dependency Resolved: \" + DependencyUtil.getFormattedFileName( artifact, false );\n\n                        if ( !isSilent() )\n                        {\n                            this.getLog().info( logStr );\n                        }\n\n                        if ( outputWriter != null )\n                        {\n                            outputWriter.write( logStr );\n                            outputWriter.write( \"\\n\" );\n                        }\n                    }\n                }\n            }\n        }\n        catch ( final IOException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( final ArtifactFilterException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        catch ( ArtifactResolverException e )\n        {\n            throw new MojoExecutionException( \"Nested:\", e );\n        }\n        finally\n        {\n            IOUtil.close( outputWriter );\n        }\n\n    }","commit_id":"fb19ccd303215cb2bdbeedf41e7c79022be5eaa3","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * This method resolves the plugin artifacts from the project.\n     *\n     * @return set of resolved plugin artifacts.\n     * @throws ArtifactFilterException \n     * @throws ArtifactResolverException \n     */\n    protected Set<Artifact> resolvePluginArtifacts()\n        throws ArtifactFilterException, ArtifactResolverException\n    {\n        final Set<Artifact> plugins = getProject().getPluginArtifacts();\n        final Set<Artifact> reports = getProject().getReportArtifacts();\n\n        Set<Artifact> artifacts = new HashSet<Artifact>();\n        artifacts.addAll( reports );\n        artifacts.addAll( plugins );\n\n        final FilterArtifacts filter = getPluginArtifactsFilter();\n        artifacts = filter.filter( artifacts );\n\n        //        final ArtifactFilter filter = getPluginFilter();\n        for ( final Artifact artifact : new HashSet<Artifact>( artifacts ) )\n        {\n            // if ( !filter.include( artifact ) )\n            // {\n            //     final String logStr =\n            //     String.format( \"    Plugin SKIPPED: %s\", DependencyUtil.getFormattedFileName( artifact, false ) );\n            //\n            //     if ( !silent )\n            //     {\n            //         this.getLog().info( logStr );\n            //     }\n            //\n            //     artifacts.remove( artifact );\n            //     continue;\n            // }\n\n            ProjectBuildingRequest buildingRequest =\n                new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n            \n            buildingRequest.setRemoteRepositories( this.remotePluginRepositories );\n            \n            // resolve the new artifact\n            getArtifactResolver().resolveArtifact( buildingRequest, artifact );\n        }\n        return artifacts;\n    }","id":44428,"modified_method":"/**\n     * This method resolves the plugin artifacts from the project.\n     *\n     * @return set of resolved plugin artifacts.\n     * @throws ArtifactFilterException \n     * @throws ArtifactResolverException \n     */\n    protected Set<Artifact> resolvePluginArtifacts()\n        throws ArtifactFilterException, ArtifactResolverException\n    {\n        final Set<Artifact> plugins = getProject().getPluginArtifacts();\n        final Set<Artifact> reports = getProject().getReportArtifacts();\n\n        Set<Artifact> artifacts = new HashSet<Artifact>();\n        artifacts.addAll( reports );\n        artifacts.addAll( plugins );\n\n        final FilterArtifacts filter = getPluginArtifactsFilter();\n        artifacts = filter.filter( artifacts );\n\n        Set<Artifact> resolvedArtifacts = new HashSet<Artifact>( artifacts.size() );\n        //        final ArtifactFilter filter = getPluginFilter();\n        for ( final Artifact artifact : new HashSet<Artifact>( artifacts ) )\n        {\n            // if ( !filter.include( artifact ) )\n            // {\n            //     final String logStr =\n            //     String.format( \"    Plugin SKIPPED: %s\", DependencyUtil.getFormattedFileName( artifact, false ) );\n            //\n            //     if ( !silent )\n            //     {\n            //         this.getLog().info( logStr );\n            //     }\n            //\n            //     artifacts.remove( artifact );\n            //     continue;\n            // }\n\n            ProjectBuildingRequest buildingRequest =\n                new DefaultProjectBuildingRequest( session.getProjectBuildingRequest() );\n            \n            buildingRequest.setRemoteRepositories( this.remotePluginRepositories );\n            \n            // resolve the new artifact\n            resolvedArtifacts.add( getArtifactResolver().resolveArtifact( buildingRequest, artifact ) .getArtifact() );\n        }\n        return artifacts;\n    }","commit_id":"fb19ccd303215cb2bdbeedf41e7c79022be5eaa3","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test remote repositories parameter\n     * \n     * @throws Exception\n     */\n    public void testRemoteRepositories()\n        throws Exception\n    {\n        setVariableValueToObject( mojo, \"remoteRepositories\", \"central::default::http://repo1.maven.apache.org/maven2,\"\n            + \"central::::http://repo1.maven.apache.org/maven2,\" + \"http://repo1.maven.apache.org/maven2\" );\n        setVariableValueToObject( mojo, \"groupId\", \"org.apache.maven\" );\n        setVariableValueToObject( mojo, \"artifactId\", \"maven-model\" );\n        setVariableValueToObject( mojo, \"version\", \"2.0.9\" );\n\n        mojo.execute();\n    }","id":44429,"modified_method":"/**\n     * Test remote repositories parameter\n     * \n     * @throws Exception\n     */\n    public void testRemoteRepositories()\n        throws Exception\n    {\n        setVariableValueToObject( mojo, \"remoteRepositories\", \"central::default::http://repo1.maven.apache.org/maven2,\"\n            + \"central::::http://repo1.maven.apache.org/maven2,\" + \"http://repo1.maven.apache.org/maven2\" );\n        mojo.setGroupId( \"org.apache.maven\" );\n        mojo.setArtifactId( \"maven-model\" );\n        mojo.setVersion( \"2.0.9\" );\n\n        mojo.execute();\n    }","commit_id":"fb19ccd303215cb2bdbeedf41e7c79022be5eaa3","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Test transitive parameter\n     * \n     * @throws Exception\n     */\n    public void testTransitive()\n        throws Exception\n    {\n        // Set properties, transitive = default value = true\n        setVariableValueToObject( mojo, \"transitive\", Boolean.FALSE );\n        setVariableValueToObject( mojo, \"remoteRepositories\", \"central::default::http://repo1.maven.apache.org/maven2\" );\n        setVariableValueToObject( mojo, \"groupId\", \"org.apache.maven\" );\n        setVariableValueToObject( mojo, \"artifactId\", \"maven-model\" );\n        setVariableValueToObject( mojo, \"version\", \"2.0.9\" );\n\n        mojo.execute();\n\n        // Set properties, transitive = false\n        setVariableValueToObject( mojo, \"transitive\", Boolean.FALSE );\n        mojo.execute();\n    }","id":44430,"modified_method":"/**\n     * Test transitive parameter\n     * \n     * @throws Exception\n     */\n    public void testTransitive()\n        throws Exception\n    {\n        // Set properties, transitive = default value = true\n        setVariableValueToObject( mojo, \"transitive\", Boolean.FALSE );\n        setVariableValueToObject( mojo, \"remoteRepositories\", \"central::default::http://repo1.maven.apache.org/maven2\" );\n        mojo.setGroupId( \"org.apache.maven\" );\n        mojo.setArtifactId( \"maven-model\" );\n        mojo.setVersion( \"2.0.9\" );\n\n        mojo.execute();\n\n        // Set properties, transitive = false\n        setVariableValueToObject( mojo, \"transitive\", Boolean.FALSE );\n        mojo.execute();\n    }","commit_id":"fb19ccd303215cb2bdbeedf41e7c79022be5eaa3","url":"https://github.com/apache/maven-plugins"},{"original_method":"public EditorCell createTargetCell(EditorContext context, SemanticNode node) {\n    SemanticNode referencedNode = null;\n    referencedNode = node.getChild(\"target\");\n    if(referencedNode == null) {\n      {\n        EditorCell_Error noRefCell = EditorCell_Error.create(context, node, \"target\");\n        noRefCell.setEditable(true);\n        noRefCell.setSelectable(true);\n        noRefCell.setDrawBorder(false);\n        noRefCell.setDrawBrackets(false);\n        noRefCell.setBracketsColor(Color.black);\n        noRefCell.setAction(EditorCellAction.DELETE, new CellAction_Empty());\n        AggregationConceptLink_ConceptLinkTargets_Menu.setCellActions(noRefCell, node);\n        return noRefCell;\n      }\n    }\n    EditorCell editorCell = context.createNodeCell(referencedNode);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_Empty());\n    AggregationConceptLink_ConceptLinkTargets_Menu.setCellActions(editorCell, node);\n    return editorCell;\n  }","id":44431,"modified_method":"public EditorCell createTargetCell(EditorContext context, SemanticNode node) {\n    SemanticNode referencedNode = null;\n    referencedNode = node.getChild(\"target\");\n    LinkDeclaration linkDeclaration = SModelUtil.getLinkDeclaration(node, \"target\");\n    if(referencedNode == null) {\n      {\n        EditorCell_Error noRefCell = EditorCell_Error.create(context, node, \"target\");\n        noRefCell.setEditable(true);\n        noRefCell.setSelectable(true);\n        noRefCell.setDrawBorder(false);\n        noRefCell.setDrawBrackets(false);\n        noRefCell.setBracketsColor(Color.black);\n        noRefCell.setAction(EditorCellAction.DELETE, new CellAction_Empty());\n        noRefCell.setSubstituteInfo(new DefaultChildSubstituteInfo(node, linkDeclaration));\n        AggregationConceptLink_ConceptLinkTargets_Menu.setCellActions(noRefCell, node);\n        return noRefCell;\n      }\n    }\n    EditorCell editorCell = context.createNodeCell(referencedNode);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    editorCell.setAction(EditorCellAction.DELETE, new CellAction_Empty());\n    if(editorCell.getSubstituteInfo() == null) {\n      editorCell.setSubstituteInfo(new DefaultChildSubstituteInfo(node, linkDeclaration));\n    }\n    AggregationConceptLink_ConceptLinkTargets_Menu.setCellActions(editorCell, node);\n    return editorCell;\n  }","commit_id":"597d9bb2adc1a9f6c4b82b8b87d27713f4489576","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createLinkDeclarationList(EditorContext context, SemanticNode node) {\n    if(this.myLinkDeclarationListHandler == null) {\n      this.myLinkDeclarationListHandler = new ConceptDeclaration_Editor_LinkDeclarationListHandler(node, \"linkDeclaration\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myLinkDeclarationListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44432,"modified_method":"public EditorCell createLinkDeclarationList(EditorContext context, SemanticNode node) {\n    if(this.myLinkDeclarationListHandler == null) {\n      this.myLinkDeclarationListHandler = new ConceptDeclaration_Editor_LinkDeclarationListHandler(node, \"linkDeclaration\", true);\n    }\n    EditorCell_Collection editorCell = this.myLinkDeclarationListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"597d9bb2adc1a9f6c4b82b8b87d27713f4489576","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createPropertyDeclarationList(EditorContext context, SemanticNode node) {\n    if(this.myPropertyDeclarationListHandler == null) {\n      this.myPropertyDeclarationListHandler = new ConceptDeclaration_Editor_PropertyDeclarationListHandler(node, \"propertyDeclaration\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myPropertyDeclarationListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44433,"modified_method":"public EditorCell createPropertyDeclarationList(EditorContext context, SemanticNode node) {\n    if(this.myPropertyDeclarationListHandler == null) {\n      this.myPropertyDeclarationListHandler = new ConceptDeclaration_Editor_PropertyDeclarationListHandler(node, \"propertyDeclaration\", true);\n    }\n    EditorCell_Collection editorCell = this.myPropertyDeclarationListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"597d9bb2adc1a9f6c4b82b8b87d27713f4489576","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConceptPropertyList(EditorContext context, SemanticNode node) {\n    if(this.myConceptPropertyListHandler == null) {\n      this.myConceptPropertyListHandler = new ConceptDeclaration_Editor_ConceptPropertyListHandler(node, \"conceptProperty\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myConceptPropertyListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44434,"modified_method":"public EditorCell createConceptPropertyList(EditorContext context, SemanticNode node) {\n    if(this.myConceptPropertyListHandler == null) {\n      this.myConceptPropertyListHandler = new ConceptDeclaration_Editor_ConceptPropertyListHandler(node, \"conceptProperty\", true);\n    }\n    EditorCell_Collection editorCell = this.myConceptPropertyListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"597d9bb2adc1a9f6c4b82b8b87d27713f4489576","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConceptLinkList(EditorContext context, SemanticNode node) {\n    if(this.myConceptLinkListHandler == null) {\n      this.myConceptLinkListHandler = new ConceptDeclaration_Editor_ConceptLinkListHandler(node, \"conceptLink\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myConceptLinkListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44435,"modified_method":"public EditorCell createConceptLinkList(EditorContext context, SemanticNode node) {\n    if(this.myConceptLinkListHandler == null) {\n      this.myConceptLinkListHandler = new ConceptDeclaration_Editor_ConceptLinkListHandler(node, \"conceptLink\", true);\n    }\n    EditorCell_Collection editorCell = this.myConceptLinkListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(false);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"597d9bb2adc1a9f6c4b82b8b87d27713f4489576","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createMemberList(EditorContext context, SemanticNode node) {\n    if(this.myMemberListHandler == null) {\n      this.myMemberListHandler = new EnumerationDataTypeDeclaration_Editor_MemberListHandler(node, \"member\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myMemberListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44436,"modified_method":"public EditorCell createMemberList(EditorContext context, SemanticNode node) {\n    if(this.myMemberListHandler == null) {\n      this.myMemberListHandler = new EnumerationDataTypeDeclaration_Editor_MemberListHandler(node, \"member\", true);\n    }\n    EditorCell_Collection editorCell = this.myMemberListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(true);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"597d9bb2adc1a9f6c4b82b8b87d27713f4489576","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createMethodsList(EditorContext context, SemanticNode node) {\n    if(this.myMethodListHandler == null) {\n      this.myMethodListHandler = new ClassConcept_Editor_MethodListHandler(node, \"method\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myMethodListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44437,"modified_method":"public EditorCell createMethodsList(EditorContext context, SemanticNode node) {\n    if(this.myMethodListHandler == null) {\n      this.myMethodListHandler = new ClassConcept_Editor_MethodListHandler(node, \"method\", true);\n    }\n    EditorCell_Collection editorCell = this.myMethodListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createStaticFieldList(EditorContext context, SemanticNode node) {\n    if(this.myStaticFieldListHandler == null) {\n      this.myStaticFieldListHandler = new ClassConcept_Editor_StaticFieldListHandler(node, \"staticField\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myStaticFieldListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44438,"modified_method":"public EditorCell createStaticFieldList(EditorContext context, SemanticNode node) {\n    if(this.myStaticFieldListHandler == null) {\n      this.myStaticFieldListHandler = new ClassConcept_Editor_StaticFieldListHandler(node, \"staticField\", true);\n    }\n    EditorCell_Collection editorCell = this.myStaticFieldListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createFieldsList(EditorContext context, SemanticNode node) {\n    if(this.myFieldListHandler == null) {\n      this.myFieldListHandler = new ClassConcept_Editor_FieldListHandler(node, \"field\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myFieldListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44439,"modified_method":"public EditorCell createFieldsList(EditorContext context, SemanticNode node) {\n    if(this.myFieldListHandler == null) {\n      this.myFieldListHandler = new ClassConcept_Editor_FieldListHandler(node, \"field\", true);\n    }\n    EditorCell_Collection editorCell = this.myFieldListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstructorsList(EditorContext context, SemanticNode node) {\n    if(this.myConstructorListHandler == null) {\n      this.myConstructorListHandler = new ClassConcept_Editor_ConstructorListHandler(node, \"constructor\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myConstructorListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44440,"modified_method":"public EditorCell createConstructorsList(EditorContext context, SemanticNode node) {\n    if(this.myConstructorListHandler == null) {\n      this.myConstructorListHandler = new ClassConcept_Editor_ConstructorListHandler(node, \"constructor\", true);\n    }\n    EditorCell_Collection editorCell = this.myConstructorListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createStaticMethodList(EditorContext context, SemanticNode node) {\n    if(this.myStaticMethodListHandler == null) {\n      this.myStaticMethodListHandler = new ClassConcept_Editor_StaticMethodListHandler(node, \"staticMethod\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myStaticMethodListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44441,"modified_method":"public EditorCell createStaticMethodList(EditorContext context, SemanticNode node) {\n    if(this.myStaticMethodListHandler == null) {\n      this.myStaticMethodListHandler = new ClassConcept_Editor_StaticMethodListHandler(node, \"staticMethod\", true);\n    }\n    EditorCell_Collection editorCell = this.myStaticMethodListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(false);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createConstructorList(EditorContext context, SemanticNode node) {\n    if(this.myConstructorListHandler == null) {\n      this.myConstructorListHandler = new EnumClass_Editor_ConstructorListHandler(node, \"constructor\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myConstructorListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44442,"modified_method":"public EditorCell createConstructorList(EditorContext context, SemanticNode node) {\n    if(this.myConstructorListHandler == null) {\n      this.myConstructorListHandler = new EnumClass_Editor_ConstructorListHandler(node, \"constructor\", true);\n    }\n    EditorCell_Collection editorCell = this.myConstructorListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createEnumConstantList(EditorContext context, SemanticNode node) {\n    if(this.myEnumConstantListHandler == null) {\n      this.myEnumConstantListHandler = new EnumClass_Editor_EnumConstantListHandler(node, \"enumConstant\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myEnumConstantListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44443,"modified_method":"public EditorCell createEnumConstantList(EditorContext context, SemanticNode node) {\n    if(this.myEnumConstantListHandler == null) {\n      this.myEnumConstantListHandler = new EnumClass_Editor_EnumConstantListHandler(node, \"enumConstant\", true);\n    }\n    EditorCell_Collection editorCell = this.myEnumConstantListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createFieldList(EditorContext context, SemanticNode node) {\n    if(this.myFieldListHandler == null) {\n      this.myFieldListHandler = new EnumClass_Editor_FieldListHandler(node, \"field\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myFieldListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44444,"modified_method":"public EditorCell createFieldList(EditorContext context, SemanticNode node) {\n    if(this.myFieldListHandler == null) {\n      this.myFieldListHandler = new EnumClass_Editor_FieldListHandler(node, \"field\", true);\n    }\n    EditorCell_Collection editorCell = this.myFieldListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createStaticMethodList(EditorContext context, SemanticNode node) {\n    if(this.myStaticMethodListHandler == null) {\n      this.myStaticMethodListHandler = new EnumClass_Editor_StaticMethodListHandler(node, \"staticMethod\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myStaticMethodListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44445,"modified_method":"public EditorCell createStaticMethodList(EditorContext context, SemanticNode node) {\n    if(this.myStaticMethodListHandler == null) {\n      this.myStaticMethodListHandler = new EnumClass_Editor_StaticMethodListHandler(node, \"staticMethod\", true);\n    }\n    EditorCell_Collection editorCell = this.myStaticMethodListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createMethodList(EditorContext context, SemanticNode node) {\n    if(this.myMethodListHandler == null) {\n      this.myMethodListHandler = new EnumClass_Editor_MethodListHandler(node, \"method\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myMethodListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44446,"modified_method":"public EditorCell createMethodList(EditorContext context, SemanticNode node) {\n    if(this.myMethodListHandler == null) {\n      this.myMethodListHandler = new EnumClass_Editor_MethodListHandler(node, \"method\", true);\n    }\n    EditorCell_Collection editorCell = this.myMethodListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createActualArgumentList(EditorContext context, SemanticNode node) {\n    if(this.myActualArgumentListHandler == null) {\n      this.myActualArgumentListHandler = new EnumConstantDeclaration_Editor_ActualArgumentListHandler(node, \"actualArgument\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myActualArgumentListHandler.createCells_Horizontal(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44447,"modified_method":"public EditorCell createActualArgumentList(EditorContext context, SemanticNode node) {\n    if(this.myActualArgumentListHandler == null) {\n      this.myActualArgumentListHandler = new EnumConstantDeclaration_Editor_ActualArgumentListHandler(node, \"actualArgument\", true);\n    }\n    EditorCell_Collection editorCell = this.myActualArgumentListHandler.createCells(context, new CellLayout_Horizontal());\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createStatementList(EditorContext context, SemanticNode node) {\n    if(this.myStatementListHandler == null) {\n      this.myStatementListHandler = new StatementList_Editor_StatementListHandler(node, \"statement\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myStatementListHandler.createCells_Vertical(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44448,"modified_method":"public EditorCell createStatementList(EditorContext context, SemanticNode node) {\n    if(this.myStatementListHandler == null) {\n      this.myStatementListHandler = new StatementList_Editor_StatementListHandler(node, \"statement\", true);\n    }\n    EditorCell_Collection editorCell = this.myStatementListHandler.createCells(context, new CellLayout_Vertical());\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createActualArgumentList(EditorContext context, SemanticNode node) {\n    if(this.myActualArgumentListHandler == null) {\n      this.myActualArgumentListHandler = new SuperConstructorInvocation_Editor_ActualArgumentListHandler(node, \"actualArgument\", true);\n    }\n    EditorCell_Collection editorCell = null;\n    editorCell = this.myActualArgumentListHandler.createCells_Horizontal(context);\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","id":44449,"modified_method":"public EditorCell createActualArgumentList(EditorContext context, SemanticNode node) {\n    if(this.myActualArgumentListHandler == null) {\n      this.myActualArgumentListHandler = new SuperConstructorInvocation_Editor_ActualArgumentListHandler(node, \"actualArgument\", true);\n    }\n    EditorCell_Collection editorCell = this.myActualArgumentListHandler.createCells(context, new CellLayout_Horizontal());\n    editorCell.setSelectable(true);\n    editorCell.setDrawBorder(true);\n    editorCell.setGridLayout(false);\n    editorCell.setDrawBrackets(false);\n    editorCell.setBracketsColor(Color.black);\n    return editorCell;\n  }","commit_id":"bf4f19749107d4ddcf6015b99d9d21559da031de","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isAllowedAlpha(FactHandle factHandle,\r\n                                  Tuple tuple,\r\n                                  WorkingMemory workingMemory) {\r\n        boolean found = true;\r\n        if ( this.alphaPresent ) {\r\n            for ( int i = 0, length = this.alphaConstraints.length; i < length && found; i++ ) {\r\n                // escape immediately if some condition does not match\r\n                found = this.alphaConstraints[i].isAllowed( factHandle,\r\n                                                            tuple,\r\n                                                            workingMemory );\r\n            }\r\n            return found;\r\n        }\r\n\r\n        return true;\r\n    }","id":44450,"modified_method":"public boolean isAllowedAlpha(FactHandle factHandle,\r\n                                  Tuple tuple,\r\n                                  WorkingMemory workingMemory) {\r\n        if ( this.alphaPresent ) {\r\n            for (int i = 0, length = this.alphaConstraints.length; i < length; i++) {\r\n                // escape immediately if some condition does not match\r\n                if (!this.alphaConstraints[i].isAllowed(factHandle, tuple, workingMemory)) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }","commit_id":"414d68eda720ee7eabca44b1a1810f996c4b3adb","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testCurrent() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tBaseTableIterator it = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertEquals(this.h1, it.current());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tassertEquals(this.h1000, it.current());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertEquals(this.h1, it.current());\r\n\t\tit = new BaseTableIterator(new TableRecord(this.h1));\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tassertEquals(this.h1, it.current());\r\n\r\n\t}","id":44451,"modified_method":"public void testCurrent() {\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tBaseTableIterator it = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.headRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1000, it.next());\r\n\t\tthis.testTable.clear();\r\n\t\tthis.testTable.add(this.h1);\r\n\t\tthis.testTable.add(this.h1000);\r\n\t\tthis.testTable.add(this.h10);\r\n\t\tthis.testTable.add(this.h100);\r\n\t\tit = new BaseTableIterator(this.testTable.headRecord,\r\n\t\t\t\tthis.testTable.tailRecord, this.testTable.tailRecord);\r\n\t\tassertEquals(this.h1, it.next());\r\n\t\tit = new BaseTableIterator(new TableRecord(this.h1));\r\n\t\tassertEquals(this.h1, it.next());\r\n\t}","commit_id":"414d68eda720ee7eabca44b1a1810f996c4b3adb","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * this method does nested loops iterations on all relavant fact tables and\r\n     * evaluates rules conditions\r\n     * \r\n     * @param token\r\n     * @throws NoMatchesFoundException\r\n     * @throws Exception\r\n     * @throws InvalidRuleException\r\n     */\r\n    final static protected void evaluate(Token token)\r\n            throws NoMatchesFoundException, InvalidRuleException {\r\n        WorkingMemoryImpl workingMemory = (WorkingMemoryImpl) token\r\n                .getWorkingMemory();\r\n        LeapsRule leapsRule = token.getCurrentRuleHandle().getLeapsRule();\r\n        // sometimes there is no normal conditions, only not and exists\r\n        int numberOfColumns = leapsRule.getNumberOfColumns();\r\n        if (numberOfColumns > 0) {\r\n            int dominantFactPosition = token.getCurrentRuleHandle()\r\n                    .getDominantPosition();\r\n            FactHandleImpl dominantFactHandle = token.getDominantFactHandle();\r\n            if (leapsRule.getColumnConstraintsAtPosition(dominantFactPosition)\r\n                    .isAllowedAlpha(dominantFactHandle, token, workingMemory)) {\r\n                FactHandleImpl interatorStartFactHandle;\r\n                FactTable factTable;\r\n                Class dominantClass = leapsRule.getColumnClassObjectTypeAtPosition(dominantFactPosition);\r\n                Class columnClass;\r\n                TableIterator[] iterators = new TableIterator[numberOfColumns];\r\n                // getting iterators first\r\n                for (int i = 0; i < numberOfColumns; i++) {\r\n                    if (i == dominantFactPosition) {\r\n                        iterators[i] = Table.singleItemIterator(dominantFactHandle);\r\n                    } else {\r\n                        columnClass = leapsRule.getColumnClassObjectTypeAtPosition(i);\r\n                        factTable = workingMemory.getFactTable(columnClass);\r\n                        interatorStartFactHandle = new FactHandleImpl(\r\n                                dominantFactHandle.getId()\r\n                                        - (dominantClass == columnClass ? 1 : 0),\r\n                                null); \r\n                        if (i > 0 && leapsRule.getColumnConstraintsAtPosition(i).isAlphaPresent()) {\r\n                            iterators[i] = factTable.tailConstrainedIterator(\r\n                                            workingMemory,\r\n                                            leapsRule.getColumnConstraintsAtPosition(i),\r\n                                            interatorStartFactHandle,\r\n                                            (token.isResume() ? (FactHandleImpl)token.get(i) \r\n                                                    : interatorStartFactHandle));\r\n                        } else {\r\n                            iterators[i] = factTable.tailIterator(\r\n                                    interatorStartFactHandle,\r\n                                            (token.isResume() ? (FactHandleImpl)token.get(i) \r\n                                                    : interatorStartFactHandle));\r\n                        }\r\n                    }\r\n                }\r\n                // check if any iterators are empty to abort\r\n                // check if we resume and any starting facts disappeared than we\r\n                // do\r\n                // not do skip on resume\r\n                boolean someIteratorsEmpty = false;\r\n                boolean doReset = false;\r\n                boolean skip = token.isResume();\r\n                TableIterator currentIterator;\r\n                for (int i = 0; i < numberOfColumns && !someIteratorsEmpty; i++) {\r\n                    currentIterator = iterators[i];\r\n                    if (currentIterator.isEmpty()) {\r\n                        someIteratorsEmpty = true;\r\n                    } else {\r\n                        if (!doReset) {\r\n                            if (skip && currentIterator.hasNext()\r\n                                    && !currentIterator.peekNext().equals(token.get(i))) {\r\n                                skip = false;\r\n                                doReset = true;\r\n                            }\r\n                        } else {\r\n                            currentIterator.reset();\r\n                        }\r\n                    }\r\n\r\n                }\r\n                // check if one of them is empty and immediate return\r\n                if (someIteratorsEmpty) {\r\n                    throw new NoMatchesFoundException();\r\n                    // \"some of tables do not have facts\");\r\n                }\r\n                // iterating is done in nested loop\r\n                // column position in the nested loop\r\n                int jj = 0;\r\n                boolean done = false;\r\n                while (!done) {\r\n                    currentIterator = iterators[jj];\r\n                    if (!currentIterator.hasNext()) {\r\n                        if (jj == 0) {\r\n                            done = true;\r\n                        } else {\r\n                            //                    \r\n                            currentIterator.reset();\r\n                            token.set(jj, (FactHandleImpl) null);\r\n                            jj = jj - 1;\r\n                            if (skip) {\r\n                                skip = false;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        currentIterator.next();\r\n                        token.set(jj, (FactHandleImpl) iterators[jj].current());\r\n                        // check if match found\r\n                        // we need to check only beta for dominant fact\r\n                        // alpha was already checked\r\n                        boolean localMatch = false;\r\n                        if (jj == 0 && jj != dominantFactPosition) {\r\n                            localMatch = leapsRule\r\n                                    .getColumnConstraintsAtPosition(jj)\r\n                                    .isAllowed(token.get(jj), token, workingMemory);\r\n                        } else {\r\n                            localMatch = leapsRule\r\n                                    .getColumnConstraintsAtPosition(jj)\r\n                                    .isAllowedBeta(token.get(jj), token, workingMemory);\r\n                        }\r\n\r\n                        if (localMatch) {\r\n                            // start iteratating next iterator\r\n                            // or for the last one check negative conditions and\r\n                            // fire\r\n                            // consequence\r\n                            if (jj == (numberOfColumns - 1)) {\r\n                                if (!skip) {\r\n                                    if (processAfterAllPositiveConstraintOk(\r\n                                            token, leapsRule, workingMemory)) {\r\n                                        return;\r\n                                    }\r\n                                } else {\r\n                                    skip = false;\r\n                                }\r\n                            } else {\r\n                                jj = jj + 1;\r\n                            }\r\n                        } else {\r\n                            if (skip) {\r\n                                skip = false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (processAfterAllPositiveConstraintOk(token, leapsRule,\r\n                    workingMemory)) {\r\n                return;\r\n            }\r\n        }\r\n        // nothing was found. inform caller about it\r\n        throw new NoMatchesFoundException();\r\n    }","id":44452,"modified_method":"/**\r\n     * this method does nested loops iterations on all relavant fact tables and\r\n     * evaluates rules conditions\r\n     * \r\n     * @param token\r\n     * @throws NoMatchesFoundException\r\n     * @throws Exception\r\n     * @throws InvalidRuleException\r\n     */\r\n    final static protected void evaluate(Token token) throws NoMatchesFoundException,\r\n            InvalidRuleException {\r\n        WorkingMemoryImpl workingMemory = (WorkingMemoryImpl) token.getWorkingMemory();\r\n        LeapsRule leapsRule = token.getCurrentRuleHandle().getLeapsRule();\r\n        // sometimes there is no normal conditions, only not and exists\r\n        int numberOfColumns = leapsRule.getNumberOfColumns();\r\n        if (numberOfColumns > 0) {\r\n            int dominantFactPosition = token.getCurrentRuleHandle().getDominantPosition();\r\n            FactHandleImpl dominantFactHandle = token.getDominantFactHandle();\r\n            if (leapsRule.getColumnConstraintsAtPosition(dominantFactPosition)\r\n                    .isAllowedAlpha(dominantFactHandle, token, workingMemory)) {\r\n                Class dominantClass = leapsRule\r\n                        .getColumnClassObjectTypeAtPosition(dominantFactPosition);\r\n                TableIterator[] iterators = new TableIterator[numberOfColumns];\r\n                // getting iterators first\r\n                for (int i = 0; i < numberOfColumns; i++) {\r\n                    if (i == dominantFactPosition) {\r\n                        iterators[i] = Table.singleItemIterator(dominantFactHandle);\r\n                    }\r\n                    else {\r\n                        Class columnClass = leapsRule.getColumnClassObjectTypeAtPosition(i);\r\n                        ColumnConstraints constraints = leapsRule\r\n                                .getColumnConstraintsAtPosition(i);\r\n                        FactTable factTable = workingMemory.getFactTable(columnClass);\r\n                        // JBRULES-189\r\n                        FactHandleImpl startFactHandle = (dominantClass == columnClass) ? new FactHandleImpl(\r\n                                dominantFactHandle.getId() - 1, null)\r\n                                : dominantFactHandle;\r\n                        //\r\n                        if (i > 0 && constraints.isAlphaPresent()) {\r\n                            iterators[i] = factTable.tailConstrainedIterator(workingMemory,\r\n                                    constraints, startFactHandle,\r\n                                    (token.isResume() ? (FactHandleImpl) token.get(i)\r\n                                            : startFactHandle));\r\n                        }\r\n                        else {\r\n                            iterators[i] = factTable.tailIterator(startFactHandle, (token\r\n                                    .isResume() ? (FactHandleImpl) token.get(i)\r\n                                    : startFactHandle));\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // check if any iterators are empty to abort\r\n                // check if we resume and any starting facts disappeared than we\r\n                // do not do skip on resume\r\n                boolean doReset = false;\r\n                boolean skip = token.isResume();\r\n                TableIterator currentIterator;\r\n                for (int i = 0; i < numberOfColumns; i++) {\r\n                    currentIterator = iterators[i];\r\n                    // check if one of them is empty and immediate return\r\n                    if (currentIterator.isEmpty()) {\r\n                        throw new NoMatchesFoundException();\r\n                    }\r\n                    else {\r\n                        if (!doReset) {\r\n                            if (skip && currentIterator.hasNext()\r\n                                    && !currentIterator.peekNext().equals(token.get(i))) {\r\n                                // we tried to resume but our fact handle at marker disappear\r\n                                // no need to resume just reset all interators positioned\r\n                                // at the marker where we stoped last time\r\n                                skip = false;\r\n                                doReset = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            currentIterator.reset();\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // iterating is done in nested loop\r\n                // column position in the nested loop\r\n                int jj = 0;\r\n                boolean done = false;\r\n                int stopIteratingCount = numberOfColumns - 1; \r\n                while (!done) {\r\n                    currentIterator = iterators[jj];\r\n                    if (!currentIterator.hasNext()) {\r\n                        if (jj == 0) {\r\n                            done = true;\r\n                        }\r\n                        else {\r\n                            // nothing for this column, go back and check next \r\n                            // on the one level up in nested loop\r\n                            currentIterator.reset();\r\n                            jj = jj - 1;\r\n                            if (skip) {\r\n                                skip = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        FactHandleImpl currentFactHandle = (FactHandleImpl) currentIterator\r\n                                .next();\r\n                        // check if match found we need to check only beta for\r\n                        // dominant fact\r\n                        // alpha was already checked\r\n                        boolean localMatch = false;\r\n                        if (!skip) {\r\n                            if (jj != 0 || jj == dominantFactPosition) {\r\n                                localMatch = leapsRule.getColumnConstraintsAtPosition(jj)\r\n                                        .isAllowedBeta(currentFactHandle, token,\r\n                                                workingMemory);\r\n                            }\r\n                            else {\r\n                                localMatch = leapsRule.getColumnConstraintsAtPosition(jj)\r\n                                        .isAllowed(currentFactHandle, token, workingMemory);\r\n                            }\r\n                        }\r\n                        if (localMatch || skip) {\r\n                            token.set(jj, currentFactHandle);\r\n                            // start iteratating next iterator or for the last\r\n                            // one check negative conditions and fire consequence\r\n                            if (jj == stopIteratingCount) {\r\n                                if (!skip) {\r\n                                    if (processAfterAllPositiveConstraintOk(token,\r\n                                            leapsRule, workingMemory)) {\r\n                                        return;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    skip = false;\r\n                                }\r\n                            }\r\n                            else {\r\n                                jj = jj + 1;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (processAfterAllPositiveConstraintOk(token, leapsRule, workingMemory)) {\r\n                return;\r\n            }\r\n        }\r\n        // nothing was found. inform caller about it\r\n        throw new NoMatchesFoundException();\r\n    }","commit_id":"414d68eda720ee7eabca44b1a1810f996c4b3adb","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Makes final check on eval, exists and not conditions after all column\r\n     * values isAllowed by column constraints\r\n     * \r\n     * @param token\r\n     * @param leapsRule\r\n     * @param workingMemory\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n    final static boolean processAfterAllPositiveConstraintOk(Token token,\r\n            LeapsRule leapsRule, WorkingMemoryImpl workingMemory) {\r\n        LeapsTuple tuple = token.getTuple();\r\n        if (leapsRule.containsEvalConditions()) {\r\n            if (!TokenEvaluator.evaluateEvalConditions(leapsRule, tuple,\r\n                    workingMemory)) {\r\n                return false;\r\n            }\r\n        }\r\n        if (leapsRule.containsExistsColumns()) {\r\n            TokenEvaluator.evaluateExistsConditions(tuple, leapsRule,\r\n                    workingMemory);\r\n        }\r\n        if (leapsRule.containsNotColumns()) {\r\n            TokenEvaluator.evaluateNotConditions(tuple, leapsRule,\r\n                    workingMemory);\r\n        }\r\n        //\r\n        Class[] classes = leapsRule.getExistsNotColumnsClasses();\r\n        for (int i = 0, length = classes.length; i < length; i++) {\r\n            workingMemory.getFactTable(classes[i]).addTuple(tuple);\r\n        }\r\n\r\n        // \r\n        if (tuple.isReadyForActivation()) {\r\n            // let agenda to do its work\r\n            workingMemory.assertTuple(tuple);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }","id":44453,"modified_method":"/**\r\n     * Makes final check on eval, exists and not conditions after all column\r\n     * values isAllowed by column constraints\r\n     * \r\n     * @param token\r\n     * @param leapsRule\r\n     * @param workingMemory\r\n     * @return\r\n     * @throws Exception\r\n     */\r\n    final static boolean processAfterAllPositiveConstraintOk(Token token,\r\n            LeapsRule leapsRule, WorkingMemoryImpl workingMemory) {\r\n        LeapsTuple tuple = token.getTuple();\r\n        if (leapsRule.containsEvalConditions()\r\n                && !TokenEvaluator.evaluateEvalConditions(leapsRule, tuple, workingMemory)) {\r\n            return false;\r\n        }\r\n        if (leapsRule.containsExistsColumns()) {\r\n            TokenEvaluator.evaluateExistsConditions(tuple, leapsRule, workingMemory);\r\n        }\r\n        if (leapsRule.containsNotColumns()) {\r\n            TokenEvaluator.evaluateNotConditions(tuple, leapsRule, workingMemory);\r\n        }\r\n        //\r\n        Class[] classes = leapsRule.getExistsNotColumnsClasses();\r\n        for (int i = 0, length = classes.length; i < length; i++) {\r\n            workingMemory.getFactTable(classes[i]).addTuple(tuple);\r\n        }\r\n\r\n        // \r\n        if (tuple.isReadyForActivation()) {\r\n            // let agenda to do its work\r\n            workingMemory.assertTuple(tuple);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }","commit_id":"414d68eda720ee7eabca44b1a1810f996c4b3adb","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Add rule\r\n     * \r\n     * @param workingMemory\r\n     * @param ruleHandle\r\n     */\r\n    public void addRule(WorkingMemoryImpl workingMemory, RuleHandle ruleHandle) {\r\n        this.rules.add(ruleHandle);\r\n        // push facts back to stack if needed\r\n        this.checkAndAddFactsToStack(workingMemory);\r\n    }","id":44454,"modified_method":"/**\r\n     * Add rule\r\n     * \r\n     * @param workingMemory\r\n     * @param ruleHandle\r\n     */\r\n    public void addRule(WorkingMemoryImpl workingMemory, RuleHandle ruleHandle) {\r\n        if (!this.rules.contains(ruleHandle)) {\r\n            this.rules.add(ruleHandle);\r\n            // push facts back to stack if needed\r\n            this.checkAndAddFactsToStack(workingMemory);\r\n        }\r\n    }","commit_id":"97e09f1c35fe4e3cbcae34d9ee55234ea36e3749","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * this method does nested loops iterations on all relavant fact tables and\r\n     * evaluates rules conditions\r\n     * \r\n     * @param token\r\n     * @throws NoMatchesFoundException\r\n     * @throws Exception\r\n     * @throws InvalidRuleException\r\n     */\r\n    final static protected void evaluate(Token token)\r\n            throws NoMatchesFoundException, InvalidRuleException {\r\n        WorkingMemoryImpl workingMemory = (WorkingMemoryImpl) token\r\n                .getWorkingMemory();\r\n        LeapsRule leapsRule = token.getCurrentRuleHandle().getLeapsRule();\r\n        // sometimes there is no normal conditions, only not and exists\r\n        int numberOfColumns = leapsRule.getNumberOfColumns();\r\n        if (numberOfColumns > 0) {\r\n            int dominantFactPosition = token.getCurrentRuleHandle()\r\n                    .getDominantPosition();\r\n            if (leapsRule.getColumnConstraintsAtPosition(dominantFactPosition)\r\n                    .isAllowedAlpha(token.getDominantFactHandle(), token,\r\n                            workingMemory)) {\r\n                TableIterator[] iterators = new TableIterator[numberOfColumns];\r\n                // getting iterators first\r\n                for (int i = 0; i < numberOfColumns; i++) {\r\n                    if (i == dominantFactPosition) {\r\n                        iterators[i] = Table.singleItemIterator(token\r\n                                .getDominantFactHandle());\r\n                    } else {\r\n                        if (i > 0\r\n                                && leapsRule.getColumnConstraintsAtPosition(i)\r\n                                        .isAlphaPresent()) {\r\n                            iterators[i] = workingMemory\r\n                                    .getFactTable(\r\n                                            leapsRule\r\n                                                    .getColumnClassObjectTypeAtPosition(i))\r\n                                    .tailConstrainedIterator(\r\n                                            workingMemory,\r\n                                            leapsRule\r\n                                                    .getColumnConstraintsAtPosition(i),\r\n                                            token.getDominantFactHandle(),\r\n                                            (token.isResume() ? token.get(i)\r\n                                                    : token\r\n                                                            .getDominantFactHandle()));\r\n                        } else {\r\n                            iterators[i] = workingMemory\r\n                                    .getFactTable(\r\n                                            leapsRule\r\n                                                    .getColumnClassObjectTypeAtPosition(i))\r\n                                    .tailIterator(\r\n                                            token.getDominantFactHandle(),\r\n                                            (token.isResume() ? token.get(i)\r\n                                                    : token\r\n                                                            .getDominantFactHandle()));\r\n                        }\r\n                    }\r\n                }\r\n                // check if any iterators are empty to abort\r\n                // check if we resume and any starting facts disappeared than we\r\n                // do\r\n                // not do skip on resume\r\n                boolean someIteratorsEmpty = false;\r\n                boolean doReset = false;\r\n                boolean skip = token.isResume();\r\n                TableIterator currentIterator;\r\n                for (int i = 0; i < numberOfColumns && !someIteratorsEmpty; i++) {\r\n                    currentIterator = iterators[i];\r\n                    if (currentIterator.isEmpty()) {\r\n                        someIteratorsEmpty = true;\r\n                    } else {\r\n                        if (!doReset) {\r\n                            if (skip\r\n                                    && currentIterator.hasNext()\r\n                                    && !currentIterator.peekNext().equals(\r\n                                            token.get(i))) {\r\n                                skip = false;\r\n                                doReset = true;\r\n                            }\r\n                        } else {\r\n                            currentIterator.reset();\r\n                        }\r\n                    }\r\n\r\n                }\r\n                // check if one of them is empty and immediate return\r\n                if (someIteratorsEmpty) {\r\n                    throw new NoMatchesFoundException();\r\n                    // \"some of tables do not have facts\");\r\n                }\r\n                // iterating is done in nested loop\r\n                // column position in the nested loop\r\n                int jj = 0;\r\n                boolean done = false;\r\n                while (!done) {\r\n                    currentIterator = iterators[jj];\r\n                    if (!currentIterator.hasNext()) {\r\n                        if (jj == 0) {\r\n                            done = true;\r\n                        } else {\r\n                            //                    \r\n                            currentIterator.reset();\r\n                            token.set(jj, (FactHandleImpl) null);\r\n                            jj = jj - 1;\r\n                            if (skip) {\r\n                                skip = false;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        currentIterator.next();\r\n                        token.set(jj, (FactHandleImpl) iterators[jj].current());\r\n                        // check if match found\r\n                        // we need to check only beta for dominant fact\r\n                        // alpha was already checked\r\n                        boolean localMatch = false;\r\n                        if (jj == 0 && jj != dominantFactPosition) {\r\n                            localMatch = leapsRule\r\n                                    .getColumnConstraintsAtPosition(jj)\r\n                                    .isAllowed(token.get(jj), token,\r\n                                            workingMemory);\r\n                        } else {\r\n                            localMatch = leapsRule\r\n                                    .getColumnConstraintsAtPosition(jj)\r\n                                    .isAllowedBeta(token.get(jj), token,\r\n                                            workingMemory);\r\n                        }\r\n\r\n                        if (localMatch) {\r\n                            // start iteratating next iterator\r\n                            // or for the last one check negative conditions and\r\n                            // fire\r\n                            // consequence\r\n                            if (jj == (numberOfColumns - 1)) {\r\n                                if (!skip) {\r\n                                    if (processAfterAllPositiveConstraintOk(\r\n                                            token, leapsRule, workingMemory)) {\r\n                                        return;\r\n                                    }\r\n                                } else {\r\n                                    skip = false;\r\n                                }\r\n                            } else {\r\n                                jj = jj + 1;\r\n                            }\r\n                        } else {\r\n                            if (skip) {\r\n                                skip = false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (processAfterAllPositiveConstraintOk(token, leapsRule,\r\n                    workingMemory)) {\r\n                return;\r\n            }\r\n        }\r\n        // nothing was found. inform caller about it\r\n        throw new NoMatchesFoundException();\r\n    }","id":44455,"modified_method":"/**\r\n     * this method does nested loops iterations on all relavant fact tables and\r\n     * evaluates rules conditions\r\n     * \r\n     * @param token\r\n     * @throws NoMatchesFoundException\r\n     * @throws Exception\r\n     * @throws InvalidRuleException\r\n     */\r\n    final static protected void evaluate(Token token)\r\n            throws NoMatchesFoundException, InvalidRuleException {\r\n        WorkingMemoryImpl workingMemory = (WorkingMemoryImpl) token\r\n                .getWorkingMemory();\r\n        LeapsRule leapsRule = token.getCurrentRuleHandle().getLeapsRule();\r\n        // sometimes there is no normal conditions, only not and exists\r\n        int numberOfColumns = leapsRule.getNumberOfColumns();\r\n        if (numberOfColumns > 0) {\r\n            int dominantFactPosition = token.getCurrentRuleHandle()\r\n                    .getDominantPosition();\r\n            FactHandleImpl dominantFactHandle = token.getDominantFactHandle();\r\n            if (leapsRule.getColumnConstraintsAtPosition(dominantFactPosition)\r\n                    .isAllowedAlpha(dominantFactHandle, token, workingMemory)) {\r\n                FactHandleImpl interatorStartFactHandle;\r\n                FactTable factTable;\r\n                Class dominantClass = leapsRule.getColumnClassObjectTypeAtPosition(dominantFactPosition);\r\n                Class columnClass;\r\n                TableIterator[] iterators = new TableIterator[numberOfColumns];\r\n                // getting iterators first\r\n                for (int i = 0; i < numberOfColumns; i++) {\r\n                    if (i == dominantFactPosition) {\r\n                        iterators[i] = Table.singleItemIterator(dominantFactHandle);\r\n                    } else {\r\n                        columnClass = leapsRule.getColumnClassObjectTypeAtPosition(i);\r\n                        factTable = workingMemory.getFactTable(columnClass);\r\n                        interatorStartFactHandle = new FactHandleImpl(\r\n                                dominantFactHandle.getId()\r\n                                        - (dominantClass == columnClass ? 1 : 0),\r\n                                null); \r\n                        if (i > 0 && leapsRule.getColumnConstraintsAtPosition(i).isAlphaPresent()) {\r\n                            iterators[i] = factTable.tailConstrainedIterator(\r\n                                            workingMemory,\r\n                                            leapsRule.getColumnConstraintsAtPosition(i),\r\n                                            interatorStartFactHandle,\r\n                                            (token.isResume() ? (FactHandleImpl)token.get(i) \r\n                                                    : interatorStartFactHandle));\r\n                        } else {\r\n                            iterators[i] = factTable.tailIterator(\r\n                                    interatorStartFactHandle,\r\n                                            (token.isResume() ? (FactHandleImpl)token.get(i) \r\n                                                    : interatorStartFactHandle));\r\n                        }\r\n                    }\r\n                }\r\n                // check if any iterators are empty to abort\r\n                // check if we resume and any starting facts disappeared than we\r\n                // do\r\n                // not do skip on resume\r\n                boolean someIteratorsEmpty = false;\r\n                boolean doReset = false;\r\n                boolean skip = token.isResume();\r\n                TableIterator currentIterator;\r\n                for (int i = 0; i < numberOfColumns && !someIteratorsEmpty; i++) {\r\n                    currentIterator = iterators[i];\r\n                    if (currentIterator.isEmpty()) {\r\n                        someIteratorsEmpty = true;\r\n                    } else {\r\n                        if (!doReset) {\r\n                            if (skip && currentIterator.hasNext()\r\n                                    && !currentIterator.peekNext().equals(token.get(i))) {\r\n                                skip = false;\r\n                                doReset = true;\r\n                            }\r\n                        } else {\r\n                            currentIterator.reset();\r\n                        }\r\n                    }\r\n\r\n                }\r\n                // check if one of them is empty and immediate return\r\n                if (someIteratorsEmpty) {\r\n                    throw new NoMatchesFoundException();\r\n                    // \"some of tables do not have facts\");\r\n                }\r\n                // iterating is done in nested loop\r\n                // column position in the nested loop\r\n                int jj = 0;\r\n                boolean done = false;\r\n                while (!done) {\r\n                    currentIterator = iterators[jj];\r\n                    if (!currentIterator.hasNext()) {\r\n                        if (jj == 0) {\r\n                            done = true;\r\n                        } else {\r\n                            //                    \r\n                            currentIterator.reset();\r\n                            token.set(jj, (FactHandleImpl) null);\r\n                            jj = jj - 1;\r\n                            if (skip) {\r\n                                skip = false;\r\n                            }\r\n                        }\r\n                    } else {\r\n                        currentIterator.next();\r\n                        token.set(jj, (FactHandleImpl) iterators[jj].current());\r\n                        // check if match found\r\n                        // we need to check only beta for dominant fact\r\n                        // alpha was already checked\r\n                        boolean localMatch = false;\r\n                        if (jj == 0 && jj != dominantFactPosition) {\r\n                            localMatch = leapsRule\r\n                                    .getColumnConstraintsAtPosition(jj)\r\n                                    .isAllowed(token.get(jj), token, workingMemory);\r\n                        } else {\r\n                            localMatch = leapsRule\r\n                                    .getColumnConstraintsAtPosition(jj)\r\n                                    .isAllowedBeta(token.get(jj), token, workingMemory);\r\n                        }\r\n\r\n                        if (localMatch) {\r\n                            // start iteratating next iterator\r\n                            // or for the last one check negative conditions and\r\n                            // fire\r\n                            // consequence\r\n                            if (jj == (numberOfColumns - 1)) {\r\n                                if (!skip) {\r\n                                    if (processAfterAllPositiveConstraintOk(\r\n                                            token, leapsRule, workingMemory)) {\r\n                                        return;\r\n                                    }\r\n                                } else {\r\n                                    skip = false;\r\n                                }\r\n                            } else {\r\n                                jj = jj + 1;\r\n                            }\r\n                        } else {\r\n                            if (skip) {\r\n                                skip = false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            if (processAfterAllPositiveConstraintOk(token, leapsRule,\r\n                    workingMemory)) {\r\n                return;\r\n            }\r\n        }\r\n        // nothing was found. inform caller about it\r\n        throw new NoMatchesFoundException();\r\n    }","commit_id":"97e09f1c35fe4e3cbcae34d9ee55234ea36e3749","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * get leaps fact table of specific type (class)\r\n     * \r\n     * @param type\r\n     *            of objects\r\n     * @return fact table of requested class type\r\n     */\r\n    protected FactTable getFactTable(Class c) {\r\n        FactTable table;\r\n        if (this.factTables.containsKey(c)) {\r\n            table = (FactTable) this.factTables.get(c);\r\n        } else {\r\n            table = new FactTable(DefaultConflictResolver.getInstance());\r\n            this.factTables.put(c, table);\r\n        }\r\n\r\n        return table;\r\n    }","id":44456,"modified_method":"/**\r\n     * get leaps fact table of specific type (class)\r\n     * \r\n     * @param type\r\n     *            of objects\r\n     * @return fact table of requested class type\r\n     */\r\n    protected FactTable getFactTable(Class c) {\r\n        FactTable table;\r\n        if (this.factTables.containsKey(c)) {\r\n            table = (FactTable) this.factTables.get(c);\r\n        } else {\r\n            table = new FactTable(DefaultConflictResolver.getInstance());\r\n            this.factTables.put(c, table);\r\n            // review existing rules and assign to the fact table if needed\r\n            for (Iterator iter = this.leapsRulesToHandlesMap.keySet().iterator(); iter.hasNext();) {\r\n                LeapsRule leapsRule = (LeapsRule) iter.next();\r\n                if(leapsRule.getNumberOfColumns() > 0) {\r\n                    List rulesHandles = (List)this.leapsRulesToHandlesMap.get(leapsRule);\r\n                    for(Iterator handles = rulesHandles.iterator(); handles.hasNext();) {\r\n                        RuleHandle handle = (RuleHandle) handles.next();\r\n                        if (leapsRule.getColumnClassObjectTypeAtPosition(\r\n                                handle.getDominantPosition()).isAssignableFrom(\r\n                                c)) {\r\n                            table.addRule(this, handle);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n            }\r\n        }\r\n\r\n        return table;\r\n    }","commit_id":"97e09f1c35fe4e3cbcae34d9ee55234ea36e3749","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * generates or just return List of internal factTables that correspond a\r\n     * class can be used to generate factTables\r\n     * \r\n     * @return\r\n     */\r\n    protected List getFactTablesList(Class c) {\r\n        ArrayList list = new ArrayList();\r\n        Class bufClass = c;\r\n        while (bufClass != null) {\r\n            //\r\n            list.add(this.getFactTable(bufClass));\r\n            // and get the next class on the list\r\n            bufClass = bufClass.getSuperclass();\r\n        }\r\n        return list;\r\n    }","id":44457,"modified_method":"/**\r\n     * generates or just return List of internal factTables that correspond a\r\n     * class can be used to generate factTables\r\n     * \r\n     * @return\r\n     */\r\n    protected List getFactTablesList(Class c) {\r\n        ArrayList list = new ArrayList();\r\n        // interfaces\r\n        Class[] interfaces = c.getInterfaces();\r\n        for (int i = 0; i < interfaces.length; i++) {\r\n            list.add(this.getFactTable(interfaces[i]));\r\n        }\r\n        // classes\r\n        Class bufClass = c;\r\n        while (bufClass != null) {\r\n            //\r\n            list.add(this.getFactTable(bufClass));\r\n            // and get the next class on the list\r\n            bufClass = bufClass.getSuperclass();\r\n        }\r\n        return list;\r\n    }","commit_id":"97e09f1c35fe4e3cbcae34d9ee55234ea36e3749","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@NotNull\n    private TypeExpression setupReturnTypeTemplate(@NotNull TemplateBuilder builder, @NotNull JetNamedFunction func) {\n        JetTypeReference returnTypeRef = func.getReturnTypeRef();\n        assert returnTypeRef != null;\n        TypeExpression returnTypeExpression = new TypeExpression(returnType.getPossibleTypes());\n        builder.replaceElement(returnTypeRef, returnTypeExpression);\n        return returnTypeExpression;\n    }","id":44458,"modified_method":"@NotNull\n    private TypeExpression setupReturnTypeTemplate(@NotNull TemplateBuilder builder, @NotNull JetNamedFunction func) {\n        JetTypeReference returnTypeRef = func.getReturnTypeRef();\n        assert returnTypeRef != null;\n        TypeExpression returnTypeExpression = new TypeExpression(returnType);\n        builder.replaceElement(returnTypeRef, returnTypeExpression);\n        return returnTypeExpression;\n    }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n        assert file != null && file instanceof JetFile; // TODO: change some assertions to notifications\n        currentFile = (JetFile) file;\n        currentFileEditor = editor;\n\n        JetType[] possibleOwnerTypes = ownerType.getPossibleTypes();\n        assert possibleOwnerTypes.length > 0;\n        if (possibleOwnerTypes.length == 1) {\n            JetType ownerType = possibleOwnerTypes[0];\n            doInvoke(project, ownerType);\n        } else {\n            // class selection\n            List<String> options = new ArrayList<String>();\n            final Map<String, JetType> optionToTypeMap = new HashMap<String, JetType>();\n            for (JetType possibleOwnerType : possibleOwnerTypes) {\n                ClassifierDescriptor possibleClassDescriptor = possibleOwnerType.getConstructor().getDeclarationDescriptor();\n                if (possibleClassDescriptor != null) {\n                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());\n                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();\n                    assert namespaceDescriptor instanceof NamespaceDescriptor;\n                    String namespace = ((NamespaceDescriptor) namespaceDescriptor).getFqName().getFqName();\n                    String option = className + \" (\" + namespace + \")\";\n                    options.add(option);\n                    optionToTypeMap.put(option, possibleOwnerType);\n                }\n            }\n\n            final JList list = new JBList(options);\n            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();\n            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n            list.setCellRenderer(renderer);\n            PopupChooserBuilder builder = new PopupChooserBuilder(list);\n            renderer.installSpeedSearch(builder);\n\n            Runnable runnable = new Runnable() {\n                @Override\n                public void run() {\n                    int index = list.getSelectedIndex();\n                    if (index < 0) return;\n                    String option = (String) list.getSelectedValue();\n                    final JetType ownerType = optionToTypeMap.get(option);\n                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n                        @Override\n                        public void run() {\n                            doInvoke(project, ownerType);\n                        }\n                    }, getText(), null);\n                }\n            };\n\n            builder.setTitle(JetBundle.message(\"choose.target.class.or.trait.title\"))\n                   .setItemChoosenCallback(runnable)\n                   .createPopup()\n                   .showInBestPositionFor(currentFileEditor);\n        }\n    }","id":44459,"modified_method":"@Override\n    public void invoke(@NotNull final Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n        assert file != null && file instanceof JetFile; // TODO: change some assertions to notifications\n        currentFile = (JetFile) file;\n        currentFileEditor = editor;\n        currentFileContext = AnalyzerFacadeWithCache.analyzeFileWithCache(currentFile).getBindingContext();\n\n        ownerType.computeTypeCandidates(currentFileContext);\n        TypeCandidate[] ownerTypeCandidates = ownerType.getTypeCandidates();\n        assert ownerTypeCandidates.length > 0;\n        if (ownerTypeCandidates.length == 1) {\n            selectedReceiverType = ownerTypeCandidates[0];\n            doInvoke(project);\n        } else {\n            // class selection\n            List<String> options = new ArrayList<String>();\n            final Map<String, TypeCandidate> optionToTypeMap = new HashMap<String, TypeCandidate>();\n            for (TypeCandidate ownerTypeCandidate : ownerTypeCandidates) {\n                ClassifierDescriptor possibleClassDescriptor = ownerTypeCandidate.getType().getConstructor().getDeclarationDescriptor();\n                if (possibleClassDescriptor != null) {\n                    String className = DescriptorRenderer.SHORT_NAMES_IN_TYPES.renderType(possibleClassDescriptor.getDefaultType());\n                    DeclarationDescriptor namespaceDescriptor = possibleClassDescriptor.getContainingDeclaration();\n                    assert namespaceDescriptor instanceof NamespaceDescriptor;\n                    String namespace = ((NamespaceDescriptor) namespaceDescriptor).getFqName().getFqName();\n                    String option = className + \" (\" + namespace + \")\";\n                    options.add(option);\n                    optionToTypeMap.put(option, ownerTypeCandidate);\n                }\n            }\n\n            final JList list = new JBList(options);\n            PsiElementListCellRenderer renderer = new JetLightClassListCellRenderer();\n            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n            list.setCellRenderer(renderer);\n            PopupChooserBuilder builder = new PopupChooserBuilder(list);\n            renderer.installSpeedSearch(builder);\n\n            Runnable runnable = new Runnable() {\n                @Override\n                public void run() {\n                    int index = list.getSelectedIndex();\n                    if (index < 0) return;\n                    String option = (String) list.getSelectedValue();\n                    selectedReceiverType = optionToTypeMap.get(option);\n                    CommandProcessor.getInstance().executeCommand(project, new Runnable() {\n                        @Override\n                        public void run() {\n                            doInvoke(project);\n                        }\n                    }, getText(), null);\n                }\n            };\n\n            builder.setTitle(JetBundle.message(\"choose.target.class.or.trait.title\"))\n                   .setItemChoosenCallback(runnable)\n                   .createPopup()\n                   .showInBestPositionFor(currentFileEditor);\n        }\n    }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable(\"can't be found\")\n        public JetType getTypeFromSelection(@NotNull String selection) {\n            for (int i = 0; i < options.length; i++) {\n                if (optionStrings[i].equals(selection)) {\n                    return options[i];\n                }\n            }\n            return null;\n        }","id":44460,"modified_method":"@Nullable(\"can't be found\")\n        public JetType getTypeFromSelection(@NotNull String selection) {\n            TypeCandidate[] options = type.getTypeCandidates();\n            for (TypeCandidate option : options) {\n                if (option.getRenderedType().equals(selection)) {\n                    return option.getType();\n                }\n            }\n            return null;\n        }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n         * Returns a collection containing the possible types represented by this instance. Infers the type from an expression if necessary.\n         * @return A collection containing the possible types represented by this instance.\n         */\n        @NotNull\n        public JetType[] getPossibleTypes(@Nullable(\"use cached, don't recompute\") BindingContext context) {\n            if (context == null) {\n                assert cachedTypeCandidates != null;\n                return cachedTypeCandidates;\n            }\n            List<JetType> types = new ArrayList<JetType>();\n            if (isType()) {\n                assert type != null : \"!isType() means type == null && expressionOfType != null\";\n                types.add(type);\n                types.addAll(TypeUtils.getAllSupertypes(type));\n            } else {\n                assert expressionOfType != null : \"!isType() means type == null && expressionOfType != null\";\n                for (JetType type : guessTypeForExpression(expressionOfType, context)) {\n                    types.add(type);\n                    if (variance == Variance.IN_VARIANCE) {\n                        types.addAll(TypeUtils.getAllSupertypes(type));\n                    }\n                }\n            }\n\n            if (types.isEmpty()) {\n                types.add(KotlinBuiltIns.getInstance().getAnyType());\n            }\n\n            return cachedTypeCandidates = types.toArray(new JetType[types.size()]);\n        }","id":44461,"modified_method":"@NotNull\n        private Collection<JetType> getPossibleTypes(BindingContext context) {\n            Collection<JetType> types = new ArrayList<JetType>();\n            if (isType()) {\n                assert type != null : \"!isType() means type == null && expressionOfType != null\";\n                types.add(type);\n                types.addAll(TypeUtils.getAllSupertypes(type));\n            } else {\n                assert expressionOfType != null : \"!isType() means type == null && expressionOfType != null\";\n                for (JetType type : guessTypeForExpression(expressionOfType, context)) {\n                    types.add(type);\n                    if (variance == Variance.IN_VARIANCE) {\n                        types.addAll(TypeUtils.getAllSupertypes(type));\n                    }\n                }\n            }\n            return types;\n        }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void setupTypeReferencesForShortening(\n            @NotNull Project project,\n            @NotNull JetNamedFunction func,\n            @NotNull List<JetTypeReference> typeRefsToShorten,\n            @NotNull TypeExpression[] parameterTypeExpressions,\n            @Nullable TypeExpression returnTypeExpression\n    ) {\n        if (isExtension) {\n            JetTypeReference receiverTypeRef = JetPsiFactory.createType(project, renderTypeLong(receiverType));\n            replaceWithLongerName(project, receiverTypeRef, receiverType);\n\n            receiverTypeRef = func.getReceiverTypeRef();\n            assert receiverTypeRef != null;\n            typeRefsToShorten.add(receiverTypeRef);\n        }\n\n        if (!isUnit) {\n            assert returnTypeExpression != null;\n            JetTypeReference returnTypeRef = func.getReturnTypeRef();\n            assert returnTypeRef != null;\n            JetType returnType = returnTypeExpression.getTypeFromSelection(returnTypeRef.getText());\n            if (returnType != null) { // user selected a given type\n                replaceWithLongerName(project, returnTypeRef, returnType);\n                returnTypeRef = func.getReturnTypeRef();\n                assert returnTypeRef != null;\n                typeRefsToShorten.add(returnTypeRef);\n            }\n        }\n\n        List<JetParameter> valueParameters = func.getValueParameters();\n        List<Integer> parameterIndicesToShorten = new ArrayList<Integer>();\n        assert valueParameters.size() == parameterTypeExpressions.length;\n        for (int i = 0; i < valueParameters.size(); i++) {\n            JetParameter parameter = valueParameters.get(i);\n            JetTypeReference parameterTypeRef = parameter.getTypeReference();\n            assert parameterTypeRef != null;\n            JetType parameterType = parameterTypeExpressions[i].getTypeFromSelection(parameterTypeRef.getText());\n            if (parameterType != null) {\n                replaceWithLongerName(project, parameterTypeRef, parameterType);\n                parameterIndicesToShorten.add(i);\n            }\n        }\n        valueParameters = func.getValueParameters();\n        for (int i : parameterIndicesToShorten) {\n            JetTypeReference parameterTypeRef = valueParameters.get(i).getTypeReference();\n            assert parameterTypeRef != null;\n            typeRefsToShorten.add(parameterTypeRef);\n        }\n    }","id":44462,"modified_method":"private void setupTypeReferencesForShortening(\n            @NotNull Project project,\n            @NotNull JetNamedFunction func,\n            @NotNull List<JetTypeReference> typeRefsToShorten,\n            @NotNull TypeExpression[] parameterTypeExpressions,\n            @Nullable TypeExpression returnTypeExpression\n    ) {\n        if (isExtension) {\n            JetTypeReference receiverTypeRef =\n                    JetPsiFactory.createType(project, renderTypeLong(selectedReceiverType.getType(), typeParameterNameMap));\n            replaceWithLongerName(project, receiverTypeRef, selectedReceiverType.getType());\n\n            receiverTypeRef = func.getReceiverTypeRef();\n            assert receiverTypeRef != null;\n            typeRefsToShorten.add(receiverTypeRef);\n        }\n\n        if (!isUnit) {\n            assert returnTypeExpression != null;\n            JetTypeReference returnTypeRef = func.getReturnTypeRef();\n            assert returnTypeRef != null;\n            JetType returnType = returnTypeExpression.getTypeFromSelection(returnTypeRef.getText());\n            if (returnType != null) { // user selected a given type\n                replaceWithLongerName(project, returnTypeRef, returnType);\n                returnTypeRef = func.getReturnTypeRef();\n                assert returnTypeRef != null;\n                typeRefsToShorten.add(returnTypeRef);\n            }\n        }\n\n        List<JetParameter> valueParameters = func.getValueParameters();\n        List<Integer> parameterIndicesToShorten = new ArrayList<Integer>();\n        assert valueParameters.size() == parameterTypeExpressions.length;\n        for (int i = 0; i < valueParameters.size(); i++) {\n            JetParameter parameter = valueParameters.get(i);\n            JetTypeReference parameterTypeRef = parameter.getTypeReference();\n            assert parameterTypeRef != null;\n            JetType parameterType = parameterTypeExpressions[i].getTypeFromSelection(parameterTypeRef.getText());\n            if (parameterType != null) {\n                replaceWithLongerName(project, parameterTypeRef, parameterType);\n                parameterIndicesToShorten.add(i);\n            }\n        }\n        valueParameters = func.getValueParameters();\n        for (int i : parameterIndicesToShorten) {\n            JetTypeReference parameterTypeRef = valueParameters.get(i).getTypeReference();\n            assert parameterTypeRef != null;\n            typeRefsToShorten.add(parameterTypeRef);\n        }\n    }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public TypeParameterListExpression(@NotNull TypeParameterDescriptor[] typeParametersFromReceiverType,\n                @NotNull Map<String, TypeParameterDescriptor[]> typeParametersMap) {\n            this.typeParametersFromReceiverType = typeParametersFromReceiverType;\n            this.typeParameterMap = typeParametersMap;\n        }","id":44463,"modified_method":"public TypeParameterListExpression(\n                @NotNull String[] typeParameterNamesFromReceiverType,\n                @NotNull Map<String, String[]> typeParametersMap\n        ) {\n            this.typeParameterNamesFromReceiverType = typeParameterNamesFromReceiverType;\n            this.parameterTypeToTypeParameterNamesMap = typeParametersMap;\n        }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n        @Override\n        public Result calculateResult(ExpressionContext context) {\n            Project project = context.getProject();\n            int offset = context.getStartOffset();\n            PsiDocumentManager.getInstance(project).commitAllDocuments();\n            Editor editor = context.getEditor();\n            assert editor != null;\n            PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n            assert file != null && file instanceof JetFile;\n            PsiElement elementAt = file.findElementAt(offset);\n            JetFunction func = PsiTreeUtil.getParentOfType(elementAt, JetFunction.class);\n            assert func != null;\n            List<JetParameter> parameters = func.getValueParameters();\n\n            Set<TypeParameterDescriptor> typeParameters = new LinkedHashSet<TypeParameterDescriptor>();\n            Collections.addAll(typeParameters, typeParametersFromReceiverType);\n            for (JetParameter parameter : parameters) {\n                JetTypeReference parameterTypeRef = parameter.getTypeReference();\n                assert parameterTypeRef != null;\n                TypeParameterDescriptor[] typeParametersFromParameter = typeParameterMap.get(parameterTypeRef.getText());\n                if (typeParametersFromParameter != null) {\n                    Collections.addAll(typeParameters, typeParametersFromParameter);\n                }\n            }\n            JetTypeReference returnTypeRef = func.getReturnTypeRef();\n            if (returnTypeRef != null) {\n                TypeParameterDescriptor[] typeParametersFromReturnType = typeParameterMap.get(returnTypeRef.getText());\n                if (typeParametersFromReturnType != null) {\n                    Collections.addAll(typeParameters, typeParametersFromReturnType);\n                }\n            }\n\n            List<String> typeParameterNames = new ArrayList<String>();\n            for (TypeParameterDescriptor typeParameter : typeParameters) {\n                typeParameterNames.add(typeParameter.getName().getIdentifier());\n            }\n\n            // make sure there are no name conflicts\n            for (int i = 0; i < typeParameterNames.size(); i++) {\n                String name = typeParameterNames.get(i);\n                name = getNextAvailableName(name, typeParameterNames.subList(0, i));\n                typeParameterNames.set(i, name);\n            }\n\n            return typeParameterNames.isEmpty()\n                    ? new TextResult(\"\")\n                    : new TextResult(\" <\" + StringUtil.join(typeParameterNames, \", \") + \">\");\n        }","id":44464,"modified_method":"public TypeExpression(@NotNull TypeOrExpressionThereof type) {\n            this.type = type;\n            TypeCandidate[] candidates = type.getTypeCandidates();\n            cachedLookupElements = new LookupElement[candidates.length];\n            for (int i = 0; i < candidates.length; i++) {\n                cachedLookupElements[i] = LookupElementBuilder.create(candidates[i], candidates[i].getRenderedType());\n            }\n        }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void replaceWithLongerName(@NotNull Project project, @NotNull JetTypeReference typeRef, @NotNull JetType type) {\n        JetTypeReference fullyQualifiedReceiverTypeRef = JetPsiFactory.createType(project, renderTypeLong(type));\n        typeRef.replace(fullyQualifiedReceiverTypeRef);\n    }","id":44465,"modified_method":"private void replaceWithLongerName(@NotNull Project project, @NotNull JetTypeReference typeRef, @NotNull JetType type) {\n        JetTypeReference fullyQualifiedReceiverTypeRef = JetPsiFactory.createType(project, renderTypeLong(type, typeParameterNameMap));\n        typeRef.replace(fullyQualifiedReceiverTypeRef);\n    }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private TypeParameterListExpression setupTypeParameterListTemplate(\n            @NotNull TemplateBuilderImpl builder,\n            @NotNull JetNamedFunction func,\n            @NotNull TypeExpression[] parameterTypeExpressions,\n            @Nullable TypeExpression returnTypeExpression,\n            @NotNull JetScope scope\n    ) {\n        Map<String, TypeParameterDescriptor[]> typeParameterMap = new HashMap<String, TypeParameterDescriptor[]>();\n        Set<TypeParameterDescriptor> receiverTypeParameters = getTypeParametersInType(receiverType);\n        TypeParameterDescriptor[] receiverTypeParametersNotInScope = getTypeParameterNamesNotInScope(receiverTypeParameters, scope);\n        for (TypeExpression parameterTypeExpression : parameterTypeExpressions) {\n            JetType[] parameterTypeOptions = parameterTypeExpression.getOptions();\n            String[] parameterTypeOptionStrings = parameterTypeExpression.getOptionStrings();\n            assert parameterTypeOptions.length == parameterTypeOptionStrings.length;\n            for (int i = 0; i < parameterTypeOptions.length; i++) {\n                Set<TypeParameterDescriptor> typeParameters = getTypeParametersInType(parameterTypeOptions[i]);\n                typeParameterMap.put(parameterTypeOptionStrings[i], getTypeParameterNamesNotInScope(typeParameters, scope));\n            }\n        }\n\n        JetTypeReference returnTypeRef = func.getReturnTypeRef();\n        if (returnTypeRef != null) {\n            assert returnTypeExpression != null;\n            JetType[] returnTypeOptions = returnTypeExpression.getOptions();\n            String[] returnTypeOptionStrings = returnTypeExpression.getOptionStrings();\n            assert returnTypeOptions.length == returnTypeOptionStrings.length;\n            for (int i = 0; i < returnTypeOptions.length; i++) {\n                Set<TypeParameterDescriptor> typeParameters = getTypeParametersInType(returnTypeOptions[i]);\n                typeParameterMap.put(returnTypeOptionStrings[i], getTypeParameterNamesNotInScope(typeParameters, scope));\n            }\n        }\n\n        builder.replaceElement(func, TextRange.create(3, 3), TYPE_PARAMETER_LIST_VARIABLE_NAME, null, false); // ((3, 3) is after \"fun\")\n        return new TypeParameterListExpression(receiverTypeParametersNotInScope, typeParameterMap);\n    }","id":44466,"modified_method":"@NotNull\n    private TypeParameterListExpression setupTypeParameterListTemplate(@NotNull TemplateBuilderImpl builder, @NotNull JetNamedFunction func) {\n        Map<String, String[]> typeParameterMap = new HashMap<String, String[]>();\n        String[] receiverTypeParameterNames = selectedReceiverType.getTypeParameterNames();\n\n        for (Parameter parameter : parameters) {\n            TypeCandidate[] parameterTypeCandidates = parameter.getType().getTypeCandidates();\n            for (TypeCandidate parameterTypeCandidate : parameterTypeCandidates) {\n                typeParameterMap.put(parameterTypeCandidate.getRenderedType(), parameterTypeCandidate.getTypeParameterNames());\n            }\n        }\n\n        JetTypeReference returnTypeRef = func.getReturnTypeRef();\n        if (returnTypeRef != null) {\n            TypeCandidate[] returnTypeCandidates = returnType.getTypeCandidates();\n            for (TypeCandidate returnTypeCandidate : returnTypeCandidates) {\n                typeParameterMap.put(returnTypeCandidate.getRenderedType(), returnTypeCandidate.getTypeParameterNames());\n            }\n        }\n\n        builder.replaceElement(func, TextRange.create(3, 3), TYPE_PARAMETER_LIST_VARIABLE_NAME, null, false); // ((3, 3) is after \"fun\")\n        return new TypeParameterListExpression(receiverTypeParameterNames, typeParameterMap);\n    }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void doInvoke(@NotNull final Project project, @NotNull JetType ownerType) {\n        // gather relevant information\n        ClassifierDescriptor ownerTypeDescriptor = ownerType.getConstructor().getDeclarationDescriptor();\n        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;\n        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;\n        receiverType = ownerClassDescriptor.getDefaultType();\n        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);\n        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {\n            ownerClass = (JetClass) typeDeclaration;\n            isExtension = !ownerClass.isWritable();\n        } else {\n            isExtension = true;\n        }\n        isUnit = returnType.isType() && isUnit(returnType.getType());\n\n        // figure out type substitutions for type parameters\n        List<TypeProjection> classTypeParameters = receiverType.getArguments();\n        List<TypeProjection> ownerTypeArguments = ownerType.getArguments();\n        assert ownerTypeArguments.size() == classTypeParameters.size();\n        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];\n        for (int i = 0; i < substitutions.length; i++) {\n            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());\n        }\n        returnType.substitute(substitutions);\n        for (Parameter parameter : parameters) {\n            parameter.getType().substitute(substitutions);\n        }\n\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            @Override\n            public void run() {\n                JetNamedFunction func = createFunctionSkeleton(project);\n                buildAndRunTemplate(project, func);\n            }\n        });\n    }","id":44467,"modified_method":"private void doInvoke(@NotNull final Project project) {\n        // gather relevant information\n        ClassifierDescriptor ownerTypeDescriptor = selectedReceiverType.getType().getConstructor().getDeclarationDescriptor();\n        assert ownerTypeDescriptor != null && ownerTypeDescriptor instanceof ClassDescriptor;\n        ownerClassDescriptor = (ClassDescriptor) ownerTypeDescriptor;\n        JetType receiverType = ownerClassDescriptor.getDefaultType();\n        PsiElement typeDeclaration = BindingContextUtils.classDescriptorToDeclaration(currentFileContext, ownerClassDescriptor);\n        if (typeDeclaration != null && typeDeclaration instanceof JetClass) {\n            ownerClass = (JetClass) typeDeclaration;\n            isExtension = !ownerClass.isWritable();\n        } else {\n            isExtension = true;\n        }\n        isUnit = returnType.isType() && isUnit(returnType.getType());\n\n        JetScope scope;\n        if (isExtension) {\n            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, containingFile);\n            assert namespaceDescriptor != null;\n            scope = namespaceDescriptor.getMemberScope();\n        } else {\n            assert ownerClassDescriptor instanceof MutableClassDescriptor;\n            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();\n        }\n\n        // figure out type substitutions for type parameters\n        List<TypeProjection> classTypeParameters = receiverType.getArguments();\n        List<TypeProjection> ownerTypeArguments = selectedReceiverType.getType().getArguments();\n        assert ownerTypeArguments.size() == classTypeParameters.size();\n        TypeSubstitution[] substitutions = new TypeSubstitution[classTypeParameters.size()];\n        for (int i = 0; i < substitutions.length; i++) {\n            substitutions[i] = new TypeSubstitution(ownerTypeArguments.get(i).getType(), classTypeParameters.get(i).getType());\n        }\n        for (Parameter parameter : parameters) {\n            parameter.getType().computeTypeCandidates(currentFileContext, substitutions, scope);\n        }\n        if (!isUnit) {\n            returnType.computeTypeCandidates(currentFileContext, substitutions, scope);\n        }\n\n        // figure out type parameter renames to avoid conflicts\n        typeParameterNameMap = getTypeParameterRenames(scope);\n        for (Parameter parameter : parameters) {\n            parameter.getType().renderTypeCandidates(typeParameterNameMap);\n        }\n        if (!isUnit) {\n            returnType.renderTypeCandidates(typeParameterNameMap);\n        }\n        if (isExtension) {\n            ownerType.renderTypeCandidates(typeParameterNameMap);\n        }\n\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n            @Override\n            public void run() {\n                JetNamedFunction func = createFunctionSkeleton(project);\n                buildAndRunTemplate(project, func);\n            }\n        });\n    }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void buildAndRunTemplate(@NotNull final Project project, @NotNull JetNamedFunction func) {\n        JetParameterList parameterList = func.getValueParameterList();\n        assert parameterList != null;\n\n        JetScope scope;\n        if (isExtension) {\n            NamespaceDescriptor namespaceDescriptor = currentFileContext.get(BindingContext.FILE_TO_NAMESPACE, containingFile);\n            assert namespaceDescriptor != null;\n            scope = namespaceDescriptor.getMemberScope();\n        } else {\n            assert ownerClassDescriptor instanceof MutableClassDescriptor;\n            scope = ((MutableClassDescriptor) ownerClassDescriptor).getScopeForMemberResolution();\n        }\n\n        // build templates\n        PsiDocumentManager.getInstance(project).commitAllDocuments();\n        PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(containingFileEditor.getDocument());\n\n        CaretModel caretModel = containingFileEditor.getCaretModel();\n        caretModel.moveToOffset(containingFile.getNode().getStartOffset());\n\n        TemplateBuilderImpl builder = new TemplateBuilderImpl(containingFile);\n        final TypeExpression returnTypeExpression = isUnit ? null : setupReturnTypeTemplate(builder, func);\n        final TypeExpression[] parameterTypeExpressions = setupParameterTypeTemplates(project, builder, parameterList);\n\n        // add a segment for the parameter list\n        // Note: because TemplateBuilderImpl does not have a replaceElement overload that takes in both a TextRange and alwaysStopAt, we\n        // need to create the segment first and then hack the Expression into the template later. We use this template to update the type\n        // parameter list as the user makes selections in the parameter types, and we need alwaysStopAt to be false so the user can't tab to\n        // it.\n        TypeParameterListExpression expression =\n                setupTypeParameterListTemplate(builder, func, parameterTypeExpressions, returnTypeExpression, scope);\n\n        // the template built by TemplateBuilderImpl is ordered by element position, but we want types to be first, so hack it\n        final TemplateImpl template = (TemplateImpl) builder.buildInlineTemplate();\n        ArrayList<Variable> variables = template.getVariables();\n        for (int i = 0; i < parameters.size(); i++) {\n            Collections.swap(variables, i * 2, i * 2 + 1);\n        }\n\n        // fix up the template to include the expression for the type parameter list\n        variables.add(new Variable(TYPE_PARAMETER_LIST_VARIABLE_NAME, expression, expression, false, true));\n\n        // run the template\n        TemplateManager.getInstance(project).startTemplate(containingFileEditor, template, new TemplateEditingAdapter() {\n            @Override\n            public void templateFinished(Template _, boolean brokenOff) {\n                // file templates\n                int offset = template.getSegmentOffset(0);\n                final JetNamedFunction func = PsiTreeUtil.findElementOfClassAtOffset(containingFile, offset, JetNamedFunction.class, false);\n                assert func != null;\n                final List<JetTypeReference> typeRefsToShorten = new ArrayList<JetTypeReference>();\n\n                ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                    @Override\n                    public void run() {\n                        // file templates\n                        setupFunctionBody(project, func);\n\n                        // change short type names to fully qualified ones (to be shortened below)\n                        setupTypeReferencesForShortening(project, func, typeRefsToShorten, parameterTypeExpressions, returnTypeExpression);\n                    }\n                });\n\n                ReferenceToClassesShortening.compactReferenceToClasses(typeRefsToShorten);\n            }\n        });\n    }","id":44468,"modified_method":"private void buildAndRunTemplate(@NotNull final Project project, @NotNull JetNamedFunction func) {\n        JetParameterList parameterList = func.getValueParameterList();\n        assert parameterList != null;\n\n        // build templates\n        PsiDocumentManager.getInstance(project).commitAllDocuments();\n        PsiDocumentManager.getInstance(project).doPostponedOperationsAndUnblockDocument(containingFileEditor.getDocument());\n\n        CaretModel caretModel = containingFileEditor.getCaretModel();\n        caretModel.moveToOffset(containingFile.getNode().getStartOffset());\n\n        TemplateBuilderImpl builder = new TemplateBuilderImpl(containingFile);\n        final TypeExpression returnTypeExpression = isUnit ? null : setupReturnTypeTemplate(builder, func);\n        final TypeExpression[] parameterTypeExpressions = setupParameterTypeTemplates(project, builder, parameterList);\n\n        // add a segment for the parameter list\n        // Note: because TemplateBuilderImpl does not have a replaceElement overload that takes in both a TextRange and alwaysStopAt, we\n        // need to create the segment first and then hack the Expression into the template later. We use this template to update the type\n        // parameter list as the user makes selections in the parameter types, and we need alwaysStopAt to be false so the user can't tab to\n        // it.\n        TypeParameterListExpression expression = setupTypeParameterListTemplate(builder, func);\n\n        // the template built by TemplateBuilderImpl is ordered by element position, but we want types to be first, so hack it\n        final TemplateImpl template = (TemplateImpl) builder.buildInlineTemplate();\n        ArrayList<Variable> variables = template.getVariables();\n        for (int i = 0; i < parameters.size(); i++) {\n            Collections.swap(variables, i * 2, i * 2 + 1);\n        }\n\n        // fix up the template to include the expression for the type parameter list\n        variables.add(new Variable(TYPE_PARAMETER_LIST_VARIABLE_NAME, expression, expression, false, true));\n\n        // run the template\n        TemplateManager.getInstance(project).startTemplate(containingFileEditor, template, new TemplateEditingAdapter() {\n            @Override\n            public void templateFinished(Template _, boolean brokenOff) {\n                // file templates\n                int offset = template.getSegmentOffset(0);\n                final JetNamedFunction func = PsiTreeUtil.findElementOfClassAtOffset(containingFile, offset, JetNamedFunction.class, false);\n                assert func != null;\n                final List<JetTypeReference> typeRefsToShorten = new ArrayList<JetTypeReference>();\n\n                ApplicationManager.getApplication().runWriteAction(new Runnable() {\n                    @Override\n                    public void run() {\n                        // file templates\n                        setupFunctionBody(project, func);\n\n                        // change short type names to fully qualified ones (to be shortened below)\n                        setupTypeReferencesForShortening(project, func, typeRefsToShorten, parameterTypeExpressions, returnTypeExpression);\n                    }\n                });\n\n                ReferenceToClassesShortening.compactReferenceToClasses(typeRefsToShorten);\n            }\n        });\n    }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {\n        JetNamedFunction func;\n        String[] parameterStrings = new String[parameters.size()];\n        for (int i = 0; i < parameterStrings.length; i++) {\n            parameterStrings[i] = \"p\" + i + \": Any\";\n        }\n        String parametersString = StringUtil.join(parameterStrings,\", \");\n        String returnTypeString = isUnit ? \"\" : \": Any\";\n        if (isExtension) { // create as extension function\n            String ownerTypeString = renderTypeShort(receiverType);\n            String methodText = String.format(\"fun %s.%s(%s)%s { }\", ownerTypeString, methodName, parametersString, returnTypeString);\n            func = JetPsiFactory.createFunction(project, methodText);\n            containingFile = currentFile;\n            containingFileEditor = currentFileEditor;\n            func = (JetNamedFunction) currentFile.add(func);\n        } else { // create as method\n            String methodText = String.format(\"fun %s(%s)%s { }\", methodName, parametersString, returnTypeString);\n            func = JetPsiFactory.createFunction(project, methodText);\n            PsiFile classContainingFile = ownerClass.getContainingFile();\n            assert classContainingFile instanceof JetFile;\n            containingFile = (JetFile) classContainingFile;\n\n            VirtualFile virtualFile = containingFile.getVirtualFile();\n            assert virtualFile != null;\n            FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);\n            fileEditorManager.openFile(virtualFile, true);\n            containingFileEditor = fileEditorManager.getSelectedTextEditor();\n\n            JetClassBody classBody = ownerClass.getBody();\n            assert classBody != null;\n            PsiElement rBrace = classBody.getRBrace();\n            assert rBrace != null;\n            func = (JetNamedFunction) classBody.addBefore(func, rBrace);\n        }\n\n        return func;\n    }","id":44469,"modified_method":"private JetNamedFunction createFunctionSkeleton(@NotNull Project project) {\n        JetNamedFunction func;\n        String[] parameterStrings = new String[parameters.size()];\n        for (int i = 0; i < parameterStrings.length; i++) {\n            parameterStrings[i] = \"p\" + i + \": Any\";\n        }\n        String parametersString = StringUtil.join(parameterStrings,\", \");\n        String returnTypeString = isUnit ? \"\" : \": Any\";\n        if (isExtension) { // create as extension function\n            String ownerTypeString = selectedReceiverType.getRenderedType();\n            String methodText = String.format(\"fun %s.%s(%s)%s { }\", ownerTypeString, methodName, parametersString, returnTypeString);\n            func = JetPsiFactory.createFunction(project, methodText);\n            containingFile = currentFile;\n            containingFileEditor = currentFileEditor;\n            func = (JetNamedFunction) currentFile.add(func);\n        } else { // create as method\n            String methodText = String.format(\"fun %s(%s)%s { }\", methodName, parametersString, returnTypeString);\n            func = JetPsiFactory.createFunction(project, methodText);\n            PsiFile classContainingFile = ownerClass.getContainingFile();\n            assert classContainingFile instanceof JetFile;\n            containingFile = (JetFile) classContainingFile;\n\n            VirtualFile virtualFile = containingFile.getVirtualFile();\n            assert virtualFile != null;\n            FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);\n            fileEditorManager.openFile(virtualFile, true);\n            containingFileEditor = fileEditorManager.getSelectedTextEditor();\n\n            JetClassBody classBody = ownerClass.getBody();\n            assert classBody != null;\n            PsiElement rBrace = classBody.getRBrace();\n            assert rBrace != null;\n            func = (JetNamedFunction) classBody.addBefore(func, rBrace);\n        }\n\n        return func;\n    }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private TypeExpression[] setupParameterTypeTemplates(@NotNull Project project, @NotNull TemplateBuilder builder,\n            @NotNull JetParameterList parameterList) {\n        List<JetParameter> jetParameters = parameterList.getParameters();\n        assert jetParameters.size() == parameters.size();\n        TypeExpression[] parameterTypeExpressions = new TypeExpression[parameters.size()];\n        for (int i = 0; i < parameters.size(); i++) {\n            Parameter parameter = parameters.get(i);\n            JetParameter jetParameter = jetParameters.get(i);\n\n            // add parameter type to the template\n            JetType[] typeOptions = parameter.getType().getPossibleTypes();\n            parameterTypeExpressions[i] = new TypeExpression(typeOptions);\n            JetTypeReference parameterTypeRef = jetParameter.getTypeReference();\n            assert parameterTypeRef != null;\n            builder.replaceElement(parameterTypeRef, parameterTypeExpressions[i]);\n\n            // add parameter name to the template\n            String[] possibleNamesFromExpression = parameter.getType().getPossibleNamesFromExpression();\n            String preferredName = parameter.getPreferredName();\n            String[] possibleNames;\n            if (preferredName != null) {\n                possibleNames = new String[possibleNamesFromExpression.length + 1];\n                possibleNames[0] = preferredName;\n                System.arraycopy(possibleNamesFromExpression, 0, possibleNames, 1, possibleNamesFromExpression.length);\n            } else {\n                possibleNames = possibleNamesFromExpression;\n            }\n\n            // figure out suggested names for each type option\n            Map<String, String[]> parameterTypeToNamesMap = new HashMap<String, String[]>();\n            String[] typeOptionStrings = parameterTypeExpressions[i].getOptionStrings();\n            assert typeOptions.length == typeOptionStrings.length;\n            for (int j = 0; j < typeOptions.length; j++) {\n                String[] suggestedNames = JetNameSuggester.suggestNamesForType(typeOptions[j], JetNameValidator.getEmptyValidator(project));\n                parameterTypeToNamesMap.put(typeOptionStrings[j], suggestedNames);\n            }\n\n            // add expression to builder\n            Expression parameterNameExpression = new ParameterNameExpression(possibleNames, parameterTypeToNamesMap);\n            PsiElement parameterNameIdentifier = jetParameter.getNameIdentifier();\n            assert parameterNameIdentifier != null;\n            builder.replaceElement(parameterNameIdentifier, parameterNameExpression);\n        }\n        return parameterTypeExpressions;\n    }","id":44470,"modified_method":"private TypeExpression[] setupParameterTypeTemplates(@NotNull Project project, @NotNull TemplateBuilder builder,\n            @NotNull JetParameterList parameterList) {\n        List<JetParameter> jetParameters = parameterList.getParameters();\n        assert jetParameters.size() == parameters.size();\n        TypeExpression[] parameterTypeExpressions = new TypeExpression[parameters.size()];\n        JetNameValidator dummyValidator = JetNameValidator.getEmptyValidator(project);\n        for (int i = 0; i < parameters.size(); i++) {\n            Parameter parameter = parameters.get(i);\n            JetParameter jetParameter = jetParameters.get(i);\n\n            // add parameter type to the template\n            parameterTypeExpressions[i] = new TypeExpression(parameter.getType());\n            JetTypeReference parameterTypeRef = jetParameter.getTypeReference();\n            assert parameterTypeRef != null;\n            builder.replaceElement(parameterTypeRef, parameterTypeExpressions[i]);\n\n            // add parameter name to the template\n            String[] possibleNamesFromExpression = parameter.getType().getPossibleNamesFromExpression();\n            String preferredName = parameter.getPreferredName();\n            String[] possibleNames;\n            if (preferredName != null) {\n                possibleNames = new String[possibleNamesFromExpression.length + 1];\n                possibleNames[0] = preferredName;\n                System.arraycopy(possibleNamesFromExpression, 0, possibleNames, 1, possibleNamesFromExpression.length);\n            } else {\n                possibleNames = possibleNamesFromExpression;\n            }\n\n            // figure out suggested names for each type option\n            Map<String, String[]> parameterTypeToNamesMap = new HashMap<String, String[]>();\n            for (TypeCandidate typeCandidate : parameter.getType().getTypeCandidates()) {\n                String[] suggestedNames = JetNameSuggester.suggestNamesForType(typeCandidate.getType(), dummyValidator);\n                parameterTypeToNamesMap.put(typeCandidate.getRenderedType(), suggestedNames);\n            }\n\n            // add expression to builder\n            Expression parameterNameExpression = new ParameterNameExpression(possibleNames, parameterTypeToNamesMap);\n            PsiElement parameterNameIdentifier = jetParameter.getNameIdentifier();\n            assert parameterNameIdentifier != null;\n            builder.replaceElement(parameterNameIdentifier, parameterNameExpression);\n        }\n        return parameterTypeExpressions;\n    }","commit_id":"a80ea6904aa853de1569b484fac84cce52cf1153","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static String getKeystoreType(String keyStoreType, Logger log) {\n        String logMsg = null;\n        if (keyStoreType != null) {\n            logMsg = \"KEY_STORE_TYPE_SET\";\n        } else {\n            keyStoreType = DEFAULT_KEYSTORE_TYPE;\n            logMsg = \"KEY_STORE_TYPE_NOT_SET\";\n        }\n        LogUtils.log(log, Level.FINE, logMsg, keyStoreType);\n        return keyStoreType;\n    }","id":44471,"modified_method":"public static String getKeystoreType(String keyStoreType, Logger log) {\n        return getKeystoreType(keyStoreType, log, DEFAULT_KEYSTORE_TYPE);\n    }","commit_id":"ad12c5b6f44d375ef7868069fb0836a663698252","url":"https://github.com/apache/cxf"},{"original_method":"public static String getKeyPassword(String keyPassword, Logger log) {\n        String logMsg = null;\n        if (keyPassword != null) {\n            logMsg = \"KEY_PASSWORD_SET\";\n        } else {\n            keyPassword =\n                SystemPropertyAction.getProperty(\"javax.net.ssl.keyStorePassword\");\n            logMsg = keyPassword != null\n                     ? \"KEY_PASSWORD_SYSTEM_PROPERTY_SET\"\n                     : \"KEY_PASSWORD_NOT_SET\";\n        }\n        LogUtils.log(log, Level.FINE, logMsg);\n        return keyPassword;\n    }","id":44472,"modified_method":"public static String getKeyPassword(String keyPassword, Logger log) {\n        String logMsg = null;\n        if (keyPassword != null) {\n            logMsg = \"KEY_PASSWORD_SET\";\n        } else {\n            keyPassword =\n                SystemPropertyAction.getProperty(\"javax.net.ssl.keyPassword\");\n            if (keyPassword == null) {\n                keyPassword =\n                    SystemPropertyAction.getProperty(\"javax.net.ssl.keyStorePassword\");\n            }\n            logMsg = keyPassword != null\n                     ? \"KEY_PASSWORD_SYSTEM_PROPERTY_SET\"\n                     : \"KEY_PASSWORD_NOT_SET\";\n        }\n        LogUtils.log(log, Level.FINE, logMsg);\n        return keyPassword;\n    }","commit_id":"ad12c5b6f44d375ef7868069fb0836a663698252","url":"https://github.com/apache/cxf"},{"original_method":"public static String getTrustStoreType(String trustStoreType, Logger log) {\n        String logMsg = null;\n        if (trustStoreType != null) {\n            logMsg = \"TRUST_STORE_TYPE_SET\";\n        } else {\n            //Can default to JKS\n            trustStoreType = DEFAULT_TRUST_STORE_TYPE;\n            logMsg = \"TRUST_STORE_TYPE_NOT_SET\";\n        }\n        LogUtils.log(log, Level.FINE, logMsg, trustStoreType);\n        return trustStoreType;\n    }","id":44473,"modified_method":"public static String getTrustStoreType(String trustStoreType, Logger log) {\n        String logMsg = null;\n        if (trustStoreType != null) {\n            logMsg = \"TRUST_STORE_TYPE_SET\";\n        } else {\n            //Can default to JKS\n            trustStoreType = SystemPropertyAction.getProperty(\"javax.net.ssl.trustStoreType\");\n            if (trustStoreType == null) {    \n                trustStoreType = DEFAULT_TRUST_STORE_TYPE;\n                logMsg = \"TRUST_STORE_TYPE_NOT_SET\";\n            } else {\n                logMsg = \"TRUST_STORE_TYPE_SYSTEM_SET\";\n            }\n        }\n        LogUtils.log(log, Level.FINE, logMsg, trustStoreType);\n        return trustStoreType;\n    }","commit_id":"ad12c5b6f44d375ef7868069fb0836a663698252","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * This method converts a JAXB generated KeyStoreType into a KeyStore.\n     */\n    public static KeyStore getKeyStore(KeyStoreType kst)\n        throws GeneralSecurityException,\n               IOException {\n\n        if (kst == null) {\n            return null;\n        }\n        String type = kst.isSetType()\n                    ? kst.getType()\n                    : KeyStore.getDefaultType();\n\n        char[] password = kst.isSetPassword()\n                    ? deobfuscate(kst.getPassword())\n                    : null;\n\n        KeyStore keyStore = !kst.isSetProvider()\n                    ? KeyStore.getInstance(type)\n                    : KeyStore.getInstance(type, kst.getProvider());\n\n        if (kst.isSetFile()) {\n            keyStore.load(new FileInputStream(kst.getFile()), password);\n        } else if (kst.isSetResource()) {\n            final java.io.InputStream is =\n                ClassLoaderUtils.getResourceAsStream(kst.getResource(), kst.getClass());\n            if (is == null) {\n                final String msg =\n                    \"Could not load keystore resource \" + kst.getResource();\n                LOG.severe(msg);\n                throw new java.io.IOException(msg);\n            }\n            keyStore.load(is, password);\n        } else if (kst.isSetUrl()) {\n            keyStore.load(new URL(kst.getUrl()).openStream(), password);\n        } else {\n            keyStore.load(null, password);\n        }\n        return keyStore;\n    }","id":44474,"modified_method":"/**\n     * This method converts a JAXB generated KeyStoreType into a KeyStore.\n     */\n    public static KeyStore getKeyStore(KeyStoreType kst)\n        throws GeneralSecurityException,\n               IOException {\n\n        if (kst == null) {\n            return null;\n        }\n        String type = SSLUtils.getKeystoreType(kst.isSetType()\n                                 ? kst.getType() : null, LOG, KeyStore.getDefaultType());\n\n        char[] password = kst.isSetPassword()\n                    ? deobfuscate(kst.getPassword())\n                    : null;\n        if (password == null) {\n            String tmp = SSLUtils.getKeystorePassword(null, LOG);\n            if (tmp != null) {\n                password = tmp.toCharArray();\n            }\n        }\n        String provider = SSLUtils.getKeystoreProvider(kst.isSetProvider() \n                                                       ? kst.getProvider() : null,\n                                                       LOG);\n        KeyStore keyStore = provider == null\n                    ? KeyStore.getInstance(type)\n                    : KeyStore.getInstance(type, provider);\n\n        if (kst.isSetFile()) {\n            keyStore.load(new FileInputStream(kst.getFile()), password);\n        } else if (kst.isSetResource()) {\n            final java.io.InputStream is =\n                ClassLoaderUtils.getResourceAsStream(kst.getResource(), kst.getClass());\n            if (is == null) {\n                final String msg =\n                    \"Could not load keystore resource \" + kst.getResource();\n                LOG.severe(msg);\n                throw new java.io.IOException(msg);\n            }\n            keyStore.load(is, password);\n        } else if (kst.isSetUrl()) {\n            keyStore.load(new URL(kst.getUrl()).openStream(), password);\n        } else {\n            String loc = SSLUtils.getKeystore(null, LOG);\n            InputStream ins = null;\n            if (loc != null) {\n                ins = new FileInputStream(loc);\n            }\n            keyStore.load(ins, password);\n        }\n        return keyStore;\n    }","commit_id":"ad12c5b6f44d375ef7868069fb0836a663698252","url":"https://github.com/apache/cxf"},{"original_method":"void m() {\n        try { }\n        catch (E1 | E2 ex) {\n            final B<? extends Number> b = ex;\n        }\n    }","id":44475,"modified_method":"void m() {\n        try { }\n        catch (E1 | E2 ex) {\n            final Exception b = ex;\n        }\n    }","commit_id":"00292e469634b1a286f5fac261ce220d8e3dcf2c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testMultiCatchSimple() throws Exception {\n    doTest(new MockIntroduceVariableHandler(\"e\", true, true, false, \"C.E1 | C.E2\"));\n  }","id":44476,"modified_method":"public void testMultiCatchSimple() throws Exception {\n    doTest(new MockIntroduceVariableHandler(\"e\", true, true, false, \"java.lang.Exception\", true));\n  }","commit_id":"00292e469634b1a286f5fac261ce220d8e3dcf2c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testMultiCatchTyped() throws Exception {\n    doTest(new MockIntroduceVariableHandler(\"b\", true, true, false, \"C.E1 | C.E2\"));\n  }","id":44477,"modified_method":"public void testMultiCatchTyped() throws Exception {\n    doTest(new MockIntroduceVariableHandler(\"b\", true, true, false, \"java.lang.Exception\", true));\n  }","commit_id":"00292e469634b1a286f5fac261ce220d8e3dcf2c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MockIntroduceVariableHandler(@NonNls final String name, final boolean replaceAll,\n                                 final boolean declareFinal, final boolean replaceLValues,\n                                 @NonNls final String expectedTypeCanonicalName) {\n\n    myName = name;\n    myReplaceAll = replaceAll;\n    myDeclareFinal = declareFinal;\n    myReplaceLValues = replaceLValues;\n    myExpectedTypeCanonicalName = expectedTypeCanonicalName;\n  }","id":44478,"modified_method":"public MockIntroduceVariableHandler(@NonNls final String name, final boolean replaceAll,\n                                      final boolean declareFinal, final boolean replaceLValues,\n                                      @NonNls final String expectedTypeCanonicalName) {\n\n    this(name, replaceAll, declareFinal, replaceLValues, expectedTypeCanonicalName, false);\n  }","commit_id":"00292e469634b1a286f5fac261ce220d8e3dcf2c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public IntroduceVariableSettings getSettings(Project project, Editor editor,\n                                               PsiExpression expr, final PsiExpression[] occurrences,\n                                               TypeSelectorManagerImpl typeSelectorManager,\n                                               final boolean declareFinalIfAll,\n                                               boolean anyAssignmentLHS,\n                                               InputValidator validator,\n                                               final OccurrencesChooser.ReplaceChoice replaceChoice) {\n    final PsiType type = typeSelectorManager.getDefaultType();\n    Assert.assertTrue(type.getCanonicalText(), type.equalsToText(myExpectedTypeCanonicalName));\n    IntroduceVariableSettings introduceVariableSettings = new IntroduceVariableSettings() {\n      @Override\n      public String getEnteredName() {\n        return myName;\n      }\n\n      @Override\n      public boolean isReplaceAllOccurrences() {\n        return myReplaceAll && occurrences.length > 1;\n      }\n\n      @Override\n      public boolean isDeclareFinal() {\n        return myDeclareFinal || isReplaceAllOccurrences() && declareFinalIfAll;\n      }\n\n      @Override\n      public boolean isReplaceLValues() {\n        return myReplaceLValues;\n      }\n\n      @Override\n      public PsiType getSelectedType() {\n        return type;\n      }\n\n      @Override\n      public boolean isOK() {\n        return true;\n      }\n    };\n    final boolean validationResult = validator.isOK(introduceVariableSettings);\n    assertValidationResult(validationResult);\n    return introduceVariableSettings;\n  }","id":44479,"modified_method":"@Override\n  public IntroduceVariableSettings getSettings(Project project, Editor editor,\n                                               PsiExpression expr, final PsiExpression[] occurrences,\n                                               TypeSelectorManagerImpl typeSelectorManager,\n                                               final boolean declareFinalIfAll,\n                                               boolean anyAssignmentLHS,\n                                               InputValidator validator,\n                                               final OccurrencesChooser.ReplaceChoice replaceChoice) {\n    final PsiType type = myLookForType ? findType(typeSelectorManager.getTypesForAll(), typeSelectorManager.getDefaultType())\n                                       : typeSelectorManager.getDefaultType();\n    Assert.assertTrue(type.getCanonicalText(), type.equalsToText(myExpectedTypeCanonicalName));\n    IntroduceVariableSettings introduceVariableSettings = new IntroduceVariableSettings() {\n      @Override\n      public String getEnteredName() {\n        return myName;\n      }\n\n      @Override\n      public boolean isReplaceAllOccurrences() {\n        return myReplaceAll && occurrences.length > 1;\n      }\n\n      @Override\n      public boolean isDeclareFinal() {\n        return myDeclareFinal || isReplaceAllOccurrences() && declareFinalIfAll;\n      }\n\n      @Override\n      public boolean isReplaceLValues() {\n        return myReplaceLValues;\n      }\n\n      @Override\n      public PsiType getSelectedType() {\n        return type;\n      }\n\n      @Override\n      public boolean isOK() {\n        return true;\n      }\n    };\n    final boolean validationResult = validator.isOK(introduceVariableSettings);\n    assertValidationResult(validationResult);\n    return introduceVariableSettings;\n  }","commit_id":"00292e469634b1a286f5fac261ce220d8e3dcf2c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void handleXmitRsp(Message msg, NakAckHeader hdr) {\n        if(msg == null)\n            return;\n\n        try {\n            if(xmit_time_stats != null) {\n                long key=(System.currentTimeMillis() - xmit_time_stats_start) / 1000;\n                XmitTimeStat stat=xmit_time_stats.get(key);\n                if(stat == null) {\n                    stat=new XmitTimeStat();\n                    XmitTimeStat stat2=xmit_time_stats.putIfAbsent(key, stat);\n                    if(stat2 != null)\n                        stat=stat2;\n                }\n                stat.xmit_rsps_received.incrementAndGet();\n            }\n\n            if(stats) {\n                xmit_rsps_received++;\n                updateStats(received, msg.getSrc(), 0, 1, 0);\n            }\n\n            msg.setDest(null);\n            hdr.type=NakAckHeader.MSG; // change the type back from XMIT_RSP --> MSG\n            up(new Event(Event.MSG, msg));\n            if(rebroadcasting)\n                checkForRebroadcasts();\n        }\n        catch(Exception ex) {\n            if(log.isErrorEnabled()) {\n                log.error(\"failed reading retransmitted message\", ex);\n            }\n        }\n    }","id":44480,"modified_method":"private void handleXmitRsp(Message msg, NakAckHeader hdr) {\n        if(msg == null)\n            return;\n\n        try {\n            if(stats) {\n                xmit_rsps_received++;\n                updateStats(received, msg.getSrc(), 0, 1, 0);\n            }\n\n            msg.setDest(null);\n            hdr.type=NakAckHeader.MSG; // change the type back from XMIT_RSP --> MSG\n            up(new Event(Event.MSG, msg));\n            if(rebroadcasting)\n                checkForRebroadcasts();\n        }\n        catch(Exception ex) {\n            if(log.isErrorEnabled()) {\n                log.error(\"failed reading retransmitted message\", ex);\n            }\n        }\n    }","commit_id":"0b5ae07c84f21f1ac3dbc836e08b0cb795441e6c","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Retransmits messsages first_seqno to last_seqno from original_sender from xmit_table to xmit_requester,\n     * called when XMIT_REQ is received.\n     * @param xmit_requester        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     * @param original_sender The member who originally sent the messsage. Guaranteed to be non-null\n     */\n    private void handleXmitReq(Address xmit_requester, long first_seqno, long last_seqno, Address original_sender) {\n        if(first_seqno > last_seqno)\n            return;\n\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\": received xmit request from \").append(xmit_requester).append(\" for \");\n            sb.append(original_sender).append(\" [\").append(first_seqno).append(\" - \").append(last_seqno).append(\"]\");\n            log.trace(sb.toString());\n        }\n\n        if(stats) {\n            xmit_reqs_received+=last_seqno - first_seqno +1;\n            updateStats(received, xmit_requester, 1, 0, 0);\n        }\n\n        if(xmit_time_stats != null) {\n            long key=(System.currentTimeMillis() - xmit_time_stats_start) / 1000;\n            XmitTimeStat stat=xmit_time_stats.get(key);\n            if(stat == null) {\n                stat=new XmitTimeStat();\n                XmitTimeStat stat2=xmit_time_stats.putIfAbsent(key, stat);\n                if(stat2 != null)\n                    stat=stat2;\n            }\n            stat.xmit_reqs_received.addAndGet((int)(last_seqno - first_seqno +1));\n            stat.xmit_rsps_sent.addAndGet((int)(last_seqno - first_seqno + 1));\n        }\n\n        NakReceiverWindow win=xmit_table.get(original_sender);\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                StringBuilder sb=new StringBuilder();\n                sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                sb.append(\") \").append(original_sender).append(\" not found in retransmission table\");\n                // don't print the table unless we are in trace mode because it can be LARGE\n                if (log.isTraceEnabled()) {\n                    sb.append(\":\\n\").append(printMessages());\n                } \n                if(print_stability_history_on_failed_xmit) {\n                    sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                }\n                log.error(sb.toString());\n            }\n            return;\n        }\n\n        long diff=last_seqno - first_seqno +1;\n        if(diff >= 10) {\n            List<Message> msgs=win.get(first_seqno, last_seqno);\n            if(msgs != null) {\n                for(Message msg: msgs)\n                    sendXmitRsp(xmit_requester, msg);\n            }\n        }\n        else {\n            for(long i=first_seqno; i <= last_seqno; i++) {\n                Message msg=win.get(i);\n                if(msg == null) {\n                    if(log.isWarnEnabled() && log_not_found_msgs && !local_addr.equals(xmit_requester)) {\n                        StringBuilder sb=new StringBuilder();\n                        sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                        sb.append(\") message \").append(original_sender).append(\"::\").append(i);\n                        sb.append(\" not found in retransmission table of \").append(original_sender).append(\":\\n\").append(win);\n                        if(print_stability_history_on_failed_xmit) {\n                            sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                        }\n                        log.warn(sb.toString());\n                    }\n                    continue;\n                }\n                sendXmitRsp(xmit_requester, msg);\n            }\n        }\n    }","id":44481,"modified_method":"/**\n     * Retransmits messsages first_seqno to last_seqno from original_sender from xmit_table to xmit_requester,\n     * called when XMIT_REQ is received.\n     * @param xmit_requester        The sender of the XMIT_REQ, we have to send the requested copy of the message to this address\n     * @param first_seqno The first sequence number to be retransmitted (<= last_seqno)\n     * @param last_seqno  The last sequence number to be retransmitted (>= first_seqno)\n     * @param original_sender The member who originally sent the messsage. Guaranteed to be non-null\n     */\n    private void handleXmitReq(Address xmit_requester, long first_seqno, long last_seqno, Address original_sender) {\n        if(first_seqno > last_seqno)\n            return;\n\n        if(log.isTraceEnabled()) {\n            StringBuilder sb=new StringBuilder();\n            sb.append(local_addr).append(\": received xmit request from \").append(xmit_requester).append(\" for \");\n            sb.append(original_sender).append(\" [\").append(first_seqno).append(\" - \").append(last_seqno).append(\"]\");\n            log.trace(sb.toString());\n        }\n\n        if(stats) {\n            xmit_reqs_received+=last_seqno - first_seqno +1;\n            updateStats(received, xmit_requester, 1, 0, 0);\n        }\n\n        NakReceiverWindow win=xmit_table.get(original_sender);\n        if(win == null) {\n            if(log.isErrorEnabled()) {\n                StringBuilder sb=new StringBuilder();\n                sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                sb.append(\") \").append(original_sender).append(\" not found in retransmission table\");\n                // don't print the table unless we are in trace mode because it can be LARGE\n                if (log.isTraceEnabled()) {\n                    sb.append(\":\\n\").append(printMessages());\n                } \n                if(print_stability_history_on_failed_xmit) {\n                    sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                }\n                log.error(sb.toString());\n            }\n            return;\n        }\n\n        long diff=last_seqno - first_seqno +1;\n        if(diff >= 10) {\n            List<Message> msgs=win.get(first_seqno, last_seqno);\n            if(msgs != null) {\n                for(Message msg: msgs)\n                    sendXmitRsp(xmit_requester, msg);\n            }\n        }\n        else {\n            for(long i=first_seqno; i <= last_seqno; i++) {\n                Message msg=win.get(i);\n                if(msg == null) {\n                    if(log.isWarnEnabled() && log_not_found_msgs && !local_addr.equals(xmit_requester)) {\n                        StringBuilder sb=new StringBuilder();\n                        sb.append(\"(requester=\").append(xmit_requester).append(\", local_addr=\").append(this.local_addr);\n                        sb.append(\") message \").append(original_sender).append(\"::\").append(i);\n                        sb.append(\" not found in retransmission table of \").append(original_sender).append(\":\\n\").append(win);\n                        if(print_stability_history_on_failed_xmit) {\n                            sb.append(\" (stability history:\\n\").append(printStabilityHistory());\n                        }\n                        log.warn(sb.toString());\n                    }\n                    continue;\n                }\n                sendXmitRsp(xmit_requester, msg);\n            }\n        }\n    }","commit_id":"0b5ae07c84f21f1ac3dbc836e08b0cb795441e6c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void setDiscardDeliveredMsgs(boolean discard_delivered_msgs) {\n        boolean old=this.discard_delivered_msgs;\n        this.discard_delivered_msgs=discard_delivered_msgs;\n        if(old != this.discard_delivered_msgs) {\n            for(NakReceiverWindow win: xmit_table.values()) {\n                win.setDiscardDeliveredMessages(this.discard_delivered_msgs);\n            }\n        }\n    }","id":44482,"modified_method":"public void setDiscardDeliveredMsgs(boolean discard_delivered_msgs) {\n        boolean old=this.discard_delivered_msgs;\n        this.discard_delivered_msgs=discard_delivered_msgs;\n    }","commit_id":"0b5ae07c84f21f1ac3dbc836e08b0cb795441e6c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init() throws Exception {\n        if(enable_xmit_time_stats) {\n            if(log.isWarnEnabled())\n                log.warn(\"enable_xmit_time_stats is experimental, and may be removed in any release\");\n            xmit_time_stats=new ConcurrentHashMap<Long,XmitTimeStat>();\n            xmit_time_stats_start=System.currentTimeMillis();\n        }\n\n        if(xmit_from_random_member) {\n            if(discard_delivered_msgs) {\n                discard_delivered_msgs=false;\n                log.warn(\"xmit_from_random_member set to true: changed discard_delivered_msgs to false\");\n            }\n        }\n\n        TP transport=getTransport();\n        if(transport != null) {\n            transport.registerProbeHandler(this);\n            if(!transport.supportsMulticasting()) {\n                if(use_mcast_xmit) {\n                    log.warn(\"use_mcast_xmit should not be used because the transport (\" + transport.getName() +\n                            \") does not support IP multicasting; setting use_mcast_xmit to false\");\n                    use_mcast_xmit=false;\n                }\n                if(use_mcast_xmit_req) {\n                    log.warn(\"use_mcast_xmit_req should not be used because the transport (\" + transport.getName() +\n                            \") does not support IP multicasting; setting use_mcast_xmit_req to false\");\n                    use_mcast_xmit_req=false;\n                }\n            }\n        }\n    }","id":44483,"modified_method":"public void init() throws Exception {\n        if(xmit_from_random_member) {\n            if(discard_delivered_msgs) {\n                discard_delivered_msgs=false;\n                log.warn(\"xmit_from_random_member set to true: changed discard_delivered_msgs to false\");\n            }\n        }\n\n        TP transport=getTransport();\n        if(transport != null) {\n            transport.registerProbeHandler(this);\n            if(!transport.supportsMulticasting()) {\n                if(use_mcast_xmit) {\n                    log.warn(\"use_mcast_xmit should not be used because the transport (\" + transport.getName() +\n                            \") does not support IP multicasting; setting use_mcast_xmit to false\");\n                    use_mcast_xmit=false;\n                }\n                if(use_mcast_xmit_req) {\n                    log.warn(\"use_mcast_xmit_req should not be used because the transport (\" + transport.getName() +\n                            \") does not support IP multicasting; setting use_mcast_xmit_req to false\");\n                    use_mcast_xmit_req=false;\n                }\n            }\n        }\n    }","commit_id":"0b5ae07c84f21f1ac3dbc836e08b0cb795441e6c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void missingMessageReceived(long seqno, final Address original_sender) {\n        ConcurrentMap<Long,Long> tmp=xmit_stats.get(original_sender);\n        if(tmp != null) {\n            Long timestamp=tmp.remove(seqno);\n            if(timestamp != null) {\n                long diff=System.currentTimeMillis() - timestamp;\n                BoundedList<Long> list=xmit_times_history.get(original_sender);\n                if(list == null) {\n                    list=new BoundedList<Long>(xmit_history_max_size);\n                    BoundedList<Long> list2=xmit_times_history.putIfAbsent(original_sender, list);\n                    if(list2 != null)\n                        list=list2;\n                }\n                list.add(diff);\n\n                // compute the smoothed average for retransmission times for original_sender\n                // needs to be synchronized because we rely on the previous value for computation of the next value\n                synchronized(smoothed_avg_xmit_times) {\n                    Double smoothed_avg=smoothed_avg_xmit_times.get(original_sender);\n                    if(smoothed_avg == null)\n                        smoothed_avg=INITIAL_SMOOTHED_AVG;\n                    // the smoothed avg takes 90% of the previous value, 100% of the new value and averages them\n                    // then, we add 10% to be on the safe side (an xmit value should rather err on the higher than lower side)\n                    smoothed_avg=((smoothed_avg * WEIGHT) + diff) / 2;\n                    smoothed_avg=smoothed_avg * (2 - WEIGHT);\n                    smoothed_avg_xmit_times.put(original_sender, smoothed_avg);\n                }\n            }\n        }\n\n        if(xmit_time_stats != null) {\n            long key=(System.currentTimeMillis() - xmit_time_stats_start) / 1000;\n            XmitTimeStat stat=xmit_time_stats.get(key);\n            if(stat == null) {\n                stat=new XmitTimeStat();\n                XmitTimeStat stat2=xmit_time_stats.putIfAbsent(key, stat);\n                if(stat2 != null)\n                    stat=stat2;\n            }\n            stat.missing_msgs_received.incrementAndGet();\n        }\n\n        if(stats) {\n            missing_msgs_received++;\n            updateStats(received, original_sender, 0, 0, 1);\n        }\n    }","id":44484,"modified_method":"public void missingMessageReceived(long seqno, final Address original_sender) {\n        ConcurrentMap<Long,Long> tmp=xmit_stats.get(original_sender);\n        if(tmp != null) {\n            Long timestamp=tmp.remove(seqno);\n            if(timestamp != null) {\n                long diff=System.currentTimeMillis() - timestamp;\n                BoundedList<Long> list=xmit_times_history.get(original_sender);\n                if(list == null) {\n                    list=new BoundedList<Long>(xmit_history_max_size);\n                    BoundedList<Long> list2=xmit_times_history.putIfAbsent(original_sender, list);\n                    if(list2 != null)\n                        list=list2;\n                }\n                list.add(diff);\n\n                // compute the smoothed average for retransmission times for original_sender\n                // needs to be synchronized because we rely on the previous value for computation of the next value\n                synchronized(smoothed_avg_xmit_times) {\n                    Double smoothed_avg=smoothed_avg_xmit_times.get(original_sender);\n                    if(smoothed_avg == null)\n                        smoothed_avg=INITIAL_SMOOTHED_AVG;\n                    // the smoothed avg takes 90% of the previous value, 100% of the new value and averages them\n                    // then, we add 10% to be on the safe side (an xmit value should rather err on the higher than lower side)\n                    smoothed_avg=((smoothed_avg * WEIGHT) + diff) / 2;\n                    smoothed_avg=smoothed_avg * (2 - WEIGHT);\n                    smoothed_avg_xmit_times.put(original_sender, smoothed_avg);\n                }\n            }\n        }\n\n        if(stats) {\n            missing_msgs_received++;\n            updateStats(received, original_sender, 0, 0, 1);\n        }\n    }","commit_id":"0b5ae07c84f21f1ac3dbc836e08b0cb795441e6c","url":"https://github.com/belaban/JGroups"},{"original_method":"private NakReceiverWindow createNakReceiverWindow(Address sender, long initial_seqno, long lowest_seqno) {\n        NakReceiverWindow win=new NakReceiverWindow(sender, this, initial_seqno, lowest_seqno, timer, true,\n                                                    xmit_table_num_rows, xmit_table_msgs_per_row,\n                                                    xmit_table_resize_factor, xmit_table_max_compaction_time, false);\n\n        if(use_stats_for_retransmission) {\n            win.setRetransmitTimeouts(new ActualInterval(sender));\n        }\n        else if(exponential_backoff > 0) {\n            win.setRetransmitTimeouts(new ExponentialInterval(exponential_backoff));\n        }\n        else {\n            win.setRetransmitTimeouts(new StaticInterval(retransmit_timeouts));\n        }\n\n        win.setDiscardDeliveredMessages(discard_delivered_msgs);\n        if(stats)\n            win.setListener(this);\n        return win;\n    }","id":44485,"modified_method":"private NakReceiverWindow createNakReceiverWindow(Address sender, long initial_seqno, long lowest_seqno) {\n        NakReceiverWindow win=new NakReceiverWindow(sender, this, initial_seqno, lowest_seqno, timer, true,\n                                                    xmit_table_num_rows, xmit_table_msgs_per_row,\n                                                    xmit_table_resize_factor, xmit_table_max_compaction_time, false);\n\n        if(use_stats_for_retransmission)\n            win.setRetransmitTimeouts(new ActualInterval(sender));\n        else if(exponential_backoff > 0)\n            win.setRetransmitTimeouts(new ExponentialInterval(exponential_backoff));\n        else\n            win.setRetransmitTimeouts(new StaticInterval(retransmit_timeouts));\n        if(stats)\n            win.setListener(this);\n        return win;\n    }","commit_id":"0b5ae07c84f21f1ac3dbc836e08b0cb795441e6c","url":"https://github.com/belaban/JGroups"},{"original_method":"public void start() throws Exception {\n        timer=getTransport().getTimer();\n        if(timer == null)\n            throw new Exception(\"timer is null\");\n        running=true;\n        leaving=false;\n\n        if(xmit_time_stats != null) {\n            Runtime.getRuntime().addShutdownHook(new Thread() {\n                public void run() {\n                    String filename=\"xmit-stats-\" + local_addr + \".log\";\n                    try {\n                        dumpXmitStats(filename);\n                    }\n                    catch(IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n        }\n    }","id":44486,"modified_method":"public void start() throws Exception {\n        timer=getTransport().getTimer();\n        if(timer == null)\n            throw new Exception(\"timer is null\");\n        running=true;\n        leaving=false;\n    }","commit_id":"0b5ae07c84f21f1ac3dbc836e08b0cb795441e6c","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Called when a message gap is detected */\n    public void messageGapDetected(long from, long to, Address src) {\n        if(xmit_time_stats != null) {\n            long key=(System.currentTimeMillis() - xmit_time_stats_start) / 1000;\n            XmitTimeStat stat=xmit_time_stats.get(key);\n            if(stat == null) {\n                stat=new XmitTimeStat();\n                XmitTimeStat stat2=xmit_time_stats.putIfAbsent(key, stat);\n                if(stat2 != null)\n                    stat=stat2;\n            }\n            stat.gaps_detected.addAndGet((int)(to - from +1));\n        }\n    }","id":44487,"modified_method":"/** Called when a message gap is detected */\n    public void messageGapDetected(long from, long to, Address src) {\n        ;\n    }","commit_id":"0b5ae07c84f21f1ac3dbc836e08b0cb795441e6c","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void retransmit(long first_seqno, long last_seqno, final Address sender, boolean multicast_xmit_request) {\n        NakAckHeader hdr;\n        Message retransmit_msg;\n        Address dest=sender; // to whom do we send the XMIT request ?\n\n        if(multicast_xmit_request || this.use_mcast_xmit_req) {\n            dest=null;\n        }\n        else {\n            if(xmit_from_random_member && !local_addr.equals(sender)) {\n                Address random_member=(Address)Util.pickRandomElement(members);\n                if(random_member != null && !local_addr.equals(random_member)) {\n                    dest=random_member;\n                    if(log.isTraceEnabled())\n                        log.trace(\"picked random member \" + dest + \" to send XMIT request to\");\n                }\n            }\n        }\n\n        hdr=NakAckHeader.createXmitRequestHeader(first_seqno, last_seqno, sender);\n        retransmit_msg=new Message(dest, null, null);\n        retransmit_msg.setFlag(Message.OOB);\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \": sending XMIT_REQ ([\" + first_seqno + \", \" + last_seqno + \"]) to \" + dest);\n        retransmit_msg.putHeader(this.id, hdr);\n\n        ConcurrentMap<Long,Long> tmp=xmit_stats.get(sender);\n        if(tmp == null) {\n            tmp=new ConcurrentHashMap<Long,Long>();\n            ConcurrentMap<Long,Long> tmp2=xmit_stats.putIfAbsent(sender, tmp);\n            if(tmp2 != null)\n                tmp=tmp2;\n        }\n        for(long seq=first_seqno; seq < last_seqno; seq++) {\n            tmp.putIfAbsent(seq, System.currentTimeMillis());\n        }\n\n        if(xmit_time_stats != null) {\n            long key=(System.currentTimeMillis() - xmit_time_stats_start) / 1000;\n            XmitTimeStat stat=xmit_time_stats.get(key);\n            if(stat == null) {\n                stat=new XmitTimeStat();\n                XmitTimeStat stat2=xmit_time_stats.putIfAbsent(key, stat);\n                if(stat2 != null)\n                    stat=stat2;\n            }\n            stat.xmit_reqs_sent.addAndGet((int)(last_seqno - first_seqno +1));\n        }\n\n        down_prot.down(new Event(Event.MSG, retransmit_msg));\n        if(stats) {\n            xmit_reqs_sent+=last_seqno - first_seqno +1;\n            updateStats(sent, sender, 1, 0, 0);\n        }\n\n        xmit_history.add(sender + \": \" + first_seqno + \"-\" + last_seqno);\n    }","id":44488,"modified_method":"protected void retransmit(long first_seqno, long last_seqno, final Address sender, boolean multicast_xmit_request) {\n        NakAckHeader hdr;\n        Message retransmit_msg;\n        Address dest=sender; // to whom do we send the XMIT request ?\n\n        if(multicast_xmit_request || this.use_mcast_xmit_req) {\n            dest=null;\n        }\n        else {\n            if(xmit_from_random_member && !local_addr.equals(sender)) {\n                Address random_member=(Address)Util.pickRandomElement(members);\n                if(random_member != null && !local_addr.equals(random_member)) {\n                    dest=random_member;\n                    if(log.isTraceEnabled())\n                        log.trace(\"picked random member \" + dest + \" to send XMIT request to\");\n                }\n            }\n        }\n\n        hdr=NakAckHeader.createXmitRequestHeader(first_seqno, last_seqno, sender);\n        retransmit_msg=new Message(dest, null, null);\n        retransmit_msg.setFlag(Message.OOB);\n        if(log.isTraceEnabled())\n            log.trace(local_addr + \": sending XMIT_REQ ([\" + first_seqno + \", \" + last_seqno + \"]) to \" + dest);\n        retransmit_msg.putHeader(this.id, hdr);\n\n        ConcurrentMap<Long,Long> tmp=xmit_stats.get(sender);\n        if(tmp == null) {\n            tmp=new ConcurrentHashMap<Long,Long>();\n            ConcurrentMap<Long,Long> tmp2=xmit_stats.putIfAbsent(sender, tmp);\n            if(tmp2 != null)\n                tmp=tmp2;\n        }\n        for(long seq=first_seqno; seq < last_seqno; seq++) {\n            tmp.putIfAbsent(seq, System.currentTimeMillis());\n        }\n\n        down_prot.down(new Event(Event.MSG, retransmit_msg));\n        if(stats) {\n            xmit_reqs_sent+=last_seqno - first_seqno +1;\n            updateStats(sent, sender, 1, 0, 0);\n        }\n\n        xmit_history.add(sender + \": \" + first_seqno + \"-\" + last_seqno);\n    }","commit_id":"0b5ae07c84f21f1ac3dbc836e08b0cb795441e6c","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * This function is used to do the anti compaction process , it spits out the file which has keys that belong to a given range\n     * If the target is not specified it spits out the file as a compacted file with the unecessary ranges wiped out.\n     *\n     * @param cfs\n     * @param sstables\n     * @param ranges\n     * @param target\n     * @return\n     * @throws java.io.IOException\n     */\n    private List<SSTableReader> doAntiCompaction(ColumnFamilyStore cfs, Collection<SSTableReader> sstables, Collection<Range> ranges, InetAddress target)\n            throws IOException\n    {\n        Table table = cfs.getTable();\n        logger.info(\"AntiCompacting [\" + StringUtils.join(sstables, \",\") + \"]\");\n        // Calculate the expected compacted filesize\n        long expectedRangeFileSize = cfs.getExpectedCompactedFileSize(sstables) / 2;\n        String compactionFileLocation = table.getDataFileLocation(expectedRangeFileSize);\n        if (compactionFileLocation == null)\n        {\n            throw new UnsupportedOperationException(\"disk full\");\n        }\n\n        List<SSTableReader> results = new ArrayList<SSTableReader>();\n        long startTime = System.currentTimeMillis();\n        long totalkeysWritten = 0;\n\n        int expectedBloomFilterSize = Math.max(SSTableReader.indexInterval(), (int)(SSTableReader.getApproximateKeyCount(sstables) / 2));\n        if (logger.isDebugEnabled())\n          logger.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\n\n        SSTableWriter writer = null;\n        CompactionIterator ci = new AntiCompactionIterator(sstables, ranges, getDefaultGCBefore(), cfs.isCompleteSSTables(sstables));\n        Iterator<AbstractCompactedRow> nni = new FilterIterator(ci, PredicateUtils.notNullPredicate());\n        executor.beginCompaction(cfs, ci);\n\n        try\n        {\n            if (!nni.hasNext())\n            {\n                return results;\n            }\n\n            while (nni.hasNext())\n            {\n                AbstractCompactedRow row = nni.next();\n                if (writer == null)\n                {\n                    FileUtils.createDirectory(compactionFileLocation);\n                    String newFilename = new File(cfs.getTempSSTablePath(compactionFileLocation)).getAbsolutePath();\n                    writer = new SSTableWriter(newFilename, expectedBloomFilterSize, StorageService.getPartitioner());\n                }\n                writer.append(row);\n                totalkeysWritten++;\n            }\n        }\n        finally\n        {\n            ci.close();\n        }\n\n        if (writer != null)\n        {\n            results.add(writer.closeAndOpenReader(getMaxDataAge(sstables)));\n            String format = \"AntiCompacted to %s.  %d/%d bytes for %d keys.  Time: %dms.\";\n            long dTime = System.currentTimeMillis() - startTime;\n            logger.info(String.format(format, writer.getFilename(), SSTable.getTotalBytes(sstables), results.get(0).length(), totalkeysWritten, dTime));\n        }\n\n        return results;\n    }","id":44489,"modified_method":"/**\n     * This function is used to do the anti compaction process , it spits out the file which has keys that belong to a given range\n     * If the target is not specified it spits out the file as a compacted file with the unecessary ranges wiped out.\n     *\n     * @param cfs\n     * @param sstables\n     * @param ranges\n     * @param target\n     * @return\n     * @throws java.io.IOException\n     */\n    private List<SSTableReader> doAntiCompaction(ColumnFamilyStore cfs, Collection<SSTableReader> sstables, Collection<Range> ranges, InetAddress target)\n            throws IOException\n    {\n        Table table = cfs.getTable();\n        logger.info(\"AntiCompacting [\" + StringUtils.join(sstables, \",\") + \"]\");\n        // Calculate the expected compacted filesize\n        long expectedRangeFileSize = cfs.getExpectedCompactedFileSize(sstables) / 2;\n        String compactionFileLocation = table.getDataFileLocation(expectedRangeFileSize);\n        if (compactionFileLocation == null)\n        {\n            throw new UnsupportedOperationException(\"disk full\");\n        }\n\n        List<SSTableReader> results = new ArrayList<SSTableReader>();\n        long startTime = System.currentTimeMillis();\n        long totalkeysWritten = 0;\n\n        int expectedBloomFilterSize = Math.max(SSTableReader.indexInterval(), (int)(SSTableReader.getApproximateKeyCount(sstables) / 2));\n        if (logger.isDebugEnabled())\n          logger.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\n\n        SSTableWriter writer = null;\n        CompactionIterator ci = new AntiCompactionIterator(sstables, ranges, getDefaultGCBefore(), cfs.isCompleteSSTables(sstables));\n        Iterator<AbstractCompactedRow> nni = new FilterIterator(ci, PredicateUtils.notNullPredicate());\n        executor.beginCompaction(cfs, ci);\n\n        try\n        {\n            if (!nni.hasNext())\n            {\n                return results;\n            }\n\n            while (nni.hasNext())\n            {\n                AbstractCompactedRow row = nni.next();\n                if (writer == null)\n                {\n                    FileUtils.createDirectory(compactionFileLocation);\n                    String newFilename = new File(cfs.getTempSSTablePath(compactionFileLocation)).getAbsolutePath();\n                    writer = new SSTableWriter(newFilename, expectedBloomFilterSize, StorageService.getPartitioner());\n                }\n                writer.append(row);\n                totalkeysWritten++;\n            }\n        }\n        finally\n        {\n            ci.close();\n        }\n\n        if (writer != null)\n        {\n            results.add(writer.closeAndOpenReader(getMaxDataAge(sstables)));\n\n            String format = \"AntiCompacted to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys.  Time: %,dms.\";\n            long dTime = System.currentTimeMillis() - startTime;\n            long startsize = SSTable.getTotalBytes(sstables);\n            long endsize = results.get(0).length();\n            double ratio = (double)endsize / (double)startsize;\n            logger.info(String.format(format, writer.getFilename(), startsize, endsize, (int)(ratio*100), totalkeysWritten, dTime));\n        }\n\n        return results;\n    }","commit_id":"b011752e150967db5241641b2592422a51f8ce18","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * For internal use and testing only.  The rest of the system should go through the submit* methods,\n     * which are properly serialized.\n     */\n    int doCompaction(ColumnFamilyStore cfs, Collection<SSTableReader> sstables, int gcBefore) throws IOException\n    {\n        // The collection of sstables passed may be empty (but not null); even if\n        // it is not empty, it may compact down to nothing if all rows are deleted.\n        Table table = cfs.getTable();\n        if (DatabaseDescriptor.isSnapshotBeforeCompaction())\n            table.snapshot(\"compact-\" + cfs.columnFamily_);\n        logger.info(\"Compacting [\" + StringUtils.join(sstables, \",\") + \"]\");\n        String compactionFileLocation = table.getDataFileLocation(cfs.getExpectedCompactedFileSize(sstables));\n        // If the compaction file path is null that means we have no space left for this compaction.\n        // try again w/o the largest one.\n        List<SSTableReader> smallerSSTables = new ArrayList<SSTableReader>(sstables);\n        while (compactionFileLocation == null && smallerSSTables.size() > 1)\n        {\n            logger.warn(\"insufficient space to compact all requested files \" + StringUtils.join(smallerSSTables, \", \"));\n            smallerSSTables.remove(cfs.getMaxSizeFile(smallerSSTables));\n            compactionFileLocation = table.getDataFileLocation(cfs.getExpectedCompactedFileSize(smallerSSTables));\n        }\n        if (compactionFileLocation == null)\n        {\n            logger.error(\"insufficient space to compact even the two smallest files, aborting\");\n            return 0;\n        }\n        sstables = smallerSSTables;\n\n        // new sstables from flush can be added during a compaction, but only the compaction can remove them,\n        // so in our single-threaded compaction world this is a valid way of determining if we're compacting\n        // all the sstables (that existed when we started)\n        boolean major = cfs.isCompleteSSTables(sstables);\n\n        long startTime = System.currentTimeMillis();\n        long totalkeysWritten = 0;\n\n        // TODO the int cast here is potentially buggy\n        int expectedBloomFilterSize = Math.max(SSTableReader.indexInterval(), (int)SSTableReader.getApproximateKeyCount(sstables));\n        if (logger.isDebugEnabled())\n          logger.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\n\n        SSTableWriter writer;\n        CompactionIterator ci = new CompactionIterator(sstables, gcBefore, major); // retain a handle so we can call close()\n        Iterator<AbstractCompactedRow> nni = new FilterIterator(ci, PredicateUtils.notNullPredicate());\n        executor.beginCompaction(cfs, ci);\n\n        try\n        {\n            if (!nni.hasNext())\n            {\n                // don't mark compacted in the finally block, since if there _is_ nondeleted data,\n                // we need to sync it (via closeAndOpen) first, so there is no period during which\n                // a crash could cause data loss.\n                cfs.markCompacted(sstables);\n                return 0;\n            }\n\n            String newFilename = new File(cfs.getTempSSTablePath(compactionFileLocation)).getAbsolutePath();\n            writer = new SSTableWriter(newFilename, expectedBloomFilterSize, StorageService.getPartitioner());\n            while (nni.hasNext())\n            {\n                AbstractCompactedRow row = nni.next();\n                long prevpos = writer.getFilePointer();\n\n                writer.append(row);\n                totalkeysWritten++;\n\n                long rowsize = writer.getFilePointer() - prevpos;\n                cfs.addToCompactedRowStats(rowsize);\n            }\n        }\n        finally\n        {\n            ci.close();\n        }\n\n        SSTableReader ssTable = writer.closeAndOpenReader(getMaxDataAge(sstables));\n        cfs.replaceCompactedSSTables(sstables, Arrays.asList(ssTable));\n        submitMinorIfNeeded(cfs);\n\n        String format = \"Compacted to %s.  %d/%d bytes for %d keys.  Time: %dms.\";\n        long dTime = System.currentTimeMillis() - startTime;\n        logger.info(String.format(format, writer.getFilename(), SSTable.getTotalBytes(sstables), ssTable.length(), totalkeysWritten, dTime));\n        return sstables.size();\n    }","id":44490,"modified_method":"/**\n     * For internal use and testing only.  The rest of the system should go through the submit* methods,\n     * which are properly serialized.\n     */\n    int doCompaction(ColumnFamilyStore cfs, Collection<SSTableReader> sstables, int gcBefore) throws IOException\n    {\n        // The collection of sstables passed may be empty (but not null); even if\n        // it is not empty, it may compact down to nothing if all rows are deleted.\n        Table table = cfs.getTable();\n        if (DatabaseDescriptor.isSnapshotBeforeCompaction())\n            table.snapshot(\"compact-\" + cfs.columnFamily_);\n        logger.info(\"Compacting [\" + StringUtils.join(sstables, \",\") + \"]\");\n        String compactionFileLocation = table.getDataFileLocation(cfs.getExpectedCompactedFileSize(sstables));\n        // If the compaction file path is null that means we have no space left for this compaction.\n        // try again w/o the largest one.\n        List<SSTableReader> smallerSSTables = new ArrayList<SSTableReader>(sstables);\n        while (compactionFileLocation == null && smallerSSTables.size() > 1)\n        {\n            logger.warn(\"insufficient space to compact all requested files \" + StringUtils.join(smallerSSTables, \", \"));\n            smallerSSTables.remove(cfs.getMaxSizeFile(smallerSSTables));\n            compactionFileLocation = table.getDataFileLocation(cfs.getExpectedCompactedFileSize(smallerSSTables));\n        }\n        if (compactionFileLocation == null)\n        {\n            logger.error(\"insufficient space to compact even the two smallest files, aborting\");\n            return 0;\n        }\n        sstables = smallerSSTables;\n\n        // new sstables from flush can be added during a compaction, but only the compaction can remove them,\n        // so in our single-threaded compaction world this is a valid way of determining if we're compacting\n        // all the sstables (that existed when we started)\n        boolean major = cfs.isCompleteSSTables(sstables);\n\n        long startTime = System.currentTimeMillis();\n        long totalkeysWritten = 0;\n\n        // TODO the int cast here is potentially buggy\n        int expectedBloomFilterSize = Math.max(SSTableReader.indexInterval(), (int)SSTableReader.getApproximateKeyCount(sstables));\n        if (logger.isDebugEnabled())\n          logger.debug(\"Expected bloom filter size : \" + expectedBloomFilterSize);\n\n        SSTableWriter writer;\n        CompactionIterator ci = new CompactionIterator(sstables, gcBefore, major); // retain a handle so we can call close()\n        Iterator<AbstractCompactedRow> nni = new FilterIterator(ci, PredicateUtils.notNullPredicate());\n        executor.beginCompaction(cfs, ci);\n\n        try\n        {\n            if (!nni.hasNext())\n            {\n                // don't mark compacted in the finally block, since if there _is_ nondeleted data,\n                // we need to sync it (via closeAndOpen) first, so there is no period during which\n                // a crash could cause data loss.\n                cfs.markCompacted(sstables);\n                return 0;\n            }\n\n            String newFilename = new File(cfs.getTempSSTablePath(compactionFileLocation)).getAbsolutePath();\n            writer = new SSTableWriter(newFilename, expectedBloomFilterSize, StorageService.getPartitioner());\n            while (nni.hasNext())\n            {\n                AbstractCompactedRow row = nni.next();\n                long prevpos = writer.getFilePointer();\n\n                writer.append(row);\n                totalkeysWritten++;\n\n                long rowsize = writer.getFilePointer() - prevpos;\n                cfs.addToCompactedRowStats(rowsize);\n            }\n        }\n        finally\n        {\n            ci.close();\n        }\n\n        SSTableReader ssTable = writer.closeAndOpenReader(getMaxDataAge(sstables));\n        cfs.replaceCompactedSSTables(sstables, Arrays.asList(ssTable));\n        submitMinorIfNeeded(cfs);\n\n        String format = \"Compacted to %s.  %,d to %,d (~%d%% of original) bytes for %,d keys.  Time: %,dms.\";\n        long dTime = System.currentTimeMillis() - startTime;\n        long startsize = SSTable.getTotalBytes(sstables);\n        long endsize = ssTable.length();\n        double ratio = (double)endsize / (double)startsize;\n        logger.info(String.format(format, writer.getFilename(), startsize, endsize, (int) (ratio * 100), totalkeysWritten, dTime));\n        return sstables.size();\n    }","commit_id":"b011752e150967db5241641b2592422a51f8ce18","url":"https://github.com/apache/cassandra"},{"original_method":"private SModel doGenerateModel(SModel inputModel, ITemplateGenerator generator) {\n    GeneratorSessionContext generatorContext = generator.getGeneratorSessionContext();\n    SModelDescriptor currentOutputModel = createTransientModel(0, inputModel, generatorContext.getModule());\n\n    // primary mapping\n    if (!generator.doPrimaryMapping(inputModel, currentOutputModel.getSModel())) {\n      SModel model = currentOutputModel.getSModel();\n      model.validateLanguagesAndImports();\n      return model;\n    }\n\n    // secondary mapping\n    int repeatCount = 1;\n    while (true) {\n      SModelDescriptor currentInputModel = currentOutputModel;\n      SModelDescriptor transientModel = createTransientModel(repeatCount, inputModel, generatorContext.getModule());\n      currentInputModel.getSModel().validateLanguagesAndImports();\n      myGeneratorSessionContext.replaceInputModel(currentInputModel);\n      if (!generator.doSecondaryMapping(currentInputModel.getSModel(), transientModel.getSModel(), repeatCount)) {\n        SModelRepository.getInstance().unRegisterModelDescriptor(transientModel, generatorContext.getModule());\n        break;\n      }\n\n      // next iteration ...\n      currentOutputModel = transientModel;\n      if (++repeatCount > 10) {\n        generator.showErrorMessage(null, \"Failed to generate output after 10 repeated mappings\");\n        throw new GenerationFailedException(\"Failed to generate output after 10 repeated mappings\");\n      }\n    }\n\n    return currentOutputModel.getSModel();\n  }","id":44491,"modified_method":"private SModel doGenerateModel(SModel inputModel, ITemplateGenerator generator) {\n    GeneratorSessionContext generatorContext = generator.getGeneratorSessionContext();\n    SModelDescriptor currentOutputModel = createTransientModel(0, inputModel, generatorContext.getModule());\n\n    // primary mapping\n    if (!generator.doPrimaryMapping(inputModel, currentOutputModel.getSModel())) {\n      SModel model = currentOutputModel.getSModel();\n      model.validateLanguagesAndImports();\n      return model;\n    }\n\n    // secondary mapping\n    SModelDescriptor transientModel;\n    int repeatCount = 1;\n    while (true) {\n      SModelDescriptor currentInputModel = currentOutputModel;\n      transientModel = createTransientModel(repeatCount, inputModel, generatorContext.getModule());\n      currentInputModel.getSModel().validateLanguagesAndImports();\n      List<String> languageNamespaces = currentInputModel.getSModel().getLanguageNamespaces();\n      if(languageNamespaces.size() == 1 && languageNamespaces.get(0).equals(myTargetLanguage.getNamespace())) {\n        break;\n      }\n      myGeneratorSessionContext.replaceInputModel(currentInputModel);\n      if (!generator.doSecondaryMapping(currentInputModel.getSModel(), transientModel.getSModel(), repeatCount)) {\n        break;\n      }\n      // next iteration ...\n      currentOutputModel = transientModel;\n      if (++repeatCount > 10) {\n        generator.showErrorMessage(null, \"Failed to generate output after 10 repeated mappings\");\n        throw new GenerationFailedException(\"Failed to generate output after 10 repeated mappings\");\n      }\n    }\n    SModelRepository.getInstance().unRegisterModelDescriptor(transientModel, generatorContext.getModule());\n    return currentOutputModel.getSModel();\n  }","commit_id":"6e417f1a20a8af3c0882c8fff494387527cb9629","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SModel doGenerateModel(SModel sourceModel, ITemplateGenerator generator) {\n    GeneratorSessionContext generatorContext = generator.getGeneratorSessionContext();\n    SModelDescriptor currentTargetModel = createTransientModel(0, sourceModel, generatorContext.getModule());\n    int iterationCount = 1;\n\n    // mapping\n    generator.doMapping(sourceModel, currentTargetModel.getSModel(), null);\n\n    // reductions...\n    while (true) {\n      SModelDescriptor currentSourceModel = currentTargetModel;\n\n      int numReductions = generator.prepareReduction(currentSourceModel.getSModel(), null);\n      while (numReductions == 0 && generator.hasPendingReductions()) {\n        numReductions = generator.preparePendingReduction();\n      }\n\n      generator.getProgressMonitor().addText(\"found reductions : \" + numReductions);\n      if (numReductions == 0) {\n        break;\n      }\n\n      currentTargetModel = createTransientModel(iterationCount, sourceModel, generatorContext.getModule());\n      generator.doReduction(currentTargetModel.getSModel());\n\n      // next iteration ...\n      if (++iterationCount > 10) {\n        generator.showErrorMessage(null, \"Failed to reduce model after 10 iterations\");\n        throw new GenerationFailedException(\"Failed to reduce model after 10 iterations\");\n      }\n    }\n\n    return currentTargetModel.getSModel();\n  }","id":44492,"modified_method":"private SModel doGenerateModel(SModel sourceModel, ITemplateGenerator generator) {\n    GeneratorSessionContext generatorContext = generator.getGeneratorSessionContext();\n    SModelDescriptor currentTargetModel = createTransientModel(0, sourceModel, generatorContext.getModule());\n    int iterationCount = 1;\n\n    // mapping\n    generator.doMapping(sourceModel, currentTargetModel.getSModel());\n\n    // reductions...\n    while (true) {\n      SModelDescriptor currentSourceModel = currentTargetModel;\n      SModelDescriptor transientModel = createTransientModel(iterationCount, sourceModel, generatorContext.getModule());\n      int numReductions = generator.prepareReduction(currentSourceModel.getSModel(), transientModel.getSModel());\n      while (numReductions == 0 && generator.hasPendingReductions()) {\n        numReductions = generator.preparePendingReduction();\n      }\n\n      generator.getProgressMonitor().addText(\"found reductions : \" + numReductions);\n      if (numReductions == 0) {\n        SModelRepository.getInstance().unRegisterModelDescriptor(transientModel, generatorContext.getModule());\n        break;\n      }\n\n      currentTargetModel = transientModel;\n      generator.doReduction();\n\n      // next iteration ...\n      if (++iterationCount > 10) {\n        generator.showErrorMessage(null, \"Failed to reduce model after 10 iterations\");\n        throw new GenerationFailedException(\"Failed to reduce model after 10 iterations\");\n      }\n    }\n\n    return currentTargetModel.getSModel();\n  }","commit_id":"217f06c10b1413d3ec4832d0b45d557929e61a06","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GenerationStatus generateModel(SModel sourceModel) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n    addProgressMessage(MessageKind.INFORMATION, \"generating model \\\"\" + sourceModel.getUID() + \"\\\"...\");\n    Class<? extends IModelGenerator> defaultGeneratorClass = getDefaultGeneratorClass();\n    addMessage(MessageKind.INFORMATION, \"    default generator class: \" + (defaultGeneratorClass != null ? defaultGeneratorClass.getName() : \"<n/a>\"));\n\n    // -- create generators list\n    List<Generator> generators = getGeneratorModiles(sourceModel);\n    if (generators.isEmpty()) {\n      addProgressMessage(MessageKind.WARNING, \"skip model \\\"\" + sourceModel.getUID() + \"\\\" : no generator avalable\");\n      return new GenerationStatus.OK(null);\n    }\n\n    // -- choose generator class\n    Class<? extends IModelGenerator> currentGeneratorClass = null;\n    for (Generator generator : generators) {\n      Class<? extends IModelGenerator> generatorClass = getGeneratorClass(generator);\n      addMessage(MessageKind.INFORMATION, \"    generator found: \" + generator.getModuleUID() + \" generator class: \" + (generatorClass != null ? generatorClass.getName() : \"<default>\"));\n      if (generatorClass != null) {\n        if (currentGeneratorClass == null) {\n          currentGeneratorClass = generatorClass;\n          continue;\n        }\n        if (currentGeneratorClass.isAssignableFrom(generatorClass)) {\n          currentGeneratorClass = generatorClass;\n        } else if (!generatorClass.isAssignableFrom(currentGeneratorClass)) {\n          addProgressMessage(MessageKind.ERROR, \"couldn't choose generator class\");\n          addMessage(MessageKind.ERROR, \"generator classes \\\"\" + currentGeneratorClass.getName() + \"\\\" and \" + generatorClass.getName() + \" are not compatible\");\n          return new GenerationStatus.ERROR();\n        }\n      }\n    }\n\n    if (currentGeneratorClass == null) {\n      if (defaultGeneratorClass == null) {\n        addProgressMessage(MessageKind.ERROR, \"generator class is not defined\");\n        return new GenerationStatus.ERROR();\n      }\n      currentGeneratorClass = defaultGeneratorClass;\n    }\n    addMessage(MessageKind.INFORMATION, \"    use generator class: \\\"\" + currentGeneratorClass + \"\\\"\");\n    GeneratorSessionContext generatorContext = new GeneratorSessionContext(myTargetLanguage, generators, myInvocationContext);\n    // templates or hand-coded?\n    if (!ITemplateGenerator.class.isAssignableFrom(currentGeneratorClass)) {\n      // hand-coded - not much to do ... just instantiate and invoke\n      IModelGenerator handCodedGenerator = currentGeneratorClass.getConstructor(IOperationContext.class).newInstance(generatorContext);\n      IProgressMonitor childMonitor = myProgressMonitor.startSubTask(GeneratorManager.AMOUNT_PER_MODEL);\n      SModel targetModel = JavaGenUtil.createTargetJavaModel(sourceModel, JavaNameUtil.packageNameForModelUID(sourceModel.getUID()), generatorContext);\n      handCodedGenerator.generate(sourceModel, targetModel, childMonitor);\n      childMonitor.finish();\n      return new GenerationStatus.OK(targetModel);\n    }\n\n    // templates generator\n    ITemplateGenerator generator = (ITemplateGenerator) currentGeneratorClass.getConstructor(GeneratorSessionContext.class, IProgressMonitor.class).newInstance(generatorContext, myProgressMonitor);\n    GenerationStatus status;\n    try {\n      SModel outputModel = doGenerateModel(sourceModel, generator);\n      boolean wasErrors = generator.getErrorCount() > 0;\n      addMessage(wasErrors ? MessageKind.WARNING : MessageKind.INFORMATION, \"model \\\"\" + sourceModel.getUID() + \"\\\" has been generated \" + (wasErrors ? \"with errors\" : \"successfully\"));\n      status = new GenerationStatus(outputModel, wasErrors, false);\n    } catch (GenerationCanceledException gce) {\n      status = new GenerationStatus.CANCELED(generator.getErrorCount() > 0);\n    } catch (GenerationFailedException gfe) {\n      myProgressMonitor.addText(gfe.toString());\n      GenerationFailueInfo failueInfo = gfe.getFailueInfo();\n      if (failueInfo != null) {\n        for (Message message : failueInfo.createMessages()) {\n          addMessage(message);\n        }\n      }\n      addMessage(MessageKind.ERROR, \"model \\\"\" + sourceModel.getUID() + \"\\\" generation failed : \" + gfe);\n      status = new GenerationStatus.ERROR();\n    } catch (Exception e) {\n      myProgressMonitor.addText(e.toString());\n      addMessage(MessageKind.ERROR, \"model \\\"\" + sourceModel.getUID() + \"\\\" generation failed : \" + e);\n      status = new GenerationStatus.ERROR();\n    }\n\n    // save transient models in session module\n    if (mySaveTransientModels) {\n      saveTransientModels(generatorContext);\n      generatorContext.getModule().dispose(); // unregister transient models\n    } else if (!status.isError()) {\n      // if ERROR - keep transient models: we need them to navigate to errors\n      generatorContext.getModule().dispose(); // unregister transient models\n    }\n\n    return status;\n  }","id":44493,"modified_method":"public GenerationStatus generateModel(SModel sourceModel) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {\n    addProgressMessage(MessageKind.INFORMATION, \"generating model \\\"\" + sourceModel.getUID() + \"\\\"...\");\n    Class<? extends IModelGenerator> defaultGeneratorClass = getDefaultGeneratorClass();\n    addMessage(MessageKind.INFORMATION, \"    default generator class: \" + (defaultGeneratorClass != null ? defaultGeneratorClass.getName() : \"<n/a>\"));\n\n    // -- create generators list\n    List<Generator> generators = getGeneratorModiles(sourceModel);\n    if (generators.isEmpty()) {\n      addProgressMessage(MessageKind.WARNING, \"skip model \\\"\" + sourceModel.getUID() + \"\\\" : no generator avalable\");\n      return new GenerationStatus.OK(null);\n    }\n\n    // -- choose generator class\n    Class<? extends IModelGenerator> currentGeneratorClass = null;\n    for (Generator generator : generators) {\n      Class<? extends IModelGenerator> generatorClass = getGeneratorClass(generator);\n      addMessage(MessageKind.INFORMATION, \"    generator found: \" + generator.getModuleUID() + \" generator class: \" + (generatorClass != null ? generatorClass.getName() : \"<default>\"));\n      if (generatorClass != null) {\n        if (currentGeneratorClass == null) {\n          currentGeneratorClass = generatorClass;\n          continue;\n        }\n        if (currentGeneratorClass.isAssignableFrom(generatorClass)) {\n          currentGeneratorClass = generatorClass;\n        } else if (!generatorClass.isAssignableFrom(currentGeneratorClass)) {\n          addProgressMessage(MessageKind.ERROR, \"couldn't choose generator class\");\n          addMessage(MessageKind.ERROR, \"generator classes \\\"\" + currentGeneratorClass.getName() + \"\\\" and \" + generatorClass.getName() + \" are not compatible\");\n          return new GenerationStatus.ERROR();\n        }\n      }\n    }\n\n    if (currentGeneratorClass == null) {\n      if (defaultGeneratorClass == null) {\n        addProgressMessage(MessageKind.ERROR, \"generator class is not defined\");\n        return new GenerationStatus.ERROR();\n      }\n      currentGeneratorClass = defaultGeneratorClass;\n    }\n    addMessage(MessageKind.INFORMATION, \"    use generator class: \\\"\" + currentGeneratorClass + \"\\\"\");\n    GeneratorSessionContext generatorContext = new GeneratorSessionContext(myTargetLanguage, generators, myInvocationContext);\n    // templates or hand-coded?\n    if (!ITemplateGenerator.class.isAssignableFrom(currentGeneratorClass)) {\n      // hand-coded - not much to do ... just instantiate and invoke\n      IModelGenerator handCodedGenerator = currentGeneratorClass.getConstructor(IOperationContext.class).newInstance(generatorContext);\n      IProgressMonitor childMonitor = myProgressMonitor.startSubTask(GeneratorManager.AMOUNT_PER_MODEL);\n      SModel targetModel = JavaGenUtil.createTargetJavaModel(sourceModel, JavaNameUtil.packageNameForModelUID(sourceModel.getUID()), generatorContext);\n      handCodedGenerator.generate(sourceModel, targetModel, childMonitor);\n      childMonitor.finish();\n      return new GenerationStatus.OK(targetModel);\n    }\n\n    // templates generator\n    ITemplateGenerator generator = (ITemplateGenerator) currentGeneratorClass.getConstructor(GeneratorSessionContext.class, IProgressMonitor.class).newInstance(generatorContext, myProgressMonitor);\n    GenerationStatus status;\n    try {\n      SModel outputModel = doGenerateModel(sourceModel, generator);\n      boolean wasErrors = generator.getErrorCount() > 0;\n      addMessage(wasErrors ? MessageKind.WARNING : MessageKind.INFORMATION, \"model \\\"\" + sourceModel.getUID() + \"\\\" has been generated \" + (wasErrors ? \"with errors\" : \"successfully\"));\n      status = new GenerationStatus(outputModel, wasErrors, false);\n    } catch (GenerationCanceledException gce) {\n      status = new GenerationStatus.CANCELED(generator.getErrorCount() > 0);\n    } catch (GenerationFailedException gfe) {\n      LOG.error(gfe);\n      myProgressMonitor.addText(gfe.toString());\n      GenerationFailueInfo failueInfo = gfe.getFailueInfo();\n      if (failueInfo != null) {\n        for (Message message : failueInfo.createMessages()) {\n          addMessage(message);\n        }\n      }\n      addMessage(MessageKind.ERROR, \"model \\\"\" + sourceModel.getUID() + \"\\\" generation failed : \" + gfe);\n      status = new GenerationStatus.ERROR();\n    } catch (Exception e) {\n      LOG.error(e);\n      myProgressMonitor.addText(e.toString());\n      addMessage(MessageKind.ERROR, \"model \\\"\" + sourceModel.getUID() + \"\\\" generation failed : \" + e);\n      status = new GenerationStatus.ERROR();\n    }\n\n    // save transient models in session module\n    if (mySaveTransientModels) {\n      saveTransientModels(generatorContext);\n      generatorContext.getModule().dispose(); // unregister transient models\n    } else if (!status.isError()) {\n      // if ERROR - keep transient models: we need them to navigate to errors\n      generatorContext.getModule().dispose(); // unregister transient models\n    }\n\n    return status;\n  }","commit_id":"217f06c10b1413d3ec4832d0b45d557929e61a06","url":"https://github.com/JetBrains/MPS"},{"original_method":"private SModel doGenerateModel(SModel inputModel, ITemplateGenerator generator) {\n    GeneratorSessionContext generatorContext = generator.getGeneratorSessionContext();\n    SModelDescriptor currentOutputModel = createTransientModel(0, inputModel, generatorContext.getModule());\n\n    // primary mapping\n    if (!generator.doPrimaryMapping(inputModel, currentOutputModel.getSModel())) {\n      SModel model = currentOutputModel.getSModel();\n      model.validateLanguagesAndImports();\n      return model;\n    }\n\n    // secondary mapping\n    SModelDescriptor transientModel;\n    int repeatCount = 1;\n    while (true) {\n      SModelDescriptor currentInputModel = currentOutputModel;\n      transientModel = createTransientModel(repeatCount, inputModel, generatorContext.getModule());\n      currentInputModel.getSModel().validateLanguagesAndImports();\n      List<String> languageNamespaces = currentInputModel.getSModel().getLanguageNamespaces();\n      if(languageNamespaces.size() == 1 && languageNamespaces.get(0).equals(myTargetLanguage.getNamespace())) {\n        break;\n      }\n      myGeneratorSessionContext.replaceInputModel(currentInputModel);\n      if (!generator.doSecondaryMapping(currentInputModel.getSModel(), transientModel.getSModel(), repeatCount)) {\n        break;\n      }\n      // next iteration ...\n      currentOutputModel = transientModel;\n      if (++repeatCount > 10) {\n        generator.showErrorMessage(null, \"Failed to generate output after 10 repeated mappings\");\n        throw new GenerationFailedException(\"Failed to generate output after 10 repeated mappings\");\n      }\n    }\n    SModelRepository.getInstance().unRegisterModelDescriptor(transientModel, generatorContext.getModule());\n    return currentOutputModel.getSModel();\n  }","id":44494,"modified_method":"private SModel doGenerateModel(SModel inputModel, ITemplateGenerator generator) {\n    GeneratorSessionContext generatorContext = generator.getGeneratorSessionContext();\n    SModelDescriptor currentOutputModel = createTransientModel(0, inputModel, generatorContext.getModule());\n\n    // primary mapping\n    if (!generator.doPrimaryMapping(inputModel, currentOutputModel.getSModel())) {\n      SModel model = currentOutputModel.getSModel();\n      model.validateLanguagesAndImports();\n      return model;\n    }\n\n    // secondary mapping\n    int repeatCount = 1;\n    while (true) {\n      currentOutputModel.getSModel().validateLanguagesAndImports();\n      // check exit condition (only the 'target language' is used in the output model)\n      List<String> languageNamespaces = currentOutputModel.getSModel().getLanguageNamespaces();\n      if(languageNamespaces.size() == 1 && languageNamespaces.get(0).equals(myTargetLanguage.getNamespace())) {\n        break;\n      }\n\n      // apply mapping to the output model\n      myGeneratorSessionContext.replaceInputModel(currentOutputModel);\n      SModelDescriptor currentInputModel = currentOutputModel;\n      SModelDescriptor transientModel = createTransientModel(repeatCount, inputModel, generatorContext.getModule());\n      if (!generator.doSecondaryMapping(currentInputModel.getSModel(), transientModel.getSModel(), repeatCount)) {\n        SModelRepository.getInstance().unRegisterModelDescriptor(transientModel, generatorContext.getModule());\n        break;\n      }\n\n      if (++repeatCount > 10) {\n        generator.showErrorMessage(null, \"Failed to generate output after 10 repeated mappings\");\n        throw new GenerationFailedException(\"Failed to generate output after 10 repeated mappings\");\n      }\n\n      // next iteration ...\n      currentOutputModel = transientModel;\n    }\n    return currentOutputModel.getSModel();\n  }","commit_id":"e036467a0886b1e3e85146112615d9fe1ecca101","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Configuration\n    public Option[] configuration() {\n        return OptionUtils.combine(launchpadConfiguration(),\n            editConfigurationFilePut(\"etc/custom.properties\", \"sling.run.modes\", \"oak,oak_tar\"),\n            addSlingFeatures(\n                \"sling-launchpad-oak-tar\"\n            ),\n            mavenBundle().groupId(\"org.apache.sling\").artifactId(\"org.apache.sling.jcr.jackrabbit.accessmanager\").version(\"2.1.2\"),\n            mavenBundle().groupId(\"org.apache.sling\").artifactId(\"org.apache.sling.jcr.jackrabbit.usermanager\").version(\"2.2.2\"),\n            // configurations for tests\n            editConfigurationFilePut(\"etc/integrationTestsConfig.cfg\", \"message\", \"This test config should be loaded at startup\"),\n            editConfigurationFilePut(\"etc/org.apache.sling.servlets.resolver.SlingServletResolver.cfg\", \"servletresolver.cacheSize\", \"0\")\n        );\n    }","id":44495,"modified_method":"@Configuration\n    public Option[] configuration() {\n        final int httpPort = 8888; // TODO findFreePort();\n        return OptionUtils.combine(baseConfiguration(),\n            cleanCaches(true),\n            editConfigurationFilePut(\"etc/org.ops4j.pax.logging.cfg\", \"log4j.rootLogger\", \"ERROR, out, sift, osgi:*\"),\n            // configurations for tests\n            editConfigurationFilePut(\"etc/custom.properties\", \"sling.run.modes\", \"oak,oak_tar\"),\n            editConfigurationFilePut(\"etc/users.properties\", \"admin\", \"admin,_g_:admingroup\"), // Sling\u2019s default admin credentials used in tests\n            editConfigurationFilePut(\"etc/org.ops4j.pax.web.cfg\", \"org.osgi.service.http.port\", Integer.toString(httpPort)),\n            editConfigurationFilePut(\"etc/integrationTestsConfig.cfg\", \"message\", \"This test config should be loaded at startup\"),\n            editConfigurationFilePut(\"etc/org.apache.sling.servlets.resolver.SlingServletResolver.cfg\", \"servletresolver.cacheSize\", \"0\"),\n            // TODO PAXWEB-935 editConfigurationFilePut(\"etc/org.apache.sling.jcr.webdav.impl.servlets.SimpleWebDavServlet.cfg\", \"dav.root\", \"/dav\"),\n            editConfigurationFilePut(\"etc/org.apache.sling.jcr.davex.impl.servlets.SlingDavExServlet.cfg\", \"alias\", \"/server\"),\n            addSlingFeatures(\n                \"sling-launchpad-oak-tar\",\n                \"sling-extension-discovery-standalone\",\n                \"sling-extension-event\",\n                \"sling-launchpad-content\",\n                \"sling-auth-form\",\n                \"sling-auth-openid\",\n                \"sling-auth-selector\",\n                \"sling-scripting-groovy\",\n                \"sling-scripting-javascript\",\n                \"sling-scripting-jsp\",\n                \"sling-installer-provider-jcr\",\n                \"sling-jcr-jackrabbit-security\"\n            ),\n            // misc (legacy, snapshots, ...) stuff\n            mavenBundle().groupId(\"org.apache.sling\").artifactId(\"org.apache.sling.servlets.compat\").versionAsInProject(),\n            // test support\n            mavenBundle().groupId(\"org.apache.sling\").artifactId(\"org.apache.sling.junit.core\").versionAsInProject(),\n            mavenBundle().groupId(\"org.apache.sling\").artifactId(\"org.apache.sling.junit.remote\").versionAsInProject(),\n            mavenBundle().groupId(\"org.apache.sling\").artifactId(\"org.apache.sling.junit.scriptable\").versionAsInProject(),\n            mavenBundle().groupId(\"org.apache.sling\").artifactId(\"org.apache.sling.launchpad.test-services\").versionAsInProject(),\n            mavenBundle().groupId(\"org.apache.sling\").artifactId(\"org.apache.sling.launchpad.test-fragment\").versionAsInProject(),\n            mavenBundle().groupId(\"org.apache.sling\").artifactId(\"org.apache.sling.testing.tools\").versionAsInProject(),\n            mavenBundle().groupId(\"org.apache.httpcomponents\").artifactId(\"httpcore-osgi\").versionAsInProject(),\n            mavenBundle().groupId(\"org.apache.httpcomponents\").artifactId(\"httpclient-osgi\").versionAsInProject(),\n            // TODO PAXWEB-935\n            mavenBundle().groupId(\"org.apache.sling\").artifactId(\"org.apache.sling.jcr.webdav\").version(\"2.2.2\")\n        );\n    }","commit_id":"93e38bbaf4e549e861533adbb5063136352816ce","url":"https://github.com/apache/sling"},{"original_method":"@Configuration\n    public Option[] configuration() throws IOException {\n        final int port = Network.getFreeServerPort();\n        // TODO find a way to start CouchDB with this port and do real tests\n        final String couchbaseHosts = String.format(\"localhost:%s\", port);\n        return OptionUtils.combine(baseConfiguration(),\n            editConfigurationFilePut(\"etc/org.apache.sling.nosql.couchbase.client.CouchbaseClient.factory.config.cfg\", \"couchbaseHosts\", couchbaseHosts),\n            addSlingFeatures(\"sling-launchpad-nosql-couchbase\")\n        );\n    }","id":44496,"modified_method":"@Configuration\n    public Option[] configuration() throws IOException, InterruptedException {\n        final int port = Network.getFreeServerPort();\n        startCouchbase(port);\n        final String couchbaseHosts = String.format(\"localhost:%s\", port);\n        return OptionUtils.combine(baseConfiguration(),\n            editConfigurationFilePut(\"etc/org.apache.karaf.features.cfg\", \"featuresBoot\", \"(wrap)\"),\n            editConfigurationFilePut(\"etc/org.apache.sling.nosql.couchbase.client.CouchbaseClient.factory.config.cfg\", \"couchbaseHosts\", couchbaseHosts),\n            editConfigurationFilePut(\"etc/org.apache.sling.nosql.couchbase.client.CouchbaseClient.factory.config.cfg\", \"clientId\", \"sling-resourceprovider-couchbase\"),\n            editConfigurationFilePut(\"etc/org.apache.sling.nosql.couchbase.client.CouchbaseClient.factory.config.cfg\", \"bucketName\", \"sling\"),\n            editConfigurationFilePut(\"etc/org.apache.sling.nosql.couchbase.client.CouchbaseClient.factory.config.cfg\", \"enabled\", \"true\"),\n            // wrappedBundle(mavenBundle().groupId(\"org.couchbase.mock\").artifactId(\"CouchbaseMock\").versionAsInProject()),\n            wrappedBundle(mavenBundle().groupId(\"com.couchbase.client\").artifactId(\"couchbase-client\").versionAsInProject()),\n            wrappedBundle(mavenBundle().groupId(\"com.intellij\").artifactId(\"annotations\").versionAsInProject()),\n            mavenBundle().groupId(\"com.google.code.gson\").artifactId(\"gson\").versionAsInProject(),\n            mavenBundle().groupId(\"com.googlecode.json-simple\").artifactId(\"json-simple\").versionAsInProject(),\n            mavenBundle().groupId(\"org.apache.servicemix.bundles\").artifactId(\"org.apache.servicemix.bundles.rhino\").versionAsInProject(),\n            mavenBundle().groupId(\"org.tukaani\").artifactId(\"xz\").versionAsInProject(),\n            addSlingFeatures(\"sling-launchpad-nosql-couchbase\")\n        );\n    }","commit_id":"e8b175486e51423498c619097fd62ea7cc615558","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @param theCpFile the cpFile to set\n     */\n    public void setCpFile( File theCpFile )\n    {\n        this.cpFile = theCpFile;\n    }","id":44497,"modified_method":"/**\n     * @param theCpFile the outputFile to set\n     */\n    public void setCpFile( File theCpFile )\n    {\n        this.outputFile = theCpFile;\n    }","commit_id":"afed470ec772a536af6b3044d72c74c62060d605","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Main entry into mojo. Gets the list of dependencies and iterates through calling copyArtifact.\n     * \n     * @throws MojoExecutionException with a message if an error occurs.\n     * @see #getDependencies\n     * @see #copyArtifact(Artifact, boolean)\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        // initialize the separators.\n        if ( StringUtils.isEmpty( fileSeparator ) )\n        {\n            isFileSepSet = false;\n        }\n        else\n        {\n            isFileSepSet = true;\n        }\n\n        if ( StringUtils.isEmpty( pathSeparator ) )\n        {\n            isPathSepSet = false;\n        }\n        else\n        {\n            isPathSepSet = true;\n        }\n\n        //don't allow them to have absolute paths when they attach.\n        if ( attach && StringUtils.isEmpty( localRepoProperty ) )\n        {\n            localRepoProperty = \"${M2_REPO}\";\n        }\n\n        Set artifacts = getResolvedDependencies( true );\n\n        if ( artifacts == null || artifacts.isEmpty() )\n        {\n            getLog().info( \"No dependencies found.\" );\n        }\n\n        List artList = new ArrayList( artifacts );\n\n        StringBuffer sb = new StringBuffer();\n        Iterator i = artList.iterator();\n\n        if ( i.hasNext() )\n        {\n            appendArtifactPath( (Artifact) i.next(), sb );\n\n            while ( i.hasNext() )\n            {\n                sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );\n                appendArtifactPath( (Artifact) i.next(), sb );\n            }\n        }\n\n        String cpString = sb.toString();\n\n        // if file separator is set, I need to replace the default one from all\n        // the file paths the where pulled from the artifacts\n        if ( isFileSepSet )\n        {\n            String separator = File.separator;\n\n            // if the file sep is \"\\\" then I need to escape it for the regex\n            if ( File.separator.equals( \"\\\\\" ) )\n            {\n                separator = \"\\\\\\\\\";\n            }\n\n            cpString = cpString.replaceAll( separator, fileSeparator );\n        }\n\n        //make the string valid for filtering\n        if (outputFilterFile)\n        {\n            cpString = \"classpath=\"+ cpString;\n        }\n        \n        if ( cpFile == null )\n        {\n            getLog().info( \"Dependencies classpath:\\n\" + cpString );\n        }\n        else\n        {\n            if ( regenerateFile || !isUpdToDate( cpString ) )\n            {\n                storeClasspathFile( cpString, cpFile );\n            }\n            else\n            {\n                this.getLog().info( \"Skipped writing classpath file '\" + cpFile + \"'.  No changes found.\" );\n            }\n        }\n        if ( attach )\n        {\n            attachFile( cpString );\n        }\n    }","id":44498,"modified_method":"/**\n     * Main entry into mojo. Gets the list of dependencies and iterates through calling copyArtifact.\n     * \n     * @throws MojoExecutionException with a message if an error occurs.\n     * @see #getDependencies\n     * @see #copyArtifact(Artifact, boolean)\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        \n        if (cpFile != null)\n        {\n            getLog().warn( \"The parameter cpFile is deprecated. Use outputFile instead.\" );\n            this.outputFile = cpFile;\n        }\n        \n        // initialize the separators.\n        if ( StringUtils.isEmpty( fileSeparator ) )\n        {\n            isFileSepSet = false;\n        }\n        else\n        {\n            isFileSepSet = true;\n        }\n\n        if ( StringUtils.isEmpty( pathSeparator ) )\n        {\n            isPathSepSet = false;\n        }\n        else\n        {\n            isPathSepSet = true;\n        }\n\n        //don't allow them to have absolute paths when they attach.\n        if ( attach && StringUtils.isEmpty( localRepoProperty ) )\n        {\n            localRepoProperty = \"${M2_REPO}\";\n        }\n\n        Set artifacts = getResolvedDependencies( true );\n\n        if ( artifacts == null || artifacts.isEmpty() )\n        {\n            getLog().info( \"No dependencies found.\" );\n        }\n\n        List artList = new ArrayList( artifacts );\n\n        StringBuffer sb = new StringBuffer();\n        Iterator i = artList.iterator();\n\n        if ( i.hasNext() )\n        {\n            appendArtifactPath( (Artifact) i.next(), sb );\n\n            while ( i.hasNext() )\n            {\n                sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );\n                appendArtifactPath( (Artifact) i.next(), sb );\n            }\n        }\n\n        String cpString = sb.toString();\n\n        // if file separator is set, I need to replace the default one from all\n        // the file paths the where pulled from the artifacts\n        if ( isFileSepSet )\n        {\n            String separator = File.separator;\n\n            // if the file sep is \"\\\" then I need to escape it for the regex\n            if ( File.separator.equals( \"\\\\\" ) )\n            {\n                separator = \"\\\\\\\\\";\n            }\n\n            cpString = cpString.replaceAll( separator, fileSeparator );\n        }\n\n        //make the string valid for filtering\n        if (outputFilterFile)\n        {\n            cpString = \"classpath=\"+ cpString;\n        }\n        \n        if ( outputFile == null )\n        {\n            getLog().info( \"Dependencies classpath:\\n\" + cpString );\n        }\n        else\n        {\n            if ( regenerateFile || !isUpdToDate( cpString ) )\n            {\n                storeClasspathFile( cpString, outputFile );\n            }\n            else\n            {\n                this.getLog().info( \"Skipped writing classpath file '\" + outputFile + \"'.  No changes found.\" );\n            }\n        }\n        if ( attach )\n        {\n            attachFile( cpString );\n        }\n    }","commit_id":"afed470ec772a536af6b3044d72c74c62060d605","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @return the cpFile\n     */\n    public File getCpFile()\n    {\n        return this.cpFile;\n    }","id":44499,"modified_method":"/**\n     * @return the outputFile\n     */\n    public File getCpFile()\n    {\n        return this.outputFile;\n    }","commit_id":"afed470ec772a536af6b3044d72c74c62060d605","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Checks that new classpath differs from that found inside the old classpathFile.\n     * \n     * @param cpString\n     * @return true if the specified classpath equals to that found inside the file, false otherwise (including when\n     *         file does not exists but new classpath does).\n     */\n    private boolean isUpdToDate( String cpString )\n    {\n        try\n        {\n            String oldCp = readClasspathFile();\n            return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );\n        }\n        catch ( Exception ex )\n        {\n            this.getLog().warn( \"Error while reading old classpath file '\" + cpFile + \"' for up-to-date check: \" + ex );\n\n            return false;\n        }\n    }","id":44500,"modified_method":"/**\n     * Checks that new classpath differs from that found inside the old classpathFile.\n     * \n     * @param cpString\n     * @return true if the specified classpath equals to that found inside the file, false otherwise (including when\n     *         file does not exists but new classpath does).\n     */\n    private boolean isUpdToDate( String cpString )\n    {\n        try\n        {\n            String oldCp = readClasspathFile();\n            return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );\n        }\n        catch ( Exception ex )\n        {\n            this.getLog().warn( \"Error while reading old classpath file '\" + outputFile + \"' for up-to-date check: \" + ex );\n\n            return false;\n        }\n    }","commit_id":"afed470ec772a536af6b3044d72c74c62060d605","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Reads into a string the file specified by the mojo param 'cpFile'. Assumes, the instance variable 'cpFile' is not\n     * null.\n     * \n     * @return the string contained in the classpathFile, if exists, or null ortherwise.\n     * @throws MojoExecutionException\n     */\n    protected String readClasspathFile()\n        throws IOException\n    {\n        if ( cpFile == null )\n        {\n            throw new IllegalArgumentException(\n                                                \"The cpFile parameter cannot be null if the file is intended to be read.\" );\n        }\n\n        if ( !cpFile.isFile() )\n        {\n            return null;\n        }\n        StringBuffer sb = new StringBuffer();\n        BufferedReader r = new BufferedReader( new FileReader( cpFile ) );\n\n        try\n        {\n            String l;\n            while ( ( l = r.readLine() ) != null )\n            {\n                sb.append( l );\n            }\n\n            return sb.toString();\n        }\n        finally\n        {\n            r.close();\n        }\n    }","id":44501,"modified_method":"/**\n     * Reads into a string the file specified by the mojo param 'outputFile'. Assumes, the instance variable 'outputFile' is not\n     * null.\n     * \n     * @return the string contained in the classpathFile, if exists, or null ortherwise.\n     * @throws MojoExecutionException\n     */\n    protected String readClasspathFile()\n        throws IOException\n    {\n        if ( outputFile == null )\n        {\n            throw new IllegalArgumentException(\n                                                \"The outputFile parameter cannot be null if the file is intended to be read.\" );\n        }\n\n        if ( !outputFile.isFile() )\n        {\n            return null;\n        }\n        StringBuffer sb = new StringBuffer();\n        BufferedReader r = new BufferedReader( new FileReader( outputFile ) );\n\n        try\n        {\n            String l;\n            while ( ( l = r.readLine() ) != null )\n            {\n                sb.append( l );\n            }\n\n            return sb.toString();\n        }\n        finally\n        {\n            r.close();\n        }\n    }","commit_id":"afed470ec772a536af6b3044d72c74c62060d605","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Main entry into mojo. Gets the list of dependencies and iterates through\n     * displaying the resolved version.\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        // get sets of dependencies\n        results = this.getDependencySets( false );\n\n        results.logStatus( getLog(), outputAbsoluteArtifactFilename, outputScope );\n    }","id":44502,"modified_method":"/**\n     * Main entry into mojo. Gets the list of dependencies and iterates through displaying the resolved version.\n     * \n     * @throws MojoExecutionException with a message if an error occurs.\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        // get sets of dependencies\n        results = this.getDependencySets( false );\n\n        String output = results.getOutput( outputAbsoluteArtifactFilename, outputScope );\n        try\n        {\n            if ( outputFile == null )\n            {\n                DependencyUtil.log( output, getLog() );\n            }\n            else\n            {\n                DependencyUtil.write( output, outputFile, getLog() );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException(e.getMessage(),e);\n        }\n    }","commit_id":"afed470ec772a536af6b3044d72c74c62060d605","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Main entry into mojo. Gets the list of dependencies and iterates through\n     * resolving the source jars.\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        this.classifier = SOURCE_CLASSIFIER;\n        this.type = SOURCE_TYPE;\n        // get sets of dependencies\n        results = this.getDependencySets( false );\n        \n        SourcesFileMarkerHandler handler = new SourcesFileMarkerHandler(this.markersDirectory);\n        handler.setResolved( true );\n        \n        Iterator iter = results.getResolvedDependencies().iterator();\n        while (iter.hasNext())\n        {\n            Artifact artifact = (Artifact) iter.next();\n            handler.setArtifact( artifact );\n            handler.setMarker();\n        }\n        \n        handler.setResolved( false );\n        iter = results.getUnResolvedDependencies().iterator();\n        while (iter.hasNext())\n        {\n            Artifact artifact = (Artifact) iter.next();\n            handler.setArtifact( artifact );\n            handler.setMarker();\n        }\n\n        results.logStatus( getLog(), outputAbsoluteArtifactFilename, false );\n    }","id":44503,"modified_method":"/**\n     * Main entry into mojo. Gets the list of dependencies and iterates through\n     * resolving the source jars.\n     * \n     * @throws MojoExecutionException\n     *             with a message if an error occurs.\n     * \n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        this.classifier = SOURCE_CLASSIFIER;\n        this.type = SOURCE_TYPE;\n        // get sets of dependencies\n        results = this.getDependencySets( false );\n        \n        SourcesFileMarkerHandler handler = new SourcesFileMarkerHandler(this.markersDirectory);\n        handler.setResolved( true );\n        \n        Iterator iter = results.getResolvedDependencies().iterator();\n        while (iter.hasNext())\n        {\n            Artifact artifact = (Artifact) iter.next();\n            handler.setArtifact( artifact );\n            handler.setMarker();\n        }\n        \n        handler.setResolved( false );\n        iter = results.getUnResolvedDependencies().iterator();\n        while (iter.hasNext())\n        {\n            Artifact artifact = (Artifact) iter.next();\n            handler.setArtifact( artifact );\n            handler.setMarker();\n        }\n\n        String output = results.getOutput( outputAbsoluteArtifactFilename, false );\n        try\n        {\n            if ( outputFile == null )\n            {\n                DependencyUtil.log( output, getLog() );\n            }\n            else\n            {\n                DependencyUtil.write( output, outputFile, getLog() );\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException(e.getMessage(),e);\n        }\n    }","commit_id":"afed470ec772a536af6b3044d72c74c62060d605","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testPath() throws Exception\n    {\n        File testPom = new File( getBasedir(), \"target/test-classes/unit/build-classpath-test/plugin-config.xml\" );\n        BuildClasspathMojo mojo = (BuildClasspathMojo) lookupMojo( \"build-classpath\", testPom );\n\n        assertNotNull( mojo );\n        assertNotNull( mojo.getProject() );\n        MavenProject project = mojo.getProject();\n        ArtifactRepository local = new StubArtifactRepository(stubFactory.getWorkingDir().getPath());\n        mojo.setLocal( local );\n        \n        Artifact artifact = stubFactory.getReleaseArtifact();\n       \n        \n        StringBuffer sb = new StringBuffer();\n        mojo.setPrefix( null );\n        mojo.setStripVersion( false );\n        mojo.appendArtifactPath( artifact, sb );\n        assertEquals(artifact.getFile().getPath(),sb.toString());\n        \n        mojo.setLocalRepoProperty( \"$M2_REPO\" );\n        sb.setLength( 0 );\n        mojo.appendArtifactPath( artifact, sb );\n        assertEquals(\"$M2_REPO\"+File.separator+artifact.getFile().getName(),sb.toString());\n        \n        mojo.setLocalRepoProperty( \"%M2_REPO%\" );\n        sb.setLength( 0 );\n        mojo.appendArtifactPath( artifact, sb );\n        assertEquals(\"%M2_REPO%\"+File.separator+artifact.getFile().getName(),sb.toString());\n        \n        mojo.setLocalRepoProperty( \"\" );\n        mojo.setPrefix( \"prefix\" );\n        sb.setLength( 0 );\n        mojo.appendArtifactPath( artifact, sb );\n        assertEquals(\"prefix\"+File.separator+artifact.getFile().getName(),sb.toString());\n      \n        mojo.setPrefix( \"prefix\" );\n        mojo.setStripVersion( true );\n        sb.setLength( 0 );\n        mojo.appendArtifactPath( artifact, sb );\n        assertEquals(\"prefix\"+File.separator+DependencyUtil.getFormattedFileName( artifact, true ),sb.toString());\n    }","id":44504,"modified_method":"public void testPath() throws Exception\n    {\n        File testPom = new File( getBasedir(), \"target/test-classes/unit/build-classpath-test/plugin-config.xml\" );\n        BuildClasspathMojo mojo = (BuildClasspathMojo) lookupMojo( \"build-classpath\", testPom );\n\n        assertNotNull( mojo );\n        assertNotNull( mojo.getProject() );\n\n        ArtifactRepository local = new StubArtifactRepository(stubFactory.getWorkingDir().getPath());\n        mojo.setLocal( local );\n        \n        Artifact artifact = stubFactory.getReleaseArtifact();\n       \n        \n        StringBuffer sb = new StringBuffer();\n        mojo.setPrefix( null );\n        mojo.setStripVersion( false );\n        mojo.appendArtifactPath( artifact, sb );\n        assertEquals(artifact.getFile().getPath(),sb.toString());\n        \n        mojo.setLocalRepoProperty( \"$M2_REPO\" );\n        sb.setLength( 0 );\n        mojo.appendArtifactPath( artifact, sb );\n        assertEquals(\"$M2_REPO\"+File.separator+artifact.getFile().getName(),sb.toString());\n        \n        mojo.setLocalRepoProperty( \"%M2_REPO%\" );\n        sb.setLength( 0 );\n        mojo.appendArtifactPath( artifact, sb );\n        assertEquals(\"%M2_REPO%\"+File.separator+artifact.getFile().getName(),sb.toString());\n        \n        mojo.setLocalRepoProperty( \"\" );\n        mojo.setPrefix( \"prefix\" );\n        sb.setLength( 0 );\n        mojo.appendArtifactPath( artifact, sb );\n        assertEquals(\"prefix\"+File.separator+artifact.getFile().getName(),sb.toString());\n      \n        mojo.setPrefix( \"prefix\" );\n        mojo.setStripVersion( true );\n        sb.setLength( 0 );\n        mojo.appendArtifactPath( artifact, sb );\n        assertEquals(\"prefix\"+File.separator+DependencyUtil.getFormattedFileName( artifact, true ),sb.toString());\n    }","commit_id":"afed470ec772a536af6b3044d72c74c62060d605","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void doTestDependencyStatusLog( Set artifacts )\n    {\n        // TODO: implement logger to check correct output\n        // this test is just looking for unexpected exceptions.\n        Log log = new SilentLog();\n\n        DependencyStatusSets dss = new DependencyStatusSets();\n        dss.logStatus( log, false );\n        dss.logStatus( log, true );\n\n        dss = new DependencyStatusSets( artifacts, null, null );\n        dss.logStatus( log, false );\n        dss.logStatus( log, true );\n\n        dss = new DependencyStatusSets( null, artifacts, null );\n        dss.logStatus( log, false );\n        dss.logStatus( log, true );\n\n        dss = new DependencyStatusSets( null, null, artifacts );\n        dss.logStatus( log, false );\n        dss.logStatus( log, true );\n\n        dss = new DependencyStatusSets( artifacts, artifacts, null );\n        dss.logStatus( log, false );\n        dss.logStatus( log, true );\n\n        dss = new DependencyStatusSets( null, artifacts, artifacts );\n        dss.logStatus( log, false );\n        dss.logStatus( log, true );\n\n        dss = new DependencyStatusSets( artifacts, null, artifacts );\n        dss.logStatus( log, false );\n        dss.logStatus( log, true );\n\n        dss = new DependencyStatusSets( artifacts, artifacts, artifacts );\n        dss.logStatus( log, false );\n        dss.logStatus( log, true );\n        dss.logStatus( log, false, true );\n        dss.logStatus( log, true, true );\n        dss.logStatus( log, false, false );\n        dss.logStatus( log, true, false );\n\n    }","id":44505,"modified_method":"public void doTestDependencyStatusLog( Set artifacts )\n    {\n        // TODO: implement logger to check correct output\n        // this test is just looking for unexpected exceptions.\n\n        DependencyStatusSets dss = new DependencyStatusSets();\n        dss.getOutput( false );\n        dss.getOutput( true );\n\n        dss = new DependencyStatusSets( artifacts, null, null );\n        dss.getOutput( false );\n        dss.getOutput( true );\n\n        dss = new DependencyStatusSets( null, artifacts, null );\n        dss.getOutput( false );\n        dss.getOutput( true );\n\n        dss = new DependencyStatusSets( null, null, artifacts );\n        dss.getOutput( false );\n        dss.getOutput( true );\n\n        dss = new DependencyStatusSets( artifacts, artifacts, null );\n        dss.getOutput( false );\n        dss.getOutput( true );\n\n        dss = new DependencyStatusSets( null, artifacts, artifacts );\n        dss.getOutput( false );\n        dss.getOutput( true );\n\n        dss = new DependencyStatusSets( artifacts, null, artifacts );\n        dss.getOutput( false );\n        dss.getOutput( true );\n\n        dss = new DependencyStatusSets( artifacts, artifacts, artifacts );\n        dss.getOutput( false );\n        dss.getOutput( true );\n        dss.getOutput( false, true );\n        dss.getOutput( true, true );\n        dss.getOutput( false, false );\n        dss.getOutput( true, false );\n\n    }","commit_id":"afed470ec772a536af6b3044d72c74c62060d605","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute() throws MojoExecutionException, MojoFailureException\n    {\n        ArtifactFilter artifactFilter = createResolvingArtifactFilter();\n\n        try\n        {\n            // TODO: note that filter does not get applied due to MNG-3236\n\n            rootNode =\n                dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory,\n                                                           artifactMetadataSource, artifactFilter, artifactCollector );\n\n            String dependencyTreeString = serialiseDependencyTree( rootNode );\n\n            if ( output != null )\n            {\n                write( dependencyTreeString, output );\n\n                getLog().info( \"Wrote dependency tree to: \" + output );\n            }\n            else\n            {\n                log( dependencyTreeString );\n            }\n        }\n        catch ( DependencyTreeBuilderException exception )\n        {\n            throw new MojoExecutionException( \"Cannot build project dependency tree\", exception );\n        }\n        catch ( IOException exception )\n        {\n            throw new MojoExecutionException( \"Cannot serialise project dependency tree\", exception );\n        }\n    }","id":44506,"modified_method":"public void execute() throws MojoExecutionException, MojoFailureException\n    {\n        if (output != null)\n        {\n            getLog().warn( \"The parameter output is deprecated. Use outputFile instead.\" );\n            this.outputFile = output;\n        }\n        \n        ArtifactFilter artifactFilter = createResolvingArtifactFilter();\n\n        try\n        {\n            // TODO: note that filter does not get applied due to MNG-3236\n\n            rootNode =\n                dependencyTreeBuilder.buildDependencyTree( project, localRepository, artifactFactory,\n                                                           artifactMetadataSource, artifactFilter, artifactCollector );\n\n            String dependencyTreeString = serialiseDependencyTree( rootNode );\n\n            if ( outputFile != null )\n            {\n                DependencyUtil.write( dependencyTreeString, outputFile, getLog() );\n\n                getLog().info( \"Wrote dependency tree to: \" + outputFile );\n            }\n            else\n            {\n                DependencyUtil.log( dependencyTreeString, getLog() );\n            }\n        }\n        catch ( DependencyTreeBuilderException exception )\n        {\n            throw new MojoExecutionException( \"Cannot build project dependency tree\", exception );\n        }\n        catch ( IOException exception )\n        {\n            throw new MojoExecutionException( \"Cannot serialise project dependency tree\", exception );\n        }\n    }","commit_id":"afed470ec772a536af6b3044d72c74c62060d605","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Test\n    public void testDuplicateAlias() throws Exception {\n        client().admin().indices().preparePutTemplate(\"template_1\")\n                .setTemplate(\"te*\")\n                .addAlias(new Alias(\"my_alias\").filter(FilterBuilders.termFilter(\"field\", \"value1\")))\n                .addAlias(new Alias(\"my_alias\").filter(FilterBuilders.termFilter(\"field\", \"value2\")))\n                .get();\n\n        GetIndexTemplatesResponse response = client().admin().indices().prepareGetTemplates(\"template_1\").get();\n        assertThat(response.getIndexTemplates().size(), equalTo(1));\n        assertThat(response.getIndexTemplates().get(0).getAliases().size(), equalTo(1));\n        assertThat(response.getIndexTemplates().get(0).getAliases().get(\"my_alias\").filter().string(), containsString(\"\\\"value1\\\"\"));\n    }","id":44507,"modified_method":"@Test\n    public void testDuplicateAlias() throws Exception {\n        client().admin().indices().preparePutTemplate(\"template_1\")\n                .setTemplate(\"te*\")\n                .addAlias(new Alias(\"my_alias\").filter(termFilter(\"field\", \"value1\")))\n                .addAlias(new Alias(\"my_alias\").filter(termFilter(\"field\", \"value2\")))\n                .get();\n\n        GetIndexTemplatesResponse response = client().admin().indices().prepareGetTemplates(\"template_1\").get();\n        assertThat(response.getIndexTemplates().size(), equalTo(1));\n        assertThat(response.getIndexTemplates().get(0).getAliases().size(), equalTo(1));\n        assertThat(response.getIndexTemplates().get(0).getAliases().get(\"my_alias\").filter().string(), containsString(\"\\\"value1\\\"\"));\n    }","commit_id":"13b9e07522a6cc96f7318fdc21c8a77b4f7d9b55","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doExecute(final IndexRequest request, final ActionListener<IndexResponse> listener) {\n        // if we don't have a master, we don't have metadata, that's fine, let it find a master using create index API\n        if (autoCreateIndex.shouldAutoCreate(request.index(), clusterService.state())) {\n            request.beforeLocalFork(); // we fork on another thread...\n            createIndexAction.execute(new CreateIndexRequest(request).index(request.index()).cause(\"auto(index api)\").masterNodeTimeout(request.timeout()), new ActionListener<CreateIndexResponse>() {\n                @Override\n                public void onResponse(CreateIndexResponse result) {\n                    innerExecute(request, listener);\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    if (ExceptionsHelper.unwrapCause(e) instanceof IndexAlreadyExistsException) {\n                        // we have the index, do it\n                        try {\n                            innerExecute(request, listener);\n                        } catch (Throwable e1) {\n                            listener.onFailure(e1);\n                        }\n                    } else {\n                        listener.onFailure(e);\n                    }\n                }\n            });\n        } else {\n            innerExecute(request, listener);\n        }\n    }","id":44508,"modified_method":"@Override\n    protected void doExecute(final IndexRequest request, final ActionListener<IndexResponse> listener) {\n        // if we don't have a master, we don't have metadata, that's fine, let it find a master using create index API\n        if (autoCreateIndex.shouldAutoCreate(request.index(), clusterService.state())) {\n            request.beforeLocalFork(); // we fork on another thread...\n            CreateIndexRequest createIndexRequest = new CreateIndexRequest(request);\n            createIndexRequest.index(request.index());\n            createIndexRequest.mapping(request.type());\n            createIndexRequest.cause(\"auto(index api)\");\n            createIndexRequest.masterNodeTimeout(request.timeout());\n            createIndexAction.execute(createIndexRequest, new ActionListener<CreateIndexResponse>() {\n                @Override\n                public void onResponse(CreateIndexResponse result) {\n                    innerExecute(request, listener);\n                }\n\n                @Override\n                public void onFailure(Throwable e) {\n                    if (ExceptionsHelper.unwrapCause(e) instanceof IndexAlreadyExistsException) {\n                        // we have the index, do it\n                        try {\n                            innerExecute(request, listener);\n                        } catch (Throwable e1) {\n                            listener.onFailure(e1);\n                        }\n                    } else {\n                        listener.onFailure(e);\n                    }\n                }\n            });\n        } else {\n            innerExecute(request, listener);\n        }\n    }","commit_id":"13b9e07522a6cc96f7318fdc21c8a77b4f7d9b55","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public ActionRequestValidationException validate() {\n        ActionRequestValidationException validationException = null;\n        return validationException;\n    }","id":44509,"modified_method":"@Override\n    public ActionRequestValidationException validate() {\n        return null;\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void clusterChanged(ClusterChangedEvent event) {\n        // update an index with number of replicas based on data nodes if possible\n        if (!event.state().nodes().localNodeMaster()) {\n            return;\n        }\n\n        Map<Integer, List<String>> nrReplicasChanged = new HashMap<Integer, List<String>>();\n\n        // we need to do this each time in case it was changed by update settings\n        for (final IndexMetaData indexMetaData : event.state().metaData()) {\n            String autoExpandReplicas = indexMetaData.settings().get(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS);\n            if (autoExpandReplicas != null && Booleans.parseBoolean(autoExpandReplicas, true)) { // Booleans only work for false values, just as we want it here\n                try {\n                    int min;\n                    int max;\n                    try {\n                        min = Integer.parseInt(autoExpandReplicas.substring(0, autoExpandReplicas.indexOf('-')));\n                        String sMax = autoExpandReplicas.substring(autoExpandReplicas.indexOf('-') + 1);\n                        if (sMax.equals(\"all\")) {\n                            max = event.state().nodes().dataNodes().size() - 1;\n                        } else {\n                            max = Integer.parseInt(sMax);\n                        }\n                    } catch (Exception e) {\n                        logger.warn(\"failed to set [{}], wrong format [{}]\", e, IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, autoExpandReplicas);\n                        continue;\n                    }\n\n                    int numberOfReplicas = event.state().nodes().dataNodes().size() - 1;\n                    if (numberOfReplicas < min) {\n                        numberOfReplicas = min;\n                    } else if (numberOfReplicas > max) {\n                        numberOfReplicas = max;\n                    }\n\n                    // same value, nothing to do there\n                    if (numberOfReplicas == indexMetaData.numberOfReplicas()) {\n                        continue;\n                    }\n\n                    if (numberOfReplicas >= min && numberOfReplicas <= max) {\n\n                        if (!nrReplicasChanged.containsKey(numberOfReplicas)) {\n                            nrReplicasChanged.put(numberOfReplicas, new ArrayList<String>());\n                        }\n\n                        nrReplicasChanged.get(numberOfReplicas).add(indexMetaData.index());\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"[{}] failed to parse auto expand replicas\", e, indexMetaData.index());\n                }\n            }\n        }\n\n        if (nrReplicasChanged.size() > 0) {\n            for (final Integer fNumberOfReplicas : nrReplicasChanged.keySet()) {\n                Settings settings = ImmutableSettings.settingsBuilder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, fNumberOfReplicas).build();\n                final List<String> indices = nrReplicasChanged.get(fNumberOfReplicas);\n\n                updateSettings(settings, indices.toArray(new String[indices.size()]), TimeValue.timeValueMinutes(10), new Listener() {\n                    @Override\n                    public void onSuccess() {\n                        for (String index : indices) {\n                            logger.info(\"[{}] auto expanded replicas to [{}]\", index, fNumberOfReplicas);\n                        }\n                    }\n\n                    @Override\n                    public void onFailure(Throwable t) {\n                        for (String index : indices) {\n                            logger.warn(\"[{}] fail to auto expand replicas to [{}]\", index, fNumberOfReplicas);\n                        }\n                    }\n                });\n            }\n        }\n    }","id":44510,"modified_method":"@Override\n    public void clusterChanged(ClusterChangedEvent event) {\n        // update an index with number of replicas based on data nodes if possible\n        if (!event.state().nodes().localNodeMaster()) {\n            return;\n        }\n\n        Map<Integer, List<String>> nrReplicasChanged = new HashMap<Integer, List<String>>();\n\n        // we need to do this each time in case it was changed by update settings\n        for (final IndexMetaData indexMetaData : event.state().metaData()) {\n            String autoExpandReplicas = indexMetaData.settings().get(IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS);\n            if (autoExpandReplicas != null && Booleans.parseBoolean(autoExpandReplicas, true)) { // Booleans only work for false values, just as we want it here\n                try {\n                    int min;\n                    int max;\n                    try {\n                        min = Integer.parseInt(autoExpandReplicas.substring(0, autoExpandReplicas.indexOf('-')));\n                        String sMax = autoExpandReplicas.substring(autoExpandReplicas.indexOf('-') + 1);\n                        if (sMax.equals(\"all\")) {\n                            max = event.state().nodes().dataNodes().size() - 1;\n                        } else {\n                            max = Integer.parseInt(sMax);\n                        }\n                    } catch (Exception e) {\n                        logger.warn(\"failed to set [{}], wrong format [{}]\", e, IndexMetaData.SETTING_AUTO_EXPAND_REPLICAS, autoExpandReplicas);\n                        continue;\n                    }\n\n                    int numberOfReplicas = event.state().nodes().dataNodes().size() - 1;\n                    if (numberOfReplicas < min) {\n                        numberOfReplicas = min;\n                    } else if (numberOfReplicas > max) {\n                        numberOfReplicas = max;\n                    }\n\n                    // same value, nothing to do there\n                    if (numberOfReplicas == indexMetaData.numberOfReplicas()) {\n                        continue;\n                    }\n\n                    if (numberOfReplicas >= min && numberOfReplicas <= max) {\n\n                        if (!nrReplicasChanged.containsKey(numberOfReplicas)) {\n                            nrReplicasChanged.put(numberOfReplicas, new ArrayList<String>());\n                        }\n\n                        nrReplicasChanged.get(numberOfReplicas).add(indexMetaData.index());\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"[{}] failed to parse auto expand replicas\", e, indexMetaData.index());\n                }\n            }\n        }\n\n        if (nrReplicasChanged.size() > 0) {\n            for (final Integer fNumberOfReplicas : nrReplicasChanged.keySet()) {\n                Settings settings = ImmutableSettings.settingsBuilder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, fNumberOfReplicas).build();\n                final List<String> indices = nrReplicasChanged.get(fNumberOfReplicas);\n\n                UpdateSettingsClusterStateUpdateRequest updateRequest = new UpdateSettingsClusterStateUpdateRequest()\n                        .indices(indices.toArray(new String[indices.size()])).settings(settings)\n                        .ackTimeout(TimeValue.timeValueMillis(0)) //no need to wait for ack here\n                        .masterNodeTimeout(TimeValue.timeValueMinutes(10));\n\n                updateSettings(updateRequest, new ClusterStateUpdateListener() {\n                    @Override\n                    public void onResponse(ClusterStateUpdateResponse response) {\n                        for (String index : indices) {\n                            logger.info(\"[{}] auto expanded replicas to [{}]\", index, fNumberOfReplicas);\n                        }\n                    }\n\n                    @Override\n                    public void onFailure(Throwable t) {\n                        for (String index : indices) {\n                            logger.warn(\"[{}] fail to auto expand replicas to [{}]\", index, fNumberOfReplicas);\n                        }\n                    }\n                });\n            }\n        }\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        UpdateSettingsRequest updateSettingsRequest = updateSettingsRequest(Strings.splitStringByCommaToArray(request.param(\"index\")));\n        updateSettingsRequest.listenerThreaded(false);\n        updateSettingsRequest.masterNodeTimeout(request.paramAsTime(\"master_timeout\", updateSettingsRequest.masterNodeTimeout()));\n\n        ImmutableSettings.Builder updateSettings = ImmutableSettings.settingsBuilder();\n        String bodySettingsStr = request.content().toUtf8();\n        if (Strings.hasText(bodySettingsStr)) {\n            try {\n                Settings buildSettings = ImmutableSettings.settingsBuilder().loadFromSource(bodySettingsStr).build();\n                for (Map.Entry<String, String> entry : buildSettings.getAsMap().entrySet()) {\n                    String key = entry.getKey();\n                    String value = entry.getValue();\n                    // clean up in case the body is wrapped with \"settings\" : { ... }\n                    if (key.startsWith(\"settings.\")) {\n                        key = key.substring(\"settings.\".length());\n                    }\n                    updateSettings.put(key, value);\n                }\n            } catch (Exception e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, BAD_REQUEST, new SettingsException(\"Failed to parse index settings\", e)));\n                } catch (IOException e1) {\n                    logger.warn(\"Failed to send response\", e1);\n                }\n                return;\n            }\n        }\n        for (Map.Entry<String, String> entry : request.params().entrySet()) {\n            if (entry.getKey().equals(\"pretty\")) {\n                continue;\n            }\n            updateSettings.put(entry.getKey(), entry.getValue());\n        }\n        updateSettingsRequest.settings(updateSettings);\n\n        client.admin().indices().updateSettings(updateSettingsRequest, new ActionListener<UpdateSettingsResponse>() {\n            @Override\n            public void onResponse(UpdateSettingsResponse updateSettingsResponse) {\n                try {\n                    XContentBuilder builder = RestXContentBuilder.restContentBuilder(request);\n                    builder.startObject()\n                            .field(\"ok\", true)\n                            .endObject();\n                    channel.sendResponse(new XContentRestResponse(request, OK, builder));\n                } catch (Throwable e) {\n                    onFailure(e);\n                }\n            }\n\n            @Override\n            public void onFailure(Throwable e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, e));\n                } catch (IOException e1) {\n                    logger.error(\"Failed to send failure response\", e1);\n                }\n            }\n        });\n    }","id":44511,"modified_method":"@Override\n    public void handleRequest(final RestRequest request, final RestChannel channel) {\n        UpdateSettingsRequest updateSettingsRequest = updateSettingsRequest(Strings.splitStringByCommaToArray(request.param(\"index\")));\n        updateSettingsRequest.listenerThreaded(false);\n        updateSettingsRequest.timeout(request.paramAsTime(\"timeout\", updateSettingsRequest.timeout()));\n        updateSettingsRequest.masterNodeTimeout(request.paramAsTime(\"master_timeout\", updateSettingsRequest.masterNodeTimeout()));\n\n        ImmutableSettings.Builder updateSettings = ImmutableSettings.settingsBuilder();\n        String bodySettingsStr = request.content().toUtf8();\n        if (Strings.hasText(bodySettingsStr)) {\n            try {\n                Settings buildSettings = ImmutableSettings.settingsBuilder().loadFromSource(bodySettingsStr).build();\n                for (Map.Entry<String, String> entry : buildSettings.getAsMap().entrySet()) {\n                    String key = entry.getKey();\n                    String value = entry.getValue();\n                    // clean up in case the body is wrapped with \"settings\" : { ... }\n                    if (key.startsWith(\"settings.\")) {\n                        key = key.substring(\"settings.\".length());\n                    }\n                    updateSettings.put(key, value);\n                }\n            } catch (Exception e) {\n                try {\n                    channel.sendResponse(new XContentThrowableRestResponse(request, BAD_REQUEST, new SettingsException(\"Failed to parse index settings\", e)));\n                } catch (IOException e1) {\n                    logger.warn(\"Failed to send response\", e1);\n                }\n                return;\n            }\n        }\n        for (Map.Entry<String, String> entry : request.params().entrySet()) {\n            if (entry.getKey().equals(\"pretty\")) {\n                continue;\n            }\n            updateSettings.put(entry.getKey(), entry.getValue());\n        }\n        updateSettingsRequest.settings(updateSettings);\n\n        client.admin().indices().updateSettings(updateSettingsRequest, new AcknowledgedRestResponseActionListener<UpdateSettingsResponse>(request, channel, logger));\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void masterOperation(final UpdateSettingsRequest request, final ClusterState state, final ActionListener<UpdateSettingsResponse> listener) throws ElasticSearchException {\n        updateSettingsService.updateSettings(request.settings(), request.indices(), request.masterNodeTimeout(), new MetaDataUpdateSettingsService.Listener() {\n            @Override\n            public void onSuccess() {\n                listener.onResponse(new UpdateSettingsResponse());\n            }\n\n            @Override\n            public void onFailure(Throwable t) {\n                logger.debug(\"failed to update settings on indices [{}]\", t, request.indices());\n                listener.onFailure(t);\n            }\n        });\n    }","id":44512,"modified_method":"@Override\n    protected void masterOperation(final UpdateSettingsRequest request, final ClusterState state, final ActionListener<UpdateSettingsResponse> listener) throws ElasticSearchException {\n\n        UpdateSettingsClusterStateUpdateRequest clusterStateUpdateRequest = new UpdateSettingsClusterStateUpdateRequest()\n                .indices(request.indices())\n                .settings(request.settings())\n                .ackTimeout(request.timeout())\n                .masterNodeTimeout(request.masterNodeTimeout());\n\n        updateSettingsService.updateSettings(clusterStateUpdateRequest, new ClusterStateUpdateListener() {\n            @Override\n            public void onResponse(ClusterStateUpdateResponse response) {\n                listener.onResponse(new UpdateSettingsResponse(response.isAcknowledged()));\n            }\n\n            @Override\n            public void onFailure(Throwable t) {\n                logger.debug(\"failed to update settings on indices [{}]\", t, request.indices());\n                listener.onFailure(t);\n            }\n        });\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        indices = in.readStringArray();\n        settings = readSettingsFromStream(in);\n    }","id":44513,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        indices = in.readStringArray();\n        settings = readSettingsFromStream(in);\n        readTimeout(in, Version.V_0_90_6);\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * The settings to crete the index with (either json/yaml/properties format)\n     */\n    public UpdateSettingsRequest settings(Map source) {\n        try {\n            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n            builder.map(source);\n            settings(builder.string());\n        } catch (IOException e) {\n            throw new ElasticSearchGenerationException(\"Failed to generate [\" + source + \"]\", e);\n        }\n        return this;\n    }","id":44514,"modified_method":"/**\n     * Sets the settings to be updated (either json/yaml/properties format)\n     */\n    @SuppressWarnings(\"unchecked\")\n    public UpdateSettingsRequest settings(Map source) {\n        try {\n            XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON);\n            builder.map(source);\n            settings(builder.string());\n        } catch (IOException e) {\n            throw new ElasticSearchGenerationException(\"Failed to generate [\" + source + \"]\", e);\n        }\n        return this;\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeStringArrayNullable(indices);\n        writeSettingsToStream(settings, out);\n    }","id":44515,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        out.writeStringArrayNullable(indices);\n        writeSettingsToStream(settings, out);\n        writeTimeout(out, Version.V_0_90_6);\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public UpdateSettingsRequest indices(String... indices) {\n        this.indices = indices;\n        return this;\n    }","id":44516,"modified_method":"/**\n     * Sets the indices to apply to settings update to\n     */\n    public UpdateSettingsRequest indices(String... indices) {\n        this.indices = indices;\n        return this;\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public UpdateSettingsRequestBuilder setIndices(String... indices) {\n        request.indices(indices);\n        return this;\n    }","id":44517,"modified_method":"/**\n     * Sets the indices the update settings will execute on\n     */\n    public UpdateSettingsRequestBuilder setIndices(String... indices) {\n        request.indices(indices);\n        return this;\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n    }","id":44518,"modified_method":"@Override\n    public void writeTo(StreamOutput out) throws IOException {\n        super.writeTo(out);\n        writeAcknowledged(out, Version.V_0_90_6);\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n    }","id":44519,"modified_method":"@Override\n    public void readFrom(StreamInput in) throws IOException {\n        super.readFrom(in);\n        readAcknowledged(in, Version.V_0_90_6);\n    }","commit_id":"5f1ebf20f74219d730e3ea55591a29dccbcff598","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Request(String[] nodesIds) {\n            super(nodesIds);\n        }","id":44520,"modified_method":"public Request(ActionRequest request, String[] nodesIds) {\n            super(request, nodesIds);\n        }","commit_id":"aa6bf5fd1d67f0d17fce87c647f56f7967bd373d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void masterOperation(final SnapshotsStatusRequest request,\n                                   final ClusterState state,\n                                   final ActionListener<SnapshotsStatusResponse> listener) throws Exception {\n        ImmutableList<SnapshotMetaData.Entry> currentSnapshots = snapshotsService.currentSnapshots(request.repository(), request.snapshots());\n\n        if (currentSnapshots.isEmpty()) {\n            listener.onResponse(buildResponse(request, currentSnapshots, null));\n            return;\n        }\n\n        Set<String> nodesIds = newHashSet();\n        for (SnapshotMetaData.Entry entry : currentSnapshots) {\n            for (SnapshotMetaData.ShardSnapshotStatus status : entry.shards().values()) {\n                if (status.nodeId() != null) {\n                    nodesIds.add(status.nodeId());\n                }\n            }\n        }\n\n        if (!nodesIds.isEmpty()) {\n            // There are still some snapshots running - check their progress\n            SnapshotId[] snapshotIds = new SnapshotId[currentSnapshots.size()];\n            for (int i = 0; i < currentSnapshots.size(); i++) {\n                snapshotIds[i] = currentSnapshots.get(i).snapshotId();\n            }\n\n            transportNodesSnapshotsStatus.status(nodesIds.toArray(new String[nodesIds.size()]),\n                    snapshotIds, request.masterNodeTimeout(), new ActionListener<TransportNodesSnapshotsStatus.NodesSnapshotStatus>() {\n                        @Override\n                        public void onResponse(TransportNodesSnapshotsStatus.NodesSnapshotStatus nodeSnapshotStatuses) {\n                            try {\n                                ImmutableList<SnapshotMetaData.Entry> currentSnapshots =\n                                        snapshotsService.currentSnapshots(request.repository(), request.snapshots());\n                                listener.onResponse(buildResponse(request, currentSnapshots, nodeSnapshotStatuses));\n                            } catch (Throwable e) {\n                                listener.onFailure(e);\n                            }\n                        }\n\n                        @Override\n                        public void onFailure(Throwable e) {\n                            listener.onFailure(e);\n                        }\n                    });\n        } else {\n            // We don't have any in-progress shards, just return current stats\n            listener.onResponse(buildResponse(request, currentSnapshots, null));\n        }\n\n    }","id":44521,"modified_method":"@Override\n    protected void masterOperation(final SnapshotsStatusRequest request,\n                                   final ClusterState state,\n                                   final ActionListener<SnapshotsStatusResponse> listener) throws Exception {\n        ImmutableList<SnapshotMetaData.Entry> currentSnapshots = snapshotsService.currentSnapshots(request.repository(), request.snapshots());\n\n        if (currentSnapshots.isEmpty()) {\n            listener.onResponse(buildResponse(request, currentSnapshots, null));\n            return;\n        }\n\n        Set<String> nodesIds = newHashSet();\n        for (SnapshotMetaData.Entry entry : currentSnapshots) {\n            for (SnapshotMetaData.ShardSnapshotStatus status : entry.shards().values()) {\n                if (status.nodeId() != null) {\n                    nodesIds.add(status.nodeId());\n                }\n            }\n        }\n\n        if (!nodesIds.isEmpty()) {\n            // There are still some snapshots running - check their progress\n            SnapshotId[] snapshotIds = new SnapshotId[currentSnapshots.size()];\n            for (int i = 0; i < currentSnapshots.size(); i++) {\n                snapshotIds[i] = currentSnapshots.get(i).snapshotId();\n            }\n\n            TransportNodesSnapshotsStatus.Request nodesRequest = new TransportNodesSnapshotsStatus.Request(request, nodesIds.toArray(new String[nodesIds.size()]))\n                    .snapshotIds(snapshotIds).timeout(request.masterNodeTimeout());\n            transportNodesSnapshotsStatus.execute(nodesRequest, new ActionListener<TransportNodesSnapshotsStatus.NodesSnapshotStatus>() {\n                        @Override\n                        public void onResponse(TransportNodesSnapshotsStatus.NodesSnapshotStatus nodeSnapshotStatuses) {\n                            try {\n                                ImmutableList<SnapshotMetaData.Entry> currentSnapshots =\n                                        snapshotsService.currentSnapshots(request.repository(), request.snapshots());\n                                listener.onResponse(buildResponse(request, currentSnapshots, nodeSnapshotStatuses));\n                            } catch (Throwable e) {\n                                listener.onFailure(e);\n                            }\n                        }\n\n                        @Override\n                        public void onFailure(Throwable e) {\n                            listener.onFailure(e);\n                        }\n                    });\n        } else {\n            // We don't have any in-progress shards, just return current stats\n            listener.onResponse(buildResponse(request, currentSnapshots, null));\n        }\n\n    }","commit_id":"aa6bf5fd1d67f0d17fce87c647f56f7967bd373d","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testStrictAliasParsingInIndicesCreatedViaTemplates() throws Exception {\n        // Indexing into a should succeed, because the field mapping for field 'field' is defined in the test mapping.\n        client().admin().indices().preparePutTemplate(\"template1\")\n                .setTemplate(\"a\")\n                .setOrder(0)\n                .addMapping(\"test\", \"field\", \"type=string\")\n                .addAlias(new Alias(\"alias1\").filter(termFilter(\"field\", \"value\"))).get();\n        // Indexing into b should succeed, because the field mapping for field 'field' is defined in the _default_ mapping and the test type exists.\n        client().admin().indices().preparePutTemplate(\"template2\")\n                .setTemplate(\"b\")\n                .setOrder(0)\n                .addMapping(\"_default_\", \"field\", \"type=string\")\n                .addMapping(\"test\")\n                .addAlias(new Alias(\"alias2\").filter(termFilter(\"field\", \"value\"))).get();\n        // Indexing into c should succeed, because the field mapping for field 'field' is defined in the _default_ mapping.\n        client().admin().indices().preparePutTemplate(\"template3\")\n                .setTemplate(\"c\")\n                .setOrder(0)\n                .addMapping(\"_default_\", \"field\", \"type=string\")\n                .addAlias(new Alias(\"alias3\").filter(termFilter(\"field\", \"value\"))).get();\n        // Indexing into d index should fail, since there is field with name 'field' in the mapping\n        client().admin().indices().preparePutTemplate(\"template4\")\n                .setTemplate(\"d\")\n                .setOrder(0)\n                .addAlias(new Alias(\"alias4\").filter(termFilter(\"field\", \"value\"))).get();\n\n        client().prepareIndex(\"a\", \"test\", \"test\").setSource(\"{}\").get();\n        client().prepareIndex(\"b\", \"test\", \"test\").setSource(\"{}\").get();\n        client().prepareIndex(\"c\", \"test\", \"test\").setSource(\"{}\").get();\n        try {\n            client().prepareIndex(\"d\", \"test\", \"test\").setSource(\"{}\").get();\n            fail();\n        } catch (Exception e) {\n            assertThat(ExceptionsHelper.unwrapCause(e), instanceOf(ElasticsearchIllegalArgumentException.class));\n            assertThat(e.getMessage(), containsString(\"failed to parse filter for alias [alias4]\"));\n        }\n    }","id":44522,"modified_method":"@Test\n    public void testStrictAliasParsingInIndicesCreatedViaTemplates() throws Exception {\n        // Indexing into a should succeed, because the field mapping for field 'field' is defined in the test mapping.\n        client().admin().indices().preparePutTemplate(\"template1\")\n                .setTemplate(\"a*\")\n                .setOrder(0)\n                .addMapping(\"test\", \"field\", \"type=string\")\n                .addAlias(new Alias(\"alias1\").filter(termFilter(\"field\", \"value\"))).get();\n        // Indexing into b should succeed, because the field mapping for field 'field' is defined in the _default_ mapping and the test type exists.\n        client().admin().indices().preparePutTemplate(\"template2\")\n                .setTemplate(\"b*\")\n                .setOrder(0)\n                .addMapping(\"_default_\", \"field\", \"type=string\")\n                .addMapping(\"test\")\n                .addAlias(new Alias(\"alias2\").filter(termFilter(\"field\", \"value\"))).get();\n        // Indexing into c should succeed, because the field mapping for field 'field' is defined in the _default_ mapping.\n        client().admin().indices().preparePutTemplate(\"template3\")\n                .setTemplate(\"c*\")\n                .setOrder(0)\n                .addMapping(\"_default_\", \"field\", \"type=string\")\n                .addAlias(new Alias(\"alias3\").filter(termFilter(\"field\", \"value\"))).get();\n        // Indexing into d index should fail, since there is field with name 'field' in the mapping\n        client().admin().indices().preparePutTemplate(\"template4\")\n                .setTemplate(\"d*\")\n                .setOrder(0)\n                .addAlias(new Alias(\"alias4\").filter(termFilter(\"field\", \"value\"))).get();\n\n        client().prepareIndex(\"a1\", \"test\", \"test\").setSource(\"{}\").get();\n        BulkResponse response = client().prepareBulk().add(new IndexRequest(\"a2\", \"test\", \"test\").source(\"{}\")).get();\n        assertThat(response.hasFailures(), is(false));\n        assertThat(response.getItems()[0].isFailed(), equalTo(false));\n        assertThat(response.getItems()[0].getIndex(), equalTo(\"a2\"));\n        assertThat(response.getItems()[0].getType(), equalTo(\"test\"));\n        assertThat(response.getItems()[0].getId(), equalTo(\"test\"));\n        assertThat(response.getItems()[0].getVersion(), equalTo(1l));\n\n        client().prepareIndex(\"b1\", \"test\", \"test\").setSource(\"{}\").get();\n        response = client().prepareBulk().add(new IndexRequest(\"b2\", \"test\", \"test\").source(\"{}\")).get();\n        assertThat(response.hasFailures(), is(false));\n        assertThat(response.getItems()[0].isFailed(), equalTo(false));\n        assertThat(response.getItems()[0].getIndex(), equalTo(\"b2\"));\n        assertThat(response.getItems()[0].getType(), equalTo(\"test\"));\n        assertThat(response.getItems()[0].getId(), equalTo(\"test\"));\n        assertThat(response.getItems()[0].getVersion(), equalTo(1l));\n\n        client().prepareIndex(\"c1\", \"test\", \"test\").setSource(\"{}\").get();\n        response = client().prepareBulk().add(new IndexRequest(\"c2\", \"test\", \"test\").source(\"{}\")).get();\n        assertThat(response.hasFailures(), is(false));\n        assertThat(response.getItems()[0].isFailed(), equalTo(false));\n        assertThat(response.getItems()[0].getIndex(), equalTo(\"c2\"));\n        assertThat(response.getItems()[0].getType(), equalTo(\"test\"));\n        assertThat(response.getItems()[0].getId(), equalTo(\"test\"));\n        assertThat(response.getItems()[0].getVersion(), equalTo(1l));\n\n        try {\n            client().prepareIndex(\"d1\", \"test\", \"test\").setSource(\"{}\").get();\n            fail();\n        } catch (Exception e) {\n            assertThat(ExceptionsHelper.unwrapCause(e), instanceOf(ElasticsearchIllegalArgumentException.class));\n            assertThat(e.getMessage(), containsString(\"failed to parse filter for alias [alias4]\"));\n        }\n        response = client().prepareBulk().add(new IndexRequest(\"d2\", \"test\", \"test\").source(\"{}\")).get();\n        assertThat(response.hasFailures(), is(true));\n        assertThat(response.getItems()[0].isFailed(), equalTo(true));\n        assertThat(response.getItems()[0].getFailureMessage(), containsString(\"failed to parse filter for alias [alias4]\"));\n    }","commit_id":"dd4a22bfedf4a3c0c34ea598dfd97903d09b6396","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected void doExecute(final BulkRequest bulkRequest, final ActionListener<BulkResponse> listener) {\n        final long startTime = System.currentTimeMillis();\n        final AtomicArray<BulkItemResponse> responses = new AtomicArray<>(bulkRequest.requests.size());\n\n        if (autoCreateIndex.needToCheck()) {\n            final Set<String> indices = Sets.newHashSet();\n            for (ActionRequest request : bulkRequest.requests) {\n                if (request instanceof DocumentRequest) {\n                    DocumentRequest req = (DocumentRequest) request;\n                    if (!indices.contains(req.index())) {\n                        indices.add(req.index());\n                    }\n                } else {\n                    throw new ElasticsearchException(\"Parsed unknown request in bulk actions: \" + request.getClass().getSimpleName());\n                }\n            }\n            final AtomicInteger counter = new AtomicInteger(indices.size());\n            ClusterState state = clusterService.state();\n            for (final String index : indices) {\n                if (autoCreateIndex.shouldAutoCreate(index, state)) {\n                    createIndexAction.execute(new CreateIndexRequest(bulkRequest).index(index).cause(\"auto(bulk api)\").masterNodeTimeout(bulkRequest.timeout()), new ActionListener<CreateIndexResponse>() {\n                        @Override\n                        public void onResponse(CreateIndexResponse result) {\n                            if (counter.decrementAndGet() == 0) {\n                                try {\n                                    executeBulk(bulkRequest, startTime, listener, responses);\n                                } catch (Throwable t) {\n                                    listener.onFailure(t);\n                                }\n                            }\n                        }\n\n                        @Override\n                        public void onFailure(Throwable e) {\n                            if (!(ExceptionsHelper.unwrapCause(e) instanceof IndexAlreadyExistsException)) {\n                                // fail all requests involving this index, if create didnt work\n                                for (int i = 0; i < bulkRequest.requests.size(); i++) {\n                                    ActionRequest request = bulkRequest.requests.get(i);\n                                    if (request != null && setResponseFailureIfIndexMatches(responses, i, request, index, e)) {\n                                        bulkRequest.requests.set(i, null);\n                                    }\n                                }\n                            }\n                            if (counter.decrementAndGet() == 0) {\n                                try {\n                                    executeBulk(bulkRequest, startTime, listener, responses);\n                                } catch (Throwable t) {\n                                    listener.onFailure(t);\n                                }\n                            }\n                        }\n                    });\n                } else {\n                    if (counter.decrementAndGet() == 0) {\n                        executeBulk(bulkRequest, startTime, listener, responses);\n                    }\n                }\n            }\n        } else {\n            executeBulk(bulkRequest, startTime, listener, responses);\n        }\n    }","id":44523,"modified_method":"@Override\n    protected void doExecute(final BulkRequest bulkRequest, final ActionListener<BulkResponse> listener) {\n        final long startTime = System.currentTimeMillis();\n        final AtomicArray<BulkItemResponse> responses = new AtomicArray<>(bulkRequest.requests.size());\n\n        if (autoCreateIndex.needToCheck()) {\n            // Keep track of all unique indices and all unique types per index for the create index requests:\n            final Map<String, Set<String>> indicesAndTypes = new HashMap<>();\n            for (ActionRequest request : bulkRequest.requests) {\n                if (request instanceof DocumentRequest) {\n                    DocumentRequest req = (DocumentRequest) request;\n                    Set<String> types = indicesAndTypes.get(req.index());\n                    if (types == null) {\n                        indicesAndTypes.put(req.index(), types = new HashSet<>());\n                    }\n                    types.add(req.type());\n                } else {\n                    throw new ElasticsearchException(\"Parsed unknown request in bulk actions: \" + request.getClass().getSimpleName());\n                }\n            }\n            final AtomicInteger counter = new AtomicInteger(indicesAndTypes.size());\n            ClusterState state = clusterService.state();\n            for (Map.Entry<String, Set<String>> entry : indicesAndTypes.entrySet()) {\n                final String index = entry.getKey();\n                if (autoCreateIndex.shouldAutoCreate(index, state)) {\n                    CreateIndexRequest createIndexRequest = new CreateIndexRequest(bulkRequest);\n                    createIndexRequest.index(index);\n                    for (String type : entry.getValue()) {\n                        createIndexRequest.mapping(type);\n                    }\n                    createIndexRequest.cause(\"auto(bulk api)\");\n                    createIndexRequest.masterNodeTimeout(bulkRequest.timeout());\n                    createIndexAction.execute(createIndexRequest, new ActionListener<CreateIndexResponse>() {\n                        @Override\n                        public void onResponse(CreateIndexResponse result) {\n                            if (counter.decrementAndGet() == 0) {\n                                try {\n                                    executeBulk(bulkRequest, startTime, listener, responses);\n                                } catch (Throwable t) {\n                                    listener.onFailure(t);\n                                }\n                            }\n                        }\n\n                        @Override\n                        public void onFailure(Throwable e) {\n                            if (!(ExceptionsHelper.unwrapCause(e) instanceof IndexAlreadyExistsException)) {\n                                // fail all requests involving this index, if create didnt work\n                                for (int i = 0; i < bulkRequest.requests.size(); i++) {\n                                    ActionRequest request = bulkRequest.requests.get(i);\n                                    if (request != null && setResponseFailureIfIndexMatches(responses, i, request, index, e)) {\n                                        bulkRequest.requests.set(i, null);\n                                    }\n                                }\n                            }\n                            if (counter.decrementAndGet() == 0) {\n                                try {\n                                    executeBulk(bulkRequest, startTime, listener, responses);\n                                } catch (Throwable t) {\n                                    listener.onFailure(t);\n                                }\n                            }\n                        }\n                    });\n                } else {\n                    if (counter.decrementAndGet() == 0) {\n                        executeBulk(bulkRequest, startTime, listener, responses);\n                    }\n                }\n            }\n        } else {\n            executeBulk(bulkRequest, startTime, listener, responses);\n        }\n    }","commit_id":"dd4a22bfedf4a3c0c34ea598dfd97903d09b6396","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ObjectValuePair\n\t\t<Configuration, PortalCacheManagerConfiguration>\n\t\t\tgetConfigurationObjectValuePair(\n\t\t\t\tString portalCacheManagerName, URL configurationURL,\n\t\t\t\tboolean usingDefault) {\n\n\t\tif (configurationURL == null) {\n\t\t\tthrow new NullPointerException(\"Configuration path is null\");\n\t\t}\n\n\t\tConfiguration ehcacheConfiguration =\n\t\t\tConfigurationFactory.parseConfiguration(configurationURL);\n\n\t\tehcacheConfiguration.setName(portalCacheManagerName);\n\n\t\thandleCacheManagerPeerFactoryConfigurations(\n\t\t\tehcacheConfiguration.\n\t\t\t\tgetCacheManagerPeerProviderFactoryConfiguration());\n\n\t\thandleCacheManagerPeerFactoryConfigurations(\n\t\t\tehcacheConfiguration.\n\t\t\t\tgetCacheManagerPeerListenerFactoryConfigurations());\n\n\t\tSet<Properties> cacheManagerListenerPropertiesSet =\n\t\t\tgetCacheManagerListenerPropertiesSet(ehcacheConfiguration);\n\n\t\tPortalCacheConfiguration defaultPortalCacheConfiguration =\n\t\t\tgetPortalCacheConfiguration(\n\t\t\t\tehcacheConfiguration.getDefaultCacheConfiguration(),\n\t\t\t\tusingDefault);\n\n\t\tSet<PortalCacheConfiguration> portalCacheConfigurations =\n\t\t\tnew HashSet<>();\n\n\t\tMap<String, CacheConfiguration> cacheConfigurations =\n\t\t\tehcacheConfiguration.getCacheConfigurations();\n\n\t\tfor (Map.Entry<String, CacheConfiguration> entry :\n\t\t\t\tcacheConfigurations.entrySet()) {\n\n\t\t\tportalCacheConfigurations.add(\n\t\t\t\tgetPortalCacheConfiguration(entry.getValue(), usingDefault));\n\t\t}\n\n\t\tPortalCacheManagerConfiguration portalCacheManagerConfiguration =\n\t\t\tnew PortalCacheManagerConfiguration(\n\t\t\t\tcacheManagerListenerPropertiesSet,\n\t\t\t\tdefaultPortalCacheConfiguration, portalCacheConfigurations);\n\n\t\treturn new ObjectValuePair<>(\n\t\t\tehcacheConfiguration, portalCacheManagerConfiguration);\n\t}","id":44524,"modified_method":"public ObjectValuePair\n\t\t<Configuration, PortalCacheManagerConfiguration>\n\t\t\tgetConfigurationObjectValuePair(\n\t\t\t\tString portalCacheManagerName, URL configurationURL,\n\t\t\t\tboolean usingDefault) {\n\n\t\tif (configurationURL == null) {\n\t\t\tthrow new NullPointerException(\"Configuration path is null\");\n\t\t}\n\n\t\tConfiguration ehcacheConfiguration =\n\t\t\tConfigurationFactory.parseConfiguration(configurationURL);\n\n\t\tehcacheConfiguration.setName(portalCacheManagerName);\n\n\t\tresolvePortalProperty(ehcacheConfiguration);\n\n\t\thandleCacheManagerPeerFactoryConfigurations(\n\t\t\tehcacheConfiguration.\n\t\t\t\tgetCacheManagerPeerProviderFactoryConfiguration());\n\n\t\thandleCacheManagerPeerFactoryConfigurations(\n\t\t\tehcacheConfiguration.\n\t\t\t\tgetCacheManagerPeerListenerFactoryConfigurations());\n\n\t\tSet<Properties> cacheManagerListenerPropertiesSet =\n\t\t\tgetCacheManagerListenerPropertiesSet(ehcacheConfiguration);\n\n\t\tPortalCacheConfiguration defaultPortalCacheConfiguration =\n\t\t\tgetPortalCacheConfiguration(\n\t\t\t\tehcacheConfiguration.getDefaultCacheConfiguration(),\n\t\t\t\tusingDefault);\n\n\t\tSet<PortalCacheConfiguration> portalCacheConfigurations =\n\t\t\tnew HashSet<>();\n\n\t\tMap<String, CacheConfiguration> cacheConfigurations =\n\t\t\tehcacheConfiguration.getCacheConfigurations();\n\n\t\tfor (Map.Entry<String, CacheConfiguration> entry :\n\t\t\t\tcacheConfigurations.entrySet()) {\n\n\t\t\tportalCacheConfigurations.add(\n\t\t\t\tgetPortalCacheConfiguration(entry.getValue(), usingDefault));\n\t\t}\n\n\t\tPortalCacheManagerConfiguration portalCacheManagerConfiguration =\n\t\t\tnew PortalCacheManagerConfiguration(\n\t\t\t\tcacheManagerListenerPropertiesSet,\n\t\t\t\tdefaultPortalCacheConfiguration, portalCacheConfigurations);\n\n\t\treturn new ObjectValuePair<>(\n\t\t\tehcacheConfiguration, portalCacheManagerConfiguration);\n\t}","commit_id":"1c0f3305a901e8f47ecbf2ec968a271f8542f057","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Properties parseProperties(\n\t\tString propertiesString, String propertySeparator) {\n\n\t\tProperties properties = new Properties();\n\n\t\tif (propertiesString == null) {\n\t\t\treturn properties;\n\t\t}\n\n\t\tif (propertySeparator == null) {\n\t\t\tpropertySeparator = StringPool.COMMA;\n\t\t}\n\n\t\tString propertyLines = propertiesString.trim();\n\n\t\tpropertyLines = StringUtil.replace(\n\t\t\tpropertyLines, propertySeparator, StringPool.NEW_LINE);\n\n\t\ttry {\n\t\t\tproperties.load(new UnsyncStringReader(propertyLines));\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new RuntimeException(ioe);\n\t\t}\n\n\t\tString portalPropertyKey = (String)properties.remove(\n\t\t\t_PORTAL_PROPERTY_KEY);\n\n\t\tif (Validator.isNull(portalPropertyKey)) {\n\t\t\treturn properties;\n\t\t}\n\n\t\tString[] values = props.getArray(portalPropertyKey);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\n\t\t\t\t\"portalPropertyKey \" + portalPropertyKey + \" has value \" +\n\t\t\t\t\tArrays.toString(values));\n\t\t}\n\n\t\tfor (String value : values) {\n\t\t\tString[] valueParts = StringUtil.split(value, CharPool.EQUAL);\n\n\t\t\tif (valueParts.length != 2) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\"Ignore malformed value \" + value);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tproperties.put(valueParts[0], _unescape(valueParts[1]));\n\t\t}\n\n\t\treturn properties;\n\t}","id":44525,"modified_method":"protected Properties parseProperties(\n\t\tString propertiesString, String propertySeparator) {\n\n\t\tProperties properties = new Properties();\n\n\t\tif (propertiesString == null) {\n\t\t\treturn properties;\n\t\t}\n\n\t\tString propertyLines = propertiesString.trim();\n\n\t\tpropertyLines = StringUtil.replace(\n\t\t\tpropertyLines, propertySeparator, StringPool.NEW_LINE);\n\n\t\ttry {\n\t\t\tproperties.load(new UnsyncStringReader(propertyLines));\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new RuntimeException(ioe);\n\t\t}\n\n\t\treturn properties;\n\t}","commit_id":"1c0f3305a901e8f47ecbf2ec968a271f8542f057","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Set<Properties> parseCacheEventListenerFactoryConfiguration(\n\t\tCacheConfiguration cacheConfiguration, boolean usingDefault) {\n\n\t\tSet<Properties> portalCacheListenerPropertiesSet = new HashSet<>();\n\n\t\tList<CacheEventListenerFactoryConfiguration>\n\t\t\tcacheEventListenerConfigurations =\n\t\t\t\tcacheConfiguration.getCacheEventListenerConfigurations();\n\n\t\tfor (CacheEventListenerFactoryConfiguration\n\t\t\t\tcacheEventListenerFactoryConfiguration :\n\t\t\t\t\tcacheEventListenerConfigurations) {\n\n\t\t\tString factoryClassName = parseFactoryClassName(\n\t\t\t\tcacheEventListenerFactoryConfiguration.\n\t\t\t\t\tgetFullyQualifiedClassPath());\n\n\t\t\tProperties properties = parseProperties(\n\t\t\t\tcacheEventListenerFactoryConfiguration.getProperties(),\n\t\t\t\tcacheEventListenerFactoryConfiguration. getPropertySeparator());\n\n\t\t\tPortalCacheListenerScope portalCacheListenerScope =\n\t\t\t\t_portalCacheListenerScopes.get(\n\t\t\t\t\tcacheEventListenerFactoryConfiguration.getListenFor());\n\n\t\t\tprocessCacheEventListenerFactoryProperties(\n\t\t\t\tfactoryClassName, portalCacheListenerPropertiesSet,\n\t\t\t\tportalCacheListenerScope, properties, usingDefault);\n\t\t}\n\n\t\tcacheEventListenerConfigurations.clear();\n\n\t\treturn portalCacheListenerPropertiesSet;\n\t}","id":44526,"modified_method":"protected Set<Properties> parseCacheEventListenerFactoryConfiguration(\n\t\tCacheConfiguration cacheConfiguration, boolean usingDefault) {\n\n\t\tSet<Properties> portalCacheListenerPropertiesSet = new HashSet<>();\n\n\t\tList<CacheEventListenerFactoryConfiguration>\n\t\t\tcacheEventListenerConfigurations =\n\t\t\t\tcacheConfiguration.getCacheEventListenerConfigurations();\n\n\t\tfor (CacheEventListenerFactoryConfiguration\n\t\t\t\tcacheEventListenerFactoryConfiguration :\n\t\t\t\t\tcacheEventListenerConfigurations) {\n\n\t\t\tString factoryClassName =\n\t\t\t\tcacheEventListenerFactoryConfiguration.\n\t\t\t\t\tgetFullyQualifiedClassPath();\n\n\t\t\tProperties properties = parseProperties(\n\t\t\t\tcacheEventListenerFactoryConfiguration.getProperties(),\n\t\t\t\tcacheEventListenerFactoryConfiguration. getPropertySeparator());\n\n\t\t\tPortalCacheListenerScope portalCacheListenerScope =\n\t\t\t\t_portalCacheListenerScopes.get(\n\t\t\t\t\tcacheEventListenerFactoryConfiguration.getListenFor());\n\n\t\t\tprocessCacheEventListenerFactoryProperties(\n\t\t\t\tfactoryClassName, portalCacheListenerPropertiesSet,\n\t\t\t\tportalCacheListenerScope, properties, usingDefault);\n\t\t}\n\n\t\tcacheEventListenerConfigurations.clear();\n\n\t\treturn portalCacheListenerPropertiesSet;\n\t}","commit_id":"1c0f3305a901e8f47ecbf2ec968a271f8542f057","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Set<Properties>\n\t\tgetCacheManagerListenerPropertiesSet(\n\t\t\tConfiguration ehcacheConfiguration) {\n\n\t\tFactoryConfiguration<?> factoryConfiguration =\n\t\t\tehcacheConfiguration.\n\t\t\t\tgetCacheManagerEventListenerFactoryConfiguration();\n\n\t\tif (factoryConfiguration == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\tProperties properties = parseProperties(\n\t\t\tfactoryConfiguration.getProperties(),\n\t\t\tfactoryConfiguration.getPropertySeparator());\n\n\t\tproperties.put(\n\t\t\tEhcacheConstants.CACHE_MANAGER_LISTENER_FACTORY_CLASS_NAME,\n\t\t\tparseFactoryClassName(\n\t\t\t\tfactoryConfiguration.getFullyQualifiedClassPath()));\n\n\t\tfactoryConfiguration.setClass(null);\n\n\t\treturn Collections.singleton(properties);\n\t}","id":44527,"modified_method":"protected Set<Properties>\n\t\tgetCacheManagerListenerPropertiesSet(\n\t\t\tConfiguration ehcacheConfiguration) {\n\n\t\tFactoryConfiguration<?> factoryConfiguration =\n\t\t\tehcacheConfiguration.\n\t\t\t\tgetCacheManagerEventListenerFactoryConfiguration();\n\n\t\tif (factoryConfiguration == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\n\t\tProperties properties = parseProperties(\n\t\t\tfactoryConfiguration.getProperties(),\n\t\t\tfactoryConfiguration.getPropertySeparator());\n\n\t\tproperties.put(\n\t\t\tEhcacheConstants.CACHE_MANAGER_LISTENER_FACTORY_CLASS_NAME,\n\t\t\tfactoryConfiguration.getFullyQualifiedClassPath());\n\n\t\tfactoryConfiguration.setClass(null);\n\n\t\treturn Collections.singleton(properties);\n\t}","commit_id":"1c0f3305a901e8f47ecbf2ec968a271f8542f057","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getPropertiesString(\n\t\tProperties properties, String propertySeparator) {\n\n\t\tif (propertySeparator == null) {\n\t\t\tpropertySeparator = StringPool.COMMA;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(properties.size() * 4);\n\n\t\tfor (Map.Entry<Object, Object> entry : properties.entrySet()) {\n\t\t\tsb.append(entry.getKey());\n\t\t\tsb.append(StringPool.EQUAL);\n\t\t\tsb.append(entry.getValue());\n\t\t\tsb.append(propertySeparator);\n\t\t}\n\n\t\tif (!properties.isEmpty()) {\n\t\t\tsb.setIndex(sb.index() - 1);\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":44528,"modified_method":"protected String getPortalPropertyKey(String propertyString) {\n\t\tif (propertyString.indexOf(CharPool.EQUAL) == -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString[] parts = StringUtil.split(propertyString, CharPool.EQUAL);\n\n\t\tif (parts[0].equals(_PORTAL_PROPERTY_KEY)) {\n\t\t\treturn parts[1];\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"1c0f3305a901e8f47ecbf2ec968a271f8542f057","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t@SuppressWarnings(\"rawtypes\")\n\tprotected void handleCacheManagerPeerFactoryConfigurations(\n\t\tList<FactoryConfiguration> factoryConfigurations) {\n\n\t\tif (factoryConfigurations.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!_clusterEnabled || _clusterLinkReplicationEnabled) {\n\t\t\tfactoryConfigurations.clear();\n\n\t\t\treturn;\n\t\t}\n\n\t\tfor (FactoryConfiguration factoryConfiguration :\n\t\t\t\tfactoryConfigurations) {\n\n\t\t\tProperties properties = null;\n\n\t\t\tfactoryConfiguration.setClass(\n\t\t\t\tparseFactoryClassName(\n\t\t\t\t\tfactoryConfiguration.getFullyQualifiedClassPath()));\n\n\t\t\tString propertiesString = factoryConfiguration.getProperties();\n\n\t\t\tif (Validator.isNull(propertiesString)) {\n\t\t\t\tproperties = new Properties();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tproperties = parseProperties(\n\t\t\t\t\tpropertiesString,\n\t\t\t\t\tfactoryConfiguration.getPropertySeparator());\n\t\t\t}\n\n\t\t\tfactoryConfiguration.setProperties(\n\t\t\t\tgetPropertiesString(\n\t\t\t\t\tproperties, factoryConfiguration.getPropertySeparator()));\n\t\t}\n\t}","id":44529,"modified_method":"@Override\n\t@SuppressWarnings(\"rawtypes\")\n\tprotected void handleCacheManagerPeerFactoryConfigurations(\n\t\tList<FactoryConfiguration> factoryConfigurations) {\n\n\t\tif (factoryConfigurations.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!_clusterEnabled || _clusterLinkReplicationEnabled) {\n\t\t\tfactoryConfigurations.clear();\n\n\t\t\treturn;\n\t\t}\n\t}","commit_id":"1c0f3305a901e8f47ecbf2ec968a271f8542f057","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected Properties parsePortalCacheBootstrapLoaderProperties(\n\t\tCacheConfiguration cacheConfiguration) {\n\n\t\tProperties portalCacheBootstrapLoaderProperties = null;\n\n\t\tBootstrapCacheLoaderFactoryConfiguration\n\t\t\tbootstrapCacheLoaderFactoryConfiguration =\n\t\t\t\tcacheConfiguration.\n\t\t\t\t\tgetBootstrapCacheLoaderFactoryConfiguration();\n\n\t\tif (bootstrapCacheLoaderFactoryConfiguration != null) {\n\t\t\tportalCacheBootstrapLoaderProperties = parseProperties(\n\t\t\t\tbootstrapCacheLoaderFactoryConfiguration.getProperties(),\n\t\t\t\tbootstrapCacheLoaderFactoryConfiguration.\n\t\t\t\t\tgetPropertySeparator());\n\n\t\t\tif (_clusterEnabled) {\n\t\t\t\tif (!_clusterLinkReplicationEnabled) {\n\t\t\t\t\tportalCacheBootstrapLoaderProperties.put(\n\t\t\t\t\t\tEhcacheConstants.\n\t\t\t\t\t\t\tBOOTSTRAP_CACHE_LOADER_FACTORY_CLASS_NAME,\n\t\t\t\t\t\tparseFactoryClassName(\n\t\t\t\t\t\t\tbootstrapCacheLoaderFactoryConfiguration.\n\t\t\t\t\t\t\t\tgetFullyQualifiedClassPath()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcacheConfiguration.addBootstrapCacheLoaderFactory(null);\n\n\t\treturn portalCacheBootstrapLoaderProperties;\n\t}","id":44530,"modified_method":"@Override\n\tprotected Properties parsePortalCacheBootstrapLoaderProperties(\n\t\tCacheConfiguration cacheConfiguration) {\n\n\t\tProperties portalCacheBootstrapLoaderProperties = null;\n\n\t\tBootstrapCacheLoaderFactoryConfiguration\n\t\t\tbootstrapCacheLoaderFactoryConfiguration =\n\t\t\t\tcacheConfiguration.\n\t\t\t\t\tgetBootstrapCacheLoaderFactoryConfiguration();\n\n\t\tif (bootstrapCacheLoaderFactoryConfiguration != null) {\n\t\t\tportalCacheBootstrapLoaderProperties = parseProperties(\n\t\t\t\tbootstrapCacheLoaderFactoryConfiguration.getProperties(),\n\t\t\t\tbootstrapCacheLoaderFactoryConfiguration.\n\t\t\t\t\tgetPropertySeparator());\n\n\t\t\tif (_clusterEnabled) {\n\t\t\t\tif (!_clusterLinkReplicationEnabled) {\n\t\t\t\t\tportalCacheBootstrapLoaderProperties.put(\n\t\t\t\t\t\tEhcacheConstants.\n\t\t\t\t\t\t\tBOOTSTRAP_CACHE_LOADER_FACTORY_CLASS_NAME,\n\t\t\t\t\t\tbootstrapCacheLoaderFactoryConfiguration.\n\t\t\t\t\t\t\tgetFullyQualifiedClassPath());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcacheConfiguration.addBootstrapCacheLoaderFactory(null);\n\n\t\treturn portalCacheBootstrapLoaderProperties;\n\t}","commit_id":"1c0f3305a901e8f47ecbf2ec968a271f8542f057","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean previewKeyPress(char c)\n   {\n      if (popup_.isShowing())\n      {\n         if (isValidForRIdentifier(c) || c == ':')\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(false, true, false);\n               }\n            });\n         }\n      }\n      else\n      {\n         // Pop up suggestions if there is more than 3 characters on the line,\n         // but never automatically insert the completion in that case\n         String currentLine = docDisplay_.getCurrentLine();\n         Position cursorPos = input_.getCursorPosition();\n         int cursorColumn = cursorPos.getColumn();\n         \n         int lookbackLength = 4;\n         boolean canAutocomplete = currentLine.length() > lookbackLength && isValidForRIdentifier(c);\n         if (canAutocomplete)\n         {\n            for (int i = 0; i < lookbackLength; i++)\n            {\n               if (!isValidForRIdentifier(currentLine.charAt(cursorColumn - i - 1)))\n               {\n                  canAutocomplete = false;\n                  break;\n               }\n            }\n         }\n         \n         final boolean fCanAutocomplete = canAutocomplete;\n         char prevChar = currentLine.charAt(cursorColumn - 1);\n         \n         if (\n               (fCanAutocomplete) ||\n               (c == ':' && prevChar == ':') ||\n               (c == '$') ||\n               (c == '@') ||\n               isSweaveCompletion(c))\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(true, true, !fCanAutocomplete);\n               }\n            });\n         }\n         else if (CompletionUtils.handleEncloseSelection(input_, c))\n         {\n            return true;\n         }\n      }\n      return false ;\n   }","id":44531,"modified_method":"public boolean previewKeyPress(char c)\n   {\n      if (popup_.isShowing())\n      {\n         if (isValidForRIdentifier(c) || c == ':')\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(false, true, false);\n               }\n            });\n         }\n      }\n      else\n      {\n         char prevChar = docDisplay_.getCurrentLine().charAt(\n               input_.getCursorPosition().getColumn() - 1);\n         \n         if (\n               (c == ':' && prevChar == ':') ||\n               (c == '$') ||\n               (c == '@') ||\n               isSweaveCompletion(c))\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(true, true, false);\n               }\n            });\n         }\n         else if (CompletionUtils.handleEncloseSelection(input_, c))\n         {\n            return true;\n         }\n      }\n      return false ;\n   }","commit_id":"fc67f917dc2c862571d43893a85cd5a99b209a67","url":"https://github.com/rstudio/rstudio"},{"original_method":"Position getLookupPosition()\n   {\n      if (coordinates_ == null)\n         return docDisplay_.getCursorPosition();\n      \n      return docDisplay_.screenCoordinatesToDocumentPosition(\n            coordinates_.getMouseX(),\n            coordinates_.getMouseY());\n   }","id":44532,"modified_method":"Position getLookupPosition()\n   {\n      if (coordinates_ == null)\n      {\n         Position position = docDisplay_.getCursorPosition();\n         \n         // Nudge the cursor column if the cursor currently lies\n         // upon a closing paren.\n         if (docDisplay_.getCharacterAtCursor() == ')' &&\n             position.getColumn() != 0)\n         {\n            position = Position.create(\n                  position.getRow(),\n                  position.getColumn() - 1);\n         }\n         \n         return position;\n      }\n      \n      return docDisplay_.screenCoordinatesToDocumentPosition(\n            coordinates_.getMouseX(),\n            coordinates_.getMouseY());\n   }","commit_id":"081750fd92e3afd7813a2b05f44c019bb3c12be5","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void codeCompletion()\n   {\n      if (initFilter_ == null || initFilter_.shouldComplete(null))\n         beginSuggest(true, false);\n   }","id":44533,"modified_method":"public void codeCompletion()\n   {\n      if (initFilter_ == null || initFilter_.shouldComplete(null))\n         beginSuggest(true, false, true);\n   }","commit_id":"f51969e986465ebae1d6ace5e08238fa09039266","url":"https://github.com/rstudio/rstudio"},{"original_method":"public boolean previewKeyDown(NativeEvent event)\n   {\n      /**\n       * KEYS THAT MATTER\n       *\n       * When popup not showing:\n       * Tab - attempt completion (handled in Console.java)\n       * \n       * When popup showing:\n       * Esc - dismiss popup\n       * Enter/Tab/Right-arrow - accept current selection\n       * Up-arrow/Down-arrow - change selected item\n       * Left-arrow - dismiss popup\n       * [identifier] - narrow suggestions--or if we're lame, just dismiss\n       * All others - dismiss popup\n       */\n      \n      nativeEvent_ = event;\n\n      int modifier = KeyboardShortcut.getModifierValue(event);\n\n      if (!popup_.isShowing())\n      {\n         if (CompletionUtils.isCompletionRequest(event, modifier))\n         {\n            if (initFilter_ == null || initFilter_.shouldComplete(event))\n            {\n               return beginSuggest(true, false);\n            }\n         }\n         else if (event.getKeyCode() == 112 // F1\n                  && modifier == KeyboardShortcut.NONE)\n         {\n            goToHelp();\n         }\n         else if (event.getKeyCode() == 113 // F2\n                  && modifier == KeyboardShortcut.NONE)\n         {\n            goToFunctionDefinition();\n         }\n      }\n      else\n      {\n         switch (event.getKeyCode())\n         {\n         // chrome on ubuntu now sends this before every keydown\n         // so we need to explicitly ignore it. see:\n         // https://github.com/ivaynberg/select2/issues/2482\n         case KeyCodes.KEY_WIN_IME: \n            return false ;\n            \n         case KeyCodes.KEY_SHIFT:\n         case KeyCodes.KEY_CTRL:\n         case KeyCodes.KEY_ALT:\n            return false ; // bare modifiers should do nothing\n         }\n         \n         if (modifier == KeyboardShortcut.NONE)\n         {\n            if (event.getKeyCode() == KeyCodes.KEY_ESCAPE)\n            {\n               invalidatePendingRequests() ;\n               return true ;\n            }\n            else if (event.getKeyCode() == KeyCodes.KEY_TAB\n                  || event.getKeyCode() == KeyCodes.KEY_ENTER\n                  || event.getKeyCode() == KeyCodes.KEY_RIGHT)\n            {\n               QualifiedName value = popup_.getSelectedValue() ;\n               if (value != null)\n               {\n                  context_.onSelection(value) ;\n                  return true ;\n               }\n            }\n            else if (event.getKeyCode() == KeyCodes.KEY_UP)\n               return popup_.selectPrev() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_DOWN)\n               return popup_.selectNext() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_PAGEUP)\n               return popup_.selectPrevPage() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_PAGEDOWN)\n               return popup_.selectNextPage() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_HOME)\n               return popup_.selectFirst() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_END)\n               return popup_.selectLast() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_LEFT)\n            {\n               invalidatePendingRequests() ;\n               return true ;\n            }\n            else if (event.getKeyCode() == 112) // F1\n            {\n               context_.showHelpTopic() ;\n               return true ;\n            }\n            else if (event.getKeyCode() == 113) // F2\n            {\n               goToFunctionDefinition();\n               return true;\n            }\n         }\n         \n         if (isIdentifierKey(event))\n            return false ;\n         \n         invalidatePendingRequests() ;\n         return false ;\n      }\n      \n      return false ;\n   }","id":44534,"modified_method":"public boolean previewKeyDown(NativeEvent event)\n   {\n      /**\n       * KEYS THAT MATTER\n       *\n       * When popup not showing:\n       * Tab - attempt completion (handled in Console.java)\n       * \n       * When popup showing:\n       * Esc - dismiss popup\n       * Enter/Tab/Right-arrow - accept current selection\n       * Up-arrow/Down-arrow - change selected item\n       * Left-arrow - dismiss popup\n       * [identifier] - narrow suggestions--or if we're lame, just dismiss\n       * All others - dismiss popup\n       */\n      \n      nativeEvent_ = event;\n\n      int modifier = KeyboardShortcut.getModifierValue(event);\n\n      if (!popup_.isShowing())\n      {\n         if (CompletionUtils.isCompletionRequest(event, modifier))\n         {\n            if (initFilter_ == null || initFilter_.shouldComplete(event))\n            {\n               return beginSuggest(true, false, true);\n            }\n         }\n         else if (event.getKeyCode() == 112 // F1\n                  && modifier == KeyboardShortcut.NONE)\n         {\n            goToHelp();\n         }\n         else if (event.getKeyCode() == 113 // F2\n                  && modifier == KeyboardShortcut.NONE)\n         {\n            goToFunctionDefinition();\n         }\n      }\n      else\n      {\n         switch (event.getKeyCode())\n         {\n         // chrome on ubuntu now sends this before every keydown\n         // so we need to explicitly ignore it. see:\n         // https://github.com/ivaynberg/select2/issues/2482\n         case KeyCodes.KEY_WIN_IME: \n            return false ;\n            \n         case KeyCodes.KEY_SHIFT:\n         case KeyCodes.KEY_CTRL:\n         case KeyCodes.KEY_ALT:\n         case KeyCodes.KEY_MAC_FF_META:\n         case KeyCodes.KEY_WIN_KEY_LEFT_META:\n            return false ; // bare modifiers should do nothing\n         }\n         \n         if (modifier == KeyboardShortcut.NONE)\n         {\n            if (event.getKeyCode() == KeyCodes.KEY_ESCAPE)\n            {\n               invalidatePendingRequests() ;\n               return true ;\n            }\n            else if (event.getKeyCode() == KeyCodes.KEY_TAB\n                  || event.getKeyCode() == KeyCodes.KEY_ENTER\n                  || event.getKeyCode() == KeyCodes.KEY_RIGHT)\n            {\n               QualifiedName value = popup_.getSelectedValue() ;\n               if (value != null)\n               {\n                  context_.onSelection(value) ;\n                  return true ;\n               }\n            }\n            else if (event.getKeyCode() == KeyCodes.KEY_UP)\n               return popup_.selectPrev() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_DOWN)\n               return popup_.selectNext() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_PAGEUP)\n               return popup_.selectPrevPage() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_PAGEDOWN)\n               return popup_.selectNextPage() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_HOME)\n               return popup_.selectFirst() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_END)\n               return popup_.selectLast() ;\n            else if (event.getKeyCode() == KeyCodes.KEY_LEFT)\n            {\n               invalidatePendingRequests() ;\n               return true ;\n            }\n            else if (event.getKeyCode() == 112) // F1\n            {\n               context_.showHelpTopic() ;\n               return true ;\n            }\n            else if (event.getKeyCode() == 113) // F2\n            {\n               goToFunctionDefinition();\n               return true;\n            }\n         }\n         \n         if (canContinueCompletions(event))\n            return false;\n         \n         // continue showing completions on backspace\n         if (event.getKeyCode() == KeyCodes.KEY_BACKSPACE)\n         {\n            // manually remove the previous character\n            input_.setSelection(new InputEditorSelection(\n                  input_.getSelection().getStart().movePosition(-1, true),\n                  input_.getSelection().getStart()));\n            input_.replaceSelection(\"\", false);\n            \n            // only suggest if the character previous to the cursor is an R identifier\n            // also halt suggestions if we're about to remove the only character on the line\n            String currentLine = docDisplay_.getCurrentLine();\n            int cursorCol = input_.getCursorPosition().getColumn();\n            char ch = currentLine.charAt(cursorCol - 1);\n            if (currentLine.length() > 0 &&\n                cursorCol > 0 &&\n                (isValidForRIdentifier(ch) || ch == ':' || ch == '$' || ch == '@'))\n            {\n               invalidatePendingRequests();\n               return beginSuggest(true, false, false);\n            }\n            else\n            {\n               invalidatePendingRequests();\n               return true;\n            }\n         }\n         \n         invalidatePendingRequests();\n         return false ;\n      }\n      \n      return false ;\n   }","commit_id":"f51969e986465ebae1d6ace5e08238fa09039266","url":"https://github.com/rstudio/rstudio"},{"original_method":"/**\n    * If false, the suggest operation was aborted\n    */\n   private boolean beginSuggest(boolean flushCache, boolean implicit)\n   {\n      if (!input_.isSelectionCollapsed())\n         return false ;\n      \n      invalidatePendingRequests(flushCache);\n      \n      InputEditorSelection selection = input_.getSelection() ;\n      if (selection == null)\n         return false;\n      \n      int cursorCol = selection.getStart().getPosition();\n      String firstLine = input_.getText().substring(0, cursorCol);\n      \n      // don't auto-complete at the start of comments\n      if (firstLine.matches(\".*#+\\\\s*$\"))\n      {\n         return false;\n      }\n      \n      // don't auto-complete with tab on lines with only whitespace,\n      // if the insertion character was a tab\n      if (nativeEvent_ != null &&\n            nativeEvent_.getKeyCode() == KeyCodes.KEY_TAB)\n         if (firstLine.matches(\"^\\\\s*$\"))\n            return false;\n      \n      AutoCompletionContext context = getAutocompletionContext();\n      \n      if (!input_.hasSelection())\n      {\n         Debug.log(\"Cursor wasn't in input box or was in subelement\");\n         return false ;\n      }\n\n      boolean canAutoAccept = flushCache;\n      \n      context_ = new CompletionRequestContext(invalidation_.getInvalidationToken(),\n                                              selection,\n                                              canAutoAccept);\n      \n      RInfixData infixData = RInfixData.create();\n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor != null)\n      {\n         CodeModel codeModel = editor.getSession().getMode().getCodeModel();\n         TokenCursor cursor = codeModel.getTokenCursor();\n         \n         if (cursor.moveToPosition(input_.getCursorPosition()))\n         {\n            String token = \"\";\n            if (cursor.currentType() == \"identifier\")\n               token = cursor.currentValue();\n            \n            String cursorPos = \"left\";\n            if (cursor.currentValue() == \"=\")\n               cursorPos = \"right\";\n            \n            TokenCursor clone = cursor.cloneCursor();\n            if (clone.moveToPreviousToken())\n               if (clone.currentValue() == \"=\")\n                  cursorPos = \"right\";\n            \n            // Try to get a dplyr join completion\n            DplyrJoinContext joinContext =\n                  codeModel.getDplyrJoinContextFromInfixChain(cursor);\n            \n            // If that failed, try a non-infix lookup\n            if (joinContext == null)\n            {\n               String joinString =\n                     getDplyrJoinString(editor, cursor);\n               \n               if (!StringUtil.isNullOrEmpty(joinString))\n               {\n                  requester_.getDplyrJoinCompletionsString(\n                        token,\n                        joinString,\n                        cursorPos,\n                        implicit,\n                        context_);\n\n                  return true;\n               }\n            }\n            else\n            {\n               requester_.getDplyrJoinCompletions(\n                     joinContext,\n                     implicit,\n                     context_);\n               return true;\n               \n            }\n            \n            // Try to see if there's an object name we should use to supplement\n            // completions\n            if (cursor.moveToPosition(input_.getCursorPosition()))\n               infixData = codeModel.getDataFromInfixChain(cursor);\n         }\n      }\n      \n      requester_.getCompletions(\n            context.getToken(),\n            context.getAssocData(),\n            context.getDataType(),\n            context.getNumCommas(),\n            context.getFunctionCallString(),\n            infixData.getDataName(),\n            infixData.getAdditionalArgs(),\n            infixData.getExcludeArgs(),\n            infixData.getExcludeArgsFromObject(),\n            implicit,\n            context_);\n\n      return true ;\n   }","id":44535,"modified_method":"/**\n    * If false, the suggest operation was aborted\n    */\n   private boolean beginSuggest(boolean flushCache, boolean implicit, final boolean canAutoInsert)\n   {\n      if (!input_.isSelectionCollapsed())\n         return false ;\n      \n      invalidatePendingRequests(flushCache);\n      \n      InputEditorSelection selection = input_.getSelection() ;\n      if (selection == null)\n         return false;\n      \n      int cursorCol = selection.getStart().getPosition();\n      String firstLine = input_.getText().substring(0, cursorCol);\n      \n      // don't auto-complete at the start of comments\n      if (firstLine.matches(\".*#+\\\\s*$\"))\n      {\n         return false;\n      }\n      \n      // don't auto-complete with tab on lines with only whitespace,\n      // if the insertion character was a tab\n      if (nativeEvent_ != null &&\n            nativeEvent_.getKeyCode() == KeyCodes.KEY_TAB)\n         if (firstLine.matches(\"^\\\\s*$\"))\n            return false;\n      \n      AutoCompletionContext context = getAutocompletionContext();\n      \n      if (!input_.hasSelection())\n      {\n         Debug.log(\"Cursor wasn't in input box or was in subelement\");\n         return false ;\n      }\n\n      context_ = new CompletionRequestContext(invalidation_.getInvalidationToken(),\n                                              selection,\n                                              canAutoInsert);\n      \n      RInfixData infixData = RInfixData.create();\n      AceEditor editor = (AceEditor) docDisplay_;\n      if (editor != null)\n      {\n         CodeModel codeModel = editor.getSession().getMode().getCodeModel();\n         TokenCursor cursor = codeModel.getTokenCursor();\n         \n         if (cursor.moveToPosition(input_.getCursorPosition()))\n         {\n            String token = \"\";\n            if (cursor.currentType() == \"identifier\")\n               token = cursor.currentValue();\n            \n            String cursorPos = \"left\";\n            if (cursor.currentValue() == \"=\")\n               cursorPos = \"right\";\n            \n            TokenCursor clone = cursor.cloneCursor();\n            if (clone.moveToPreviousToken())\n               if (clone.currentValue() == \"=\")\n                  cursorPos = \"right\";\n            \n            // Try to get a dplyr join completion\n            DplyrJoinContext joinContext =\n                  codeModel.getDplyrJoinContextFromInfixChain(cursor);\n            \n            // If that failed, try a non-infix lookup\n            if (joinContext == null)\n            {\n               String joinString =\n                     getDplyrJoinString(editor, cursor);\n               \n               if (!StringUtil.isNullOrEmpty(joinString))\n               {\n                  requester_.getDplyrJoinCompletionsString(\n                        token,\n                        joinString,\n                        cursorPos,\n                        implicit,\n                        context_);\n\n                  return true;\n               }\n            }\n            else\n            {\n               requester_.getDplyrJoinCompletions(\n                     joinContext,\n                     implicit,\n                     context_);\n               return true;\n               \n            }\n            \n            // Try to see if there's an object name we should use to supplement\n            // completions\n            if (cursor.moveToPosition(input_.getCursorPosition()))\n               infixData = codeModel.getDataFromInfixChain(cursor);\n         }\n      }\n      \n      requester_.getCompletions(\n            context.getToken(),\n            context.getAssocData(),\n            context.getDataType(),\n            context.getNumCommas(),\n            context.getFunctionCallString(),\n            infixData.getDataName(),\n            infixData.getAdditionalArgs(),\n            infixData.getExcludeArgs(),\n            infixData.getExcludeArgsFromObject(),\n            implicit,\n            context_);\n\n      return true ;\n   }","commit_id":"f51969e986465ebae1d6ace5e08238fa09039266","url":"https://github.com/rstudio/rstudio"},{"original_method":"public boolean previewKeyPress(char c)\n   {\n      if (popup_.isShowing())\n      {\n         if (isValidForRIdentifier(c) || c == ':')\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(false, false);\n               }\n            });\n         }\n      }\n      else\n      {\n         char prevChar = docDisplay_.getCurrentLine().charAt(input_.getCursorPosition().getColumn() - 1);\n         if (\n               (c == ':' && prevChar == ':') ||\n               (c == '$') ||\n               (c == '@') ||\n               isSweaveCompletion(c))\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(true, true);\n               }\n            });\n         }\n         else if (CompletionUtils.handleEncloseSelection(input_, c))\n         {\n            return true;\n         }\n      }\n      return false ;\n   }","id":44536,"modified_method":"public boolean previewKeyPress(char c)\n   {\n      if (popup_.isShowing())\n      {\n         if (isValidForRIdentifier(c) || c == ':')\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(false, true, false);\n               }\n            });\n         }\n      }\n      else\n      {\n         // Pop up suggestions if there is more than 3 characters on the line,\n         // but never automatically insert the completion in that case\n         String currentLine = docDisplay_.getCurrentLine();\n         Position cursorPos = input_.getCursorPosition();\n         int cursorColumn = cursorPos.getColumn();\n         \n         boolean canAutocomplete = currentLine.length() > 2 && isValidForRIdentifier(c);\n         if (canAutocomplete)\n         {\n            for (int i = 0; i < 2; i++)\n            {\n               if (!isValidForRIdentifier(currentLine.charAt(cursorColumn - i - 1)))\n               {\n                  canAutocomplete = false;\n                  break;\n               }\n            }\n         }\n         \n         final boolean fCanAutocomplete = canAutocomplete;\n         char prevChar = currentLine.charAt(cursorColumn - 1);\n         \n         if (\n               (fCanAutocomplete) ||\n               (c == ':' && prevChar == ':') ||\n               (c == '$') ||\n               (c == '@') ||\n               isSweaveCompletion(c))\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(true, true, !fCanAutocomplete);\n               }\n            });\n         }\n         else if (CompletionUtils.handleEncloseSelection(input_, c))\n         {\n            return true;\n         }\n      }\n      return false ;\n   }","commit_id":"f51969e986465ebae1d6ace5e08238fa09039266","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void onSelection(QualifiedName qname)\n      {\n         final String value = qname.name ;\n         \n         if (invalidationToken_.isInvalid())\n            return ;\n         \n         popup_.hide() ;\n         requester_.flushCache() ;\n         \n         if (value == null)\n         {\n            assert false : \"Selected comp value is null\" ;\n            return ;\n         }\n\n         applyValue(qname);\n\n         if (suggestOnAccept_)\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(true, true);\n               }\n            });\n         }\n      }","id":44537,"modified_method":"private void onSelection(QualifiedName qname)\n      {\n         final String value = qname.name ;\n         \n         if (invalidationToken_.isInvalid())\n            return ;\n         \n         popup_.hide() ;\n         requester_.flushCache() ;\n         \n         if (value == null)\n         {\n            assert false : \"Selected comp value is null\" ;\n            return ;\n         }\n\n         applyValue(qname);\n\n         if (suggestOnAccept_)\n         {\n            Scheduler.get().scheduleDeferred(new ScheduledCommand()\n            {\n               @Override\n               public void execute()\n               {\n                  beginSuggest(true, true, canAutoAccept_);\n               }\n            });\n         }\n      }","commit_id":"f51969e986465ebae1d6ace5e08238fa09039266","url":"https://github.com/rstudio/rstudio"},{"original_method":"/**\r\n   * Performs a cp command.\r\n   *  \r\n   *  @param args The name of the file\r\n   *  @throws IOException in case of problems with the PrintOutput \r\n   */\r\n  private void cp(final StringList args) throws IOException {\r\n\r\n    if(args.size < 2) {\r\n      printHelp();\r\n      return;\r\n    }    \r\n    Data data = context.data();\r\n    // Last element of arguments is the target\r\n    String targetfile = args.remove(args.size - 1);\r\n\r\n    // All other argument should be copied\r\n    while(args.size > 0) {\r\n      String sourcefile = args.remove(0);\r\n      // Get all pre values of the source files\r\n      int[] sources = FSUtils.getSpecificFilesOrDirs(data, \r\n          curDirPre, sourcefile);\r\n      sourcefile = sourcefile.substring(sourcefile.lastIndexOf('/') + 1);\r\n      // check if there is an existing target dir or file \r\n      int[] target = FSUtils.getSpecificFilesOrDirs(data, \r\n          curDirPre, targetfile);\r\n      targetfile = targetfile.substring(targetfile.lastIndexOf('/') + 1);\r\n      // The pre value of the new file\r\n      int preOfNewFile = 4;\r\n\r\n      switch(sources.length) {\r\n        case 0:\r\n          // There is no source file\r\n          FSUtils.printError(out, \"cp\", sourcefile, 2);\r\n          break;\r\n        case 1: \r\n          /* Just one file or dir to copy\r\n           * Possibilities:\r\n           *  1. Source = dir -> copy recursive if option -R is set\r\n           *  2. Source = file / Target = dir -> copy to dir\r\n           *  3. Source = file / Target = file -> override target\r\n           *  4. Source = file / Target is not existing  -> create a new file\r\n           */\r\n          if(FSUtils.isDir(data, sources[0])) {\r\n            //Test if it is a dir. Just copy if frecursive is set.\r\n            if(fRecursive) {\r\n              cpRecursive(sources[0], target, targetfile); \r\n              break;\r\n            } else {\r\n              FSUtils.printError(out, \"cp\", \r\n                  Token.string(FSUtils.getName(data, sources[0])), 100);\r\n              break;\r\n            }\r\n          }\r\n\r\n          byte[] size = Token.token(FSUtils.getSize(data, sources[0]));\r\n          byte[] mtime = Token.token(System.currentTimeMillis());\r\n\r\n          if(target.length == 1) {\r\n            if(FSUtils.isDir(data, target[0])) {\r\n              // copy file to dir\r\n              byte[] name = FSUtils.getName(data, sources[0]);\r\n              byte[] suffix = FSUtils.getSuffix(data, sources[0]);\r\n\r\n              if(!(target[0] == FSUtils.getROOTDIR())) {\r\n                preOfNewFile = target[0] + 5;\r\n              }                             \r\n              FSUtils.insert(data, false, name, suffix, size, mtime,\r\n                  target[0], preOfNewFile);\r\n            } else {\r\n              // file exists - override\r\n              FSUtils.update(data, FSUtils.getName(data, target[0]),\r\n                  FSUtils.getSuffix(data, target[0]),\r\n                  size, mtime, target[0]);\r\n            }\r\n          } else {\r\n            // create new file and insert into current dir\r\n            byte[] name = Token.token(targetfile);\r\n            byte[] suffix = getSuffix(targetfile);\r\n\r\n            if(!(curDirPre == FSUtils.getROOTDIR())) {\r\n              preOfNewFile = curDirPre + 5;\r\n            }        \r\n            FSUtils.insert(data, false, name, suffix, size, mtime,\r\n                curDirPre, preOfNewFile);\r\n          }      \r\n          break;\r\n        default:\r\n          if(target.length != 1) { \r\n            FSUtils.printError(out, \"cp\", \"\", 99);\r\n            break;\r\n          }\r\n        if(FSUtils.isFile(data, target[0])) {\r\n          FSUtils.printError(out, \"cp\", \r\n              Token.string(FSUtils.getName(data, target[0])), 20);\r\n          break;\r\n        }\r\n        if(!(target[0] == FSUtils.getROOTDIR())) {\r\n          preOfNewFile = target[0] + 5;\r\n        }  \r\n        ArrayList<byte[]>  toInsert = new ArrayList<byte[]>();\r\n\r\n        for(int i : sources) {  \r\n          // if i is dir go to next value\r\n          if(FSUtils.isDir(data, i)) {\r\n            FSUtils.printError(out, \"cp\", \r\n                Token.string(FSUtils.getName(data, i)), 100);\r\n            continue;\r\n          }      \r\n          toInsert.add(FSUtils.getName(data, i));\r\n          toInsert.add(FSUtils.getSuffix(data, i));\r\n          toInsert.add(Token.token(FSUtils.getSize(data, i)));\r\n        }\r\n        for(int j = 0; j < toInsert.size(); ++j) {\r\n\r\n          FSUtils.insert(data, false, toInsert.remove(0), toInsert.remove(0),\r\n              toInsert.remove(0), Token.token(System.currentTimeMillis()),\r\n              target[0], preOfNewFile);\r\n        }       \r\n        break;\r\n      }      \r\n    }\r\n  }","id":44538,"modified_method":"/**\r\n   * Performs a cp command.\r\n   *  \r\n   *  @param args The name of the file\r\n   *  @throws IOException in case of problems with the PrintOutput \r\n   */\r\n  private void cp(final StringList args) throws IOException {\r\n\r\n    if(args.size < 2) {\r\n      printHelp();\r\n      return;\r\n    }    \r\n    Data data = context.data();\r\n    // Last element of arguments is the target\r\n    String targetfile = args.remove(args.size - 1);\r\n\r\n    // All other argument should be copied\r\n    while(args.size > 0) {\r\n      String sourcefile = args.remove(0);\r\n      // Get all pre values of the source files\r\n      int[] sources = FSUtils.getSpecificFilesOrDirs(data, \r\n          curDirPre, sourcefile);\r\n      sourcefile = sourcefile.substring(sourcefile.lastIndexOf('/') + 1);\r\n      // check if there is an existing target dir or file \r\n      int[] target = FSUtils.getSpecificFilesOrDirs(data, \r\n          curDirPre, targetfile);\r\n      targetfile = targetfile.substring(targetfile.lastIndexOf('/') + 1);\r\n      // The pre value of the new file\r\n      int preOfNewFile = 4;\r\n\r\n      switch(sources.length) {\r\n        case 0:\r\n          // There is no source file\r\n          FSUtils.printError(out, \"cp\", sourcefile, 2);\r\n          break;\r\n        case 1: \r\n          /* Just one file or dir to copy\r\n           * Possibilities:\r\n           *  1. Source = dir -> copy recursive if option -R is set\r\n           *  2. Source = file / Target = dir -> copy to dir\r\n           *  3. Source = file / Target = file -> override target\r\n           *  4. Source = file / Target is not existing  -> create a new file\r\n           */\r\n          if(FSUtils.isDir(data, sources[0])) {\r\n            //Test if it is a dir. Just copy if frecursive is set.\r\n            if(fRecursive) {\r\n              cpRecursive(sources[0], target, targetfile); \r\n              break;\r\n            } else {\r\n              FSUtils.printError(out, \"cp\", \r\n                  Token.string(FSUtils.getName(data, sources[0])), 100);\r\n              break;\r\n            }\r\n          }\r\n\r\n          byte[] size = Token.token(FSUtils.getSize(data, sources[0]));\r\n          byte[] mtime = Token.token(System.currentTimeMillis());\r\n\r\n          if(target.length == 1) {\r\n            if(FSUtils.isDir(data, target[0])) {\r\n              // copy file to dir\r\n              byte[] name = FSUtils.getName(data, sources[0]);\r\n              byte[] suffix = FSUtils.getSuffix(data, sources[0]);\r\n\r\n              if(!(target[0] == FSUtils.getROOTDIR())) {\r\n                preOfNewFile = target[0] + FSUtils.NUMATT;\r\n              }                             \r\n              FSUtils.insert(data, false, name, suffix, size, mtime,\r\n                  target[0], preOfNewFile);\r\n            } else {\r\n              // file exists - override\r\n              FSUtils.update(data, FSUtils.getName(data, target[0]),\r\n                  FSUtils.getSuffix(data, target[0]),\r\n                  size, mtime, target[0]);\r\n            }\r\n          } else {\r\n            // create new file and insert into current dir\r\n            byte[] name = Token.token(targetfile);\r\n            byte[] suffix = getSuffix(targetfile);\r\n\r\n            if(!(curDirPre == FSUtils.getROOTDIR())) {\r\n              preOfNewFile = curDirPre + FSUtils.NUMATT;\r\n            }        \r\n            FSUtils.insert(data, false, name, suffix, size, mtime,\r\n                curDirPre, preOfNewFile);\r\n          }      \r\n          break;\r\n\r\n\r\n        default:\r\n          if(target.length != 1) { \r\n            FSUtils.printError(out, \"cp\", \"\", 99);\r\n            break;\r\n          }\r\n        if(FSUtils.isFile(data, target[0])) {\r\n          FSUtils.printError(out, \"cp\", \r\n              Token.string(FSUtils.getName(data, target[0])), 20);\r\n          break;\r\n        }\r\n        if(!(target[0] == FSUtils.getROOTDIR())) {\r\n          preOfNewFile = target[0] + FSUtils.NUMATT;\r\n        }  \r\n        ArrayList<byte[]>  toInsert = new ArrayList<byte[]>();\r\n        int sizeToAdd = 0;\r\n        for(int i : sources) {  \r\n          i += sizeToAdd; \r\n          // if i is dir and frecursive is false go to next value\r\n          if(FSUtils.isDir(data, i)) {\r\n            if(fRecursive) {\r\n              sizeToAdd += data.size(i, Data.ELEM);    \r\n              cpRecursive(i, target, \"\");              \r\n              continue;\r\n            } else {\r\n              FSUtils.printError(out, \"cp\", \r\n                  Token.string(FSUtils.getName(data, i)), 100);\r\n              continue;\r\n            }\r\n          }      \r\n          toInsert.add(FSUtils.getName(data, i));\r\n          toInsert.add(FSUtils.getSuffix(data, i));\r\n          toInsert.add(Token.token(FSUtils.getSize(data, i)));\r\n        }\r\n        for(int j = 0; j < toInsert.size(); ++j) {\r\n\r\n          FSUtils.insert(data, false, toInsert.remove(0), toInsert.remove(0),\r\n              toInsert.remove(0), Token.token(System.currentTimeMillis()),\r\n              target[0], preOfNewFile);\r\n        }       \r\n        break;\r\n      }      \r\n    }\r\n  }","commit_id":"f070f8faa8e61c496b2c856d3b1ea1dbfa654ee1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Copies all contents of a dir.\r\n   * \r\n   * @param pre value of the source\r\n   * @param target the list if there is a target\r\n   * @param targetFile the name of the target\r\n   * @throws IOException in case of problems with the PrintOutput \r\n   */\r\n  private void cpRecursive(final int pre,\r\n      final int[] target, final String targetFile) throws IOException {\r\n\r\n    int[] dirs = new int[]{pre};\r\n    Data data = context.data();\r\n    ArrayList<byte[]>  toInsert = new ArrayList<byte[]>();\r\n\r\n    if(target.length == 1) {\r\n      if(FSUtils.isFile(data, target[0])) {\r\n        FSUtils.printError(out, \"cp\", \r\n            Token.string(FSUtils.getName(data, target[0])), 20);\r\n        return;\r\n      }\r\n    }\r\n    int d = 0;  \r\n    // remember fs hierarchy\r\n    while(0 < dirs.length) {\r\n      IntList allDir = new IntList();\r\n      while(d < dirs.length) {\r\n        int[] toCopy = FSUtils.getAllOfDir(data, dirs[d]);\r\n        toInsert.add(null);\r\n        // remember relative path for insertion\r\n        toInsert.add(FSUtils.getRelativePath(data, dirs[d], pre));\r\n        for(int p : toCopy) {\r\n          if(FSUtils.isDir(data, p)) {          \r\n            allDir.add(p);\r\n            toInsert.add(Token.token(\"d\"));\r\n          } else {\r\n            toInsert.add(Token.token(\"f\"));\r\n          }          \r\n          toInsert.add(FSUtils.getName(data, p));\r\n          toInsert.add(FSUtils.getSuffix(data, p));\r\n          toInsert.add(Token.token(FSUtils.getSize(data, p)));\r\n        }\r\n        ++d;\r\n      }\r\n      dirs = allDir.finish();\r\n      d = 0;\r\n    }\r\n    // pre value of the dir of insertion\r\n    int copyRoot;\r\n    // pre value of the parrent node\r\n    int parPre;\r\n    // need to calculate the pre value of the new directory\r\n    int preOfNewFile = 4;\r\n    // if target exists - insert into the target the directory to copy\r\n    if(target.length == 1) {\r\n      if(!(target[0] == FSUtils.getROOTDIR())) {\r\n        preOfNewFile = target[0] + 5;\r\n      }  \r\n      parPre = target[0];\r\n      // insert a copy of the source dir into the target dir\r\n      FSUtils.insert(data, true, FSUtils.getName(data, pre), Token.token(\"\"),\r\n          Token.token(0), Token.token(System.currentTimeMillis()),\r\n          parPre, preOfNewFile);\r\n      parPre = preOfNewFile;\r\n    } else {     \r\n      // target does not extist - create a new directory and copy all contents\r\n      // of the source directory to it\r\n      if(!(curDirPre == FSUtils.getROOTDIR())) {\r\n        preOfNewFile = curDirPre + 5;\r\n      }      \r\n      parPre = preOfNewFile; \r\n      FSUtils.insert(data, true, Token.token(targetFile), Token.token(\"\"),\r\n          Token.token(0), Token.token(System.currentTimeMillis()),\r\n          curDirPre, preOfNewFile);\r\n    }\r\n    out.print(\"Par: \" + parPre + \"\\n\");\r\n    // insert fs hierarchy\r\n    copyRoot = parPre;\r\n    while(!toInsert.isEmpty()) {      \r\n      if(toInsert.get(0) == null) {\r\n        toInsert.remove(0);\r\n        parPre = FSUtils.goToDir(data, copyRoot, \r\n            Token.string(toInsert.remove(0)));\r\n        continue;\r\n      }\r\n      boolean isDir = true;\r\n      if(Token.string(toInsert.remove(0)).equals(\"f\"))\r\n        isDir = false;      \r\n      FSUtils.insert(data, isDir, toInsert.remove(0), toInsert.remove(0),\r\n          toInsert.remove(0), Token.token(System.currentTimeMillis()),\r\n          parPre, parPre + 5);\r\n    }\r\n  }","id":44539,"modified_method":"/**\r\n   * Copies all contents of a dir.\r\n   * \r\n   * @param pre value of the source\r\n   * @param target the list if there is a target\r\n   * @param targetFile the name of the target\r\n   * @throws IOException in case of problems with the PrintOutput \r\n   */\r\n  private void cpRecursive(final int pre,\r\n      final int[] target, final String targetFile) throws IOException {\r\n\r\n    int[] dirs = new int[]{pre};\r\n    Data data = context.data();\r\n    ArrayList<byte[]>  toInsert = new ArrayList<byte[]>();\r\n\r\n    if(target.length == 1) {\r\n      if(FSUtils.isFile(data, target[0])) {\r\n        FSUtils.printError(out, \"cp\", \r\n            Token.string(FSUtils.getName(data, target[0])), 20);\r\n        return;\r\n      }\r\n    }\r\n    int d = 0;  \r\n    // remember fs hierarchy\r\n    while(0 < dirs.length) {\r\n      IntList allDir = new IntList();\r\n      while(d < dirs.length) {\r\n        int[] toCopy = FSUtils.getAllOfDir(data, dirs[d]);\r\n        toInsert.add(null);\r\n        // remember relative path for insertion\r\n        toInsert.add(FSUtils.getRelativePath(data, dirs[d], pre));\r\n        for(int p : toCopy) {\r\n          if(FSUtils.isDir(data, p)) {          \r\n            allDir.add(p);\r\n            toInsert.add(Token.token(\"d\"));\r\n          } else {\r\n            toInsert.add(Token.token(\"f\"));\r\n          }          \r\n          toInsert.add(FSUtils.getName(data, p));\r\n          toInsert.add(FSUtils.getSuffix(data, p));\r\n          toInsert.add(Token.token(FSUtils.getSize(data, p)));\r\n        }\r\n        ++d;\r\n      }\r\n      dirs = allDir.finish();\r\n      d = 0;\r\n    }\r\n    // pre value of the dir of insertion\r\n    int copyRoot;\r\n    // pre value of the parrent node\r\n    int parPre;\r\n    // need to calculate the pre value of the new directory\r\n    int preOfNewFile = 4;\r\n    // if target exists - insert into the target the directory to copy\r\n    if(target.length == 1) {\r\n      if(!(target[0] == FSUtils.getROOTDIR())) {\r\n        preOfNewFile = target[0] + FSUtils.NUMATT;\r\n      }  \r\n      parPre = target[0];\r\n      // insert a copy of the source dir into the target dir\r\n      FSUtils.insert(data, true, FSUtils.getName(data, pre), Token.token(\"\"),\r\n          Token.token(0), Token.token(System.currentTimeMillis()),\r\n          parPre, preOfNewFile);\r\n      parPre = preOfNewFile;\r\n    } else {     \r\n      // target does not extist - create a new directory and copy all contents\r\n      // of the source directory to it\r\n      if(!(curDirPre == FSUtils.getROOTDIR())) {\r\n        preOfNewFile = curDirPre + FSUtils.NUMATT;\r\n      }      \r\n      parPre = preOfNewFile; \r\n      FSUtils.insert(data, true, Token.token(targetFile), Token.token(\"\"),\r\n          Token.token(0), Token.token(System.currentTimeMillis()),\r\n          curDirPre, preOfNewFile);\r\n    }    \r\n    // insert fs hierarchy\r\n    copyRoot = parPre;\r\n    byte[] f = Token.token(\"f\");\r\n    while(!toInsert.isEmpty()) {      \r\n      if(toInsert.get(0) == null) {\r\n        toInsert.remove(0);\r\n        parPre = FSUtils.goToDir(data, copyRoot, \r\n            Token.string(toInsert.remove(0)));\r\n        continue;\r\n      }      \r\n      boolean isDir = true;\r\n      if(Token.eq(toInsert.remove(0), f))\r\n        isDir = false;      \r\n      FSUtils.insert(data, isDir, toInsert.remove(0), toInsert.remove(0),\r\n          toInsert.remove(0), Token.token(System.currentTimeMillis()),\r\n          parPre, parPre + FSUtils.NUMATT);\r\n    }\r\n  }","commit_id":"f070f8faa8e61c496b2c856d3b1ea1dbfa654ee1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the pre value of a dir.\r\n   *  \r\n   * @param out - the Outputstream\r\n   * @param programm - name of the programm\r\n   * @param arg - passed by the console\r\n   * @param error - error code\r\n   * @throws IOException - in case of problems with the PrintOutput \r\n   */\r\n  public static void printError(final PrintOutput out, final String programm, \r\n      final String arg, final int error) throws IOException {\r\n    switch(error) {\r\n      case 1:\r\n        out.print(programm + \": \" + arg + \": \" + EPERM);\r\n        break;\r\n      case 2:\r\n        out.print(programm + \": \" + arg + \": \" + ENOENT);\r\n        break;\r\n      case 5:\r\n        out.print(programm + \": \" + arg + \": \" + EIO);\r\n        break;\r\n      case 13:\r\n        out.print(programm + \": \" + arg + \": \" + EACCES);\r\n        break;\r\n      case 17:\r\n        out.print(programm + \": \" + arg + \": \" + EEXIST);\r\n        break;\r\n      case 20:\r\n        out.print(programm + \": \" + arg + \": \" + ENOTDIR);\r\n        break;\r\n      case 21:\r\n        out.print(programm + \": \" + arg + \": \" + EISDIR);\r\n        break;\r\n      case 22:\r\n        out.print(programm + \": \" + arg + \": \" + EACCES);\r\n        break;\r\n      case 30:\r\n        out.print(programm + \": \" + arg + \": \" + EROFS);\r\n        break;\r\n      case 34:\r\n        out.print(programm + \": \" + arg + \": \" + ERANGE);\r\n        break;\r\n      case 63:\r\n        out.print(programm + \": \" + arg + \": \" + ENAMETOOLONG);\r\n        break;\r\n      case 66:\r\n        out.print(programm + \": \" + arg + \": \" + ENOTEMPTY);\r\n        break;\r\n      case 79:\r\n        out.print(programm + \": \" + arg + \": \" + EFTYPE);\r\n        break;\r\n      case 99:\r\n        out.print(programm + \": \" + arg + \": \" + EMISSARG);\r\n        break;\r\n      case 100:\r\n        out.print(programm + \": \" + arg + \": \" + EOMDIR);\r\n        break;        \r\n      case 101:\r\n        out.print(programm + \": \" + arg + \": \" + ENAMENOALLOW);\r\n        break;     \r\n      case 102:\r\n        out.print(programm + \": \" + arg + \": \" + EINVOPT);\r\n        break;  \r\n      default:\r\n        out.print(programm + \": \" + arg + \": \" + EUND);\r\n      break;\r\n    }\r\n    out.print(NL);\r\n  }","id":44540,"modified_method":"/**\r\n   * Returns the pre value of a dir.\r\n   *  \r\n   * @param out - the Outputstream\r\n   * @param programm - name of the programm\r\n   * @param arg - passed by the console\r\n   * @param error - error code\r\n   * @throws IOException - in case of problems with the PrintOutput \r\n   */\r\n  public static void printError(final PrintOutput out, final String programm, \r\n      final String arg, final int error) throws IOException {\r\n    switch(error) {\r\n      case 1:\r\n        out.print(programm + \": \" + arg + \": \" + EPERM);\r\n        break;\r\n      case 2:\r\n        out.print(programm + \": \" + arg + \": \" + ENOENT);\r\n        break;\r\n      case 5:\r\n        out.print(programm + \": \" + arg + \": \" + EIO);\r\n        break;\r\n      case 13:\r\n        out.print(programm + \": \" + arg + \": \" + EACCES);\r\n        break;\r\n      case 17:\r\n        out.print(programm + \": \" + arg + \": \" + EEXIST);\r\n        break;\r\n      case 20:\r\n        out.print(programm + \": \" + arg + \": \" + ENOTDIR);\r\n        break;\r\n      case 21:\r\n        out.print(programm + \": \" + arg + \": \" + EISDIR);\r\n        break;\r\n      case 22:\r\n        out.print(programm + \": \" + arg + \": \" + EACCES);\r\n        break;\r\n      case 30:\r\n        out.print(programm + \": \" + arg + \": \" + EROFS);\r\n        break;\r\n      case 34:\r\n        out.print(programm + \": \" + arg + \": \" + ERANGE);\r\n        break;\r\n      case 63:\r\n        out.print(programm + \": \" + arg + \": \" + ENAMETOOLONG);\r\n        break;\r\n      case 66:\r\n        out.print(programm + \": \" + arg + \": \" + ENOTEMPTY);\r\n        break;\r\n      case 79:\r\n        out.print(programm + \": \" + arg + \": \" + EFTYPE);\r\n        break;\r\n      case 99:\r\n        out.print(programm + \": \" + EMISSARG);\r\n        break;\r\n      case 100:\r\n        out.print(programm + \": \" + arg + \": \" + EOMDIR);\r\n        break;        \r\n      case 101:\r\n        out.print(programm + \": \" + arg + \": \" + ENAMENOALLOW);\r\n        break;     \r\n      case 102:\r\n        out.print(programm + \": \" + arg + \": \" + EINVOPT);\r\n        break;  \r\n      default:\r\n        out.print(programm + \": \" + arg + \": \" + EUND);\r\n      break;\r\n    }\r\n    out.print(NL);\r\n  }","commit_id":"f070f8faa8e61c496b2c856d3b1ea1dbfa654ee1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the pre value of a dir.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @param path - path name\r\n   * @return -  all pre values of all files\r\n   */\r\n  public static int[] getOneSpecificFileOrDir(final Data data, final int pre,\r\n      final String path) {\r\n\r\n    final IntList res = new IntList();\r\n    final DirIterator it = new DirIterator(data, pre);\r\n\r\n    String fileToFind = FSUtils.transformToRegex(path);\r\n    while(it.more()) {\r\n      final int n = it.next();\r\n      if(Pattern.matches(fileToFind, Token.string(getName(data, n)))) \r\n        res.add(n);\r\n    }\r\n    return res.finish();\r\n  }","id":44541,"modified_method":"/**\r\n   * Returns the pre value of a dir.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @param path - path name\r\n   * @return -  all pre values of all files\r\n   */\r\n  public static int getOneSpecificDir(final Data data, final int pre,\r\n      final String path) {\r\n\r\n    final DirIterator it = new DirIterator(data, pre);\r\n\r\n    String fileToFind = FSUtils.transformToRegex(path);\r\n    while(it.more()) {\r\n      final int n = it.next();\r\n      if(Pattern.matches(fileToFind, Token.string(getName(data, n))) \r\n          && isDir(data, n)) \r\n        return n;\r\n    }\r\n    return -1;\r\n  }","commit_id":"f070f8faa8e61c496b2c856d3b1ea1dbfa654ee1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Performs a touch command.\n   * \n   * @param cmd - command line\n   * @throws IOException - in case of problems with the PrintOutput \n   */\n  public void mkdirMain(final String cmd) \n  throws IOException {\n\n    GetOpts g = new GetOpts(cmd, \"h\");\n    // get all Options\n    int ch = g.getopt();\n    while (ch != -1) {\n      switch (ch) {\n        case 'h':\n          printHelp();\n          return;\n        case ':':         \n          FSUtils.printError(out, \"mkdir\", g.getPath(), 99);\n          return;  \n        case '?':         \n          FSUtils.printError(out, \"mkdir\", g.getPath(), 102);\n          return;\n      }      \n      ch = g.getopt();\n    }\n    // if there is path expression remove it     \n    if(g.getPath() != null) {      \n      mkdir(g.getPath());\n    } \n  }","id":44542,"modified_method":"/**\n   * Performs a touch command.\n   * \n   * @param cmd - command line\n   * @throws IOException - in case of problems with the PrintOutput \n   */\n  public void mkdirMain(final String cmd) \n  throws IOException {\n\n    GetOpts g = new GetOpts(cmd, \"h\", 1);\n    // get all Options\n    int ch = g.getopt();\n    while (ch != -1) {\n      switch (ch) {\n        case 'h':\n          printHelp();\n          return;\n        case ':':         \n          FSUtils.printError(out, \"mkdir\", g.getPath(), 99);\n          return;  \n        case '?':         \n          FSUtils.printError(out, \"mkdir\", g.getPath(), 102);\n          return;\n      }      \n      ch = g.getopt();\n    }\n    // if there is path expression remove it     \n    if(g.getPath() != null) {      \n      mkdir(g.getPath());\n    } else {\n      FSUtils.printError(out, \"mkdir\", \"\", 99);\n    }\n  }","commit_id":"f070f8faa8e61c496b2c856d3b1ea1dbfa654ee1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Performs an mkdir command.\n   *  \n   *  @param path The name of the file\n   *  @throws IOException in case of problems with the PrintOutput \n   */\n  private void mkdir(final String path) throws IOException {\n\n    String dir = \"\";\n    int beginIndex = path.lastIndexOf('/');\n    if(beginIndex == -1) {\n      dir = path;\n    } else {\n      curDirPre = FSUtils.goToDir(context.data(), curDirPre, \n          path.substring(0, beginIndex));   \n      if(curDirPre == -1) {\n        FSUtils.printError(out, \"mkdir\", path, 2);        \n      } else {\n        dir = path.substring(beginIndex + 1);\n      }\n    }\n    int[] sources =  FSUtils.getOneSpecificFileOrDir(context.data(), \n        curDirPre, dir);\n    \n   \n    \n    if(sources.length > 0) {\n      for(int dirPre : sources) {\n        if(FSUtils.isDir(context.data(), dirPre)) {\n          FSUtils.printError(out, \"mkdir\", path, 17);\n          return;\n        }\n      }\n    } else {   \n      // add new dir  \n      try {\n        int preNewFile = 4;\n        if(!(curDirPre == FSUtils.getROOTDIR())) {\n          preNewFile = curDirPre + 5;\n        }\n        FSUtils.insert(context.data(), true, Token.token(dir), \n            Token.token(\"\"), Token.token(0), \n            Token.token(System.currentTimeMillis()), curDirPre, preNewFile);\n      } catch(Exception e) {\n        e.printStackTrace();\n      }\n    }\n  }","id":44543,"modified_method":"/**\n   * Performs an mkdir command.\n   *  \n   *  @param path The name of the file\n   *  @throws IOException in case of problems with the PrintOutput \n   */\n  private void mkdir(final String path) throws IOException {\n\n    String dir = \"\";\n    int beginIndex = path.lastIndexOf('/');\n    if(beginIndex == -1) {\n      dir = path;\n    } else {\n      curDirPre = FSUtils.goToDir(context.data(), curDirPre, \n          path.substring(0, beginIndex));   \n      if(curDirPre == -1) {\n        FSUtils.printError(out, \"mkdir\", path, 2);     \n        return;\n      } else {\n        dir = path.substring(beginIndex + 1);\n      }\n    }\n\n    if(!FSUtils.validFileName(dir)) {\n      FSUtils.printError(out, \"mkdir\", dir, 101);              \n      return;\n    }\n\n    int source =  FSUtils.getOneSpecificDir(context.data(), \n        curDirPre, dir);\n    if(source > -1) {\n      FSUtils.printError(out, \"mkdir\", path, 17);\n      return;\n\n\n    } else {   \n      // add new dir  \n      try {\n        int preNewFile = 4;\n        if(!(curDirPre == FSUtils.getROOTDIR())) {\n          preNewFile = curDirPre + FSUtils.NUMATT;\n        }\n        FSUtils.insert(context.data(), true, Token.token(dir), \n            Token.token(\"\"), Token.token(0), \n            Token.token(System.currentTimeMillis()), curDirPre, preNewFile);\n      } catch(Exception e) {\n        e.printStackTrace();\n      }\n    }\n  }","commit_id":"f070f8faa8e61c496b2c856d3b1ea1dbfa654ee1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs a rm command.\r\n   *  \r\n   *  @param path The name of the file\r\n   *  @throws IOException in case of problems with the PrintOutput \r\n   */\r\n  private void remove(final String path) throws IOException {\r\n    Data data = context.data();\r\n\r\n    int[] del = FSUtils.getSpecificFilesOrDirs(data, curDirPre, \r\n        path);\r\n    long sizeOfNode = 0;\r\n    for(int toDel : del) {\r\n      if(toDel == -1) {\r\n        FSUtils.printError(out, \"rm\", path, 2);\r\n        return;\r\n      } else {\r\n        /* \r\n         * Pre Value of all nodes changes if one node is deleted.\r\n         * This is the adjustment of the former \r\n         */\r\n        toDel -= sizeOfNode;\r\n        if((FSUtils.isDir(data, toDel) && fRecursive) ||\r\n            (FSUtils.isFile(data, toDel))) {\r\n          try {            \r\n            sizeOfNode += data.size(toDel, Data.ELEM);\r\n            data.delete(toDel);\r\n            data.flush();  \r\n          } catch(Exception e) {\r\n            e.printStackTrace();\r\n          }     \r\n        } else {\r\n          FSUtils.printError(out, \"rm\", path, 21);\r\n        }\r\n      }\r\n    }\r\n    \r\n  }","id":44544,"modified_method":"/**\r\n   * Performs a rm command.\r\n   *  \r\n   *  @param path The name of the file\r\n   *  @throws IOException in case of problems with the PrintOutput \r\n   */\r\n  private void remove(final String path) throws IOException {\r\n    Data data = context.data();\r\n\r\n    int[] del = FSUtils.getSpecificFilesOrDirs(data, curDirPre, \r\n        path);\r\n    long sizeOfNode = 0;\r\n    for(int toDel : del) {\r\n      if(toDel == -1) {\r\n        FSUtils.printError(out, \"rm\", path, 2);\r\n        return;\r\n      } else {\r\n        /* \r\n         * Pre Value of all nodes changes if one node is deleted.\r\n         * This is the adjustment of the former \r\n         */\r\n        toDel -= sizeOfNode;\r\n        if((FSUtils.isDir(data, toDel) && fRecursive) ||\r\n            (FSUtils.isFile(data, toDel))) {\r\n\r\n          sizeOfNode += data.size(toDel, Data.ELEM);\r\n          FSUtils.delete(data, toDel);\r\n        } else {\r\n          FSUtils.printError(out, \"rm\", path, 21);\r\n        }\r\n      }\r\n    }\r\n\r\n  }","commit_id":"f070f8faa8e61c496b2c856d3b1ea1dbfa654ee1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs a touch command.\r\n   *  \r\n   *  @param path The name of the file \r\n   * @throws IOException - in case of problems with the PrintOutput \r\n   */\r\n  private void touch(final String path) throws IOException {\r\n\r\n    String file = path.substring(path.lastIndexOf('/') + 1);\r\n\r\n    int[] preFound =  FSUtils.getSpecificFilesOrDirs(context.data(), \r\n        curDirPre, path);\r\n    if(preFound.length  > 0) {\r\n      for(int i : preFound) {\r\n        if(FSUtils.isFile(context.data(), i)) {\r\n          FSUtils.update(context.data(), null, null, null,\r\n             Token.token(System.currentTimeMillis()), i);\r\n        }\r\n      }\r\n    } else {   \r\n      // add new file \r\n      if(file.indexOf('?') > 0 || file.indexOf('*') > 0 \r\n          || file.indexOf('[') > 0 || file.indexOf(']') > 0) {\r\n        FSUtils.printError(out, \"touch\", file, 101);              \r\n        return;\r\n      } \r\n      try {\r\n        int preNewFile = 4;\r\n        if(!(curDirPre == FSUtils.getROOTDIR())) {\r\n          preNewFile = curDirPre + 5;\r\n        }\r\n        // TODO<HS> Go to dir... \r\n        FSUtils.insert(context.data(), false, Token.token(file), \r\n            getSuffix(file), Token.token(0), \r\n            Token.token(System.currentTimeMillis()),\r\n            curDirPre, preNewFile);        \r\n      } catch(Exception e) {\r\n        e.printStackTrace();\r\n      }\r\n    }\r\n  }","id":44545,"modified_method":"/**\r\n   * Performs a touch command.\r\n   *  \r\n   *  @param path The name of the file \r\n   * @throws IOException - in case of problems with the PrintOutput \r\n   */\r\n  private void touch(final String path) throws IOException {\r\n    \r\n    int beginIndex = path.lastIndexOf('/');\r\n    if(beginIndex > -1) {\r\n      curDirPre = FSUtils.goToDir(context.data(), curDirPre, \r\n          path.substring(0, beginIndex));   \r\n      if(curDirPre == -1) {\r\n        FSUtils.printError(out, \"touch\", path, 2);\r\n        return;\r\n      } \r\n    }\r\n    \r\n    String file = path.substring(path.lastIndexOf('/') + 1);\r\n\r\n    int[] preFound =  FSUtils.getSpecificFilesOrDirs(context.data(), \r\n        curDirPre, file);\r\n    if(preFound.length  > 0 && preFound[0] != -1) {\r\n      for(int i : preFound) {\r\n        if(FSUtils.isFile(context.data(), i)) {\r\n          FSUtils.update(context.data(), null, null, null,\r\n             Token.token(System.currentTimeMillis()), i);\r\n        }\r\n      }\r\n    } else {   \r\n      // add new file \r\n      if(!FSUtils.validFileName(file)) {\r\n        FSUtils.printError(out, \"touch\", file, 101);              \r\n        return;\r\n      } \r\n      try {\r\n        int preNewFile = 4;\r\n        if(!(curDirPre == FSUtils.getROOTDIR())) {\r\n          preNewFile = curDirPre + FSUtils.NUMATT;\r\n        }\r\n        FSUtils.insert(context.data(), false, Token.token(file), \r\n            getSuffix(file), Token.token(0), \r\n            Token.token(System.currentTimeMillis()),\r\n            curDirPre, preNewFile);        \r\n      } catch(Exception e) {\r\n        e.printStackTrace();\r\n      }\r\n    }\r\n  }","commit_id":"f070f8faa8e61c496b2c856d3b1ea1dbfa654ee1","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the pre value of a dir.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @param dir - directory name\r\n   * @param kind - kind value of dir (elem)\r\n   * @return -  all pre values of all files\r\n   */\r\n  public static int getSpecificFile(final Data data, final int pre,\r\n      final String dir, final int kind) {\r\n    int n = pre;        \r\n    // Wie weit das Verzeichnis reicht\r\n    int size = data.size(n, kind) + n;\r\n    // Zu erstem file/dir springen\r\n    n += data.attSize(n, data.kind(n));\r\n\r\n    while(n < size) {\r\n      if(isFile(data , n)) {\r\n        // pre speichern\r\n        if(Token.string(getName(data, n)).equals(dir)) {\r\n         return n; \r\n        }\r\n      }\r\n      n += data.size(n, kind);\r\n    }    \r\n    return -1;\r\n  }","id":44546,"modified_method":"/**\r\n   * Returns the pre value of a dir.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @param dir - directory name\r\n   * @param kind - kind value of dir (elem)\r\n   * @return -  all pre values of all files\r\n   */\r\n  public static int getSpecificFile(final Data data, final int pre,\r\n      final byte[] dir, final int kind) {\r\n    int n = pre;        \r\n    // Wie weit das Verzeichnis reicht\r\n    int size = data.size(n, kind) + n;\r\n    // Zu erstem file/dir springen\r\n    n += data.attSize(n, data.kind(n));\r\n\r\n    while(n < size) {\r\n      if(isFile(data , n)) {\r\n        // pre speichern\r\n        if(Token.eq(getName(data, n), dir)) {\r\n         return n; \r\n        }\r\n      }\r\n      n += data.size(n, kind);\r\n    }    \r\n    return -1;\r\n  }","commit_id":"29122c88cb4a81e0f0d4e129f54f97b49668d9b6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   *  Test pathexpression.\r\n   * \r\n   * @param data - data table \r\n   * @param pre - pre value\r\n   * @param path - path expression\r\n   * @return pre value of the result dir \r\n   */\r\n  public static int goToDir(final Data data, final int pre, final String path) {\r\n\r\n    int n = pre;\r\n    int kind = data.kind(pre);\r\n\r\n    // No path -> return the same dir\r\n    if(path.length() < 1) {\r\n      return pre;\r\n    }\r\n\r\n    // Seperate path expression \r\n    String[] paths = path.split(\"/\");\r\n\r\n    for(String p : paths) {\r\n      // Parent directory\r\n      if(p.equalsIgnoreCase(\"..\")) {\r\n        n = data.parent(n, kind);\r\n      // / was first char of the path - after split it's \"\"  \r\n      } else if(p.equalsIgnoreCase(\"\")) {\r\n        n = 3;\r\n      // if path equals \".\" do nothing else getDir  \r\n      } else if(!p.equalsIgnoreCase(\".\")) {\r\n        n = getSpecificDir(data, n, p, kind);\r\n      }\r\n      // if there is no such dir return -1\r\n      if(n == -1) {\r\n        return -1;\r\n      }      \r\n    }\r\n    return n;\r\n  }","id":44547,"modified_method":"/**\r\n   *  Test pathexpression.\r\n   * \r\n   * @param data - data table \r\n   * @param pre - pre value\r\n   * @param path - path expression\r\n   * @return pre value of the result dir \r\n   */\r\n  public static int goToDir(final Data data, final int pre, final String path) {\r\n\r\n    int n = pre;\r\n    int kind = data.kind(pre);\r\n\r\n    // No path -> return the same dir\r\n    if(path.length() < 1) {\r\n      return pre;\r\n    }\r\n\r\n    // Seperate path expression \r\n    String[] paths = path.split(\"/\");\r\n\r\n    for(String p : paths) {\r\n      // Parent directory\r\n      if(p.equals(\"..\")) {\r\n        n = data.parent(n, kind);\r\n      // / was first char of the path - after split it's \"\"  \r\n      } else if(p.equals(\"\")) {\r\n        n = 3;\r\n      // if path equals \".\" do nothing else getDir  \r\n      } else if(!p.equals(\".\")) {\r\n        n = getSpecificDir(data, n, Token.token(p), kind);\r\n      }\r\n      // if there is no such dir return -1\r\n      if(n == -1) {\r\n        return -1;\r\n      }      \r\n    }\r\n    return n;\r\n  }","commit_id":"29122c88cb4a81e0f0d4e129f54f97b49668d9b6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns all directories and files of a directory.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @return -  all pre values of the dirs and files\r\n   */\r\n  public static int[] getAllOfDir(final Data data, final int pre) {\r\n\r\n    // Den Elementtyp einmal speichern\r\n    int kind = data.kind(pre);    \r\n    int n = pre;    \r\n    // Wie weit das Verzeichnis reicht\r\n    int size = data.size(n, kind) + n;\r\n    // Zu erstem file/dir springen\r\n    n += data.attSize(n, data.kind(n));\r\n    // Ergebnisarray \r\n    int[] res = new int[((size - n) / 5) + 1];\r\n    int i = 0;\r\n    while(n < size) {\r\n      // pre speichern\r\n      res[i++] = n;\r\n      n += data.size(n, data.kind(n));\r\n    }    \r\n    return res;        \r\n  }","id":44548,"modified_method":"/**\r\n   * Returns all directories and files of a directory.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @return -  all pre values of the dirs and files\r\n   */\r\n  public static int[] getAllOfDir(final Data data, final int pre) {\r\n\r\n    // Den Elementtyp einmal speichern\r\n    int kind = data.kind(pre);    \r\n    int n = pre;    \r\n    // Wie weit das Verzeichnis reicht\r\n    int size = data.size(n, kind) + n;\r\n    // Zu erstem file/dir springen\r\n    n += data.attSize(n, kind);\r\n    // Ergebnisarray \r\n    // <HS> ..calculation size/5 is dubious as XML structure might change,\r\n    //    (e.g. if file contents are included)..\r\n    IntList res = new IntList();\r\n    while(n < size) {\r\n      // pre speichern\r\n      res.add(n);\r\n      n += data.size(n, data.kind(n));\r\n    }    \r\n    return res.finish();\r\n  }","commit_id":"29122c88cb4a81e0f0d4e129f54f97b49668d9b6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns the pre value of a dir.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @param dir - directory name\r\n   * @param kind - kind value of dir (elem)\r\n   * @return -  all pre values of all files\r\n   */\r\n  public static int getSpecificDir(final Data data, final int pre,\r\n      final String dir, final int kind) {\r\n    int n = pre;        \r\n    // Wie weit das Verzeichnis reicht\r\n    int size = data.size(n, kind) + n;\r\n    // Zu erstem file/dir springen\r\n    n += data.attSize(n, data.kind(n));\r\n\r\n    while(n < size) {\r\n      if(isDir(data , n)) {\r\n        // pre speichern\r\n        if(Token.string(getName(data, n)).equals(dir)) {\r\n         return n; \r\n        }\r\n      }\r\n      n += data.size(n, kind);\r\n    }    \r\n    return -1;\r\n  }","id":44549,"modified_method":"/**\r\n   * Returns the pre value of a dir.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @param dir - directory name\r\n   * @param kind - kind value of dir (elem)\r\n   * @return -  all pre values of all files\r\n   */\r\n  public static int getSpecificDir(final Data data, final int pre,\r\n      final byte[] dir, final int kind) {\r\n    int n = pre;        \r\n    // Wie weit das Verzeichnis reicht\r\n    int size = data.size(n, kind) + n;\r\n    // Zu erstem file/dir springen\r\n    n += data.attSize(n, data.kind(n));\r\n\r\n    while(n < size) {\r\n      if(isDir(data , n)) {\r\n        // pre speichern\r\n        // <CG> using byte comparison to avoid byte/string conversion\r\n        if(Token.eq(getName(data, n), dir)) {\r\n          return n;\r\n        }\r\n      }\r\n      n += data.size(n, kind);\r\n    }    \r\n    return -1;\r\n  }","commit_id":"29122c88cb4a81e0f0d4e129f54f97b49668d9b6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns all files of a directory.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @return -  all pre values of all files\r\n   */\r\n  public static int[] getAllFiles(final Data data, final int pre) {\r\n    // Den Elementtyp einmal speichern\r\n    int kind = data.kind(pre);    \r\n    int n = pre;    \r\n    // Wie weit das Verzeichnis reicht\r\n    int size = data.size(n, kind) + n;\r\n    // Zu erstem file/dir springen\r\n    n += data.attSize(n, data.kind(n));\r\n    // Ergebnisarray \r\n    int[] res = new int[((size - n) / 5) + 1];\r\n    int i = 0;\r\n    while(n < size) {\r\n      if(isFile(data , n)) {\r\n        // pre speichern\r\n        res[i++] = n;        \r\n      }\r\n      n += data.size(n, data.kind(n));\r\n    }    \r\n    return res;\r\n  }","id":44550,"modified_method":"/**\r\n   * Returns all files of a directory.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @return -  all pre values of all files\r\n   */\r\n  public static int[] getAllFiles(final Data data, final int pre) {\r\n    // Den Elementtyp einmal speichern\r\n    int kind = data.kind(pre);    \r\n    int n = pre;    \r\n    // Wie weit das Verzeichnis reicht\r\n    int size = data.size(n, kind) + n;\r\n    // Zu erstem file/dir springen\r\n    n += data.attSize(n, kind);\r\n    // Ergebnisarray \r\n    IntList res = new IntList();\r\n    while(n < size) {\r\n      if(isFile(data , n)) {\r\n        // pre speichern\r\n        res.add(n);\r\n      }\r\n      n += data.size(n, data.kind(n));\r\n    }    \r\n    return res.finish();\r\n  }","commit_id":"29122c88cb4a81e0f0d4e129f54f97b49668d9b6","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Returns all directories of a directory.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @return -  all pre values of all files\r\n   */\r\n  public static int[] getAllDir(final Data data, final int pre) {\r\n    // Den Elementtyp einmal speichern\r\n    int kind = data.kind(pre);    \r\n    int n = pre;    \r\n    // Wie weit das Verzeichnis reicht\r\n    int size = data.size(n, kind) + n;\r\n    // Zu erstem file/dir springen\r\n    n += data.attSize(n, kind);\r\n    // Ergebnisarray \r\n    int[] res = new int[((size - n) / 5) + 1];\r\n    int i = 0;\r\n    while(n < size) {\r\n      if(isDir(data , n)) {\r\n        // pre speichern\r\n        res[i++] = n;        \r\n      }\r\n      n += data.size(n, kind);\r\n    }    \r\n    return res;\r\n  }","id":44551,"modified_method":"/**\r\n   * Returns all directories of a directory.\r\n   *  \r\n   * @param data - the data table\r\n   * @param pre - pre value of the \"parent\" directory\r\n   * @return -  all pre values of all files\r\n   */\r\n  public static int[] getAllDir(final Data data, final int pre) {\r\n    // Den Elementtyp einmal speichern\r\n    int kind = data.kind(pre);    \r\n    int n = pre;    \r\n    // Wie weit das Verzeichnis reicht\r\n    int size = data.size(n, kind) + n;\r\n    // Zu erstem file/dir springen\r\n    n += data.attSize(n, kind);\r\n    // Ergebnisarray \r\n    IntList res = new IntList();\r\n    while(n < size) {\r\n      if(isDir(data , n)) {\r\n        // pre speichern\r\n        res.add(n);\r\n      }\r\n      n += data.size(n, kind);\r\n    }    \r\n    return res.finish();\r\n  }","commit_id":"29122c88cb4a81e0f0d4e129f54f97b49668d9b6","url":"https://github.com/BaseXdb/basex"},{"original_method":"protected EObject internalResolveElementAt(XtextResource resource, int offset, boolean isContainment) {\n\t\tIParseResult parseResult = resource.getParseResult();\n\t\tif (parseResult != null && parseResult.getRootNode() != null) {\n\t\t\tILeafNode leaf = NodeModelUtils.findLeafNodeAtOffset(parseResult.getRootNode(), offset);\n\t\t\tif(leaf.isHidden() && leaf.getOffset() == offset) {\n\t\t\t\tleaf = NodeModelUtils.findLeafNodeAtOffset(parseResult.getRootNode(), offset - 1);\n\t\t\t}\n\t\t\tINode node = leaf;\n\t\t\twhile (node != null) {\n\t\t\t\tif (node.getGrammarElement() instanceof CrossReference) {\n\t\t\t\t\treturn resolveCrossReferencedElement(node);\n\t\t\t\t} else if (isContainment && node.hasDirectSemanticElement()) {\n\t\t\t\t\treturn node.getSemanticElement();\n\t\t\t\t} else {\n\t\t\t\t\tnode = node.getParent();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":44552,"modified_method":"protected EObject internalResolveElementAt(XtextResource resource, int offset, boolean isContainment) {\n\t\tIParseResult parseResult = resource.getParseResult();\n\t\tif (parseResult != null && parseResult.getRootNode() != null) {\n\t\t\tILeafNode leaf = NodeModelUtils.findLeafNodeAtOffset(parseResult.getRootNode(), offset);\n\t\t\tif (leaf != null && leaf.isHidden() && leaf.getOffset() == offset) {\n\t\t\t\tleaf = NodeModelUtils.findLeafNodeAtOffset(parseResult.getRootNode(), offset - 1);\n\t\t\t}\n\t\t\tINode node = leaf;\n\t\t\twhile (node != null) {\n\t\t\t\tif (node.getGrammarElement() instanceof CrossReference) {\n\t\t\t\t\treturn resolveCrossReferencedElement(node);\n\t\t\t\t} else if (isContainment && node.hasDirectSemanticElement()) {\n\t\t\t\t\treturn node.getSemanticElement();\n\t\t\t\t} else {\n\t\t\t\t\tnode = node.getParent();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"35c4fa75eaebb2d20b13d77cf1dd542aa009807e","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @return a new <code>XtextCompletionProposal<\/code> for the given text and\n\t *         offset.\n\t */\n\tprotected final XtextCompletionProposal createCompletionProposal(String text, int offset) {\n\t\treturn new XtextCompletionProposal(text, new StyledString(text), text, getDefaultImageFilePath(),\n\t\t\t\tgetPluginId(), offset);\n\t}","id":44553,"modified_method":"/**\n\t * @return a new <code>XtextCompletionProposal<\/code> for the given text and\n\t *         offset.\n\t */\n\tprotected final XtextCompletionProposal createCompletionProposal(AbstractElement abstractElement, EObject model,\n\t\t\tString text, int offset) {\n\t\treturn new XtextCompletionProposal(abstractElement, model, text, new StyledString(text), text,\n\t\t\t\tgetDefaultImageFilePath(), getPluginId(), offset);\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Concrete subclasses can override this for custom sort and filter\n\t * behavior. Gets called after all completion proposals have been collected.\n\t * \n\t * The default behavior of this implementation is to sort duplicates and to trim \n\t * matching <code>ICompletionProposal#displayString<\/code> with matching prefix values.\n\t * \n\t * @param completionProposalList matching {@link ICompletionProposal} to sort and filter\n\t * @param model - the most specific model element under the cursor. \n\t * @param prefix - the prefix under the cursor or null if there is no prefix\n\t * @return the sorted and filtered <code>ICompletionProposal<\/code> list.\n\t * \n\t */\n\tprotected List<? extends ICompletionProposal> doSortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList,EObject model,String prefix) {\n\t\t\n\t\tif (model instanceof LeafNode) {\n\t\t\t\n\t\t\tLeafNode leafNode = (LeafNode) model;\n\t\t\t\n\t\t\tMap<String,ICompletionProposal> displayString2ICompletionProposalMap = new HashMap<String,ICompletionProposal>();\n\t\t\t\n\t\t\tfor (Iterator<? extends ICompletionProposal> iterator = completionProposalList.iterator(); iterator.hasNext();) {\n\n\t\t\t\tICompletionProposal completionProposal = iterator.next();\n\t\t\t\t\n\t\t\t\t// filter duplicate displayString\n\t\t\t\tif (!displayString2ICompletionProposalMap.containsKey(completionProposal.getDisplayString())) {\n\t\t\t\t\n\t\t\t\t\tdisplayString2ICompletionProposalMap.put(completionProposal.getDisplayString(), completionProposal);\n\t\t\t\t\t\n\t\t\t\t\t// trim displayString\n\t\t\t\t\tif (leafNode.isHidden() && !\"\".equals(leafNode.getText().trim()) ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (completionProposal.getDisplayString().startsWith(leafNode.getText()) && \n\t\t\t\t\t\t\t\tcompletionProposal instanceof XtextCompletionProposal) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tXtextCompletionProposal xtextCompletionProposal = (XtextCompletionProposal) completionProposal;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\txtextCompletionProposal.setText(xtextCompletionProposal.getText().replaceFirst(leafNode.getText(), \"\"));\n\t\t\t\t\t\t}  else {\n\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\titerator.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\t\n\t\treturn completionProposalList;\n\t}","id":44554,"modified_method":"/**\n\t * Concrete subclasses can override this for custom sort and filter\n\t * behavior. Gets called after all completion proposals have been collected.\n\t * \n\t * The default behavior of this implementation is to sort duplicates and to\n\t * trim matching <code>ICompletionProposal#displayString<\/code> with\n\t * matching prefix values.\n\t * \n\t * @param completionProposalList\n\t *            matching {@link ICompletionProposal} to sort and filter\n\t * @param model\n\t *            - the most specific model element under the cursor.\n\t * @param prefix\n\t *            - the prefix under the cursor or null if there is no prefix\n\t * @param offset\n\t * @param document\n\t * @return the sorted and filtered <code>ICompletionProposal<\/code> list.\n\t * \n\t */\n\tprotected List<? extends ICompletionProposal> doSortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix,\n\t\t\tIDocument document, int offset) {\n\n\t\tif (model instanceof LeafNode) {\n\n\t\t\tLeafNode leafNode = (LeafNode) model;\n\n\t\t\tMap<String, ICompletionProposal> displayString2ICompletionProposalMap = new HashMap<String, ICompletionProposal>();\n\n\t\t\tfor (Iterator<? extends ICompletionProposal> iterator = completionProposalList.iterator(); iterator\n\t\t\t\t\t.hasNext();) {\n\n\t\t\t\tICompletionProposal completionProposal = iterator.next();\n\n\t\t\t\t// filter duplicate displayString\n\t\t\t\tif (!displayString2ICompletionProposalMap.containsKey(completionProposal.getDisplayString())) {\n\n\t\t\t\t\tdisplayString2ICompletionProposalMap.put(completionProposal.getDisplayString(), completionProposal);\n\n\t\t\t\t\tboolean cursorIsAtTheEndOfTheLastElement = offset == (leafNode.getOffset() + leafNode.getLength());\n\t\t\t\t\t/**\n\t\t\t\t\t * 1. filter and trim proposal's matching the prefix of the\n\t\t\t\t\t * current leafNode (e.g. leafNode 'kin' for keyword 'kind'\n\t\t\t\t\t * will be trimmed to 'd' , displayString stays the same)\n\t\t\t\t\t * <p/>\n\t\t\t\t\t * 2. special case for crossref: if the cursor is at the end\n\t\t\t\t\t * of the previous element kind>|< we want to apply the\n\t\t\t\t\t * filter only to instances of the previous grammarElement\n\t\t\t\t\t * in order to always show all matches for 'right-to-left'\n\t\t\t\t\t * backtracking use-cases\n\t\t\t\t\t */\n\t\t\t\t\tif ((leafNode.isHidden() || cursorIsAtTheEndOfTheLastElement)\n\t\t\t\t\t\t\t&& !\"\".equals(leafNode.getText().trim())\n\t\t\t\t\t\t\t&& completionProposal instanceof XtextCompletionProposal) {\n\n\t\t\t\t\t\tXtextCompletionProposal xtextCompletionProposal = (XtextCompletionProposal) completionProposal;\n\n\t\t\t\t\t\tAbstractElement abstractElement = xtextCompletionProposal.getAbstractElement();\n\n\t\t\t\t\t\tEObject grammarElement = leafNode.getGrammarElement();\n\t\t\t\t\t\t// at the end of the last element we want to filter only\n\t\t\t\t\t\t// the CompletionProposal for the same grammar element\n\t\t\t\t\t\tif (completionProposal.getDisplayString().startsWith(leafNode.getText())) {\n\t\t\t\t\t\t\txtextCompletionProposal.setText(xtextCompletionProposal.getText().substring(\n\t\t\t\t\t\t\t\t\tleafNode.getText().length()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((cursorIsAtTheEndOfTheLastElement && abstractElement.equals(grammarElement))\n\t\t\t\t\t\t\t\t|| !cursorIsAtTheEndOfTheLastElement) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"filter completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"filter duplicate completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t\t}\n\n\t\t\t\t\titerator.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Concrete subclasses can override this to provide custom lookup behaviour\n\t * for <code>CrossReference<\/code>. This implementation delegates to the\n\t * injected LinkingService\n\t * \n\t * @return a list of <code>ICompletionProposal<\/code> matching the given\n\t *         assignment\n\t */\n\tprotected List<? extends ICompletionProposal> lookupCrossReference(CrossReference crossReference, EObject model,\n\t\t\tString prefix, int offset) {\n\t\t\n\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\tif (linkingService != null) {\n\t\t\tEObject semanticModel = model instanceof AbstractNode?NodeUtil.getNearestSemanticObject((AbstractNode) model):model;\n\t\t\tList<Pair<String, URI>> candidates = linkingService.getLinkCandidates(semanticModel, crossReference, prefix);\n\t\t\tfor (Pair<String, URI> candidate : candidates) {\n\t\t\t\tcompletionProposalList.add(createCompletionProposal(candidate.getFirstElement(), offset));\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","id":44555,"modified_method":"/**\n\t * Concrete subclasses can override this to provide custom lookup behaviour\n\t * for <code>CrossReference<\/code>. This implementation delegates to the\n\t * injected LinkingService\n\t * \n\t * @return a list of <code>ICompletionProposal<\/code> matching the given\n\t *         assignment\n\t */\n\tprotected List<? extends ICompletionProposal> lookupCrossReference(CrossReference crossReference, EObject model,\n\t\t\tString prefix, int offset) {\n\n\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\tif (linkingService != null) {\n\t\t\tEObject semanticModel = model instanceof AbstractNode ? NodeUtil\n\t\t\t\t\t.getNearestSemanticObject((AbstractNode) model) : model;\n\t\t\tList<Pair<String, URI>> candidates = linkingService\n\t\t\t\t\t.getLinkCandidates(semanticModel, crossReference, prefix);\n\t\t\tfor (Pair<String, URI> candidate : candidates) {\n\t\t\t\tcompletionProposalList.add(createCompletionProposal(crossReference, model, candidate.getFirstElement(),\n\t\t\t\t\t\toffset));\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Concrete subclasses can override this to provide a more meaningful and sophisticated behaviour\n\t * whenever a list of ICompletionProposal's should be computed for simple <code>LexerRule<\/code> call's.\n\t * \n\t * This implementation returns one <code>ICompletionProposal<\/code> with a displayString composed\n\t * of the name of the containing rule plus the featurename of an optional assignment and at the end the name \n\t * of the given LexerRule (e.i. ParserRuleName+AssignmentFeatureName+LexerRuleName) or {@link #getDefaultIntegerValue()} \n\t * if its <i>INT<\/i> based LexerRule.\n\t * \n\t * @param lexerRule the 'called' LexerRule instance\n\t * @param ruleCall the ruleCall for the provided lexerRule\n\t * @param offset an offset within the document for which completions should be computed\n\t * @return a computed list of <code>ICompletionProposal<\/code> for the given <code>LexerRule<\/code>\n\t */\n\tprotected List<? extends ICompletionProposal> doCompleteLexerRuleRuleCall(LexerRule lexerRule,RuleCall ruleCall, int offset) {\n\t\tParserRule containingParserRule = GrammarUtil.containingParserRule(ruleCall);\n\t\tAssignment containingAssignment = GrammarUtil.containingAssignment(ruleCall);\n\t\t\n\t\tString defaultDisplayString = containingParserRule.getName() + \n\t\t\t(null != containingAssignment ? firstLetterCapitalized(containingAssignment.getFeature()) : \"\") + lexerRule.getName();\n\t\t\n\t\tif (LEXER_RULE_INT.equalsIgnoreCase(lexerRule.getName())) {\n\t\t\tdefaultDisplayString=String.valueOf(getDefaultIntegerValue());\n\t\t} else if (LEXER_RULE_STRING.equalsIgnoreCase(lexerRule.getName())) {\n\t\t\tdefaultDisplayString=\"\\\"\"+defaultDisplayString+\"\\\"\";\n\t\t} \n\t\t\n\t\treturn Collections.singletonList(createCompletionProposal(defaultDisplayString, offset));\n\t}","id":44556,"modified_method":"/**\n\t * Concrete subclasses can override this to provide a more meaningful and\n\t * sophisticated behaviour whenever a list of ICompletionProposal's should\n\t * be computed for simple <code>LexerRule<\/code> call's.\n\t * \n\t * This implementation returns one <code>ICompletionProposal<\/code> with a\n\t * displayString composed of the name of the containing rule plus the\n\t * featurename of an optional assignment and at the end the name of the\n\t * given LexerRule (e.i. ParserRuleName+AssignmentFeatureName+LexerRuleName)\n\t * or {@link #getDefaultIntegerValue()} if its <i>INT<\/i> based LexerRule.\n\t * \n\t * @param lexerRule\n\t *            the 'called' LexerRule instance\n\t * @param ruleCall\n\t *            the ruleCall for the provided lexerRule\n\t * @param offset\n\t *            an offset within the document for which completions should be\n\t *            computed\n\t * @return a computed list of <code>ICompletionProposal<\/code> for the given\n\t *         <code>LexerRule<\/code>\n\t */\n\tprotected List<? extends ICompletionProposal> doCompleteLexerRuleRuleCall(LexerRule lexerRule, RuleCall ruleCall,\n\t\t\tEObject model, int offset) {\n\t\tParserRule containingParserRule = GrammarUtil.containingParserRule(ruleCall);\n\t\tAssignment containingAssignment = GrammarUtil.containingAssignment(ruleCall);\n\n\t\tString defaultDisplayString = containingParserRule.getName()\n\t\t\t\t+ (null != containingAssignment ? firstLetterCapitalized(containingAssignment.getFeature()) : \"\")\n\t\t\t\t+ lexerRule.getName();\n\n\t\tif (LEXER_RULE_INT.equalsIgnoreCase(lexerRule.getName())) {\n\t\t\tdefaultDisplayString = String.valueOf(getDefaultIntegerValue());\n\t\t}\n\t\telse if (LEXER_RULE_STRING.equalsIgnoreCase(lexerRule.getName())) {\n\t\t\tdefaultDisplayString = \"\\\"\" + defaultDisplayString + \"\\\"\";\n\t\t}\n\n\t\treturn Collections.singletonList(createCompletionProposal(containingAssignment, model, defaultDisplayString,\n\t\t\t\toffset));\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeKeyword(Keyword keyword, EObject model, String prefix,\n\t\t\tIDocument doc, int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKeyword '\" + keyword.getValue() + \"' for model '\" + model + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\tString text = keyword.getValue().length() == 1 ? keyword.getValue() : keyword.getValue() + \" \";\n\t\treturn Collections.singletonList(createCompletionProposal(text, offset));\n\t}","id":44557,"modified_method":"public List<? extends ICompletionProposal> completeKeyword(Keyword keyword, EObject model, String prefix,\n\t\t\tIDocument doc, int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKeyword '\" + keyword.getValue() + \"' for model '\" + model + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\tString text = keyword.getValue().length() == 1 ? keyword.getValue() : keyword.getValue() + \" \";\n\t\treturn Collections.singletonList(createCompletionProposal(keyword, model, text, offset));\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> sortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix) {\n\t\treturn doSortAndFilter(completionProposalList,model,prefix);\n\t}","id":44558,"modified_method":"public List<? extends ICompletionProposal> sortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix,\n\t\t\tIDocument document, int offset) {\n\t\treturn doSortAndFilter(completionProposalList, model, prefix, document, offset);\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeRuleCall(RuleCall ruleCall, EObject model, String prefix,\n\t\t\tIDocument doc, int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeRuleCall '\" + ruleCall.getName() + \"' cardinality '\" + ruleCall.getCardinality()\n\t\t\t\t\t+ \"' for model '\" + model + \"' and prefix '\" + prefix.trim() + \"'\");\n\t\t}\n\t\t\n\t\tAbstractRule calledRule = GrammarUtil.calledRule(ruleCall);\n\t\t\n\t\tif (calledRule instanceof LexerRule) {\n\t\t\treturn doCompleteLexerRuleRuleCall((LexerRule) calledRule, ruleCall, offset);\n\t\t} \n\t\t\n\t\treturn Collections.emptyList();\n\t}","id":44559,"modified_method":"public List<? extends ICompletionProposal> completeRuleCall(RuleCall ruleCall, EObject model, String prefix,\n\t\t\tIDocument doc, int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeRuleCall '\" + ruleCall.getName() + \"' cardinality '\" + ruleCall.getCardinality()\n\t\t\t\t\t+ \"' for model '\" + model + \"' and prefix '\" + prefix.trim() + \"'\");\n\t\t}\n\n\t\tAbstractRule calledRule = GrammarUtil.calledRule(ruleCall);\n\n\t\tif (calledRule instanceof LexerRule) {\n\t\t\treturn doCompleteLexerRuleRuleCall((LexerRule) calledRule, ruleCall, model, offset);\n\t\t}\n\n\t\treturn Collections.emptyList();\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * computes the possible grammar elements following the one at the given\n\t * offset and calls the respective methods on the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\t\t\n\t\tICompletionProposal[] completionProposals = null;\n\t\t\n\t\tif (proposalProvider != null) {\n\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\t\n\t\t\tif (document instanceof XtextDocument) {\n\t\t\t\t\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\t\t\t\t\n\t\t\t\tXtextDocument xtextDocument = (XtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\tString prefix = null==currentLeafNode ? \"\" : currentLeafNode.getText();\n\n\t\t\t\tSet<AbstractElement> nextValidElementSet = ParseTreeUtil.getElementSetValidFromOffset(rootNode,lastCompleteNode, offset);\n\t\t\t\t/**\n\t\t\t\t * in the case of a non linked crossreference we delegate to proposalProvider (again)  \n\t\t\t\t */\n\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof CrossReference && !isLinked(lastCompleteNode) ) {\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement().eContainer());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (List<EObject> resolvedElementOrRuleList : new ProposalCandidateResolverSwitch(nextValidElementSet)) {\n\n\t\t\t\t\tList<ICompletionProposal> collectedCompletionProposalList = collectCompletionProposalList(resolvedElementOrRuleList,  xtextDocument,\n\t\t\t\t\t\t\tlastCompleteNode, prefix, offset);\n\t\t\t\t\t\n\t\t\t\t\tcompletionProposalList.addAll(collectedCompletionProposalList);\n\t\t\t\t}\n\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<? extends ICompletionProposal> sortAndFilter = proposalProvider.sortAndFilter(completionProposalList,currentLeafNode,prefix);\n\t\t\t\t\tcompletionProposals =  sortAndFilter.toArray(new ICompletionProposal[] {});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn completionProposals;\n\t}","id":44560,"modified_method":"/**\n\t * computes the possible grammar elements following the one at the given\n\t * offset and calls the respective methods on the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\t\t\n\t\tICompletionProposal[] completionProposals = null;\n\t\t\n\t\tif (proposalProvider != null) {\n\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\t\n\t\t\tif (document instanceof XtextDocument) {\n\t\t\t\t\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\t\t\t\t\n\t\t\t\tXtextDocument xtextDocument = (XtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\tString prefix = null==currentLeafNode ? \"\" : currentLeafNode.getText();\n\t\t\t\t\n\t\t\t\tSet<AbstractElement> nextValidElementSet = new LinkedHashSet<AbstractElement>();\n\t\t\t\t/**\n\t\t\t\t * in the case of a non linked crossreference we delegate to proposalProvider (again) \n\t\t\t\t */\n\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof CrossReference && !isLinked(lastCompleteNode)) {\n\t\t\t\t\t\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t} \n\t\t\t\t/**\n\t\t\t\t * in the case we are at the end of the completed previous element add for 'right-to-left' backtracking cases\n\t\t\t\t */\n\t\t\t\telse if (currentLeafNode==lastCompleteNode) {\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode,lastCompleteNode, offset));\n\t\t\t\t\n\t\t\t\tProposalProviderInvokerSwitch proposalProviderInvokerSwitch = new ProposalProviderInvokerSwitch(\n\t\t\t\t\t\tlastCompleteNode, document, offset, prefix, proposalProvider);\n\t\t\t\t\n\t\t\t\tfor (List<EObject> resolvedElementOrRuleList : new ProposalCandidateResolverSwitch(nextValidElementSet)) {\n\n\t\t\t\t\tList<ICompletionProposal> collectedCompletionProposalList = \n\t\t\t\t\t\tproposalProviderInvokerSwitch.collectCompletionProposalList(resolvedElementOrRuleList);\n\t\t\t\t\t\n\t\t\t\t\tcompletionProposalList.addAll(collectedCompletionProposalList);\n\t\t\t\t}\n\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<? extends ICompletionProposal> sortAndFilter = proposalProvider.sortAndFilter(completionProposalList,currentLeafNode,prefix,document,offset);\n\t\t\t\t\tcompletionProposals =  sortAndFilter.toArray(new ICompletionProposal[] {});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn completionProposals;\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprivate boolean isLinked(AbstractNode lastCompleteNode) {\n\t\t\n\t\tEObject semanticModel = NodeUtil.getNearestSemanticObject(lastCompleteNode);\n\t\t\t\t\n\t\tEReference eReference = getReference((CrossReference) lastCompleteNode.getGrammarElement(), semanticModel.eClass());\n\t\t\n\t\tif (eReference.getUpperBound() == 1 ) {\n\t\t\n\t\t\tif (null!=semanticModel.eGet(eReference)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse { \n\t\t\t\n\t\t\tEcoreEList<EObject> ecoreEList = (EcoreEList<EObject>) semanticModel.eGet(eReference);\n\t\t\t\n\t\t\tfor (Iterator<EObject> iterator = ecoreEList.iterator(); iterator.hasNext();) {\n\t\t\t\t\n\t\t\t\tEObject object = iterator.next();\n\t\t\t\t\n\t\t\t\tif (EcoreUtil2.getURIFragment(object).equalsIgnoreCase(((LeafNode)lastCompleteNode).getText())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}","id":44561,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprivate boolean isLinked(AbstractNode lastCompleteNode) {\n\n\t\tEObject semanticModel = NodeUtil.getNearestSemanticObject(lastCompleteNode);\n\n\t\tEReference eReference = getReference((CrossReference) lastCompleteNode.getGrammarElement(), semanticModel\n\t\t\t\t.eClass());\n\n\t\tif (eReference.getUpperBound() == 1) {\n\n\t\t\tif (null != semanticModel.eGet(eReference)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\tEcoreEList<EObject> ecoreEList = (EcoreEList<EObject>) semanticModel.eGet(eReference);\n\n\t\t\tfor (EObject object : ecoreEList) {\n\n\t\t\t\tif (EcoreUtil2.getURIFragment(object).equalsIgnoreCase(((LeafNode) lastCompleteNode).getText())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeSpielplatzGroesse(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielplatzGroesse feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"1\", offset));\t\t\n\t}","id":44562,"modified_method":"public List<? extends ICompletionProposal> completeSpielplatzGroesse(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielplatzGroesse feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"1\", offset));\t\t\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeKindName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKindName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"KindName\", offset));\n\t}","id":44563,"modified_method":"public List<? extends ICompletionProposal> completeKindName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKindName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"KindName\", offset));\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeSpielzeugName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielzeugName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"SpielzeugName\", offset));\n\t}","id":44564,"modified_method":"public List<? extends ICompletionProposal> completeSpielzeugName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielzeugName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"SpielzeugName\", offset));\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeCustomTypeParserRuleName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeCustomTypeParserRuleName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"CustomTypeParserRuleName\", offset));\n\t}","id":44565,"modified_method":"public List<? extends ICompletionProposal> completeCustomTypeParserRuleName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeCustomTypeParserRuleName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"CustomTypeParserRuleName\", offset));\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeSpielplatzBeschreibung(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielplatzBeschreibung feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"\\\"SpielplatzBeschreibung\\\"\", offset));\t\t\n\t}","id":44566,"modified_method":"public List<? extends ICompletionProposal> completeSpielplatzBeschreibung(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielplatzBeschreibung feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"\\\"SpielplatzBeschreibung\\\"\", offset));\t\t\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeErwachsenerAge(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeErwachsenerAge feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"1\", offset));\t\t\n\t}","id":44567,"modified_method":"public List<? extends ICompletionProposal> completeErwachsenerAge(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeErwachsenerAge feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"1\", offset));\t\t\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeErwachsenerName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeErwachsenerName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"ErwachsenerName\", offset));\n\t}","id":44568,"modified_method":"public List<? extends ICompletionProposal> completeErwachsenerName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeErwachsenerName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"ErwachsenerName\", offset));\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeKindAge(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKindAge feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"1\", offset));\t\t\n\t}","id":44569,"modified_method":"public List<? extends ICompletionProposal> completeKindAge(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKindAge feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"1\", offset));\t\t\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @param text\n\t *            the text value to be replaced/inserted\n\t * @param label\n\t *            the label to be displayed\n\t * @param description\n\t *            some additional description for the tooltip\n\t * @param imageFilePath\n\t *            the relative path of the image file, relative to the root of\n\t *            the plug-in; the path must be legal\n\t * @param pluginId\n\t *            the id of the plug-in containing the image file;\n\t * @param offset\n\t *            the offset of the text\n\t */\n\tpublic XtextCompletionProposal(String text, StyledString label,\n\t\t\tString description, String imageFilePath, String pluginIdentifier,\n\t\t\tint offset) {\n\t\tAssert.isNotNull(text, \"parameter 'text' must not be null\");\n\t\tAssert.isNotNull(pluginIdentifier,\n\t\t\t\t\"pluginIdentifier 'text' must not be null\");\n\t\tthis.text = text;\n\t\tthis.description = description;\n\t\tthis.offset = offset;\n\t\tthis.pluginIdentifier = pluginIdentifier;\n\n\t\tif (label != null) {\n\t\t\tthis.label = label;\n\t\t} else {\n\t\t\tthis.label = new StyledString(this.text);\n\t\t}\n\t\tif (imageFilePath != null) {\n\t\t\tinitializeImage(imageFilePath);\n\t\t}\n\t}","id":44570,"modified_method":"/**\n\t * @param element\n\t *            the element for which this CompletionProposal is created for\n\t * @param model the last semtantically complete object \n\t * @param text\n\t *            the text value to be replaced/inserted\n\t * @param label\n\t *            the label to be displayed\n\t * @param description\n\t *            some additional description for the tooltip\n\t * @param imageFilePath\n\t *            the relative path of the image file, relative to the root of\n\t *            the plug-in; the path must be legal\n\t * @param pluginId\n\t *            the id of the plug-in containing the image file;\n\t * @param offset\n\t *            the offset of the text\n\t */\n\tpublic XtextCompletionProposal(AbstractElement element,EObject model,String text, StyledString label,\n\t\t\tString description, String imageFilePath, String pluginIdentifier,\n\t\t\tint offset) {\n\t\tAssert.isNotNull(text, \"parameter 'text' must not be null\");\n\t\tAssert.isNotNull(pluginIdentifier,\n\t\t\t\t\"pluginIdentifier 'text' must not be null\");\n\t\tthis.abstractElement = element;\n\t\tthis.model = model;\n\t\tthis.text = text;\n\t\tthis.description = description;\n\t\tthis.offset = offset;\n\t\tthis.pluginIdentifier = pluginIdentifier;\n\n\t\tif (label != null) {\n\t\t\tthis.label = label;\n\t\t} else {\n\t\t\tthis.label = new StyledString(this.text);\n\t\t}\n\t\tif (imageFilePath != null) {\n\t\t\tinitializeImage(imageFilePath);\n\t\t}\n\t}","commit_id":"0dcacba2b3c50df06b552d01fdc6314c698c72c6","url":"https://github.com/eclipse/xtext"},{"original_method":"private void updatePathFromTree(final List<VirtualFile> selection, boolean now) {\n    if (!isToShowTextField() || myTreeIsUpdating) return;\n\n    String text = \"\";\n    if (selection.size() > 0) {\n      final VirtualFile vFile = selection.get(0);\n      if (vFile.isInLocalFileSystem()) {\n        text = vFile.getPresentableUrl();\n      }\n      else {\n        text = vFile.getUrl();\n      }\n    }\n    else {\n      List<VirtualFile> roots = myChooserDescriptor.getRoots();\n      if (!myFileSystemTree.getTree().isRootVisible() && roots.size() == 1) {\n        VirtualFile vFile = roots.get(0);\n        if (vFile.isInLocalFileSystem()) {\n          text = vFile.getPresentableUrl();\n        }\n        else {\n          text = vFile.getUrl();\n        }\n      }\n    }\n\n    myPathTextField.setText(text, now, new Runnable() {\n      public void run() {\n        myPathTextField.getField().selectAll();\n        setErrorText(null);\n      }\n    });\n  }","id":44571,"modified_method":"private void updatePathFromTree(final List<VirtualFile> selection, boolean now) {\n    if (!isToShowTextField() || myTreeIsUpdating) return;\n\n    String text = \"\";\n    if (selection.size() > 0) {\n      text = getFilePath(selection.get(0));\n    }\n    else {\n      List<VirtualFile> roots = myChooserDescriptor.getRoots();\n      if (!myFileSystemTree.getTree().isRootVisible() && roots.size() == 1) {\n        text = getFilePath(roots.get(0));\n      }\n    }\n\n    myPathTextField.setText(text, now, new Runnable() {\n      public void run() {\n        myPathTextField.getField().selectAll();\n        setErrorText(null);\n      }\n    });\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isArchive(VirtualFile file) {\n    if (isArchiveFileSystem(file) && file.getParent() == null) return true;\n    return !file.isDirectory() &&\n           file.getFileType() == FileTypes.ARCHIVE &&\n           !isArchiveFileSystem(file.getParent());\n  }","id":44572,"modified_method":"public static boolean isArchive(@Nullable final VirtualFile file) {\n    if (file == null) return false;\n    if (isArchiveFileSystem(file) && file.getParent() == null) return true;\n    return !file.isDirectory() &&\n           file.getFileType() == FileTypes.ARCHIVE &&\n           !isArchiveFileSystem(file.getParent());\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isArchive() {\n    return isArchive(getFile());\n  }","id":44573,"modified_method":"public final boolean isArchive() {\n    return isArchive(getFile());\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isFileHidden(VirtualFile virtualFile) {\n    if (virtualFile == null || !virtualFile.isValid()) return false;\n    if (!virtualFile.isInLocalFileSystem()) return false;\n    File file = new File(virtualFile.getPath().replace('/', File.separatorChar));\n    return file.getParent() != null && file.isHidden(); // Under Windows logical driver files (e.g C:\\) are hidden.\n  }","id":44574,"modified_method":"public static boolean isFileHidden(@Nullable final VirtualFile file) {\n    if (file == null || !file.isValid()) return false;\n    if (!file.isInLocalFileSystem()) return false;\n    final File ioFile = new File(file.getPath().replace('/', File.separatorChar));\n    return ioFile.isHidden() && ioFile.getParent() != null; // Under Windows logical driver files (e.g C:\\) are hidden.\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final String toString() {\n    if (myName != null) {\n      return myName;\n    }\n    else if (myFile != null) {\n      return myFile.getName();\n    }\n    return \"\";\n  }","id":44575,"modified_method":"@Override\n  public final String toString() {\n    return myName != null ? myName : \"\";\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processSelectionChange() {\n    if (myListeners.size() == 0) return;\n    List<VirtualFile> selection = new ArrayList<VirtualFile>();\n\n    final TreePath[] paths = myTree.getSelectionPaths();\n    if (paths != null) {\n      for (TreePath each : paths) {\n        final Object last = each.getLastPathComponent();\n        if (last instanceof DefaultMutableTreeNode) {\n          final Object object = ((DefaultMutableTreeNode)last).getUserObject();\n          if (object instanceof FileNodeDescriptor) {\n            final FileElement element = ((FileNodeDescriptor)object).getElement();\n            final VirtualFile file = element.getFile();\n            if (file != null) {\n              selection.add(file);\n            }\n          }\n        }\n      }\n    }\n\n    fireSelection(selection);\n  }","id":44576,"modified_method":"private void processSelectionChange() {\n    if (myListeners.size() == 0) return;\n    List<VirtualFile> selection = new ArrayList<VirtualFile>();\n\n    final TreePath[] paths = myTree.getSelectionPaths();\n    if (paths != null) {\n      for (TreePath each : paths) {\n        final Object last = each.getLastPathComponent();\n        if (last instanceof DefaultMutableTreeNode) {\n          final Object object = ((DefaultMutableTreeNode)last).getUserObject();\n          if (object instanceof FileNodeDescriptor) {\n            final FileElement element = ((FileNodeDescriptor)object).getElement();\n            final VirtualFile file = element.getFile();\n            if (file != null) {\n              file.putUserData(PATH_KEY, element.getPath());\n              selection.add(file);\n            }\n          }\n        }\n      }\n    }\n\n    fireSelection(selection);\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void dispose() {\n    PropertiesComponent.getInstance().setValue(\"FileChooser.showHiddens\", Boolean.toString(myShownHiddens));\n  }","id":44577,"modified_method":"public final void dispose() {\n    PropertiesComponent.getInstance().setValue(\"FileChooser.showHiddens\", Boolean.toString(myShowHidden));\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FileTreeStructure(Project project, FileChooserDescriptor chooserDescriptor) {\n    myProject = project;\n    List<VirtualFile> roots = chooserDescriptor.getRoots();\n    final VirtualFile[] rootFiles = VfsUtil.toVirtualFileArray(roots);\n    VirtualFile rootFile = rootFiles.length == 1 ? rootFiles[0] : null;\n    myRootElement = new RootFileElement(rootFiles, rootFile != null? rootFile.getPresentableUrl() : chooserDescriptor.getTitle(), chooserDescriptor.isShowFileSystemRoots());\n    myChooserDescriptor = chooserDescriptor;\n\n    String value = PropertiesComponent.getInstance().getValue(\"FileChooser.showHiddens\");\n    myShownHiddens = Boolean.valueOf(value).booleanValue();\n  }","id":44578,"modified_method":"public FileTreeStructure(Project project, FileChooserDescriptor chooserDescriptor) {\n    myProject = project;\n    final VirtualFile[] rootFiles = VfsUtil.toVirtualFileArray(chooserDescriptor.getRoots());\n    final String name = rootFiles.length == 1 && rootFiles[0] != null ? rootFiles[0].getPresentableUrl() : chooserDescriptor.getTitle();\n    myRootElement = new RootFileElement(rootFiles, name, chooserDescriptor.isShowFileSystemRoots());\n    myChooserDescriptor = chooserDescriptor;\n    myShowHidden = PropertiesComponent.getInstance().getBoolean(\"FileChooser.showHiddens\", false);\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Object[] getFileChildren(FileElement element) {\n    VirtualFile file = element.getFile();\n\n    if (file == null || !file.isValid()) {\n      if (element == myRootElement) {\n        return myRootElement.getChildren();\n      }\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }\n\n    VirtualFile[] children = null;\n\n    if (element.isArchive() && myChooserDescriptor.isChooseJarContents()) {\n      String path = file.getPath();\n      if (!(file.getFileSystem() instanceof JarFileSystem)) {\n        file = JarFileSystem.getInstance().findFileByPath(path + JarFileSystem.JAR_SEPARATOR);\n      }\n      if (file != null) children = file.getChildren();\n    }\n    else {\n      children = file.getChildren();\n    }\n\n    if (children == null) {\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }\n\n    HashSet<FileElement> childrenSet = new HashSet<FileElement>();\n    for (VirtualFile child : children) {\n      if (myChooserDescriptor.isFileVisible(child, myShownHiddens)) {\n        final FileElement childElement = new FileElement(child, child.getName());\n        childElement.setParent(element);\n        childrenSet.add(childElement);\n      }\n    }\n    return ArrayUtil.toObjectArray(childrenSet);\n  }","id":44579,"modified_method":"private Object[] getFileChildren(FileElement element) {\n    VirtualFile file = element.getFile();\n\n    if (file == null || !file.isValid()) {\n      if (element == myRootElement) {\n        return myRootElement.getChildren();\n      }\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }\n\n    VirtualFile[] children = null;\n\n    if (element.isArchive() && myChooserDescriptor.isChooseJarContents()) {\n      String path = file.getPath();\n      if (!(file.getFileSystem() instanceof JarFileSystem)) {\n        file = JarFileSystem.getInstance().findFileByPath(path + JarFileSystem.JAR_SEPARATOR);\n      }\n      if (file != null) children = file.getChildren();\n    }\n    else {\n      children = file.getChildren();\n    }\n\n    if (children == null) {\n      return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    }\n\n    HashSet<FileElement> childrenSet = new HashSet<FileElement>();\n    for (VirtualFile child : children) {\n      if (myChooserDescriptor.isFileVisible(child, myShowHidden)) {\n        final FileElement childElement = new FileElement(child, child.getName());\n        childElement.setParent(element);\n        childrenSet.add(childElement);\n      }\n    }\n    return ArrayUtil.toObjectArray(childrenSet);\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final boolean areHiddensShown() {\n    return myShownHiddens;\n  }","id":44580,"modified_method":"public final boolean areHiddensShown() {\n    return myShowHidden;\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void showHiddens(final boolean showHiddens) {\n    myShownHiddens = showHiddens;\n  }","id":44581,"modified_method":"public final void showHiddens(final boolean showHiddens) {\n    myShowHidden = showHiddens;\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Object[] getFileSystemRoots() {\n    File[] roots = File.listRoots();\n    LocalFileSystem localFileSystem = LocalFileSystem.getInstance();\n    HashSet<FileElement> rootChildren = new HashSet<FileElement>();\n    for (File root : roots) {\n      String path = root.getAbsolutePath();\n      path = path.replace(File.separatorChar, '/');\n      VirtualFile file = localFileSystem.findFileByPath(path);\n      if (file == null) continue;\n      rootChildren.add(new FileElement(file, file.getPresentableUrl()));\n    }\n    return ArrayUtil.toObjectArray(rootChildren);\n  }","id":44582,"modified_method":"private static VirtualFile[] getFileSystemRoots() {\n    final LocalFileSystem localFileSystem = LocalFileSystem.getInstance();\n    final Set<VirtualFile> roots = new HashSet<VirtualFile>();\n    final File[] ioRoots = File.listRoots();\n    if (ioRoots != null) {\n      for (final File root : ioRoots) {\n        final String path = FileUtil.toSystemIndependentName(root.getAbsolutePath());\n        final VirtualFile file = localFileSystem.findFileByPath(path);\n        if (file != null) {\n          roots.add(file);\n        }\n      }\n    }\n    return VfsUtil.toVirtualFileArray(roots);\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RootFileElement(VirtualFile[] files, String name, boolean showFileSystemRoots) {\n    super(files.length == 1 ? files[0] : null, name);\n    myFiles = files;\n    myShowFileSystemRoots = showFileSystemRoots;\n  }","id":44583,"modified_method":"public RootFileElement(@NotNull final VirtualFile[] files, final String name, final boolean showFileSystemRoots) {\n    super(null, name);\n    myFiles = files.length == 0 && showFileSystemRoots ? getFileSystemRoots() : files;\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getChildren() {\n    if (myFiles.length <= 1 && myShowFileSystemRoots) {\n      return getFileSystemRoots();\n    }\n    if (myChildren == null) {\n      myChildren = createFileElementArray();\n    }\n    return myChildren;\n  }","id":44584,"modified_method":"public Object[] getChildren() {\n    if (myChildren == null) {\n      final List<FileElement> children = new ArrayList<FileElement>();\n      for (final VirtualFile file : myFiles) {\n        if (file != null) {\n          children.add(new FileElement(file, file.getPresentableUrl()));\n        }\n      }\n      myChildren = ArrayUtil.toObjectArray(children);\n    }\n    return myChildren;\n  }","commit_id":"e9dca91401ac10392d178189b3bec8f698479f89","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Concrete subclasses can override this to provide custom lookup behaviour\n\t * for <code>CrossReference<\/code>. This implementation delegates to the\n\t * injected LinkingService\n\t * \n\t * @return a list of <code>ICompletionProposal<\/code> matching the given\n\t *         assignment\n\t */\n\tprotected List<? extends ICompletionProposal> lookupCrossReference(CrossReference crossReference, EObject model,\n\t\t\tString prefix, int offset) {\n\t\t\n\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\tif (linkingService != null) {\n\t\t\tEObject semanticModel = model instanceof AbstractNode?NodeUtil.getNearestSemanticObject((AbstractNode) model):model;\n\t\t\tList<Pair<String, URI>> candidates = linkingService.getLinkCandidates(semanticModel, crossReference, prefix);\n\t\t\tfor (Pair<String, URI> candidate : candidates) {\n\t\t\t\tcompletionProposalList.add(createCompletionProposal(candidate.getFirstElement(), offset));\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","id":44585,"modified_method":"/**\n\t * Concrete subclasses can override this to provide custom lookup behaviour\n\t * for <code>CrossReference<\/code>. This implementation delegates to the\n\t * injected LinkingService\n\t * \n\t * @return a list of <code>ICompletionProposal<\/code> matching the given\n\t *         assignment\n\t */\n\tprotected List<? extends ICompletionProposal> lookupCrossReference(CrossReference crossReference, EObject model,\n\t\t\tString prefix, int offset) {\n\n\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\tif (linkingService != null) {\n\t\t\tEObject semanticModel = model instanceof AbstractNode ? NodeUtil\n\t\t\t\t\t.getNearestSemanticObject((AbstractNode) model) : model;\n\t\t\tList<Pair<String, URI>> candidates = linkingService\n\t\t\t\t\t.getLinkCandidates(semanticModel, crossReference, prefix);\n\t\t\tfor (Pair<String, URI> candidate : candidates) {\n\t\t\t\tcompletionProposalList.add(createCompletionProposal(crossReference, model, candidate.getFirstElement(),\n\t\t\t\t\t\toffset));\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeKeyword(Keyword keyword, EObject model, String prefix,\n\t\t\tIDocument doc, int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKeyword '\" + keyword.getValue() + \"' for model '\" + model + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\tString text = keyword.getValue().length() == 1 ? keyword.getValue() : keyword.getValue() + \" \";\n\t\treturn Collections.singletonList(createCompletionProposal(text, offset));\n\t}","id":44586,"modified_method":"public List<? extends ICompletionProposal> completeKeyword(Keyword keyword, EObject model, String prefix,\n\t\t\tIDocument doc, int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKeyword '\" + keyword.getValue() + \"' for model '\" + model + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\tString text = keyword.getValue().length() == 1 ? keyword.getValue() : keyword.getValue() + \" \";\n\t\treturn Collections.singletonList(createCompletionProposal(keyword, model, text, offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> sortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix) {\n\t\treturn doSortAndFilter(completionProposalList,model,prefix);\n\t}","id":44587,"modified_method":"public List<? extends ICompletionProposal> sortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix,\n\t\t\tIDocument document, int offset) {\n\t\treturn doSortAndFilter(completionProposalList, model, prefix, document, offset);\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeRuleCall(RuleCall ruleCall, EObject model, String prefix,\n\t\t\tIDocument doc, int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeRuleCall '\" + ruleCall.getName() + \"' cardinality '\" + ruleCall.getCardinality()\n\t\t\t\t\t+ \"' for model '\" + model + \"' and prefix '\" + prefix.trim() + \"'\");\n\t\t}\n\t\t\n\t\tAbstractRule calledRule = GrammarUtil.calledRule(ruleCall);\n\t\t\n\t\tif (calledRule instanceof LexerRule) {\n\t\t\treturn doCompleteLexerRuleRuleCall((LexerRule) calledRule, ruleCall, offset);\n\t\t} \n\t\t\n\t\treturn Collections.emptyList();\n\t}","id":44588,"modified_method":"public List<? extends ICompletionProposal> completeRuleCall(RuleCall ruleCall, EObject model, String prefix,\n\t\t\tIDocument doc, int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeRuleCall '\" + ruleCall.getName() + \"' cardinality '\" + ruleCall.getCardinality()\n\t\t\t\t\t+ \"' for model '\" + model + \"' and prefix '\" + prefix.trim() + \"'\");\n\t\t}\n\n\t\tAbstractRule calledRule = GrammarUtil.calledRule(ruleCall);\n\n\t\tif (calledRule instanceof LexerRule) {\n\t\t\treturn doCompleteLexerRuleRuleCall((LexerRule) calledRule, ruleCall, model, offset);\n\t\t}\n\n\t\treturn Collections.emptyList();\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @return a new <code>XtextCompletionProposal<\/code> for the given text and\n\t *         offset.\n\t */\n\tprotected final XtextCompletionProposal createCompletionProposal(String text, int offset) {\n\t\treturn new XtextCompletionProposal(text, new StyledString(text), text, getDefaultImageFilePath(),\n\t\t\t\tgetPluginId(), offset);\n\t}","id":44589,"modified_method":"/**\n\t * @return a new <code>XtextCompletionProposal<\/code> for the given text and\n\t *         offset.\n\t */\n\tprotected final XtextCompletionProposal createCompletionProposal(AbstractElement abstractElement, EObject model,\n\t\t\tString text, int offset) {\n\t\treturn new XtextCompletionProposal(abstractElement, model, text, new StyledString(text), text,\n\t\t\t\tgetDefaultImageFilePath(), getPluginId(), offset);\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Concrete subclasses can override this for custom sort and filter\n\t * behavior. Gets called after all completion proposals have been collected.\n\t * \n\t * The default behavior of this implementation is to sort duplicates and to trim \n\t * matching <code>ICompletionProposal#displayString<\/code> with matching prefix values.\n\t * \n\t * @param completionProposalList matching {@link ICompletionProposal} to sort and filter\n\t * @param model - the most specific model element under the cursor. \n\t * @param prefix - the prefix under the cursor or null if there is no prefix\n\t * @return the sorted and filtered <code>ICompletionProposal<\/code> list.\n\t * \n\t */\n\tprotected List<? extends ICompletionProposal> doSortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList,EObject model,String prefix) {\n\t\t\n\t\tif (model instanceof LeafNode) {\n\t\t\t\n\t\t\tLeafNode leafNode = (LeafNode) model;\n\t\t\t\n\t\t\tMap<String,ICompletionProposal> displayString2ICompletionProposalMap = new HashMap<String,ICompletionProposal>();\n\t\t\t\n\t\t\tfor (Iterator<? extends ICompletionProposal> iterator = completionProposalList.iterator(); iterator.hasNext();) {\n\n\t\t\t\tICompletionProposal completionProposal = iterator.next();\n\t\t\t\t\n\t\t\t\t// filter duplicate displayString\n\t\t\t\tif (!displayString2ICompletionProposalMap.containsKey(completionProposal.getDisplayString())) {\n\t\t\t\t\n\t\t\t\t\tdisplayString2ICompletionProposalMap.put(completionProposal.getDisplayString(), completionProposal);\n\t\t\t\t\t\n\t\t\t\t\t// trim displayString\n\t\t\t\t\tif (leafNode.isHidden() && !\"\".equals(leafNode.getText().trim()) ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (completionProposal.getDisplayString().startsWith(leafNode.getText()) && \n\t\t\t\t\t\t\t\tcompletionProposal instanceof XtextCompletionProposal) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tXtextCompletionProposal xtextCompletionProposal = (XtextCompletionProposal) completionProposal;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\txtextCompletionProposal.setText(xtextCompletionProposal.getText().replaceFirst(leafNode.getText(), \"\"));\n\t\t\t\t\t\t}  else {\n\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\titerator.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\t\n\t\treturn completionProposalList;\n\t}","id":44590,"modified_method":"/**\n\t * Concrete subclasses can override this for custom sort and filter\n\t * behavior. Gets called after all completion proposals have been collected.\n\t * \n\t * The default behavior of this implementation is to sort duplicates and to\n\t * trim matching <code>ICompletionProposal#displayString<\/code> with\n\t * matching prefix values.\n\t * \n\t * @param completionProposalList\n\t *            matching {@link ICompletionProposal} to sort and filter\n\t * @param model\n\t *            - the most specific model element under the cursor.\n\t * @param prefix\n\t *            - the prefix under the cursor or null if there is no prefix\n\t * @param offset\n\t * @param document\n\t * @return the sorted and filtered <code>ICompletionProposal<\/code> list.\n\t * \n\t */\n\tprotected List<? extends ICompletionProposal> doSortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix,\n\t\t\tIDocument document, int offset) {\n\n\t\tif (model instanceof LeafNode) {\n\n\t\t\tLeafNode leafNode = (LeafNode) model;\n\n\t\t\tMap<String, ICompletionProposal> displayString2ICompletionProposalMap = new HashMap<String, ICompletionProposal>();\n\n\t\t\tfor (Iterator<? extends ICompletionProposal> iterator = completionProposalList.iterator(); iterator\n\t\t\t\t\t.hasNext();) {\n\n\t\t\t\tICompletionProposal completionProposal = iterator.next();\n\n\t\t\t\t// filter duplicate displayString\n\t\t\t\tif (!displayString2ICompletionProposalMap.containsKey(completionProposal.getDisplayString())) {\n\n\t\t\t\t\tdisplayString2ICompletionProposalMap.put(completionProposal.getDisplayString(), completionProposal);\n\n\t\t\t\t\tboolean cursorIsAtTheEndOfTheLastElement = offset == (leafNode.getOffset() + leafNode.getLength());\n\t\t\t\t\t/**\n\t\t\t\t\t * 1. filter and trim proposal's matching the prefix of the\n\t\t\t\t\t * current leafNode (e.g. leafNode 'kin' for keyword 'kind'\n\t\t\t\t\t * will be trimmed to 'd' , displayString stays the same)\n\t\t\t\t\t * <p/>\n\t\t\t\t\t * 2. special case for crossref: if the cursor is at the end\n\t\t\t\t\t * of the previous element kind>|< we want to apply the\n\t\t\t\t\t * filter only to instances of the previous grammarElement\n\t\t\t\t\t * in order to always show all matches for 'right-to-left'\n\t\t\t\t\t * backtracking use-cases\n\t\t\t\t\t */\n\t\t\t\t\tif ((leafNode.isHidden() || cursorIsAtTheEndOfTheLastElement)\n\t\t\t\t\t\t\t&& !\"\".equals(leafNode.getText().trim())\n\t\t\t\t\t\t\t&& completionProposal instanceof XtextCompletionProposal) {\n\n\t\t\t\t\t\tXtextCompletionProposal xtextCompletionProposal = (XtextCompletionProposal) completionProposal;\n\n\t\t\t\t\t\tAbstractElement abstractElement = xtextCompletionProposal.getAbstractElement();\n\n\t\t\t\t\t\tEObject grammarElement = leafNode.getGrammarElement();\n\t\t\t\t\t\t// at the end of the last element we want to filter only\n\t\t\t\t\t\t// the CompletionProposal for the same grammar element\n\t\t\t\t\t\tif (completionProposal.getDisplayString().startsWith(leafNode.getText())) {\n\t\t\t\t\t\t\txtextCompletionProposal.setText(xtextCompletionProposal.getText().substring(\n\t\t\t\t\t\t\t\t\tleafNode.getText().length()));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if ((cursorIsAtTheEndOfTheLastElement && abstractElement.equals(grammarElement))\n\t\t\t\t\t\t\t\t|| !cursorIsAtTheEndOfTheLastElement) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"filter completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"filter duplicate completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t\t}\n\n\t\t\t\t\titerator.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Concrete subclasses can override this to provide a more meaningful and sophisticated behaviour\n\t * whenever a list of ICompletionProposal's should be computed for simple <code>LexerRule<\/code> call's.\n\t * \n\t * This implementation returns one <code>ICompletionProposal<\/code> with a displayString composed\n\t * of the name of the containing rule plus the featurename of an optional assignment and at the end the name \n\t * of the given LexerRule (e.i. ParserRuleName+AssignmentFeatureName+LexerRuleName) or {@link #getDefaultIntegerValue()} \n\t * if its <i>INT<\/i> based LexerRule.\n\t * \n\t * @param lexerRule the 'called' LexerRule instance\n\t * @param ruleCall the ruleCall for the provided lexerRule\n\t * @param offset an offset within the document for which completions should be computed\n\t * @return a computed list of <code>ICompletionProposal<\/code> for the given <code>LexerRule<\/code>\n\t */\n\tprotected List<? extends ICompletionProposal> doCompleteLexerRuleRuleCall(LexerRule lexerRule,RuleCall ruleCall, int offset) {\n\t\tParserRule containingParserRule = GrammarUtil.containingParserRule(ruleCall);\n\t\tAssignment containingAssignment = GrammarUtil.containingAssignment(ruleCall);\n\t\t\n\t\tString defaultDisplayString = containingParserRule.getName() + \n\t\t\t(null != containingAssignment ? firstLetterCapitalized(containingAssignment.getFeature()) : \"\") + lexerRule.getName();\n\t\t\n\t\tif (LEXER_RULE_INT.equalsIgnoreCase(lexerRule.getName())) {\n\t\t\tdefaultDisplayString=String.valueOf(getDefaultIntegerValue());\n\t\t} else if (LEXER_RULE_STRING.equalsIgnoreCase(lexerRule.getName())) {\n\t\t\tdefaultDisplayString=\"\\\"\"+defaultDisplayString+\"\\\"\";\n\t\t} \n\t\t\n\t\treturn Collections.singletonList(createCompletionProposal(defaultDisplayString, offset));\n\t}","id":44591,"modified_method":"/**\n\t * Concrete subclasses can override this to provide a more meaningful and\n\t * sophisticated behaviour whenever a list of ICompletionProposal's should\n\t * be computed for simple <code>LexerRule<\/code> call's.\n\t * \n\t * This implementation returns one <code>ICompletionProposal<\/code> with a\n\t * displayString composed of the name of the containing rule plus the\n\t * featurename of an optional assignment and at the end the name of the\n\t * given LexerRule (e.i. ParserRuleName+AssignmentFeatureName+LexerRuleName)\n\t * or {@link #getDefaultIntegerValue()} if its <i>INT<\/i> based LexerRule.\n\t * \n\t * @param lexerRule\n\t *            the 'called' LexerRule instance\n\t * @param ruleCall\n\t *            the ruleCall for the provided lexerRule\n\t * @param offset\n\t *            an offset within the document for which completions should be\n\t *            computed\n\t * @return a computed list of <code>ICompletionProposal<\/code> for the given\n\t *         <code>LexerRule<\/code>\n\t */\n\tprotected List<? extends ICompletionProposal> doCompleteLexerRuleRuleCall(LexerRule lexerRule, RuleCall ruleCall,\n\t\t\tEObject model, int offset) {\n\t\tParserRule containingParserRule = GrammarUtil.containingParserRule(ruleCall);\n\t\tAssignment containingAssignment = GrammarUtil.containingAssignment(ruleCall);\n\n\t\tString defaultDisplayString = containingParserRule.getName()\n\t\t\t\t+ (null != containingAssignment ? firstLetterCapitalized(containingAssignment.getFeature()) : \"\")\n\t\t\t\t+ lexerRule.getName();\n\n\t\tif (LEXER_RULE_INT.equalsIgnoreCase(lexerRule.getName())) {\n\t\t\tdefaultDisplayString = String.valueOf(getDefaultIntegerValue());\n\t\t}\n\t\telse if (LEXER_RULE_STRING.equalsIgnoreCase(lexerRule.getName())) {\n\t\t\tdefaultDisplayString = \"\\\"\" + defaultDisplayString + \"\\\"\";\n\t\t}\n\n\t\treturn Collections.singletonList(createCompletionProposal(containingAssignment, model, defaultDisplayString,\n\t\t\t\toffset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprivate boolean isLinked(AbstractNode lastCompleteNode) {\n\t\t\n\t\tEObject semanticModel = NodeUtil.getNearestSemanticObject(lastCompleteNode);\n\t\t\t\t\n\t\tEReference eReference = getReference((CrossReference) lastCompleteNode.getGrammarElement(), semanticModel.eClass());\n\t\t\n\t\tif (eReference.getUpperBound() == 1 ) {\n\t\t\n\t\t\tif (null!=semanticModel.eGet(eReference)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse { \n\t\t\t\n\t\t\tEcoreEList<EObject> ecoreEList = (EcoreEList<EObject>) semanticModel.eGet(eReference);\n\t\t\t\n\t\t\tfor (Iterator<EObject> iterator = ecoreEList.iterator(); iterator.hasNext();) {\n\t\t\t\t\n\t\t\t\tEObject object = iterator.next();\n\t\t\t\t\n\t\t\t\tif (EcoreUtil2.getURIFragment(object).equalsIgnoreCase(((LeafNode)lastCompleteNode).getText())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn false;\n\t}","id":44592,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprivate boolean isLinked(AbstractNode lastCompleteNode) {\n\n\t\tEObject semanticModel = NodeUtil.getNearestSemanticObject(lastCompleteNode);\n\n\t\tEReference eReference = getReference((CrossReference) lastCompleteNode.getGrammarElement(), semanticModel\n\t\t\t\t.eClass());\n\n\t\tif (eReference.getUpperBound() == 1) {\n\n\t\t\tif (null != semanticModel.eGet(eReference)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\tEcoreEList<EObject> ecoreEList = (EcoreEList<EObject>) semanticModel.eGet(eReference);\n\n\t\t\tfor (EObject object : ecoreEList) {\n\n\t\t\t\tif (EcoreUtil2.getURIFragment(object).equalsIgnoreCase(((LeafNode) lastCompleteNode).getText())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * computes the possible grammar elements following the one at the given\n\t * offset and calls the respective methods on the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\t\t\n\t\tICompletionProposal[] completionProposals = null;\n\t\t\n\t\tif (proposalProvider != null) {\n\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\t\n\t\t\tif (document instanceof XtextDocument) {\n\t\t\t\t\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\t\t\t\t\n\t\t\t\tXtextDocument xtextDocument = (XtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\tString prefix = null==currentLeafNode ? \"\" : currentLeafNode.getText();\n\n\t\t\t\tSet<AbstractElement> nextValidElementSet = ParseTreeUtil.getElementSetValidFromOffset(rootNode,lastCompleteNode, offset);\n\t\t\t\t/**\n\t\t\t\t * in the case of a non linked crossreference we delegate to proposalProvider (again)  \n\t\t\t\t */\n\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof CrossReference && !isLinked(lastCompleteNode) ) {\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement().eContainer());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (List<EObject> resolvedElementOrRuleList : new ProposalCandidateResolverSwitch(nextValidElementSet)) {\n\n\t\t\t\t\tList<ICompletionProposal> collectedCompletionProposalList = collectCompletionProposalList(resolvedElementOrRuleList,  xtextDocument,\n\t\t\t\t\t\t\tlastCompleteNode, prefix, offset);\n\t\t\t\t\t\n\t\t\t\t\tcompletionProposalList.addAll(collectedCompletionProposalList);\n\t\t\t\t}\n\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<? extends ICompletionProposal> sortAndFilter = proposalProvider.sortAndFilter(completionProposalList,currentLeafNode,prefix);\n\t\t\t\t\tcompletionProposals =  sortAndFilter.toArray(new ICompletionProposal[] {});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn completionProposals;\n\t}","id":44593,"modified_method":"/**\n\t * computes the possible grammar elements following the one at the given\n\t * offset and calls the respective methods on the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\t\t\n\t\tICompletionProposal[] completionProposals = null;\n\t\t\n\t\tif (proposalProvider != null) {\n\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\t\n\t\t\tif (document instanceof XtextDocument) {\n\t\t\t\t\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\t\t\t\t\n\t\t\t\tXtextDocument xtextDocument = (XtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\tString prefix = null==currentLeafNode ? \"\" : currentLeafNode.getText();\n\t\t\t\t\n\t\t\t\tSet<AbstractElement> nextValidElementSet = new LinkedHashSet<AbstractElement>();\n\t\t\t\t/**\n\t\t\t\t * in the case of a non linked crossreference we delegate to proposalProvider (again) \n\t\t\t\t */\n\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof CrossReference && !isLinked(lastCompleteNode)) {\n\t\t\t\t\t\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t} \n\t\t\t\t/**\n\t\t\t\t * in the case we are at the end of the completed previous element add for 'right-to-left' backtracking cases\n\t\t\t\t */\n\t\t\t\telse if (currentLeafNode==lastCompleteNode) {\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode,lastCompleteNode, offset));\n\t\t\t\t\n\t\t\t\tProposalProviderInvokerSwitch proposalProviderInvokerSwitch = new ProposalProviderInvokerSwitch(\n\t\t\t\t\t\tlastCompleteNode, document, offset, prefix, proposalProvider);\n\t\t\t\t\n\t\t\t\tfor (List<EObject> resolvedElementOrRuleList : new ProposalCandidateResolverSwitch(nextValidElementSet)) {\n\n\t\t\t\t\tList<ICompletionProposal> collectedCompletionProposalList = \n\t\t\t\t\t\tproposalProviderInvokerSwitch.collectCompletionProposalList(resolvedElementOrRuleList);\n\t\t\t\t\t\n\t\t\t\t\tcompletionProposalList.addAll(collectedCompletionProposalList);\n\t\t\t\t}\n\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<? extends ICompletionProposal> sortAndFilter = proposalProvider.sortAndFilter(completionProposalList,currentLeafNode,prefix,document,offset);\n\t\t\t\t\tcompletionProposals =  sortAndFilter.toArray(new ICompletionProposal[] {});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn completionProposals;\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeErwachsenerName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeErwachsenerName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"ErwachsenerName\", offset));\n\t}","id":44594,"modified_method":"public List<? extends ICompletionProposal> completeErwachsenerName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeErwachsenerName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"ErwachsenerName\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeSpielplatzGroesse(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielplatzGroesse feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"1\", offset));\t\t\n\t}","id":44595,"modified_method":"public List<? extends ICompletionProposal> completeSpielplatzGroesse(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielplatzGroesse feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"1\", offset));\t\t\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeCustomTypeParserRuleName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeCustomTypeParserRuleName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"CustomTypeParserRuleName\", offset));\n\t}","id":44596,"modified_method":"public List<? extends ICompletionProposal> completeCustomTypeParserRuleName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeCustomTypeParserRuleName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"CustomTypeParserRuleName\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeErwachsenerAge(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeErwachsenerAge feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"1\", offset));\t\t\n\t}","id":44597,"modified_method":"public List<? extends ICompletionProposal> completeErwachsenerAge(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeErwachsenerAge feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"1\", offset));\t\t\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeSpielzeugName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielzeugName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"SpielzeugName\", offset));\n\t}","id":44598,"modified_method":"public List<? extends ICompletionProposal> completeSpielzeugName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielzeugName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"SpielzeugName\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeKindName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKindName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"KindName\", offset));\n\t}","id":44599,"modified_method":"public List<? extends ICompletionProposal> completeKindName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKindName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"KindName\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeSpielplatzBeschreibung(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielplatzBeschreibung feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"\\\"SpielplatzBeschreibung\\\"\", offset));\t\t\n\t}","id":44600,"modified_method":"public List<? extends ICompletionProposal> completeSpielplatzBeschreibung(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeSpielplatzBeschreibung feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"\\\"SpielplatzBeschreibung\\\"\", offset));\t\t\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeKindAge(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKindAge feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"1\", offset));\t\t\n\t}","id":44601,"modified_method":"public List<? extends ICompletionProposal> completeKindAge(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKindAge feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment,model,\"1\", offset));\t\t\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @param text\n\t *            the text value to be replaced/inserted\n\t * @param label\n\t *            the label to be displayed\n\t * @param description\n\t *            some additional description for the tooltip\n\t * @param imageFilePath\n\t *            the relative path of the image file, relative to the root of\n\t *            the plug-in; the path must be legal\n\t * @param pluginId\n\t *            the id of the plug-in containing the image file;\n\t * @param offset\n\t *            the offset of the text\n\t */\n\tpublic XtextCompletionProposal(String text, StyledString label,\n\t\t\tString description, String imageFilePath, String pluginIdentifier,\n\t\t\tint offset) {\n\t\tAssert.isNotNull(text, \"parameter 'text' must not be null\");\n\t\tAssert.isNotNull(pluginIdentifier,\n\t\t\t\t\"pluginIdentifier 'text' must not be null\");\n\t\tthis.text = text;\n\t\tthis.description = description;\n\t\tthis.offset = offset;\n\t\tthis.pluginIdentifier = pluginIdentifier;\n\n\t\tif (label != null) {\n\t\t\tthis.label = label;\n\t\t} else {\n\t\t\tthis.label = new StyledString(this.text);\n\t\t}\n\t\tif (imageFilePath != null) {\n\t\t\tinitializeImage(imageFilePath);\n\t\t}\n\t}","id":44602,"modified_method":"/**\n\t * @param element\n\t *            the element for which this CompletionProposal is created for\n\t * @param model the last semtantically complete object \n\t * @param text\n\t *            the text value to be replaced/inserted\n\t * @param label\n\t *            the label to be displayed\n\t * @param description\n\t *            some additional description for the tooltip\n\t * @param imageFilePath\n\t *            the relative path of the image file, relative to the root of\n\t *            the plug-in; the path must be legal\n\t * @param pluginId\n\t *            the id of the plug-in containing the image file;\n\t * @param offset\n\t *            the offset of the text\n\t */\n\tpublic XtextCompletionProposal(AbstractElement element,EObject model,String text, StyledString label,\n\t\t\tString description, String imageFilePath, String pluginIdentifier,\n\t\t\tint offset) {\n\t\tAssert.isNotNull(text, \"parameter 'text' must not be null\");\n\t\tAssert.isNotNull(pluginIdentifier,\n\t\t\t\t\"pluginIdentifier 'text' must not be null\");\n\t\tthis.abstractElement = element;\n\t\tthis.model = model;\n\t\tthis.text = text;\n\t\tthis.description = description;\n\t\tthis.offset = offset;\n\t\tthis.pluginIdentifier = pluginIdentifier;\n\n\t\tif (label != null) {\n\t\t\tthis.label = label;\n\t\t} else {\n\t\t\tthis.label = new StyledString(this.text);\n\t\t}\n\t\tif (imageFilePath != null) {\n\t\t\tinitializeImage(imageFilePath);\n\t\t}\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeLexerRuleBody(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeLexerRuleBody feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"\\\"LexerRuleBody\\\"\", offset));\t\t\n\t}","id":44603,"modified_method":"public List<? extends ICompletionProposal> completeLexerRuleBody(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeLexerRuleBody feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"\\\"LexerRuleBody\\\"\", offset));\t\t\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeGrammarSuperGrammarIdElements(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeGrammarSuperGrammarIdElements feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"GrammarSuperGrammarIdElements\", offset));\n\t}","id":44604,"modified_method":"public List<? extends ICompletionProposal> completeGrammarSuperGrammarIdElements(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeGrammarSuperGrammarIdElements feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"GrammarSuperGrammarIdElements\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeKeywordValue(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKeywordValue feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"\\\"KeywordValue\\\"\", offset));\t\t\n\t}","id":44605,"modified_method":"public List<? extends ICompletionProposal> completeKeywordValue(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeKeywordValue feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"\\\"KeywordValue\\\"\", offset));\t\t\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeTypeRefName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeTypeRefName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"TypeRefName\", offset));\n\t}","id":44606,"modified_method":"public List<? extends ICompletionProposal> completeTypeRefName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeTypeRefName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"TypeRefName\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeGeneratedMetamodelNsURI(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeGeneratedMetamodelNsURI feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"\\\"GeneratedMetamodelNsURI\\\"\", offset));\t\t\n\t}","id":44607,"modified_method":"public List<? extends ICompletionProposal> completeGeneratedMetamodelNsURI(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeGeneratedMetamodelNsURI feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"\\\"GeneratedMetamodelNsURI\\\"\", offset));\t\t\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeRuleCallName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeRuleCallName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"RuleCallName\", offset));\n\t}","id":44608,"modified_method":"public List<? extends ICompletionProposal> completeRuleCallName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeRuleCallName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"RuleCallName\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeLexerRuleName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeLexerRuleName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"LexerRuleName\", offset));\n\t}","id":44609,"modified_method":"public List<? extends ICompletionProposal> completeLexerRuleName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeLexerRuleName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"LexerRuleName\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeAssignmentFeature(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeAssignmentFeature feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"AssignmentFeature\", offset));\n\t}","id":44610,"modified_method":"public List<? extends ICompletionProposal> completeAssignmentFeature(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeAssignmentFeature feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"AssignmentFeature\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeGrammarIdElements(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeGrammarIdElements feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"GrammarIdElements\", offset));\n\t}","id":44611,"modified_method":"public List<? extends ICompletionProposal> completeGrammarIdElements(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeGrammarIdElements feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"GrammarIdElements\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeReferencedMetamodelAlias(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeReferencedMetamodelAlias feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"ReferencedMetamodelAlias\", offset));\n\t}","id":44612,"modified_method":"public List<? extends ICompletionProposal> completeReferencedMetamodelAlias(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeReferencedMetamodelAlias feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"ReferencedMetamodelAlias\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeActionFeature(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeActionFeature feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"ActionFeature\", offset));\n\t}","id":44613,"modified_method":"public List<? extends ICompletionProposal> completeActionFeature(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeActionFeature feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"ActionFeature\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeGeneratedMetamodelAlias(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeGeneratedMetamodelAlias feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"GeneratedMetamodelAlias\", offset));\n\t}","id":44614,"modified_method":"public List<? extends ICompletionProposal> completeGeneratedMetamodelAlias(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeGeneratedMetamodelAlias feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"GeneratedMetamodelAlias\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeParserRuleName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeParserRuleName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"ParserRuleName\", offset));\n\t}","id":44615,"modified_method":"public List<? extends ICompletionProposal> completeParserRuleName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeParserRuleName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"ParserRuleName\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeGeneratedMetamodelName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeGeneratedMetamodelName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"GeneratedMetamodelName\", offset));\n\t}","id":44616,"modified_method":"public List<? extends ICompletionProposal> completeGeneratedMetamodelName(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeGeneratedMetamodelName feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"GeneratedMetamodelName\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeReferencedMetamodelUri(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeReferencedMetamodelUri feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"\\\"ReferencedMetamodelUri\\\"\", offset));\t\t\n\t}","id":44617,"modified_method":"public List<? extends ICompletionProposal> completeReferencedMetamodelUri(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeReferencedMetamodelUri feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"\\\"ReferencedMetamodelUri\\\"\", offset));\t\t\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"public List<? extends ICompletionProposal> completeTypeRefAlias(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeTypeRefAlias feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(\"TypeRefAlias\", offset));\n\t}","id":44618,"modified_method":"public List<? extends ICompletionProposal> completeTypeRefAlias(Assignment assignment, EObject model, String prefix, IDocument doc,int offset) {\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"completeTypeRefAlias feature '\" + assignment.getFeature() + \"' terminal '\"\n\t\t\t\t\t+ assignment.getTerminal() + \"' cardinality '\" + assignment.getCardinality() + \"' and prefix '\"\n\t\t\t\t\t+ prefix.trim() + \"'\");\n\t\t}\n\t\treturn Collections.singletonList(createCompletionProposal(assignment, model, \"TypeRefAlias\", offset));\n\t}","commit_id":"6bd2d22a5c47055397f212ef533a9cc5a5f07182","url":"https://github.com/eclipse/xtext"},{"original_method":"private synchronized Answer execute(LoadBalancerConfigCommand cmd, int numRetries) {\n        try {\n            if (_isSdx) {\n                return Answer.createUnsupportedCommandAnswer(cmd);\n            }\n\n            LoadBalancerTO[] loadBalancers = cmd.getLoadBalancers();\n            if (loadBalancers == null) {\n                return new Answer(cmd);\n            }\n\n            for (LoadBalancerTO loadBalancer : loadBalancers) {\n                String srcIp = loadBalancer.getSrcIp();\n                int srcPort = loadBalancer.getSrcPort();\n                String lbProtocol = getNetScalerProtocol(loadBalancer);\n                String lbAlgorithm = loadBalancer.getAlgorithm();\n                String nsVirtualServerName  = generateNSVirtualServerName(srcIp, srcPort);\n\n                boolean destinationsToAdd = false;\n                for (DestinationTO destination : loadBalancer.getDestinations()) {\n                    if (!destination.isRevoked()) {\n                        destinationsToAdd = true;\n                        break;\n                    }\n                }\n\n                if (!loadBalancer.isRevoked() && destinationsToAdd) {\n\n                    // create a load balancing virtual server\n                    addLBVirtualServer(nsVirtualServerName, srcIp, srcPort, lbAlgorithm, lbProtocol, loadBalancer.getStickinessPolicies());\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Created load balancing virtual server \" + nsVirtualServerName + \" on the Netscaler device\");\n                    }\n\n                    for (DestinationTO destination : loadBalancer.getDestinations()) {\n                        \n                        String nsServerName = generateNSServerName(destination.getDestIp());\n                        String nsServiceName = generateNSServiceName(destination.getDestIp(), destination.getDestPort());\n                        \n                        if (!destination.isRevoked()) {\n                            // add a new destination to deployed load balancing rule\n\n                            // add a new server\n                            if (!nsServerExists(nsServerName)) {\n                                com.citrix.netscaler.nitro.resource.config.basic.server nsServer = new com.citrix.netscaler.nitro.resource.config.basic.server();\n                                nsServer.set_name(nsServerName);\n                                nsServer.set_ipaddress(destination.getDestIp());\n                                apiCallResult = com.citrix.netscaler.nitro.resource.config.basic.server.add(_netscalerService, nsServer);\n                                if ((apiCallResult.errorcode != 0) && (apiCallResult.errorcode != NitroError.NS_RESOURCE_EXISTS)) {\n                                    throw new ExecutionException(\"Failed to add server \" + destination.getDestIp() + \" due to\" + apiCallResult.message);\n                                }\n                            }\n\n                            // create a new service using the server added\n                            if (!nsServiceExists(nsServiceName)) {\n                                com.citrix.netscaler.nitro.resource.config.basic.service newService = new com.citrix.netscaler.nitro.resource.config.basic.service();\n                                newService.set_name(nsServiceName);\n                                newService.set_port(destination.getDestPort());\n                                newService.set_servername(nsServerName);\n                                newService.set_state(\"ENABLED\");\n                                newService.set_servicetype(lbProtocol);\n\n                                apiCallResult = com.citrix.netscaler.nitro.resource.config.basic.service.add(_netscalerService, newService);\n                                if (apiCallResult.errorcode != 0) {\n                                    throw new ExecutionException(\"Failed to create service \" + nsServiceName + \" using server \" + nsServerName + \" due to\" + apiCallResult.message);\n                                }\n                            }\n\n                            //bind service to load balancing virtual server    \n                            if (!nsServiceBindingExists(nsVirtualServerName, nsServiceName)) {\n                                com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding svcBinding = new com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding();\n                                svcBinding.set_name(nsVirtualServerName);\n                                svcBinding.set_servicename(nsServiceName);\n                                apiCallResult = com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding.add(_netscalerService, svcBinding);\n                                \n                                if (apiCallResult.errorcode != 0) {\n                                    throw new ExecutionException(\"Failed to bind service: \" + nsServiceName + \" to the lb virtual server: \" + nsVirtualServerName + \" on Netscaler device\");\n                                }\n                            }\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Successfully added LB destination: \" + destination.getDestIp() + \":\" + destination.getDestPort() + \" to load balancer \" + srcIp + \":\" + srcPort);\n                            }\n                        } else {\n                            // remove a destination from the deployed load balancing rule\n                            com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding[] serviceBindings = com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding.get(_netscalerService, nsVirtualServerName);\n                            if (serviceBindings != null) {\n                                for (com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding binding : serviceBindings) {\n                                    if (nsServiceName.equalsIgnoreCase(binding.get_servicename())) {\n                                        // delete the binding\n                                        apiCallResult = com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding.delete(_netscalerService, binding);\n                                        if (apiCallResult.errorcode != 0) {\n                                            throw new ExecutionException(\"Failed to delete the binding between the virtual server: \" + nsVirtualServerName + \" and service:\" + nsServiceName + \" due to\" + apiCallResult.message);\n                                        }\n    \n                                        // delete the service\n                                        apiCallResult = com.citrix.netscaler.nitro.resource.config.basic.service.delete(_netscalerService, nsServiceName);\n                                        if (apiCallResult.errorcode != 0) {\n                                            throw new ExecutionException(\"Failed to delete service: \" + nsServiceName + \" due to \" + apiCallResult.message);\n                                        }\n    \n                                        // delete the server if there is no associated services\n                                        server_service_binding[] services = server_service_binding.get(_netscalerService, nsServerName);\n                                        if ((services == null) || (services.length == 0)) {\n                                            apiCallResult = com.citrix.netscaler.nitro.resource.config.basic.server.delete(_netscalerService, nsServerName);\n                                            if (apiCallResult.errorcode != 0) {\n                                                throw new ExecutionException(\"Failed to remove server:\" + nsServerName + \" due to \" + apiCallResult.message);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                         }\n                    }\n                } else {\n                    // delete the implemented load balancing rule and its destinations \n                    lbvserver lbserver = getVirtualServerIfExisits(nsVirtualServerName);\n                    if (lbserver == null) {\n                        throw new ExecutionException(\"Failed to find virtual server with name:\" + nsVirtualServerName);\n                    }\n\n                    //unbind the all services associated with this virtual server\n                    com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding[] serviceBindings = com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding.get(_netscalerService, nsVirtualServerName);\n                    \n                    if (serviceBindings != null) {\n                        for (com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding binding : serviceBindings) {\n                            String serviceName = binding.get_servicename();\n                            apiCallResult = com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding.delete(_netscalerService, binding);\n                            if (apiCallResult.errorcode != 0) {\n                                throw new ExecutionException(\"Failed to unbind service from the lb virtual server: \" + nsVirtualServerName + \" due to \" + apiCallResult.message);\n                            }\n    \n                            com.citrix.netscaler.nitro.resource.config.basic.service svc = com.citrix.netscaler.nitro.resource.config.basic.service.get(_netscalerService, serviceName);\n                            String nsServerName = svc.get_servername();\n\n                            // check if service is bound to any other virtual server\n                            boolean deleteService = true;\n                            lbvserver[] lbservers = lbvserver.get(_netscalerService);\n                            for (lbvserver vserver : lbservers) {\n                                filtervalue[] filter = new filtervalue[1];\n                                filter[0] = new filtervalue(\"servicename\", serviceName);\n                                lbvserver_service_binding[] result = (lbvserver_service_binding[]) lbvserver_service_binding.get_filtered(_netscalerService, vserver.get_name(), filter);\n                                if (result != null && result.length > 0) {\n                                    deleteService = false;\n                                    break;\n                                }\n                            }\n                            \n                            if (deleteService) {\n                                // no lb virtual servers are bound to this service so delete it\n                                com.citrix.netscaler.nitro.resource.config.basic.service.delete(_netscalerService, serviceName);\n                            }\n\n                            //delete the server if no more services attached\n                            server_service_binding[] services = server_service_binding.get(_netscalerService, nsServerName);\n                            if ((services == null) || (services.length == 0)) {\n                                apiCallResult = com.citrix.netscaler.nitro.resource.config.basic.server.delete(_netscalerService, nsServerName);\n                                if (apiCallResult.errorcode != 0) {\n                                    throw new ExecutionException(\"Failed to remove server:\" + nsServerName + \" due to \" + apiCallResult.message);\n                                }\n                            }\n                        }\n                    }\n                    removeLBVirtualServer(nsVirtualServerName);\n                }\n            }\n\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"Successfully executed resource LoadBalancerConfigCommand: \" + _gson.toJson(cmd));\n            }\n\n            saveConfiguration();\n            return new Answer(cmd);\n        } catch (ExecutionException e) {\n            s_logger.error(\"Failed to execute LoadBalancerConfigCommand due to \" + e.getMessage());\n            if (shouldRetry(numRetries)) {\n                return retry(cmd, numRetries);\n            } else {\n                return new Answer(cmd, e);\n            }\n        }  catch (Exception e) {\n            s_logger.error(\"Failed to execute LoadBalancerConfigCommand due to \" + e.getMessage());\n            if (shouldRetry(numRetries)) {\n                return retry(cmd, numRetries);\n            } else {\n                return new Answer(cmd, e);\n            }\n        } \n    }","id":44619,"modified_method":"private synchronized Answer execute(LoadBalancerConfigCommand cmd, int numRetries) {\n        try {\n            if (_isSdx) {\n                return Answer.createUnsupportedCommandAnswer(cmd);\n            }\n\n            LoadBalancerTO[] loadBalancers = cmd.getLoadBalancers();\n            if (loadBalancers == null) {\n                return new Answer(cmd);\n            }\n\n            for (LoadBalancerTO loadBalancer : loadBalancers) {\n                String srcIp = loadBalancer.getSrcIp();\n                int srcPort = loadBalancer.getSrcPort();\n                String lbProtocol = getNetScalerProtocol(loadBalancer);\n                String lbAlgorithm = loadBalancer.getAlgorithm();\n                String nsVirtualServerName  = generateNSVirtualServerName(srcIp, srcPort);\n\n                boolean destinationsToAdd = false;\n                for (DestinationTO destination : loadBalancer.getDestinations()) {\n                    if (!destination.isRevoked()) {\n                        destinationsToAdd = true;\n                        break;\n                    }\n                }\n\n                if (!loadBalancer.isRevoked() && destinationsToAdd) {\n\n                    // create a load balancing virtual server\n                    addLBVirtualServer(nsVirtualServerName, srcIp, srcPort, lbAlgorithm, lbProtocol, loadBalancer.getStickinessPolicies());\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"Created load balancing virtual server \" + nsVirtualServerName + \" on the Netscaler device\");\n                    }\n\n                    for (DestinationTO destination : loadBalancer.getDestinations()) {\n                        \n                        String nsServerName = generateNSServerName(destination.getDestIp());\n                        String nsServiceName = generateNSServiceName(destination.getDestIp(), destination.getDestPort());\n                        \n                        if (!destination.isRevoked()) {\n                            // add a new destination to deployed load balancing rule\n\n                            // add a new server\n                            if (!nsServerExists(nsServerName)) {\n                                com.citrix.netscaler.nitro.resource.config.basic.server nsServer = new com.citrix.netscaler.nitro.resource.config.basic.server();\n                                nsServer.set_name(nsServerName);\n                                nsServer.set_ipaddress(destination.getDestIp());\n                                apiCallResult = com.citrix.netscaler.nitro.resource.config.basic.server.add(_netscalerService, nsServer);\n                                if ((apiCallResult.errorcode != 0) && (apiCallResult.errorcode != NitroError.NS_RESOURCE_EXISTS)) {\n                                    throw new ExecutionException(\"Failed to add server \" + destination.getDestIp() + \" due to\" + apiCallResult.message);\n                                }\n                            }\n\n                            // create a new service using the server added\n                            if (!nsServiceExists(nsServiceName)) {\n                                com.citrix.netscaler.nitro.resource.config.basic.service newService = new com.citrix.netscaler.nitro.resource.config.basic.service();\n                                newService.set_name(nsServiceName);\n                                newService.set_port(destination.getDestPort());\n                                newService.set_servername(nsServerName);\n                                newService.set_state(\"ENABLED\");\n                                newService.set_servicetype(lbProtocol);\n\n                                apiCallResult = com.citrix.netscaler.nitro.resource.config.basic.service.add(_netscalerService, newService);\n                                if (apiCallResult.errorcode != 0) {\n                                    throw new ExecutionException(\"Failed to create service \" + nsServiceName + \" using server \" + nsServerName + \" due to\" + apiCallResult.message);\n                                }\n                            }\n\n                            //bind service to load balancing virtual server    \n                            if (!nsServiceBindingExists(nsVirtualServerName, nsServiceName)) {\n                                com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding svcBinding = new com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding();\n                                svcBinding.set_name(nsVirtualServerName);\n                                svcBinding.set_servicename(nsServiceName);\n                                apiCallResult = com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding.add(_netscalerService, svcBinding);\n                                \n                                if (apiCallResult.errorcode != 0) {\n                                    throw new ExecutionException(\"Failed to bind service: \" + nsServiceName + \" to the lb virtual server: \" + nsVirtualServerName + \" on Netscaler device\");\n                                }\n                            }\n                            if (s_logger.isDebugEnabled()) {\n                                s_logger.debug(\"Successfully added LB destination: \" + destination.getDestIp() + \":\" + destination.getDestPort() + \" to load balancer \" + srcIp + \":\" + srcPort);\n                            }\n                        } else {\n                            // remove a destination from the deployed load balancing rule\n                            com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding[] serviceBindings = com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding.get(_netscalerService, nsVirtualServerName);\n                            if (serviceBindings != null) {\n                                for (com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding binding : serviceBindings) {\n                                    if (nsServiceName.equalsIgnoreCase(binding.get_servicename())) {\n                                        // delete the binding\n                                        apiCallResult = com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding.delete(_netscalerService, binding);\n                                        if (apiCallResult.errorcode != 0) {\n                                            throw new ExecutionException(\"Failed to delete the binding between the virtual server: \" + nsVirtualServerName + \" and service:\" + nsServiceName + \" due to\" + apiCallResult.message);\n                                        }\n    \n                                        // delete the service\n                                        apiCallResult = com.citrix.netscaler.nitro.resource.config.basic.service.delete(_netscalerService, nsServiceName);\n                                        if (apiCallResult.errorcode != 0) {\n                                            throw new ExecutionException(\"Failed to delete service: \" + nsServiceName + \" due to \" + apiCallResult.message);\n                                        }\n    \n                                        // delete the server if there is no associated services\n                                        server_service_binding[] services = server_service_binding.get(_netscalerService, nsServerName);\n                                        if ((services == null) || (services.length == 0)) {\n                                            apiCallResult = com.citrix.netscaler.nitro.resource.config.basic.server.delete(_netscalerService, nsServerName);\n                                            if (apiCallResult.errorcode != 0) {\n                                                throw new ExecutionException(\"Failed to remove server:\" + nsServerName + \" due to \" + apiCallResult.message);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                         }\n                    }\n                } else {\n                    // delete the implemented load balancing rule and its destinations \n                    lbvserver lbserver = getVirtualServerIfExisits(nsVirtualServerName);\n                    if (lbserver != null) {\n                        //unbind the all services associated with this virtual server\n                        com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding[] serviceBindings = com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding.get(_netscalerService, nsVirtualServerName);\n                        \n                        if (serviceBindings != null) {\n                            for (com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding binding : serviceBindings) {\n                                String serviceName = binding.get_servicename();\n                                apiCallResult = com.citrix.netscaler.nitro.resource.config.lb.lbvserver_service_binding.delete(_netscalerService, binding);\n                                if (apiCallResult.errorcode != 0) {\n                                    throw new ExecutionException(\"Failed to unbind service from the lb virtual server: \" + nsVirtualServerName + \" due to \" + apiCallResult.message);\n                                }\n        \n                                com.citrix.netscaler.nitro.resource.config.basic.service svc = com.citrix.netscaler.nitro.resource.config.basic.service.get(_netscalerService, serviceName);\n                                String nsServerName = svc.get_servername();\n\n                                // check if service is bound to any other virtual server\n                                boolean deleteService = true;\n                                lbvserver[] lbservers = lbvserver.get(_netscalerService);\n                                for (lbvserver vserver : lbservers) {\n                                    filtervalue[] filter = new filtervalue[1];\n                                    filter[0] = new filtervalue(\"servicename\", serviceName);\n                                    lbvserver_service_binding[] result = (lbvserver_service_binding[]) lbvserver_service_binding.get_filtered(_netscalerService, vserver.get_name(), filter);\n                                    if (result != null && result.length > 0) {\n                                        deleteService = false;\n                                        break;\n                                    }\n                                }\n                                \n                                if (deleteService) {\n                                    // no lb virtual servers are bound to this service so delete it\n                                    com.citrix.netscaler.nitro.resource.config.basic.service.delete(_netscalerService, serviceName);\n                                }\n\n                                //delete the server if no more services attached\n                                server_service_binding[] services = server_service_binding.get(_netscalerService, nsServerName);\n                                if ((services == null) || (services.length == 0)) {\n                                    apiCallResult = com.citrix.netscaler.nitro.resource.config.basic.server.delete(_netscalerService, nsServerName);\n                                    if (apiCallResult.errorcode != 0) {\n                                        throw new ExecutionException(\"Failed to remove server:\" + nsServerName + \" due to \" + apiCallResult.message);\n                                    }\n                                }\n                            }\n                        }\n                        removeLBVirtualServer(nsVirtualServerName);\n                    }\n                }\n            }\n\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"Successfully executed resource LoadBalancerConfigCommand: \" + _gson.toJson(cmd));\n            }\n\n            saveConfiguration();\n            return new Answer(cmd);\n        } catch (ExecutionException e) {\n            s_logger.error(\"Failed to execute LoadBalancerConfigCommand due to \" + e.getMessage());\n            if (shouldRetry(numRetries)) {\n                return retry(cmd, numRetries);\n            } else {\n                return new Answer(cmd, e);\n            }\n        }  catch (Exception e) {\n            s_logger.error(\"Failed to execute LoadBalancerConfigCommand due to \" + e.getMessage());\n            if (shouldRetry(numRetries)) {\n                return retry(cmd, numRetries);\n            } else {\n                return new Answer(cmd, e);\n            }\n        } \n    }","commit_id":"47a6f74f6f349d9cb5dbde4db4ab0d61212e8d53","url":"https://github.com/apache/cloudstack"},{"original_method":"private void deleteGuestVlan(long vlanTag, String vlanSelfIp, String vlanNetmask) throws ExecutionException {\n        try {\n            if (nsVlanExists(vlanTag)) {\n\n                // Delete all servers and associated services from this guest VLAN\n                deleteServersInGuestVlan(vlanTag, vlanSelfIp, vlanNetmask);\n\n                // unbind vlan to the private interface\n                vlan_interface_binding vlanIfBinding = new vlan_interface_binding();\n                vlanIfBinding.set_id(vlanTag);\n                vlanIfBinding.set_ifnum(_privateInterface);\n                vlanIfBinding.set_tagged(true);\n                try {\n                    apiCallResult = vlan_interface_binding.delete(_netscalerService, vlanIfBinding);\n                } catch (nitro_exception e) {\n                    // FIXME: Vlan binding (subsequent unbind) to an interfaces will fail on the VPX created on Xen server and on \n                    // NetScaler SDX appliance till the VPX fix to handle VLAN's is released. Relaxing this restriction NetScaler until then\n                    if (!(_deviceName.equalsIgnoreCase(\"NetscalerVPXLoadBalancer\") && e.getErrorCode() == NitroError.NS_RESOURCE_NOT_EXISTS)) {\n                        throw new ExecutionException(\"Failed to unbind vlan from the interface while shutdown of guest network on the Netscaler device due to \" + e.getMessage());\n                    }\n                }\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to unbind vlan:\" + vlanTag + \" with the private interface due to \" + apiCallResult.message);\n                }\n\n                //unbind the vlan to subnet\n                vlan_nsip_binding vlanSnipBinding = new vlan_nsip_binding();\n                vlanSnipBinding.set_netmask(vlanNetmask);\n                vlanSnipBinding.set_ipaddress(vlanSelfIp);\n                vlanSnipBinding.set_id(vlanTag);\n                apiCallResult = vlan_nsip_binding.delete(_netscalerService, vlanSnipBinding);\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to unbind vlan:\" + vlanTag + \" with the subnet due to \" + apiCallResult.message);\n                }\n\n                // remove subnet IP\n                nsip subnetIp = nsip.get(_netscalerService, vlanSelfIp);\n                apiCallResult = nsip.delete(_netscalerService, subnetIp);\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to remove subnet ip:\" + vlanTag + \" to the subnet due to\" + apiCallResult.message);\n                }\n\n                // remove vlan\n                apiCallResult = com.citrix.netscaler.nitro.resource.config.network.vlan.delete(_netscalerService, vlanTag);\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to remove vlan with tag:\" + vlanTag + \"due to\" + apiCallResult.message);\n                }\n            } \n        }  catch (nitro_exception e) {\n            throw new ExecutionException(\"Failed to delete guest vlan network on the Netscaler device due to \" + e.getMessage());\n        }  catch (Exception e) {\n            throw new ExecutionException(\"Failed to delete guest vlan network on the Netscaler device due to \" + e.getMessage());\n        }\n    }","id":44620,"modified_method":"private void deleteGuestVlan(long vlanTag, String vlanSelfIp, String vlanNetmask) throws ExecutionException {\n        try {\n\n            // Delete all servers and associated services from this guest VLAN\n            deleteServersInGuestVlan(vlanTag, vlanSelfIp, vlanNetmask);\n\n            // unbind vlan to the private interface\n            try {\n                vlan_interface_binding vlanIfBinding = new vlan_interface_binding();\n                vlanIfBinding.set_id(vlanTag);\n                vlanIfBinding.set_ifnum(_privateInterface);\n                vlanIfBinding.set_tagged(true);\n                apiCallResult = vlan_interface_binding.delete(_netscalerService, vlanIfBinding);\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to unbind vlan:\" + vlanTag + \" with the private interface due to \" + apiCallResult.message);\n                }\n            } catch (nitro_exception e) {\n                // if Vlan to interface binding does not exist then ignore the exception and proceed\n                if (!(e.getErrorCode() == NitroError.NS_RESOURCE_NOT_EXISTS)) {\n                    throw new ExecutionException(\"Failed to unbind vlan from the interface while shutdown of guest network on the Netscaler device due to \" + e.getMessage());\n                }\n            }\n\n            // unbind the vlan to subnet\n            try {              \n                vlan_nsip_binding vlanSnipBinding = new vlan_nsip_binding();\n                vlanSnipBinding.set_netmask(vlanNetmask);\n                vlanSnipBinding.set_ipaddress(vlanSelfIp);\n                vlanSnipBinding.set_id(vlanTag);\n                apiCallResult = vlan_nsip_binding.delete(_netscalerService, vlanSnipBinding);\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to unbind vlan:\" + vlanTag + \" with the subnet due to \" + apiCallResult.message);\n                }\n            } catch (nitro_exception e) {\n                // if Vlan to subnet binding does not exist then ignore the exception and proceed\n                if (!(e.getErrorCode() == NitroError.NS_RESOURCE_NOT_EXISTS)) {\n                    throw new ExecutionException(\"Failed to unbind vlan:\" + vlanTag + \" with the subnet due to \" + e.getMessage());\n                }\n            }\n\n            // remove subnet IP\n            try {\n                nsip subnetIp = nsip.get(_netscalerService, vlanSelfIp);\n                apiCallResult = nsip.delete(_netscalerService, subnetIp);\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to remove subnet ip:\" + vlanSelfIp + \" from the NetScaler device due to\" + apiCallResult.message);\n                }\n            } catch (nitro_exception e) {\n                // if subnet SNIP does not exist then ignore the exception and proceed\n                if (!(e.getErrorCode() == NitroError.NS_RESOURCE_NOT_EXISTS)) {\n                    throw new ExecutionException(\"Failed to remove subnet ip:\" + vlanSelfIp + \" from the NetScaler device due to\" + e.getMessage());\n                }\n            }\n\n            // remove the vlan from the NetScaler device\n            if (nsVlanExists(vlanTag)) {\n                // remove vlan\n                apiCallResult = com.citrix.netscaler.nitro.resource.config.network.vlan.delete(_netscalerService, vlanTag);\n                if (apiCallResult.errorcode != 0) {\n                    throw new ExecutionException(\"Failed to remove vlan with tag:\" + vlanTag + \"due to\" + apiCallResult.message);\n                }\n            } \n        }  catch (nitro_exception e) {\n            throw new ExecutionException(\"Failed to delete guest vlan network on the Netscaler device due to \" + e.getMessage());\n        }  catch (Exception e) {\n            throw new ExecutionException(\"Failed to delete guest vlan network on the Netscaler device due to \" + e.getMessage());\n        }\n    }","commit_id":"47a6f74f6f349d9cb5dbde4db4ab0d61212e8d53","url":"https://github.com/apache/cloudstack"},{"original_method":"private void cacheAutoDetectedFileType(@NotNull VirtualFile file, @NotNull FileType fileType) {\n    DataOutputStream stream = autoDetectedAttribute.writeAttribute(file);\n    boolean wasAutodetectedAsText = fileType == FileTypes.PLAIN_TEXT;\n    boolean wasAutodetectedAsBinary = fileType == FileTypes.UNKNOWN;\n    try {\n      try {\n        int flags = BitUtil.set(0, AUTO_DETECTED_AS_TEXT_MASK, wasAutodetectedAsText);\n        flags = BitUtil.set(flags, AUTO_DETECTED_AS_BINARY_MASK, wasAutodetectedAsBinary);\n        stream.writeByte(flags);\n      }\n      finally {\n        stream.close();\n      }\n    }\n    catch (IOException e) {\n      LOG.error(e);\n    }\n    if (file instanceof VirtualFileWithId) {\n      int id = Math.abs(((VirtualFileWithId)file).getId());\n      int flags = AUTO_DETECT_WAS_RUN_MASK | ATTRIBUTES_WERE_LOADED_MASK;\n      flags = BitUtil.set(flags, AUTO_DETECTED_AS_TEXT_MASK, wasAutodetectedAsText);\n      flags = BitUtil.set(flags, AUTO_DETECTED_AS_BINARY_MASK, wasAutodetectedAsBinary);\n      packedFlags.set(id, flags);\n\n      if (wasAutodetectedAsText || wasAutodetectedAsBinary) {\n        file.putUserData(DETECTED_FROM_CONTENT_FILE_TYPE_KEY, null);\n        return;\n      }\n    }\n    file.putUserData(DETECTED_FROM_CONTENT_FILE_TYPE_KEY, fileType);\n  }","id":44621,"modified_method":"private void cacheAutoDetectedFileType(@NotNull VirtualFile file, @NotNull FileType fileType) {\n    boolean wasAutodetectedAsText = fileType == FileTypes.PLAIN_TEXT;\n    boolean wasAutodetectedAsBinary = fileType == FileTypes.UNKNOWN;\n\n    int flags = BitUtil.set(0, AUTO_DETECTED_AS_TEXT_MASK, wasAutodetectedAsText);\n    flags = BitUtil.set(flags, AUTO_DETECTED_AS_BINARY_MASK, wasAutodetectedAsBinary);\n    writeFlagsToCache(file, flags);\n    if (file instanceof VirtualFileWithId) {\n      int id = Math.abs(((VirtualFileWithId)file).getId());\n      flags = AUTO_DETECT_WAS_RUN_MASK | ATTRIBUTES_WERE_LOADED_MASK;\n      flags = BitUtil.set(flags, AUTO_DETECTED_AS_TEXT_MASK, wasAutodetectedAsText);\n      flags = BitUtil.set(flags, AUTO_DETECTED_AS_BINARY_MASK, wasAutodetectedAsBinary);\n      packedFlags.set(id, flags);\n\n      if (wasAutodetectedAsText || wasAutodetectedAsBinary) {\n        file.putUserData(DETECTED_FROM_CONTENT_FILE_TYPE_KEY, null);\n        return;\n      }\n    }\n    file.putUserData(DETECTED_FROM_CONTENT_FILE_TYPE_KEY, fileType);\n  }","commit_id":"e7051267d746dccc74f88d54280e6019043bba21","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void reDetect(@NotNull Collection<VirtualFile> files) {\n    final List<VirtualFile> changed = new ArrayList<VirtualFile>();\n    for (VirtualFile file : files) {\n      boolean shouldRedetect = wasAutoDetectedBefore(file) && isDetectable(file);\n      if (toLog()) {\n        log(\"F: Redetect file: \" + file.getName() + \"; shouldRedetect: \" + shouldRedetect);\n      }\n      if (shouldRedetect) {\n        int id = file instanceof VirtualFileWithId ? ((VirtualFileWithId)file).getId() : -1;\n        FileType before = getAutoDetectedType(file, id);\n\n        packedFlags.set(id, ATTRIBUTES_WERE_LOADED_MASK);\n\n        file.putUserData(DETECTED_FROM_CONTENT_FILE_TYPE_KEY, null);\n        FileType after = getFileTypeByFile(file); // may be back to standard file type\n        if (toLog()) {\n          log(\"F: After redetect file: \" + file.getName() + \"; before: \" + before.getName() + \"; after: \" + after.getName()+\"; now getFileType()=\"+file.getFileType().getName());\n        }\n\n        if (before != after) {\n          changed.add(file);\n          LOG.debug(file+\" type was re-detected. Was: \"+before.getName()+\"; now: \"+after.getName());\n        }\n      }\n    }\n    if (!changed.isEmpty()) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          FileContentUtilCore.reparseFiles(changed);\n        }\n      }, ApplicationManager.getApplication().getDisposed());\n    }\n  }","id":44622,"modified_method":"private void reDetect(@NotNull Collection<VirtualFile> files) {\n    final Collection<VirtualFile> changed = new ArrayList<VirtualFile>();\n    for (VirtualFile file : files) {\n      boolean shouldRedetect = wasAutoDetectedBefore(file) && isDetectable(file);\n      if (toLog()) {\n        log(\"F: Redetect file: \" + file.getName() + \"; shouldRedetect: \" + shouldRedetect);\n      }\n      if (shouldRedetect) {\n        int id = file instanceof VirtualFileWithId ? ((VirtualFileWithId)file).getId() : -1;\n        FileType before = getAutoDetectedType(file, id);\n\n        packedFlags.set(id, ATTRIBUTES_WERE_LOADED_MASK);\n\n        file.putUserData(DETECTED_FROM_CONTENT_FILE_TYPE_KEY, null);\n        FileType after = getFileTypeByFile(file); // may be back to standard file type\n        if (toLog()) {\n          log(\"F: After redetect file: \" + file.getName() + \"; before: \" + before.getName() + \"; after: \" + after.getName()+\"; now getFileType()=\"+file.getFileType().getName());\n        }\n\n        if (before != after) {\n          changed.add(file);\n          LOG.debug(file+\" type was re-detected. Was: \"+before.getName()+\"; now: \"+after.getName());\n        }\n      }\n    }\n    if (!changed.isEmpty()) {\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          FileContentUtilCore.reparseFiles(changed);\n        }\n      }, ApplicationManager.getApplication().getDisposed());\n    }\n  }","commit_id":"e7051267d746dccc74f88d54280e6019043bba21","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private FileType getOrDetectFromContent(@NotNull VirtualFile file) {\n    if (!isDetectable(file)) return UnknownFileType.INSTANCE;\n    if (file instanceof VirtualFileWithId) {\n      int id = ((VirtualFileWithId)file).getId();\n      if (id < 0) return UnknownFileType.INSTANCE;\n\n      //boolean autoDetectWasRun = this.autoDetectWasRun.get(id);\n      long flags = packedFlags.get(id);\n      boolean autoDetectWasRun = (flags & AUTO_DETECT_WAS_RUN_MASK) != 0;\n      if (autoDetectWasRun) {\n        FileType type = getAutoDetectedType(file, id);\n        if (toLog()) {\n          log(\"F: autodetected getFileType(\"+file.getName()+\") = \"+type.getName());\n        }\n        return type;\n      }\n      boolean wasDetectedAsText = false;\n      boolean wasDetectedAsBinary = false;\n      boolean wasAutoDetectRun = false;\n      if ((flags & ATTRIBUTES_WERE_LOADED_MASK) == 0) {\n        DataInputStream stream = autoDetectedAttribute.readAttribute(file);\n        try {\n          try {\n            byte status = stream != null ? stream.readByte() : 0;\n            wasAutoDetectRun = stream != null;\n            wasDetectedAsText = BitUtil.isSet(status, AUTO_DETECTED_AS_TEXT_MASK);\n            wasDetectedAsBinary = BitUtil.isSet(status, AUTO_DETECTED_AS_BINARY_MASK);\n          }\n          finally {\n            if (stream != null) {\n              stream.close();\n            }\n          }\n        }\n        catch (IOException ignored) {\n        }\n        flags = ATTRIBUTES_WERE_LOADED_MASK;\n        flags = BitUtil.set(flags, AUTO_DETECTED_AS_TEXT_MASK, wasDetectedAsText);\n        flags = BitUtil.set(flags, AUTO_DETECTED_AS_BINARY_MASK, wasDetectedAsBinary);\n        flags = BitUtil.set(flags, AUTO_DETECT_WAS_RUN_MASK, wasAutoDetectRun);\n\n        packedFlags.set(id, flags);\n      }\n      if (wasAutoDetectRun && (wasDetectedAsText || wasDetectedAsBinary)) {\n        return wasDetectedAsText ? FileTypes.PLAIN_TEXT : UnknownFileType.INSTANCE;\n      }\n    }\n    FileType fileType = file.getUserData(DETECTED_FROM_CONTENT_FILE_TYPE_KEY);\n    // run autodetection\n    if (fileType == null) {\n      fileType = detectFromContent(file);\n    }\n\n    if (toLog()) {\n      log(\"F: getFileType after detect run(\"+file.getName()+\") = \"+fileType.getName());\n    }\n\n    return fileType;\n  }","id":44623,"modified_method":"@NotNull\n  private FileType getOrDetectFromContent(@NotNull VirtualFile file) {\n    if (!isDetectable(file)) return UnknownFileType.INSTANCE;\n    if (file instanceof VirtualFileWithId) {\n      int id = ((VirtualFileWithId)file).getId();\n      if (id < 0) return UnknownFileType.INSTANCE;\n\n      long flags = packedFlags.get(id);\n      boolean autoDetectWasRun = (flags & AUTO_DETECT_WAS_RUN_MASK) != 0;\n      if (autoDetectWasRun) {\n        FileType type = getAutoDetectedType(file, id);\n        if (toLog()) {\n          log(\"F: autodetected getFileType(\"+file.getName()+\") = \"+type.getName());\n        }\n        return type;\n      }\n      if ((flags & ATTRIBUTES_WERE_LOADED_MASK) == 0) {\n        flags = readFlagsFromCache(file);\n        packedFlags.set(id, flags);\n      }\n      boolean wasDetectedAsText = BitUtil.isSet(flags, AUTO_DETECTED_AS_TEXT_MASK);\n      boolean wasDetectedAsBinary = BitUtil.isSet(flags, AUTO_DETECTED_AS_BINARY_MASK);\n      boolean wasAutoDetectRun = BitUtil.isSet(flags, AUTO_DETECT_WAS_RUN_MASK);\n      if (wasAutoDetectRun && (wasDetectedAsText || wasDetectedAsBinary)) {\n        return wasDetectedAsText ? FileTypes.PLAIN_TEXT : UnknownFileType.INSTANCE;\n      }\n    }\n    FileType fileType = file.getUserData(DETECTED_FROM_CONTENT_FILE_TYPE_KEY);\n    // run autodetection\n    if (fileType == null) {\n      fileType = detectFromContent(file);\n    }\n\n    if (toLog()) {\n      log(\"F: getFileType after detect run(\"+file.getName()+\") = \"+fileType.getName());\n    }\n\n    return fileType;\n  }","commit_id":"e7051267d746dccc74f88d54280e6019043bba21","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Gen(Context context) {\n        context.put(genKey, this);\n\n        names = Names.instance(context);\n        log = Log.instance(context);\n        syms = Symtab.instance(context);\n        chk = Check.instance(context);\n        rs = Resolve.instance(context);\n        make = TreeMaker.instance(context);\n        target = Target.instance(context);\n        types = Types.instance(context);\n        methodType = new MethodType(null, null, null, syms.methodClass);\n        allowGenerics = Source.instance(context).allowGenerics();\n        stringBufferType = target.useStringBuilder()\n            ? syms.stringBuilderType\n            : syms.stringBufferType;\n        stringBufferAppend = new HashMap<Type,Symbol>();\n        accessDollar = names.\n            fromString(\"access\" + target.syntheticNameChar());\n\n        Options options = Options.instance(context);\n        lineDebugInfo =\n            options.isUnset(G_CUSTOM) ||\n            options.isSet(G_CUSTOM, \"lines\");\n        varDebugInfo =\n            options.isUnset(G_CUSTOM)\n            ? options.isSet(G)\n            : options.isSet(G_CUSTOM, \"vars\");\n        genCrt = options.isSet(XJCOV);\n        debugCode = options.isSet(\"debugcode\");\n        allowInvokedynamic = target.hasInvokedynamic() || options.isSet(\"invokedynamic\");\n\n        generateIproxies =\n            target.requiresIproxy() ||\n            options.isSet(\"miranda\");\n\n        if (target.generateStackMapTable()) {\n            // ignore cldc because we cannot have both stackmap formats\n            this.stackMap = StackMapFormat.JSR202;\n        } else {\n            if (target.generateCLDCStackmap()) {\n                this.stackMap = StackMapFormat.CLDC;\n            } else {\n                this.stackMap = StackMapFormat.NONE;\n            }\n        }\n\n        // by default, avoid jsr's for simple finalizers\n        int setjsrlimit = 50;\n        String jsrlimitString = options.get(\"jsrlimit\");\n        if (jsrlimitString != null) {\n            try {\n                setjsrlimit = Integer.parseInt(jsrlimitString);\n            } catch (NumberFormatException ex) {\n                // ignore ill-formed numbers for jsrlimit\n            }\n        }\n        this.jsrlimit = setjsrlimit;\n        this.useJsrLocally = false; // reset in visitTry\n    }","id":44624,"modified_method":"protected Gen(Context context) {\n        context.put(genKey, this);\n\n        names = Names.instance(context);\n        log = Log.instance(context);\n        syms = Symtab.instance(context);\n        chk = Check.instance(context);\n        rs = Resolve.instance(context);\n        make = TreeMaker.instance(context);\n        target = Target.instance(context);\n        types = Types.instance(context);\n        methodType = new MethodType(null, null, null, syms.methodClass);\n        allowGenerics = Source.instance(context).allowGenerics();\n        stringBufferType = target.useStringBuilder()\n            ? syms.stringBuilderType\n            : syms.stringBufferType;\n        stringBufferAppend = new HashMap<Type,Symbol>();\n        accessDollar = names.\n            fromString(\"access\" + target.syntheticNameChar());\n\n        Options options = Options.instance(context);\n        lineDebugInfo =\n            options.isUnset(G_CUSTOM) ||\n            options.isSet(G_CUSTOM, \"lines\");\n        varDebugInfo =\n            options.isUnset(G_CUSTOM) ||\n            options.isSet(G_CUSTOM, \"vars\");\n        genCrt = options.isSet(XJCOV);\n        debugCode = options.isSet(\"debugcode\");\n        allowInvokedynamic = target.hasInvokedynamic() || options.isSet(\"invokedynamic\");\n\n        generateIproxies =\n            target.requiresIproxy() ||\n            options.isSet(\"miranda\");\n\n        if (target.generateStackMapTable()) {\n            // ignore cldc because we cannot have both stackmap formats\n            this.stackMap = StackMapFormat.JSR202;\n        } else {\n            if (target.generateCLDCStackmap()) {\n                this.stackMap = StackMapFormat.CLDC;\n            } else {\n                this.stackMap = StackMapFormat.NONE;\n            }\n        }\n\n        // by default, avoid jsr's for simple finalizers\n        int setjsrlimit = 50;\n        String jsrlimitString = options.get(\"jsrlimit\");\n        if (jsrlimitString != null) {\n            try {\n                setjsrlimit = Integer.parseInt(jsrlimitString);\n            } catch (NumberFormatException ex) {\n                // ignore ill-formed numbers for jsrlimit\n            }\n        }\n        this.jsrlimit = setjsrlimit;\n        this.useJsrLocally = false; // reset in visitTry\n    }","commit_id":"29a05c3754523f42461ffa04a297e9e947825056","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected void sendFile(\n\t\t\tHttpServletRequest request, HttpServletResponse response, User user,\n\t\t\tString[] pathArray)\n\t\tthrows Exception {\n\n\t\tFileEntry fileEntry = getFileEntry(pathArray);\n\n\t\tif (fileEntry == null) {\n\t\t\tthrow new NoSuchFileEntryException();\n\t\t}\n\n\t\tString version = ParamUtil.getString(request, \"version\");\n\n\t\tif (Validator.isNull(version)) {\n\t\t\tif (Validator.isNotNull(fileEntry.getVersion())) {\n\t\t\t\tversion = fileEntry.getVersion();\n\t\t\t}\n\t\t}\n\n\t\tString tempFileId = DLUtil.getTempFileId(\n\t\t\tfileEntry.getFileEntryId(), version);\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion(version);\n\n\t\tString fileName = fileVersion.getTitle();\n\n\t\tString extension = fileVersion.getExtension();\n\n\t\tif (Validator.isNotNull(extension) &&\n\t\t\t!fileName.endsWith(StringPool.PERIOD + extension)) {\n\n\t\t\tfileName += StringPool.PERIOD + extension;\n\t\t}\n\n\t\tboolean converted = false;\n\n\t\tString targetExtension = ParamUtil.getString(\n\t\t\trequest, \"targetExtension\");\n\t\tint imageThumbnail = ParamUtil.getInteger(request, \"imageThumbnail\");\n\t\tint documentThumbnail = ParamUtil.getInteger(\n\t\t\trequest, \"documentThumbnail\");\n\t\tint previewFileIndex = ParamUtil.getInteger(\n\t\t\trequest, \"previewFileIndex\");\n\t\tboolean audioPreview = ParamUtil.getBoolean(request, \"audioPreview\");\n\t\tboolean videoPreview = ParamUtil.getBoolean(request, \"videoPreview\");\n\t\tint videoThumbnail = ParamUtil.getInteger(request, \"videoThumbnail\");\n\n\t\tInputStream inputStream = null;\n\t\tlong contentLength = 0;\n\n\t\tif ((imageThumbnail > 0) && (imageThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(fileVersion.getExtension());\n\n\t\t\tint thumbnailIndex = imageThumbnail - 1;\n\n\t\t\tinputStream = ImageProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = ImageProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if ((documentThumbnail > 0) && (documentThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(PDFProcessorImpl.THUMBNAIL_TYPE);\n\n\t\t\tint thumbnailIndex = documentThumbnail - 1;\n\n\t\t\tinputStream = PDFProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = PDFProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (previewFileIndex > 0) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(PDFProcessorImpl.PREVIEW_TYPE);\n\t\t\tinputStream = PDFProcessorUtil.getPreviewAsStream(\n\t\t\t\tfileVersion, previewFileIndex);\n\t\t\tcontentLength = PDFProcessorUtil.getPreviewFileSize(\n\t\t\t\tfileVersion, previewFileIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (audioPreview) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(AudioProcessor.PREVIEW_TYPE);\n\t\t\tinputStream = AudioProcessorUtil.getPreviewAsStream(fileVersion);\n\t\t\tcontentLength = AudioProcessorUtil.getPreviewFileSize(fileVersion);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (videoPreview) {\n\t\t\tString type = ParamUtil.getString(request, \"type\");\n\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(type);\n\t\t\tinputStream = VideoProcessorUtil.getPreviewAsStream(\n\t\t\t\tfileVersion, type);\n\t\t\tcontentLength = VideoProcessorUtil.getPreviewFileSize(\n\t\t\t\tfileVersion, type);\n\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.ACCEPT_RANGES,\n\t\t\t\tHttpHeaders.ACCEPT_RANGES_BYTES_VALUE);\n\n\t\t\tList<Range> ranges = null;\n\n\t\t\ttry {\n\t\t\t\tranges = ServletResponseUtil.getRanges(\n\t\t\t\t\trequest, response, contentLength);\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t_log.error(ioe);\n\t\t\t\t}\n\n\t\t\t\tresponse.setHeader(\n\t\t\t\t\tHttpHeaders.CONTENT_RANGE, \"bytes */\" + contentLength);\n\n\t\t\t\tresponse.sendError(\n\t\t\t\t\tHttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((ranges != null) && (ranges.size() > 0)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Video range requested\");\n\t\t\t\t}\n\n\t\t\t\tString contentType = MimeTypesUtil.getContentType(fileName);\n\n\t\t\t\tServletResponseUtil.write(\n\t\t\t\t\trequest, response, fileName, ranges, inputStream,\n\t\t\t\t\tcontentLength, contentType);\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if ((videoThumbnail > 0) && (videoThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(VideoProcessorImpl.THUMBNAIL_TYPE);\n\n\t\t\tint thumbnailIndex = videoThumbnail - 1;\n\n\t\t\tinputStream = VideoProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = VideoProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse {\n\t\t\tinputStream = fileVersion.getContentStream(true);\n\t\t\tcontentLength = fileVersion.getSize();\n\n\t\t\tif (Validator.isNotNull(targetExtension)) {\n\t\t\t\tFile convertedFile = DocumentConversionUtil.convert(\n\t\t\t\t\ttempFileId, inputStream, extension, targetExtension);\n\n\t\t\t\tif (convertedFile != null) {\n\t\t\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\t\t\tStringPool.PERIOD).concat(targetExtension);\n\t\t\t\t\tinputStream = new FileInputStream(convertedFile);\n\t\t\t\t\tcontentLength = convertedFile.length();\n\n\t\t\t\t\tconverted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tString contentType = null;\n\n\t\tif (converted) {\n\t\t\tcontentType = MimeTypesUtil.getContentType(fileName);\n\t\t}\n\t\telse {\n\t\t\tcontentType = fileVersion.getMimeType();\n\t\t}\n\n\t\tServletResponseUtil.sendFile(\n\t\t\trequest, response, fileName, inputStream, contentLength,\n\t\t\tcontentType);\n\t}","id":44625,"modified_method":"protected void sendFile(\n\t\t\tHttpServletRequest request, HttpServletResponse response, User user,\n\t\t\tString[] pathArray)\n\t\tthrows Exception {\n\n\t\t// Retrieve file details\n\n\t\tFileEntry fileEntry = getFileEntry(pathArray);\n\n\t\tif (fileEntry == null) {\n\t\t\tthrow new NoSuchFileEntryException();\n\t\t}\n\n\t\tString version = ParamUtil.getString(request, \"version\");\n\n\t\tif (Validator.isNull(version)) {\n\t\t\tif (Validator.isNotNull(fileEntry.getVersion())) {\n\t\t\t\tversion = fileEntry.getVersion();\n\t\t\t}\n\t\t}\n\n\t\tString tempFileId = DLUtil.getTempFileId(\n\t\t\tfileEntry.getFileEntryId(), version);\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion(version);\n\n\t\tString fileName = fileVersion.getTitle();\n\n\t\tString extension = fileVersion.getExtension();\n\n\t\tif (Validator.isNotNull(extension) &&\n\t\t\t!fileName.endsWith(StringPool.PERIOD + extension)) {\n\n\t\t\tfileName += StringPool.PERIOD + extension;\n\t\t}\n\n\t\t// Handle requested conversion\n\n\t\tboolean converted = false;\n\n\t\tString targetExtension = ParamUtil.getString(\n\t\t\trequest, \"targetExtension\");\n\t\tint imageThumbnail = ParamUtil.getInteger(request, \"imageThumbnail\");\n\t\tint documentThumbnail = ParamUtil.getInteger(\n\t\t\trequest, \"documentThumbnail\");\n\t\tint previewFileIndex = ParamUtil.getInteger(\n\t\t\trequest, \"previewFileIndex\");\n\t\tboolean audioPreview = ParamUtil.getBoolean(request, \"audioPreview\");\n\t\tboolean videoPreview = ParamUtil.getBoolean(request, \"videoPreview\");\n\t\tint videoThumbnail = ParamUtil.getInteger(request, \"videoThumbnail\");\n\n\t\tInputStream inputStream = null;\n\t\tlong contentLength = 0;\n\n\t\tif ((imageThumbnail > 0) && (imageThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(fileVersion.getExtension());\n\n\t\t\tint thumbnailIndex = imageThumbnail - 1;\n\n\t\t\tinputStream = ImageProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = ImageProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if ((documentThumbnail > 0) && (documentThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(PDFProcessorImpl.THUMBNAIL_TYPE);\n\n\t\t\tint thumbnailIndex = documentThumbnail - 1;\n\n\t\t\tinputStream = PDFProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = PDFProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (previewFileIndex > 0) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(PDFProcessorImpl.PREVIEW_TYPE);\n\t\t\tinputStream = PDFProcessorUtil.getPreviewAsStream(\n\t\t\t\tfileVersion, previewFileIndex);\n\t\t\tcontentLength = PDFProcessorUtil.getPreviewFileSize(\n\t\t\t\tfileVersion, previewFileIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (audioPreview) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(AudioProcessor.PREVIEW_TYPE);\n\t\t\tinputStream = AudioProcessorUtil.getPreviewAsStream(fileVersion);\n\t\t\tcontentLength = AudioProcessorUtil.getPreviewFileSize(fileVersion);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (videoPreview) {\n\t\t\tString type = ParamUtil.getString(request, \"type\");\n\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(type);\n\t\t\tinputStream = VideoProcessorUtil.getPreviewAsStream(\n\t\t\t\tfileVersion, type);\n\t\t\tcontentLength = VideoProcessorUtil.getPreviewFileSize(\n\t\t\t\tfileVersion, type);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if ((videoThumbnail > 0) && (videoThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(VideoProcessorImpl.THUMBNAIL_TYPE);\n\n\t\t\tint thumbnailIndex = videoThumbnail - 1;\n\n\t\t\tinputStream = VideoProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = VideoProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse {\n\t\t\tinputStream = fileVersion.getContentStream(true);\n\t\t\tcontentLength = fileVersion.getSize();\n\n\t\t\tif (Validator.isNotNull(targetExtension)) {\n\t\t\t\tFile convertedFile = DocumentConversionUtil.convert(\n\t\t\t\t\ttempFileId, inputStream, extension, targetExtension);\n\n\t\t\t\tif (convertedFile != null) {\n\t\t\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\t\t\tStringPool.PERIOD).concat(targetExtension);\n\t\t\t\t\tinputStream = new FileInputStream(convertedFile);\n\t\t\t\t\tcontentLength = convertedFile.length();\n\n\t\t\t\t\tconverted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Determine proper content type\n\n\t\tString contentType = null;\n\n\t\tif (converted) {\n\t\t\tcontentType = MimeTypesUtil.getContentType(fileName);\n\t\t}\n\t\telse {\n\t\t\tcontentType = fileVersion.getMimeType();\n\t\t}\n\n\t\t// Support range HTTP header\n\n\t\tresponse.setHeader(\n\t\t\tHttpHeaders.ACCEPT_RANGES, HttpHeaders.ACCEPT_RANGES_BYTES_VALUE);\n\n\t\tList<Range> ranges = null;\n\n\t\ttry {\n\t\t\tranges = ServletResponseUtil.getRanges(\n\t\t\t\trequest, response, contentLength);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t_log.error(ioe);\n\t\t\t}\n\n\t\t\tresponse.setHeader(\n\t\t\t\tHttpHeaders.CONTENT_RANGE, \"bytes */\" + contentLength);\n\n\t\t\tresponse.sendError(\n\t\t\t\tHttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif ((ranges == null) || ranges.isEmpty()) {\n\t\t\tServletResponseUtil.sendFile(\n\t\t\t\trequest, response, fileName, inputStream, contentLength,\n\t\t\t\tcontentType);\n\t\t}\n\t\telse {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Request has range header \" +\n\t\t\t\t\t\trequest.getHeader(HttpHeaders.RANGE));\n\t\t\t}\n\n\t\t\tServletResponseUtil.write(\n\t\t\t\trequest, response, fileName, ranges, inputStream, contentLength,\n\t\t\t\tcontentType);\n\t\t}\n\t}","commit_id":"662df131f01f35f99889aa77e2f68aa046a34579","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void sendFile(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPermissionChecker permissionChecker, String[] pathArray)\n\t\tthrows Exception {\n\n\t\tlong groupId = 0;\n\t\tlong folderId = 0;\n\t\tString name = null;\n\t\tString fileName = null;\n\n\t\tDLFileEntry fileEntry = null;\n\n\t\tif (pathArray.length == 1) {\n\t\t\tlong fileShortcutId = GetterUtil.getLong(pathArray[0]);\n\n\t\t\tDLFileShortcut fileShortcut =\n\t\t\t\tDLFileShortcutServiceUtil.getFileShortcut(fileShortcutId);\n\n\t\t\tgroupId = fileShortcut.getGroupId();\n\t\t\tfolderId = fileShortcut.getToFolderId();\n\t\t\tname = fileShortcut.getToName();\n\n\t\t\tfileEntry = DLFileEntryLocalServiceUtil.getFileEntry(\n\t\t\t\tgroupId, folderId, name);\n\n\t\t\tfileName = fileEntry.getTitle();\n\t\t}\n\t\telse if (pathArray.length == 2) {\n\t\t\tgroupId = GetterUtil.getLong(pathArray[0]);\n\n\t\t\tfileEntry =\n\t\t\t\tDLFileEntryLocalServiceUtil.getFileEntryByUuidAndGroupId(\n\t\t\t\t\tpathArray[1], groupId);\n\n\t\t\tfolderId = fileEntry.getFolderId();\n\t\t\tfileName = fileEntry.getTitle();\n\t\t\tname = fileEntry.getName();\n\t\t}\n\t\telse {\n\t\t\tgroupId = GetterUtil.getLong(pathArray[0]);\n\t\t\tfolderId = GetterUtil.getLong(pathArray[1]);\n\t\t\tfileName = HttpUtil.decodeURL(pathArray[2], true);\n\n\t\t\tfileEntry = DLFileEntryServiceUtil.getFileEntryByTitle(\n\t\t\t\tgroupId, folderId, fileName);\n\n\t\t\tname = fileEntry.getName();\n\t\t}\n\n\t\tif (fileEntry == null) {\n\t\t\tthrow new NoSuchFileEntryException();\n\t\t}\n\n\t\tDLFileEntryPermission.check(\n\t\t\tpermissionChecker, fileEntry, ActionKeys.VIEW);\n\n\t\tdouble version = ParamUtil.getDouble(request, \"version\");\n\n\t\tString targetExtension = ParamUtil.getString(\n\t\t\trequest, \"targetExtension\");\n\n\t\tif (version == 0) {\n\t\t\tif (fileEntry.getVersion() > 0) {\n\t\t\t\tversion = fileEntry.getVersion();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new NoSuchFileEntryException();\n\t\t\t}\n\t\t}\n\n\t\tInputStream is = null;\n\n\t\ttry {\n\t\t\tis = DLFileEntryLocalServiceUtil.getFileAsStream(\n\t\t\t\tpermissionChecker.getCompanyId(), permissionChecker.getUserId(),\n\t\t\t\tgroupId, folderId, name, version);\n\n\t\t\tboolean converted = false;\n\n\t\t\tif (Validator.isNotNull(targetExtension)) {\n\t\t\t\tString id = DocumentConversionUtil.getTempFileId(\n\t\t\t\t\tfileEntry.getFileEntryId(), version);\n\n\t\t\t\tString sourceExtension = FileUtil.getExtension(fileName);\n\n\t\t\t\tInputStream convertedIS = DocumentConversionUtil.convert(\n\t\t\t\t\tid, is, sourceExtension, targetExtension);\n\n\t\t\t\tif ((convertedIS != null) && (convertedIS != is)) {\n\t\t\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\t\t\tsb.append(FileUtil.stripExtension(fileName));\n\t\t\t\t\tsb.append(StringPool.PERIOD);\n\t\t\t\t\tsb.append(targetExtension);\n\n\t\t\t\t\tfileName = sb.toString();\n\n\t\t\t\t\tis = convertedIS;\n\n\t\t\t\t\tconverted = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint contentLength = 0;\n\n\t\t\tif (!converted) {\n\t\t\t\tif (version >= fileEntry.getVersion()) {\n\t\t\t\t\tcontentLength = fileEntry.getSize();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tDLFileVersion fileVersion =\n\t\t\t\t\t\tDLFileVersionLocalServiceUtil.getFileVersion(\n\t\t\t\t\t\t\tgroupId, folderId, name, version);\n\n\t\t\t\t\tcontentLength = fileVersion.getSize();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString contentType = MimeTypesUtil.getContentType(fileName);\n\n\t\t\tServletResponseUtil.sendFile(\n\t\t\t\tresponse, fileName, is, contentLength, contentType);\n\t\t}\n\t\tfinally {\n\t\t\tServletResponseUtil.cleanUp(is);\n\t\t}\n\t}","id":44626,"modified_method":"protected void sendFile(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tPermissionChecker permissionChecker, String[] pathArray)\n\t\tthrows Exception {\n\n\t\tlong groupId = 0;\n\t\tlong folderId = 0;\n\t\tString name = null;\n\t\tString fileName = null;\n\n\t\tDLFileEntry fileEntry = null;\n\n\t\tif (pathArray.length == 1) {\n\t\t\tlong fileShortcutId = GetterUtil.getLong(pathArray[0]);\n\n\t\t\tDLFileShortcut fileShortcut =\n\t\t\t\tDLFileShortcutServiceUtil.getFileShortcut(fileShortcutId);\n\n\t\t\tgroupId = fileShortcut.getGroupId();\n\t\t\tfolderId = fileShortcut.getToFolderId();\n\t\t\tname = fileShortcut.getToName();\n\n\t\t\tfileEntry = DLFileEntryLocalServiceUtil.getFileEntry(\n\t\t\t\tgroupId, folderId, name);\n\n\t\t\tfileName = fileEntry.getTitle();\n\t\t}\n\t\telse if (pathArray.length == 2) {\n\t\t\tgroupId = GetterUtil.getLong(pathArray[0]);\n\n\t\t\tfileEntry =\n\t\t\t\tDLFileEntryLocalServiceUtil.getFileEntryByUuidAndGroupId(\n\t\t\t\t\tpathArray[1], groupId);\n\n\t\t\tfolderId = fileEntry.getFolderId();\n\t\t\tfileName = fileEntry.getTitle();\n\t\t\tname = fileEntry.getName();\n\t\t}\n\t\telse {\n\t\t\tgroupId = GetterUtil.getLong(pathArray[0]);\n\t\t\tfolderId = GetterUtil.getLong(pathArray[1]);\n\t\t\tfileName = HttpUtil.decodeURL(pathArray[2], true);\n\n\t\t\tfileEntry = DLFileEntryServiceUtil.getFileEntryByTitle(\n\t\t\t\tgroupId, folderId, fileName);\n\n\t\t\tname = fileEntry.getName();\n\t\t}\n\n\t\tif (fileEntry == null) {\n\t\t\tthrow new NoSuchFileEntryException();\n\t\t}\n\n\t\tDLFileEntryPermission.check(\n\t\t\tpermissionChecker, fileEntry, ActionKeys.VIEW);\n\n\t\tdouble version = ParamUtil.getDouble(request, \"version\");\n\n\t\tString targetExtension = ParamUtil.getString(\n\t\t\trequest, \"targetExtension\");\n\n\t\tif (version == 0) {\n\t\t\tif (fileEntry.getVersion() > 0) {\n\t\t\t\tversion = fileEntry.getVersion();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new NoSuchFileEntryException();\n\t\t\t}\n\t\t}\n\n\t\tInputStream is = DLFileEntryLocalServiceUtil.getFileAsStream(\n\t\t\tpermissionChecker.getCompanyId(), permissionChecker.getUserId(),\n\t\t\tgroupId, folderId, name, version);\n\n\t\tboolean converted = false;\n\n\t\tif (Validator.isNotNull(targetExtension)) {\n\t\t\tString id = DocumentConversionUtil.getTempFileId(\n\t\t\t\tfileEntry.getFileEntryId(), version);\n\n\t\t\tString sourceExtension = FileUtil.getExtension(fileName);\n\n\t\t\tInputStream convertedIS = DocumentConversionUtil.convert(\n\t\t\t\tid, is, sourceExtension, targetExtension);\n\n\t\t\tif ((convertedIS != null) && (convertedIS != is)) {\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\t\tsb.append(FileUtil.stripExtension(fileName));\n\t\t\t\tsb.append(StringPool.PERIOD);\n\t\t\t\tsb.append(targetExtension);\n\n\t\t\t\tfileName = sb.toString();\n\n\t\t\t\tis = convertedIS;\n\n\t\t\t\tconverted = true;\n\t\t\t}\n\t\t}\n\n\t\tint contentLength = 0;\n\n\t\tif (!converted) {\n\t\t\tif (version >= fileEntry.getVersion()) {\n\t\t\t\tcontentLength = fileEntry.getSize();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tDLFileVersion fileVersion =\n\t\t\t\t\tDLFileVersionLocalServiceUtil.getFileVersion(\n\t\t\t\t\t\tgroupId, folderId, name, version);\n\n\t\t\t\tcontentLength = fileVersion.getSize();\n\t\t\t}\n\t\t}\n\n\t\tString contentType = MimeTypesUtil.getContentType(fileName);\n\n\t\tServletResponseUtil.sendFile(\n\t\t\tresponse, fileName, is, contentLength, contentType);\n\t}","commit_id":"b328b7dd34962d1846ea1bb660336d9465463da6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void getFile(\n\t\t\tlong fileEntryId, long folderId, String name, String title,\n\t\t\tString version, long fileShortcutId, String uuid, long groupId,\n\t\t\tString targetExtension, HttpServletRequest request,\n\t\t\tHttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tif (name.startsWith(\"DLFE-\")) {\n\t\t\tname = name.substring(5);\n\t\t}\n\n\t\tname = FileUtil.stripExtension(name);\n\n\t\tFileEntry fileEntry = null;\n\n\t\tif (Validator.isNotNull(uuid) && (groupId > 0)) {\n\t\t\tfileEntry = DLAppServiceUtil.getFileEntryByUuidAndGroupId(\n\t\t\t\tuuid, groupId);\n\n\t\t\tfolderId = fileEntry.getFolderId();\n\t\t}\n\n\t\tif (fileEntryId > 0) {\n\t\t\tfileEntry = DLAppServiceUtil.getFileEntry(fileEntryId);\n\t\t}\n\t\telse if (fileShortcutId <= 0) {\n\t\t\tif (Validator.isNotNull(title)) {\n\t\t\t\tfileEntry = DLAppServiceUtil.getFileEntry(\n\t\t\t\t\tgroupId, folderId, title);\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(name)) {\n\t\t\t\tDLFileEntry dlFileEntry =\n\t\t\t\t\tDLFileEntryLocalServiceUtil.fetchFileEntryByName(\n\t\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\t\tif (dlFileEntry == null) {\n\n\t\t\t\t\t// LPS-30374\n\n\t\t\t\t\tList<DLFileEntry> dlFileEntries =\n\t\t\t\t\t\tDLFileEntryLocalServiceUtil.getFileEntries(\n\t\t\t\t\t\t\tfolderId, name);\n\n\t\t\t\t\tif (!dlFileEntries.isEmpty()) {\n\t\t\t\t\t\tdlFileEntry = dlFileEntries.get(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dlFileEntry != null) {\n\t\t\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t\t\t(ThemeDisplay)request.getAttribute(\n\t\t\t\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\t\t\tPermissionChecker permissionChecker =\n\t\t\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\t\t\tDLFileEntryPermission.check(\n\t\t\t\t\t\tpermissionChecker, dlFileEntry, ActionKeys.VIEW);\n\n\t\t\t\t\tfileEntry = new LiferayFileEntry(dlFileEntry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tDLFileShortcut fileShortcut = DLAppServiceUtil.getFileShortcut(\n\t\t\t\tfileShortcutId);\n\n\t\t\tfileEntryId = fileShortcut.getToFileEntryId();\n\n\t\t\tfileEntry = DLAppServiceUtil.getFileEntry(fileEntryId);\n\t\t}\n\n\t\tif (Validator.isNull(version)) {\n\t\t\tif ((fileEntry != null) &&\n\t\t\t\tValidator.isNotNull(fileEntry.getVersion())) {\n\n\t\t\t\tversion = fileEntry.getVersion();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new NoSuchFileEntryException(\n\t\t\t\t\t\"{fileEntryId=\" + fileEntryId + \"}\");\n\t\t\t}\n\t\t}\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion(version);\n\n\t\tInputStream is = fileVersion.getContentStream(true);\n\n\t\tString fileName = fileVersion.getTitle();\n\n\t\tString sourceExtension = fileVersion.getExtension();\n\n\t\tif (Validator.isNotNull(sourceExtension) &&\n\t\t\t!fileName.endsWith(StringPool.PERIOD + sourceExtension)) {\n\n\t\t\tfileName += StringPool.PERIOD + sourceExtension;\n\t\t}\n\n\t\tlong contentLength = fileVersion.getSize();\n\t\tString contentType = fileVersion.getMimeType();\n\n\t\tif (Validator.isNotNull(targetExtension)) {\n\t\t\tString id = DLUtil.getTempFileId(\n\t\t\t\tfileEntry.getFileEntryId(), version);\n\n\t\t\tFile convertedFile = DocumentConversionUtil.convert(\n\t\t\t\tid, is, sourceExtension, targetExtension);\n\n\t\t\tif (convertedFile != null) {\n\t\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\t\tStringPool.PERIOD).concat(targetExtension);\n\t\t\t\tis = new FileInputStream(convertedFile);\n\t\t\t\tcontentLength = convertedFile.length();\n\t\t\t\tcontentType = MimeTypesUtil.getContentType(fileName);\n\t\t\t}\n\t\t}\n\n\t\tServletResponseUtil.sendFile(\n\t\t\trequest, response, fileName, is, contentLength, contentType);\n\t}","id":44627,"modified_method":"protected void getFile(\n\t\t\tlong fileEntryId, long folderId, String name, String title,\n\t\t\tString version, long fileShortcutId, String uuid, long groupId,\n\t\t\tString targetExtension, HttpServletRequest request,\n\t\t\tHttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tif (name.startsWith(\"DLFE-\")) {\n\t\t\tname = name.substring(5);\n\t\t}\n\n\t\tname = FileUtil.stripExtension(name);\n\n\t\tFileEntry fileEntry = null;\n\n\t\tif (Validator.isNotNull(uuid) && (groupId > 0)) {\n\t\t\tfileEntry = DLAppServiceUtil.getFileEntryByUuidAndGroupId(\n\t\t\t\tuuid, groupId);\n\n\t\t\tfolderId = fileEntry.getFolderId();\n\t\t}\n\n\t\tif (fileEntryId > 0) {\n\t\t\tfileEntry = DLAppServiceUtil.getFileEntry(fileEntryId);\n\t\t}\n\t\telse if (fileShortcutId <= 0) {\n\t\t\tif (Validator.isNotNull(title)) {\n\t\t\t\tfileEntry = DLAppServiceUtil.getFileEntry(\n\t\t\t\t\tgroupId, folderId, title);\n\t\t\t}\n\t\t\telse if (Validator.isNotNull(name)) {\n\t\t\t\tDLFileEntry dlFileEntry =\n\t\t\t\t\tDLFileEntryLocalServiceUtil.fetchFileEntryByName(\n\t\t\t\t\t\tgroupId, folderId, name);\n\n\t\t\t\tif (dlFileEntry == null) {\n\n\t\t\t\t\t// LPS-30374\n\n\t\t\t\t\tList<DLFileEntry> dlFileEntries =\n\t\t\t\t\t\tDLFileEntryLocalServiceUtil.getFileEntries(\n\t\t\t\t\t\t\tfolderId, name);\n\n\t\t\t\t\tif (!dlFileEntries.isEmpty()) {\n\t\t\t\t\t\tdlFileEntry = dlFileEntries.get(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (dlFileEntry != null) {\n\t\t\t\t\tThemeDisplay themeDisplay =\n\t\t\t\t\t\t(ThemeDisplay)request.getAttribute(\n\t\t\t\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\t\t\tPermissionChecker permissionChecker =\n\t\t\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\t\t\tDLFileEntryPermission.check(\n\t\t\t\t\t\tpermissionChecker, dlFileEntry, ActionKeys.VIEW);\n\n\t\t\t\t\tfileEntry = new LiferayFileEntry(dlFileEntry);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tDLFileShortcut fileShortcut = DLAppServiceUtil.getFileShortcut(\n\t\t\t\tfileShortcutId);\n\n\t\t\tfileEntryId = fileShortcut.getToFileEntryId();\n\n\t\t\tfileEntry = DLAppServiceUtil.getFileEntry(fileEntryId);\n\t\t}\n\n\t\tif (Validator.isNull(version)) {\n\t\t\tif ((fileEntry != null) &&\n\t\t\t\tValidator.isNotNull(fileEntry.getVersion())) {\n\n\t\t\t\tversion = fileEntry.getVersion();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new NoSuchFileEntryException(\n\t\t\t\t\t\"{fileEntryId=\" + fileEntryId + \"}\");\n\t\t\t}\n\t\t}\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion(version);\n\n\t\tInputStream is = fileVersion.getContentStream(true);\n\n\t\tString fileName = fileVersion.getTitle();\n\n\t\tString sourceExtension = fileVersion.getExtension();\n\n\t\tif (Validator.isNotNull(sourceExtension) &&\n\t\t\t!fileName.endsWith(StringPool.PERIOD + sourceExtension)) {\n\n\t\t\tfileName += StringPool.PERIOD + sourceExtension;\n\t\t}\n\n\t\tlong contentLength = fileVersion.getSize();\n\t\tString contentType = fileVersion.getMimeType();\n\n\t\tif (Validator.isNotNull(targetExtension)) {\n\t\t\tString id = DLUtil.getTempFileId(\n\t\t\t\tfileEntry.getFileEntryId(), version);\n\n\t\t\tFile convertedFile = DocumentConversionUtil.convert(\n\t\t\t\tid, is, sourceExtension, targetExtension);\n\n\t\t\tif (convertedFile != null) {\n\t\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\t\tStringPool.PERIOD).concat(targetExtension);\n\t\t\t\tis = new FileInputStream(convertedFile);\n\t\t\t\tcontentLength = convertedFile.length();\n\t\t\t\tcontentType = MimeTypesUtil.getContentType(fileName);\n\t\t\t}\n\t\t}\n\n\t\tFlashMagicBytesUtil.Result flashMagicBytesUtilResult =\n\t\t\tFlashMagicBytesUtil.check(is);\n\n\t\tis = flashMagicBytesUtilResult.getInputStream();\n\n\t\tif (flashMagicBytesUtilResult.isFlash()) {\n\t\t\tfileName = FileUtil.stripExtension(fileName) + \".swf\";\n\t\t}\n\n\t\tServletResponseUtil.sendFile(\n\t\t\trequest, response, fileName, is, contentLength, contentType);\n\t}","commit_id":"7a804f1ed65aef25e73a84ee90ba3ae248073295","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int process(WebDAVRequest webDAVRequest) throws WebDAVException {\n\t\tInputStream is = null;\n\n\t\ttry {\n\t\t\tWebDAVStorage storage = webDAVRequest.getWebDAVStorage();\n\t\t\tHttpServletRequest request = webDAVRequest.getHttpServletRequest();\n\t\t\tHttpServletResponse response =\n\t\t\t\twebDAVRequest.getHttpServletResponse();\n\n\t\t\tResource resource = storage.getResource(webDAVRequest);\n\n\t\t\tif (resource == null) {\n\t\t\t\treturn HttpServletResponse.SC_NOT_FOUND;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tis = resource.getContentAsStream();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t_log.error(e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is != null) {\n\t\t\t\ttry {\n\t\t\t\t\tServletResponseUtil.sendFile(\n\t\t\t\t\t\trequest, response, resource.getDisplayName(), is,\n\t\t\t\t\t\tresource.getSize(), resource.getContentType());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn HttpServletResponse.SC_OK;\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_NOT_FOUND;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","id":44628,"modified_method":"@Override\n\tpublic int process(WebDAVRequest webDAVRequest) throws WebDAVException {\n\t\tInputStream is = null;\n\n\t\ttry {\n\t\t\tWebDAVStorage storage = webDAVRequest.getWebDAVStorage();\n\t\t\tHttpServletRequest request = webDAVRequest.getHttpServletRequest();\n\t\t\tHttpServletResponse response =\n\t\t\t\twebDAVRequest.getHttpServletResponse();\n\n\t\t\tResource resource = storage.getResource(webDAVRequest);\n\n\t\t\tif (resource == null) {\n\t\t\t\treturn HttpServletResponse.SC_NOT_FOUND;\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tis = resource.getContentAsStream();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t_log.error(e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is != null) {\n\t\t\t\tFlashMagicBytesUtil.Result flashMagicBytesUtilResult =\n\t\t\t\t\tFlashMagicBytesUtil.check(is);\n\n\t\t\t\tis = flashMagicBytesUtilResult.getInputStream();\n\n\t\t\t\tString fileName = resource.getDisplayName();\n\n\t\t\t\tif (flashMagicBytesUtilResult.isFlash()) {\n\t\t\t\t\tfileName = FileUtil.stripExtension(fileName) + \".swf\";\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tServletResponseUtil.sendFile(\n\t\t\t\t\t\trequest, response, fileName, is, resource.getSize(),\n\t\t\t\t\t\tresource.getContentType());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t\t_log.warn(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn HttpServletResponse.SC_OK;\n\t\t\t}\n\n\t\t\treturn HttpServletResponse.SC_NOT_FOUND;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new WebDAVException(e);\n\t\t}\n\t}","commit_id":"7a804f1ed65aef25e73a84ee90ba3ae248073295","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void getFile(\n\t\t\tlong nodeId, String title, String fileName, int status,\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tWikiPage wikiPage = WikiPageServiceUtil.getPage(nodeId, title);\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\twikiPage.getGroupId(), wikiPage.getAttachmentsFolderId(), fileName);\n\n\t\tDLFileEntry dlFileEntry = (DLFileEntry)fileEntry.getModel();\n\n\t\tif ((status != WorkflowConstants.STATUS_IN_TRASH) &&\n\t\t\tdlFileEntry.isInTrash()) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (dlFileEntry.isInTrash()) {\n\t\t\tfileName = TrashUtil.getOriginalTitle(dlFileEntry.getTitle());\n\t\t}\n\n\t\tServletResponseUtil.sendFile(\n\t\t\trequest, response, fileName, fileEntry.getContentStream(),\n\t\t\tfileEntry.getSize(), fileEntry.getMimeType());\n\t}","id":44629,"modified_method":"protected void getFile(\n\t\t\tlong nodeId, String title, String fileName, int status,\n\t\t\tHttpServletRequest request, HttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tWikiPage wikiPage = WikiPageServiceUtil.getPage(nodeId, title);\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\twikiPage.getGroupId(), wikiPage.getAttachmentsFolderId(), fileName);\n\n\t\tDLFileEntry dlFileEntry = (DLFileEntry)fileEntry.getModel();\n\n\t\tif ((status != WorkflowConstants.STATUS_IN_TRASH) &&\n\t\t\tdlFileEntry.isInTrash()) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (dlFileEntry.isInTrash()) {\n\t\t\tfileName = TrashUtil.getOriginalTitle(dlFileEntry.getTitle());\n\t\t}\n\n\t\tInputStream is = fileEntry.getContentStream();\n\n\t\tFlashMagicBytesUtil.Result flashMagicBytesUtilResult =\n\t\t\tFlashMagicBytesUtil.check(is);\n\n\t\tis = flashMagicBytesUtilResult.getInputStream();\n\n\t\tif (flashMagicBytesUtilResult.isFlash()) {\n\t\t\tfileName = FileUtil.stripExtension(fileName) + \".swf\";\n\t\t}\n\n\t\tServletResponseUtil.sendFile(\n\t\t\trequest, response, fileName, is, fileEntry.getSize(),\n\t\t\tfileEntry.getMimeType());\n\t}","commit_id":"7a804f1ed65aef25e73a84ee90ba3ae248073295","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void sendPortletFileEntry(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tString[] pathArray)\n\t\tthrows Exception {\n\n\t\tFileEntry fileEntry = getPortletFileEntry(request, pathArray);\n\n\t\tif (fileEntry == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString fileName = HttpUtil.decodeURL(HtmlUtil.escape(pathArray[2]));\n\n\t\tif (fileEntry.isInTrash()) {\n\t\t\tfileName = TrashUtil.getOriginalTitle(fileName);\n\t\t}\n\n\t\tboolean download = ParamUtil.getBoolean(request, \"download\");\n\n\t\tif (download) {\n\t\t\tServletResponseUtil.sendFile(\n\t\t\t\trequest, response, fileName, fileEntry.getContentStream(),\n\t\t\t\tfileEntry.getSize(), fileEntry.getMimeType(),\n\t\t\t\tHttpHeaders.CONTENT_DISPOSITION_ATTACHMENT);\n\t\t}\n\t\telse {\n\t\t\tServletResponseUtil.sendFile(\n\t\t\t\trequest, response, fileName, fileEntry.getContentStream(),\n\t\t\t\tfileEntry.getSize(), fileEntry.getMimeType());\n\t\t}\n\t}","id":44630,"modified_method":"protected void sendPortletFileEntry(\n\t\t\tHttpServletRequest request, HttpServletResponse response,\n\t\t\tString[] pathArray)\n\t\tthrows Exception {\n\n\t\tFileEntry fileEntry = getPortletFileEntry(request, pathArray);\n\n\t\tif (fileEntry == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString fileName = HttpUtil.decodeURL(HtmlUtil.escape(pathArray[2]));\n\n\t\tif (fileEntry.isInTrash()) {\n\t\t\tfileName = TrashUtil.getOriginalTitle(fileName);\n\t\t}\n\n\t\tboolean download = ParamUtil.getBoolean(request, \"download\");\n\n\t\tif (download) {\n\t\t\tServletResponseUtil.sendFile(\n\t\t\t\trequest, response, fileName, fileEntry.getContentStream(),\n\t\t\t\tfileEntry.getSize(), fileEntry.getMimeType(),\n\t\t\t\tHttpHeaders.CONTENT_DISPOSITION_ATTACHMENT);\n\t\t}\n\t\telse {\n\t\t\tInputStream is = fileEntry.getContentStream();\n\n\t\t\tFlashMagicBytesUtil.Result flashMagicBytesUtilResult =\n\t\t\t\tFlashMagicBytesUtil.check(is);\n\n\t\t\tis = flashMagicBytesUtilResult.getInputStream();\n\n\t\t\tif (flashMagicBytesUtilResult.isFlash()) {\n\t\t\t\tfileName = FileUtil.stripExtension(fileName) + \".swf\";\n\t\t\t}\n\n\t\t\tServletResponseUtil.sendFile(\n\t\t\t\trequest, response, fileName, is, fileEntry.getSize(),\n\t\t\t\tfileEntry.getMimeType());\n\t\t}\n\t}","commit_id":"7a804f1ed65aef25e73a84ee90ba3ae248073295","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addRedirects (ModuleOutputPaths moduleOutputPaths, String outputRoot, String cachesOutputRoot, boolean useTransientOutputFolder) {\n      myOutputRedirects.add(new OutputPathRedirects(moduleOutputPaths, outputRoot, cachesOutputRoot, useTransientOutputFolder));\n    }","id":44631,"modified_method":"public OutputPathRedirects addRedirects (ModuleOutputPaths moduleOutputPaths, String outputRoot, String cachesOutputRoot, boolean useTransientOutputFolder) {\n      OutputPathRedirects redirects = new OutputPathRedirects(moduleOutputPaths, outputRoot, cachesOutputRoot, useTransientOutputFolder);\n      myOutputRedirects.add(redirects);\n      return redirects;\n    }","commit_id":"f600b6c3b871f1d0e453801f53892dea0cc1bee0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean build() {\n    ProjectOperationContext context = new ProjectOperationContext(myProject);\n    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());\n\n    final Iterable<IMResource> resources = Sequence.fromIterable(collectResources(context, myToMake.keySet())).toListSequence();\n    ISequence<IModule> mpsModules = Sequence.fromIterable(resources).select(new ISelector<IMResource, IModule>() {\n      public IModule select(IMResource r) {\n        return r.module();\n      }\n    });\n    ModuleOutputPaths outputPaths = new ModuleOutputPaths(mpsModules);\n    myForeignRootPaths = new MyForeignRootPaths(outputPaths.getOutputPaths());\n\n    myRedirects = new MyRedirects();\n    Set<ModuleBuildTarget> processed = new HashSet<ModuleBuildTarget>();\n    for (ModuleBuildTarget target : myToMake.values()) {\n      if (processed.contains(target)) continue;\n      processed.add(target);\n\n      JpsMPSModuleExtension mpsModule = JpsMPSExtensionService.getInstance().getExtension(target.getModule());\n      if (mpsModule == null) continue;\n\n      File outputRoot = getOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      File cachesOutputRoot = getCachesOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      myRedirects.addRedirects(outputPaths, outputRoot.getAbsolutePath(), cachesOutputRoot.getAbsolutePath(), mpsModule.getConfiguration().isUseTransientOutputFolder());\n    }\n\n\n    GenerationDependenciesCache.getInstance().registerCachePathRedirect(new GenerationDependenciesCache.CachePathRedirect() {\n      public IFile redirectTo(IFile outputPath) {\n        return myRedirects.getRedirect(outputPath.getPath());\n      }\n    });\n    GeneratorPathsComponent.getInstance().registerForeignPathsProvider(new ForeignPathsProvider() {\n      public String belongsToForeignPath(IFile path) {\n        return (myForeignRootPaths != null ?\n          myForeignRootPaths.findForeignPrefix(path.getPath()) :\n          null\n        );\n      }\n    });\n\n    Future<IResult> res;\n\n    BuildMakeService bms = new BuildMakeService();\n    MakeSession ms = new MakeSession(context, myMessageHandler, true) {\n      @Override\n      public IScript toScript(ScriptBuilder scriptBuilder) {\n        scriptBuilder.withFacetNames(\n          new IFacet.Name(\"jetbrains.mps.build.reduced.ReportFiles\"),\n          new IFacet.Name(\"jetbrains.mps.build.reduced.CollectHashes\"));\n        return scriptBuilder.toScript();\n      }\n    };\n\n    ReducedMakeFacetConfiguration makeFacetConfiguration = new ReducedMakeFacetConfiguration(\n      myRedirects, !myContext.getCompileContext().isMake(), new Stub(), new IJobMonitor.Stub());\n    IScriptController scriptCtl = makeFacetConfiguration.configureFacets();\n    boolean success;\n\n    try {\n      res = bms.make(ms, resources, null, scriptCtl);\n      success = res.get().isSucessful();\n\n      success = processFiles(success, makeFacetConfiguration);\n\n      final Map<String, String> fileHashes = makeFacetConfiguration.getFileHashes();\n      // TODO do something with these\n\n    } catch (InterruptedException e) {\n      reportError(e);\n      success = false;\n    } catch (ExecutionException e) {\n      reportError(e);\n      success = false;\n    }\n\n    return success;\n  }","id":44632,"modified_method":"public boolean build() {\n    ProjectOperationContext context = new ProjectOperationContext(myProject);\n    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());\n\n    final Iterable<IMResource> resources = Sequence.fromIterable(collectResources(context, myToMake.keySet())).toListSequence();\n    ISequence<IModule> mpsModules = Sequence.fromIterable(resources).select(new ISelector<IMResource, IModule>() {\n      public IModule select(IMResource r) {\n        return r.module();\n      }\n    });\n    ModuleOutputPaths outputPaths = new ModuleOutputPaths(mpsModules);\n    myForeignRootPaths = new MyForeignRootPaths(outputPaths.getOutputPaths());\n\n    myRedirects = new MyRedirects();\n    Set<ModuleBuildTarget> processed = new HashSet<ModuleBuildTarget>();\n    for (ModuleBuildTarget target : myToMake.values()) {\n      if (processed.contains(target)) continue;\n      processed.add(target);\n\n      JpsMPSModuleExtension mpsModule = JpsMPSExtensionService.getInstance().getExtension(target.getModule());\n      if (mpsModule == null) continue;\n\n      File outputRoot = getOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      File cachesOutputRoot = getCachesOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      boolean useTransientOutputFolder = mpsModule.getConfiguration().isUseTransientOutputFolder();\n      OutputPathRedirects redirects = myRedirects.addRedirects(outputPaths, outputRoot.getAbsolutePath(), cachesOutputRoot.getAbsolutePath(), useTransientOutputFolder);\n      if (useTransientOutputFolder) {\n        BuildRootIndex buildRootIndex = myContext.getCompileContext().getProjectDescriptor().getBuildRootIndex();\n        buildRootIndex.associateTempRoot(myContext.getCompileContext(), target,\n          new JavaSourceRootDescriptor(outputRoot, target, true, true, \"\", Collections.<File>emptySet()));\n      }\n    }\n\n    GenerationDependenciesCache.getInstance().registerCachePathRedirect(new GenerationDependenciesCache.CachePathRedirect() {\n      public IFile redirectTo(IFile outputPath) {\n        return myRedirects.getRedirect(outputPath.getPath());\n      }\n    });\n    GeneratorPathsComponent.getInstance().registerForeignPathsProvider(new ForeignPathsProvider() {\n      public String belongsToForeignPath(IFile path) {\n        return (myForeignRootPaths != null ?\n          myForeignRootPaths.findForeignPrefix(path.getPath()) :\n          null\n        );\n      }\n    });\n\n    Future<IResult> res;\n\n    BuildMakeService bms = new BuildMakeService();\n    MakeSession ms = new MakeSession(context, myMessageHandler, true) {\n      @Override\n      public IScript toScript(ScriptBuilder scriptBuilder) {\n        scriptBuilder.withFacetNames(\n          new IFacet.Name(\"jetbrains.mps.build.reduced.ReportFiles\"),\n          new IFacet.Name(\"jetbrains.mps.build.reduced.CollectHashes\"));\n        return scriptBuilder.toScript();\n      }\n    };\n\n    ReducedMakeFacetConfiguration makeFacetConfiguration = new ReducedMakeFacetConfiguration(\n      myRedirects, !myContext.getCompileContext().isMake(), new Stub(), new IJobMonitor.Stub());\n    IScriptController scriptCtl = makeFacetConfiguration.configureFacets();\n    boolean success;\n\n    try {\n      res = bms.make(ms, resources, null, scriptCtl);\n      success = res.get().isSucessful();\n\n      success = processFiles(success, makeFacetConfiguration);\n\n      final Map<String, String> fileHashes = makeFacetConfiguration.getFileHashes();\n      // TODO do something with these\n\n    } catch (InterruptedException e) {\n      reportError(e);\n      success = false;\n    } catch (ExecutionException e) {\n      reportError(e);\n      success = false;\n    }\n\n    return success;\n  }","commit_id":"f600b6c3b871f1d0e453801f53892dea0cc1bee0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void testBuild_blProject () {\n    String models = PathUtil.getParentPath(copyFromUserDirToProject(\"tests/blProject/models/main.mps\", \"models/main.mps\"));\n    String srcgen = PathUtil.getParentPath(createFile(\"source_gen/empty.txt\", \"\"));\n    JpsModule main = addModule(\"main\", models, srcgen);\n\n    MPSConfigurationBean configuration = new MPSConfigurationBean();\n    configuration.setGeneratorOutputPath(srcgen);\n    configuration.setUsedLanguages(\n      new String[] {\"f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)\",\n                    \"f61473f9-130f-42f6-b98d-6c438812c2f6(jetbrains.mps.baseLanguage.unitTest)\"});\n\n    DefaultModelRoot dmr = new DefaultModelRoot();\n    dmr.setContentRoot(models);\n    dmr.addFile(DefaultModelRoot.SOURCE_ROOTS, models);\n\n    configuration.setModelRoots(Arrays.<ModelRoot>asList(dmr));\n\n    JpsMPSExtensionService.getInstance().setExtension(main, new JpsMPSModuleExtensionImpl(configuration));\n    buildParams.put(MPSMakeConstants.MPS_LANGUAGES.toString(), getLanguageLocations());\n\n    rebuildAll();\n  }","id":44633,"modified_method":"public void testBuild_blProject () {\n    String models = PathUtil.getParentPath(copyFromUserDirToProject(\"tests/blProject/models/main.mps\", \"models/main.mps\"));\n    String srcgen = PathUtil.getParentPath(createFile(\"source_gen/empty.txt\", \"\"));\n    JpsModule main = addModule(\"main\", models, srcgen);\n\n    MPSConfigurationBean configuration = createConfiguration(srcgen);\n\n    DefaultModelRoot dmr = createModelRoot(models);\n    configuration.setModelRoots(Arrays.<ModelRoot>asList(dmr));\n\n    JpsMPSExtensionService.getInstance().setExtension(main, new JpsMPSModuleExtensionImpl(configuration));\n    buildParams.put(MPSMakeConstants.MPS_LANGUAGES.toString(), getLanguageLocations());\n\n    rebuildAll();\n  }","commit_id":"f600b6c3b871f1d0e453801f53892dea0cc1bee0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private File getOutputRoot (JpsModule module, final BuildDataManager buildDataManager) {\n    File moduleDataRoot = getModuleDataRoot(module, buildDataManager.getDataPaths());\n    return new File(moduleDataRoot, MPSMakePaths.SOURCE_GEN);\n  }","id":44634,"modified_method":"private File getTmpOutputRoot(JpsModule module, final BuildDataManager buildDataManager) {\n    File moduleDataRoot = getModuleDataRoot(module, buildDataManager.getDataPaths());\n    return new File(moduleDataRoot, MPSMakePaths.SOURCE_GEN);\n  }","commit_id":"58ca2228350efa5e37bf979eb9393d4f1c49e96c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean build() {\n    ProjectOperationContext context = new ProjectOperationContext(myProject);\n    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());\n\n    final Iterable<IMResource> resources = Sequence.fromIterable(collectResources(context, myToMake.keySet())).toListSequence();\n    ISequence<IModule> mpsModules = Sequence.fromIterable(resources).select(new ISelector<IMResource, IModule>() {\n      public IModule select(IMResource r) {\n        return r.module();\n      }\n    });\n    ModuleOutputPaths outputPaths = new ModuleOutputPaths(mpsModules);\n    myForeignRootPaths = new MyForeignRootPaths(outputPaths.getOutputPaths());\n\n    myRedirects = new MyRedirects();\n    Set<ModuleBuildTarget> processed = new HashSet<ModuleBuildTarget>();\n    for (ModuleBuildTarget target : myToMake.values()) {\n      if (processed.contains(target)) continue;\n      processed.add(target);\n\n      JpsMPSModuleExtension mpsModule = JpsMPSExtensionService.getInstance().getExtension(target.getModule());\n      if (mpsModule == null) continue;\n\n      File outputRoot = getOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      File cachesOutputRoot = getCachesOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      boolean useTransientOutputFolder = mpsModule.getConfiguration().isUseTransientOutputFolder();\n      OutputPathRedirects redirects = myRedirects.addRedirects(outputPaths, outputRoot.getAbsolutePath(), cachesOutputRoot.getAbsolutePath(), useTransientOutputFolder);\n      if (useTransientOutputFolder) {\n        BuildRootIndex buildRootIndex = myContext.getCompileContext().getProjectDescriptor().getBuildRootIndex();\n        buildRootIndex.associateTempRoot(myContext.getCompileContext(), target,\n          new JavaSourceRootDescriptor(outputRoot, target, true, true, \"\", Collections.<File>emptySet()));\n      }\n    }\n\n    GenerationDependenciesCache.getInstance().registerCachePathRedirect(new GenerationDependenciesCache.CachePathRedirect() {\n      public IFile redirectTo(IFile outputPath) {\n        return myRedirects.getRedirect(outputPath.getPath());\n      }\n    });\n    GeneratorPathsComponent.getInstance().registerForeignPathsProvider(new ForeignPathsProvider() {\n      public String belongsToForeignPath(IFile path) {\n        return (myForeignRootPaths != null ?\n          myForeignRootPaths.findForeignPrefix(path.getPath()) :\n          null\n        );\n      }\n    });\n\n    Future<IResult> res;\n\n    BuildMakeService bms = new BuildMakeService();\n    MakeSession ms = new MakeSession(context, myMessageHandler, true) {\n      @Override\n      public IScript toScript(ScriptBuilder scriptBuilder) {\n        scriptBuilder.withFacetNames(\n          new IFacet.Name(\"jetbrains.mps.build.reduced.ReportFiles\"),\n          new IFacet.Name(\"jetbrains.mps.build.reduced.CollectHashes\"));\n        return scriptBuilder.toScript();\n      }\n    };\n\n    ReducedMakeFacetConfiguration makeFacetConfiguration = new ReducedMakeFacetConfiguration(\n      myRedirects, !myContext.getCompileContext().isMake(), new Stub(), new IJobMonitor.Stub());\n    IScriptController scriptCtl = makeFacetConfiguration.configureFacets();\n    boolean success;\n\n    try {\n      res = bms.make(ms, resources, null, scriptCtl);\n      success = res.get().isSucessful();\n\n      success = processFiles(success, makeFacetConfiguration);\n\n      final Map<String, String> fileHashes = makeFacetConfiguration.getFileHashes();\n      // TODO do something with these\n\n    } catch (InterruptedException e) {\n      reportError(e);\n      success = false;\n    } catch (ExecutionException e) {\n      reportError(e);\n      success = false;\n    }\n\n    return success;\n  }","id":44635,"modified_method":"public boolean build() {\n    ProjectOperationContext context = new ProjectOperationContext(myProject);\n    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());\n\n    final Iterable<IMResource> resources = Sequence.fromIterable(collectResources(context, myToMake.keySet())).toListSequence();\n    ISequence<IModule> mpsModules = Sequence.fromIterable(resources).select(new ISelector<IMResource, IModule>() {\n      public IModule select(IMResource r) {\n        return r.module();\n      }\n    });\n    ModuleOutputPaths outputPaths = new ModuleOutputPaths(mpsModules);\n    myForeignRootPaths = new MyForeignRootPaths(outputPaths.getOutputPaths());\n\n    myRedirects = new MyRedirects();\n    Set<ModuleBuildTarget> processed = new HashSet<ModuleBuildTarget>();\n    for (ModuleBuildTarget target : myToMake.values()) {\n      if (processed.contains(target)) continue;\n      processed.add(target);\n\n      JpsMPSModuleExtension mpsModule = JpsMPSExtensionService.getInstance().getExtension(target.getModule());\n      if (mpsModule == null) continue;\n\n      File outputTmpRoot = getTmpOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      File cachesOutputRoot = getCachesOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      boolean useTransientOutputFolder = mpsModule.getConfiguration().isUseTransientOutputFolder();\n      File generatorOutputRoot = new File (mpsModule.getConfiguration().getGeneratorOutputPath());\n      myRedirects.addRedirects(outputPaths, outputTmpRoot.getAbsolutePath(), cachesOutputRoot.getAbsolutePath(), useTransientOutputFolder);\n\n      if (useTransientOutputFolder || !isGenOutputUnderSourceRoot(target, mpsModule)) {\n        BuildRootIndex buildRootIndex = myContext.getCompileContext().getProjectDescriptor().getBuildRootIndex();\n        File outputRoot = useTransientOutputFolder ? outputTmpRoot : generatorOutputRoot;\n        buildRootIndex.associateTempRoot(myContext.getCompileContext(), target,\n          new JavaSourceRootDescriptor(outputRoot, target, true, true, \"\", Collections.<File>emptySet()));\n      }\n    }\n\n    GenerationDependenciesCache.getInstance().registerCachePathRedirect(new GenerationDependenciesCache.CachePathRedirect() {\n      public IFile redirectTo(IFile outputPath) {\n        return myRedirects.getRedirect(outputPath.getPath());\n      }\n    });\n    GeneratorPathsComponent.getInstance().registerForeignPathsProvider(new ForeignPathsProvider() {\n      public String belongsToForeignPath(IFile path) {\n        return (myForeignRootPaths != null ?\n          myForeignRootPaths.findForeignPrefix(path.getPath()) :\n          null\n        );\n      }\n    });\n\n    Future<IResult> res;\n\n    BuildMakeService bms = new BuildMakeService();\n    MakeSession ms = new MakeSession(context, myMessageHandler, true) {\n      @Override\n      public IScript toScript(ScriptBuilder scriptBuilder) {\n        scriptBuilder.withFacetNames(\n          new IFacet.Name(\"jetbrains.mps.build.reduced.ReportFiles\"),\n          new IFacet.Name(\"jetbrains.mps.build.reduced.CollectHashes\"));\n        return scriptBuilder.toScript();\n      }\n    };\n\n    ReducedMakeFacetConfiguration makeFacetConfiguration = new ReducedMakeFacetConfiguration(\n      myRedirects, !myContext.getCompileContext().isMake(), new Stub(), new IJobMonitor.Stub());\n    IScriptController scriptCtl = makeFacetConfiguration.configureFacets();\n    boolean success;\n\n    try {\n      res = bms.make(ms, resources, null, scriptCtl);\n      success = res.get().isSucessful();\n\n      success = processFiles(success, makeFacetConfiguration);\n\n      final Map<String, String> fileHashes = makeFacetConfiguration.getFileHashes();\n      // TODO do something with these\n\n    } catch (InterruptedException e) {\n      reportError(e);\n      success = false;\n    } catch (ExecutionException e) {\n      reportError(e);\n      success = false;\n    }\n\n    return success;\n  }","commit_id":"58ca2228350efa5e37bf979eb9393d4f1c49e96c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean build() {\n    ProjectOperationContext context = new ProjectOperationContext(myProject);\n    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());\n\n    final Iterable<IMResource> resources = Sequence.fromIterable(collectResources(context, myToMake.keySet())).toListSequence();\n    ISequence<SModule> mpsModules = Sequence.fromIterable(resources).select(new ISelector<IMResource, SModule>() {\n      public SModule select(IMResource r) {\n        return r.module();\n      }\n    });\n    ModuleOutputPaths outputPaths = new ModuleOutputPaths(mpsModules);\n    myForeignRootPaths = new MyForeignRootPaths(outputPaths.getOutputPaths());\n\n    myRedirects = new MyRedirects();\n    Set<ModuleBuildTarget> processed = new HashSet<ModuleBuildTarget>();\n    for (ModuleBuildTarget target : myToMake.values()) {\n      if (processed.contains(target)) continue;\n      processed.add(target);\n\n      JpsMPSModuleExtension mpsModule = JpsMPSExtensionService.getInstance().getExtension(target.getModule());\n      if (mpsModule == null) continue;\n\n      File outputTmpRoot = getTmpOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      File cachesOutputRoot = getCachesOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      boolean useTransientOutputFolder = mpsModule.getConfiguration().isUseTransientOutputFolder();\n      File generatorOutputRoot = new File (mpsModule.getConfiguration().getGeneratorOutputPath());\n      myRedirects.addRedirects(outputPaths, outputTmpRoot.getAbsolutePath(), cachesOutputRoot.getAbsolutePath(), useTransientOutputFolder);\n\n      if (useTransientOutputFolder || !isGenOutputUnderSourceRoot(target, mpsModule)) {\n        BuildRootIndex buildRootIndex = myContext.getCompileContext().getProjectDescriptor().getBuildRootIndex();\n        File outputRoot = useTransientOutputFolder ? outputTmpRoot : generatorOutputRoot;\n        buildRootIndex.associateTempRoot(myContext.getCompileContext(), target,\n          new JavaSourceRootDescriptor(outputRoot, target, true, true, \"\", Collections.<File>emptySet()));\n      }\n    }\n\n    GenerationDependenciesCache.getInstance().registerCachePathRedirect(new GenerationDependenciesCache.CachePathRedirect() {\n      public IFile redirectTo(IFile outputPath) {\n        return myRedirects.getRedirect(outputPath.getPath());\n      }\n    });\n    GeneratorPathsComponent.getInstance().registerForeignPathsProvider(new ForeignPathsProvider() {\n      public String belongsToForeignPath(IFile path) {\n        return (myForeignRootPaths != null ?\n          myForeignRootPaths.findForeignPrefix(path.getPath()) :\n          null\n        );\n      }\n    });\n\n    Future<IResult> res;\n\n    BuildMakeService bms = new BuildMakeService();\n    MakeSession ms = new MakeSession(context, myMessageHandler, true) {\n      @Override\n      public IScript toScript(ScriptBuilder scriptBuilder) {\n        scriptBuilder.withFacetNames(\n          new IFacet.Name(\"jetbrains.mps.make.reduced.ReportFiles\"),\n          new IFacet.Name(\"jetbrains.mps.make.reduced.CollectHashes\"));\n        return scriptBuilder.toScript();\n      }\n    };\n\n    ReducedMakeFacetConfiguration makeFacetConfiguration = new ReducedMakeFacetConfiguration(\n      myRedirects, !myContext.getCompileContext().isMake(), new Stub(), new IJobMonitor.Stub());\n    IScriptController scriptCtl = makeFacetConfiguration.configureFacets();\n    boolean success;\n\n    try {\n      res = bms.make(ms, resources, null, scriptCtl);\n      success = res.get().isSucessful();\n\n      success = processFiles(success, makeFacetConfiguration);\n\n      final Map<String, String> fileHashes = makeFacetConfiguration.getFileHashes();\n      // TODO do something with these\n\n    } catch (InterruptedException e) {\n      reportError(e);\n      success = false;\n    } catch (ExecutionException e) {\n      reportError(e);\n      success = false;\n    }\n\n    return success;\n  }","id":44636,"modified_method":"public boolean build() {\n    ProjectOperationContext context = new ProjectOperationContext(myProject);\n    GenerationSettingsProvider.getInstance().setGenerationSettings(new DefaultModifiableGenerationSettings());\n\n    final Iterable<IMResource> resources = Sequence.fromIterable(collectResources(context, myToMake.keySet())).toListSequence();\n    ISequence<SModule> mpsModules = Sequence.fromIterable(resources).select(new ISelector<IMResource, SModule>() {\n      public SModule select(IMResource r) {\n        return r.module();\n      }\n    });\n    ModuleOutputPaths outputPaths = new ModuleOutputPaths(mpsModules);\n    myForeignRootPaths = new MyForeignRootPaths(outputPaths.getOutputPaths());\n\n    myRedirects = new MyRedirects();\n    Set<ModuleBuildTarget> processed = new HashSet<ModuleBuildTarget>();\n    for (ModuleBuildTarget target : myToMake.values()) {\n      if (processed.contains(target)) continue;\n      processed.add(target);\n\n      JpsMPSModuleExtension mpsModule = JpsMPSExtensionService.getInstance().getExtension(target.getModule());\n      if (mpsModule == null) continue;\n\n      File outputTmpRoot = getTmpOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      File cachesOutputRoot = getCachesOutputRoot(mpsModule.getModule(), myContext.getCompileContext().getProjectDescriptor().dataManager);\n      boolean useTransientOutputFolder = mpsModule.getConfiguration().isUseTransientOutputFolder();\n      myRedirects.addRedirects(outputPaths, outputTmpRoot.getAbsolutePath(), cachesOutputRoot.getAbsolutePath(), useTransientOutputFolder);\n\n      File generatorOutputRoot = new File (mpsModule.getConfiguration().getGeneratorOutputPath());\n      File outputRoot = useTransientOutputFolder ? outputTmpRoot : generatorOutputRoot;\n      myOutputRootsPerTarget.put(target, outputRoot);\n\n      if (useTransientOutputFolder || !isGenOutputUnderSourceRoot(target, mpsModule)) {\n        BuildRootIndex buildRootIndex = myContext.getCompileContext().getProjectDescriptor().getBuildRootIndex();\n        buildRootIndex.associateTempRoot(myContext.getCompileContext(), target,\n          new JavaSourceRootDescriptor(outputRoot, target, true, true, \"\", Collections.<File>emptySet()));\n      }\n    }\n\n    GenerationDependenciesCache.getInstance().registerCachePathRedirect(new GenerationDependenciesCache.CachePathRedirect() {\n      public IFile redirectTo(IFile outputPath) {\n        return myRedirects.getRedirect(outputPath.getPath());\n      }\n    });\n    GeneratorPathsComponent.getInstance().registerForeignPathsProvider(new ForeignPathsProvider() {\n      public String belongsToForeignPath(IFile path) {\n        return (myForeignRootPaths != null ?\n          myForeignRootPaths.findForeignPrefix(path.getPath()) :\n          null\n        );\n      }\n    });\n\n    Future<IResult> res;\n\n    BuildMakeService bms = new BuildMakeService();\n    MakeSession ms = new MakeSession(context, myMessageHandler, true) {\n      @Override\n      public IScript toScript(ScriptBuilder scriptBuilder) {\n        scriptBuilder.withFacetNames(\n          new IFacet.Name(\"jetbrains.mps.make.reduced.ReportFiles\"),\n          new IFacet.Name(\"jetbrains.mps.make.reduced.CollectHashes\"));\n        return scriptBuilder.toScript();\n      }\n    };\n\n    ReducedMakeFacetConfiguration makeFacetConfiguration = new ReducedMakeFacetConfiguration(\n      myRedirects, !myContext.getCompileContext().isMake(), new Stub(), new IJobMonitor.Stub());\n    IScriptController scriptCtl = makeFacetConfiguration.configureFacets();\n    boolean success;\n\n    try {\n      res = bms.make(ms, resources, null, scriptCtl);\n      success = res.get().isSucessful();\n\n      success = processFiles(success, makeFacetConfiguration);\n\n      final Map<String, String> fileHashes = makeFacetConfiguration.getFileHashes();\n      // TODO do something with these\n\n    } catch (InterruptedException e) {\n      reportError(e);\n      success = false;\n    } catch (ExecutionException e) {\n      reportError(e);\n      success = false;\n    }\n\n    return success;\n  }","commit_id":"a0ecf6d673e29123c3445e7b090741b9caab65ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean processFiles(boolean success, ReducedMakeFacetConfiguration makeFacetConfiguration) {\n    ProjectBuilderLogger logger = myContext.getCompileContext().getLoggingManager().getProjectBuilderLogger();\n    if (logger.isEnabled()) {\n      try {\n        logger.logCompiledPaths(makeFacetConfiguration.getWrittenFiles(), MPSMakeConstants.BUILDER_ID, \"Written files:\");\n      } catch (IOException ignore) {}\n    }\n\n    for (String writtenFile : makeFacetConfiguration.getWrittenFiles()) {\n      myContext.getCompileContext().processMessage(new FileGeneratedEvent());\n      try {\n        FSOperations.markDirty(myContext.getCompileContext(), new File(writtenFile));\n\n        myRefreshComponent.refresh(writtenFile);\n\n        SModel source = makeFacetConfiguration.getSource(writtenFile);\n        if (source != null && source.getSource() instanceof FileDataSource) {\n            myOutputConsumer.registerOutputFile(\n              myToMake.get(source),\n              new File(writtenFile),\n              Collections.singletonList(((FileDataSource)source.getSource()).getLocation()));\n        }\n      } catch (IOException e) {\n        reportError(e);\n        success = false;\n      }\n    }\n    for (String keptFile : makeFacetConfiguration.getKeptFiles()) {\n      try {\n        FSOperations.markDirty(myContext.getCompileContext(), new File(keptFile));\n      } catch (IOException e) {\n        reportError(e);\n        success = false;\n      }\n\n      SModel source = makeFacetConfiguration.getSource(keptFile);\n      if (source != null && source.getSource() instanceof FileDataSource) {\n        try {\n          myOutputConsumer.registerOutputFile(\n            myToMake.get(source),\n            new File(keptFile),\n            Collections.singletonList(((FileDataSource)source.getSource()).getLocation()));\n        }\n        catch (IOException e) {\n          reportError(e);\n          success = false;\n        }\n      }\n    }\n\n    if (logger.isEnabled()) {\n      logger.logDeletedFiles(makeFacetConfiguration.getDeletedFiles());\n    }\n\n    for (String deletedFile : makeFacetConfiguration.getDeletedFiles()) {\n      try {\n        FSOperations.markDeleted(myContext.getCompileContext(), new File(deletedFile));\n      } catch (IOException e) {\n        reportError(e);\n        success = false;\n      }\n    }\n    myRefreshComponent.removed(makeFacetConfiguration.getDeletedFiles());\n    return success;\n  }","id":44637,"modified_method":"private boolean processFiles(boolean success, ReducedMakeFacetConfiguration makeFacetConfiguration) {\n    ProjectBuilderLogger logger = myContext.getCompileContext().getLoggingManager().getProjectBuilderLogger();\n    if (logger.isEnabled()) {\n      try {\n        logger.logCompiledPaths(makeFacetConfiguration.getWrittenFiles(), MPSMakeConstants.BUILDER_ID, \"Written files:\");\n      } catch (IOException ignore) {}\n    }\n\n    for (String writtenFile : makeFacetConfiguration.getWrittenFiles()) {\n      // TODO: this seems unnecessary\n      myContext.getCompileContext().processMessage(new FileGeneratedEvent());\n\n      try {\n        SModel source = makeFacetConfiguration.getSource(writtenFile);\n        ModuleBuildTarget target = myToMake.get(source);\n        File file = new File(writtenFile);\n\n        if (source != null && source.getSource() instanceof FileDataSource) {\n          myOutputConsumer.registerOutputFile(\n            target,\n            file,\n            Collections.singletonList(((FileDataSource)source.getSource()).getLocation()));\n        }\n\n        if (TraceInfoCache.TRACE_FILE_NAME.equals(file.getName())){\n          try {\n            copyResource(target, file);\n          }\n          catch (IOException e) {\n            myContext.getCompileContext().processMessage(\n              new CompilerMessage(\"MPS resources\", Kind.ERROR, e.getMessage(), FileUtil.toSystemIndependentName(file.getParent())));\n          }\n          success = false;\n        }\n\n        FSOperations.markDirty(myContext.getCompileContext(), file);\n\n        myRefreshComponent.refresh(writtenFile);\n\n      } catch (IOException e) {\n        reportError(e);\n        success = false;\n      }\n    }\n    for (String keptFile : makeFacetConfiguration.getKeptFiles()) {\n      try {\n        FSOperations.markDirty(myContext.getCompileContext(), new File(keptFile));\n      } catch (IOException e) {\n        reportError(e);\n        success = false;\n      }\n\n      SModel source = makeFacetConfiguration.getSource(keptFile);\n      if (source != null && source.getSource() instanceof FileDataSource) {\n        try {\n          myOutputConsumer.registerOutputFile(\n            myToMake.get(source),\n            new File(keptFile),\n            Collections.singletonList(((FileDataSource)source.getSource()).getLocation()));\n        }\n        catch (IOException e) {\n          reportError(e);\n          success = false;\n        }\n      }\n    }\n\n    if (logger.isEnabled()) {\n      logger.logDeletedFiles(makeFacetConfiguration.getDeletedFiles());\n    }\n\n    for (String deletedFile : makeFacetConfiguration.getDeletedFiles()) {\n      try {\n        FSOperations.markDeleted(myContext.getCompileContext(), new File(deletedFile));\n      } catch (IOException e) {\n        reportError(e);\n        success = false;\n      }\n    }\n    myRefreshComponent.removed(makeFacetConfiguration.getDeletedFiles());\n    return success;\n  }","commit_id":"a0ecf6d673e29123c3445e7b090741b9caab65ae","url":"https://github.com/JetBrains/MPS"},{"original_method":"void setFromServerPolicy(HTTPServerPolicy policy) {\n        if (policy.isSetCacheControl()) {\n            headers.put(\"Cache-Control\",\n                        createMutableList(policy.getCacheControl().value()));\n        }\n        if (policy.isSetContentLocation()) {\n            headers.put(\"Content-Location\",\n                        createMutableList(policy.getContentLocation()));\n        }\n        if (policy.isSetContentEncoding()) {\n            headers.put(\"Content-Encoding\",\n                        createMutableList(policy.getContentEncoding()));\n        }\n        if (policy.isSetContentType()) {\n            headers.put(HttpHeaderHelper.CONTENT_TYPE,\n                        createMutableList(policy.getContentType()));\n        }\n        if (policy.isSetServerType()) {\n            headers.put(\"Server\",\n                        createMutableList(policy.getServerType()));\n        }\n        if (policy.isSetHonorKeepAlive() && !policy.isHonorKeepAlive()) {\n            headers.put(\"Connection\",\n                        createMutableList(\"close\"));\n        } else if (policy.isSetKeepAliveParameters()) {\n            headers.put(\"Keep-Alive\", createMutableList(policy.getKeepAliveParameters()));\n        }\n        \n    \n        \n    /*\n     * TODO - hook up these policies\n    <xs:attribute name=\"SuppressClientSendErrors\" type=\"xs:boolean\" use=\"optional\" default=\"false\">\n    <xs:attribute name=\"SuppressClientReceiveErrors\" type=\"xs:boolean\" use=\"optional\" default=\"false\">\n    */\n    }","id":44638,"modified_method":"void setFromServerPolicy(HTTPServerPolicy policy) {\n        if (policy.isSetCacheControl()) {\n            headers.put(\"Cache-Control\",\n                        createMutableList(policy.getCacheControl()));\n        }\n        if (policy.isSetContentLocation()) {\n            headers.put(\"Content-Location\",\n                        createMutableList(policy.getContentLocation()));\n        }\n        if (policy.isSetContentEncoding()) {\n            headers.put(\"Content-Encoding\",\n                        createMutableList(policy.getContentEncoding()));\n        }\n        if (policy.isSetContentType()) {\n            headers.put(HttpHeaderHelper.CONTENT_TYPE,\n                        createMutableList(policy.getContentType()));\n        }\n        if (policy.isSetServerType()) {\n            headers.put(\"Server\",\n                        createMutableList(policy.getServerType()));\n        }\n        if (policy.isSetHonorKeepAlive() && !policy.isHonorKeepAlive()) {\n            headers.put(\"Connection\",\n                        createMutableList(\"close\"));\n        } else if (policy.isSetKeepAliveParameters()) {\n            headers.put(\"Keep-Alive\", createMutableList(policy.getKeepAliveParameters()));\n        }\n        \n    \n        \n    /*\n     * TODO - hook up these policies\n    <xs:attribute name=\"SuppressClientSendErrors\" type=\"xs:boolean\" use=\"optional\" default=\"false\">\n    <xs:attribute name=\"SuppressClientReceiveErrors\" type=\"xs:boolean\" use=\"optional\" default=\"false\">\n    */\n    }","commit_id":"02d654381d1d8059d4064a9f73d012ac0babbca2","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * This call places HTTP Header strings into the headers that are relevant\n     * to the ClientPolicy that is set on this conduit by configuration.\n     * \n     * REVISIT: A cookie is set statically from configuration? \n     */\n    void setFromClientPolicy(HTTPClientPolicy policy) {\n        if (policy == null) {\n            return;\n        }\n        if (policy.isSetCacheControl()) {\n            headers.put(\"Cache-Control\",\n                    createMutableList(policy.getCacheControl().value()));\n        }\n        if (policy.isSetHost()) {\n            headers.put(\"Host\",\n                    createMutableList(policy.getHost()));\n        }\n        if (policy.isSetConnection()) {\n            headers.put(\"Connection\",\n                    createMutableList(policy.getConnection().value()));\n        }\n        if (policy.isSetAccept()) {\n            headers.put(\"Accept\",\n                    createMutableList(policy.getAccept()));\n        } else if (!headers.containsKey(\"Accept\")) {\n            headers.put(\"Accept\", createMutableList(\"*/*\"));\n        }\n        if (policy.isSetAcceptEncoding()) {\n            headers.put(\"Accept-Encoding\",\n                    createMutableList(policy.getAcceptEncoding()));\n        }\n        if (policy.isSetAcceptLanguage()) {\n            headers.put(\"Accept-Language\",\n                    createMutableList(policy.getAcceptLanguage()));\n        }\n        if (policy.isSetContentType()) {\n            message.put(Message.CONTENT_TYPE, policy.getContentType());\n        }\n        if (policy.isSetCookie()) {\n            headers.put(\"Cookie\",\n                    createMutableList(policy.getCookie()));\n        }\n        if (policy.isSetBrowserType()) {\n            headers.put(\"BrowserType\",\n                    createMutableList(policy.getBrowserType()));\n        }\n        if (policy.isSetReferer()) {\n            headers.put(\"Referer\",\n                    createMutableList(policy.getReferer()));\n        }\n    }","id":44639,"modified_method":"/**\n     * This call places HTTP Header strings into the headers that are relevant\n     * to the ClientPolicy that is set on this conduit by configuration.\n     * \n     * REVISIT: A cookie is set statically from configuration? \n     */\n    void setFromClientPolicy(HTTPClientPolicy policy) {\n        if (policy == null) {\n            return;\n        }\n        if (policy.isSetCacheControl()) {\n            headers.put(\"Cache-Control\",\n                    createMutableList(policy.getCacheControl()));\n        }\n        if (policy.isSetHost()) {\n            headers.put(\"Host\",\n                    createMutableList(policy.getHost()));\n        }\n        if (policy.isSetConnection()) {\n            headers.put(\"Connection\",\n                    createMutableList(policy.getConnection().value()));\n        }\n        if (policy.isSetAccept()) {\n            headers.put(\"Accept\",\n                    createMutableList(policy.getAccept()));\n        } else if (!headers.containsKey(\"Accept\")) {\n            headers.put(\"Accept\", createMutableList(\"*/*\"));\n        }\n        if (policy.isSetAcceptEncoding()) {\n            headers.put(\"Accept-Encoding\",\n                    createMutableList(policy.getAcceptEncoding()));\n        }\n        if (policy.isSetAcceptLanguage()) {\n            headers.put(\"Accept-Language\",\n                    createMutableList(policy.getAcceptLanguage()));\n        }\n        if (policy.isSetContentType()) {\n            message.put(Message.CONTENT_TYPE, policy.getContentType());\n        }\n        if (policy.isSetCookie()) {\n            headers.put(\"Cookie\",\n                    createMutableList(policy.getCookie()));\n        }\n        if (policy.isSetBrowserType()) {\n            headers.put(\"BrowserType\",\n                    createMutableList(policy.getBrowserType()));\n        }\n        if (policy.isSetReferer()) {\n            headers.put(\"Referer\",\n                    createMutableList(policy.getReferer()));\n        }\n    }","commit_id":"02d654381d1d8059d4064a9f73d012ac0babbca2","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Determines if two HTTPServerPolicy objects are equal.\n     * REVISIT: Check if this can be replaced by a generated equals method.\n     * @param p1 one server policy\n     * @param p2 another server policy\n     * @return true iff the two policies are equal\n     */\n    public static boolean equals(HTTPServerPolicy p1, HTTPServerPolicy p2) {\n        if (p1 == p2) {\n            return true;\n        }\n        boolean result = true;\n\n        result &= (p1.isHonorKeepAlive() == p2.isHonorKeepAlive())\n            && (p1.getCacheControl() == null \n                ? p2.getCacheControl() == null \n                : p1.getCacheControl().value().equals(p2.getCacheControl().value()))\n            && equals(p1.getContentEncoding(), p2.getContentEncoding())\n            && equals(p1.getContentLocation(), p2.getContentLocation())\n            && equals(p1.getContentType(), p2.getContentType())\n            && equals(p1.getKeepAliveParameters(), p2.getKeepAliveParameters());\n        if (!result) {\n            return false;\n        }\n        result &= (p1.getReceiveTimeout() == p2.getReceiveTimeout())\n            && equals(p1.getRedirectURL(), p2.getRedirectURL())\n            && equals(p1.getServerType(), p2.getServerType())\n            && (p1.isSuppressClientReceiveErrors() == p2.isSuppressClientReceiveErrors())\n            && (p1.isSuppressClientSendErrors() == p2.isSuppressClientSendErrors());\n        \n        return result;\n    }","id":44640,"modified_method":"/**\n     * Determines if two HTTPServerPolicy objects are equal.\n     * REVISIT: Check if this can be replaced by a generated equals method.\n     * @param p1 one server policy\n     * @param p2 another server policy\n     * @return true iff the two policies are equal\n     */\n    public static boolean equals(HTTPServerPolicy p1, HTTPServerPolicy p2) {\n        if (p1 == p2) {\n            return true;\n        }\n        boolean result = true;\n\n        result &= (p1.isHonorKeepAlive() == p2.isHonorKeepAlive())\n            && (p1.getCacheControl() == null \n                ? p2.getCacheControl() == null \n                : p1.getCacheControl().equals(p2.getCacheControl()))\n            && equals(p1.getContentEncoding(), p2.getContentEncoding())\n            && equals(p1.getContentLocation(), p2.getContentLocation())\n            && equals(p1.getContentType(), p2.getContentType())\n            && equals(p1.getKeepAliveParameters(), p2.getKeepAliveParameters());\n        if (!result) {\n            return false;\n        }\n        result &= (p1.getReceiveTimeout() == p2.getReceiveTimeout())\n            && equals(p1.getRedirectURL(), p2.getRedirectURL())\n            && equals(p1.getServerType(), p2.getServerType())\n            && (p1.isSuppressClientReceiveErrors() == p2.isSuppressClientReceiveErrors())\n            && (p1.isSuppressClientSendErrors() == p2.isSuppressClientSendErrors());\n        \n        return result;\n    }","commit_id":"02d654381d1d8059d4064a9f73d012ac0babbca2","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Checks if two HTTPClientPolicy objects are compatible.\n     * @param p1 one client policy\n     * @param p2 another client policy\n     * @return true iff policies are compatible\n     */\n    public static boolean compatible(HTTPClientPolicy p1, HTTPClientPolicy p2) {\n        \n        if (p1 == p2 || p1.equals(p2)) {\n            return true;\n        }\n        \n        boolean compatible = true;\n        \n        if (compatible) {\n            compatible &= compatible(p1.getAccept(), p2.getAccept());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getAcceptEncoding(), p2.getAcceptEncoding());\n        }\n           \n        if (compatible) {\n            compatible &= compatible(p1.getAcceptLanguage(), p2.getAcceptLanguage());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getBrowserType(), p2.getBrowserType());\n        }\n        \n        if (compatible) {\n            compatible &= !p1.isSetCacheControl() || !p2.isSetCacheControl()\n                || p1.getCacheControl().value().equals(p2.getCacheControl().value());\n        }\n        \n        if (compatible) {            \n            compatible = !p1.isSetConnection() || !p2.isSetConnection()\n                || p1.getConnection().value().equals(p2.getConnection().value());\n        }\n        \n        if (compatible) {\n            compatible = !p1.isSetContentType() || !p2.isSetContentType()\n                || p1.getContentType().equals(p2.getContentType());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getCookie(), p2.getCookie());\n        }\n        \n        // REVISIT: Should compatibility require strict equality?\n        \n        if (compatible) {\n            compatible &= compatible(p1.getDecoupledEndpoint(), p2.getDecoupledEndpoint());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getHost(), p2.getHost());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getProxyServer(), p2.getProxyServer());\n        }\n       \n        if (compatible) {\n            compatible &= !p1.isSetProxyServerPort() || !p2.isSetProxyServerPort()\n                || p1.getProxyServerPort() == p2.getProxyServerPort();\n        }\n        \n        if (compatible) {\n            compatible &= !p1.isSetProxyServerType() || !p2.isSetProxyServerType()\n                || p1.getProxyServerType().equals(p2.getProxyServerType());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getReferer(), p2.getReferer());\n        }\n        \n        if (compatible) {\n            compatible &= p1.isAllowChunking() == p2.isAllowChunking();\n        }\n        \n        if (compatible) {\n            compatible &= p1.isAutoRedirect() == p2.isAutoRedirect();\n        }\n        \n        return compatible;\n    }","id":44641,"modified_method":"/**\n     * Checks if two HTTPClientPolicy objects are compatible.\n     * @param p1 one client policy\n     * @param p2 another client policy\n     * @return true iff policies are compatible\n     */\n    public static boolean compatible(HTTPClientPolicy p1, HTTPClientPolicy p2) {\n        \n        if (p1 == p2 || p1.equals(p2)) {\n            return true;\n        }\n        \n        boolean compatible = true;\n        \n        if (compatible) {\n            compatible &= compatible(p1.getAccept(), p2.getAccept());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getAcceptEncoding(), p2.getAcceptEncoding());\n        }\n           \n        if (compatible) {\n            compatible &= compatible(p1.getAcceptLanguage(), p2.getAcceptLanguage());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getBrowserType(), p2.getBrowserType());\n        }\n        \n        if (compatible) {\n            compatible &= !p1.isSetCacheControl() || !p2.isSetCacheControl()\n                || p1.getCacheControl().equals(p2.getCacheControl());\n        }\n        \n        if (compatible) {            \n            compatible = !p1.isSetConnection() || !p2.isSetConnection()\n                || p1.getConnection().value().equals(p2.getConnection().value());\n        }\n        \n        if (compatible) {\n            compatible = !p1.isSetContentType() || !p2.isSetContentType()\n                || p1.getContentType().equals(p2.getContentType());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getCookie(), p2.getCookie());\n        }\n        \n        // REVISIT: Should compatibility require strict equality?\n        \n        if (compatible) {\n            compatible &= compatible(p1.getDecoupledEndpoint(), p2.getDecoupledEndpoint());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getHost(), p2.getHost());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getProxyServer(), p2.getProxyServer());\n        }\n       \n        if (compatible) {\n            compatible &= !p1.isSetProxyServerPort() || !p2.isSetProxyServerPort()\n                || p1.getProxyServerPort() == p2.getProxyServerPort();\n        }\n        \n        if (compatible) {\n            compatible &= !p1.isSetProxyServerType() || !p2.isSetProxyServerType()\n                || p1.getProxyServerType().equals(p2.getProxyServerType());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getReferer(), p2.getReferer());\n        }\n        \n        if (compatible) {\n            compatible &= p1.isAllowChunking() == p2.isAllowChunking();\n        }\n        \n        if (compatible) {\n            compatible &= p1.isAutoRedirect() == p2.isAutoRedirect();\n        }\n        \n        return compatible;\n    }","commit_id":"02d654381d1d8059d4064a9f73d012ac0babbca2","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Determines if two HTTPClientPolicy objects are equal.\n     * REVISIT: Check if this can be replaced by a generated equals method.\n     * @param p1 one client policy\n     * @param p2 another client policy\n     * @return true iff the two policies are equal\n     */\n    public static boolean equals(HTTPClientPolicy p1, HTTPClientPolicy p2) {\n        if (p1 == p2) {\n            return true;\n        }\n        boolean result = true;\n        result &= (p1.isAllowChunking() == p2.isAllowChunking())\n            && (p1.isAutoRedirect() == p2.isAutoRedirect())\n            && equals(p1.getAccept(), p2.getAccept())\n            && equals(p1.getAcceptEncoding(), p2.getAcceptEncoding())\n            && equals(p1.getAcceptLanguage(), p2.getAcceptLanguage())\n            && equals(p1.getBrowserType(), p2.getBrowserType());\n        if (!result) {\n            return false;\n        }\n      \n        result &= (p1.getCacheControl() == null \n                ? p2.getCacheControl() == null \n                : p1.getCacheControl().value().equals(p2.getCacheControl().value())\n                && p1.getConnection().value().equals(p2.getConnection().value()))        \n            && (p1.getConnectionTimeout() == p2.getConnectionTimeout())\n            && equals(p1.getContentType(), p2.getContentType())\n            && equals(p1.getCookie(), p2.getCookie())\n            && equals(p1.getDecoupledEndpoint(), p2.getDecoupledEndpoint())\n            && equals(p1.getHost(), p2.getHost());\n        if (!result) {\n            return false;\n        } \n\n        result &= equals(p1.getProxyServer(), p2.getProxyServer())\n            && (p1.isSetProxyServerPort() \n                ? p1.getProxyServerPort() == p2.getProxyServerPort()\n                : !p2.isSetProxyServerPort())\n            && p1.getProxyServerType().value().equals(p2.getProxyServerType().value())\n            && (p1.getReceiveTimeout() == p2.getReceiveTimeout())\n            && equals(p1.getReferer(), p2.getReferer());\n        \n        return result;\n    }","id":44642,"modified_method":"/**\n     * Determines if two HTTPClientPolicy objects are equal.\n     * REVISIT: Check if this can be replaced by a generated equals method.\n     * @param p1 one client policy\n     * @param p2 another client policy\n     * @return true iff the two policies are equal\n     */\n    public static boolean equals(HTTPClientPolicy p1, HTTPClientPolicy p2) {\n        if (p1 == p2) {\n            return true;\n        }\n        boolean result = true;\n        result &= (p1.isAllowChunking() == p2.isAllowChunking())\n            && (p1.isAutoRedirect() == p2.isAutoRedirect())\n            && equals(p1.getAccept(), p2.getAccept())\n            && equals(p1.getAcceptEncoding(), p2.getAcceptEncoding())\n            && equals(p1.getAcceptLanguage(), p2.getAcceptLanguage())\n            && equals(p1.getBrowserType(), p2.getBrowserType());\n        if (!result) {\n            return false;\n        }\n      \n        result &= (p1.getCacheControl() == null \n                ? p2.getCacheControl() == null \n                : p1.getCacheControl().equals(p2.getCacheControl())\n                && p1.getConnection().value().equals(p2.getConnection().value()))        \n            && (p1.getConnectionTimeout() == p2.getConnectionTimeout())\n            && equals(p1.getContentType(), p2.getContentType())\n            && equals(p1.getCookie(), p2.getCookie())\n            && equals(p1.getDecoupledEndpoint(), p2.getDecoupledEndpoint())\n            && equals(p1.getHost(), p2.getHost());\n        if (!result) {\n            return false;\n        } \n\n        result &= equals(p1.getProxyServer(), p2.getProxyServer())\n            && (p1.isSetProxyServerPort() \n                ? p1.getProxyServerPort() == p2.getProxyServerPort()\n                : !p2.isSetProxyServerPort())\n            && p1.getProxyServerType().value().equals(p2.getProxyServerType().value())\n            && (p1.getReceiveTimeout() == p2.getReceiveTimeout())\n            && equals(p1.getReferer(), p2.getReferer());\n        \n        return result;\n    }","commit_id":"02d654381d1d8059d4064a9f73d012ac0babbca2","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Checks if two HTTPServerPolicy objects are compatible.\n     * @param p1 one server policy\n     * @param p2 another server policy\n     * @return true iff policies are compatible\n     */\n    public static boolean compatible(HTTPServerPolicy p1, HTTPServerPolicy p2) {\n        \n        if (p1 == p2 || p1.equals(p2)) {\n            return true;\n        }\n        \n        boolean compatible = true;\n        \n        if (compatible) {\n            compatible &= !p1.isSetCacheControl() || !p2.isSetCacheControl()\n                || p1.getCacheControl().value().equals(p2.getCacheControl().value());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getContentEncoding(), p2.getContentEncoding());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getContentLocation(), p2.getContentLocation());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getContentType(), p2.getContentType());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getRedirectURL(), p2.getRedirectURL());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getServerType(), p2.getServerType());\n        }\n        \n        if (compatible) {\n            compatible &= p1.isHonorKeepAlive() == p2.isHonorKeepAlive();\n        }\n        \n        if (compatible) {\n            compatible &= p1.isSuppressClientReceiveErrors() == p2.isSuppressClientReceiveErrors();\n        }\n        \n        if (compatible) {\n            compatible &= p1.isSuppressClientSendErrors() == p2.isSuppressClientSendErrors();\n        }\n        if (compatible) {\n            compatible &= compatible(p1.getKeepAliveParameters(), p2.getKeepAliveParameters());\n        }\n        \n        return compatible;\n    }","id":44643,"modified_method":"/**\n     * Checks if two HTTPServerPolicy objects are compatible.\n     * @param p1 one server policy\n     * @param p2 another server policy\n     * @return true iff policies are compatible\n     */\n    public static boolean compatible(HTTPServerPolicy p1, HTTPServerPolicy p2) {\n        \n        if (p1 == p2 || p1.equals(p2)) {\n            return true;\n        }\n        \n        boolean compatible = true;\n        \n        if (compatible) {\n            compatible &= !p1.isSetCacheControl() || !p2.isSetCacheControl()\n                || p1.getCacheControl().equals(p2.getCacheControl());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getContentEncoding(), p2.getContentEncoding());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getContentLocation(), p2.getContentLocation());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getContentType(), p2.getContentType());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getRedirectURL(), p2.getRedirectURL());\n        }\n        \n        if (compatible) {\n            compatible &= compatible(p1.getServerType(), p2.getServerType());\n        }\n        \n        if (compatible) {\n            compatible &= p1.isHonorKeepAlive() == p2.isHonorKeepAlive();\n        }\n        \n        if (compatible) {\n            compatible &= p1.isSuppressClientReceiveErrors() == p2.isSuppressClientReceiveErrors();\n        }\n        \n        if (compatible) {\n            compatible &= p1.isSuppressClientSendErrors() == p2.isSuppressClientSendErrors();\n        }\n        if (compatible) {\n            compatible &= compatible(p1.getKeepAliveParameters(), p2.getKeepAliveParameters());\n        }\n        \n        return compatible;\n    }","commit_id":"02d654381d1d8059d4064a9f73d012ac0babbca2","url":"https://github.com/apache/cxf"},{"original_method":"protected Map<String, Object> createModel(BindyFixedLengthFactory factory, String line, int count) throws Exception {\n        // Check if the record length corresponds to the parameter\n        // provided in the @FixedLengthRecord\n        if (factory.recordLength() > 0) {\n            if ((line.length() < factory.recordLength()) || (line.length() > factory.recordLength())) {\n                throw new java.lang.IllegalArgumentException(\"Size of the record: \" + line.length() \n                        + \" is not equal to the value provided in the model: \" + factory.recordLength());\n            }\n        }\n\n        // Create POJO where Fixed data will be stored\n        Map<String, Object> model = factory.factory();\n        \n        // Bind data from Fixed record with model classes\n        factory.bind(line, model, count);\n\n        // Link objects together\n        factory.link(model);\n        \n        LOG.debug(\"Graph of objects created: {}\", model);\n        return model;\n    }","id":44644,"modified_method":"protected Map<String, Object> createModel(BindyFixedLengthFactory factory, String line, int count) throws Exception {\n        String myLine = line;\n\n        // Check if the record length corresponds to the parameter\n        // provided in the @FixedLengthRecord\n        if (factory.recordLength() > 0) {\n            if (isPaddingNeededAndEnable(factory, myLine)) {\n                //myLine = rightPad(myLine, factory.recordLength());\n            }\n            if (isTrimmingNeededAndEnabled(factory, myLine)) {\n                myLine = myLine.substring(0, factory.recordLength());\n            }\n            if ((myLine.length() < factory.recordLength()\n                    && !factory.isIgnoreMissingChars()) || (myLine.length() > factory.recordLength())) {\n                throw new java.lang.IllegalArgumentException(\"Size of the record: \" + myLine.length()\n                        + \" is not equal to the value provided in the model: \" + factory.recordLength());\n            }\n        }\n\n        // Create POJO where Fixed data will be stored\n        Map<String, Object> model = factory.factory();\n\n        // Bind data from Fixed record with model classes\n        factory.bind(myLine, model, count);\n\n        // Link objects together\n        factory.link(model);\n\n        LOG.debug(\"Graph of objects created: {}\", model);\n        return model;\n    }","commit_id":"0e72f475f80a9699fe49004c431e1ce4e360c35d","url":"https://github.com/apache/camel"},{"original_method":"public void bind(String record, Map<String, Object> model, int line) throws Exception {\n\n        int pos = 1;\n        int counterMandatoryFields = 0;\n        DataField dataField;\n        String token;\n        int offset = 1;\n        int length;\n        String delimiter;\n        Field field;\n\n        // Iterate through the list of positions\n        // defined in the @DataField\n        // and grab the data from the line\n        Collection<DataField> c = dataFields.values();\n        Iterator<DataField> itr = c.iterator();\n\n        // this iterator is for a link list that was built using items in order\n        while (itr.hasNext()) {\n            dataField = itr.next();\n            length = dataField.length();\n            delimiter = dataField.delimiter();\n\n            if (length == 0 && dataField.lengthPos() != 0) {\n                Field lengthField = annotatedFields.get(dataField.lengthPos());\n                lengthField.setAccessible(true);\n                Object modelObj = model.get(lengthField.getDeclaringClass().getName());\n                Object lengthObj =  lengthField.get(modelObj);\n                length = ((Integer)lengthObj).intValue();\n            }\n            if (length < 1 && delimiter == null && dataField.lengthPos() == 0) {\n                throw new IllegalArgumentException(\"Either length or delimiter must be specified for the field : \" + dataField.toString());\n            }\n            if (offset - 1 <= -1) {\n                throw new IllegalArgumentException(\"Offset/Position of the field \" + dataField.toString()\n                                                   + \" cannot be negative\");\n            }\n\n            // skip ahead if the expected position is greater than the offset\n            if (dataField.pos() > offset) {\n                LOG.debug(\"skipping ahead [\" + (dataField.pos() - offset) + \"] chars.\");\n                offset = dataField.pos();\n            }\n\n            if (length > 0) {\n                token = record.substring(offset - 1, offset + length - 1);\n                offset += length;\n            } else if (!delimiter.equals(\"\")) {\n                String tempToken = record.substring(offset - 1, record.length());\n                token = tempToken.substring(0, tempToken.indexOf(delimiter));\n                // include the delimiter in the offset calculation\n                offset += token.length() + 1;\n            } else {\n                // defined as a zero-length field\n                token = \"\";\n            }\n\n            if (dataField.trim()) {\n                token = token.trim();\n            }\n\n            // Check mandatory field\n            if (dataField.required()) {\n\n                // Increment counter of mandatory fields\n                ++counterMandatoryFields;\n\n                // Check if content of the field is empty\n                // This is not possible for mandatory fields\n                if (token.equals(\"\")) {\n                    throw new IllegalArgumentException(\"The mandatory field defined at the position \" + pos\n                                                       + \" is empty for the line: \" + line);\n                }\n            }\n\n            // Get Field to be set\n            field = annotatedFields.get(dataField.pos());\n            field.setAccessible(true);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Pos/Offset: {}, Data: {}, Field type: {}\", new Object[]{offset, token, field.getType()});\n            }\n\n            // Create format object to format the field\n            FormattingOptions formattingOptions = ConverterUtils.convert(dataField,\n                    field.getType(),\n                    field.getAnnotation(BindyConverter.class),\n                    getLocale());\n            Format<?> format = formatFactory.getFormat(formattingOptions);\n\n            // field object to be set\n            Object modelField = model.get(field.getDeclaringClass().getName());\n\n            // format the data received\n            Object value = null;\n\n            if (!token.equals(\"\")) {\n                try {\n                    value = format.parse(token);\n                } catch (FormatException ie) {\n                    throw new IllegalArgumentException(ie.getMessage() + \", position: \" + offset + \", line: \" + line, ie);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Parsing error detected for field defined at the position/offset: \" + offset + \", line: \" + line, e);\n                }\n            } else {\n                value = getDefaultValueForPrimitive(field.getType());\n            }\n\n            field.set(modelField, value);\n\n            ++pos;\n\n        }\n\n        // check for unmapped non-whitespace data at the end of the line\n        if (offset <= record.length() && !(record.substring(offset - 1, record.length())).trim().equals(\"\") && !isIgnoreTrailingChars()) {\n            throw new IllegalArgumentException(\"Unexpected / unmapped characters found at the end of the fixed-length record at line : \" + line);\n        }\n\n        LOG.debug(\"Counter mandatory fields: {}\", counterMandatoryFields);\n\n        if (pos < totalFields) {\n            throw new IllegalArgumentException(\"Some fields are missing (optional or mandatory), line: \" + line);\n        }\n\n        if (counterMandatoryFields < numberMandatoryFields) {\n            throw new IllegalArgumentException(\"Some mandatory fields are missing, line: \" + line);\n        }\n\n    }","id":44645,"modified_method":"public void bind(String record, Map<String, Object> model, int line) throws Exception {\n\n        int pos = 1;\n        int counterMandatoryFields = 0;\n        DataField dataField;\n        String token;\n        int offset = 1;\n        int length;\n        String delimiter;\n        Field field;\n\n        // Iterate through the list of positions\n        // defined in the @DataField\n        // and grab the data from the line\n        Collection<DataField> c = dataFields.values();\n        Iterator<DataField> itr = c.iterator();\n\n        // this iterator is for a link list that was built using items in order\n        while (itr.hasNext()) {\n            dataField = itr.next();\n            length = dataField.length();\n            delimiter = dataField.delimiter();\n\n            if (length == 0 && dataField.lengthPos() != 0) {\n                Field lengthField = annotatedFields.get(dataField.lengthPos());\n                lengthField.setAccessible(true);\n                Object modelObj = model.get(lengthField.getDeclaringClass().getName());\n                Object lengthObj =  lengthField.get(modelObj);\n                length = ((Integer)lengthObj).intValue();\n            }\n            if (length < 1 && delimiter == null && dataField.lengthPos() == 0) {\n                throw new IllegalArgumentException(\"Either length or delimiter must be specified for the field : \" + dataField.toString());\n            }\n            if (offset - 1 <= -1) {\n                throw new IllegalArgumentException(\"Offset/Position of the field \" + dataField.toString()\n                                                   + \" cannot be negative\");\n            }\n\n            // skip ahead if the expected position is greater than the offset\n            if (dataField.pos() > offset) {\n                LOG.debug(\"skipping ahead [\" + (dataField.pos() - offset) + \"] chars.\");\n                offset = dataField.pos();\n            }\n\n            if (length > 0) {\n                if (record.length() < offset) {\n                    token = \"\";\n                } else {\n                    int endIndex = offset + length - 1;\n                    if (endIndex > record.length()) {\n                        endIndex = record.length();\n                    }\n                    token = record.substring(offset - 1, endIndex);\n                }\n                offset += length;\n            } else if (!delimiter.equals(\"\")) {\n                String tempToken = record.substring(offset - 1, record.length());\n                token = tempToken.substring(0, tempToken.indexOf(delimiter));\n                // include the delimiter in the offset calculation\n                offset += token.length() + 1;\n            } else {\n                // defined as a zero-length field\n                token = \"\";\n            }\n\n            if (dataField.trim()) {\n                token = trim(token, dataField, paddingChar);\n                //token = token.trim();\n            }\n\n            // Check mandatory field\n            if (dataField.required()) {\n\n                // Increment counter of mandatory fields\n                ++counterMandatoryFields;\n\n                // Check if content of the field is empty\n                // This is not possible for mandatory fields\n                if (token.equals(\"\")) {\n                    throw new IllegalArgumentException(\"The mandatory field defined at the position \" + pos\n                                                       + \" is empty for the line: \" + line);\n                }\n            }\n\n            // Get Field to be set\n            field = annotatedFields.get(dataField.pos());\n            field.setAccessible(true);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Pos/Offset: {}, Data: {}, Field type: {}\", new Object[]{offset, token, field.getType()});\n            }\n\n            // Create format object to format the field\n            FormattingOptions formattingOptions = ConverterUtils.convert(dataField,\n                    field.getType(),\n                    field.getAnnotation(BindyConverter.class),\n                    getLocale());\n            Format<?> format = formatFactory.getFormat(formattingOptions);\n\n            // field object to be set\n            Object modelField = model.get(field.getDeclaringClass().getName());\n\n            // format the data received\n            Object value = null;\n\n            if (\"\".equals(token)) {\n                token = dataField.defaultValue();\n            }\n            if (!\"\".equals(token)) {\n                try {\n                    value = format.parse(token);\n                } catch (FormatException ie) {\n                    throw new IllegalArgumentException(ie.getMessage() + \", position: \" + offset + \", line: \" + line, ie);\n                } catch (Exception e) {\n                    throw new IllegalArgumentException(\"Parsing error detected for field defined at the position/offset: \" + offset + \", line: \" + line, e);\n                }\n            } else {\n                value = getDefaultValueForPrimitive(field.getType());\n            }\n\n            field.set(modelField, value);\n\n            ++pos;\n\n        }\n\n        // check for unmapped non-whitespace data at the end of the line\n        if (offset <= record.length() && !(record.substring(offset - 1, record.length())).trim().equals(\"\") && !isIgnoreTrailingChars()) {\n            throw new IllegalArgumentException(\"Unexpected / unmapped characters found at the end of the fixed-length record at line : \" + line);\n        }\n\n        LOG.debug(\"Counter mandatory fields: {}\", counterMandatoryFields);\n\n        if (pos < totalFields) {\n            throw new IllegalArgumentException(\"Some fields are missing (optional or mandatory), line: \" + line);\n        }\n\n        if (counterMandatoryFields < numberMandatoryFields) {\n            throw new IllegalArgumentException(\"Some mandatory fields are missing, line: \" + line);\n        }\n\n    }","commit_id":"0e72f475f80a9699fe49004c431e1ce4e360c35d","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Get parameters defined in @FixedLengthRecord annotation\n     */\n    private void initFixedLengthRecordParameters() {\n\n        for (Class<?> cl : models) {\n\n            // Get annotation @FixedLengthRecord from the class\n            FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);\n\n            if (record != null) {\n                LOG.debug(\"Fixed length record: {}\", record);\n\n                // Get carriage return parameter\n                crlf = record.crlf();\n                LOG.debug(\"Carriage return defined for the CSV: {}\", crlf);\n\n                // Get header parameter\n                header =  record.header();\n                LOG.debug(\"Header: {}\", header);\n                hasHeader = header != void.class;\n                LOG.debug(\"Has Header: {}\", hasHeader);\n\n                // Get skipHeader parameter\n                skipHeader = record.skipHeader();\n                LOG.debug(\"Skip Header: {}\", skipHeader);\n\n                // Get footer parameter\n                footer =  record.footer();\n                LOG.debug(\"Footer: {}\", footer);\n                hasFooter = record.footer() != void.class;\n                LOG.debug(\"Has Footer: {}\", hasFooter);\n\n                // Get skipFooter parameter\n                skipFooter = record.skipFooter();\n                LOG.debug(\"Skip Footer: {}\", skipFooter);\n\n                // Get isHeader parameter\n                isHeader = hasHeader ? cl.equals(header) : false;\n                LOG.debug(\"Is Header: {}\", isHeader);\n\n                // Get isFooter parameter\n                isFooter = hasFooter ? cl.equals(footer) : false;\n                LOG.debug(\"Is Footer: {}\", isFooter);\n\n                // Get padding character\n                paddingChar = record.paddingChar();\n                LOG.debug(\"Padding char: {}\", paddingChar);\n\n                // Get length of the record\n                recordLength = record.length();\n                LOG.debug(\"Length of the record: {}\", recordLength);\n\n                // Get flag for ignore trailing characters\n                ignoreTrailingChars = record.ignoreTrailingChars();\n                LOG.debug(\"Ignore trailing chars: {}\", ignoreTrailingChars);\n            }\n        }\n\n        if (hasHeader && isHeader) {\n            throw new java.lang.IllegalArgumentException(\"Record can not be configured with both 'isHeader=true' and 'hasHeader=true'\");\n        }\n\n        if (hasFooter && isFooter) {\n            throw new java.lang.IllegalArgumentException(\"Record can not be configured with both 'isFooter=true' and 'hasFooter=true'\");\n        }\n\n        if ((isHeader || isFooter) && (skipHeader || skipFooter)) {\n            throw new java.lang.IllegalArgumentException(\n                    \"skipHeader and/or skipFooter can not be configured on a record where 'isHeader=true' or 'isFooter=true'\");\n        }\n\n    }","id":44646,"modified_method":"/**\n     * Get parameters defined in @FixedLengthRecord annotation\n     */\n    private void initFixedLengthRecordParameters() {\n\n        for (Class<?> cl : models) {\n\n            // Get annotation @FixedLengthRecord from the class\n            FixedLengthRecord record = cl.getAnnotation(FixedLengthRecord.class);\n\n            if (record != null) {\n                LOG.debug(\"Fixed length record: {}\", record);\n\n                // Get carriage return parameter\n                crlf = record.crlf();\n                LOG.debug(\"Carriage return defined for the CSV: {}\", crlf);\n\n                // Get header parameter\n                header =  record.header();\n                LOG.debug(\"Header: {}\", header);\n                hasHeader = header != void.class;\n                LOG.debug(\"Has Header: {}\", hasHeader);\n\n                // Get skipHeader parameter\n                skipHeader = record.skipHeader();\n                LOG.debug(\"Skip Header: {}\", skipHeader);\n\n                // Get footer parameter\n                footer =  record.footer();\n                LOG.debug(\"Footer: {}\", footer);\n                hasFooter = record.footer() != void.class;\n                LOG.debug(\"Has Footer: {}\", hasFooter);\n\n                // Get skipFooter parameter\n                skipFooter = record.skipFooter();\n                LOG.debug(\"Skip Footer: {}\", skipFooter);\n\n                // Get isHeader parameter\n                isHeader = hasHeader ? cl.equals(header) : false;\n                LOG.debug(\"Is Header: {}\", isHeader);\n\n                // Get isFooter parameter\n                isFooter = hasFooter ? cl.equals(footer) : false;\n                LOG.debug(\"Is Footer: {}\", isFooter);\n\n                // Get padding character\n                paddingChar = record.paddingChar();\n                LOG.debug(\"Padding char: {}\", paddingChar);\n\n                // Get length of the record\n                recordLength = record.length();\n                LOG.debug(\"Length of the record: {}\", recordLength);\n\n                // Get flag for ignore trailing characters\n                ignoreTrailingChars = record.ignoreTrailingChars();\n                LOG.debug(\"Ignore trailing chars: {}\", ignoreTrailingChars);\n\n                ignoreMissingChars = record.ignoreMissingChars();\n                LOG.debug(\"Enable ignore missing chars: {}\", ignoreMissingChars);\n            }\n        }\n\n        if (hasHeader && isHeader) {\n            throw new java.lang.IllegalArgumentException(\"Record can not be configured with both 'isHeader=true' and 'hasHeader=true'\");\n        }\n\n        if (hasFooter && isFooter) {\n            throw new java.lang.IllegalArgumentException(\"Record can not be configured with both 'isFooter=true' and 'hasFooter=true'\");\n        }\n\n        if ((isHeader || isFooter) && (skipHeader || skipFooter)) {\n            throw new java.lang.IllegalArgumentException(\n                    \"skipHeader and/or skipFooter can not be configured on a record where 'isHeader=true' or 'isFooter=true'\");\n        }\n\n    }","commit_id":"0e72f475f80a9699fe49004c431e1ce4e360c35d","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    @DirtiesContext\n    public void testUnMarshallMessage() throws Exception {\n\n        expected = \"10A9  PaulineM    ISINXD12345678BUYShare000002500.45USD01-08-2009  Hello   \";\n\n        template.sendBody(expected);\n\n        result.expectedMessageCount(1);\n        result.assertIsSatisfied();\n\n        // check the model\n        \n        BindySimpleFixedLengthUnmarshallTrimFieldTest.Order order = result.getReceivedExchanges().get(0).getIn().getBody(BindySimpleFixedLengthUnmarshallTrimFieldTest.Order.class);\n        Assert.assertEquals(10, order.getOrderNr());\n        // the field is not trimmed\n        Assert.assertEquals(\"Pauline\", order.getFirstName());\n        Assert.assertEquals(\"M    \", order.getLastName()); // no trim\n        Assert.assertEquals(\"Hello\", order.getComment());\n    }","id":44647,"modified_method":"@Test\n    @DirtiesContext\n    public void testUnMarshallMessage() throws Exception {\n\n        expected = \"10A9  PaulineM    ISINXD12345678BUYShare000002500.45USD01-08-2009  Hello###\";\n\n        template.sendBody(expected);\n\n        result.expectedMessageCount(1);\n        result.assertIsSatisfied();\n\n        // check the model\n        \n        BindySimpleFixedLengthUnmarshallTrimFieldTest.Order order = result.getReceivedExchanges().get(0).getIn().getBody(BindySimpleFixedLengthUnmarshallTrimFieldTest.Order.class);\n        Assert.assertEquals(10, order.getOrderNr());\n        // the field is not trimmed\n        Assert.assertEquals(\"Pauline\", order.getFirstName());\n        Assert.assertEquals(\"M    \", order.getLastName()); // no trim\n        Assert.assertEquals(\"  Hello\", order.getComment());\n    }","commit_id":"0e72f475f80a9699fe49004c431e1ce4e360c35d","url":"https://github.com/apache/camel"},{"original_method":"public String generateHeader() {\n\n        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields);\n        Iterator<Integer> it = dataFieldsSorted.keySet().iterator();\n\n        StringBuilder builderHeader = new StringBuilder();\n\n        while (it.hasNext()) {\n\n            DataField dataField = dataFieldsSorted.get(it.next());\n\n            // Retrieve the field\n            Field field = annotedFields.get(dataField.pos());\n            // Change accessibility to allow to read protected/private fields\n            field.setAccessible(true);\n\n            // Get dataField\n            if (!dataField.columnName().equals(\"\")) {\n                builderHeader.append(dataField.columnName());\n            } else {\n                builderHeader.append(field.getName());\n            }\n\n            if (it.hasNext()) {\n                builderHeader.append(separator);\n            }\n\n        }\n\n        return builderHeader.toString();\n    }","id":44648,"modified_method":"/**\n     * Generate for the first line the headers of the columns\n     * \n     * @return the headers columns\n     */\n    public String generateHeader() {\n\n        Map<Integer, DataField> dataFieldsSorted = new TreeMap<Integer, DataField>(dataFields);\n        Iterator<Integer> it = dataFieldsSorted.keySet().iterator();\n\n        StringBuilder builderHeader = new StringBuilder();\n\n        while (it.hasNext()) {\n\n            DataField dataField = dataFieldsSorted.get(it.next());\n\n            // Retrieve the field\n            Field field = annotedFields.get(dataField.pos());\n            // Change accessibility to allow to read protected/private fields\n            field.setAccessible(true);\n\n            // Get dataField\n            if (!dataField.columnName().equals(\"\")) {\n                builderHeader.append(dataField.columnName());\n            } else {\n                builderHeader.append(field.getName());\n            }\n\n            if (it.hasNext()) {\n                builderHeader.append(separator);\n            }\n\n        }\n\n        return builderHeader.toString();\n    }","commit_id":"c3a3ff2b2beaa2e01aff6faf304c54e3255cfa4c","url":"https://github.com/apache/camel"},{"original_method":"private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {\n\n        String result = \"\";\n\n        for (Field field : clazz.getDeclaredFields()) {\n\n            field.setAccessible(true);\n\n            DataField datafield = field.getAnnotation(DataField.class);\n\n            if (datafield != null) {\n\n                if (obj != null) {\n\n                    // Retrieve the format, pattern and precision associated to\n                    // the type\n                    Class type = field.getType();\n                    String pattern = datafield.pattern();\n                    int precision = datafield.precision();\n\n                    // Create format\n                    Format format = FormatFactory.getFormat(type, pattern, precision);\n\n                    // Get field value\n                    Object value = field.get(obj);\n\n                    result = formatString(format, value);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value to be formatted : \" + value + \", position : \" + datafield.pos() + \", and its formated value : \" + result);\n                    }\n\n                } else {\n                    result = \"\";\n                }\n\n                Integer key;\n\n                if (isMessageOrdered()) {\n\n                    // Generate a key using the number of the section\n                    // and the position of the field\n                    Integer key1 = sections.get(obj.getClass().getName());\n                    Integer key2 = datafield.position();\n                    Integer keyGenerated = generateKey(key1, key2);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key generated : \" + String.valueOf(keyGenerated) + \", for section : \" + key1);\n                    }\n\n                    key = keyGenerated;\n\n                } else {\n\n                    key = datafield.pos();\n                }\n\n                if (!results.containsKey(key)) {\n\n                    List list = new LinkedList();\n                    list.add(result);\n                    results.put(key, list);\n\n                } else {\n\n                    List list = (LinkedList)results.get(key);\n                    list.add(result);\n                }\n\n            }\n\n            OneToMany oneToMany = field.getAnnotation(OneToMany.class);\n            if (oneToMany != null) {\n\n                // Set global variable\n                // Will be used during generation of CSV\n                isOneToMany = true;\n\n                ArrayList list = (ArrayList)field.get(obj);\n\n                if (list != null) {\n\n                    Iterator it = list.iterator();\n\n                    while (it.hasNext()) {\n\n                        Object target = it.next();\n                        generateCsvPositionMap(target.getClass(), target);\n\n                    }\n\n                } else {\n\n                    // Call this function to add empty value\n                    // in the table\n                    generateCsvPositionMap(field.getClass(), null);\n                }\n\n            }\n        }\n\n    }","id":44649,"modified_method":"/**\n     * \n     * Generate a table containing the data formated and sorted with their position/offset\n     * If the model is Ordered than a key is created combining the annotation @Section and Position of the field\n     * If a relation @OneToMany is defined, than we iterate recursivelu through this function\n     * The result is placed in the Map<Integer, List> results\n     * \n     * @param clazz\n     * @param obj\n     * @throws Exception\n     */\n    private void generateCsvPositionMap(Class clazz, Object obj) throws Exception {\n\n        String result = \"\";\n\n        for (Field field : clazz.getDeclaredFields()) {\n\n            field.setAccessible(true);\n\n            DataField datafield = field.getAnnotation(DataField.class);\n\n            if (datafield != null) {\n\n                if (obj != null) {\n\n                    // Retrieve the format, pattern and precision associated to\n                    // the type\n                    Class type = field.getType();\n                    String pattern = datafield.pattern();\n                    int precision = datafield.precision();\n\n                    // Create format\n                    Format format = FormatFactory.getFormat(type, pattern, precision);\n\n                    // Get field value\n                    Object value = field.get(obj);\n\n                    result = formatString(format, value);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Value to be formatted : \" + value + \", position : \" + datafield.pos() + \", and its formated value : \" + result);\n                    }\n\n                } else {\n                    result = \"\";\n                }\n\n                Integer key;\n\n                if (isMessageOrdered()) {\n\n                    // Generate a key using the number of the section\n                    // and the position of the field\n                    Integer key1 = sections.get(obj.getClass().getName());\n                    Integer key2 = datafield.position();\n                    Integer keyGenerated = generateKey(key1, key2);\n\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Key generated : \" + String.valueOf(keyGenerated) + \", for section : \" + key1);\n                    }\n\n                    key = keyGenerated;\n\n                } else {\n\n                    key = datafield.pos();\n                }\n\n                if (!results.containsKey(key)) {\n\n                    List list = new LinkedList();\n                    list.add(result);\n                    results.put(key, list);\n\n                } else {\n\n                    List list = (LinkedList)results.get(key);\n                    list.add(result);\n                }\n\n            }\n\n            OneToMany oneToMany = field.getAnnotation(OneToMany.class);\n            if (oneToMany != null) {\n\n                // Set global variable\n                // Will be used during generation of CSV\n                isOneToMany = true;\n\n                ArrayList list = (ArrayList)field.get(obj);\n\n                if (list != null) {\n\n                    Iterator it = list.iterator();\n\n                    while (it.hasNext()) {\n\n                        Object target = it.next();\n                        generateCsvPositionMap(target.getClass(), target);\n\n                    }\n\n                } else {\n\n                    // Call this function to add empty value\n                    // in the table\n                    generateCsvPositionMap(field.getClass(), null);\n                }\n\n            }\n        }\n\n    }","commit_id":"c3a3ff2b2beaa2e01aff6faf304c54e3255cfa4c","url":"https://github.com/apache/camel"},{"original_method":"public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {\r\n    \tBindyFixedLengthFactory factory = getFactory(exchange.getContext().getPackageScanClassResolver());\r\n        ObjectHelper.notNull(factory, \"not instantiated\");\r\n\r\n        // List of Pojos\r\n        List<Map<String, Object>> models = new ArrayList<Map<String, Object>>();\r\n\r\n        // Pojos of the model\r\n        Map<String, Object> model;\r\n\r\n        InputStreamReader in = new InputStreamReader(inputStream);\r\n\r\n        // Scanner is used to read big file\r\n        Scanner scanner = new Scanner(in);\r\n\r\n        int count = 0;\r\n\r\n        try {\r\n\r\n            // TODO Test if we have a Header\r\n        \t// TODO Test if we have a Footer (containing by example checksum)\r\n\r\n            while (scanner.hasNextLine()) {\r\n\r\n                // Read the line\r\n                String line = scanner.nextLine().trim();\r\n\r\n                if (ObjectHelper.isEmpty(line)) {\r\n                    // skip if line is empty\r\n                    continue;\r\n                }\r\n\r\n                // Increment counter\r\n                count++;\r\n                \r\n                // Check if the record length corresponds to the parameter\r\n                // provided in the @FixedLengthRecord\r\n                if (line.length() != factory.recordLength()-1) {\r\n                \tthrow new java.lang.IllegalArgumentException(\"Size of the record : \" + line.length() + \" is not equal to the value provided in the model : \" + factory.recordLength() + \" !\");\r\n                }\r\n\r\n                // Create POJO where Fixed data will be stored\r\n                model = factory.factory();\r\n                \r\n                // Bind data from Fixed record with model classes\r\n                factory.bind(line, model, count);\r\n\r\n                // Link objects together\r\n                factory.link(model);\r\n\r\n                // Add objects graph to the list\r\n                models.add(model);\r\n\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Graph of objects created : \" + model);\r\n                }\r\n\r\n            }\r\n\r\n            // Test if models list is empty or not\r\n            // If this is the case (correspond to an empty stream, ...)\r\n            if (models.size() == 0) {\r\n                throw new java.lang.IllegalArgumentException(\"No records have been defined in the message !\");\r\n            } else {\r\n                return models;\r\n            }\r\n\r\n        } finally {\r\n            scanner.close();\r\n            ObjectHelper.close(in, \"in\", LOG);\r\n        }\r\n\r\n    }","id":44650,"modified_method":"public Object unmarshal(Exchange exchange, InputStream inputStream) throws Exception {\r\n    \tBindyFixedLengthFactory factory = getFactory(exchange.getContext().getPackageScanClassResolver());\r\n        ObjectHelper.notNull(factory, \"not instantiated\");\r\n\r\n        // List of Pojos\r\n        List<Map<String, Object>> models = new ArrayList<Map<String, Object>>();\r\n\r\n        // Pojos of the model\r\n        Map<String, Object> model;\r\n\r\n        InputStreamReader in = new InputStreamReader(inputStream);\r\n\r\n        // Scanner is used to read big file\r\n        Scanner scanner = new Scanner(in);\r\n\r\n        int count = 0;\r\n\r\n        try {\r\n\r\n            // TODO Test if we have a Header\r\n        \t// TODO Test if we have a Footer (containing by example checksum)\r\n\r\n            while (scanner.hasNextLine()) {\r\n\r\n                // Read the line\r\n                String line = scanner.nextLine().trim();\r\n\r\n                if (ObjectHelper.isEmpty(line)) {\r\n                    // skip if line is empty\r\n                    continue;\r\n                }\r\n\r\n                // Increment counter\r\n                count++;\r\n                \r\n                // Check if the record length corresponds to the parameter\r\n                // provided in the @FixedLengthRecord\r\n                if ((line.length() < factory.recordLength()) || (line.length() > factory.recordLength())){\r\n                \tthrow new java.lang.IllegalArgumentException(\"Size of the record : \" + line.length() + \" is not equal to the value provided in the model : \" + factory.recordLength() + \" !\");\r\n                }\r\n\r\n                // Create POJO where Fixed data will be stored\r\n                model = factory.factory();\r\n                \r\n                // Bind data from Fixed record with model classes\r\n                factory.bind(line, model, count);\r\n\r\n                // Link objects together\r\n                factory.link(model);\r\n\r\n                // Add objects graph to the list\r\n                models.add(model);\r\n\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Graph of objects created : \" + model);\r\n                }\r\n\r\n            }\r\n\r\n            // Test if models list is empty or not\r\n            // If this is the case (correspond to an empty stream, ...)\r\n            if (models.size() == 0) {\r\n                throw new java.lang.IllegalArgumentException(\"No records have been defined in the message !\");\r\n            } else {\r\n                return models;\r\n            }\r\n\r\n        } finally {\r\n            scanner.close();\r\n            ObjectHelper.close(in, \"in\", LOG);\r\n        }\r\n\r\n    }","commit_id":"c3a3ff2b2beaa2e01aff6faf304c54e3255cfa4c","url":"https://github.com/apache/camel"},{"original_method":"public String unbind(Map<String, Object> model) throws Exception {\r\n\r\n        StringBuilder buffer = new StringBuilder();\r\n\r\n        return buffer.toString();\r\n\r\n    }","id":44651,"modified_method":"public String unbind(Map<String, Object> model) throws Exception {\r\n\r\n        StringBuilder buffer = new StringBuilder();\r\n        results = new HashMap<Integer, List>();\r\n\r\n        for (Class clazz : models) {\r\n\r\n            if (model.containsKey(clazz.getName())) {\r\n\r\n                Object obj = model.get(clazz.getName());\r\n\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"Model object : \" + obj + \", class : \" + obj.getClass().getName());\r\n                }\r\n\r\n                if (obj != null) {\r\n\r\n                    // Generate Fixed Length table\r\n                \t// containing the positions of the fields\r\n                    generateFixedLengthPositionMap(clazz, obj);\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        // Convert Map<Integer, List> into List<List>\r\n        TreeMap<Integer, List> sortValues = new TreeMap<Integer, List>(results);\r\n        List<String> temp = new ArrayList<String>();\r\n\r\n        for (Integer key : sortValues.keySet()) {\r\n\r\n            // Get list of values\r\n            List<String> val = sortValues.get(key);\r\n            String value = (String)val.get(0);\r\n            \r\n            buffer.append(value);\r\n\r\n        }\r\n        \r\n        return buffer.toString();\r\n\r\n    }","commit_id":"c3a3ff2b2beaa2e01aff6faf304c54e3255cfa4c","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Feature decodeLoc(String line) {\n        StringTokenizer st = new StringTokenizer(line, DELIMITER);\n        if ( st.countTokens() < 1 )\n            throw new CodecLineParsingException(\"Couldn't parse GenomeLoc out of the following line because there aren't enough tokens.\\nLine: \" + line);\n\n        GenomeLoc loc;\n        String chr = st.nextToken();\n        if ( chr.indexOf(\":\") != -1 )\n            loc = genomeLocParser.parseGenomeInterval(chr);\n        else\n            loc = genomeLocParser.createGenomeLoc(chr, Integer.valueOf(st.nextToken()), Integer.valueOf(st.nextToken()));\n        return new AnnotatorInputTableFeature(loc.getContig(), (int)loc.getStart(), (int)loc.getStop());\n    }","id":44652,"modified_method":"@Override\n    public Feature decodeLoc(String line) {\n        StringTokenizer st = new StringTokenizer(line, DELIMITER);\n        if ( st.countTokens() < 1 )\n            throw new CodecLineParsingException(\"Couldn't parse GenomeLoc out of the following line because there aren't enough tokens.\\nLine: \" + line);\n\n        GenomeLoc loc;\n        String chr = st.nextToken();\n        if ( chr.indexOf(\":\") != -1 ) {\n            loc = genomeLocParser.parseGenomeInterval(chr);\n        } else {\n            if ( st.countTokens() < 3 )\n                throw new CodecLineParsingException(\"Couldn't parse GenomeLoc out of the following line because there aren't enough tokens.\\nLine: \" + line);\n            loc = genomeLocParser.createGenomeLoc(chr, Integer.valueOf(st.nextToken()), Integer.valueOf(st.nextToken()));\n        }\n        return new AnnotatorInputTableFeature(loc.getContig(), loc.getStart(), loc.getStop());\n    }","commit_id":"f1b0f3bc49836a6a7cddf050f6bad1a089a797ee","url":"https://github.com/broadgsa/gatk"},{"original_method":"public IntervalOverlapFilteringIterator(CloseableIterator<SAMRecord> iterator, List<GenomeLoc> intervals) {\n            this.iterator = iterator;\n\n            // Look at the interval list to detect whether we should worry about unmapped reads.\n            // If we find a mix of mapped/unmapped intervals, throw an exception.\n            boolean foundMappedIntervals = false;\n            for(GenomeLoc location: intervals) {\n                if(! GenomeLoc.isUnmapped(location))\n                    foundMappedIntervals = true;\n                keepOnlyUnmappedReads |= GenomeLoc.isUnmapped(location);\n            }\n\n\n            if(foundMappedIntervals) {\n                if(keepOnlyUnmappedReads)\n                    throw new ReviewedStingException(\"Tried to apply IntervalOverlapFilteringIterator to a mixed of mapped and unmapped intervals.  Please apply this filter to only mapped or only unmapped reads\");\n                this.intervalStarts = new int[intervals.size()];\n                this.intervalEnds = new int[intervals.size()];\n                int i = 0;\n                for(GenomeLoc interval: intervals) {\n                    intervalStarts[i] = (int)interval.getStart();\n                    intervalEnds[i] = (int)interval.getStop();\n                    i++;\n                }\n            }\n            \n            advance();\n        }","id":44653,"modified_method":"public IntervalOverlapFilteringIterator(CloseableIterator<SAMRecord> iterator, List<GenomeLoc> intervals) {\n            this.iterator = iterator;\n\n            // Look at the interval list to detect whether we should worry about unmapped reads.\n            // If we find a mix of mapped/unmapped intervals, throw an exception.\n            boolean foundMappedIntervals = false;\n            for(GenomeLoc location: intervals) {\n                if(! GenomeLoc.isUnmapped(location))\n                    foundMappedIntervals = true;\n                keepOnlyUnmappedReads |= GenomeLoc.isUnmapped(location);\n            }\n\n\n            if(foundMappedIntervals) {\n                if(keepOnlyUnmappedReads)\n                    throw new ReviewedStingException(\"Tried to apply IntervalOverlapFilteringIterator to a mixed of mapped and unmapped intervals.  Please apply this filter to only mapped or only unmapped reads\");\n                this.intervalContigIndices = new int[intervals.size()];\n                this.intervalStarts = new int[intervals.size()];\n                this.intervalEnds = new int[intervals.size()];\n                int i = 0;\n                for(GenomeLoc interval: intervals) {\n                    intervalContigIndices[i] = interval.getContigIndex();\n                    intervalStarts[i] = interval.getStart();\n                    intervalEnds[i] = interval.getStop();\n                    i++;\n                }\n            }\n            \n            advance();\n        }","commit_id":"fec495e2928a2dc13e5957ab1f3131b151b18a08","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void advance() {\n            nextRead = null;\n\n            if(!iterator.hasNext())\n                return;\n\n            SAMRecord candidateRead = iterator.next();\n            while(nextRead == null && (keepOnlyUnmappedReads || currentBound < intervalStarts.length)) {\n                if(!keepOnlyUnmappedReads) {\n                    // Mapped read filter; check against GenomeLoc-derived bounds.\n                    if(candidateRead.getAlignmentEnd() >= intervalStarts[currentBound] ||\n                            (candidateRead.getReadUnmappedFlag() && candidateRead.getAlignmentStart() >= intervalStarts[currentBound])) {\n                        // This read ends after the current interval begins (or, if unmapped, starts within the bounds of the interval.\n                        // Promising, but this read must be checked against the ending bound.\n                        if(candidateRead.getAlignmentStart() <= intervalEnds[currentBound]) {\n                            // Yes, this read is within both bounds.  This must be our next read.\n                            nextRead = candidateRead;\n                            break;\n                        }\n                        else {\n                            // Oops, we're past the end bound.  Increment the current bound and try again.\n                            currentBound++;\n                            continue;\n                        }\n                    }\n                }\n                else {\n                    // Found an unmapped read.  We're done.\n                    if(candidateRead.getReadUnmappedFlag()) {\n                        nextRead = candidateRead;\n                        break;\n                    }\n                }\n\n                // No more reads available.  Stop the search.\n                if(!iterator.hasNext())\n                    break;\n\n                // No reasonable read found; advance the iterator.\n                candidateRead = iterator.next();\n            }\n        }","id":44654,"modified_method":"private void advance() {\n            nextRead = null;\n\n            if(!iterator.hasNext())\n                return;\n\n            SAMRecord candidateRead = iterator.next();\n            while(nextRead == null && (keepOnlyUnmappedReads || currentBound < intervalStarts.length)) {\n                if(!keepOnlyUnmappedReads) {\n                    // Mapped read filter; check against GenomeLoc-derived bounds.\n                    if(readEndsOnOrAfterStartingBound(candidateRead)) {\n                        // This read ends after the current interval begins.\n                        // Promising, but this read must be checked against the ending bound.\n                        if(readStartsOnOrBeforeEndingBound(candidateRead)) {\n                            // Yes, this read is within both bounds.  This must be our next read.\n                            nextRead = candidateRead;\n                            break;\n                        }\n                        else {\n                            // Oops, we're past the end bound.  Increment the current bound and try again.\n                            currentBound++;\n                            continue;\n                        }\n                    }\n                }\n                else {\n                    // Found an unmapped read.  We're done.\n                    if(candidateRead.getReadUnmappedFlag()) {\n                        nextRead = candidateRead;\n                        break;\n                    }\n                }\n\n                // No more reads available.  Stop the search.\n                if(!iterator.hasNext())\n                    break;\n\n                // No reasonable read found; advance the iterator.\n                candidateRead = iterator.next();\n            }\n        }","commit_id":"fec495e2928a2dc13e5957ab1f3131b151b18a08","url":"https://github.com/broadgsa/gatk"},{"original_method":"public CloseableIterator<GATKFeature> query(GenomeLoc interval, boolean contained) throws IOException {\n        return new FeatureToGATKFeatureIterator(genomeLocParser,reader.query(interval.getContig(),(int)interval.getStart(),(int)interval.getStop()),this.getName());\n    }","id":44655,"modified_method":"public CloseableIterator<GATKFeature> query(GenomeLoc interval, boolean contained) throws IOException {\n        return new FeatureToGATKFeatureIterator(genomeLocParser,reader.query(interval.getContig(),interval.getStart(),interval.getStop()),this.getName());\n    }","commit_id":"0982d35f5bbe417ec27f15a8f37cc6c809adbe39","url":"https://github.com/broadgsa/gatk"},{"original_method":"public CloseableIterator<GATKFeature> query(GenomeLoc interval) throws IOException {\n        return new FeatureToGATKFeatureIterator(genomeLocParser,reader.query(interval.getContig(),(int)interval.getStart(),(int)interval.getStop()),this.getName());\n    }","id":44656,"modified_method":"public CloseableIterator<GATKFeature> query(GenomeLoc interval) throws IOException {\n        return new FeatureToGATKFeatureIterator(genomeLocParser,reader.query(interval.getContig(),interval.getStart(),interval.getStop()),this.getName());\n    }","commit_id":"0982d35f5bbe417ec27f15a8f37cc6c809adbe39","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testCreateMultipleIterators() {\n        ReferenceOrderedDataPool iteratorPool = new ReferenceOrderedDataPool(rod,seq.getSequenceDictionary(),genomeLocParser,false);\n        LocationAwareSeekableRODIterator iterator1 = iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        // Create a new iterator at position 2.\n        LocationAwareSeekableRODIterator iterator2 = iteratorPool.iterator( new MappedStreamSegment(testSite2) );\n\n        Assert.assertEquals(iteratorPool.numIterators(), 2, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 0, \"Number of available iterators in the pool is incorrect\");\n\n        // Test out-of-order access: first iterator2, then iterator1.\n        // Ugh...first call to a region needs to be a seek. \n        TableFeature datum = (TableFeature)iterator2.seekForward(testSite2).get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite2));\n        assertTrue(datum.get(\"COL1\").equals(\"C\"));\n        assertTrue(datum.get(\"COL2\").equals(\"D\"));\n        assertTrue(datum.get(\"COL3\").equals(\"E\"));\n\n        datum = (TableFeature)iterator1.next().get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        // Advance iterator2, and make sure both iterator's contents are still correct.\n        datum = (TableFeature)iterator2.next().get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite3));\n        assertTrue(datum.get(\"COL1\").equals(\"F\"));\n        assertTrue(datum.get(\"COL2\").equals(\"G\"));\n        assertTrue(datum.get(\"COL3\").equals(\"H\"));\n\n        datum = (TableFeature)iterator1.next().get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite2));\n        assertTrue(datum.get(\"COL1\").equals(\"C\"));\n        assertTrue(datum.get(\"COL2\").equals(\"D\"));\n        assertTrue(datum.get(\"COL3\").equals(\"E\"));\n\n        // Cleanup, and make sure the number of iterators dies appropriately.\n        iteratorPool.release(iterator1);\n\n        Assert.assertEquals(iteratorPool.numIterators(), 2, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 1, \"Number of available iterators in the pool is incorrect\");\n\n        iteratorPool.release(iterator2);\n\n        Assert.assertEquals(iteratorPool.numIterators(), 2, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 2, \"Number of available iterators in the pool is incorrect\");\n    }","id":44657,"modified_method":"@Test\n    public void testCreateMultipleIterators() {\n        ReferenceOrderedQueryDataPool iteratorPool = new ReferenceOrderedQueryDataPool(triplet,builder,seq.getSequenceDictionary(),genomeLocParser);\n        LocationAwareSeekableRODIterator iterator1 = iteratorPool.iterator( new EntireStream() );\n\n        // Create a new iterator at position 2.\n        LocationAwareSeekableRODIterator iterator2 = iteratorPool.iterator( new EntireStream() );\n\n        Assert.assertEquals(iteratorPool.numIterators(), 2, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 0, \"Number of available iterators in the pool is incorrect\");\n\n        // Test out-of-order access: first iterator2, then iterator1.\n        // Ugh...first call to a region needs to be a seek.\n        TableFeature datum = (TableFeature)iterator2.seekForward(testSite2).get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite2));\n        assertTrue(datum.get(\"COL1\").equals(\"C\"));\n        assertTrue(datum.get(\"COL2\").equals(\"D\"));\n        assertTrue(datum.get(\"COL3\").equals(\"E\"));\n\n        datum = (TableFeature)iterator1.next().get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        // Advance iterator2, and make sure both iterator's contents are still correct.\n        datum = (TableFeature)iterator2.next().get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite3));\n        assertTrue(datum.get(\"COL1\").equals(\"F\"));\n        assertTrue(datum.get(\"COL2\").equals(\"G\"));\n        assertTrue(datum.get(\"COL3\").equals(\"H\"));\n\n        datum = (TableFeature)iterator1.next().get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite2));\n        assertTrue(datum.get(\"COL1\").equals(\"C\"));\n        assertTrue(datum.get(\"COL2\").equals(\"D\"));\n        assertTrue(datum.get(\"COL3\").equals(\"E\"));\n\n        // Cleanup, and make sure the number of iterators dies appropriately.\n        iteratorPool.release(iterator1);\n\n        Assert.assertEquals(iteratorPool.numIterators(), 2, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 1, \"Number of available iterators in the pool is incorrect\");\n\n        iteratorPool.release(iterator2);\n\n        Assert.assertEquals(iteratorPool.numIterators(), 2, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 2, \"Number of available iterators in the pool is incorrect\");\n    }","commit_id":"0982d35f5bbe417ec27f15a8f37cc6c809adbe39","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testIteratorConservation() {\n        ReferenceOrderedDataPool iteratorPool = new ReferenceOrderedDataPool(rod,seq.getSequenceDictionary(),genomeLocParser,false);\n        LocationAwareSeekableRODIterator iterator = iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        Assert.assertEquals(iteratorPool.numIterators(), 1, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 0, \"Number of available iterators in the pool is incorrect\");\n\n        TableFeature datum = (TableFeature)iterator.next().get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        iteratorPool.release(iterator);\n\n        // Create another iterator after the current iterator.\n        iterator = iteratorPool.iterator( new MappedStreamSegment(testSite3) );\n\n        // Make sure that the previously acquired iterator was reused.\n        Assert.assertEquals(iteratorPool.numIterators(), 1, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 0, \"Number of available iterators in the pool is incorrect\");\n\n        datum = (TableFeature)iterator.seekForward(testSite3).get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite3));\n        assertTrue(datum.get(\"COL1\").equals(\"F\"));\n        assertTrue(datum.get(\"COL2\").equals(\"G\"));\n        assertTrue(datum.get(\"COL3\").equals(\"H\"));\n\n        iteratorPool.release(iterator);\n\n        Assert.assertEquals(iteratorPool.numIterators(), 1, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 1, \"Number of available iterators in the pool is incorrect\");\n    }","id":44658,"modified_method":"@Test\n    public void testIteratorConservation() {\n        ReferenceOrderedDataPool iteratorPool = new ReferenceOrderedDataPool(triplet,builder,seq.getSequenceDictionary(),genomeLocParser,false);\n        LocationAwareSeekableRODIterator iterator = iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        Assert.assertEquals(iteratorPool.numIterators(), 1, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 0, \"Number of available iterators in the pool is incorrect\");\n\n        TableFeature datum = (TableFeature)iterator.next().get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        iteratorPool.release(iterator);\n\n        // Create another iterator after the current iterator.\n        iterator = iteratorPool.iterator( new MappedStreamSegment(testSite3) );\n\n        // Make sure that the previously acquired iterator was reused.\n        Assert.assertEquals(iteratorPool.numIterators(), 1, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 0, \"Number of available iterators in the pool is incorrect\");\n\n        datum = (TableFeature)iterator.seekForward(testSite3).get(0).getUnderlyingObject();\n        assertTrue(datum.getLocation().equals(testSite3));\n        assertTrue(datum.get(\"COL1\").equals(\"F\"));\n        assertTrue(datum.get(\"COL2\").equals(\"G\"));\n        assertTrue(datum.get(\"COL3\").equals(\"H\"));\n\n        iteratorPool.release(iterator);\n\n        Assert.assertEquals(iteratorPool.numIterators(), 1, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 1, \"Number of available iterators in the pool is incorrect\");\n    }","commit_id":"0982d35f5bbe417ec27f15a8f37cc6c809adbe39","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testCreateSingleIterator() {\n        ResourcePool iteratorPool = new ReferenceOrderedDataPool(rod,seq.getSequenceDictionary(),genomeLocParser,false);\n        LocationAwareSeekableRODIterator iterator = (LocationAwareSeekableRODIterator)iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        Assert.assertEquals(iteratorPool.numIterators(), 1, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 0, \"Number of available iterators in the pool is incorrect\");\n\n        TableFeature datum = (TableFeature)iterator.next().get(0).getUnderlyingObject();\n\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        iteratorPool.release(iterator);\n\n        Assert.assertEquals(iteratorPool.numIterators(), 1, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 1, \"Number of available iterators in the pool is incorrect\");\n    }","id":44659,"modified_method":"@Test\n    public void testCreateSingleIterator() {\n        ResourcePool iteratorPool = new ReferenceOrderedDataPool(triplet,builder,seq.getSequenceDictionary(),genomeLocParser,false);\n        LocationAwareSeekableRODIterator iterator = (LocationAwareSeekableRODIterator)iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        Assert.assertEquals(iteratorPool.numIterators(), 1, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 0, \"Number of available iterators in the pool is incorrect\");\n\n        TableFeature datum = (TableFeature)iterator.next().get(0).getUnderlyingObject();\n\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        iteratorPool.release(iterator);\n\n        Assert.assertEquals(iteratorPool.numIterators(), 1, \"Number of iterators in the pool is incorrect\");\n        Assert.assertEquals(iteratorPool.numAvailableIterators(), 1, \"Number of available iterators in the pool is incorrect\");\n    }","commit_id":"0982d35f5bbe417ec27f15a8f37cc6c809adbe39","url":"https://github.com/broadgsa/gatk"},{"original_method":"@BeforeMethod\n    public void setUp() {\n        String fileName = testDir + \"TabularDataTest.dat\";\n        RMDTrackBuilder builder = new RMDTrackBuilder(seq.getSequenceDictionary(),genomeLocParser,null);\n        rod = builder.createInstanceOfTrack(new RMDTriplet(\"tableTest\",\"Table\",fileName,RMDStorageType.FILE));\n    }","id":44660,"modified_method":"@BeforeMethod\n    public void setUp() {\n        String fileName = testDir + \"TabularDataTest.dat\";\n        triplet = new RMDTriplet(\"tableTest\",\"Table\",fileName,RMDStorageType.FILE);\n        builder = new RMDTrackBuilder(Collections.singletonList(triplet),seq.getSequenceDictionary(),genomeLocParser,null);\n    }","commit_id":"0982d35f5bbe417ec27f15a8f37cc6c809adbe39","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new iterator from the existing reference-ordered data.  This new iterator is expected\n     * to be completely independent of any other iterator.\n     * @return The newly created resource.\n     */\n    public LocationAwareSeekableRODIterator createNewResource() {\n        LocationAwareSeekableRODIterator iter = new SeekableRODIterator(referenceSequenceDictionary,genomeLocParser,track.getIterator());\n        return (flashbackData) ? new FlashBackIterator(iter) : iter;\n    }","id":44661,"modified_method":"/**\n     * Create a new iterator from the existing reference-ordered data.  This new iterator is expected\n     * to be completely independent of any other iterator.\n     * @return The newly created resource.\n     */\n    public LocationAwareSeekableRODIterator createNewResource() {\n        if(numIterators() > 0)\n            throw new ReviewedStingException(\"BUG: Tried to create multiple iterators over streaming ROD interface\");\n        LocationAwareSeekableRODIterator iter = new SeekableRODIterator(referenceSequenceDictionary,genomeLocParser,builder.createInstanceOfTrack(fileDescriptor).getIterator());\n        return (flashbackData) ? new FlashBackIterator(iter) : iter;\n    }","commit_id":"0982d35f5bbe417ec27f15a8f37cc6c809adbe39","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ReferenceOrderedDataPool( RMDTrack track, SAMSequenceDictionary sequenceDictionary,GenomeLocParser genomeLocParser, boolean flashbackData ) {\n        super(sequenceDictionary,genomeLocParser);\n        this.track = track;\n        this.flashbackData = flashbackData;\n    }","id":44662,"modified_method":"public ReferenceOrderedDataPool(RMDTriplet fileDescriptor,RMDTrackBuilder builder,SAMSequenceDictionary sequenceDictionary,GenomeLocParser genomeLocParser,boolean flashbackData) {\n        super(sequenceDictionary,genomeLocParser);\n        this.fileDescriptor = fileDescriptor;\n        this.builder = builder;\n        this.flashbackData = flashbackData;\n\n        // prepopulate one RMDTrack\n        LocationAwareSeekableRODIterator iterator = createNewResource();\n        this.addNewResource(iterator);\n\n        // Pull the proper header and sequence dictionary from the prepopulated track.\n        //this.header = iterator.getHeader();\n        //this.sequenceDictionary = iterator.getSequenceDictionary();\n        this.header = null;\n        this.sequenceDictionary = null;\n    }","commit_id":"0982d35f5bbe417ec27f15a8f37cc6c809adbe39","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new reference-ordered data source.\n     */\n    public ReferenceOrderedDataSource(RMDTriplet fileDescriptor,\n                                      RMDTrackBuilder builder,\n                                      SAMSequenceDictionary referenceSequenceDictionary,\n                                      GenomeLocParser genomeLocParser,\n                                      boolean flashbackData ) {\n        this.fileDescriptor = fileDescriptor;\n        this.builder = builder;\n        if (fileDescriptor.getStorageType() != RMDTriplet.RMDStorageType.STREAM) {\n            iteratorPool = new ReferenceOrderedQueryDataPool(fileDescriptor,\n                                                             builder,\n                                                             referenceSequenceDictionary,\n                                                             genomeLocParser);\n            header = ((ReferenceOrderedQueryDataPool)iteratorPool).getHeader();\n            this.sequenceDictionary = ((ReferenceOrderedQueryDataPool)iteratorPool).getSequenceDictionary();\n        }\n        else {\n            RMDTrack track = builder.createInstanceOfTrack(fileDescriptor);\n            header = track.getHeader();\n            this.sequenceDictionary = track.getSequenceDictionary();\n            iteratorPool = new ReferenceOrderedDataPool(track,referenceSequenceDictionary,genomeLocParser,flashbackData);\n        }\n    }","id":44663,"modified_method":"/**\n     * Create a new reference-ordered data source.\n     */\n    public ReferenceOrderedDataSource(RMDTriplet fileDescriptor,\n                                      RMDTrackBuilder builder,\n                                      SAMSequenceDictionary referenceSequenceDictionary,\n                                      GenomeLocParser genomeLocParser,\n                                      boolean flashbackData ) {\n        this.fileDescriptor = fileDescriptor;\n        this.builder = builder;\n\n        // TODO: Unify the two blocks of code below by creating a ReferenceOrderedDataPool base class of a coherent type (not RMDTrack for one and SeekableIterator for the other).\n        if (fileDescriptor.getStorageType() != RMDTriplet.RMDStorageType.STREAM) {\n            iteratorPool = new ReferenceOrderedQueryDataPool(fileDescriptor,\n                                                             builder,\n                                                             referenceSequenceDictionary,\n                                                             genomeLocParser);\n            this.header = ((ReferenceOrderedQueryDataPool)iteratorPool).getHeader();\n            this.sequenceDictionary = ((ReferenceOrderedQueryDataPool)iteratorPool).getSequenceDictionary();\n        }\n        else {\n            iteratorPool = new ReferenceOrderedDataPool(fileDescriptor,\n                                                        builder,\n                                                        referenceSequenceDictionary,\n                                                        genomeLocParser,\n                                                        flashbackData);\n            this.header = ((ReferenceOrderedDataPool)iteratorPool).getHeader();\n            this.sequenceDictionary = ((ReferenceOrderedDataPool)iteratorPool).getSequenceDictionary();\n        }\n    }","commit_id":"0982d35f5bbe417ec27f15a8f37cc6c809adbe39","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected <M, T> T carryWalkerOverInterval(LocusWindowWalker<M, T> walker, T sum, LocusContext window) {\n        ReferenceIterator refSite = refIter.seekForward(window.getLocation());\n        StringBuffer refBases = new StringBuffer(refSite.getBaseAsString());\n        int locusLength = (int)(window.getLocation().getStop() - window.getLocation().getStart());\n        for ( int i = 0; i < locusLength; i++ ) {\n            refSite = refSite.next();\n            refBases.append(refSite.getBaseAsChar());\n        }\n        window.setReferenceContig(refSite.getCurrentContig());\n\n        // Iterate forward to get all reference ordered data covering this interval\n        final RefMetaDataTracker tracker = getReferenceOrderedDataAtLocus(window.getLocation());\n\n        sum = walkAtinterval( walker, sum, window, refBases.toString(), tracker );\n\n        printProgress(\"intervals\", window.getLocation());\n\n        return sum;\n    }","id":44664,"modified_method":"protected <M, T> T carryWalkerOverInterval(LocusWindowWalker<M, T> walker, T sum, LocusContext window) {\n\n        String refBases = new String(sequenceFile.getSubsequenceAt(window.getContig(),window.getLocation().getStart(),window.getLocation().getStop()).getBases());\n\n        // Iterate forward to get all reference ordered data covering this interval\n        final RefMetaDataTracker tracker = getReferenceOrderedDataAtLocus(window.getLocation());\n\n        sum = walkAtinterval( walker, sum, window, refBases, tracker );\n\n        printProgress(\"intervals\", window.getLocation());\n\n        return sum;\n    }","commit_id":"83816fb8018f33b980c8dbae0bc21409d84c65e8","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Traverse by intervals -- the key driver of linearly ordered traversal of intervals.  Provides reads, RODs, and\n     * the reference base for each interval in the reference to the intervalWalker walker.  Supports all of the\n     * interaction contract implied by the interval walker\n     *\n     * @param walker An interval walker object\n     * @param <M>    MapType -- the result of calling map() on walker\n     * @param <T>    ReduceType -- the result of calling reduce() on the walker\n     * @return 0 on success\n     */\n    protected <M, T> T traverseByIntervals(LocusWindowWalker<M, T> walker, List<GenomeLoc> locations) {\n        logger.debug(\"Entering traverseByIntervals\");\n\n        if(readsFiles.size() > 1)\n            throw new UnsupportedOperationException(\"Cannot do ByInterval traversal on file with multiple inputs.\");        \n\n        samReader = initializeSAMFile(readsFiles.get(0));\n\n        verifySortOrder(true);\n\n        walker.initialize();\n\n        T sum = walker.reduceInit();\n\n        if ( locations.isEmpty() ) {\n            logger.debug(\"There are no intervals provided for the traversal\");\n        } else {\n            if ( !samReader.hasIndex() )\n                Utils.scareUser(\"Processing locations were requested, but no index was found for the input SAM/BAM file. This operation is potentially dangerously slow, aborting.\");\n\n            sum = intervalTraversal(walker, locations, sum);\n        }\n\n        //printOnTraversalDone(\"intervals\", sum);\n        walker.onTraversalDone(sum);\n        return sum;\n    }","id":44665,"modified_method":"/**\n     * Traverse by intervals -- the key driver of linearly ordered traversal of intervals.  Provides reads, RODs, and\n     * the reference base for each interval in the reference to the intervalWalker walker.  Supports all of the\n     * interaction contract implied by the interval walker\n     *\n     * @param walker An interval walker object\n     * @param <M>    MapType -- the result of calling map() on walker\n     * @param <T>    ReduceType -- the result of calling reduce() on the walker\n     * @return 0 on success\n     */\n    protected <M, T> T traverseByIntervals(LocusWindowWalker<M, T> walker, List<GenomeLoc> locations) {\n        logger.debug(\"Entering traverseByIntervals\");\n\n        if(readsFiles.size() > 1)\n            throw new UnsupportedOperationException(\"Cannot do ByInterval traversal on file with multiple inputs.\");        \n\n         try {\n             sequenceFile = new IndexedFastaSequenceFile(GenomeAnalysisEngine.instance.getArguments().referenceFile);\n         }\n         catch ( FileNotFoundException ex ) {\n             throw new StingException(\"No ref!\",ex);\n         }\n\n        samReader = initializeSAMFile(readsFiles.get(0));\n\n        verifySortOrder(true);\n\n        walker.initialize();\n\n        T sum = walker.reduceInit();\n\n        if ( locations.isEmpty() ) {\n            logger.debug(\"There are no intervals provided for the traversal\");\n        } else {\n            if ( !samReader.hasIndex() )\n                Utils.scareUser(\"Processing locations were requested, but no index was found for the input SAM/BAM file. This operation is potentially dangerously slow, aborting.\");\n\n            sum = intervalTraversal(walker, locations, sum);\n        }\n\n        //printOnTraversalDone(\"intervals\", sum);\n        walker.onTraversalDone(sum);\n        return sum;\n    }","commit_id":"83816fb8018f33b980c8dbae0bc21409d84c65e8","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    protected boolean canAuthorizationBeSkipped(Client client,\n                                                UserSubject userSubject,\n                                                List<String> requestedScope,\n                                                List<OAuthPermission> permissions) {\n        return super.canAuthorizationBeSkipped(client, userSubject, requestedScope, permissions);\n    }","id":44666,"modified_method":"@Override\n    protected boolean canAuthorizationBeSkipped(MultivaluedMap<String, String> params,\n                                                Client client,\n                                                UserSubject userSubject,\n                                                List<String> requestedScope,\n                                                List<OAuthPermission> permissions) {\n        List<String> promptValues = OidcUtils.getPromptValues(params);\n        if (promptValues.contains(OidcUtils.PROMPT_CONSENT_VALUE)) {\n            // Displaying the consent screen is preferred by the client\n            return false;\n        }\n        // Check the pre-configured consent\n        boolean preConfiguredConsentForScopes =\n            super.canAuthorizationBeSkipped(params, client, userSubject, requestedScope, permissions);\n        boolean nonePromptRequested = promptValues.contains(OidcUtils.PROMPT_NONE_VALUE);\n        \n        if (nonePromptRequested && !preConfiguredConsentForScopes) {\n            // An error is returned if client does not have pre-configured consent for the requested scopes/claims\n            LOG.log(Level.FINE, \"Prompt 'none' request can not be met\");\n            throw new OAuthServiceException(new OAuthError(OidcUtils.CONSENT_REQUIRED_ERROR));\n        }\n        return !nonePromptRequested && preConfiguredConsentForScopes;\n    }","commit_id":"dda4c7b8298a21e2dce24f72717edf0980285949","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected Response startAuthorization(MultivaluedMap<String, String> params, \n                                          UserSubject userSubject,\n                                          Client client) {    \n        // Validate the prompt - if it contains \"none\" then an error is returned with any other value\n        String prompt = params.getFirst(PROMPT_PARAMETER);\n        if (prompt != null) {\n            String[] promptValues = prompt.trim().split(\" \");\n            if (promptValues.length > 1) {\n                for (String promptValue : promptValues) {\n                    if (\"none\".equals(promptValue)) {\n                        LOG.log(Level.FINE, \"The prompt value {} is invalid\", prompt);\n                        throw new OAuthServiceException(new OAuthError(OAuthConstants.INVALID_REQUEST));\n                    }\n                }\n            }\n        }\n        \n        return super.startAuthorization(params, userSubject, client);\n    }","id":44667,"modified_method":"@Override\n    protected Response startAuthorization(MultivaluedMap<String, String> params, \n                                          UserSubject userSubject,\n                                          Client client) {    \n        // Validate the prompt - if it contains \"none\" then an error is returned with any other value\n        List<String> promptValues = OidcUtils.getPromptValues(params);\n        if (promptValues != null && promptValues.size() > 1 && promptValues.contains(OidcUtils.PROMPT_NONE_VALUE)) {\n            LOG.log(Level.FINE, \"The prompt value {} is invalid\", params.getFirst(OidcUtils.PROMPT_PARAMETER));\n            throw new OAuthServiceException(new OAuthError(OAuthConstants.INVALID_REQUEST));\n        }\n        \n        return super.startAuthorization(params, userSubject, client);\n    }","commit_id":"dda4c7b8298a21e2dce24f72717edf0980285949","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected Response startAuthorization(MultivaluedMap<String, String> params, \n                                          UserSubject userSubject,\n                                          Client client) {    \n        // Validate the nonce, it must be present for the Implicit flow\n        if (params.getFirst(OAuthConstants.NONCE) == null) {\n            LOG.fine(\"A nonce is required for the Implicit flow\");\n            throw new OAuthServiceException(new OAuthError(OAuthConstants.INVALID_REQUEST));\n        }\n        \n        // Validate the prompt - if it contains \"none\" then an error is returned with any other value\n        String prompt = params.getFirst(PROMPT_PARAMETER);\n        if (prompt != null) {\n            String[] promptValues = prompt.trim().split(\" \");\n            if (promptValues.length > 1) {\n                for (String promptValue : promptValues) {\n                    if (\"none\".equals(promptValue)) {\n                        LOG.log(Level.FINE, \"The prompt value {} is invalid\", prompt);\n                        throw new OAuthServiceException(new OAuthError(OAuthConstants.INVALID_REQUEST));\n                    }\n                }\n            }\n        }\n        \n        return super.startAuthorization(params, userSubject, client);\n    }","id":44668,"modified_method":"@Override\n    protected Response startAuthorization(MultivaluedMap<String, String> params, \n                                          UserSubject userSubject,\n                                          Client client) {    \n        // Validate the nonce, it must be present for the Implicit flow\n        if (params.getFirst(OAuthConstants.NONCE) == null) {\n            LOG.fine(\"A nonce is required for the Implicit flow\");\n            throw new OAuthServiceException(new OAuthError(OAuthConstants.INVALID_REQUEST));\n        }\n        \n        // Validate the prompt - if it contains \"none\" then an error is returned with any other value\n        List<String> promptValues = OidcUtils.getPromptValues(params);\n        if (promptValues.size() > 1 && promptValues.contains(OidcUtils.PROMPT_NONE_VALUE)) {\n            LOG.log(Level.FINE, \"The prompt value {} is invalid\", params.getFirst(OidcUtils.PROMPT_PARAMETER));\n            throw new OAuthServiceException(new OAuthError(OAuthConstants.INVALID_REQUEST));\n        }\n        \n        return super.startAuthorization(params, userSubject, client);\n    }","commit_id":"dda4c7b8298a21e2dce24f72717edf0980285949","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected boolean canAuthorizationBeSkipped(Client client,\n                                                UserSubject userSubject,\n                                                List<String> requestedScope,\n                                                List<OAuthPermission> permissions) {\n        return super.canAuthorizationBeSkipped(client, userSubject, requestedScope, permissions);\n    }","id":44669,"modified_method":"@Override\n    protected boolean canAuthorizationBeSkipped(MultivaluedMap<String, String> params,\n                                                Client client,\n                                                UserSubject userSubject,\n                                                List<String> requestedScope,\n                                                List<OAuthPermission> permissions) {\n        List<String> promptValues = OidcUtils.getPromptValues(params);\n        if (promptValues.contains(OidcUtils.PROMPT_CONSENT_VALUE)) {\n            // Displaying the consent screen is preferred by the client\n            return false;\n        }\n        // Check the pre-configured consent\n        boolean preConfiguredConsentForScopes =\n            super.canAuthorizationBeSkipped(params, client, userSubject, requestedScope, permissions);\n        boolean nonePromptRequested = promptValues.contains(OidcUtils.PROMPT_NONE_VALUE);\n        \n        if (nonePromptRequested && !preConfiguredConsentForScopes) {\n            // An error is returned if client does not have pre-configured consent for the requested scopes/claims\n            LOG.log(Level.FINE, \"Prompt 'none' request can not be met\");\n            throw new OAuthServiceException(new OAuthError(OidcUtils.CONSENT_REQUIRED_ERROR));\n        }\n        return !nonePromptRequested && preConfiguredConsentForScopes;\n    }","commit_id":"dda4c7b8298a21e2dce24f72717edf0980285949","url":"https://github.com/apache/cxf"},{"original_method":"protected Response startAuthorization(MultivaluedMap<String, String> params, \n                                          UserSubject userSubject,\n                                          Client client) {    \n        \n        if (authorizationFilter != null) {\n            params = authorizationFilter.process(params, userSubject, client);\n        }\n        \n        // Validate the provided request URI, if any, against the ones Client provided\n        // during the registration\n        String redirectUri = validateRedirectUri(client, params.getFirst(OAuthConstants.REDIRECT_URI)); \n        \n        // Enforce the client confidentiality requirements\n        if (!OAuthUtils.isGrantSupportedForClient(client, canSupportPublicClient(client), supportedGrantType)) {\n            LOG.fine(\"The grant type is not supported\");\n            return createErrorResponse(params, redirectUri, OAuthConstants.UNAUTHORIZED_CLIENT);\n        }\n        \n        // Check response_type\n        String responseType = params.getFirst(OAuthConstants.RESPONSE_TYPE);\n        if (responseType == null || !getSupportedResponseTypes().contains(responseType)) {\n            LOG.fine(\"The response type is null or not supported\");\n            return createErrorResponse(params, redirectUri, OAuthConstants.UNSUPPORTED_RESPONSE_TYPE);\n        }\n        // Get the requested scopes\n        String providedScope = params.getFirst(OAuthConstants.SCOPE);\n        List<String> requestedScope = null;\n        try {\n            requestedScope = OAuthUtils.getRequestedScopes(client, \n                                                           providedScope,\n                                                           useAllClientScopes,\n                                                           partialMatchScopeValidation);\n        } catch (OAuthServiceException ex) {\n            LOG.log(Level.FINE, \"Error parsing scopes\", ex);\n            return createErrorResponse(params, redirectUri, OAuthConstants.INVALID_SCOPE);\n        }\n        // Convert the requested scopes to OAuthPermission instances\n        List<OAuthPermission> requestedPermissions = null;\n        try {\n            requestedPermissions = getDataProvider().convertScopeToPermissions(client, requestedScope);\n        } catch (OAuthServiceException ex) {\n            LOG.log(Level.FINE, \"Error converting scopes into OAuthPermissions\", ex);\n            return createErrorResponse(params, redirectUri, OAuthConstants.INVALID_SCOPE);\n        }\n        // Validate the audience\n        String clientAudience = params.getFirst(OAuthConstants.CLIENT_AUDIENCE);\n        // Right now if the audience parameter is set it is expected to be contained\n        // in the list of Client audiences set at the Client registration time.\n        if (!OAuthUtils.validateAudience(clientAudience, client.getRegisteredAudiences())) {\n            LOG.fine(\"Error validating audience parameter\");\n            throw new OAuthServiceException(new OAuthError(OAuthConstants.INVALID_REQUEST));\n        }\n    \n        // Request a new grant only if no pre-authorized token is available\n        ServerAccessToken preAuthorizedToken = null;\n        if (canAccessTokenBeReturned(responseType)) {\n            preAuthorizedToken = getDataProvider().getPreauthorizedToken(client, requestedScope, userSubject, \n                                                                         supportedGrantType);\n        }\n        \n        List<OAuthPermission> alreadyAuthorizedPerms = null;\n        boolean preAuthorizationComplete = false;\n        if (preAuthorizedToken != null) {\n            alreadyAuthorizedPerms = preAuthorizedToken.getScopes();\n            preAuthorizationComplete = \n                OAuthUtils.convertPermissionsToScopeList(alreadyAuthorizedPerms).containsAll(requestedScope);\n            if (!preAuthorizationComplete) {\n                preAuthorizedToken = null;\n            }\n        }\n        final boolean authorizationCanBeSkipped = preAuthorizationComplete \n            || canAuthorizationBeSkipped(client, userSubject, requestedScope, requestedPermissions);\n        \n        // Populate the authorization challenge data \n        OAuthAuthorizationData data = \n            createAuthorizationData(client, params, redirectUri, userSubject,  \n                                    requestedPermissions, \n                                    alreadyAuthorizedPerms, \n                                    authorizationCanBeSkipped);\n        \n        if (authorizationCanBeSkipped) {\n            getMessageContext().put(AUTHORIZATION_REQUEST_PARAMETERS, params);\n            List<OAuthPermission> approvedScopes = \n                preAuthorizationComplete ? preAuthorizedToken.getScopes() : requestedPermissions; \n            return createGrant(data,\n                               client, \n                               requestedScope,\n                               OAuthUtils.convertPermissionsToScopeList(approvedScopes),\n                               userSubject,\n                               preAuthorizedToken);\n        }\n        \n        return Response.ok(data).build();\n        \n    }","id":44670,"modified_method":"protected Response startAuthorization(MultivaluedMap<String, String> params, \n                                          UserSubject userSubject,\n                                          Client client) {    \n        \n        if (authorizationFilter != null) {\n            params = authorizationFilter.process(params, userSubject, client);\n        }\n        \n        // Validate the provided request URI, if any, against the ones Client provided\n        // during the registration\n        String redirectUri = validateRedirectUri(client, params.getFirst(OAuthConstants.REDIRECT_URI)); \n        \n        // Enforce the client confidentiality requirements\n        if (!OAuthUtils.isGrantSupportedForClient(client, canSupportPublicClient(client), supportedGrantType)) {\n            LOG.fine(\"The grant type is not supported\");\n            return createErrorResponse(params, redirectUri, OAuthConstants.UNAUTHORIZED_CLIENT);\n        }\n        \n        // Check response_type\n        String responseType = params.getFirst(OAuthConstants.RESPONSE_TYPE);\n        if (responseType == null || !getSupportedResponseTypes().contains(responseType)) {\n            LOG.fine(\"The response type is null or not supported\");\n            return createErrorResponse(params, redirectUri, OAuthConstants.UNSUPPORTED_RESPONSE_TYPE);\n        }\n        // Get the requested scopes\n        String providedScope = params.getFirst(OAuthConstants.SCOPE);\n        List<String> requestedScope = null;\n        try {\n            requestedScope = OAuthUtils.getRequestedScopes(client, \n                                                           providedScope,\n                                                           useAllClientScopes,\n                                                           partialMatchScopeValidation);\n        } catch (OAuthServiceException ex) {\n            LOG.log(Level.FINE, \"Error parsing scopes\", ex);\n            return createErrorResponse(params, redirectUri, OAuthConstants.INVALID_SCOPE);\n        }\n        // Convert the requested scopes to OAuthPermission instances\n        List<OAuthPermission> requestedPermissions = null;\n        try {\n            requestedPermissions = getDataProvider().convertScopeToPermissions(client, requestedScope);\n        } catch (OAuthServiceException ex) {\n            LOG.log(Level.FINE, \"Error converting scopes into OAuthPermissions\", ex);\n            return createErrorResponse(params, redirectUri, OAuthConstants.INVALID_SCOPE);\n        }\n        // Validate the audience\n        String clientAudience = params.getFirst(OAuthConstants.CLIENT_AUDIENCE);\n        // Right now if the audience parameter is set it is expected to be contained\n        // in the list of Client audiences set at the Client registration time.\n        if (!OAuthUtils.validateAudience(clientAudience, client.getRegisteredAudiences())) {\n            LOG.fine(\"Error validating audience parameter\");\n            throw new OAuthServiceException(new OAuthError(OAuthConstants.INVALID_REQUEST));\n        }\n    \n        // Request a new grant only if no pre-authorized token is available\n        ServerAccessToken preAuthorizedToken = null;\n        if (canAccessTokenBeReturned(responseType)) {\n            preAuthorizedToken = getDataProvider().getPreauthorizedToken(client, requestedScope, userSubject, \n                                                                         supportedGrantType);\n        }\n        \n        List<OAuthPermission> alreadyAuthorizedPerms = null;\n        boolean preAuthorizationComplete = false;\n        if (preAuthorizedToken != null) {\n            alreadyAuthorizedPerms = preAuthorizedToken.getScopes();\n            preAuthorizationComplete = \n                OAuthUtils.convertPermissionsToScopeList(alreadyAuthorizedPerms).containsAll(requestedScope);\n            if (!preAuthorizationComplete) {\n                preAuthorizedToken = null;\n            }\n        }\n        final boolean authorizationCanBeSkipped = preAuthorizationComplete \n            || canAuthorizationBeSkipped(params, client, userSubject, requestedScope, requestedPermissions);\n        \n        // Populate the authorization challenge data \n        OAuthAuthorizationData data = \n            createAuthorizationData(client, params, redirectUri, userSubject,  \n                                    requestedPermissions, \n                                    alreadyAuthorizedPerms, \n                                    authorizationCanBeSkipped);\n        \n        if (authorizationCanBeSkipped) {\n            getMessageContext().put(AUTHORIZATION_REQUEST_PARAMETERS, params);\n            List<OAuthPermission> approvedScopes = \n                preAuthorizationComplete ? preAuthorizedToken.getScopes() : requestedPermissions; \n            return createGrant(data,\n                               client, \n                               requestedScope,\n                               OAuthUtils.convertPermissionsToScopeList(approvedScopes),\n                               userSubject,\n                               preAuthorizedToken);\n        }\n        \n        return Response.ok(data).build();\n        \n    }","commit_id":"dda4c7b8298a21e2dce24f72717edf0980285949","url":"https://github.com/apache/cxf"},{"original_method":"protected boolean canAuthorizationBeSkipped(Client client, \n                                                UserSubject userSubject,\n                                                List<String> requestedScope, \n                                                List<OAuthPermission> permissions) {\n        return scopesRequiringNoConsent != null \n               && requestedScope != null\n               && requestedScope.size() == scopesRequiringNoConsent.size()\n               && requestedScope.containsAll(scopesRequiringNoConsent);\n    }","id":44671,"modified_method":"protected boolean canAuthorizationBeSkipped(MultivaluedMap<String, String> params,\n                                                Client client, \n                                                UserSubject userSubject,\n                                                List<String> requestedScope, \n                                                List<OAuthPermission> permissions) {\n        return scopesRequiringNoConsent != null \n               && requestedScope != null\n               && requestedScope.size() == scopesRequiringNoConsent.size()\n               && requestedScope.containsAll(scopesRequiringNoConsent);\n    }","commit_id":"dda4c7b8298a21e2dce24f72717edf0980285949","url":"https://github.com/apache/cxf"},{"original_method":"protected Response startAuthorization(MultivaluedMap<String, String> params, \n                                          UserSubject userSubject,\n                                          Client client) {    \n        \n        // Validate the provided request URI, if any, against the ones Client provided\n        // during the registration\n        String redirectUri = validateRedirectUri(client, params.getFirst(OAuthConstants.REDIRECT_URI)); \n        \n        // Enforce the client confidentiality requirements\n        if (!OAuthUtils.isGrantSupportedForClient(client, canSupportPublicClient(client), supportedGrantType)) {\n            return createErrorResponse(params, redirectUri, OAuthConstants.UNAUTHORIZED_CLIENT);\n        }\n        \n        // Check response_type\n        String responseType = params.getFirst(OAuthConstants.RESPONSE_TYPE);\n        if (responseType == null || !supportedResponseTypes.contains(responseType)) {\n            return createErrorResponse(params, redirectUri, OAuthConstants.UNSUPPORTED_RESPONSE_TYPE);\n        }\n        // Get the requested scopes\n        String providedScope = params.getFirst(OAuthConstants.SCOPE);\n        List<String> requestedScope = null;\n        try {\n            requestedScope = OAuthUtils.getRequestedScopes(client, \n                                                           providedScope,\n                                                           useAllClientScopes,\n                                                           partialMatchScopeValidation);\n        } catch (OAuthServiceException ex) {\n            return createErrorResponse(params, redirectUri, OAuthConstants.INVALID_SCOPE);\n        }\n        // Convert the requested scopes to OAuthPermission instances\n        List<OAuthPermission> requestedPermissions = null;\n        try {\n            requestedPermissions = getDataProvider().convertScopeToPermissions(client, requestedScope);\n        } catch (OAuthServiceException ex) {\n            return createErrorResponse(params, redirectUri, OAuthConstants.INVALID_SCOPE);\n        }\n        // Validate the audience\n        String clientAudience = params.getFirst(OAuthConstants.CLIENT_AUDIENCE);\n        // Right now if the audience parameter is set it is expected to be contained\n        // in the list of Client audiences set at the Client registration time.\n        if (!OAuthUtils.validateAudience(clientAudience, client.getRegisteredAudiences())) {\n            throw new OAuthServiceException(new OAuthError(OAuthConstants.INVALID_REQUEST));\n        }\n    \n        // Request a new grant only if no pre-authorized token is available\n        ServerAccessToken preAuthorizedToken = getDataProvider().getPreauthorizedToken(\n            client, requestedScope, userSubject, supportedGrantType);\n        final boolean authorizationCanBeSkipped = \n            preAuthorizedToken != null \n            || canAuthorizationBeSkipped(client, userSubject, requestedScope, requestedPermissions);\n        \n        // Populate the authorization challenge data \n        OAuthAuthorizationData data = \n            createAuthorizationData(client, params, redirectUri, userSubject, requestedScope, \n                                    requestedPermissions, authorizationCanBeSkipped);\n        \n        if (authorizationCanBeSkipped) {\n            List<OAuthPermission> approvedScopes = \n                preAuthorizedToken != null ? preAuthorizedToken.getScopes() : requestedPermissions; \n            return createGrant(data,\n                               client, \n                               requestedScope,\n                               OAuthUtils.convertPermissionsToScopeList(approvedScopes),\n                               userSubject,\n                               preAuthorizedToken);\n        }\n        \n        return Response.ok(data).build();\n        \n    }","id":44672,"modified_method":"protected Response startAuthorization(MultivaluedMap<String, String> params, \n                                          UserSubject userSubject,\n                                          Client client) {    \n        \n        // Validate the provided request URI, if any, against the ones Client provided\n        // during the registration\n        String redirectUri = validateRedirectUri(client, params.getFirst(OAuthConstants.REDIRECT_URI)); \n        \n        // Enforce the client confidentiality requirements\n        if (!OAuthUtils.isGrantSupportedForClient(client, canSupportPublicClient(client), supportedGrantType)) {\n            return createErrorResponse(params, redirectUri, OAuthConstants.UNAUTHORIZED_CLIENT);\n        }\n        \n        // Check response_type\n        String responseType = params.getFirst(OAuthConstants.RESPONSE_TYPE);\n        if (responseType == null || !supportedResponseTypes.contains(responseType)) {\n            return createErrorResponse(params, redirectUri, OAuthConstants.UNSUPPORTED_RESPONSE_TYPE);\n        }\n        // Get the requested scopes\n        String providedScope = params.getFirst(OAuthConstants.SCOPE);\n        List<String> requestedScope = null;\n        try {\n            requestedScope = OAuthUtils.getRequestedScopes(client, \n                                                           providedScope,\n                                                           useAllClientScopes,\n                                                           partialMatchScopeValidation);\n        } catch (OAuthServiceException ex) {\n            return createErrorResponse(params, redirectUri, OAuthConstants.INVALID_SCOPE);\n        }\n        // Convert the requested scopes to OAuthPermission instances\n        List<OAuthPermission> requestedPermissions = null;\n        try {\n            requestedPermissions = getDataProvider().convertScopeToPermissions(client, requestedScope);\n        } catch (OAuthServiceException ex) {\n            return createErrorResponse(params, redirectUri, OAuthConstants.INVALID_SCOPE);\n        }\n        // Validate the audience\n        String clientAudience = params.getFirst(OAuthConstants.CLIENT_AUDIENCE);\n        // Right now if the audience parameter is set it is expected to be contained\n        // in the list of Client audiences set at the Client registration time.\n        if (!OAuthUtils.validateAudience(clientAudience, client.getRegisteredAudiences())) {\n            throw new OAuthServiceException(new OAuthError(OAuthConstants.INVALID_REQUEST));\n        }\n    \n        // Request a new grant only if no pre-authorized token is available\n        ServerAccessToken preAuthorizedToken = getDataProvider().getPreauthorizedToken(\n            client, requestedScope, userSubject, supportedGrantType);\n        final boolean preAuthorizationComplete = preAuthorizedToken != null\n            && OAuthUtils.convertPermissionsToScopeList(preAuthorizedToken.getScopes()).containsAll(requestedScope);\n        final boolean authorizationCanBeSkipped = preAuthorizationComplete \n            || canAuthorizationBeSkipped(client, userSubject, requestedScope, requestedPermissions);\n        \n        // Populate the authorization challenge data \n        OAuthAuthorizationData data = \n            createAuthorizationData(client, params, redirectUri, userSubject, requestedScope, \n                                    requestedPermissions, authorizationCanBeSkipped);\n        \n        if (authorizationCanBeSkipped) {\n            List<OAuthPermission> approvedScopes = \n                preAuthorizedToken != null ? preAuthorizedToken.getScopes() : requestedPermissions; \n            return createGrant(data,\n                               client, \n                               requestedScope,\n                               OAuthUtils.convertPermissionsToScopeList(approvedScopes),\n                               userSubject,\n                               preAuthorizedToken);\n        }\n        \n        return Response.ok(data).build();\n        \n    }","commit_id":"fdfb80cfef02263a66a98ef43beeaa56b76dbd38","url":"https://github.com/apache/cxf"},{"original_method":"private void createUIComponents() {\n    myMainClass = new LabeledComponent<EditorTextFieldWithBrowseButton>();\n    myMainClass.setComponent(new EditorTextFieldWithBrowseButton(myProject, true));\n  }","id":44673,"modified_method":"private void createUIComponents() {\n    myMainClass = new LabeledComponent<EditorTextFieldWithBrowseButton>();\n    myMainClass.setComponent(new EditorTextFieldWithBrowseButton(myProject, true, new JavaCodeFragment.VisibilityChecker() {\n      @Override\n      public Visibility isDeclarationVisible(PsiElement declaration, PsiElement place) {\n        if (declaration instanceof PsiClass) {\n          final PsiClass aClass = (PsiClass)declaration;\n          if (ConfigurationUtil.MAIN_CLASS.value(aClass) && PsiMethodUtil.findMainMethod(aClass) != null) {\n            return Visibility.VISIBLE;\n          }\n        }\n        return Visibility.NOT_VISIBLE;\n      }\n    }));\n  }","commit_id":"e17f6dc08f3c6c5c8ef145001bb2b48963b5676b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Document createDocument(final String text, PsiManager manager, boolean isClassesAccepted) {\n    PsiElement defaultPackage = JavaPsiFacade.getInstance(manager.getProject()).findPackage(\"\");\n    final JavaCodeFragment fragment = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory()\n      .createReferenceCodeFragment(text, defaultPackage, true, isClassesAccepted);\n    fragment.setVisibilityChecker(JavaCodeFragment.VisibilityChecker.EVERYTHING_VISIBLE);\n    return PsiDocumentManager.getInstance(manager.getProject()).getDocument(fragment);\n  }","id":44674,"modified_method":"private static Document createDocument(final String text,\n                                         PsiManager manager,\n                                         boolean isClassesAccepted,\n                                         JavaCodeFragment.VisibilityChecker visibilityChecker) {\n    PsiElement defaultPackage = JavaPsiFacade.getInstance(manager.getProject()).findPackage(\"\");\n    final JavaCodeFragment fragment = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory()\n      .createReferenceCodeFragment(text, defaultPackage, true, isClassesAccepted);\n    fragment.setVisibilityChecker(visibilityChecker);\n    return PsiDocumentManager.getInstance(manager.getProject()).getDocument(fragment);\n  }","commit_id":"e17f6dc08f3c6c5c8ef145001bb2b48963b5676b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public EditorTextFieldWithBrowseButton(Project project, boolean isClassAccepted) {\n    super(new EditorTextField(createDocument(\"\", PsiManager.getInstance(project), isClassAccepted), project, StdFileTypes.JAVA), null);\n  }","id":44675,"modified_method":"public EditorTextFieldWithBrowseButton(Project project, boolean isClassAccepted) {\n    this(project, isClassAccepted, JavaCodeFragment.VisibilityChecker.EVERYTHING_VISIBLE);\n  }","commit_id":"e17f6dc08f3c6c5c8ef145001bb2b48963b5676b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createUIComponents() {\n    myPackage = new LabeledComponent<EditorTextFieldWithBrowseButton>();\n    myPackage.setComponent(new EditorTextFieldWithBrowseButton(myProject, false));\n\n    myClass = new LabeledComponent<EditorTextFieldWithBrowseButton>();\n    myClass.setComponent(new EditorTextFieldWithBrowseButton(myProject, true));\n\n    myMethod = new LabeledComponent<EditorTextFieldWithBrowseButton>();\n    final EditorTextFieldWithBrowseButton textFieldWithBrowseButton = new EditorTextFieldWithBrowseButton(myProject, true);\n    new TextFieldCompletionProvider() {\n      @Override\n      protected void addCompletionVariants(@NotNull String text, int offset, @NotNull String prefix, @NotNull CompletionResultSet result) {\n        final String className = getClassName();\n        if (className.trim().length() == 0) {\n          return;\n        }\n        final PsiClass testClass = getModuleSelector().findClass(className);\n        if (testClass == null) return;\n        final JUnitUtil.TestMethodFilter filter = new JUnitUtil.TestMethodFilter(testClass);\n        for (PsiMethod psiMethod : testClass.getAllMethods()) {\n          if (filter.value(psiMethod)) {\n            result.addElement(LookupElementBuilder.create(psiMethod.getName()));\n          }\n        }\n      }\n    }.apply(textFieldWithBrowseButton.getChildComponent());\n    myMethod.setComponent(textFieldWithBrowseButton);\n  }","id":44676,"modified_method":"private void createUIComponents() {\n    myPackage = new LabeledComponent<EditorTextFieldWithBrowseButton>();\n    myPackage.setComponent(new EditorTextFieldWithBrowseButton(myProject, false));\n\n    myClass = new LabeledComponent<EditorTextFieldWithBrowseButton>();\n    final TestClassBrowser classBrowser = new TestClassBrowser(myProject);\n    myClass.setComponent(new EditorTextFieldWithBrowseButton(myProject, true, new JavaCodeFragment.VisibilityChecker() {\n      @Override\n      public Visibility isDeclarationVisible(PsiElement declaration, PsiElement place) {\n        try {\n          if (declaration instanceof PsiClass && classBrowser.getFilter().isAccepted(((PsiClass)declaration))) {\n            return Visibility.VISIBLE;\n          }\n        }\n        catch (ClassBrowser.NoFilterException e) {\n          return Visibility.NOT_VISIBLE;\n        }\n        return Visibility.NOT_VISIBLE;\n      }\n    }));\n\n    myMethod = new LabeledComponent<EditorTextFieldWithBrowseButton>();\n    final EditorTextFieldWithBrowseButton textFieldWithBrowseButton = new EditorTextFieldWithBrowseButton(myProject, true);\n    new TextFieldCompletionProvider() {\n      @Override\n      protected void addCompletionVariants(@NotNull String text, int offset, @NotNull String prefix, @NotNull CompletionResultSet result) {\n        final String className = getClassName();\n        if (className.trim().length() == 0) {\n          return;\n        }\n        final PsiClass testClass = getModuleSelector().findClass(className);\n        if (testClass == null) return;\n        final JUnitUtil.TestMethodFilter filter = new JUnitUtil.TestMethodFilter(testClass);\n        for (PsiMethod psiMethod : testClass.getAllMethods()) {\n          if (filter.value(psiMethod)) {\n            result.addElement(LookupElementBuilder.create(psiMethod.getName()));\n          }\n        }\n      }\n    }.apply(textFieldWithBrowseButton.getChildComponent());\n    myMethod.setComponent(textFieldWithBrowseButton);\n  }","commit_id":"e17f6dc08f3c6c5c8ef145001bb2b48963b5676b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ClassFilter.ClassFilterWithScope getFilter() throws MessageInfoException {\n    TestNGConfiguration config = new TestNGConfiguration(\"<no-name>\", getProject(), TestNGConfigurationType.getInstance().getConfigurationFactories()[0]);\n    editor.applyEditorTo(config);\n    GlobalSearchScope scope = getSearchScope(config.getModules());\n    if (scope == null) {\n      throw new MessageInfoException(new MessagesEx.MessageInfo(getProject(), \"No classes found in project\", \"Can't Browse Tests\"));\n    }\n    return new TestClassFilter(scope, getProject(), false);\n  }","id":44677,"modified_method":"public ClassFilter.ClassFilterWithScope getFilter() throws MessageInfoException {\n    TestNGConfiguration config = new TestNGConfiguration(\"<no-name>\", getProject(), TestNGConfigurationType.getInstance().getConfigurationFactories()[0]);\n    editor.applyEditorTo(config);\n    GlobalSearchScope scope = getSearchScope(config.getModules());\n    if (scope == null) {\n      throw new MessageInfoException(new MessagesEx.MessageInfo(getProject(), \"No classes found in project\", \"Can't Browse Tests\"));\n    }\n    return new TestClassFilter(scope, getProject(), false);\n  }","commit_id":"e17f6dc08f3c6c5c8ef145001bb2b48963b5676b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createView() {\n    commonParametersPanel.add(commonJavaParameters, BorderLayout.CENTER);\n\n    packageTest.setSelected(false);\n    suiteTest.setSelected(false);\n    suiteTest.setEnabled(true);\n    groupTest.setSelected(false);\n    groupTest.setEnabled(true);\n    classTest.setSelected(false);\n    classTest.setEnabled(true);\n\n    classField.setComponent(new EditorTextFieldWithBrowseButton(project, true));\n\n    final EditorTextFieldWithBrowseButton methodEditorTextField = new EditorTextFieldWithBrowseButton(project, true);\n    new TextFieldCompletionProvider() {\n      @Override\n      protected void addCompletionVariants(@NotNull String text, int offset, @NotNull String prefix, @NotNull CompletionResultSet result) {\n        final String className = getClassName();\n        if (className.trim().length() == 0) {\n          return;\n        }\n        final PsiClass testClass = getModuleSelector().findClass(className);\n        if (testClass == null) return;\n        for (PsiMethod psiMethod : testClass.getAllMethods()) {\n          if (TestNGUtil.hasTest(psiMethod)) {\n            result.addElement(LookupElementBuilder.create(psiMethod.getName()));\n          }\n        }\n      }\n    }.apply(methodEditorTextField.getChildComponent());\n    methodField.setComponent(methodEditorTextField);\n\n    groupField.setComponent(new TextFieldWithBrowseButton.NoPathCompletion());\n    suiteField.setComponent(new TextFieldWithBrowseButton());\n    packageField.setVisible(true);\n    packageField.setEnabled(true);\n    packageField.setComponent(new EditorTextFieldWithBrowseButton(project, false));\n\n\n    TextFieldWithBrowseButton outputDirectoryButton = new TextFieldWithBrowseButton();\n    outputDirectory.setComponent(outputDirectoryButton);\n    outputDirectoryButton.addBrowseFolderListener(\"TestNG\", \"Select test output directory\", project,\n                                                  FileChooserDescriptorFactory.createSingleFolderDescriptor());\n    moduleClasspath.setEnabled(true);\n    moduleClasspath.setComponent(new JComboBox());\n\n    propertiesTableModel = new TestNGParametersTableModel();\n    listenerModel = new TestNGListenersTableModel();\n\n    TextFieldWithBrowseButton textFieldWithBrowseButton = new TextFieldWithBrowseButton();\n    propertiesFile.setComponent(textFieldWithBrowseButton);\n\n    FileChooserDescriptor propertiesFileDescriptor = new FileChooserDescriptor(true, false, false, false, false, false)\n    {\n      @Override\n      public boolean isFileVisible(VirtualFile virtualFile, boolean showHidden) {\n        if (!showHidden && virtualFile.getName().charAt(0) == '.') return false;\n        return virtualFile.isDirectory() || \"properties\".equals(virtualFile.getExtension());\n      }\n    };\n\n    textFieldWithBrowseButton\n        .addBrowseFolderListener(\"TestNG\", \"Select .properties file for test properties\", project, propertiesFileDescriptor);\n\n    propertiesTableView.setModel(propertiesTableModel);\n    propertiesTableView.setShowGrid(true);\n\n    listenersTable.setModel(listenerModel);\n\n    myAddButton.addActionListener(new ActionListener()\n    {\n      public void actionPerformed(ActionEvent e) {\n        propertiesTableModel.addParameter();\n        int index = propertiesTableModel.getRowCount() - 1;\n        propertiesTableView.setRowSelectionInterval(index, index);\n      }\n    });\n    myRemoveButton.addActionListener(new ActionListener()\n    {\n      public void actionPerformed(ActionEvent e) {\n        int idx = propertiesTableView.getSelectedRow() - 1;\n        for (int row : propertiesTableView.getSelectedRows()) {\n          propertiesTableModel.removeProperty(row);\n        }\n        if (idx > -1) propertiesTableView.setRowSelectionInterval(idx, idx);\n      }\n    });\n  }","id":44678,"modified_method":"private void createView() {\n    commonParametersPanel.add(commonJavaParameters, BorderLayout.CENTER);\n\n    packageTest.setSelected(false);\n    suiteTest.setSelected(false);\n    suiteTest.setEnabled(true);\n    groupTest.setSelected(false);\n    groupTest.setEnabled(true);\n    classTest.setSelected(false);\n    classTest.setEnabled(true);\n\n    classField.setComponent(new EditorTextFieldWithBrowseButton(project, true, new JavaCodeFragment.VisibilityChecker() {\n      @Override\n      public Visibility isDeclarationVisible(PsiElement declaration, PsiElement place) {\n        try {\n          if (declaration instanceof PsiClass && \n              new TestClassBrowser(project, TestNGConfigurationEditor.this).getFilter().isAccepted((PsiClass)declaration)) {\n            return Visibility.VISIBLE;\n          }\n        }\n        catch (MessageInfoException e) {\n          return Visibility.NOT_VISIBLE;\n        }\n        return Visibility.NOT_VISIBLE;\n      }\n    }));\n\n    final EditorTextFieldWithBrowseButton methodEditorTextField = new EditorTextFieldWithBrowseButton(project, true);\n    new TextFieldCompletionProvider() {\n      @Override\n      protected void addCompletionVariants(@NotNull String text, int offset, @NotNull String prefix, @NotNull CompletionResultSet result) {\n        final String className = getClassName();\n        if (className.trim().length() == 0) {\n          return;\n        }\n        final PsiClass testClass = getModuleSelector().findClass(className);\n        if (testClass == null) return;\n        for (PsiMethod psiMethod : testClass.getAllMethods()) {\n          if (TestNGUtil.hasTest(psiMethod)) {\n            result.addElement(LookupElementBuilder.create(psiMethod.getName()));\n          }\n        }\n      }\n    }.apply(methodEditorTextField.getChildComponent());\n    methodField.setComponent(methodEditorTextField);\n\n    groupField.setComponent(new TextFieldWithBrowseButton.NoPathCompletion());\n    suiteField.setComponent(new TextFieldWithBrowseButton());\n    packageField.setVisible(true);\n    packageField.setEnabled(true);\n    packageField.setComponent(new EditorTextFieldWithBrowseButton(project, false));\n\n\n    TextFieldWithBrowseButton outputDirectoryButton = new TextFieldWithBrowseButton();\n    outputDirectory.setComponent(outputDirectoryButton);\n    outputDirectoryButton.addBrowseFolderListener(\"TestNG\", \"Select test output directory\", project,\n                                                  FileChooserDescriptorFactory.createSingleFolderDescriptor());\n    moduleClasspath.setEnabled(true);\n    moduleClasspath.setComponent(new JComboBox());\n\n    propertiesTableModel = new TestNGParametersTableModel();\n    listenerModel = new TestNGListenersTableModel();\n\n    TextFieldWithBrowseButton textFieldWithBrowseButton = new TextFieldWithBrowseButton();\n    propertiesFile.setComponent(textFieldWithBrowseButton);\n\n    FileChooserDescriptor propertiesFileDescriptor = new FileChooserDescriptor(true, false, false, false, false, false)\n    {\n      @Override\n      public boolean isFileVisible(VirtualFile virtualFile, boolean showHidden) {\n        if (!showHidden && virtualFile.getName().charAt(0) == '.') return false;\n        return virtualFile.isDirectory() || \"properties\".equals(virtualFile.getExtension());\n      }\n    };\n\n    textFieldWithBrowseButton\n        .addBrowseFolderListener(\"TestNG\", \"Select .properties file for test properties\", project, propertiesFileDescriptor);\n\n    propertiesTableView.setModel(propertiesTableModel);\n    propertiesTableView.setShowGrid(true);\n\n    listenersTable.setModel(listenerModel);\n\n    myAddButton.addActionListener(new ActionListener()\n    {\n      public void actionPerformed(ActionEvent e) {\n        propertiesTableModel.addParameter();\n        int index = propertiesTableModel.getRowCount() - 1;\n        propertiesTableView.setRowSelectionInterval(index, index);\n      }\n    });\n    myRemoveButton.addActionListener(new ActionListener()\n    {\n      public void actionPerformed(ActionEvent e) {\n        int idx = propertiesTableView.getSelectedRow() - 1;\n        for (int row : propertiesTableView.getSelectedRows()) {\n          propertiesTableModel.removeProperty(row);\n        }\n        if (idx > -1) propertiesTableView.setRowSelectionInterval(idx, idx);\n      }\n    });\n  }","commit_id":"e17f6dc08f3c6c5c8ef145001bb2b48963b5676b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkAccess(Class<?> clazz) {\n        if (privileged) {\n            return;\n        }\n        if (Filter.class.isAssignableFrom(clazz)) {\n            checkAccess(clazz, restrictedFilters);\n        } else if (Servlet.class.isAssignableFrom(clazz)) {\n            if (ContainerServlet.class.isAssignableFrom(clazz)) {\n                throw new SecurityException(\"Restricted (ContainerServlet) \" +\n                        clazz);\n            }\n            checkAccess(clazz, restrictedServlets);\n        } else {\n            checkAccess(clazz, restrictedListeners);\n        }\n    }","id":44679,"modified_method":"private void checkAccess(Class<?> clazz) {\n        if (privileged) {\n            return;\n        }\n        if (ContainerServlet.class.isAssignableFrom(clazz)) {\n            throw new SecurityException(sm.getString(\n                    \"defaultInstanceManager.restrictedContainerServlet\", clazz));\n        }\n        while (clazz != null) {\n            if (restrictedClasses.contains(clazz.getName())) {\n                throw new SecurityException(sm.getString(\n                        \"defaultInstanceManager.restrictedClass\", clazz));\n            }\n            clazz = clazz.getSuperclass();\n        }\n    }","commit_id":"ebf661c8400d475e07bc90505a09b2fca7d255a2","url":"https://github.com/apache/tomcat"},{"original_method":"public DefaultInstanceManager(Context context,\n            Map<String, Map<String, String>> injectionMap,\n            org.apache.catalina.Context catalinaContext,\n            ClassLoader containerClassLoader) {\n        classLoader = catalinaContext.getLoader().getClassLoader();\n        privileged = catalinaContext.getPrivileged();\n        this.containerClassLoader = containerClassLoader;\n        ignoreAnnotations = catalinaContext.getIgnoreAnnotations();\n        Log log = catalinaContext.getLogger();\n        restrictedServlets = loadProperties(\n                \"org/apache/catalina/core/RestrictedServlets.properties\",\n                \"defaultInstanceManager.restrictedServletsResource\", log);\n        restrictedListeners = loadProperties(\n                \"org/apache/catalina/core/RestrictedListeners.properties\",\n                \"defaultInstanceManager.restrictedListenersResource\", log);\n        restrictedFilters = loadProperties(\n                \"org/apache/catalina/core/RestrictedFilters.properties\",\n                \"defaultInstanceManager.restrictedFiltersResource\", log);\n        this.context = context;\n        this.injectionMap = injectionMap;\n        this.postConstructMethods = catalinaContext.findPostConstructMethods();\n        this.preDestroyMethods = catalinaContext.findPreDestroyMethods();\n    }","id":44680,"modified_method":"public DefaultInstanceManager(Context context,\n            Map<String, Map<String, String>> injectionMap,\n            org.apache.catalina.Context catalinaContext,\n            ClassLoader containerClassLoader) {\n        classLoader = catalinaContext.getLoader().getClassLoader();\n        privileged = catalinaContext.getPrivileged();\n        this.containerClassLoader = containerClassLoader;\n        ignoreAnnotations = catalinaContext.getIgnoreAnnotations();\n        Log log = catalinaContext.getLogger();\n        Set<String> classNames = new HashSet<>();\n        loadProperties(classNames,\n                \"org/apache/catalina/core/RestrictedServlets.properties\",\n                \"defaultInstanceManager.restrictedServletsResource\", log);\n        loadProperties(classNames,\n                \"org/apache/catalina/core/RestrictedListeners.properties\",\n                \"defaultInstanceManager.restrictedListenersResource\", log);\n        loadProperties(classNames,\n                \"org/apache/catalina/core/RestrictedFilters.properties\",\n                \"defaultInstanceManager.restrictedFiltersResource\", log);\n        restrictedClasses = Collections.unmodifiableSet(classNames);\n        this.context = context;\n        this.injectionMap = injectionMap;\n        this.postConstructMethods = catalinaContext.findPostConstructMethods();\n        this.preDestroyMethods = catalinaContext.findPreDestroyMethods();\n    }","commit_id":"ebf661c8400d475e07bc90505a09b2fca7d255a2","url":"https://github.com/apache/tomcat"},{"original_method":"private static Properties loadProperties(String resourceName, String messageKey, Log log) {\n        Properties result = new Properties();\n        ClassLoader cl = DefaultInstanceManager.class.getClassLoader();\n        try (InputStream is = cl.getResourceAsStream(resourceName)) {\n            if (is == null) {\n                log.error(sm.getString(messageKey, resourceName));\n            } else {\n                result.load(is);\n            }\n        } catch (IOException ioe) {\n            log.error(sm.getString(messageKey, resourceName), ioe);\n        }\n        return result;\n    }","id":44681,"modified_method":"private static void loadProperties(Set<String> classNames, String resourceName,\n            String messageKey, Log log) {\n        Properties properties = new Properties();\n        ClassLoader cl = DefaultInstanceManager.class.getClassLoader();\n        try (InputStream is = cl.getResourceAsStream(resourceName)) {\n            if (is == null) {\n                log.error(sm.getString(messageKey, resourceName));\n            } else {\n                properties.load(is);\n            }\n        } catch (IOException ioe) {\n            log.error(sm.getString(messageKey, resourceName), ioe);\n        }\n        if (properties.isEmpty()) {\n            return;\n        }\n        for (Map.Entry<Object, Object> e : properties.entrySet()) {\n            if (\"restricted\".equals(e.getValue())) {\n                classNames.add(e.getKey().toString());\n            } else {\n                log.warn(sm.getString(\n                        \"defaultInstanceManager.restrictedWrongValue\",\n                        resourceName, e.getKey(), e.getValue()));\n            }\n        }\n    }","commit_id":"ebf661c8400d475e07bc90505a09b2fca7d255a2","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        ReplicatedMapProxy that = (ReplicatedMapProxy) o;\n\n        if (!replicatedRecordStore.equals(that.replicatedRecordStore)) return false;\n\n        return true;\n    }","id":44682,"modified_method":"public boolean storageEquals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        if (!super.equals(o)) return false;\n\n        ReplicatedMapProxy that = (ReplicatedMapProxy) o;\n\n        if (!replicatedRecordStore.equals(that.replicatedRecordStore)) return false;\n\n        return true;\n    }","commit_id":"60b07649cb438cef6c9aa40d07542aa1695cd5e0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void equalsTest(InMemoryFormat inMemoryFormat) throws Exception {\n        TestHazelcastInstanceFactory nodeFactory = createHazelcastInstanceFactory(2);\n        Config cfg = new Config();\n        cfg.getReplicatedMapConfig(\"default\").setInMemoryFormat(inMemoryFormat);\n\n        cfg.getReplicatedMapConfig(\"default\").setReplicationDelayMillis(0);\n\n        HazelcastInstance instance1 = nodeFactory.newHazelcastInstance(cfg);\n        HazelcastInstance instance2 = nodeFactory.newHazelcastInstance(cfg);\n\n        final ReplicatedMap<Object, Integer> map1 = instance1.getReplicatedMap(\"default\");\n        final ReplicatedMap<Object, Integer> map2 = instance2.getReplicatedMap(\"default\");\n\n        for (int i = 0; i < 1000; i++) {\n            map1.put(i, i);\n        }\n\n        final Comparator<Integer> comparator = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o1.compareTo(o2);\n            }\n        };\n\n        HazelcastTestSupport.assertTrueEventually(new AssertTask() {\n            public void run() {\n                assertEquals(1000, map1.size());\n                assertEquals(1000, map2.size());\n\n                assertTrue(map1.equals(map2));\n\n                assertEquals(map1.entrySet(), map2.entrySet());\n                assertEquals(map1.values(comparator), map2.values(comparator));\n            }\n        });\n    }","id":44683,"modified_method":"private void equalsTest(InMemoryFormat inMemoryFormat) throws Exception {\n        TestHazelcastInstanceFactory nodeFactory = createHazelcastInstanceFactory(2);\n        Config cfg = new Config();\n        cfg.getReplicatedMapConfig(\"default\").setInMemoryFormat(inMemoryFormat);\n\n        cfg.getReplicatedMapConfig(\"default\").setReplicationDelayMillis(0);\n\n        HazelcastInstance instance1 = nodeFactory.newHazelcastInstance(cfg);\n        HazelcastInstance instance2 = nodeFactory.newHazelcastInstance(cfg);\n\n        final ReplicatedMapProxy<Object, Integer> map1 = (ReplicatedMapProxy) instance1.getReplicatedMap(\"default\");\n        final ReplicatedMapProxy<Object, Integer> map2 = (ReplicatedMapProxy) instance2.getReplicatedMap(\"default\");\n\n        for (int i = 0; i < 1000; i++) {\n            map1.put(i, i);\n        }\n\n        final Comparator<Integer> comparator = new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o1.compareTo(o2);\n            }\n        };\n\n        HazelcastTestSupport.assertTrueEventually(new AssertTask() {\n            public void run() {\n                assertEquals(1000, map1.size());\n                assertEquals(1000, map2.size());\n\n                assertTrue(map1.equals(map2));\n                assertTrue(map1.storageEquals(map2));\n\n                assertEquals(map1.entrySet(), map2.entrySet());\n                assertEquals(map1.values(comparator), map2.values(comparator));\n            }\n        });\n    }","commit_id":"60b07649cb438cef6c9aa40d07542aa1695cd5e0","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private void sameMap_putTTLandPut_allMostSimil_repDelay0(InMemoryFormat inMemoryFormat) throws Exception {\n        TestHazelcastInstanceFactory nodeFactory = createHazelcastInstanceFactory(2);\n        Config cfg = new Config();\n        cfg.getReplicatedMapConfig(\"default\").setInMemoryFormat(inMemoryFormat);\n\n        cfg.getReplicatedMapConfig(\"default\").setReplicationDelayMillis(0);\n\n        HazelcastInstance instance1 = nodeFactory.newHazelcastInstance(cfg);\n        HazelcastInstance instance2 = nodeFactory.newHazelcastInstance(cfg);\n\n        final ReplicatedMap<Object, Object> map1 = instance1.getReplicatedMap(\"default\");\n        final ReplicatedMap<Object, Object> map2 = instance2.getReplicatedMap(\"default\");\n\n        map1.put(1, 1, 1, TimeUnit.MINUTES);\n        map1.put(1, 1);\n\n        HazelcastTestSupport.assertTrueEventually(new AssertTask() {\n            public void run() {\n                assertEquals(map1.get(1), map2.get(1));\n            }\n        });\n\n        map1.put(1, 1, 1, TimeUnit.MINUTES);\n\n        HazelcastTestSupport.assertTrueEventually(new AssertTask() {\n            public void run() {\n                assertEquals(map1.get(1), map2.get(1));\n            }\n        });\n    }","id":44684,"modified_method":"private void sameMap_putTTLandPut_allMostSimil_repDelay0(InMemoryFormat inMemoryFormat) throws Exception {\n        TestHazelcastInstanceFactory nodeFactory = createHazelcastInstanceFactory(2);\n        Config cfg = new Config();\n        cfg.getReplicatedMapConfig(\"default\").setInMemoryFormat(inMemoryFormat);\n\n        cfg.getReplicatedMapConfig(\"default\").setReplicationDelayMillis(0);\n\n        HazelcastInstance instance1 = nodeFactory.newHazelcastInstance(cfg);\n        HazelcastInstance instance2 = nodeFactory.newHazelcastInstance(cfg);\n\n        final ReplicatedMapProxy<Object, Object> map1 = (ReplicatedMapProxy) instance1.getReplicatedMap(\"default\");\n        final ReplicatedMapProxy<Object, Object> map2 = (ReplicatedMapProxy) instance2.getReplicatedMap(\"default\");\n\n        CountDownLatch replicateLatch = new CountDownLatch(1);\n        CountDownLatch startReplication = new CountDownLatch(2);\n        PreReplicationHook hook = createReplicationHook(replicateLatch, startReplication);\n        map1.setPreReplicationHook(hook);\n\n        map1.put(1, 1, 1, TimeUnit.MINUTES);\n        map1.put(1, 1);\n\n        startReplication.await(1, TimeUnit.MINUTES);\n        replicateLatch.countDown();\n\n        HazelcastTestSupport.assertTrueEventually(new AssertTask() {\n            public void run() {\n                assertEquals(map1.get(1), map2.get(1));\n            }\n        });\n\n        map1.put(1, 1, 1, TimeUnit.MINUTES);\n\n        HazelcastTestSupport.assertTrueEventually(new AssertTask() {\n            public void run() {\n                assertEquals(map1.get(1), map2.get(1));\n            }\n        });\n    }","commit_id":"2cbdc6e7905af4f5c1c9098d58bc996cd2066f5d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\r\n   * Resolves a QName.\r\n   * @param ctx query context\r\n   * @param q qname\r\n   * @param it item\r\n   * @return prefix sequence\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item resolve(final QueryContext ctx, final Item q, final Item it)\r\n      throws QueryException {\r\n\r\n    final byte[] name = trim(checkStr(q));\r\n    if(!XMLToken.isQName(name)) Err.value(Type.QNM, q);\r\n\r\n    final QNm nm = new QNm(name);\r\n    final byte[] pref = nm.pref();\r\n    byte[] uri = ((Nod) check(it, Type.ELM)).uri(pref);\r\n    if(uri == null) {\r\n      if(pref.length != 0) Err.or(NSDECL, pref);\r\n      uri = ctx.nsElem;\r\n    }\r\n    nm.uri = Uri.uri(uri);\r\n    return nm;\r\n  }","id":44685,"modified_method":"/**\r\n   * Resolves a QName.\r\n   * @param ctx query context\r\n   * @param q qname\r\n   * @param it item\r\n   * @return prefix sequence\r\n   * @throws QueryException query exception\r\n   */\r\n  private Item resolve(final QueryContext ctx, final Item q, final Item it)\r\n      throws QueryException {\r\n\r\n    final byte[] name = trim(checkStr(q));\r\n    if(!XMLToken.isQName(name)) Err.value(Type.QNM, q);\r\n\r\n    final QNm nm = new QNm(name);\r\n    final byte[] pref = nm.pref();\r\n    byte[] uri = ((Nod) check(it, Type.ELM)).uri(pref, ctx);\r\n    if(uri == null && pref.length != 0) Err.or(NSDECL, pref);\r\n    nm.uri = Uri.uri(uri);\r\n    return nm;\r\n  }","commit_id":"588153be5111db84cac0b32f1df39a7b6fa986b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Seq atomic(final QueryContext ctx) throws QueryException {\n    final Constr c = new Constr(ctx, expr[1]);\n    final NodIter seq = c.children;\n    final NodIter aSeq = c.ats;\n    if(c.errAtt) Err.or(UPNOATTRPER);\n    if(c.duplAtt != null) Err.or(UPATTDUPL, c.duplAtt);\n\n    // check target constraints\n    final Iter t = expr[0].iter(ctx);\n    Item i = t.next();\n    if(i == null) Err.or(UPSEQEMP, this);\n    if(!(i instanceof Nod) || t.next() != null)\n      Err.or(before || after ? UPTRGTYP2 : UPTRGTYP, this);\n\n    final Nod n = (Nod) i;\n    final Nod par = n.parent();\n    if(before || after) {\n      if(n.type == Type.ATT || n.type == Type.DOC) Err.or(UPTRGTYP2, this);\n      if(par == null) Err.or(UPPAREMPTY, this);\n    } else {\n      if(n.type != Type.ELM && n.type != Type.DOC) Err.or(UPTRGTYP, this);\n    }\n\n    UpdatePrimitive up = null;\n    if(aSeq.size() > 0) {\n      if(before || after) {\n        if(par.type != Type.ELM) Err.or(UPATTDOC, this);\n//        if(!UpdateFunctions.checkAttNames(par.attr(), aSeq, null))\n//          Err.or(UPATTDUPL, n.nname());\n        up = new InsertAttribute(par, aSeq);\n      } else {\n        if(n.type != Type.ELM) Err.or(UPWRTRGTYP2, this);\n//        if(!UpdateFunctions.checkAttNames(n.attr(), aSeq, null))\n//          Err.or(UPATTDUPL, n.nname());\n        up = new InsertAttribute(n, aSeq);\n      }\n      ctx.updates.add(up, ctx);\n    }\n    if(seq.size() > 0) {\n      if(before) {\n        up = new InsertBefore(n, seq);\n      } else if(after) {\n        up = new InsertAfter(n, seq);\n      } else if(first) {\n        up = new InsertIntoFirst(n, seq);\n      } else {\n        up = new InsertInto(n, seq, last);\n      }\n      ctx.updates.add(up, ctx);\n    }\n    return Seq.EMPTY;\n  }","id":44686,"modified_method":"@Override\n  public Seq atomic(final QueryContext ctx) throws QueryException {\n    final Constr c = new Constr(ctx, expr[1]);\n    final NodIter cList = c.children;\n    final NodIter aList = c.ats;\n    if(c.errAtt) Err.or(UPNOATTRPER);\n    if(c.duplAtt != null) Err.or(UPATTDUPL, c.duplAtt);\n\n    // check target constraints\n    final Iter t = expr[0].iter(ctx);\n    Item i = t.next();\n    if(i == null) Err.or(UPSEQEMP, this);\n    if(!(i instanceof Nod) || t.next() != null)\n      Err.or(before || after ? UPTRGTYP2 : UPTRGTYP, this);\n\n    final Nod n = (Nod) i;\n    final Nod par = n.parent();\n    if(before || after) {\n      if(n.type == Type.ATT || n.type == Type.DOC) Err.or(UPTRGTYP2, this);\n      if(par == null) Err.or(UPPAREMPTY, this);\n    } else {\n      if(n.type != Type.ELM && n.type != Type.DOC) Err.or(UPTRGTYP, this);\n    }\n\n    UpdatePrimitive up = null;\n    if(aList.size() > 0) {\n      final Nod tar = before || after ? par : n;\n      if(tar.type != Type.ELM)\n        Err.or(before || after ? UPATTELM : UPATTELM2, this);\n\n      //if(!UpdateFunctions.checkAttNames(tar.attr(), aSeq, null))\n      //Err.or(UPATTDUPL, tar.nname());\n\n      for(int a = 0; a < aList.size(); a++) {\n        final QNm name = aList.get(a).qname();\n        final byte[] uri = tar.uri(name.pref(), ctx);\n        if(uri != null && !eq(name.uri.str(), uri)) Err.or(UPCONFNS);\n      }\n      \n      up = new InsertAttribute(tar, aList);\n      ctx.updates.add(up, ctx);\n    }\n\n    if(cList.size() > 0) {\n      if(before) {\n        up = new InsertBefore(n, cList);\n      } else if(after) {\n        up = new InsertAfter(n, cList);\n      } else if(first) {\n        up = new InsertIntoFirst(n, cList);\n      } else {\n        up = new InsertInto(n, cList, last);\n      }\n      ctx.updates.add(up, ctx);\n    }\n    return Seq.EMPTY;\n  }","commit_id":"588153be5111db84cac0b32f1df39a7b6fa986b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public Item get(final long i) {\r\n    return i < size ? item[(int) i] : null;\r\n  }","id":44687,"modified_method":"@Override\r\n  public Nod get(final long i) {\r\n    return i < size ? item[(int) i] : null;\r\n  }","commit_id":"588153be5111db84cac0b32f1df39a7b6fa986b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public Seq atomic(final QueryContext ctx) throws QueryException {\n    final Iter t = expr[0].iter(ctx);\n    final Item i = t.next();\n\n    // check target constraints\n    if(i == null) Err.or(UPSEQEMP, this);\n    if(t.next() != null) Err.or(UPWRTRGTYP, this);\n\n    CFrag ex = null;\n    if(i.type == Type.ELM) {\n      ex = new CElem(expr[1], new Expr[0], new Atts());\n    } else if(i.type == Type.ATT) {\n      ex = new CAttr(expr[1], new Expr[0], false);\n    } else if(i.type == Type.PI) {\n      ex = new CPI(expr[1], Seq.EMPTY);\n    } else {\n      Err.or(UPWRTRGTYP, this);\n    }\n\n    // check namespace conflicts...\n    final QNm name = ex.atomic(ctx).qname();\n    final Nod tar = (Nod) i;\n    final Nod test = i.type == Type.ELM ? tar :\n      i.type == Type.ATT ? tar.parent() : null;\n\n    if(test != null) {\n      byte[] uri = test.uri(name.pref());\n      if(uri == null && name.pref().length == 0) uri = ctx.nsElem;\n      if(uri != null && !eq(name.uri.str(), uri)) Err.or(UPCONFNS);\n    }\n\n    ctx.updates.add(new RenamePrimitive(tar, name), ctx);\n    return Seq.EMPTY;\n  }","id":44688,"modified_method":"@Override\n  public Seq atomic(final QueryContext ctx) throws QueryException {\n    final Iter t = expr[0].iter(ctx);\n    final Item i = t.next();\n\n    // check target constraints\n    if(i == null) Err.or(UPSEQEMP, this);\n    if(t.next() != null) Err.or(UPWRTRGTYP, this);\n\n    CFrag ex = null;\n    if(i.type == Type.ELM) {\n      ex = new CElem(expr[1], new Expr[0], new Atts());\n    } else if(i.type == Type.ATT) {\n      ex = new CAttr(expr[1], new Expr[0], false);\n    } else if(i.type == Type.PI) {\n      ex = new CPI(expr[1], Seq.EMPTY);\n    } else {\n      Err.or(UPWRTRGTYP, this);\n    }\n\n    // check namespace conflicts...\n    final QNm name = ex.atomic(ctx).qname();\n    final Nod tar = (Nod) i;\n    final Nod test = i.type == Type.ELM ? tar :\n      i.type == Type.ATT ? tar.parent() : null;\n\n    if(test != null) {\n      final byte[] uri = test.uri(name.pref(), ctx);\n      if(uri != null && !eq(name.uri.str(), uri)) Err.or(UPCONFNS);\n    }\n\n    ctx.updates.add(new RenamePrimitive(tar, name), ctx);\n    return Seq.EMPTY;\n  }","commit_id":"588153be5111db84cac0b32f1df39a7b6fa986b8","url":"https://github.com/BaseXdb/basex"},{"original_method":"public AuthenticationProtocolHandler(HttpClient client)\n    {\n        this.client = client;\n    }","id":44689,"modified_method":"public AuthenticationProtocolHandler(HttpClient client)\n    {\n        this(client, 4096);\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public WWWAuthenticate(String type, String realm, String params)\n        {\n            this.type = type;\n            this.realm = realm;\n            this.params = params;\n        }","id":44690,"modified_method":"public WWWAuthenticate(String value, String type, String realm)\n        {\n            this.value = value;\n            this.type = type;\n            this.realm = realm;\n        }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Response.Listener getResponseListener()\n    {\n        return this;\n    }","id":44691,"modified_method":"@Override\n    public Response.Listener getResponseListener()\n    {\n        return new AuthenticationListener();\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean authenticate(Request request, String params, Attributes context)\n    {\n        String encoding = StringUtil.__ISO_8859_1;\n        try\n        {\n            String value = \"Basic \" + B64Code.encode(user + \":\" + password, encoding);\n            request.header(HttpHeader.AUTHORIZATION.asString(), value);\n        }\n        catch (UnsupportedEncodingException x)\n        {\n            throw new UnsupportedCharsetException(encoding);\n        }\n    }","id":44692,"modified_method":"@Override\n    public Result authenticate(Request request, ContentResponse response, String wwwAuthenticate, Attributes context)\n    {\n        String encoding = StringUtil.__ISO_8859_1;\n        try\n        {\n            String value = \"Basic \" + B64Code.encode(user + \":\" + password, encoding);\n            return new BasicResult(request.uri(), value);\n        }\n        catch (UnsupportedEncodingException x)\n        {\n            throw new UnsupportedCharsetException(encoding);\n        }\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private Map<String, String> parseParams(String paramString)\n    {\n        Map<String, String> result = new HashMap<>();\n        List<String> parts = splitParams(paramString);\n        for (String part : parts)\n        {\n            Matcher matcher = PARAM_PATTERN.matcher(part);\n            if (matcher.matches())\n                result.put(matcher.group(1).trim().toLowerCase(), matcher.group(2).trim());\n        }\n        return result;\n    }","id":44693,"modified_method":"private Map<String, String> parseParams(String wwwAuthenticate)\n    {\n        Map<String, String> result = new HashMap<>();\n        List<String> parts = splitParams(wwwAuthenticate);\n        for (String part : parts)\n        {\n            Matcher matcher = PARAM_PATTERN.matcher(part);\n            if (matcher.matches())\n            {\n                String name = matcher.group(1).trim().toLowerCase();\n                String value = matcher.group(2).trim();\n                if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\"))\n                    value = value.substring(1, value.length() - 1);\n                result.put(name, value);\n            }\n        }\n        return result;\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean authenticate(Request request, String paramString, Attributes context)\n    {\n        Map<String, String> params = parseParams(paramString);\n        String nonce = params.get(\"nonce\");\n        if (nonce == null || nonce.length() == 0)\n            return false;\n        String opaque = params.get(\"opaque\");\n        String algorithm = params.get(\"algorithm\");\n        if (algorithm == null)\n            algorithm = \"MD5\";\n        MessageDigest digester = getMessageDigest(algorithm);\n        if (digester == null)\n            return false;\n        String serverQOP = params.get(\"qop\");\n        String clientQOP = null;\n        if (serverQOP != null)\n        {\n            List<String> serverQOPValues = Arrays.asList(serverQOP.split(\",\"));\n            if (serverQOPValues.contains(\"auth\"))\n                clientQOP = \"auth\";\n            else if (serverQOPValues.contains(\"auth-int\"))\n                clientQOP = \"auth-int\";\n        }\n\n        String hash = compute(digester, clientQOP, content, nonce);\n\n        StringBuilder value = new StringBuilder(\"Digest\");\n        value.append(\" username=\\\"\").append(user).append(\"\\\"\");\n        value.append(\", realm=\\\"\").append(realm).append(\"\\\"\");\n        value.append(\", nonce=\\\"\").append(nonce).append(\"\\\"\");\n        if (opaque != null)\n            value.append(\", opaque=\\\"\").append(opaque).append(\"\\\"\");\n        value.append(\", algorithm=\\\"\").append(algorithm).append(\"\\\"\");\n        value.append(\", uri=\\\"\").append(request.uri()).append(\"\\\"\");\n        if (clientQOP != null)\n            value.append(\", qop=\\\"\").append(clientQOP).append(\"\\\"\");\n        value.append(\", response=\\\"\").append(hash).append(\"\\\"\");\n\n        request.header(HttpHeader.AUTHORIZATION.asString(), value.toString());\n    }","id":44694,"modified_method":"@Override\n    public Result authenticate(Request request, ContentResponse response, String wwwAuthenticate, Attributes context)\n    {\n        // Avoid case sensitivity problems on the 'D' character\n        String type = \"igest\";\n        wwwAuthenticate = wwwAuthenticate.substring(wwwAuthenticate.indexOf(type) + type.length());\n\n        Map<String, String> params = parseParams(wwwAuthenticate);\n        String nonce = params.get(\"nonce\");\n        if (nonce == null || nonce.length() == 0)\n            return null;\n        String opaque = params.get(\"opaque\");\n        String algorithm = params.get(\"algorithm\");\n        if (algorithm == null)\n            algorithm = \"MD5\";\n        MessageDigest digester = getMessageDigest(algorithm);\n        if (digester == null)\n            return null;\n        String serverQOP = params.get(\"qop\");\n        String clientQOP = null;\n        if (serverQOP != null)\n        {\n            List<String> serverQOPValues = Arrays.asList(serverQOP.split(\",\"));\n            if (serverQOPValues.contains(\"auth\"))\n                clientQOP = \"auth\";\n            else if (serverQOPValues.contains(\"auth-int\"))\n                clientQOP = \"auth-int\";\n        }\n\n        return new DigestResult(request.uri(), response.content(), realm, user, password, algorithm, nonce, clientQOP, opaque);\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private List<String> splitParams(String paramString)\n    {\n        List<String> result = new ArrayList<>();\n        int start = 0;\n        for (int i = 0; i < paramString.length(); ++i)\n        {\n            int quotes = 0;\n            char ch = paramString.charAt(i);\n            switch (ch)\n            {\n                case '\"':\n                    ++quotes;\n                    break;\n                case ',':\n                    if (quotes % 2 == 0)\n                    {\n                        result.add(paramString.substring(start, i).trim());\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        result.add(paramString.substring(start, paramString.length()).trim());\n        return result;\n    }","id":44695,"modified_method":"private List<String> splitParams(String paramString)\n    {\n        List<String> result = new ArrayList<>();\n        int start = 0;\n        for (int i = 0; i < paramString.length(); ++i)\n        {\n            int quotes = 0;\n            char ch = paramString.charAt(i);\n            switch (ch)\n            {\n                case '\\\\':\n                    ++i;\n                    break;\n                case '\"':\n                    ++quotes;\n                    break;\n                case ',':\n                    if (quotes % 2 == 0)\n                    {\n                        result.add(paramString.substring(start, i).trim());\n                        start = i + 1;\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        result.add(paramString.substring(start, paramString.length()).trim());\n        return result;\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public Authentication findAuthenticationResult(String uri)\n    {\n        // TODO: I should match the longest URI\n        for (Map.Entry<String, Authentication> entry : results.entrySet())\n        {\n            if (uri.startsWith(entry.getKey()))\n                return entry.getValue();\n        }\n        return null;\n    }","id":44696,"modified_method":"@Override\n    public Authentication.Result findAuthenticationResult(String uri)\n    {\n        // TODO: I should match the longest URI\n        for (Map.Entry<String, Authentication.Result> entry : results.entrySet())\n        {\n            if (uri.startsWith(entry.getKey()))\n                return entry.getValue();\n        }\n        return null;\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void addAuthenticationResult(Authentication.Result result)\n    {\n        results.put(result.getURI(), result.getAuthentication());\n    }","id":44697,"modified_method":"@Override\n    public void addAuthenticationResult(Authentication.Result result)\n    {\n        results.put(result.getURI(), result);\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void test_DigestAuthentication() throws Exception\n    {\n        startDigest(new EmptyHandler());\n        test_Authentication(new DigestAuthentication(\"http://localhost:\" + connector.getLocalPort(), realm));\n    }","id":44698,"modified_method":"@Test\n    public void test_DigestAuthentication() throws Exception\n    {\n        startDigest(new EmptyHandler());\n        test_Authentication(new DigestAuthentication(\"http://localhost:\" + connector.getLocalPort(), realm, \"digest\", \"digest\"));\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void test_Authentication(Authentication authentication) throws Exception\n    {\n        AuthenticationStore authenticationStore = client.getAuthenticationStore();\n\n        final AtomicInteger requests = new AtomicInteger();\n        Request.Listener.Adapter requestListener = new Request.Listener.Adapter()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                requests.incrementAndGet();\n            }\n        };\n        client.getRequestListeners().add(requestListener);\n\n        // Request without Authentication causes a 401\n        Request request = client.newRequest(\"localhost\", connector.getLocalPort()).path(\"/test\");\n        ContentResponse response = request.send().get(5, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(401, response.status());\n        Assert.assertEquals(1, requests.get());\n        client.getRequestListeners().remove(requestListener);\n        requests.set(0);\n\n        authenticationStore.addAuthentication(authentication);\n\n        requestListener = new Request.Listener.Adapter()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                requests.incrementAndGet();\n            }\n        };\n        client.getRequestListeners().add(requestListener);\n\n        // Request with authentication causes a 401 (no previous successful authentication) + 200\n        response = request.send().get(5, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.status());\n        Assert.assertEquals(2, requests.get());\n        client.getRequestListeners().remove(requestListener);\n        requests.set(0);\n\n        requestListener = new Request.Listener.Adapter()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                requests.incrementAndGet();\n            }\n        };\n        client.getRequestListeners().add(requestListener);\n\n        // Further requests do not trigger 401 because there is a previous successful authentication\n        // Remove existing header to be sure it's added by the implementation\n        request.header(HttpHeader.AUTHORIZATION.asString(), null);\n        response = request.send().get(555, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.status());\n        Assert.assertEquals(1, requests.get());\n        client.getRequestListeners().remove(requestListener);\n        requests.set(0);\n    }","id":44699,"modified_method":"private void test_Authentication(Authentication authentication) throws Exception\n    {\n        AuthenticationStore authenticationStore = client.getAuthenticationStore();\n\n        final AtomicInteger requests = new AtomicInteger();\n        Request.Listener.Adapter requestListener = new Request.Listener.Adapter()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                requests.incrementAndGet();\n            }\n        };\n        client.getRequestListeners().add(requestListener);\n\n        // Request without Authentication causes a 401\n        Request request = client.newRequest(\"localhost\", connector.getLocalPort()).path(\"/test\");\n        ContentResponse response = request.send().get(555, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(401, response.status());\n        Assert.assertEquals(1, requests.get());\n        client.getRequestListeners().remove(requestListener);\n        requests.set(0);\n\n        authenticationStore.addAuthentication(authentication);\n\n        requestListener = new Request.Listener.Adapter()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                requests.incrementAndGet();\n            }\n        };\n        client.getRequestListeners().add(requestListener);\n\n        // Request with authentication causes a 401 (no previous successful authentication) + 200\n        response = request.send().get(555, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.status());\n        Assert.assertEquals(2, requests.get());\n        client.getRequestListeners().remove(requestListener);\n        requests.set(0);\n\n        requestListener = new Request.Listener.Adapter()\n        {\n            @Override\n            public void onSuccess(Request request)\n            {\n                requests.incrementAndGet();\n            }\n        };\n        client.getRequestListeners().add(requestListener);\n\n        // Further requests do not trigger 401 because there is a previous successful authentication\n        // Remove existing header to be sure it's added by the implementation\n        request.header(HttpHeader.AUTHORIZATION.asString(), null);\n        response = request.send().get(555, TimeUnit.SECONDS);\n        Assert.assertNotNull(response);\n        Assert.assertEquals(200, response.status());\n        Assert.assertEquals(1, requests.get());\n        client.getRequestListeners().remove(requestListener);\n        requests.set(0);\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void normalizeRequest(Request request)\n    {\n        if (request.method() == null)\n            request.method(HttpMethod.GET);\n\n        if (request.version() == null)\n            request.version(HttpVersion.HTTP_1_1);\n\n        if (request.agent() == null)\n            request.agent(client.getUserAgent());\n\n        if (request.idleTimeout() <= 0)\n            request.idleTimeout(client.getIdleTimeout());\n\n        // TODO: follow redirects\n\n        HttpVersion version = request.version();\n        HttpFields headers = request.headers();\n        ContentProvider content = request.content();\n\n        // Make sure the path is there\n        String path = request.path();\n        if (path.matches(\"\\\\s*\"))\n            request.path(\"/\");\n\n        // Add content headers\n        if (content != null)\n        {\n            long contentLength = content.length();\n            if (contentLength >= 0)\n            {\n                if (!headers.containsKey(HttpHeader.CONTENT_LENGTH.asString()))\n                    headers.put(HttpHeader.CONTENT_LENGTH, String.valueOf(contentLength));\n            }\n            else\n            {\n                if (!headers.containsKey(HttpHeader.TRANSFER_ENCODING.asString()))\n                    headers.put(HttpHeader.TRANSFER_ENCODING, \"chunked\");\n            }\n        }\n\n        // Cookies\n        List<HttpCookie> cookies = client.getCookieStore().getCookies(getDestination(), request.path());\n        StringBuilder cookieString = null;\n        for (int i = 0; i < cookies.size(); ++i)\n        {\n            if (cookieString == null)\n                cookieString = new StringBuilder();\n            if (i > 0)\n                cookieString.append(\"; \");\n            HttpCookie cookie = cookies.get(i);\n            cookieString.append(cookie.getName()).append(\"=\").append(cookie.getValue());\n        }\n        if (cookieString != null)\n            request.header(HttpHeader.COOKIE.asString(), cookieString.toString());\n\n        // Authorization\n        Authentication authentication = client.getAuthenticationStore().findAuthenticationResult(request.uri());\n        if (authentication != null)\n            authentication.authenticate(request);\n\n        // TODO: decoder headers\n\n        // If we are HTTP 1.1, add the Host header\n        if (version.getVersion() > 10)\n        {\n            if (!headers.containsKey(HttpHeader.HOST.asString()))\n            {\n                String value = request.host();\n                int port = request.port();\n                if (port > 0)\n                    value += \":\" + port;\n                headers.put(HttpHeader.HOST, value);\n            }\n        }\n    }","id":44700,"modified_method":"private void normalizeRequest(Request request)\n    {\n        if (request.method() == null)\n            request.method(HttpMethod.GET);\n\n        if (request.version() == null)\n            request.version(HttpVersion.HTTP_1_1);\n\n        if (request.agent() == null)\n            request.agent(client.getUserAgent());\n\n        if (request.idleTimeout() <= 0)\n            request.idleTimeout(client.getIdleTimeout());\n\n        // TODO: follow redirects\n\n        HttpVersion version = request.version();\n        HttpFields headers = request.headers();\n        ContentProvider content = request.content();\n\n        // Make sure the path is there\n        String path = request.path();\n        if (path.matches(\"\\\\s*\"))\n            request.path(\"/\");\n\n        // Add content headers\n        if (content != null)\n        {\n            long contentLength = content.length();\n            if (contentLength >= 0)\n            {\n                if (!headers.containsKey(HttpHeader.CONTENT_LENGTH.asString()))\n                    headers.put(HttpHeader.CONTENT_LENGTH, String.valueOf(contentLength));\n            }\n            else\n            {\n                if (!headers.containsKey(HttpHeader.TRANSFER_ENCODING.asString()))\n                    headers.put(HttpHeader.TRANSFER_ENCODING, \"chunked\");\n            }\n        }\n\n        // Cookies\n        List<HttpCookie> cookies = client.getCookieStore().getCookies(getDestination(), request.path());\n        StringBuilder cookieString = null;\n        for (int i = 0; i < cookies.size(); ++i)\n        {\n            if (cookieString == null)\n                cookieString = new StringBuilder();\n            if (i > 0)\n                cookieString.append(\"; \");\n            HttpCookie cookie = cookies.get(i);\n            cookieString.append(cookie.getName()).append(\"=\").append(cookie.getValue());\n        }\n        if (cookieString != null)\n            request.header(HttpHeader.COOKIE.asString(), cookieString.toString());\n\n        // Authorization\n        Authentication.Result authnResult = client.getAuthenticationStore().findAuthenticationResult(request.uri());\n        if (authnResult != null)\n            authnResult.apply(request);\n\n        // TODO: decoder headers\n\n        // If we are HTTP 1.1, add the Host header\n        if (version.getVersion() > 10)\n        {\n            if (!headers.containsKey(HttpHeader.HOST.asString()))\n            {\n                String value = request.host();\n                int port = request.port();\n                if (port > 0)\n                    value += \":\" + port;\n                headers.put(HttpHeader.HOST, value);\n            }\n        }\n    }","commit_id":"f5d68f0caf664986c24e5c2a5e11b25f61b55605","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Produces\n    public ProducerTemplate createProducerTemplate(InjectionPoint point) {\n        ProducerTemplate producerTemplate = camelContext.createProducerTemplate();\n        Produce annotation = point.getAnnotated().getAnnotation(Produce.class);\n        if (annotation != null) {\n            String uri = annotation.uri();\n            String ref = annotation.ref();\n            String property = annotation.property();\n            if (ObjectHelper.isEmpty(uri)) {\n                if (ObjectHelper.isNotEmpty(ref)) {\n                    uri = \"ref:\" + ref;\n                } else {\n                    ObjectHelper.notEmpty(property, \"uri, ref or property\", annotation);\n                    // now lets get the property value\n                    throw new UnsupportedOperationException(\"property not yet supported\");\n                }\n            }\n            producerTemplate.setDefaultEndpointUri(uri);\n        }\n        return producerTemplate;\n    }","id":44701,"modified_method":"@Produces\n    public ProducerTemplate createProducerTemplate(InjectionPoint point) {\n        ProducerTemplate producerTemplate = camelContext.createProducerTemplate();\n        Annotated annotated = point.getAnnotated();\n        Uri uri = annotated.getAnnotation(Uri.class);\n        Endpoint endpoint = null;\n        if (uri != null) {\n            endpoint = CamelContextHelper.getMandatoryEndpoint(camelContext, uri.value());\n        } else {\n            Produce annotation = annotated.getAnnotation(Produce.class);\n            if (annotation != null) {\n                endpoint = getEndpoint(point, annotation.uri(), annotation.ref(), annotation.property());\n            }\n        }\n        if (endpoint != null) {\n            producerTemplate.setDefaultEndpoint(endpoint);\n        }\n        return producerTemplate;\n    }","commit_id":"2723b3820808be4c2163b4d4b01db85edd34ac57","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    @Produces\n    public Endpoint createEndpoint(InjectionPoint point) {\n        Class<? extends Endpoint> endpointType = Endpoint.class;\n        Type pointType = point.getType();\n        if (pointType instanceof Class<?>) {\n            endpointType = (Class<? extends Endpoint>)pointType;\n        }\n        EndpointInject annotation = point.getAnnotated().getAnnotation(EndpointInject.class);\n        if (annotation != null) {\n            String uri = annotation.uri();\n            if (ObjectHelper.isEmpty(uri)) {\n                String ref = annotation.ref();\n                if (ObjectHelper.isNotEmpty(ref)) {\n                    uri = \"ref:\" + ref;\n                } else {\n\n                }\n            }\n            return camelContext.getEndpoint(uri, endpointType);\n        }\n        throw new IllegalArgumentException(\n                \"Could not create instance of Endpoint for the given injection point \" + point);\n    }","id":44702,"modified_method":"@SuppressWarnings(\"unchecked\")\n    @Produces\n    public Endpoint createEndpoint(InjectionPoint point, BeanManager beanManager) {\n        Annotated annotated = point.getAnnotated();\n        Uri uri = annotated.getAnnotation(Uri.class);\n        if (uri != null) {\n            return CamelContextHelper.getMandatoryEndpoint(camelContext, uri.value());\n        }\n        EndpointInject annotation = annotated.getAnnotation(EndpointInject.class);\n        ObjectHelper.notNull(annotation, \"Must be annotated with @EndpointInject\");\n        return getEndpoint(point, annotation.uri(), annotation.ref(), annotation.property());\n    }","commit_id":"2723b3820808be4c2163b4d4b01db85edd34ac57","url":"https://github.com/apache/camel"},{"original_method":"@Produces\n    @Mock\n    public MockEndpoint createMockEndpoint(InjectionPoint point) {\n        String url = \"\";\n        String name = \"\";\n        EndpointInject annotation = point.getAnnotated().getAnnotation(EndpointInject.class);\n        if (annotation != null) {\n            url = annotation.uri();\n            name = annotation.ref();\n        }\n        if (ObjectHelper.isEmpty(name)) {\n            name = point.getMember().getName();\n        }\n        if (ObjectHelper.isEmpty(url)) {\n            url = \"mock:\" + name;\n        }\n        return camelContext.getEndpoint(url, MockEndpoint.class);\n    }","id":44703,"modified_method":"@Produces\n    @Mock\n    public MockEndpoint createMockEndpoint(InjectionPoint point) {\n        String uri = \"\";\n        String ref = \"\";\n        EndpointInject annotation = point.getAnnotated().getAnnotation(EndpointInject.class);\n        if (annotation != null) {\n            uri = annotation.uri();\n            ref = annotation.ref();\n        }\n        if (ObjectHelper.isEmpty(ref)) {\n            ref = point.getMember().getName();\n        }\n        if (ObjectHelper.isEmpty(uri)) {\n            uri = \"mock:\" + ref;\n        }\n        return CamelContextHelper.getMandatoryEndpoint(camelContext, uri, MockEndpoint.class);\n    }","commit_id":"2723b3820808be4c2163b4d4b01db85edd34ac57","url":"https://github.com/apache/camel"},{"original_method":"protected Endpoint getEndpointInjection(Object bean, String uri, String name, String propertyName,\n                                            String injectionPointName, boolean mandatory) {\n        if (ObjectHelper.isEmpty(uri) && ObjectHelper.isEmpty(name)) {\n            // if no uri or ref, then fallback and try the endpoint property\n            return doGetEndpointInjection(bean, propertyName, injectionPointName);\n        } else {\n            return doGetEndpointInjection(uri, name, injectionPointName, mandatory);\n        }\n    }","id":44704,"modified_method":"public Endpoint getEndpointInjection(Object bean, String uri, String name, String propertyName,\n                                            String injectionPointName, boolean mandatory) {\n        if (ObjectHelper.isEmpty(uri) && ObjectHelper.isEmpty(name)) {\n            // if no uri or ref, then fallback and try the endpoint property\n            return doGetEndpointInjection(bean, propertyName, injectionPointName);\n        } else {\n            return doGetEndpointInjection(uri, name, injectionPointName, mandatory);\n        }\n    }","commit_id":"2723b3820808be4c2163b4d4b01db85edd34ac57","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void shouldInjectEndpoint() {\n        assertNotNull(bean);\n        ProducerTemplate producer = bean.getProducer();\n        assertNotNull(\"Could not find injected producer!\", producer);\n        assertEquals(\"producer default URI\", \"mock://foo\", producer.getDefaultEndpoint().getEndpointUri());\n    }","id":44705,"modified_method":"@Test\n    public void shouldInjectEndpoint() {\n        assertNotNull(bean);\n        ProducerTemplate producer = bean.getProducer();\n        assertNotNull(\"Could not find injected producer!\", producer);\n        assertEquals(\"producer default URI\", \"mock://foo\", producer.getDefaultEndpoint().getEndpointUri());\n\n        ProducerTemplate producer2 = bean.getProducer2();\n        assertNotNull(\"Could not find injected producer2!\", producer2);\n        assertEquals(\"producer2 default URI\", \"mock://bar\", producer2.getDefaultEndpoint().getEndpointUri());\n    }","commit_id":"2723b3820808be4c2163b4d4b01db85edd34ac57","url":"https://github.com/apache/camel"},{"original_method":"@Override\n  protected AnAction[] createActions(final ConsoleView console, final ProcessHandler processHandler, final Executor executor) {\n    // These action is effectively added only to the Run tool window. For Debug see DartCommandLineDebugProcess.registerAdditionalActions()\n    final AnAction[] actions = super.createActions(console, processHandler, executor);\n    final AnAction[] newActions = new AnAction[actions.length + 2];\n    System.arraycopy(actions, 0, newActions, 0, actions.length);\n\n    newActions[newActions.length - 2] = new Separator();\n\n    newActions[newActions.length - 1] =\n      new OpenDartObservatoryUrlAction(\"http://\" + NetUtils.getLocalHostString() + \":\" + myObservatoryPort,\n                                       () -> !processHandler.isProcessTerminated());\n\n    return newActions;\n  }","id":44706,"modified_method":"@Override\n  protected AnAction[] createActions(final ConsoleView console, final ProcessHandler processHandler, final Executor executor) {\n    // These actions are effectively added only to the Run tool window. For Debug see DartCommandLineDebugProcess.registerAdditionalActions()\n    final List<AnAction> actions = new ArrayList(Arrays.asList(super.createActions(console, processHandler, executor)));\n    addObservatoryActions(actions, processHandler);\n    return actions.toArray(new AnAction[actions.size()]);\n  }","commit_id":"0fbdb4eff05c74dfee519f6852bc77e0531e231a","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected List<SubstituteAction> createActions() {\n    List<SubstituteAction> actions = new ArrayList<>();\n    actions.addAll(myOldSubstituteInfo.createActions());\n    actions.addAll(myNewSubstituteInfo.createActions());\n    return actions;\n  }","id":44707,"modified_method":"@Override\n  protected List<SubstituteAction> createActions() {\n    final SNode sourceNode = myNewSubstituteInfo.getSourceNode();\n    if (sourceNode == null) {\n      return new ArrayList<>();\n    }\n    if (OldNewSubstituteUtil.areOldActionsApplicable(sourceNode.getConcept(), myOldSubstituteInfo.getEditorContext().getRepository())) {\n      return myOldSubstituteInfo.createActions();\n    } else {\n      return myNewSubstituteInfo.createActions();\n    }\n  }","commit_id":"236f40c4b0c3bd1e99b6e6b8992de5c0422e29c9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean areOldActionsApplicable(SNode concept, SRepository repository) {\n    if (concept == null) {\n      return false;\n    }\n    final SModel model = concept.getModel();\n    if (model == null) {\n      return false;\n    }\n    final SModule module = model.getModule();\n\n    final LanguageRuntime actionsLanguageRuntime = LanguageRegistry.getInstance(repository).getLanguage(ACTIONS_LANG);\n    if (actionsLanguageRuntime == null) {\n      return false;\n    }\n    final SLanguage language = MetaAdapterFactory.getLanguage(actionsLanguageRuntime.getId(), ACTIONS_LANG);\n    final int usedLanguageVersion = module.getUsedLanguageVersion(language);\n    return usedLanguageVersion <= 0;\n  }","id":44708,"modified_method":"public static boolean areOldActionsApplicable(SNode concept, SRepository repository) {\n    if (concept == null) {\n      return false;\n    }\n    final SModel model = concept.getModel();\n    if (model == null) {\n      return false;\n    }\n    final SModule module = model.getModule();\n\n    final LanguageRuntime actionsLanguageRuntime = LanguageRegistry.getInstance(repository).getLanguage(ACTIONS_LANG);\n    if (actionsLanguageRuntime == null) {\n      return false;\n    }\n    final SLanguage language = MetaAdapterFactory.getLanguage(actionsLanguageRuntime.getId(), ACTIONS_LANG);\n    if (!module.getUsedLanguages().contains(language)) {\n      return true;\n    }\n    final int usedLanguageVersion = module.getUsedLanguageVersion(language);\n    return usedLanguageVersion <= 0;\n  }","commit_id":"236f40c4b0c3bd1e99b6e6b8992de5c0422e29c9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void sendData(LiveMonitoringData data) {\n\t\tString st = settings.LIVE_MONITORING_URL.get();\n\t\tList<String> prm = new ArrayList<String>();\n\t\tint maxLen = 0;\n\t\tfor(int i = 0; i < 7; i++) {\n\t\t\tboolean b = st.contains(\"{\"+i+\"}\");\n\t\t\tif(b) {\n\t\t\t\tmaxLen = i;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < maxLen + 1; i++) {\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tprm.add(data.lat + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tprm.add(data.lon + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tprm.add(data.time + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tprm.add(data.hdop + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tprm.add(data.alt + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tprm.add(data.speed + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tprm.add(data.bearing + \"\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tString url = MessageFormat.format(st, prm.toArray());\n\t\ttry {\n\n\t\t\tHttpParams params = new BasicHttpParams();\n\t\t\tHttpConnectionParams.setConnectionTimeout(params, 15000);\n\t\t\tDefaultHttpClient httpclient = new DefaultHttpClient(params);\n\t\t\t// Parse the URL and let the URI constructor handle proper encoding of special characters such as spaces\n\t\t\tURL u = new URL(url);\n\t\t\tURI uri = new URI(u.getProtocol(), u.getAuthority(), u.getHost(), u.getPort(), u.getPath(), u.getQuery(), u.getRef());\n\t\t\tHttpRequestBase method = new HttpGet(uri);\n\t\t\tlog.info(\"Monitor \" + uri);\n\t\t\tHttpResponse response = httpclient.execute(method);\n\t\t\t\n\t\t\tif(response.getStatusLine() == null || \n\t\t\t\tresponse.getStatusLine().getStatusCode() != 200){\n\t\t\t\t\n\t\t\t\tString msg;\n\t\t\t\tif(response.getStatusLine() == null){\n\t\t\t\t\tmsg = ctx.getString(R.string.failed_op); //$NON-NLS-1$\n\t\t\t\t} else {\n\t\t\t\t\tmsg = response.getStatusLine().getStatusCode() + \" : \" + //$NON-NLS-1$//$NON-NLS-2$\n\t\t\t\t\t\t\tresponse.getStatusLine().getReasonPhrase();\n\t\t\t\t}\n\t\t\t\tlog.error(\"Error sending monitor request: \" +  msg);\n\t\t\t} else {\n\t\t\t\tInputStream is = response.getEntity().getContent();\n\t\t\t\tStringBuilder responseBody = new StringBuilder();\n\t\t\t\tif (is != null) {\n\t\t\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(is, \"UTF-8\")); //$NON-NLS-1$\n\t\t\t\t\tString s;\n\t\t\t\t\twhile ((s = in.readLine()) != null) {\n\t\t\t\t\t\tresponseBody.append(s);\n\t\t\t\t\t\tresponseBody.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t\thttpclient.getConnectionManager().shutdown();\n\t\t\t\tlog.info(\"Monitor response (\" + response.getFirstHeader(\"Content-Type\") + \"): \" + responseBody.toString());\n\t\t\t}\n\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"Failed connect to \" + url + \": \" + e.getMessage(), e);\n\t\t}\n\t}","id":44709,"modified_method":"public void sendData(LiveMonitoringData data) {\n\t\tString st = settings.LIVE_MONITORING_URL.get();\n\t\tList<String> prm = new ArrayList<String>();\n\t\tint maxLen = 0;\n\t\tfor(int i = 0; i < 7; i++) {\n\t\t\tboolean b = st.contains(\"{\"+i+\"}\");\n\t\t\tif(b) {\n\t\t\t\tmaxLen = i;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < maxLen + 1; i++) {\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tprm.add(data.lat + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tprm.add(data.lon + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tprm.add(data.time + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tprm.add(data.hdop + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tprm.add(data.alt + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tprm.add(data.speed + \"\");\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tprm.add(data.bearing + \"\");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tString url = MessageFormat.format(st, prm.toArray());\n\t\ttry {\n\n\t\t\tHttpParams params = new BasicHttpParams();\n\t\t\tHttpConnectionParams.setConnectionTimeout(params, 15000);\n\t\t\tDefaultHttpClient httpclient = new DefaultHttpClient(params);\n\t\t\t// Parse the URL and let the URI constructor handle proper encoding of special characters such as spaces\n\t\t\tURL u = new URL(url);\n\t\t\tURI uri = new URI(u.getProtocol(), u.getUserInfo(), u.getHost(), u.getPort(), u.getPath(), u.getQuery(), u.getRef());\n\t\t\tHttpRequestBase method = new HttpGet(uri);\n\t\t\tlog.info(\"Monitor \" + uri);\n\t\t\tHttpResponse response = httpclient.execute(method);\n\t\t\t\n\t\t\tif(response.getStatusLine() == null || \n\t\t\t\tresponse.getStatusLine().getStatusCode() != 200){\n\t\t\t\t\n\t\t\t\tString msg;\n\t\t\t\tif(response.getStatusLine() == null){\n\t\t\t\t\tmsg = ctx.getString(R.string.failed_op); //$NON-NLS-1$\n\t\t\t\t} else {\n\t\t\t\t\tmsg = response.getStatusLine().getStatusCode() + \" : \" + //$NON-NLS-1$//$NON-NLS-2$\n\t\t\t\t\t\t\tresponse.getStatusLine().getReasonPhrase();\n\t\t\t\t}\n\t\t\t\tlog.error(\"Error sending monitor request: \" +  msg);\n\t\t\t} else {\n\t\t\t\tInputStream is = response.getEntity().getContent();\n\t\t\t\tStringBuilder responseBody = new StringBuilder();\n\t\t\t\tif (is != null) {\n\t\t\t\t\tBufferedReader in = new BufferedReader(new InputStreamReader(is, \"UTF-8\")); //$NON-NLS-1$\n\t\t\t\t\tString s;\n\t\t\t\t\twhile ((s = in.readLine()) != null) {\n\t\t\t\t\t\tresponseBody.append(s);\n\t\t\t\t\t\tresponseBody.append(\"\\n\"); //$NON-NLS-1$\n\t\t\t\t\t}\n\t\t\t\t\tis.close();\n\t\t\t\t}\n\t\t\t\thttpclient.getConnectionManager().shutdown();\n\t\t\t\tlog.info(\"Monitor response (\" + response.getFirstHeader(\"Content-Type\") + \"): \" + responseBody.toString());\n\t\t\t}\n\n\t\t\t\n\t\t} catch (Exception e) {\n\t\t\tlog.error(\"Failed connect to \" + url + \": \" + e.getMessage(), e);\n\t\t}\n\t}","commit_id":"04229be99d1327870959fad2f85ed796a0f33821","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void updateLocation(net.osmand.Location location) {\n\t\tif (OsmAndLocationProvider.isPointAccurateForRouting(location) && isLiveMonitoringEnabled()\n\t\t\t\t&& OsmandPlugin.getEnabledPlugin(OsmandMonitoringPlugin.class) != null) {\n\t\t\tlong locationTime = System.currentTimeMillis();\n\t\t\t//* 1000 in next line seems to be wrong with new IntervalChooseDialog\n\t\t\t//if (time - lastTimeUpdated > settings.LIVE_MONITORING_INTERVAL.get() * 1000) {\n\t\t\tif (locationTime - lastTimeUpdated > settings.LIVE_MONITORING_INTERVAL.get()) {\n\t\t\t\tLiveMonitoringData data = new LiveMonitoringData((float)location.getLatitude(), (float)location.getLongitude(),\n\t\t\t\t\t\t(float) location.getAltitude(),(float) location.getSpeed(),(float) location.getAccuracy(), (float) location.getBearing(), locationTime );\n\t\t\t\tnew LiveSender().execute(data);\n\t\t\t\tlastTimeUpdated = locationTime;\n\t\t\t}\n\t\t}\n\t\t\n\t}","id":44710,"modified_method":"public void updateLocation(net.osmand.Location location) {\n\t\tif (OsmAndLocationProvider.isPointAccurateForRouting(location) && isLiveMonitoringEnabled()\n\t\t\t\t&& OsmandPlugin.getEnabledPlugin(OsmandMonitoringPlugin.class) != null) {\n\t\t\tlong locationTime = System.currentTimeMillis();\n\t\t\tif (locationTime - lastTimeUpdated > settings.LIVE_MONITORING_INTERVAL.get()) {\n\t\t\t\tLiveMonitoringData data = new LiveMonitoringData((float)location.getLatitude(), (float)location.getLongitude(),\n\t\t\t\t\t\t(float)location.getAltitude(), location.getSpeed(), location.getAccuracy(), location.getBearing(), locationTime);\n\t\t\t\tnew LiveSender().execute(data);\n\t\t\t\tlastTimeUpdated = locationTime;\n\t\t\t}\n\t\t}\n\t\t\n\t}","commit_id":"04229be99d1327870959fad2f85ed796a0f33821","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void resolveUpdatePass(String stepName, final _FunctionTypes._return_P1_E0<? extends Iterable<SReference>, ? super SNode> extractor, final ProgressMonitor progress) {\n    final Map<SNodeReference, List<SReference>> resolveMap = MapSequence.fromMap(new HashMap<SNodeReference, List<SReference>>());\n\n    progress.start(stepName, myRootCount);\n\n    myModelAccess.runReadAction(new Runnable() {\n      public void run() {\n\n        for (SModel model : ListSequence.fromList(myModels)) {\n          for (SNode claz : ListSequence.fromList(SModelOperations.getRoots(model, \"jetbrains.mps.baseLanguage.structure.Classifier\"))) {\n\n            Iterable<SReference> refs = extractor.invoke(claz);\n            resolveRefs(refs, resolveMap);\n\n            progress.advance(1);\n          }\n        }\n      }\n    });\n\n    try {\n      SwingUtilities.invokeAndWait(new Runnable() {\n        public void run() {\n          myModelAccess.executeCommand(new Runnable() {\n            public void run() {\n              updateReference(resolveMap);\n            }\n          });\n        }\n      });\n\n    } catch (InterruptedException e) {\n      LOG.error(stepName + \" pass was interrupted\", e);\n    } catch (InvocationTargetException e) {\n      LOG.error(\"Exception in \" + stepName + \" pass\", e.getCause());\n    }\n\n    progress.done();\n  }","id":44711,"modified_method":"private void resolveUpdatePass(String stepName, final _FunctionTypes._return_P1_E0<? extends Iterable<SReference>, ? super SNode> extractor, final ProgressMonitor progress) {\n    final Map<SNodeReference, List<SReference>> resolveMap = MapSequence.fromMap(new HashMap<SNodeReference, List<SReference>>());\n\n    progress.start(stepName, myRootCount + 1);\n\n    myModelAccess.runReadAction(new Runnable() {\n      public void run() {\n\n        for (SModel model : ListSequence.fromList(myModels)) {\n          for (SNode claz : ListSequence.fromList(SModelOperations.getRoots(model, \"jetbrains.mps.baseLanguage.structure.Classifier\"))) {\n\n            progress.step(SPropertyOperations.getString(claz, \"name\"));\n\n            Iterable<SReference> refs = extractor.invoke(claz);\n            resolveRefs(refs, resolveMap);\n\n            SetSequence.fromSet(myVisitedRefs).addSequence(Sequence.fromIterable(refs));\n            progress.advance(1);\n          }\n        }\n      }\n    });\n\n    runCommand(stepName, new Runnable() {\n      public void run() {\n        updateReference(resolveMap);\n      }\n    });\n\n    progress.advance(1);\n    progress.done();\n  }","commit_id":"fe224013a10dff14872ce453e44efb49b6761c05","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Iterable<SReference> getFieldAndMethodTypeRefs(SNode node) {\n    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());\n\n    for (SNode member : ListSequence.fromList(SLinkOperations.getTargets(node, \"member\", true))) {\n      if (SNodeOperations.isInstanceOf(member, \"jetbrains.mps.baseLanguage.structure.VariableDeclaration\")) {\n        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, \"jetbrains.mps.baseLanguage.structure.VariableDeclaration\"), \"type\", true))));\n\n      } else if (SNodeOperations.isInstanceOf(member, \"jetbrains.mps.baseLanguage.structure.MethodDeclaration\")) {\n        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\"), \"returnType\", true))));\n        for (SNode param : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(member, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\"), \"parameter\", true))) {\n          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(SLinkOperations.getTarget(param, \"type\", true))));\n        }\n        for (SNode thrws : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(member, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\"), \"throwsItem\", true))) {\n          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(thrws)));\n        }\n\n      } else if (SNodeOperations.isInstanceOf(member, \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getFieldAndMethodTypeRefs(SNodeOperations.cast(member, \"jetbrains.mps.baseLanguage.structure.Classifier\"))));\n      }\n    }\n\n    return refs;\n  }","id":44712,"modified_method":"private Iterable<SReference> getFieldAndMethodTypeRefs(SNode node) {\n    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());\n\n    for (SNode member : ListSequence.fromList(SLinkOperations.getTargets(node, \"member\", true))) {\n      if (SNodeOperations.isInstanceOf(member, \"jetbrains.mps.baseLanguage.structure.VariableDeclaration\")) {\n        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, \"jetbrains.mps.baseLanguage.structure.VariableDeclaration\"), \"type\", true))));\n\n      } else if (SNodeOperations.isInstanceOf(member, \"jetbrains.mps.baseLanguage.structure.MethodDeclaration\")) {\n        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(member, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\"), \"returnType\", true))));\n        for (SNode param : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(member, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\"), \"parameter\", true))) {\n          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(param, \"type\", true))));\n        }\n        for (SNode thrws : ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(member, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\"), \"throwsItem\", true))) {\n          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(thrws)));\n        }\n\n      } else if (SNodeOperations.isInstanceOf(member, \"jetbrains.mps.baseLanguage.structure.Classifier\")) {\n        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getFieldAndMethodTypeRefs(SNodeOperations.cast(member, \"jetbrains.mps.baseLanguage.structure.Classifier\"))));\n      }\n    }\n\n    return refs;\n  }","commit_id":"fe224013a10dff14872ce453e44efb49b6761c05","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Iterable<SReference> getTopLevelRefs(SNode node) {\n    final List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());\n\n    if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(SLinkOperations.getTarget(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"superclass\", true))));\n      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"implementedInterface\", true)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode it) {\n          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(it)));\n        }\n      });\n\n    } else if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.Interface\"), \"extendedInterface\", true)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode it) {\n          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(it)));\n        }\n      });\n    }\n\n    for (SNode inner : ListSequence.fromList(SNodeOperations.getDescendants(node, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, new String[]{}))) {\n      if (SNodeOperations.isInstanceOf(inner, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\")) {\n        continue;\n      }\n      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getTopLevelRefs(inner)));\n    }\n\n    return refs;\n  }","id":44713,"modified_method":"private Iterable<SReference> getTopLevelRefs(SNode node) {\n    final List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());\n\n    if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(SLinkOperations.getTarget(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"superclass\", true))));\n      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), \"implementedInterface\", true)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode it) {\n          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(it)));\n        }\n      });\n\n    } else if (SNodeOperations.isInstanceOf(node, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      ListSequence.fromList(SLinkOperations.getTargets(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.Interface\"), \"extendedInterface\", true)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode it) {\n          ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(it)));\n        }\n      });\n    }\n\n    for (SNode inner : ListSequence.fromList(SNodeOperations.getDescendants(node, \"jetbrains.mps.baseLanguage.structure.Classifier\", false, new String[]{}))) {\n      if (SNodeOperations.isInstanceOf(inner, \"jetbrains.mps.baseLanguage.structure.AnonymousClass\")) {\n        continue;\n      }\n      ListSequence.fromList(refs).addSequence(Sequence.fromIterable(getTopLevelRefs(inner)));\n    }\n\n    return refs;\n  }","commit_id":"fe224013a10dff14872ce453e44efb49b6761c05","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void resolveReferences(SNode startNode, Map<SNodeReference, List<SReference>> result, int pass) {\n    final Queue<SNode> stack = QueueSequence.fromQueue(new LinkedList<SNode>());\n    QueueSequence.fromQueue(stack).addLastElement(startNode);\n\n    while (QueueSequence.fromQueue(stack).isNotEmpty()) {\n      SNode node = QueueSequence.fromQueue(stack).removeFirstElement();\n      SModel ourModel = node.getModel();\n      ListSequence.fromList(SNodeOperations.getChildren(node)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode it) {\n          QueueSequence.fromQueue(stack).addLastElement(it);\n        }\n      });\n\n      Iterable<? extends SReference> refs = node.getReferences();\n      List<SReference> newRefs = ListSequence.fromList(new ArrayList<SReference>());\n\n      for (final SReference ref : Sequence.fromIterable(refs)) {\n        if (!(ref instanceof DynamicReference)) {\n          continue;\n        }\n        // FIXME temp hack around typesystem looping when resolving certain dyn.references \n\n        if (pass == 0) {\n          if (ref.getRole().equals(\"baseMethodDeclaration\")) {\n            continue;\n          }\n          if (ref.getRole().equals(\"fieldDeclaration\") || ref.getRole().equals(\"variableDeclaration\")) {\n            continue;\n          }\n\n        } else if (SNodeOperations.getConceptDeclaration(node) == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.DotExpression\")) {\n          if (Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true))).any(new IWhereFilter<SReference>() {\n            public boolean accept(SReference it) {\n              SReference ref = it;\n              return ref instanceof DynamicReference;\n            }\n          })) {\n\n            continue;\n          }\n        }\n\n        SNode target = null;\n\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        Future<SNode> future = executor.submit(new Callable<SNode>() {\n          public SNode call() throws Exception {\n            final Wrappers._T<SNode> result = new Wrappers._T<SNode>();\n            myModelAccess.runReadAction(new Runnable() {\n              public void run() {\n                result.value = ref.getTargetNode();\n              }\n            });\n            return result.value;\n          }\n        });\n\n        try {\n          target = future.get(1000, TimeUnit.MILLISECONDS);\n        } catch (TimeoutException e) {\n          LOG.error(\"Reference resolve timeout\");\n          future.cancel(true);\n        } catch (Exception e) {\n          future.cancel(true);\n        }\n\n        if (target == null) {\n          continue;\n        }\n\n        SModelReference targetModel = target.getModel().getReference();\n\n        SReference staticRef = StaticReference.create(ref.getRole(), node, target.getModel().getReference(), target.getNodeId());\n        ListSequence.fromList(newRefs).addElement(staticRef);\n      }\n\n      if (ListSequence.fromList(newRefs).isNotEmpty()) {\n        MapSequence.fromMap(result).put(node.getReference(), newRefs);\n      }\n    }\n  }","id":44714,"modified_method":"private void resolveReferences(SNode startNode, Map<SNodeReference, List<SReference>> result, int pass) {\n    final Queue<SNode> stack = QueueSequence.fromQueue(new LinkedList<SNode>());\n    QueueSequence.fromQueue(stack).addLastElement(startNode);\n\n    while (QueueSequence.fromQueue(stack).isNotEmpty()) {\n      SNode node = QueueSequence.fromQueue(stack).removeFirstElement();\n      SModel ourModel = node.getModel();\n      ListSequence.fromList(SNodeOperations.getChildren(node)).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode it) {\n          QueueSequence.fromQueue(stack).addLastElement(it);\n        }\n      });\n\n      Iterable<? extends SReference> refs = node.getReferences();\n      List<SReference> newRefs = ListSequence.fromList(new ArrayList<SReference>());\n\n      for (final SReference ref : Sequence.fromIterable(refs)) {\n        if (!(ref instanceof DynamicReference)) {\n          continue;\n        }\n        // FIXME temp hack around typesystem looping when resolving certain dyn.references \n\n        if (pass == 0) {\n          if (ref.getRole().equals(\"baseMethodDeclaration\")) {\n            continue;\n          }\n          if (ref.getRole().equals(\"fieldDeclaration\") || ref.getRole().equals(\"variableDeclaration\")) {\n            continue;\n          }\n\n        } else if (SNodeOperations.getConceptDeclaration(node) == SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.DotExpression\")) {\n          if (Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.DotExpression\"), \"operand\", true))).any(new IWhereFilter<SReference>() {\n            public boolean accept(SReference it) {\n              SReference ref = it;\n              return ref instanceof DynamicReference;\n            }\n          })) {\n\n            continue;\n          }\n        }\n\n        SNode target = null;\n\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        Future<SNode> future = executor.submit(new Callable<SNode>() {\n          public SNode call() throws Exception {\n            final Wrappers._T<SNode> result = new Wrappers._T<SNode>();\n            myModelAccess.runReadAction(new Runnable() {\n              public void run() {\n                result.value = ref.getTargetNode();\n              }\n            });\n            return result.value;\n          }\n        });\n\n        try {\n          target = future.get(1000, TimeUnit.MILLISECONDS);\n        } catch (TimeoutException e) {\n          System.out.println(\"Reference resolve timeout\");\n          future.cancel(true);\n        } catch (Exception e) {\n          future.cancel(true);\n        }\n\n        if (target == null) {\n          continue;\n        }\n\n        SModelReference targetModel = target.getModel().getReference();\n\n        SReference staticRef = StaticReference.create(ref.getRole(), node, target.getModel().getReference(), target.getNodeId());\n        ListSequence.fromList(newRefs).addElement(staticRef);\n      }\n\n      if (ListSequence.fromList(newRefs).isNotEmpty()) {\n        MapSequence.fromMap(result).put(node.getReference(), newRefs);\n      }\n    }\n  }","commit_id":"fe224013a10dff14872ce453e44efb49b6761c05","url":"https://github.com/JetBrains/MPS"},{"original_method":"private Iterable<SReference> getVarTypeRefs(SNode node) {\n    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());\n\n    for (SNode block : ListSequence.fromList(SNodeOperations.getDescendants(node, \"jetbrains.mps.baseLanguage.structure.StatementList\", false, new String[]{}))) {\n\n      for (SNode varDecl : ListSequence.fromList(SNodeOperations.getDescendants(block, \"jetbrains.mps.baseLanguage.structure.VariableDeclaration\", false, new String[]{}))) {\n        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(SNodeOperations.getReferences(SLinkOperations.getTarget(varDecl, \"type\", true))));\n      }\n    }\n\n    return refs;\n  }","id":44715,"modified_method":"private Iterable<SReference> getVarTypeRefs(SNode node) {\n    List<SReference> refs = ListSequence.fromList(new ArrayList<SReference>());\n\n    for (SNode block : ListSequence.fromList(SNodeOperations.getDescendants(node, \"jetbrains.mps.baseLanguage.structure.StatementList\", false, new String[]{}))) {\n\n      for (SNode varDecl : ListSequence.fromList(SNodeOperations.getDescendants(block, \"jetbrains.mps.baseLanguage.structure.VariableDeclaration\", false, new String[]{}))) {\n        ListSequence.fromList(refs).addSequence(Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(varDecl, \"type\", true))));\n      }\n    }\n\n    return refs;\n  }","commit_id":"fe224013a10dff14872ce453e44efb49b6761c05","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void resolveRefs(Iterable<SReference> refs, Map<SNodeReference, List<SReference>> result) {\n    for (SReference ref : refs) {\n      if (!(ref instanceof DynamicReference)) {\n        continue;\n      }\n\n      SNode target = ref.getTargetNode();\n      if (target == null) {\n        continue;\n      }\n\n      SNode source = ref.getSourceNode();\n      SModelReference targetModel = target.getModel().getReference();\n\n      SReference staticRef = StaticReference.create(ref.getRole(), source, targetModel, target.getNodeId());\n\n      List<SReference> nodeRefs = MapSequence.fromMap(result).get(source.getReference());\n      if (nodeRefs == null) {\n        nodeRefs = ListSequence.fromList(new ArrayList<SReference>());\n        MapSequence.fromMap(result).put(source.getReference(), nodeRefs);\n      }\n      ListSequence.fromList(nodeRefs).addElement((SReference) staticRef);\n    }\n  }","id":44716,"modified_method":"private void resolveRefs(Iterable<SReference> refs, Map<SNodeReference, List<SReference>> result) {\n    for (SReference ref : refs) {\n      if (!(ref instanceof DynamicReference)) {\n        continue;\n      }\n      if (SetSequence.fromSet(myVisitedRefs).contains((SReference) ref)) {\n        continue;\n      }\n\n      SNode target = ref.getTargetNode();\n      if (target == null) {\n        continue;\n      }\n\n      SNode source = ref.getSourceNode();\n      SModelReference targetModel = target.getModel().getReference();\n\n      SReference staticRef = StaticReference.create(ref.getRole(), source, targetModel, target.getNodeId());\n\n      List<SReference> nodeRefs = MapSequence.fromMap(result).get(source.getReference());\n      if (nodeRefs == null) {\n        nodeRefs = ListSequence.fromList(new ArrayList<SReference>());\n        MapSequence.fromMap(result).put(source.getReference(), nodeRefs);\n      }\n      ListSequence.fromList(nodeRefs).addElement((SReference) staticRef);\n    }\n  }","commit_id":"fe224013a10dff14872ce453e44efb49b6761c05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void convertToMps(final List<IFile> files, ProgressMonitor progress) throws JavaParseException, IOException {\n\n    progress.start(\"Converting...\", 31);\n\n    // first we build AST \n    final ProgressMonitor parseProgress = progress.subTask(1);\n    parseProgress.start(\"Parsing...\", ListSequence.fromList(files).count());\n\n    // read action needed only because java parser does new node<Concept> \n\n    myModelAccess.runReadAction(new Runnable() {\n      public void run() {\n        for (IFile file : ListSequence.fromList(files)) {\n          try {\n            parseFile(file);\n            parseProgress.advance(1);\n\n            ListSequence.fromList(mySuccessfulFiles).addElement(file);\n\n          } catch (JavaParseException e) {\n          } catch (IOException e) {\n          }\n        }\n      }\n    });\n\n    parseProgress.done();\n\n\n    final Wrappers._int rootCount = new Wrappers._int(0);\n\n    // now we attach the models and try to resolve      \n\n    runCommand(\"model creation pass\", new Runnable() {\n      public void run() {\n        for (String pakage : SetSequence.fromSet(MapSequence.fromMap(classesPerPackage).keySet())) {\n          final SModel model = registerModelForPackage(pakage);\n\n          Set<SNode> roots = MapSequence.fromMap(classesPerPackage).get(pakage);\n          SetSequence.fromSet(roots).visitAll(new IVisitor<SNode>() {\n            public void visit(SNode it) {\n              model.addRootNode(it);\n            }\n          });\n          rootCount.value = rootCount.value + SetSequence.fromSet(roots).count();\n\n          ((SModelInternal) model).addLanguage(PersistenceFacade.getInstance().createModuleReference(\"f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)\"));\n\n        }\n\n        for (String pakage : SetSequence.fromSet(MapSequence.fromMap(classesPerPackage).keySet())) {\n          final SModel model = registerModelForPackage(pakage);\n\n          Set<SNode> roots = MapSequence.fromMap(classesPerPackage).get(pakage);\n          SetSequence.fromSet(roots).visitAll(new IVisitor<SNode>() {\n            public void visit(SNode it) {\n              model.addRootNode(it);\n            }\n          });\n\n          rootCount.value = rootCount.value + SetSequence.fromSet(roots).count();\n          ListSequence.fromList(myModels).addElement(model);\n        }\n\n        // should be cheap \n        for (SModel model : ListSequence.fromList(myModels)) {\n          JavaParser.tryResolveUnknowns(SModelOperations.getRoots(model, null));\n        }\n\n      }\n    });\n\n    myRootCount = rootCount.value;\n\n    ProgressMonitor resolveProgress = progress.subTask(30);\n\n    resolveUpdatePass(\"top level refs\", new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {\n      public Iterable<SReference> invoke(SNode node) {\n        return getTopLevelRefs(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n      }\n    }, resolveProgress.subTask(10));\n\n    resolveUpdatePass(\"field/method type refs\", new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {\n      public Iterable<SReference> invoke(SNode node) {\n        return getFieldAndMethodTypeRefs(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n      }\n    }, resolveProgress.subTask(10));\n\n    resolveUpdatePass(\"all type refs\", new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {\n      public Iterable<SReference> invoke(SNode node) {\n        return getFieldAndMethodTypeRefs(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n      }\n    }, resolveProgress.subTask(10));\n\n    progress.done();\n  }","id":44717,"modified_method":"public void convertToMps(final List<IFile> files, ProgressMonitor progress) throws JavaParseException, IOException {\n\n    progress.start(\"Converting...\", 31);\n\n    // first we build AST \n    final ProgressMonitor parseProgress = progress.subTask(1);\n    parseProgress.start(\"Parsing...\", ListSequence.fromList(files).count());\n\n    // read action needed only because java parser does new node<Concept> \n\n    myModelAccess.runReadAction(new Runnable() {\n      public void run() {\n        for (IFile file : ListSequence.fromList(files)) {\n          try {\n            parseFile(file);\n            parseProgress.advance(1);\n\n            ListSequence.fromList(mySuccessfulFiles).addElement(file);\n\n          } catch (JavaParseException e) {\n          } catch (IOException e) {\n          }\n        }\n      }\n    });\n\n    parseProgress.done();\n\n\n    final Wrappers._int rootCount = new Wrappers._int(0);\n\n    // now we attach the models and try to resolve      \n\n    runCommand(\"model creation pass\", new Runnable() {\n      public void run() {\n        for (String pakage : SetSequence.fromSet(MapSequence.fromMap(classesPerPackage).keySet())) {\n          final SModel model = registerModelForPackage(pakage);\n\n          Set<SNode> roots = MapSequence.fromMap(classesPerPackage).get(pakage);\n          SetSequence.fromSet(roots).visitAll(new IVisitor<SNode>() {\n            public void visit(SNode it) {\n              model.addRootNode(it);\n            }\n          });\n          rootCount.value = rootCount.value + SetSequence.fromSet(roots).count();\n\n          ((SModelInternal) model).addLanguage(PersistenceFacade.getInstance().createModuleReference(\"f3061a53-9226-4cc5-a443-f952ceaf5816(jetbrains.mps.baseLanguage)\"));\n\n        }\n\n        for (String pakage : SetSequence.fromSet(MapSequence.fromMap(classesPerPackage).keySet())) {\n          final SModel model = registerModelForPackage(pakage);\n\n          Set<SNode> roots = MapSequence.fromMap(classesPerPackage).get(pakage);\n          SetSequence.fromSet(roots).visitAll(new IVisitor<SNode>() {\n            public void visit(SNode it) {\n              model.addRootNode(it);\n            }\n          });\n\n          rootCount.value = rootCount.value + SetSequence.fromSet(roots).count();\n          ListSequence.fromList(myRoots).addSequence(SetSequence.fromSet(roots));\n          ListSequence.fromList(myModels).addElement(model);\n        }\n\n        // should be cheap \n        for (SModel model : ListSequence.fromList(myModels)) {\n          JavaParser.tryResolveUnknowns(SModelOperations.getRoots(model, null));\n        }\n\n      }\n    });\n\n    myRootCount = rootCount.value;\n\n    ProgressMonitor resolveProgress = progress.subTask(30);\n\n    resolveProgress.start(\"Resolving...\", 10);\n\n    resolveUpdatePass(\"top level refs\", new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {\n      public Iterable<SReference> invoke(SNode node) {\n        return getTopLevelRefs(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n      }\n    }, resolveProgress.subTask(1));\n\n    resolveUpdatePass(\"field/method type refs\", new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {\n      public Iterable<SReference> invoke(SNode node) {\n        return getFieldAndMethodTypeRefs(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n      }\n    }, resolveProgress.subTask(1));\n\n    resolveUpdatePass(\"all type refs\", new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {\n      public Iterable<SReference> invoke(SNode node) {\n        return getVarTypeRefs(SNodeOperations.cast(node, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n      }\n    }, resolveProgress.subTask(2));\n\n    resolveUpdatePass(\"all variable refs\", new _FunctionTypes._return_P1_E0<Iterable<SReference>, SNode>() {\n      public Iterable<SReference> invoke(SNode node) {\n        return getVariableRefs(node);\n      }\n    }, resolveProgress.subTask(2));\n\n    resolveUpdatePass(\"all operands\", new _FunctionTypes._return_P1_E0<ISequence<SReference>, SNode>() {\n      public ISequence<SReference> invoke(SNode node) {\n        return ListSequence.fromList(SNodeOperations.getDescendants(node, \"jetbrains.mps.baseLanguage.structure.DotExpression\", false, new String[]{})).translate(new ITranslator2<SNode, SReference>() {\n          public Iterable<SReference> translate(SNode it) {\n            return deepReferences(SLinkOperations.getTarget(it, \"operand\", true));\n          }\n        });\n      }\n    }, resolveProgress.subTask(2));\n\n    resolveUpdatePass(\"all operations\", new _FunctionTypes._return_P1_E0<ISequence<SReference>, SNode>() {\n      public ISequence<SReference> invoke(SNode node) {\n        return ListSequence.fromList(SNodeOperations.getDescendants(node, \"jetbrains.mps.baseLanguage.structure.DotExpression\", false, new String[]{})).translate(new ITranslator2<SNode, SReference>() {\n          public Iterable<SReference> translate(SNode it) {\n            if (Sequence.fromIterable(deepReferences(SLinkOperations.getTarget(it, \"operand\", true))).any(new IWhereFilter<SReference>() {\n              public boolean accept(SReference it) {\n                return (SReference) it instanceof DynamicReference;\n              }\n            })) {\n              return ListSequence.fromList(new ArrayList<SReference>());\n            } else {\n              if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"operation\", true), \"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation\")) {\n                return Sequence.<SReference>singleton(SNodeOperations.getReference(SNodeOperations.cast(SLinkOperations.getTarget(it, \"operation\", true), \"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation\"), SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.FieldReferenceOperation\", \"fieldDeclaration\")));\n              } else if (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"operation\", true), \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\")) {\n                return Sequence.<SReference>singleton(SNodeOperations.getReference(SNodeOperations.cast(SLinkOperations.getTarget(it, \"operation\", true), \"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\"), SLinkOperations.findLinkDeclaration(\"jetbrains.mps.baseLanguage.structure.InstanceMethodCallOperation\", \"instanceMethodDeclaration\")));\n              } else {\n                return ListSequence.fromList(new ArrayList<SReference>());\n              }\n            }\n          }\n        });\n      }\n    }, resolveProgress.subTask(2));\n\n    // <node> \n\n    // <node> \n\n\n    // <node> \n\n    resolveProgress.done();\n\n    progress.done();\n  }","commit_id":"fe224013a10dff14872ce453e44efb49b6761c05","url":"https://github.com/JetBrains/MPS"},{"original_method":"public synchronized ImmutableList<IResourceDescription.Delta> clean(Set<URI> toBeRemoved, IProgressMonitor monitor) {\n\t\tensureLoaded();\n\t\t\n\t\ttoBeRemoved = ensureNotNull(toBeRemoved);\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, \"Create resource descriptions\", 3);\n\t\tsubMonitor.subTask(\"Create resource descriptions\");\n\t\ttry {\n\t\t\tif (subMonitor.isCanceled() || toBeRemoved.isEmpty())\n\t\t\t\treturn ImmutableList.of();\n\t\t\tCollection<Delta> deltas = doClean(toBeRemoved, subMonitor.newChild(1));\n\n\t\t\tfinal Map<URI, IResourceDescription> newMap = getCopiedResourceDescriptionsMap();\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn ImmutableList.of();\n\t\t\tfor(Delta delta: deltas) {\n\t\t\t\tnewMap.remove(delta.getOld().getURI());\n\t\t\t}\n\t\t\tResourceDescriptionChangeEvent event = new ResourceDescriptionChangeEvent(deltas, this);\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn ImmutableList.of();\n\t\t\tupdateMarkers(null, event.getDeltas(), subMonitor);\n\t\t\t// update the reference\n\t\t\tsetResourceDescriptionsMap(newMap);\n\t\t\tnotifyListeners(event);\n\t\t\treturn event.getDeltas();\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44718,"modified_method":"public synchronized ImmutableList<IResourceDescription.Delta> clean(Set<URI> toBeRemoved, IProgressMonitor monitor) {\n\t\tensureLoaded();\n\t\ttoBeRemoved = ensureNotNull(toBeRemoved);\n\t\t\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, \"Create resource descriptions\", 2);\n\t\tsubMonitor.subTask(\"Create resource descriptions\");\n\t\tif (subMonitor.isCanceled() || toBeRemoved.isEmpty())\n\t\t\treturn ImmutableList.of();\n\t\tCollection<Delta> deltas = doClean(toBeRemoved, subMonitor.newChild(1));\n\n\t\tfinal Map<URI, IResourceDescription> newMap = getCopiedResourceDescriptionsMap();\n\t\tif (subMonitor.isCanceled())\n\t\t\treturn ImmutableList.of();\n\t\tfor(Delta delta: deltas) {\n\t\t\tnewMap.remove(delta.getOld().getURI());\n\t\t}\n\t\tResourceDescriptionChangeEvent event = new ResourceDescriptionChangeEvent(deltas, this);\n\t\tif (subMonitor.isCanceled())\n\t\t\treturn ImmutableList.of();\n\t\tupdateMarkers(null, event.getDeltas(), subMonitor.newChild(1));\n\t\t// update the reference\n\t\tsetResourceDescriptionsMap(newMap);\n\t\tnotifyListeners(event);\n\t\treturn event.getDeltas();\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void updateMarkers(ResourceSet resourceSet, ImmutableList<IResourceDescription.Delta> deltas, IProgressMonitor monitor) {\n    \tmarkerUpdater.updateMarker(resourceSet, deltas, monitor);\n    }","id":44719,"modified_method":"protected void updateMarkers(ResourceSet resourceSet, ImmutableList<IResourceDescription.Delta> deltas, IProgressMonitor monitor) {\n    \tSubMonitor progress = SubMonitor.convert(monitor, 1);\n    \tmarkerUpdater.updateMarker(resourceSet, deltas, progress.newChild(1));\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Collection<Delta> doClean(Set<URI> toBeRemoved, SubMonitor monitor) {\n\t\tCollection<Delta> result = updater.clean(this, toBeRemoved, monitor);\n\t\treturn result;\n\t}","id":44720,"modified_method":"protected Collection<Delta> doClean(Set<URI> toBeRemoved, IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 1);\n\t\tCollection<Delta> result = updater.clean(this, toBeRemoved, subMonitor.newChild(1));\n\t\treturn result;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected abstract Collection<Delta> doUpdate(ResourceSet resourceSet, Set<URI> toBeAddedOrUpdated,\n\t\t\tSet<URI> toBeRemoved, Map<URI, IResourceDescription> newMap, SubMonitor subMonitor);","id":44721,"modified_method":"protected abstract Collection<Delta> doUpdate(ResourceSet resourceSet, Set<URI> toBeAddedOrUpdated,\n\t\t\tSet<URI> toBeRemoved, Map<URI, IResourceDescription> newMap, IProgressMonitor monitor);","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Collection<Delta> transitiveUpdate(ResourceSet resourceSet, Set<URI> toBeAddedOrUpdated, Set<URI> toBeRemoved,\n\t\t\tSubMonitor subMonitor) {\n\t\treturn updater.transitiveUpdate(this, resourceSet, toBeAddedOrUpdated, toBeRemoved, subMonitor.newChild(1));\n\t}","id":44722,"modified_method":"protected Collection<Delta> transitiveUpdate(ResourceSet resourceSet, Set<URI> toBeAddedOrUpdated, Set<URI> toBeRemoved,\n\t\t\tIProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 1);\n\t\tCollection<Delta> result = updater.transitiveUpdate(this, resourceSet, toBeAddedOrUpdated, toBeRemoved, subMonitor.newChild(1));\n\t\treturn result;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public synchronized ImmutableList<IResourceDescription.Delta> update(ResourceSet resourceSet,\n            Set<URI> toBeAddedOrUpdated,\n            Set<URI> toBeRemoved,\n            IProgressMonitor monitor) {\n        ensureLoaded();\n        toBeAddedOrUpdated = ensureNotNull(toBeAddedOrUpdated);\n        toBeRemoved = ensureNotNull(toBeRemoved);\n\n        final SubMonitor subMonitor = SubMonitor.convert(monitor, \"Create resource descriptions\", 3);\n        subMonitor.subTask(\"Create resource descriptions\");\n        try {\n            if (subMonitor.isCanceled() || (toBeAddedOrUpdated.isEmpty() && toBeRemoved.isEmpty())) {\n                return ImmutableList.of();\n            }\n            \n            final Map<URI, IResourceDescription> newMap = getCopiedResourceDescriptionsMap();\n            final Collection<Delta> result = doUpdate(resourceSet, toBeAddedOrUpdated, toBeRemoved,\n\t\t\t\t\tnewMap, subMonitor);\n            \n            if (subMonitor.isCanceled())\n\t\t\t\treturn ImmutableList.of();\n            final ResourceDescriptionChangeEvent event = new ResourceDescriptionChangeEvent(result, this);\n            // update the reference\n            setResourceDescriptionsMap(newMap);\n            notifyListeners(event);\n            return event.getDeltas();\n        } finally {\n            subMonitor.done();\n        }\n    }","id":44723,"modified_method":"public synchronized ImmutableList<IResourceDescription.Delta> update(ResourceSet resourceSet,\n            Set<URI> toBeAddedOrUpdated,\n            Set<URI> toBeRemoved,\n            IProgressMonitor monitor) {\n        ensureLoaded();\n        toBeAddedOrUpdated = ensureNotNull(toBeAddedOrUpdated);\n        toBeRemoved = ensureNotNull(toBeRemoved);\n\n        final SubMonitor subMonitor = SubMonitor.convert(monitor, \"Create resource descriptions\", 1);\n        subMonitor.subTask(\"Create resource descriptions\");\n        if (subMonitor.isCanceled() || (toBeAddedOrUpdated.isEmpty() && toBeRemoved.isEmpty())) {\n            return ImmutableList.of();\n        }\n        \n        final Map<URI, IResourceDescription> newMap = getCopiedResourceDescriptionsMap();\n        final Collection<Delta> result = doUpdate(resourceSet, toBeAddedOrUpdated, toBeRemoved,\n\t\t\t\tnewMap, subMonitor.newChild(1));\n        \n        if (subMonitor.isCanceled())\n\t\t\treturn ImmutableList.of();\n        final ResourceDescriptionChangeEvent event = new ResourceDescriptionChangeEvent(result, this);\n        // update the reference\n        setResourceDescriptionsMap(newMap);\n        notifyListeners(event);\n        return event.getDeltas();\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tprotected IStatus run(IProgressMonitor monitor) {\n\t\t\tsynchronized (projectsScheduledForBuild) {\n\t\t\t\tprojectsScheduledForBuild.remove(project);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t// project could have been modified in the meantime, so check again\n\t\t\t\tif (isBuildable(project)) {\n\t\t\t\t\tproject.build(IncrementalProjectBuilder.FULL_BUILD, XtextBuilder.BUILDER_ID, builderArguments,\n\t\t\t\t\t\t\tmonitor);\n\t\t\t\t}\n\t\t\t} catch (Exception x) {\n\t\t\t\tlog.error(x.getMessage(), x);\n\t\t\t\treturn new Status(IStatus.ERROR, Activator.getDefault().getBundle().getSymbolicName(), \"Build of \"\n\t\t\t\t\t\t+ Strings.notNull(project.getName()) + \" failed.\\nSee log for details.\");\n\t\t\t}\n\t\t\treturn Status.OK_STATUS;\n\t\t}","id":44724,"modified_method":"@Override\n\t\tprotected IStatus run(IProgressMonitor monitor) {\n\t\t\tSubMonitor progress = SubMonitor.convert(monitor, 1);\n\t\t\ttry {\n\t\t\t\tsynchronized (projectsScheduledForBuild) {\n\t\t\t\t\tprojectsScheduledForBuild.remove(project);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\t// project could have been modified in the meantime, so check again\n\t\t\t\t\tif (isBuildable(project)) {\n\t\t\t\t\t\tproject.build(IncrementalProjectBuilder.FULL_BUILD, XtextBuilder.BUILDER_ID, builderArguments,\n\t\t\t\t\t\t\t\tprogress.newChild(1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprogress.worked(1);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception x) {\n\t\t\t\t\tlog.error(x.getMessage(), x);\n\t\t\t\t\treturn new Status(IStatus.ERROR, Activator.getDefault().getBundle().getSymbolicName(), \"Build of \"\n\t\t\t\t\t\t\t+ Strings.notNull(project.getName()) + \" failed.\\nSee log for details.\");\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (monitor != null)\n\t\t\t\t\tmonitor.done();\n\t\t\t}\n\t\t\treturn Status.OK_STATUS;\n\t\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ImmutableList<Delta> updateAndCopyDescriptions(\r\n            ResourceSet resourceSet, SubMonitor subMonitor,\r\n            Iterator<Delta> deltaIterator,\r\n            Map<URI, IResourceDescription> newMap,\r\n            int firstIndex,\r\n            final int nofDeltas) {\r\n        final SubMonitor deltaMonitor = SubMonitor.convert(subMonitor.newChild(1), \"Update resource descriptions\", clusterSize);\r\n        final Set<Delta> result = Sets.newHashSet();\r\n        try {\r\n            for (int i = 0; i < clusterSize && deltaIterator.hasNext(); i++) {\r\n                final Delta delta = deltaIterator.next();\r\n                if (deltaMonitor.isCanceled()) {\r\n                    return ImmutableList.of();\r\n                }\r\n                deltaMonitor.subTask(\"Update resource description \" + firstIndex + \" of \" + nofDeltas);\r\n                IResourceDescription newDescription = null;\r\n                if (delta.getNew() != null) {\r\n                    final Resource resource = resourceSet.getResource(delta.getUri(), true);\r\n                    final IResourceDescription.Manager manager = getResourceDescriptionManager(delta.getUri());\r\n                    newDescription = manager.getResourceDescription(resource);\r\n                }\r\n                final DefaultResourceDescriptionDelta copiedDelta = new DefaultResourceDescriptionDelta(delta.getOld(),\r\n                        copy(newDescription));\r\n                result.add(copiedDelta);\r\n                if (copiedDelta.getNew() == null) {\r\n                    newMap.remove(copiedDelta.getUri());\r\n                } else {\r\n                    newMap.put(copiedDelta.getUri(), copiedDelta.getNew());\r\n                }\r\n                firstIndex++;\r\n                deltaMonitor.worked(1);\r\n            }\r\n            return ImmutableList.copyOf(result);\r\n        } finally {\r\n            deltaMonitor.done();\r\n        }\r\n    }","id":44725,"modified_method":"protected ImmutableList<Delta> updateAndCopyDescriptions(\r\n            ResourceSet resourceSet, Iterator<Delta> deltaIterator,\r\n            Map<URI, IResourceDescription> newMap,\r\n            int firstIndex,\r\n            int noOfDeltas,\r\n            IProgressMonitor monitor) {\r\n        SubMonitor progress = SubMonitor.convert(monitor, \"Update resource descriptions\", clusterSize);\r\n        Set<Delta> result = Sets.newHashSet();\r\n        for (int i = 0; i < clusterSize && deltaIterator.hasNext(); i++) {\r\n            Delta delta = deltaIterator.next();\r\n            if (progress.isCanceled()) {\r\n                return ImmutableList.of();\r\n            }\r\n            progress.subTask(\"Update resource description \" + firstIndex + \" of \" + noOfDeltas);\r\n            IResourceDescription newDescription = null;\r\n            if (delta.getNew() != null) {\r\n                Resource resource = resourceSet.getResource(delta.getUri(), true);\r\n                IResourceDescription.Manager manager = getResourceDescriptionManager(delta.getUri());\r\n                newDescription = manager.getResourceDescription(resource);\r\n            }\r\n            DefaultResourceDescriptionDelta copiedDelta = new DefaultResourceDescriptionDelta(delta.getOld(),\r\n                    copy(newDescription));\r\n            result.add(copiedDelta);\r\n            if (copiedDelta.getNew() == null) {\r\n                newMap.remove(copiedDelta.getUri());\r\n            } else {\r\n                newMap.put(copiedDelta.getUri(), copiedDelta.getNew());\r\n            }\r\n            firstIndex++;\r\n            progress.worked(1);\r\n        }\r\n        return ImmutableList.copyOf(result);\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\r\n\tprotected Collection<Delta> doUpdate(ResourceSet resourceSet, Set<URI> toBeAddedOrUpdated,\r\n\t\t\tSet<URI> toBeRemoved, final Map<URI, IResourceDescription> newMap, final SubMonitor subMonitor) {\r\n\t\tfinal Collection<Delta> deltas = collectResources(resourceSet, toBeAddedOrUpdated, toBeRemoved, subMonitor);\r\n\t\tfinal Set<Delta> allCopiedDeltas = Sets.newHashSet();\r\n\r\n\t\tfinal Iterator<Delta> deltaIterator = deltas.iterator();\r\n\t\tfinal int nofDeltas = deltas.size();\r\n\t\tint currentDeltaIndex = 1;\r\n\t\twhile (deltaIterator.hasNext()) {\r\n\t\t    final ImmutableList<Delta> copiedDeltas = updateAndCopyDescriptions(resourceSet, subMonitor, deltaIterator,\r\n\t\t            newMap, currentDeltaIndex, nofDeltas);\r\n\t\t    if (subMonitor.isCanceled()) {\r\n\t\t        return ImmutableList.of();\r\n\t\t    }\r\n\t\t    currentDeltaIndex += copiedDeltas.size();\r\n\t\t    updateMarkers(resourceSet, copiedDeltas, subMonitor);\r\n\t\t    resourceSet.getResources().clear();\r\n\t\t    allCopiedDeltas.addAll(copiedDeltas);\r\n\t\t    if (subMonitor.isCanceled()) {\r\n\t\t        return ImmutableList.of();\r\n\t\t    }\r\n\t\t}\r\n\t\treturn allCopiedDeltas;\r\n\t}","id":44726,"modified_method":"@Override\r\n\tprotected Collection<Delta> doUpdate(ResourceSet resourceSet, Set<URI> toBeAddedOrUpdated,\r\n\t\t\tSet<URI> toBeRemoved, final Map<URI, IResourceDescription> newMap, IProgressMonitor monitor) {\r\n\t\tSubMonitor progress = SubMonitor.convert(monitor, 100);\r\n\t\t\r\n\t\tCollection<Delta> deltas = collectResources(resourceSet, toBeAddedOrUpdated, toBeRemoved, progress.newChild(20));\r\n\t\tSet<Delta> allCopiedDeltas = Sets.newHashSet();\r\n\r\n\t\tIterator<Delta> deltaIterator = deltas.iterator();\r\n\t\tint noOfDeltas = deltas.size();\r\n\t\tint currentDeltaIndex = 1;\r\n\t\twhile (deltaIterator.hasNext()) {\r\n\t\t\tprogress.setWorkRemaining(2 * (noOfDeltas - currentDeltaIndex));\r\n\t\t    ImmutableList<Delta> copiedDeltas = updateAndCopyDescriptions(resourceSet, deltaIterator, newMap,\r\n\t\t            currentDeltaIndex, noOfDeltas, progress.newChild(clusterSize));\r\n\t\t    if (monitor.isCanceled()) {\r\n\t\t        return ImmutableList.of();\r\n\t\t    }\r\n\t\t    currentDeltaIndex += copiedDeltas.size();\r\n\t\t    updateMarkers(resourceSet, copiedDeltas, progress.newChild(copiedDeltas.size()));\r\n\t\t    resourceSet.getResources().clear();\r\n\t\t    allCopiedDeltas.addAll(copiedDeltas);\r\n\t\t    if (monitor.isCanceled()) {\r\n\t\t        return ImmutableList.of();\r\n\t\t    }\r\n\t\t}\r\n\t\treturn allCopiedDeltas;\r\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Collection<Delta> collectResources(ResourceSet resourceSet, Set<URI> toBeAddedOrUpdated, Set<URI> toBeRemoved,\r\n            SubMonitor subMonitor) {\r\n        resourceSet.getLoadOptions().put(AbstractGlobalScopeProvider.NAMED_BUILDER_SCOPE, Boolean.TRUE);\r\n        final Collection<Delta> deltas = transitiveUpdate(resourceSet, toBeAddedOrUpdated, toBeRemoved, subMonitor);\r\n        return deltas;\r\n    }","id":44727,"modified_method":"protected Collection<Delta> collectResources(ResourceSet resourceSet, Set<URI> toBeAddedOrUpdated, Set<URI> toBeRemoved,\r\n    \t\tIProgressMonitor monitor) {\r\n    \tSubMonitor progress = SubMonitor.convert(monitor, 1);\r\n        resourceSet.getLoadOptions().put(AbstractGlobalScopeProvider.NAMED_BUILDER_SCOPE, Boolean.TRUE);\r\n        Collection<Delta> result = transitiveUpdate(resourceSet, toBeAddedOrUpdated, toBeRemoved, progress.newChild(1));\r\n        return result;\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"private IResourceDescription copy(IResourceDescription toCopy) {\r\n        if (toCopy == null) {\r\n            return null;\r\n        }\r\n        final ResourceDescriptionImpl copied = BuilderStateUtil.create(toCopy);\r\n        return copied;\r\n    }","id":44728,"modified_method":"private IResourceDescription copy(IResourceDescription toCopy) {\r\n        if (toCopy == null) {\r\n            return null;\r\n        }\r\n        ResourceDescriptionImpl result = BuilderStateUtil.create(toCopy);\r\n        return result;\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected IResourceDescription.Manager getResourceDescriptionManager(URI uri) {\r\n        final IResourceServiceProvider resourceServiceProvider = managerRegistry.getResourceServiceProvider(uri);\r\n        if (resourceServiceProvider == null) {\r\n            return null;\r\n        }\r\n        return resourceServiceProvider.getResourceDescriptionManager();\r\n    }","id":44729,"modified_method":"protected IResourceDescription.Manager getResourceDescriptionManager(URI uri) {\r\n        IResourceServiceProvider resourceServiceProvider = managerRegistry.getResourceServiceProvider(uri);\r\n        if (resourceServiceProvider == null) {\r\n            return null;\r\n        }\r\n        return resourceServiceProvider.getResourceDescriptionManager();\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\r\n     * This method computes the {@link IResourceDescription}s for all affected (i.e. added, updated or transitively\r\n     * affected) resources. It does not change any state in the underlying {@link org.eclipse.xtext.resource.IResourceDescriptions}\r\n     * instance.\r\n     * \r\n     * @param rs\r\n     *            - The ResourceSet to use for reloading the to be updated resources\r\n     * @param toBeUpdated\r\n     *            - the URIs which have to be reloaded\r\n     * @param toBeDeleted\r\n     *            - the URIs which are about to be deleted\r\n     * @return returns an iterable of fresh {@link IResourceDescription} for all resources, which are affected by the\r\n     *         change (i.e. the to BeUpdated and toBeDeleted resources)\r\n     */\r\n    public Collection<IResourceDescription.Delta> transitiveUpdate(final IResourceDescriptions oldState, final ResourceSet rs,\r\n            Set<URI> toBeUpdated, Set<URI> toBeDeleted, IProgressMonitor monitor) {\r\n        final SubMonitor subMonitor = SubMonitor.convert(monitor, \"Find affected resources\", 2);\r\n        subMonitor.subTask(\"Find affected resources\");\r\n        try {\r\n            final Set<URI> toBeDeletedAsSet = Sets.newHashSet(toBeDeleted);\r\n            toBeDeletedAsSet.removeAll(Collections2.forIterable(toBeUpdated));\r\n            final Map<URI, IResourceDescription.Delta> result = Maps.newHashMap();\r\n            // add deleted\r\n            for (final URI toDelete : toBeDeletedAsSet) {\r\n                final IResourceDescription resourceDescription = oldState.getResourceDescription(toDelete);\r\n                if (resourceDescription != null) {\r\n                    result.put(toDelete, new DefaultResourceDescriptionDelta(resourceDescription, null));\r\n                }\r\n            }\r\n\r\n            final CurrentDescriptions newState = new CurrentDescriptions(rs, oldState, toBeDeletedAsSet);\r\n            final IUniqueURIQueue queue = queueFactory.create(toBeUpdated);\r\n            queueAffectedResourceDescriptions(oldState, newState, result.values(), queue);            \r\n            while (!queue.isEmpty()) {\r\n                final Map<URI, Delta> clusterDeltas = loadResourceCluster(oldState, rs, queue, toBeDeletedAsSet,\r\n                \t\tsubMonitor.newChild(1), result.size() + 1);\r\n                result.putAll(clusterDeltas);\r\n                for (final Delta delta : clusterDeltas.values()) {\r\n                    newState.register(delta);\r\n                }\r\n                queueAffectedResourceDescriptions(oldState, newState, clusterDeltas.values(), queue);\r\n\r\n                rs.getResources().clear();\r\n            }\r\n            return result.values();\r\n        } finally {\r\n            subMonitor.done();\r\n        }\r\n    }","id":44730,"modified_method":"/**\r\n     * This method computes the {@link IResourceDescription}s for all affected (i.e. added, updated or transitively\r\n     * affected) resources. It does not change any state in the underlying {@link org.eclipse.xtext.resource.IResourceDescriptions}\r\n     * instance.\r\n     * \r\n     * @param rs\r\n     *            - The ResourceSet to use for reloading the to be updated resources\r\n     * @param toBeUpdated\r\n     *            - the URIs which have to be reloaded\r\n     * @param toBeDeleted\r\n     *            - the URIs which are about to be deleted\r\n     * @return returns an iterable of fresh {@link IResourceDescription} for all resources, which are affected by the\r\n     *         change (i.e. the to BeUpdated and toBeDeleted resources)\r\n     */\r\n    public Collection<IResourceDescription.Delta> transitiveUpdate(IResourceDescriptions oldState, final ResourceSet rs,\r\n            Set<URI> toBeUpdated, Set<URI> toBeDeleted, IProgressMonitor monitor) {\r\n        SubMonitor subMonitor = SubMonitor.convert(monitor, \"Find affected resources\", 100);\r\n        subMonitor.subTask(\"Find affected resources\");\r\n\r\n        Set<URI> toBeDeletedAsSet = Sets.newHashSet(toBeDeleted);\r\n        if (!toBeDeletedAsSet.isEmpty()) {\r\n\t        for(URI updatedURI: toBeUpdated) {\r\n\t        \ttoBeDeletedAsSet.remove(updatedURI);\r\n\t        \tif (toBeDeletedAsSet.isEmpty())\r\n\t        \t\tbreak;\r\n\t        }\r\n        }\r\n        Map<URI, IResourceDescription.Delta> result = Maps.newHashMap();\r\n        // add deleted\r\n        for (final URI toDelete : toBeDeletedAsSet) {\r\n            IResourceDescription resourceDescription = oldState.getResourceDescription(toDelete);\r\n            if (resourceDescription != null) {\r\n                result.put(toDelete, new DefaultResourceDescriptionDelta(resourceDescription, null));\r\n            }\r\n        }\r\n\r\n        int startWith = result.size();\r\n        CurrentDescriptions newState = new CurrentDescriptions(rs, oldState, toBeDeletedAsSet);\r\n        IUniqueURIQueue queue = queueFactory.create(toBeUpdated);\r\n        queueAffectedResourceDescriptions(oldState, newState, result.values(), queue);            \r\n        while (!queue.isEmpty()) {\r\n        \tsubMonitor.setWorkRemaining(100);\r\n            Map<URI, Delta> clusterDeltas = loadResourceCluster(oldState, rs, queue, toBeDeletedAsSet,\r\n            \t\tsubMonitor.newChild(30), result.size() - startWith + 1);\r\n            result.putAll(clusterDeltas);\r\n            for (final Delta delta : clusterDeltas.values()) {\r\n                newState.register(delta);\r\n            }\r\n            queueAffectedResourceDescriptions(oldState, newState, clusterDeltas.values(), queue);\r\n            rs.getResources().clear();\r\n        }\r\n        return result.values();\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Map<URI, IResourceDescription.Delta> loadResourceCluster(\r\n            IResourceDescriptions oldState,\r\n            final ResourceSet set,\r\n            IUniqueURIQueue queue,\r\n            Set<URI> ignoredURIs,\r\n            IProgressMonitor monitor,\r\n            int baseIndex) {\r\n        final SubMonitor subMonitor = SubMonitor.convert(monitor, clusterSize);\r\n        try {\r\n            final Map<URI, IResourceDescription.Delta> result = Maps.newHashMap();\r\n            for (int i = 0; i < clusterSize && !queue.isEmpty(); i++) {\r\n                if (subMonitor.isCanceled()) {\r\n                    return Collections.emptyMap();\r\n                }\r\n                subMonitor.subTask(\"Loading affected resource \" + baseIndex);\r\n                final URI uri = queue.get();\r\n                Resource resource = null;\r\n                try {\r\n                \tif (!ignoredURIs.contains(uri)) {\r\n                \t\tresource = set.getResource(uri, true);\r\n\r\n\t                    final IResourceDescription.Manager manager = getResourceDescriptionManager(uri);\r\n\t                    if (manager != null) {\r\n\t                        final IResourceDescription description = manager.getResourceDescription(resource);\r\n\t                        final IResourceDescription copiedDescription = new CopiedResourceDescription(description);\r\n\t                        result.put(uri, new DefaultResourceDescriptionDelta(\r\n\t                                oldState.getResourceDescription(uri), copiedDescription));\r\n\t                    }\r\n                \t}\r\n                } catch (final WrappedException ex) {\r\n                    if (set.getURIConverter().exists(uri, Collections.emptyMap())) {\r\n                        log.error(\"Error loading resource from: \" + uri.toString(), ex);\r\n                    }\r\n                    if (resource != null) {\r\n                        set.getResources().remove(resource);\r\n                    }\r\n                    final IResourceDescription oldDescription = oldState.getResourceDescription(uri);\r\n                    if (oldDescription != null) {\r\n                        result.put(uri, new DefaultResourceDescriptionDelta(oldDescription, null));\r\n                    }\r\n                }\r\n                baseIndex++;\r\n                subMonitor.worked(1);\r\n            }\r\n            return result;\r\n        } finally {\r\n            subMonitor.done();\r\n        }\r\n\r\n    }","id":44731,"modified_method":"protected Map<URI, IResourceDescription.Delta> loadResourceCluster(\r\n            IResourceDescriptions oldState,\r\n            ResourceSet resourceSet,\r\n            IUniqueURIQueue queue,\r\n            Collection<URI> ignoredURIs,\r\n            IProgressMonitor monitor,\r\n            int baseIndex) {\r\n        SubMonitor subMonitor = SubMonitor.convert(monitor, clusterSize);\r\n        Map<URI, IResourceDescription.Delta> result = Maps.newHashMap();\r\n        for (int i = 0; i < clusterSize && !queue.isEmpty(); i++) {\r\n            if (subMonitor.isCanceled()) {\r\n                return Collections.emptyMap();\r\n            }\r\n            subMonitor.subTask(\"Loading affected resource \" + baseIndex + \" of \" + queue.totalSize());\r\n            URI nextURI = queue.remove();\r\n            Resource resource = null;\r\n            try {\r\n            \tif (!ignoredURIs.contains(nextURI)) {\r\n            \t\tresource = resourceSet.getResource(nextURI, true);\r\n\r\n                    IResourceDescription.Manager manager = getResourceDescriptionManager(nextURI);\r\n                    if (manager != null) {\r\n                        IResourceDescription description = manager.getResourceDescription(resource);\r\n                        IResourceDescription copiedDescription = new CopiedResourceDescription(description);\r\n                        result.put(nextURI, new DefaultResourceDescriptionDelta(\r\n                                oldState.getResourceDescription(nextURI), copiedDescription));\r\n                    }\r\n            \t}\r\n            } catch (final WrappedException ex) {\r\n                if (resourceSet.getURIConverter().exists(nextURI, Collections.emptyMap())) {\r\n                    log.error(\"Error loading resource from: \" + nextURI.toString(), ex);\r\n                }\r\n                if (resource != null) {\r\n                    resourceSet.getResources().remove(resource);\r\n                }\r\n                IResourceDescription oldDescription = oldState.getResourceDescription(nextURI);\r\n                if (oldDescription != null) {\r\n                    result.put(nextURI, new DefaultResourceDescriptionDelta(oldDescription, null));\r\n                }\r\n            }\r\n            baseIndex++;\r\n            subMonitor.worked(1);\r\n        }\r\n        return result;\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void queueAffectedResourceDescriptions(\r\n            IResourceDescriptions oldState,\r\n            CurrentDescriptions newState,\r\n            Collection<IResourceDescription.Delta> deltas,\r\n            IUniqueURIQueue queue) throws IllegalArgumentException {\r\n        final Iterable<? extends IResourceDescription> descriptions = oldState.getAllResourceDescriptions();\r\n        for (final IResourceDescription desc : descriptions) {\r\n            final IResourceDescription.Manager manager = getResourceDescriptionManager(desc.getURI());\r\n            if (manager != null) {\r\n                if (manager.isAffected(deltas, desc, newState)) {\r\n                    queue.add(desc.getURI());\r\n                }\r\n            }\r\n        }\r\n    }","id":44732,"modified_method":"protected void queueAffectedResourceDescriptions(\r\n            IResourceDescriptions oldState,\r\n            CurrentDescriptions newState,\r\n            Collection<IResourceDescription.Delta> deltas,\r\n            IUniqueURIQueue queue) throws IllegalArgumentException {\r\n        Iterable<IResourceDescription> descriptions = oldState.getAllResourceDescriptions();\r\n        for (IResourceDescription desc : descriptions) {\r\n            IResourceDescription.Manager manager = getResourceDescriptionManager(desc.getURI());\r\n            if (manager != null) {\r\n                if (manager.isAffected(deltas, desc, newState)) {\r\n                    queue.add(desc.getURI());\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected IResourceDescription.Manager getResourceDescriptionManager(URI uri) {\r\n        final IResourceServiceProvider resourceServiceProvider = managerRegistry.getResourceServiceProvider(uri);\r\n        if (resourceServiceProvider == null) {\r\n            return null;\r\n        }\r\n        return resourceServiceProvider.getResourceDescriptionManager();\r\n    }","id":44733,"modified_method":"protected IResourceDescription.Manager getResourceDescriptionManager(URI uri) {\r\n        IResourceServiceProvider resourceServiceProvider = managerRegistry.getResourceServiceProvider(uri);\r\n        if (resourceServiceProvider == null) {\r\n            return null;\r\n        }\r\n        return resourceServiceProvider.getResourceDescriptionManager();\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public Collection<IResourceDescription.Delta> clean(IResourceDescriptions oldState, Set<URI> toBeDeleted,\r\n            IProgressMonitor monitor) {\r\n        final SubMonitor subMonitor = SubMonitor.convert(monitor, \"Clean resources\", 2);\r\n        subMonitor.subTask(\"Clean resources\");\r\n        try {\r\n            final Set<URI> toBeDeletedAsSet = Sets.newHashSet(toBeDeleted);\r\n            final Map<URI, IResourceDescription.Delta> result = Maps.newHashMap();\r\n            for (final URI toDelete : toBeDeletedAsSet) {\r\n                final IResourceDescription resourceDescription = oldState.getResourceDescription(toDelete);\r\n                if (resourceDescription != null) {\r\n                    result.put(toDelete, new DefaultResourceDescriptionDelta(resourceDescription, null));\r\n                }\r\n            }\r\n            return result.values();\r\n        } finally {\r\n            subMonitor.done();\r\n        }\r\n    }","id":44734,"modified_method":"public Collection<IResourceDescription.Delta> clean(IResourceDescriptions oldState, Set<URI> toBeDeleted,\r\n            IProgressMonitor monitor) {\r\n        SubMonitor subMonitor = SubMonitor.convert(monitor, \"Clean resources\", toBeDeleted.size());\r\n        subMonitor.subTask(\"Clean resources\");\r\n        Set<URI> toBeDeletedAsSet = Sets.newHashSet(toBeDeleted);\r\n        Map<URI, IResourceDescription.Delta> result = Maps.newHashMap();\r\n        for (URI toDelete : toBeDeletedAsSet) {\r\n            IResourceDescription resourceDescription = oldState.getResourceDescription(toDelete);\r\n            if (resourceDescription != null) {\r\n                result.put(toDelete, new DefaultResourceDescriptionDelta(resourceDescription, null));\r\n            }\r\n            subMonitor.worked(1);\r\n        }\r\n        return result.values();\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public CopiedResourceDescription(IResourceDescription original) {\r\n        this.uri = original.getURI();\r\n        this.exported = ImmutableList.copyOf(Iterables.transform(original.getExportedObjects(),\r\n                new Function<IEObjectDescription, IEObjectDescription>() {\r\n                    public IEObjectDescription apply(IEObjectDescription from) {\r\n                        if (from.getEObjectOrProxy().eIsProxy()) {\r\n                            return from;\r\n                        }\r\n                        final InternalEObject result = (InternalEObject) EcoreUtil.create(from.getEClass());\r\n                        result.eSetProxyURI(EcoreUtil.getURI(from.getEObjectOrProxy()));\r\n                        Map<String, String> userData = null;\r\n                        for (final String key : from.getUserDataKeys()) {\r\n                            if (userData == null) {\r\n                                userData = Maps.newHashMapWithExpectedSize(2);\r\n                            }\r\n                            userData.put(key, from.getUserData(key));\r\n                        }\r\n                        return EObjectDescription.create(from.getName(), result, userData);\r\n                    }\r\n                }));\r\n    }","id":44735,"modified_method":"public CopiedResourceDescription(IResourceDescription original) {\r\n        this.uri = original.getURI();\r\n        this.exported = ImmutableList.copyOf(Iterables.transform(original.getExportedObjects(),\r\n                new Function<IEObjectDescription, IEObjectDescription>() {\r\n                    public IEObjectDescription apply(IEObjectDescription from) {\r\n                        if (from.getEObjectOrProxy().eIsProxy()) {\r\n                            return from;\r\n                        }\r\n                        InternalEObject result = (InternalEObject) EcoreUtil.create(from.getEClass());\r\n                        result.eSetProxyURI(EcoreUtil.getURI(from.getEObjectOrProxy()));\r\n                        Map<String, String> userData = null;\r\n                        for (final String key : from.getUserDataKeys()) {\r\n                            if (userData == null) {\r\n                                userData = Maps.newHashMapWithExpectedSize(2);\r\n                            }\r\n                            userData.put(key, from.getUserData(key));\r\n                        }\r\n                        return EObjectDescription.create(from.getName(), result, userData);\r\n                    }\r\n                }));\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public void setContext(Notifier ctx) {\r\n            final ResourceSet resourceSet = EcoreUtil2.getResourceSet(ctx);\r\n            delegate = (IResourceDescriptions) EcoreUtil.getAdapter(\r\n                    resourceSet.eAdapters(), CurrentDescriptions.class);\r\n        }","id":44736,"modified_method":"public void setContext(Notifier ctx) {\r\n            ResourceSet resourceSet = EcoreUtil2.getResourceSet(ctx);\r\n            delegate = (IResourceDescriptions) EcoreUtil.getAdapter(\r\n                    resourceSet.eAdapters(), CurrentDescriptions.class);\r\n        }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\r\n    public boolean isAdapterForType(Object type) {\r\n        return getClass().equals(type);\r\n    }","id":44737,"modified_method":"@Override\r\n    public boolean isAdapterForType(Object type) {\r\n        return CurrentDescriptions.class.equals(type);\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public CurrentDescriptions(ResourceSet resourceSet, IResourceDescriptions oldState, Set<URI> initiallyDeleted) {\r\n        this.oldState = oldState;\r\n        for (final URI uri : initiallyDeleted) {\r\n            updatedDescriptions.put(uri, null);\r\n        }\r\n        resourceSet.eAdapters().add(this);\r\n    }","id":44738,"modified_method":"public CurrentDescriptions(ResourceSet resourceSet, IResourceDescriptions oldState, Set<URI> initiallyDeleted) {\r\n        this.oldState = oldState;\r\n        for (URI uri : initiallyDeleted) {\r\n            updatedDescriptions.put(uri, null);\r\n        }\r\n        resourceSet.eAdapters().add(this);\r\n    }","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic ToBeBuilt updateProject(IProject project, IProgressMonitor monitor) throws CoreException {\n\t\tfinal ToBeBuilt toBeBuilt = super.updateProject(project, monitor);\n\t\tif (!project.isAccessible())\n\t\t\treturn toBeBuilt;\n\t\tIJavaProject javaProject = JavaCore.create(project);\n\t\tif (javaProject.exists()) {\n\t\t\tIPackageFragmentRoot[] roots = javaProject.getPackageFragmentRoots();\n\t\t\tfinal JarEntryLocator locator = new JarEntryLocator();\n\t\t\tfor (final IPackageFragmentRoot root : roots) {\n\t\t\t\tif (shouldHandle(root)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnew PackageFragmentRootWalker<Void>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected Void handle(IJarEntryResource jarEntry, TraversalState state) {\n\t\t\t\t\t\t\t\tURI uri = locator.getURI(root, jarEntry, state);\n\t\t\t\t\t\t\t\tif (isValid(uri, jarEntry)) {\n\t\t\t\t\t\t\t\t\ttoBeBuilt.getToBeDeleted().add(uri);\n\t\t\t\t\t\t\t\t\ttoBeBuilt.getToBeUpdated().add(uri);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.traverse(root,false);\n\t\t\t\t\t} catch (JavaModelException ex) {\n\t\t\t\t\t\tif (!ex.isDoesNotExist())\n\t\t\t\t\t\t\tlog.error(ex.getMessage(), ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn toBeBuilt;\n\t}","id":44739,"modified_method":"@Override\n\tpublic ToBeBuilt updateProject(IProject project, IProgressMonitor monitor) throws CoreException {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, 2);\n\t\tfinal ToBeBuilt toBeBuilt = super.updateProject(project, progress.newChild(1));\n\t\tif (!project.isAccessible() || progress.isCanceled())\n\t\t\treturn toBeBuilt;\n\t\tIJavaProject javaProject = JavaCore.create(project);\n\t\tif (javaProject.exists()) {\n\t\t\tIPackageFragmentRoot[] roots = javaProject.getPackageFragmentRoots();\n\t\t\tprogress.setWorkRemaining(roots.length);\n\t\t\tfinal JarEntryLocator locator = new JarEntryLocator();\n\t\t\tfor (final IPackageFragmentRoot root : roots) {\n\t\t\t\tif (progress.isCanceled())\n\t\t\t\t\treturn toBeBuilt;\n\t\t\t\tif (shouldHandle(root)) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnew PackageFragmentRootWalker<Void>() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected Void handle(IJarEntryResource jarEntry, TraversalState state) {\n\t\t\t\t\t\t\t\tURI uri = locator.getURI(root, jarEntry, state);\n\t\t\t\t\t\t\t\tif (isValid(uri, jarEntry)) {\n\t\t\t\t\t\t\t\t\ttoBeBuilt.getToBeDeleted().add(uri);\n\t\t\t\t\t\t\t\t\ttoBeBuilt.getToBeUpdated().add(uri);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.traverse(root,false);\n\t\t\t\t\t} catch (JavaModelException ex) {\n\t\t\t\t\t\tif (!ex.isDoesNotExist())\n\t\t\t\t\t\t\tlog.error(ex.getMessage(), ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprogress.worked(1);\n\t\t\t}\n\t\t}\n\t\treturn toBeBuilt;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public void updateMarker(ResourceSet resourceSet, ImmutableList<Delta> resourceDescriptionDeltas,\n\t\t\tIProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, \"Validate resources\", resourceDescriptionDeltas.size());\n\t\tsubMonitor.subTask(\"Validate resources\");\n\t\ttry {\n\t\t\tfor (Delta delta : resourceDescriptionDeltas) {\n\t\t\t\tif (subMonitor.isCanceled())\n\t\t\t\t\treturn;\n\t\t\t\tif (delta.getNew() != null) {\n\t\t\t\t\tIterable<IStorage> storages = mapper.getStorages(delta.getNew().getURI());\n\t\t\t\t\tSubMonitor child = subMonitor.newChild(1);\n\t\t\t\t\tfor (IStorage storage : storages) {\n\t\t\t\t\t\tif (storage instanceof IFile) {\n\t\t\t\t\t\t\tIFile file = (IFile) storage;\n\t\t\t\t\t\t\tif (!file.isReadOnly()) {\n\t\t\t\t\t\t\t\tResource resource = resourceSet.getResource(delta.getNew().getURI(), true);\n\t\t\t\t\t\t\t\taddMarkers(file, resource, child);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tIterable<IStorage> storages = mapper.getStorages(delta.getOld().getURI());\n\t\t\t\t\tfor (IStorage storage : storages) {\n\t\t\t\t\t\tif (storage instanceof IFile) {\n\t\t\t\t\t\t\tIFile file = (IFile) storage;\n\t\t\t\t\t\t\tif (!file.isReadOnly() && file.isAccessible()) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tfile.deleteMarkers(MarkerTypes.FAST_VALIDATION, true, IResource.DEPTH_ZERO);\n\t\t\t\t\t\t\t\t\tfile.deleteMarkers(MarkerTypes.NORMAL_VALIDATION, true, IResource.DEPTH_ZERO);\n\t\t\t\t\t\t\t\t} catch(CoreException ex) {\n\t\t\t\t\t\t\t\t\tlog.error(ex.getMessage(), ex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsubMonitor.worked(1);\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44740,"modified_method":"public void updateMarker(ResourceSet resourceSet, ImmutableList<Delta> resourceDescriptionDeltas,\n\t\t\tIProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, \"Validate resources\", resourceDescriptionDeltas.size());\n\t\tsubMonitor.subTask(\"Validate resources\");\n\t\tfor (Delta delta : resourceDescriptionDeltas) {\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn;\n\t\t\tif (delta.getNew() != null) {\n\t\t\t\tIterable<IStorage> storages = mapper.getStorages(delta.getNew().getURI());\n\t\t\t\tSubMonitor child = subMonitor.newChild(1);\n\t\t\t\tchild.setWorkRemaining(3);\n\t\t\t\tfor (IStorage storage : storages) {\n\t\t\t\t\tchild.setWorkRemaining(3);\n\t\t\t\t\tif (storage instanceof IFile) {\n\t\t\t\t\t\tIFile file = (IFile) storage;\n\t\t\t\t\t\tif (!file.isReadOnly()) {\n\t\t\t\t\t\t\tResource resource = resourceSet.getResource(delta.getNew().getURI(), true);\n\t\t\t\t\t\t\taddMarkers(file, resource, child.newChild(2));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild.worked(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tIterable<IStorage> storages = mapper.getStorages(delta.getOld().getURI());\n\t\t\t\tfor (IStorage storage : storages) {\n\t\t\t\t\tif (storage instanceof IFile) {\n\t\t\t\t\t\tIFile file = (IFile) storage;\n\t\t\t\t\t\tif (!file.isReadOnly() && file.isAccessible()) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tfile.deleteMarkers(MarkerTypes.FAST_VALIDATION, true, IResource.DEPTH_ZERO);\n\t\t\t\t\t\t\t\tfile.deleteMarkers(MarkerTypes.NORMAL_VALIDATION, true, IResource.DEPTH_ZERO);\n\t\t\t\t\t\t\t} catch(CoreException ex) {\n\t\t\t\t\t\t\t\tlog.error(ex.getMessage(), ex);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubMonitor.worked(1);\n\t\t\t}\n\t\t}\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void addMarkers(IFile file, Resource resource, final IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 2);\n\t\ttry {\n\t\t\tIResourceServiceProvider provider = resourceServiceProviderRegistry.getResourceServiceProvider(resource\n\t\t\t\t\t.getURI());\n\t\t\tif (provider == null)\n\t\t\t\treturn;\n\n\t\t\tIResourceValidator resourceValidator = provider.getResourceValidator();\n\t\t\tList<Issue> list = resourceValidator\n\t\t\t\t\t.validate(resource, CheckMode.NORMAL_AND_FAST, getCancelIndicator(subMonitor));\n\t\t\tif (monitor.isCanceled())\n\t\t\t\treturn;\n\t\t\tsubMonitor.worked(1);\n\t\t\tfile.deleteMarkers(MarkerTypes.FAST_VALIDATION, true, IResource.DEPTH_ZERO);\n\t\t\tfile.deleteMarkers(MarkerTypes.NORMAL_VALIDATION, true, IResource.DEPTH_ZERO);\n\t\t\tfor (Issue issue : list) {\n\t\t\t\tmarkerCreator.createMarker(issue, file, MarkerTypes.forCheckType(issue.getType()));\n\t\t\t}\n\t\t} catch (CoreException e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44741,"modified_method":"protected void addMarkers(IFile file, Resource resource, final IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 1);\n\t\ttry {\n\t\t\tIResourceServiceProvider provider = \n\t\t\t\tresourceServiceProviderRegistry.getResourceServiceProvider(resource.getURI());\n\t\t\tif (provider == null)\n\t\t\t\treturn;\n\n\t\t\tIResourceValidator resourceValidator = provider.getResourceValidator();\n\t\t\tList<Issue> list = resourceValidator.validate(resource, CheckMode.NORMAL_AND_FAST, getCancelIndicator(subMonitor));\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn;\n\t\t\tsubMonitor.worked(1);\n\t\t\tfile.deleteMarkers(MarkerTypes.FAST_VALIDATION, true, IResource.DEPTH_ZERO);\n\t\t\tfile.deleteMarkers(MarkerTypes.NORMAL_VALIDATION, true, IResource.DEPTH_ZERO);\n\t\t\tfor (Issue issue : list) {\n\t\t\t\tmarkerCreator.createMarker(issue, file, MarkerTypes.forCheckType(issue.getType()));\n\t\t\t}\n\t\t} catch (CoreException e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t} \n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void doValidate(ResourceSet rs, ImmutableList<Delta> deltas, IProgressMonitor monitor) {\n\t\tupdateMarkers(rs, deltas, monitor);\n\t}","id":44742,"modified_method":"protected void doValidate(ResourceSet rs, ImmutableList<Delta> deltas, IProgressMonitor monitor) {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, 1); \n\t\tupdateMarkers(rs, deltas, progress.newChild(1));\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected ImmutableList<Delta> doUpdate(ResourceSet resourceSet, Set<URI> toBeAddedOrUpdated,\n\t\t\tSet<URI> toBeRemoved, final Map<URI, IResourceDescription> newMap, SubMonitor subMonitor) {\n\t\tresourceSet.eAdapters().add(new ShadowingResourceDescriptions.Adapter(this, toBeAddedOrUpdated, toBeRemoved));\n\t\tresourceSet.getLoadOptions().put(AbstractGlobalScopeProvider.NAMED_BUILDER_SCOPE, Boolean.TRUE);\n\t\tCollection<Delta> deltas = transitiveUpdate(resourceSet, toBeAddedOrUpdated, toBeRemoved, subMonitor.newChild(1));\n\t\t\n\t\tSet<Delta> copiedDeltas = Sets.newHashSet();\n\t\t\n\t\tSubMonitor deltaMonitor = SubMonitor.convert(subMonitor.newChild(1), \"Update resource descriptions\", deltas.size());\n\t\tint total = deltas.size();\n\t\tint current = 1;\n\t\ttry {\n\t\t\tfor (Delta delta : deltas) {\n\t\t\t\tif (deltaMonitor.isCanceled())\n\t\t\t\t\treturn ImmutableList.of();\n\t\t\t\tdeltaMonitor.subTask(\"Update resource description \" + current + \" of \" + total);\n\t\t\t\tDefaultResourceDescriptionDelta copiedDelta = new DefaultResourceDescriptionDelta(delta.getOld(),\n\t\t\t\t\t\tcreateNew(delta, toBeAddedOrUpdated));\n\t\t\t\tcopiedDeltas.add(copiedDelta);\n\t\t\t\tif (delta.getNew() == null) {\n\t\t\t\t\tnewMap.remove(copiedDelta.getOld().getURI());\n\t\t\t\t} else {\n\t\t\t\t\tnewMap.put(copiedDelta.getNew().getURI(), copiedDelta.getNew());\n\t\t\t\t}\n\t\t\t\tcurrent++;\n\t\t\t\tdeltaMonitor.worked(1);\n\t\t\t}\n\t\t} finally {\n\t\t\tdeltaMonitor.done();\n\t\t}\n\t\tImmutableList<Delta> immutableDeltas = ImmutableList.copyOf(copiedDeltas);\n\t\tdoValidate(resourceSet, immutableDeltas, subMonitor.newChild(1));\n\t\treturn immutableDeltas;\n\t}","id":44743,"modified_method":"@Override\n\tprotected ImmutableList<Delta> doUpdate(ResourceSet resourceSet, Set<URI> toBeAddedOrUpdated,\n\t\t\tSet<URI> toBeRemoved, Map<URI, IResourceDescription> newMap, IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 3);\n\t\t\n\t\tresourceSet.eAdapters().add(new ShadowingResourceDescriptions.Adapter(this, toBeAddedOrUpdated, toBeRemoved));\n\t\tresourceSet.getLoadOptions().put(AbstractGlobalScopeProvider.NAMED_BUILDER_SCOPE, Boolean.TRUE);\n\t\tCollection<Delta> deltas = transitiveUpdate(resourceSet, toBeAddedOrUpdated, toBeRemoved, subMonitor.newChild(1));\n\t\t\n\t\tSet<Delta> copiedDeltas = Sets.newHashSet();\n\t\t\n\t\tSubMonitor deltaMonitor = SubMonitor.convert(subMonitor.newChild(1), \"Update resource descriptions\", deltas.size());\n\t\tint total = deltas.size();\n\t\tint current = 1;\n\t\tfor (Delta delta : deltas) {\n\t\t\tif (deltaMonitor.isCanceled())\n\t\t\t\treturn ImmutableList.of();\n\t\t\tdeltaMonitor.subTask(\"Update resource description \" + current + \" of \" + total);\n\t\t\tDefaultResourceDescriptionDelta copiedDelta = new DefaultResourceDescriptionDelta(delta.getOld(),\n\t\t\t\t\tcreateNew(delta, toBeAddedOrUpdated));\n\t\t\tcopiedDeltas.add(copiedDelta);\n\t\t\tif (delta.getNew() == null) {\n\t\t\t\tnewMap.remove(copiedDelta.getOld().getURI());\n\t\t\t} else {\n\t\t\t\tnewMap.put(copiedDelta.getNew().getURI(), copiedDelta.getNew());\n\t\t\t}\n\t\t\tcurrent++;\n\t\t\tdeltaMonitor.worked(1);\n\t\t}\n\t\tImmutableList<Delta> immutableDeltas = ImmutableList.copyOf(copiedDeltas);\n\t\tdoValidate(resourceSet, immutableDeltas, subMonitor.newChild(1));\n\t\treturn immutableDeltas;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void scheduleRemoveProjectJob(final IProject project) {\n\t\tfinal ToBeBuilt toBeBuilt = getToBeBuiltComputer().removeProject(project, new NullProgressMonitor());\n\t\tnew Job(\"Removing project \" + project.getName() + \" from Xtext index.\") {\n\t\t\t{\n\t\t\t\tsetRule(workspace.getRoot());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean belongsTo(Object family) {\n\t\t\t\treturn family == ResourcesPlugin.FAMILY_AUTO_BUILD;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected IStatus run(IProgressMonitor monitor) {\n\t\t\t\ttry {\n\t\t\t\t\tnew WorkspaceModifyOperation(getRule()) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void execute(IProgressMonitor monitor) throws CoreException,\n\t\t\t\t\t\t\t\tInvocationTargetException, InterruptedException {\n\t\t\t\t\t\t\tResourceSet resourceSet = getResourceSetProvider().get(project);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tgetBuilderState().update(resourceSet,\n\t\t\t\t\t\t\t\t\ttoBeBuilt.getToBeUpdated(), \n\t\t\t\t\t\t\t\t\ttoBeBuilt.getToBeDeleted(), \n\t\t\t\t\t\t\t\t\tmonitor);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresourceSet.getResources().clear();\n\t\t\t\t\t\t\tresourceSet.eAdapters().clear();\n\t\t\t\t\t\t}\n\t\t\t\t\t}.run(monitor);\n\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\treturn Status.OK_STATUS;\n\t\t\t}\n\t\t}.schedule();\n\t}","id":44744,"modified_method":"protected void scheduleRemoveProjectJob(final IProject project) {\n\t\tfinal ToBeBuilt toBeBuilt = getToBeBuiltComputer().removeProject(project, new NullProgressMonitor());\n\t\tnew Job(\"Removing project \" + project.getName() + \" from Xtext index.\") {\n\t\t\t{\n\t\t\t\tsetRule(workspace.getRoot());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean belongsTo(Object family) {\n\t\t\t\treturn family == ResourcesPlugin.FAMILY_AUTO_BUILD;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected IStatus run(IProgressMonitor monitor) {\n\t\t\t\ttry {\n\t\t\t\t\tnew WorkspaceModifyOperation(getRule()) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tprotected void execute(IProgressMonitor monitor) throws CoreException,\n\t\t\t\t\t\t\t\tInvocationTargetException, InterruptedException {\n\t\t\t\t\t\t\tSubMonitor progress = SubMonitor.convert(monitor, 1);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tResourceSet resourceSet = getResourceSetProvider().get(project);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tgetBuilderState().update(resourceSet,\n\t\t\t\t\t\t\t\t\t\ttoBeBuilt.getToBeUpdated(), \n\t\t\t\t\t\t\t\t\t\ttoBeBuilt.getToBeDeleted(), \n\t\t\t\t\t\t\t\t\t\tprogress.newChild(1));\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tresourceSet.getResources().clear();\n\t\t\t\t\t\t\t\tresourceSet.eAdapters().clear();\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tif (monitor != null)\n\t\t\t\t\t\t\t\t\tmonitor.done();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}.run(monitor);\n\t\t\t\t} catch (InvocationTargetException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\tlog.error(e.getMessage(), e);\n\t\t\t\t}\n\t\t\t\treturn Status.OK_STATUS;\n\t\t\t}\n\t\t}.schedule();\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public void build(IBuildContext buildContext, IProgressMonitor monitor)\n\t\t\tthrows CoreException {\n\t\tImmutableList<IXtextBuilderParticipant> participants = getParticipants();\n\t\tif (participants.isEmpty())\n\t\t\treturn;\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, participants.size());\n\t\tsubMonitor.subTask(\"Invoking build participants\");\n\t\ttry {\n\t\t\tfor(IXtextBuilderParticipant participant: participants) {\n\t\t\t\tif (subMonitor.isCanceled())\n\t\t\t\t\treturn;\n\t\t\t\tparticipant.build(buildContext, subMonitor.newChild(1));\n\t\t\t}\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44745,"modified_method":"public void build(IBuildContext buildContext, IProgressMonitor monitor)\n\t\t\tthrows CoreException {\n\t\tImmutableList<IXtextBuilderParticipant> participants = getParticipants();\n\t\tif (participants.isEmpty())\n\t\t\treturn;\n\t\tSubMonitor progress = SubMonitor.convert(monitor, participants.size());\n\t\tprogress.subTask(\"Invoking build participants\");\n\t\tfor(IXtextBuilderParticipant participant: participants) {\n\t\t\tif (progress.isCanceled())\n\t\t\t\treturn;\n\t\t\tparticipant.build(buildContext, progress.newChild(1));\n\t\t}\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Set<IResourceDescription> findAffectedResourceDescriptions(IResourceDescriptions oldState,\n\t\t\tIResourceDescriptions newState, Collection<IResourceDescription.Delta> deltas, IProgressMonitor monitor) throws IllegalArgumentException {\n\t\tSet<IResourceDescription> result = Sets.newHashSet();\n\t\tIterable<? extends IResourceDescription> descriptions = oldState.getAllResourceDescriptions();\n\t\tfor (IResourceDescription desc : descriptions) {\n\t\t\tif (monitor.isCanceled())\n\t\t\t\treturn Collections.emptySet();\n\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(desc.getURI());\n\t\t\tif (manager != null) {\n\t\t\t\tif (manager.isAffected(deltas, desc, newState)) {\n\t\t\t\t\tresult.add(desc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":44746,"modified_method":"protected Set<IResourceDescription> findAffectedResourceDescriptions(IResourceDescriptions oldState,\n\t\t\tIResourceDescriptions newState, Collection<IResourceDescription.Delta> deltas, IProgressMonitor monitor) throws IllegalArgumentException {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, Iterables.size(oldState.getAllResourceDescriptions()));\n\t\t\n\t\tSet<IResourceDescription> result = Sets.newHashSet();\n\t\tIterable<? extends IResourceDescription> descriptions = oldState.getAllResourceDescriptions();\n\t\tfor (IResourceDescription desc : descriptions) {\n\t\t\tif (progress.isCanceled())\n\t\t\t\treturn Collections.emptySet();\n\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(desc.getURI());\n\t\t\tif (manager != null) {\n\t\t\t\tif (manager.isAffected(deltas, desc, newState)) {\n\t\t\t\t\tresult.add(desc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprogress.worked(1);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * This method computes the {@link IResourceDescription}s for all affected (i.e. added, updated or transitively\n\t * affected) resources. It does not change any state in the underlying\n\t * {@link org.eclipse.xtext.resource.IResourceDescriptions} instance.\n\t * \n\t * @param rs\n\t *            - The ResourceSet to use for reloading the to be updated resources\n\t * @param toBeUpdated\n\t *            - the URIs which have to be reloaded\n\t * @param toBeDeleted\n\t *            - the URIs which are about to be deleted\n\t * @return returns an iterable of fresh {@link IResourceDescription} for all resources, which are affected by the\n\t *         change (i.e. the to BeUpdated and toBeDeleted resources)\n\t */\n\tpublic Collection<IResourceDescription.Delta> transitiveUpdate(IResourceDescriptions oldState, final ResourceSet rs,\n\t\t\tSet<URI> toBeUpdated, Set<URI> toBeDeleted, IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, \"Find affected resources\", 2);\n\t\tsubMonitor.subTask(\"Find affected resources\");\n\t\ttry {\n\t\t\tSet<URI> toBeDeletedAsSet = Sets.newHashSet(toBeDeleted);\n\t\t\ttoBeDeletedAsSet.removeAll(Collections2.forIterable(toBeUpdated));\n\t\t\tMap<URI, IResourceDescription.Delta> result = Maps.newHashMap();\n\t\t\t// add deleted\n\t\t\tfor (URI toDelete : toBeDeletedAsSet) {\n\t\t\t\tIResourceDescription resourceDescription = oldState.getResourceDescription(toDelete);\n\t\t\t\tif (resourceDescription != null)\n\t\t\t\t\tresult.put(toDelete, new DefaultResourceDescriptionDelta(resourceDescription, null));\n\t\t\t}\n\t\n\t\t\t// add toBeUpdated\n\t\t\tresult.putAll(update(oldState, rs, toBeUpdated, subMonitor.newChild(1)));\n\t\n\t\t\t// add dependent\n\t\t\twhile (true) {\n\t\t\t\tif (subMonitor.isCanceled())\n\t\t\t\t\treturn Collections.emptySet();\n\t\t\t\tsubMonitor.setWorkRemaining(1);\n\t\t\t\tShadowingResourceDescriptions newState = shadowingResourceDescriptionsProvider.get();\n\t\t\t\tnewState.setContext(rs);\n\t\t\t\tSet<IResourceDescription> descriptions = findAffectedResourceDescriptions(\n\t\t\t\t\t\toldState, newState, result.values(), subMonitor);\n\t\t\t\tSet<URI> uris = Sets.newHashSet(Iterables.transform(descriptions,\n\t\t\t\t\t\tnew Function<IResourceDescription, URI>() {\n\t\t\t\t\t\t\tpublic URI apply(IResourceDescription from) {\n\t\t\t\t\t\t\t\treturn from.getURI();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\turis.removeAll(result.keySet());\n\t\t\t\tif (!uris.isEmpty()) {\n\t\t\t\t\tresult.putAll(update(oldState, rs, uris, subMonitor.newChild(1)));\n\t\t\t\t} else {\n\t\t\t\t\treturn result.values();\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44747,"modified_method":"/**\n\t * This method computes the {@link IResourceDescription}s for all affected (i.e. added, updated or transitively\n\t * affected) resources. It does not change any state in the underlying\n\t * {@link org.eclipse.xtext.resource.IResourceDescriptions} instance.\n\t * \n\t * @param rs\n\t *            - The ResourceSet to use for reloading the to be updated resources\n\t * @param toBeUpdated\n\t *            - the URIs which have to be reloaded\n\t * @param toBeDeleted\n\t *            - the URIs which are about to be deleted\n\t * @return returns an iterable of fresh {@link IResourceDescription} for all resources, which are affected by the\n\t *         change (i.e. the to BeUpdated and toBeDeleted resources)\n\t */\n\tpublic Collection<IResourceDescription.Delta> transitiveUpdate(IResourceDescriptions oldState, final ResourceSet rs,\n\t\t\tSet<URI> toBeUpdated, Set<URI> toBeDeleted, IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, \"Find affected resources\", 10);\n\t\tsubMonitor.subTask(\"Find affected resources\");\n\t\t\t\n\t\tSet<URI> toBeDeletedAsSet = Sets.newHashSet(toBeDeleted);\n\t\ttoBeDeletedAsSet.removeAll(Collections2.forIterable(toBeUpdated));\n\t\tMap<URI, IResourceDescription.Delta> result = Maps.newHashMap();\n\t\t// add deleted\n\t\tfor (URI toDelete : toBeDeletedAsSet) {\n\t\t\tIResourceDescription resourceDescription = oldState.getResourceDescription(toDelete);\n\t\t\tif (resourceDescription != null)\n\t\t\t\tresult.put(toDelete, new DefaultResourceDescriptionDelta(resourceDescription, null));\n\t\t}\n\n\t\t// add toBeUpdated\n\t\tresult.putAll(update(oldState, rs, toBeUpdated, subMonitor.newChild(3)));\n\n\t\t// add dependent\n\t\twhile (true) {\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn Collections.emptySet();\n\t\t\tsubMonitor.setWorkRemaining(7);\n\t\t\tShadowingResourceDescriptions newState = shadowingResourceDescriptionsProvider.get();\n\t\t\tnewState.setContext(rs);\n\t\t\tSet<IResourceDescription> descriptions = findAffectedResourceDescriptions(\n\t\t\t\t\toldState, newState, result.values(), subMonitor.newChild(2));\n\t\t\tSet<URI> uris = Sets.newHashSet(Iterables.transform(descriptions,\n\t\t\t\t\tnew Function<IResourceDescription, URI>() {\n\t\t\t\t\t\tpublic URI apply(IResourceDescription from) {\n\t\t\t\t\t\t\treturn from.getURI();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\turis.removeAll(result.keySet());\n\t\t\tif (!uris.isEmpty()) {\n\t\t\t\tresult.putAll(update(oldState, rs, uris, subMonitor.newChild(3)));\n\t\t\t} else {\n\t\t\t\treturn result.values();\n\t\t\t}\n\t\t}\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Map<URI, IResourceDescription.Delta> update(IResourceDescriptions oldState, final ResourceSet set,\n\t\t\tSet<URI> toBeUpdated, IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, toBeUpdated.size() * 2);\n\t\tint total = toBeUpdated.size();\n\t\tint current = 1;\n\t\ttry {\n\t\t\tMap<URI, IResourceDescription.Delta> result = Maps.newHashMap();\n\t\t\tfor (URI uri : toBeUpdated) {\n\t\t\t\tif (subMonitor.isCanceled())\n\t\t\t\t\treturn Collections.emptyMap();\n\t\t\t\tResource res = null;\n\t\t\t\ttry {\n\t\t\t\t\tsubMonitor.subTask(\"Loading affected resource \" + current + \" of \" + total);\n\t\t\t\t\tres = set.getResource(uri, true);\n\t\t\t\t\tcurrent++;\n\t\t\t\t} catch (WrappedException ex) {\n\t\t\t\t\tif (set.getURIConverter().exists(uri, Collections.emptyMap()))\n\t\t\t\t\t\tlog.error(\"Error loading resource from: \" + uri.toString(), ex);\n\t\t\t\t\tif (res != null) {\n\t\t\t\t\t\tset.getResources().remove(res);\n\t\t\t\t\t}\n\t\t\t\t\tIResourceDescription oldDescription = oldState.getResourceDescription(uri);\n\t\t\t\t\tif (oldDescription != null)\n\t\t\t\t\t\tresult.put(uri, new DefaultResourceDescriptionDelta(oldDescription, null));\n\t\t\t\t}\n\t\t\t\tsubMonitor.worked(1);\n\t\t\t}\n\t\t\tfor (URI uri : toBeUpdated) {\n\t\t\t\tif (subMonitor.isCanceled())\n\t\t\t\t\treturn Collections.emptyMap();\n\t\t\t\tif (!result.containsKey(uri)) {\n\t\t\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(uri);\n\t\t\t\t\tif (manager != null) {\n\t\t\t\t\t\tResource resource = set.getResource(uri, false);\n\t\t\t\t\t\tIResourceDescription description = manager.getResourceDescription(resource);\n\t\t\t\t\t\tresult.put(uri, new DefaultResourceDescriptionDelta(oldState.getResourceDescription(uri),\n\t\t\t\t\t\t\t\tdescription));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsubMonitor.worked(1);\n\t\t\t}\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44748,"modified_method":"protected Map<URI, IResourceDescription.Delta> update(IResourceDescriptions oldState, ResourceSet set,\n\t\t\tSet<URI> toBeUpdated, IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, toBeUpdated.size() * 2);\n\t\tint total = toBeUpdated.size();\n\t\tint current = 1;\n\t\tMap<URI, IResourceDescription.Delta> result = Maps.newHashMap();\n\t\tfor (URI uri : toBeUpdated) {\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn Collections.emptyMap();\n\t\t\tResource res = null;\n\t\t\ttry {\n\t\t\t\tsubMonitor.subTask(\"Loading affected resource \" + current + \" of \" + total);\n\t\t\t\tres = set.getResource(uri, true);\n\t\t\t\tcurrent++;\n\t\t\t} catch (WrappedException ex) {\n\t\t\t\tif (set.getURIConverter().exists(uri, Collections.emptyMap()))\n\t\t\t\t\tlog.error(\"Error loading resource from: \" + uri.toString(), ex);\n\t\t\t\tif (res != null) {\n\t\t\t\t\tset.getResources().remove(res);\n\t\t\t\t}\n\t\t\t\tIResourceDescription oldDescription = oldState.getResourceDescription(uri);\n\t\t\t\tif (oldDescription != null)\n\t\t\t\t\tresult.put(uri, new DefaultResourceDescriptionDelta(oldDescription, null));\n\t\t\t}\n\t\t\tsubMonitor.worked(1);\n\t\t}\n\t\tsubMonitor.setWorkRemaining(total - result.size());\n\t\tfor (URI uri : toBeUpdated) {\n\t\t\tif (!result.containsKey(uri)) {\n\t\t\t\tif (subMonitor.isCanceled())\n\t\t\t\t\treturn Collections.emptyMap();\n\t\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(uri);\n\t\t\t\tif (manager != null) {\n\t\t\t\t\tResource resource = set.getResource(uri, false);\n\t\t\t\t\tIResourceDescription description = manager.getResourceDescription(resource);\n\t\t\t\t\tresult.put(uri, new DefaultResourceDescriptionDelta(\n\t\t\t\t\t\t\toldState.getResourceDescription(uri), description));\n\t\t\t\t}\n\t\t\t\tsubMonitor.worked(1);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public Collection<IResourceDescription.Delta> clean(IResourceDescriptions oldState, Set<URI> toBeDeleted, IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, \"Clean resources\", 2);\n\t\tsubMonitor.subTask(\"Clean resources\");\n\t\ttry {\n\t\t\tSet<URI> toBeDeletedAsSet = Sets.newHashSet(toBeDeleted);\n\t\t\tMap<URI, IResourceDescription.Delta> result = Maps.newHashMap();\n\t\t\t// add deleted\n\t\t\tfor (URI toDelete : toBeDeletedAsSet) {\n\t\t\t\tIResourceDescription resourceDescription = oldState.getResourceDescription(toDelete);\n\t\t\t\tif (resourceDescription != null)\n\t\t\t\t\tresult.put(toDelete, new DefaultResourceDescriptionDelta(resourceDescription, null));\n\t\t\t}\n\t\n\t\t\treturn result.values();\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44749,"modified_method":"public Collection<IResourceDescription.Delta> clean(IResourceDescriptions oldState, Set<URI> toBeDeleted, IProgressMonitor monitor) {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, \"Clean resources\", toBeDeleted.size());\n\t\tsubMonitor.subTask(\"Clean resources\");\n\t\t\n\t\tSet<URI> toBeDeletedAsSet = Sets.newHashSet(toBeDeleted);\n\t\tMap<URI, IResourceDescription.Delta> result = Maps.newHashMap();\n\t\t// add deleted\n\t\tfor (URI toDelete : toBeDeletedAsSet) {\n\t\t\tif (subMonitor.isCanceled())\n\t\t\t\treturn Collections.emptyList();\n\t\t\tIResourceDescription resourceDescription = oldState.getResourceDescription(toDelete);\n\t\t\tif (resourceDescription != null)\n\t\t\t\tresult.put(toDelete, new DefaultResourceDescriptionDelta(resourceDescription, null));\n\t\t\tsubMonitor.worked(1);\n\t\t}\n\n\t\treturn result.values();\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public ToBeBuilt updateProjectNewResourcesOnly(final IProject project, final IProgressMonitor monitor) throws CoreException {\n\t\tToBeBuilt toBeBuilt = updateProject(project, monitor);\n\t\tCollection<URI> existingURIs = Collections2.forIterable(Iterables.transform(builderState\n\t\t\t\t.getAllResourceDescriptions(), new Function<IResourceDescription, URI>() {\n\t\t\tpublic URI apply(IResourceDescription from) {\n\t\t\t\treturn from.getURI();\n\t\t\t}\n\t\t}));\n\t\ttoBeBuilt.getToBeDeleted().removeAll(existingURIs);\n\t\ttoBeBuilt.getToBeUpdated().removeAll(existingURIs);\n\t\treturn toBeBuilt;\n\t}","id":44750,"modified_method":"public ToBeBuilt updateProjectNewResourcesOnly(IProject project, IProgressMonitor monitor) throws CoreException {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, \"Collecting resources\", 1);\n\t\tprogress.subTask(\"Collecting resources\");\n\t\tToBeBuilt toBeBuilt = updateProject(project, progress.newChild(1));\n\t\tIterable<URI> existingURIs = Iterables.transform(\n\t\t\t\tbuilderState.getAllResourceDescriptions(), \n\t\t\t\tnew Function<IResourceDescription, URI>() {\n\t\t\t\t\tpublic URI apply(IResourceDescription from) {\n\t\t\t\t\t\treturn from.getURI();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t);\n\t\tfor(URI existingURI: existingURIs) {\n\t\t\ttoBeBuilt.getToBeDeleted().remove(existingURI);\n\t\t\ttoBeBuilt.getToBeUpdated().remove(existingURI);\n\t\t}\n\t\treturn toBeBuilt;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public ToBeBuilt updateProject(final IProject project, final IProgressMonitor monitor) throws CoreException {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, \"Collecting resources\", 1);\n\t\tsubMonitor.subTask(\"Collecting resources\");\n\t\ttry {\n\t\t\tfinal ToBeBuilt toBeBuilt = removeProject(project, monitor);\n\t\t\tif (!project.isAccessible())\n\t\t\t\treturn toBeBuilt;\n\t\t\tproject.accept(new IResourceVisitor() {\n\t\t\t\tpublic boolean visit(IResource resource) throws CoreException {\n\t\t\t\t\tif (resource instanceof IStorage) {\n\t\t\t\t\t\treturn updateStorage(monitor, toBeBuilt, (IStorage) resource);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn toBeBuilt;\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44751,"modified_method":"public ToBeBuilt updateProject(IProject project, IProgressMonitor monitor) throws CoreException {\n\t\tfinal SubMonitor progress = SubMonitor.convert(monitor, \"Collecting resources\", 1);\n\t\tprogress.subTask(\"Collecting resources\");\n\t\t\n\t\tfinal ToBeBuilt toBeBuilt = removeProject(project, progress.newChild(1));\n\t\tif (!project.isAccessible() || progress.isCanceled())\n\t\t\treturn toBeBuilt;\n\t\t\n\t\tproject.accept(new IResourceVisitor() {\n\t\t\tpublic boolean visit(IResource resource) throws CoreException {\n\t\t\t\tif (progress.isCanceled())\n\t\t\t\t\treturn false;\n\t\t\t\tif (resource instanceof IStorage) {\n\t\t\t\t\treturn updateStorage(null, toBeBuilt, (IStorage) resource);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\treturn toBeBuilt;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean updateStorage(final IProgressMonitor monitor, final ToBeBuilt toBeBuilt, IStorage storage) {\n\t\tif (monitor.isCanceled())\n\t\t\treturn false;\n\t\tif (!isHandled(storage))\n\t\t\treturn true;\n\t\tURI uri = getUri(storage);\n\t\tif (uri != null) {\n\t\t\ttoBeBuilt.getToBeUpdated().add(uri);\n\t\t}\n\t\treturn true;\n\t}","id":44752,"modified_method":"public boolean updateStorage(final IProgressMonitor monitor, final ToBeBuilt toBeBuilt, IStorage storage) {\n\t\tif (!isHandled(storage))\n\t\t\treturn true;\n\t\tURI uri = getUri(storage);\n\t\tif (uri != null) {\n\t\t\ttoBeBuilt.getToBeUpdated().add(uri);\n\t\t}\n\t\treturn true;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean removeStorage(final IProgressMonitor monitor, final ToBeBuilt toBeBuilt, IStorage storage) {\n\t\tif (monitor.isCanceled())\n\t\t\treturn false;\n\t\tif (!isHandled(storage))\n\t\t\treturn true;\n\t\tURI uri = getUri(storage);\n\t\tif (uri != null) {\n\t\t\ttoBeBuilt.getToBeDeleted().add(uri);\n\t\t}\n\t\treturn true;\n\t}","id":44753,"modified_method":"public boolean removeStorage(final IProgressMonitor monitor, final ToBeBuilt toBeBuilt, IStorage storage) {\n\t\tif (!isHandled(storage))\n\t\t\treturn true;\n\t\tURI uri = getUri(storage);\n\t\tif (uri != null) {\n\t\t\ttoBeBuilt.getToBeDeleted().add(uri);\n\t\t}\n\t\treturn true;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"public ToBeBuilt removeProject(IProject project, final IProgressMonitor monitor) {\n\t\tToBeBuilt result = new ToBeBuilt();\n\t\tSubMonitor.convert(monitor, 0);\n\t\tIterable<IResourceDescription> allResourceDescriptions = builderState.getAllResourceDescriptions();\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, Collections2.forIterable(allResourceDescriptions).size());\n\t\tfor (IResourceDescription description : allResourceDescriptions) {\n\t\t\tIterable<IStorage> storages = mapper.getStorages(description.getURI());\n\t\t\tif (!storages.iterator().hasNext()) {\n\t\t\t\tresult.getToBeDeleted().add(description.getURI());\n\t\t\t} else {\n\t\t\t\tfor (IStorage storage : storages) {\n\t\t\t\t\tif (isOnProject(storage, project))\n\t\t\t\t\t\tresult.getToBeDeleted().add(description.getURI());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsubMonitor.worked(1);\n\t\t}\n\t\treturn result;\n\t}","id":44754,"modified_method":"public ToBeBuilt removeProject(IProject project, IProgressMonitor monitor) {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, Iterables.size(builderState.getAllResourceDescriptions()));\n\t\tToBeBuilt result = new ToBeBuilt();\n\t\tIterable<IResourceDescription> allResourceDescriptions = builderState.getAllResourceDescriptions();\n\t\tfor (IResourceDescription description : allResourceDescriptions) {\n\t\t\tIterable<IStorage> storages = mapper.getStorages(description.getURI());\n\t\t\tif (!storages.iterator().hasNext()) {\n\t\t\t\tresult.getToBeDeleted().add(description.getURI());\n\t\t\t} else {\n\t\t\t\tfor (IStorage storage : storages) {\n\t\t\t\t\tif (isOnProject(storage, project))\n\t\t\t\t\t\tresult.getToBeDeleted().add(description.getURI());\n\t\t\t\t}\n\t\t\t}\n\t\t\tprogress.worked(1);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void fullBuild(final IProgressMonitor monitor, boolean isRecoveryBuild) throws CoreException {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 2);\n\t\ttry {\n\t\t\tIProject project = getProject();\n\t\t\tfinal ToBeBuilt toBeBuilt = (isRecoveryBuild) ? toBeBuiltComputer.updateProjectNewResourcesOnly(project,\n\t\t\t\t\tsubMonitor.newChild(1)) : toBeBuiltComputer.updateProject(project, subMonitor.newChild(1));\n\t\t\tdoBuild(toBeBuilt, subMonitor.newChild(1), isRecoveryBuild ? BuildType.RECOVERY : BuildType.FULL);\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44755,"modified_method":"/**\n\t * @param monitor the progress monitor to use for reporting progress to the user. It is the caller's responsibility\n\t *        to call done() on the given monitor. Accepts null, indicating that no progress should be\n\t *        reported and that the operation cannot be cancelled.\n\t */\n\tprotected void fullBuild(final IProgressMonitor monitor, boolean isRecoveryBuild) throws CoreException {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, 2);\n\t\t\n\t\tIProject project = getProject();\n\t\tToBeBuilt toBeBuilt = \n\t\t\tisRecoveryBuild\n\t\t\t\t? toBeBuiltComputer.updateProjectNewResourcesOnly(project, progress.newChild(1)) \n\t\t\t\t: toBeBuiltComputer.updateProject(project, progress.newChild(1));\n\t\tdoBuild(toBeBuilt, progress.newChild(1), \n\t\t\tisRecoveryBuild \n\t\t\t\t? BuildType.RECOVERY \n\t\t\t\t: BuildType.FULL);\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void incrementalBuild(IResourceDelta delta, final IProgressMonitor monitor) throws CoreException {\n\t\tfinal ToBeBuilt toBeBuilt = new ToBeBuilt();\n\t\tfinal SubMonitor subMonitor = SubMonitor.convert(monitor, \"Collecting resources\", 2);\n\t\tsubMonitor.subTask(\"Collecting resources\");\n\t\ttry {\n\t\t\tIResourceDeltaVisitor visitor = new IResourceDeltaVisitor() {\n\t\t\t\tpublic boolean visit(IResourceDelta delta) throws CoreException {\n\t\t\t\t\tif (delta.getResource() instanceof IStorage) {\n\t\t\t\t\t\tif (delta.getKind() == IResourceDelta.REMOVED) {\n\t\t\t\t\t\t\treturn toBeBuiltComputer.removeStorage(\n\t\t\t\t\t\t\t\t\tsubMonitor, \n\t\t\t\t\t\t\t\t\ttoBeBuilt, (IStorage) delta.getResource());\n\t\t\t\t\t\t} else if (delta.getKind() == IResourceDelta.ADDED || delta.getKind() == IResourceDelta.CHANGED) {\n\t\t\t\t\t\t\treturn toBeBuiltComputer.updateStorage(\n\t\t\t\t\t\t\t\t\tsubMonitor, \n\t\t\t\t\t\t\t\t\ttoBeBuilt, \n\t\t\t\t\t\t\t\t\t(IStorage) delta.getResource());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t};\n\t\t\tdelta.accept(visitor);\n\t\t\tsubMonitor.worked(1);\n\t\t\tdoBuild(toBeBuilt, subMonitor.newChild(1), BuildType.INCREMENTAL);\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44756,"modified_method":"/**\n\t * @param monitor the progress monitor to use for reporting progress to the user. It is the caller's responsibility\n\t *        to call done() on the given monitor. Accepts null, indicating that no progress should be\n\t *        reported and that the operation cannot be cancelled.\n\t */\n\tprotected void incrementalBuild(IResourceDelta delta, final IProgressMonitor monitor) throws CoreException {\n\t\tfinal SubMonitor progress = SubMonitor.convert(monitor, \"Collecting resources\", 2);\n\t\tprogress.subTask(\"Collecting resources\");\n\t\t\n\t\tfinal ToBeBuilt toBeBuilt = new ToBeBuilt();\n\t\tIResourceDeltaVisitor visitor = new IResourceDeltaVisitor() {\n\t\t\tpublic boolean visit(IResourceDelta delta) throws CoreException {\n\t\t\t\tif (progress.isCanceled())\n\t\t\t\t\treturn false;\n\t\t\t\t\n\t\t\t\tif (delta.getResource() instanceof IStorage) {\n\t\t\t\t\tif (delta.getKind() == IResourceDelta.REMOVED) {\n\t\t\t\t\t\treturn toBeBuiltComputer.removeStorage(\n\t\t\t\t\t\t\t\tnull, \n\t\t\t\t\t\t\t\ttoBeBuilt, \n\t\t\t\t\t\t\t\t(IStorage) delta.getResource());\n\t\t\t\t\t} else if (delta.getKind() == IResourceDelta.ADDED || delta.getKind() == IResourceDelta.CHANGED) {\n\t\t\t\t\t\treturn toBeBuiltComputer.updateStorage(\n\t\t\t\t\t\t\t\tnull, \n\t\t\t\t\t\t\t\ttoBeBuilt, \n\t\t\t\t\t\t\t\t(IStorage) \n\t\t\t\t\t\t\t\tdelta.getResource());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t\tdelta.accept(visitor);\n\t\tif (progress.isCanceled())\n\t\t\treturn;\n\t\tprogress.worked(1);\n\t\tdoBuild(toBeBuilt, progress.newChild(1), BuildType.INCREMENTAL);\n\t\t\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void clean(IProgressMonitor monitor) throws CoreException {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 2);\n\t\ttry {\n\t\t\tToBeBuilt toBeBuilt = toBeBuiltComputer.removeProject(getProject(), subMonitor.newChild(1));\n\t\t\tdoClean(toBeBuilt, subMonitor.newChild(1));\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44757,"modified_method":"/**\n\t * @param monitor the progress monitor to use for reporting progress to the user. It is the <em>implementors<\/em> responsibility\n\t *        to call done() on the given monitor. Accepts null, indicating that no progress should be\n\t *        reported and that the operation cannot be cancelled.\n\t */\n\t@Override\n\tprotected void clean(IProgressMonitor monitor) throws CoreException {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, 2);\n\t\ttry {\n\t\t\tToBeBuilt toBeBuilt = toBeBuiltComputer.removeProject(getProject(), progress.newChild(1));\n\t\t\tdoClean(toBeBuilt, progress.newChild(1));\n\t\t} finally {\n\t\t\tif (monitor != null)\n\t\t\t\tmonitor.done();\n\t\t}\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void doBuild(ToBeBuilt toBeBuilt, IProgressMonitor monitor, BuildType type) throws CoreException {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 2);\n\t\ttry {\n\t\t\tResourceSet resourceSet = getResourceSetProvider().get(getProject());\n\t\t\tif (resourceSet instanceof ResourceSetImpl) {\n\t\t\t\t((ResourceSetImpl) resourceSet).setURIResourceMap(Maps.<URI, Resource> newHashMap());\n\t\t\t}\n\t\t\tImmutableList<Delta> deltas = builderState.update(resourceSet, toBeBuilt.toBeUpdated,\n\t\t\t\t\ttoBeBuilt.toBeDeleted, subMonitor.newChild(1));\n\t\t\tif (participant != null) {\n\t\t\t\tparticipant.build(\n\t\t\t\t\t\tnew IXtextBuilderParticipant.BuildContext(this, resourceSet, deltas, type), \n\t\t\t\t\t\tsubMonitor.newChild(1));\n\t\t\t}\n\t\t\tresourceSet.getResources().clear();\n\t\t\tresourceSet.eAdapters().clear();\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44758,"modified_method":"/**\n\t * @param monitor the progress monitor to use for reporting progress to the user. It is the caller's responsibility\n\t *        to call done() on the given monitor. Accepts null, indicating that no progress should be\n\t *        reported and that the operation cannot be cancelled.\n\t */\n\tprotected void doBuild(ToBeBuilt toBeBuilt, IProgressMonitor monitor, BuildType type) throws CoreException {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, 2);\n\t\t\n\t\tResourceSet resourceSet = getResourceSetProvider().get(getProject());\n\t\tif (resourceSet instanceof ResourceSetImpl) {\n\t\t\t((ResourceSetImpl) resourceSet).setURIResourceMap(Maps.<URI, Resource> newHashMap());\n\t\t}\n\t\tImmutableList<Delta> deltas = builderState.update(\n\t\t\t\tresourceSet, \n\t\t\t\ttoBeBuilt.toBeUpdated,\n\t\t\t\ttoBeBuilt.toBeDeleted, \n\t\t\t\tprogress.newChild(1));\n\t\tif (participant != null) {\n\t\t\tparticipant.build(\n\t\t\t\t\tnew IXtextBuilderParticipant.BuildContext(this, resourceSet, deltas, type), \n\t\t\t\t\tprogress.newChild(1));\n\t\t} else {\n\t\t\tprogress.worked(1);\n\t\t}\n\t\tresourceSet.getResources().clear();\n\t\tresourceSet.eAdapters().clear();\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void doClean(ToBeBuilt toBeBuilt, IProgressMonitor monitor) throws CoreException {\n\t\tSubMonitor subMonitor = SubMonitor.convert(monitor, 2);\n\t\ttry {\n\t\t\tImmutableList<Delta> deltas = builderState.clean(toBeBuilt.toBeDeleted, subMonitor.newChild(1));\n\t\t\tif (participant != null)\n\t\t\t\tparticipant.build(new IXtextBuilderParticipant.BuildContext(this, \n\t\t\t\t\t\tgetResourceSetProvider().get(getProject()), \n\t\t\t\t\t\tdeltas,\n\t\t\t\t\t\tBuildType.CLEAN), \n\t\t\t\t\t\tsubMonitor.newChild(1));\n\t\t} finally {\n\t\t\tsubMonitor.done();\n\t\t}\n\t}","id":44759,"modified_method":"/**\n\t * @param monitor the progress monitor to use for reporting progress to the user. It is the caller's responsibility\n\t *        to call done() on the given monitor. Accepts null, indicating that no progress should be\n\t *        reported and that the operation cannot be cancelled.\n\t */\n\tprotected void doClean(ToBeBuilt toBeBuilt, IProgressMonitor monitor) throws CoreException {\n\t\tSubMonitor progress = SubMonitor.convert(monitor, 2);\n\t\tImmutableList<Delta> deltas = builderState.clean(toBeBuilt.toBeDeleted, progress.newChild(1));\n\t\tif (participant != null) {\n\t\t\tparticipant.build(new IXtextBuilderParticipant.BuildContext(this, \n\t\t\t\t\tgetResourceSetProvider().get(getProject()), \n\t\t\t\t\tdeltas,\n\t\t\t\t\tBuildType.CLEAN), \n\t\t\t\t\tprogress.newChild(1));\n\t\t} else {\n\t\t\tprogress.worked(1);\n\t\t}\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"@SuppressWarnings(\"rawtypes\")\n\t@Override\n\tprotected IProject[] build(int kind, Map args, IProgressMonitor monitor) throws CoreException {\n\t\ttry {\n\t\t\tfinal String taskName = \"Building \" + getProject().getName() + \": \";\n\t\t\tmonitor = new ProgressMonitorWrapper(monitor) {\n\t\t\t\t@Override\n\t\t\t\tpublic void subTask(String name) {\n\t\t\t\t\tsuper.subTask(taskName + name);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (kind == FULL_BUILD) {\n\t\t\t\tfullBuild(monitor, IBuildFlag.RECOVERY_BUILD.isSet(args));\n\t\t\t} else {\n\t\t\t\tIResourceDelta delta = getDelta(getProject());\n\t\t\t\tif (delta == null || isOpened(delta)) {\n\t\t\t\t\tfullBuild(monitor, IBuildFlag.RECOVERY_BUILD.isSet(args));\n\t\t\t\t} else {\n\t\t\t\t\tincrementalBuild(delta, monitor);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (CoreException e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t} finally {\n\t\t\tmonitor.done();\n\t\t}\n\t\treturn null;\n\t}","id":44760,"modified_method":"@SuppressWarnings(\"rawtypes\")\n\t@Override\n\tprotected IProject[] build(int kind, Map args, IProgressMonitor monitor) throws CoreException {\n\t\ttry {\n\t\t\tif (monitor != null) {\n\t\t\t\tfinal String taskName = \"Building \" + getProject().getName() + \": \";\n\t\t\t\tmonitor = new ProgressMonitorWrapper(monitor) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void subTask(String name) {\n\t\t\t\t\t\tsuper.subTask(taskName + name);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tSubMonitor progress = SubMonitor.convert(monitor, 1);\n\t\t\tif (kind == FULL_BUILD) {\n\t\t\t\tfullBuild(progress.newChild(1), IBuildFlag.RECOVERY_BUILD.isSet(args));\n\t\t\t} else {\n\t\t\t\tIResourceDelta delta = getDelta(getProject());\n\t\t\t\tif (delta == null || isOpened(delta)) {\n\t\t\t\t\tfullBuild(progress.newChild(1), IBuildFlag.RECOVERY_BUILD.isSet(args));\n\t\t\t\t} else {\n\t\t\t\t\tincrementalBuild(delta, progress.newChild(1));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (CoreException e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t\tthrow e;\n\t\t} catch (Exception e) {\n\t\t\tlog.error(e.getMessage(), e);\n\t\t} finally {\n\t\t\tif (monitor != null)\n\t\t\t\tmonitor.done();\n\t\t}\n\t\treturn null;\n\t}","commit_id":"bc6cf49aa96eec73243e6d866156706d826dc256","url":"https://github.com/eclipse/xtext"},{"original_method":"private IMarkerResolutionGenerator2 getResolutionGenerator() {\n        return resolutionGenerator;\n    }","id":44761,"modified_method":"protected IMarkerResolutionGenerator2 getResolutionGenerator() {\n        return resolutionGenerator;\n    }","commit_id":"9bb79e4b1fa8a5c3dd362f8d9745d6f2cde15c6e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void assertPresentBugPattern(String bugPatternType, IMarker[] markers) {\n        for (int i = 0; i < markers.length; i++) {\n            BugPattern pattern = MarkerUtil.findBugPatternForMarker(markers[i]);\n            if (pattern.getType().equals(bugPatternType)) {\n                return;\n            }\n        }\n        fail(\"Couldn't find pattern \" + bugPatternType);\n    }","id":44762,"modified_method":"protected void assertPresentBugPattern(String bugPatternType, IMarker[] markers) {\n        for (int i = 0; i < markers.length; i++) {\n            BugPattern pattern = MarkerUtil.findBugPatternForMarker(markers[i]);\n            if (pattern.getType().equals(bugPatternType)) {\n                return;\n            }\n        }\n        fail(\"Couldn't find pattern \" + bugPatternType);\n    }","commit_id":"9bb79e4b1fa8a5c3dd362f8d9745d6f2cde15c6e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void assertPresentBugPatterns(String[] expectedPatterns, IMarker[] markers) {\n        for (int i = 0; i < expectedPatterns.length; i++) {\n            assertPresentBugPattern(expectedPatterns[i], markers);\n        }\n    }","id":44763,"modified_method":"protected void assertPresentBugPatterns(String[] expectedPatterns, IMarker[] markers) {\n        for (int i = 0; i < expectedPatterns.length; i++) {\n            assertPresentBugPattern(expectedPatterns[i], markers);\n        }\n    }","commit_id":"9bb79e4b1fa8a5c3dd362f8d9745d6f2cde15c6e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void assertAllMarkersHaveResolutions(IMarker[] markers) {\n        for (int i = 0; i < markers.length; i++) {\n            assertTrue(getResolutionGenerator().hasResolutions(markers[i]));\n        }\n    }","id":44764,"modified_method":"protected void assertAllMarkersHaveResolutions(IMarker[] markers) {\n        for (int i = 0; i < markers.length; i++) {\n            assertTrue(getResolutionGenerator().hasResolutions(markers[i]));\n        }\n    }","commit_id":"9bb79e4b1fa8a5c3dd362f8d9745d6f2cde15c6e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n    public void run(IMarker[] markers, IProgressMonitor multipleFixMonitor) {\n        List<PendingRewrite> pendingRewrites = new ArrayList<>(markers.length);\n        for (int i = 0; i < markers.length; i++) {\n            // this was done in the superclass implementation\n            multipleFixMonitor.subTask(Util.getProperty(IMarker.MESSAGE, markers[i]));\n            pendingRewrites.add(resolveWithoutWriting(markers[i]));\n        }\n\n        // fully commit all changes\n        for (PendingRewrite pendingRewrite : pendingRewrites) {\n            completeRewrite(pendingRewrite);\n        }\n    }","id":44765,"modified_method":"@Override\n    public void run(IMarker[] markers, IProgressMonitor multipleFixMonitor) {\n        List<PendingRewrite> pendingRewrites = new ArrayList<>(markers.length);\n        for (int i = 0; i < markers.length; i++) {\n            // this was done in the superclass implementation\n            if (multipleFixMonitor != null) {\n                multipleFixMonitor.subTask(Util.getProperty(IMarker.MESSAGE, markers[i]));\n            }\n            pendingRewrites.add(resolveWithoutWriting(markers[i]));\n        }\n\n        // fully commit all changes\n        for (PendingRewrite pendingRewrite : pendingRewrites) {\n            completeRewrite(pendingRewrite);\n        }\n    }","commit_id":"9bb79e4b1fa8a5c3dd362f8d9745d6f2cde15c6e","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + Arrays.hashCode(nonBlankTokens);\n    result = prime * result + Arrays.hashCode(tokens);\n    result = prime * result + Arrays.hashCode(whPositions);\n    // tokenSet and lemmaSet are a subset of tokens and don't need to be included\n    return result;\n  }","id":44766,"modified_method":"@Override\n  public int hashCode() {\n    // tokenSet and lemmaSet are a subset of tokens and don't need to be included\n    return Objects.hash(nonBlankTokens, tokens, whPositions);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@SuppressWarnings(\"ControlFlowStatementWithoutBraces\")\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass() != obj.getClass())\n      return false;\n    final AnalyzedSentence other = (AnalyzedSentence) obj;\n    if (!Arrays.equals(nonBlankTokens, other.nonBlankTokens))\n      return false;\n    if (!Arrays.equals(tokens, other.tokens))\n      return false;\n    if (!Arrays.equals(whPositions, other.whPositions))\n      return false;\n    // tokenSet and lemmaSet are a subset of tokens and don't need to be included\n    return true;\n  }","id":44767,"modified_method":"@SuppressWarnings(\"ControlFlowStatementWithoutBraces\")\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null) return false;\n    if (getClass() != o.getClass()) return false;\n    AnalyzedSentence other = (AnalyzedSentence) o;\n    // tokenSet and lemmaSet are a subset of tokens and don't need to be included\n    return Arrays.equals(nonBlankTokens, other.nonBlankTokens) \n        && Arrays.equals(tokens, other.tokens)\n        && Arrays.equals(whPositions, other.whPositions);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public int hashCode() {\n    return new HashCodeBuilder().append(isWhitespaceBefore).append(lemma).append(posTag).append(token).toHashCode();\n  }","id":44768,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hash(isWhitespaceBefore, lemma, posTag, token);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public boolean equals(final Object obj) {\n    if (obj == null) { return false; }\n    if (obj == this) { return true; }\n    if (obj.getClass() != getClass()) {\n      return false;\n    }\n    final AnalyzedToken rhs = (AnalyzedToken) obj;\n    return new EqualsBuilder()\n            .append(token, rhs.token)\n            .append(posTag, rhs.posTag)\n            .append(lemma, rhs.lemma)\n            .append(isWhitespaceBefore, rhs.isWhitespaceBefore)\n            .isEquals();\n  }","id":44769,"modified_method":"@Override\n  public boolean equals(final Object o) {\n    if (o == null) return false;\n    if (o == this) return true;\n    if (o.getClass() != getClass()) return false;\n    AnalyzedToken other = (AnalyzedToken) o;\n    return Objects.equals(token, other.token)\n        && Objects.equals(posTag, other.posTag)\n        && Objects.equals(lemma, other.lemma)\n        && Objects.equals(isWhitespaceBefore, other.isWhitespaceBefore);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ConfusionSet other = (ConfusionSet) o;\n    if (factor != other.factor) return false;\n    if (!set.equals(other.set)) return false;\n    return true;\n  }","id":44770,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ConfusionSet other = (ConfusionSet) o;\n    return Objects.equals(set, other.set) && Objects.equals(factor, other.factor);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public int hashCode() {\n    int result = set.hashCode();\n    result = 31 * result + (int) (factor ^ (factor >>> 32));\n    return result;\n  }","id":44771,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hash(set, factor);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public int hashCode() {\n    int result = str.hashCode();\n    result = 31 * result + (description != null ? description.hashCode() : 0);\n    return result;\n  }","id":44772,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hash(str, description);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ConfusionString that = (ConfusionString) o;\n    if (!str.equals(that.str)) return false;\n    if (description != null ? !description.equals(that.description) : that.description != null) return false;\n    return true;\n  }","id":44773,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    ConfusionString other = (ConfusionString) o;\n    return Objects.equals(str, other.str) && Objects.equals(description, other.description);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public boolean equals(final Object obj) {\n    if (this == obj) { return true; }\n    if (obj == null) { return false; }\n    if (getClass() != obj.getClass()) {\n      return false;\n    }\n    final EquivalenceTypeLocator other = (EquivalenceTypeLocator) obj;\n    return Objects.equals(feature, other.feature) &&\n            Objects.equals(type, other.type);\n  }","id":44774,"modified_method":"@Override\n  public boolean equals(final Object o) {\n    if (this == o) { return true; }\n    if (o == null) { return false; }\n    if (getClass() != o.getClass()) {\n      return false;\n    }\n    EquivalenceTypeLocator other = (EquivalenceTypeLocator) o;\n    return Objects.equals(feature, other.feature)\n        && Objects.equals(type, other.type);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public int hashCode() {\n    int result = start;\n    result = 31 * result + end;\n    return result;\n  }","id":44775,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hash(start, end);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    MatchPosition position = (MatchPosition) o;\n    if (end != position.end) return false;\n    if (start != position.start) return false;\n    return true;\n  }","id":44776,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    MatchPosition other = (MatchPosition) o;\n    return Objects.equals(start, other.start) && Objects.equals(end, other.end);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    RuleMatch other = (RuleMatch) o;\n    return new EqualsBuilder()\n            .append(rule.getId(), other.rule.getId())\n            .append(offsetPosition, other.offsetPosition)\n            .append(message, other.message)\n            .append(suggestedReplacements, other.suggestedReplacements)\n            .isEquals();\n  }","id":44777,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    RuleMatch other = (RuleMatch) o;\n    return Objects.equals(rule.getId(), other.rule.getId())\n        && Objects.equals(offsetPosition, other.offsetPosition)\n        && Objects.equals(message, other.message)\n        && Objects.equals(suggestedReplacements, other.suggestedReplacements);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public int hashCode() {\n    return new HashCodeBuilder()\n            .append(rule.getId())\n            .append(offsetPosition)\n            .append(message)\n            .append(suggestedReplacements).toHashCode();\n  }","id":44778,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hash(rule.getId(), offsetPosition, message, suggestedReplacements);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public int hashCode() {\n    int result = lemma != null ? lemma.hashCode() : 0;\n    result = 31 * result + (posTag != null ? posTag.hashCode() : 0);\n    return result;\n  }","id":44779,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hash(lemma, posTag);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    TaggedWord that = (TaggedWord) o;\n    if (lemma != null ? !lemma.equals(that.lemma) : that.lemma != null) return false;\n    if (posTag != null ? !posTag.equals(that.posTag) : that.posTag != null) return false;\n    return true;\n  }","id":44780,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    TaggedWord other = (TaggedWord) o;\n    return Objects.equals(lemma, other.lemma) && Objects.equals(posTag, other.posTag);\n  }","commit_id":"77a6bb79f3236402be25148087c421aac7bb7187","url":"https://github.com/languagetool-org/languagetool"},{"original_method":"public int getNextStepDepth(final SuspendContextImpl context) {\n    try {\n      if (myPosition != null) {\n        final SourcePosition locationPosition = ApplicationManager.getApplication().runReadAction(new Computable<SourcePosition>() {\n          public SourcePosition compute() {\n            return ContextUtil.getSourcePosition(context);          \n          }\n        });\n\n        if (locationPosition != null) {\n          if (myDepth == StepRequest.STEP_OVER || myDepth == StepRequest.STEP_INTO) {\n            int frameCount = -1;\n            if (context.getFrameProxy() != null) {\n              try {\n                frameCount = context.getFrameProxy().threadProxy().frameCount();\n              }\n              catch (EvaluateException e) {\n              }\n            }\n            final boolean filesEqual = myPosition.getFile().equals(locationPosition.getFile());\n            if (filesEqual && myPosition.getLine() == locationPosition.getLine() && myFrameCount == frameCount) {\n              return myDepth;\n            }\n            if (myDepth == StepRequest.STEP_INTO) {\n              // check if we are still at the line from which the stepping begun\n              if (filesEqual && myFrameCount == frameCount && myPosition.getLine() != locationPosition.getLine()) {\n                return STOP;\n              }\n            }\n          }\n        }\n      }\n      // the rest of the code makes sence for depth == STEP_INTO only\n\n      if (myDepth == StepRequest.STEP_INTO) {\n        final DebuggerSettings settings = DebuggerSettings.getInstance();\n        if (settings.SKIP_SYNTHETIC_METHODS) {\n          Location location = context.getFrameProxy().location();\n          Method method = location.method();\n          if (method != null) {\n            if (myVirtualMachineProxy.canGetSyntheticAttribute()? method.isSynthetic() : method.name().indexOf('$') >= 0) {\n              return myDepth;\n            }\n          }\n        }\n        if (!myIgnoreFilters) {\n          if(settings.SKIP_GETTERS) {\n            boolean isGetter = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){\n              public Boolean compute() {\n                final PsiMethod psiMethod = PsiTreeUtil.getParentOfType(PositionUtil.getContextElement(context), PsiMethod.class);\n                return (psiMethod != null && DebuggerUtils.isSimpleGetter(psiMethod))? Boolean.TRUE : Boolean.FALSE;\n              }\n            }).booleanValue();\n\n            if(isGetter) {\n              return StepRequest.STEP_OUT;\n            }\n          }\n\n          if (settings.SKIP_CONSTRUCTORS) {\n            Location location = context.getFrameProxy().location();\n            Method method = location.method();\n            if (method != null && method.isConstructor()) {\n              return StepRequest.STEP_OUT;\n            }\n          }\n\n          if (settings.SKIP_CLASSLOADERS) {\n            Location location = context.getFrameProxy().location();\n            if (DebuggerUtilsEx.isAssignableFrom(\"java.lang.ClassLoader\", location.declaringType())) {\n              return StepRequest.STEP_OUT;\n            }\n          }\n        }\n        // smart step feature\n        if (myTargetMethodSignature != null) {\n          final Location location = context.getFrameProxy().location();\n          if (!myTargetMethodSignature.shouldStopAtLocation(location)) {\n            return StepRequest.STEP_OUT;\n          }\n        }\n      }\n    }\n    catch (VMDisconnectedException e) {\n    }\n    catch (EvaluateException e) {\n      LOG.error(e);\n    }\n    return STOP;\n  }","id":44781,"modified_method":"public int getNextStepDepth(final SuspendContextImpl context) {\n    try {\n      if (myPosition != null) {\n        final SourcePosition locationPosition = ApplicationManager.getApplication().runReadAction(new Computable<SourcePosition>() {\n          public SourcePosition compute() {\n            return ContextUtil.getSourcePosition(context);          \n          }\n        });\n\n        if (locationPosition != null) {\n          if (myDepth == StepRequest.STEP_OVER || myDepth == StepRequest.STEP_INTO) {\n            int frameCount = -1;\n            if (context.getFrameProxy() != null) {\n              try {\n                frameCount = context.getFrameProxy().threadProxy().frameCount();\n              }\n              catch (EvaluateException e) {\n              }\n            }\n            final boolean filesEqual = myPosition.getFile().equals(locationPosition.getFile());\n            if (filesEqual && myPosition.getLine() == locationPosition.getLine() && myFrameCount == frameCount) {\n              return myDepth;\n            }\n            if (myDepth == StepRequest.STEP_INTO) {\n              // check if we are still at the line from which the stepping begun\n              if (filesEqual && myFrameCount == frameCount && myPosition.getLine() != locationPosition.getLine()) {\n                return STOP;\n              }\n            }\n          }\n        }\n      }\n      // the rest of the code makes sence for depth == STEP_INTO only\n\n      if (myDepth == StepRequest.STEP_INTO) {\n        final DebuggerSettings settings = DebuggerSettings.getInstance();\n        if (settings.SKIP_SYNTHETIC_METHODS) {\n          Location location = context.getFrameProxy().location();\n          Method method = location.method();\n          if (method != null) {\n            if (myVirtualMachineProxy.canGetSyntheticAttribute()? method.isSynthetic() : method.name().indexOf('$') >= 0) {\n              return myDepth;\n            }\n          }\n        }\n        if (!myIgnoreFilters) {\n          if(settings.SKIP_GETTERS) {\n            boolean isGetter = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>(){\n              public Boolean compute() {\n                final PsiMethod psiMethod = PsiTreeUtil.getParentOfType(PositionUtil.getContextElement(context), PsiMethod.class);\n                return (psiMethod != null && DebuggerUtils.isSimpleGetter(psiMethod))? Boolean.TRUE : Boolean.FALSE;\n              }\n            }).booleanValue();\n\n            if(isGetter) {\n              return StepRequest.STEP_OUT;\n            }\n          }\n\n          if (settings.SKIP_CONSTRUCTORS) {\n            Location location = context.getFrameProxy().location();\n            Method method = location.method();\n            if (method != null && method.isConstructor()) {\n              return StepRequest.STEP_OUT;\n            }\n          }\n\n          if (settings.SKIP_CLASSLOADERS) {\n            Location location = context.getFrameProxy().location();\n            if (DebuggerUtilsEx.isAssignableFrom(\"java.lang.ClassLoader\", location.declaringType())) {\n              return StepRequest.STEP_OUT;\n            }\n          }\n        }\n        // smart step feature\n        if (myTargetMethodSignature != null) {\n          final Location location = context.getFrameProxy().location();\n          if (!myTargetMethodSignature.shouldStopAtLocation(location, context.getDebugProcess())) {\n            return StepRequest.STEP_OUT;\n          }\n        }\n      }\n    }\n    catch (VMDisconnectedException e) {\n    }\n    catch (EvaluateException e) {\n      LOG.error(e);\n    }\n    return STOP;\n  }","commit_id":"2214686722da8438dddb3ff4f60ea420ba492bf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean shouldStopAtLocation(Location location) {\n      final Method method = location.method();\n      final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n      try {\n        builder.append(method.name());\n        builder.append(method.signature());\n        if (!myTargetMethodSignature.equals(builder.toString())) {\n          return false;\n        }\n      }\n      finally{\n        StringBuilderSpinAllocator.dispose(builder);\n      }\n      final ReferenceType declaringType = method.declaringType();\n      return DebuggerUtilsEx.isAssignableFrom(myDeclaringClassName, declaringType);\n    }","id":44782,"modified_method":"public boolean shouldStopAtLocation(Location location, final DebugProcessImpl debugProcess) {\n      try {\n        final Method method = location.method();\n        if (!myTargetMethodName.equals(method.name())) {\n          return false;\n        }\n        if (!myTargetMethodSignature.getName(debugProcess).equals(method.signature())) {\n          return false;\n        }\n        final ReferenceType declaringType = method.declaringType();\n        return DebuggerUtilsEx.isAssignableFrom(myDeclaringClassName.getName(debugProcess), declaringType);\n      }\n      catch (EvaluateException e) {\n        LOG.info(e);\n      }\n      return true;\n    }","commit_id":"2214686722da8438dddb3ff4f60ea420ba492bf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SmartStepFilter(PsiMethod psiMethod, final DebugProcessImpl debugProcess) throws EvaluateException {\n      myDeclaringClassName = JVMNameUtil.getJVMQualifiedName(psiMethod.getContainingClass()).getName(debugProcess);\n      final JVMName methodSignature = JVMNameUtil.getJVMSignature(psiMethod);\n      @NonNls final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n      try {\n        builder.append(psiMethod.isConstructor()? \"<init>\" : psiMethod.getName());\n        builder.append(methodSignature.getName(debugProcess));\n        myTargetMethodSignature = builder.toString();\n      }\n      finally {\n        StringBuilderSpinAllocator.dispose(builder);\n      }\n    }","id":44783,"modified_method":"public SmartStepFilter(PsiMethod psiMethod) {\n      myDeclaringClassName = JVMNameUtil.getJVMQualifiedName(psiMethod.getContainingClass());\n      myTargetMethodName = psiMethod.isConstructor()? \"<init>\" : psiMethod.getName();\n      myTargetMethodSignature = JVMNameUtil.getJVMSignature(psiMethod);\n    }","commit_id":"2214686722da8438dddb3ff4f60ea420ba492bf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static RequestHint.SmartStepFilter createSmartStepFilter(final PsiMethod method, final DebuggerSession session) {\n    try {\n      return new RequestHint.SmartStepFilter(method, session.getProcess());\n    }\n    catch (EvaluateException e) {\n      return null;\n    }\n  }","id":44784,"modified_method":"@Nullable\n  private static RequestHint.SmartStepFilter createSmartStepFilter(final PsiMethod method) {\n    return new RequestHint.SmartStepFilter(method);\n  }","commit_id":"2214686722da8438dddb3ff4f60ea420ba492bf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doStep(final @NotNull Project project, final @Nullable SourcePosition position, final @NotNull DebuggerSession session) {\n    final VirtualFile file = position != null ? position.getFile().getVirtualFile() : null;\n    final FileEditor fileEditor = file != null? FileEditorManager.getInstance(project).getSelectedEditor(file) : null;\n    if (fileEditor instanceof TextEditor) {\n      final List<PsiMethod> methods = findReferencedMethods(position);\n      if (methods.size() > 0) {\n        if (methods.size() == 1) {\n          session.stepInto(false, createSmartStepFilter(methods.get(0), session));\n        }\n        else {\n          final PsiMethodListPopupStep popupStep = new PsiMethodListPopupStep(methods, new PsiMethodListPopupStep.OnChooseRunnable() {\n            public void execute(PsiMethod chosenMethod) {\n              session.stepInto(false, createSmartStepFilter(chosenMethod, session));\n            }\n          });\n          final ListPopup popup = JBPopupFactory.getInstance().createListPopup(popupStep);\n          final RelativePoint point = calcPopupLocation(((TextEditor)fileEditor).getEditor(), position);\n          popup.show(point);\n        }\n        return;\n      }\n    }\n    session.stepInto(false, null);\n  }","id":44785,"modified_method":"private static void doStep(final @NotNull Project project, final @Nullable SourcePosition position, final @NotNull DebuggerSession session) {\n    final VirtualFile file = position != null ? position.getFile().getVirtualFile() : null;\n    final FileEditor fileEditor = file != null? FileEditorManager.getInstance(project).getSelectedEditor(file) : null;\n    if (fileEditor instanceof TextEditor) {\n      final List<PsiMethod> methods = findReferencedMethods(position);\n      if (methods.size() > 0) {\n        if (methods.size() == 1) {\n          session.stepInto(false, createSmartStepFilter(methods.get(0)));\n        }\n        else {\n          final PsiMethodListPopupStep popupStep = new PsiMethodListPopupStep(methods, new PsiMethodListPopupStep.OnChooseRunnable() {\n            public void execute(PsiMethod chosenMethod) {\n              session.stepInto(false, createSmartStepFilter(chosenMethod));\n            }\n          });\n          final ListPopup popup = JBPopupFactory.getInstance().createListPopup(popupStep);\n          final RelativePoint point = calcPopupLocation(((TextEditor)fileEditor).getEditor(), position);\n          popup.show(point);\n        }\n        return;\n      }\n    }\n    session.stepInto(false, null);\n  }","commit_id":"2214686722da8438dddb3ff4f60ea420ba492bf9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int hashCode() {\n    return new HashCodeBuilder()\n      .append(beforeFile)\n      .append(afterFile)\n      .append(status)\n      .toHashCode();\n  }","id":44786,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(beforeFile, afterFile, status);\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean equals(Object object) {\n    if (object == this) {\n      return true;\n    }\n    if (!(object instanceof HgChange)) {\n      return false;\n    }\n    HgChange that = (HgChange) object;\n    return new EqualsBuilder()\n      .append(beforeFile, that.beforeFile)\n      .append(afterFile, that.afterFile)\n      .append(status, that.status)\n      .isEquals();\n  }","id":44787,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    HgChange change = (HgChange)o;\n\n    if (!afterFile.equals(change.afterFile)) {\n      return false;\n    }\n    if (!beforeFile.equals(change.beforeFile)) {\n      return false;\n    }\n    if (status != change.status) {\n      return false;\n    }\n\n    return true;\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean equals(Object object) {\n    if (object == this) {\n      return true;\n    }\n    if (!(object instanceof HgContentRevision)) {\n      return false;\n    }\n    HgContentRevision that = (HgContentRevision) object;\n    return new EqualsBuilder()\n      .append(myHgFile, that.myHgFile)\n      .append(myRevisionNumber, that.myRevisionNumber)\n      .isEquals();\n  }","id":44788,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    HgContentRevision revision = (HgContentRevision)o;\n\n    if (!myHgFile.equals(revision.myHgFile)) {\n      return false;\n    }\n    if (!myRevisionNumber.equals(revision.myRevisionNumber)) {\n      return false;\n    }\n\n    return true;\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int hashCode() {\n    return new HashCodeBuilder()\n      .append(myHgFile)\n      .append(myRevisionNumber)\n      .toHashCode();\n  }","id":44789,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(myHgFile, myRevisionNumber);\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int hashCode() {\n    return new HashCodeBuilder()\n      .append(vcsRoot)\n      .append(file)\n      .toHashCode();\n  }","id":44790,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(vcsRoot, file);\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String toString() {\n    return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE)\n      .append(\"repo\", vcsRoot)\n      .append(\"file\", file)\n      .append(\"relativePath\", getRelativePath())\n      .toString();\n  }","id":44791,"modified_method":"@Override\n  public String toString() {\n    return Objects.toStringHelper(HgFile.class)\n      .add(\"repo\", vcsRoot)\n      .add(\"file\", file)\n      .add(\"relativePath\", getRelativePath())\n      .toString();\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean equals(Object object) {\n    if (object == this) {\n      return true;\n    }\n    if (!(object instanceof HgFile)) {\n      return false;\n    }\n    HgFile that = (HgFile) object;\n    return new EqualsBuilder()\n      .append(vcsRoot, that.vcsRoot)\n      .append(file, that.file)\n      .isEquals();\n  }","id":44792,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    HgFile that = (HgFile)o;\n\n    if (!vcsRoot.equals(that.vcsRoot)) {\n      return false;\n    }\n    if (file != null ? !FileUtil.filesEqual(file, that.file) : that.file != null) {\n      return false;\n    }\n\n    return true;\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean equals(Object object) {\n    if (object == this) {\n      return true;\n    }\n    if (!(object instanceof HgFileRevision)) {\n      return false;\n    }\n    HgFileRevision that = (HgFileRevision) object;\n    return new EqualsBuilder()\n      .append(hgFile, that.hgFile)\n      .append(vcsRevisionNumber, that.vcsRevisionNumber)\n      .isEquals();\n  }","id":44793,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    HgFileRevision revision = (HgFileRevision)o;\n\n    if (!hgFile.equals(revision.hgFile)) {\n      return false;\n    }\n    if (!vcsRevisionNumber.equals(revision.vcsRevisionNumber)) {\n      return false;\n    }\n\n    return true;\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int hashCode() {\n    return new HashCodeBuilder()\n      .append(hgFile)\n      .append(vcsRevisionNumber)\n      .toHashCode();\n  }","id":44794,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(hgFile, vcsRevisionNumber);\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int hashCode() {\n    return new HashCodeBuilder()\n      .append(revision)\n      .append(changeset)\n      .toHashCode();\n  }","id":44795,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(revision, changeset);\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final List<HgFileRevision> execute(HgFile hgFile, int limit, boolean includeFiles) {\n    if ((limit <= 0 && limit != -1) || hgFile == null || hgFile.getRepo() == null) {\n      return Collections.emptyList();\n    }\n\n    HgCommandExecutor hgCommandExecutor = new HgCommandExecutor(project);\n\n    String template = HgChangesetUtil.makeTemplate(includeFiles ? LONG_TEMPLATE_ITEMS : SHORT_TEMPLATE_ITEMS);\n    int itemCount = includeFiles ? LONG_TEMPLATE_ITEMS.length : SHORT_TEMPLATE_ITEMS.length;\n\n    FilePath originalFileName = HgUtil.getOriginalFileName(hgFile.toFilePath(), ChangeListManager.getInstance(project));\n    HgFile originalHgFile = new HgFile(hgFile.getRepo(), originalFileName);\n    HgCommandResult result = execute(\n      hgCommandExecutor, hgFile.getRepo(), template, limit, originalHgFile\n    );\n\n    final List<HgFileRevision> revisions = new LinkedList<HgFileRevision>();\n    if (result == null) {\n      return revisions;\n    }\n\n    String output = result.getRawOutput();\n    String[] changeSets = output.split(HgChangesetUtil.CHANGESET_SEPARATOR);\n    for (String line : changeSets) {\n      try {\n        String[] attributes = line.split(HgChangesetUtil.ITEM_SEPARATOR);\n        if (attributes.length != itemCount) {\n          LOG.debug(\"Wrong format. Skipping line \" + line);\n          continue;\n        }\n\n        String revisionString = attributes[REVISION_INDEX];\n        String changeset = attributes[CHANGESET_INDEX];\n        String parentsString = attributes[PARENTS_INDEX];\n\n        List<HgRevisionNumber> parents = new ArrayList<HgRevisionNumber>(2);\n        if (StringUtils.isEmpty(parentsString)) {\n          Long revision = Long.valueOf(revisionString);\n          HgRevisionNumber parentRevision = HgRevisionNumber.getLocalInstance(String.valueOf(revision - 1));\n          parents.add(parentRevision);\n        } else {\n          //hg returns parents in the format 'rev:node rev:node ' (note the trailing space)\n          String[] parentStrings = parentsString.trim().split(\" \");\n          for (String parentString : parentStrings) {\n            String[] parentParts = parentString.split(\":\");\n            parents.add(HgRevisionNumber.getInstance(parentParts[0], parentParts[1]));\n          }\n        }\n        HgRevisionNumber vcsRevisionNumber = HgRevisionNumber.getInstance(\n          revisionString,\n          changeset,\n          parents\n        );\n\n        Date revisionDate = DATE_FORMAT.parse(attributes[DATE_INDEX]);\n        String author = attributes[AUTHOR_INDEX];\n        String branchName = attributes[BRANCH_INDEX];\n        String commitMessage = attributes[MESSAGE_INDEX];\n\n        Set<String> filesAdded;\n        Set<String> filesModified;\n        Set<String> filesDeleted;\n        Map<String, String> copies;\n        if (FILES_ADDED_INDEX < itemCount) {\n          filesAdded = parseFileList(attributes[FILES_ADDED_INDEX]);\n          filesModified = parseFileList(attributes[FILES_MODIFIED_INDEX]);\n          filesDeleted = parseFileList(attributes[FILES_DELETED_INDEX]);\n\n          copies = parseCopiesFileList(attributes[FILES_COPIED_INDEX]);\n          // Only keep renames, i.e. copies where the source file is also deleted.\n          Iterator<String> keys = copies.keySet().iterator();\n          while (keys.hasNext()) {\n            String s = keys.next();\n            if (!filesDeleted.contains(s)) {\n              keys.remove();\n            }\n          }\n        } else {\n          filesAdded = Collections.emptySet();\n          filesModified = Collections.emptySet();\n          filesDeleted = Collections.emptySet();\n          copies = Collections.emptyMap();\n        }\n\n        revisions.add(new HgFileRevision(project, hgFile, vcsRevisionNumber,\n          branchName, revisionDate, author, commitMessage, filesModified, filesAdded, filesDeleted, copies));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Error parsing rev in line \" + line);\n      } catch (ParseException e) {\n        LOG.warn(\"Error parsing date in line \" + line);\n      }\n    }\n    return revisions;\n  }","id":44796,"modified_method":"public final List<HgFileRevision> execute(final HgFile hgFile, int limit, boolean includeFiles) {\n    if ((limit <= 0 && limit != -1) || hgFile == null || hgFile.getRepo() == null) {\n      return Collections.emptyList();\n    }\n\n    HgCommandExecutor hgCommandExecutor = new HgCommandExecutor(project);\n\n    String template = HgChangesetUtil.makeTemplate(includeFiles ? LONG_TEMPLATE_ITEMS : SHORT_TEMPLATE_ITEMS);\n    int itemCount = includeFiles ? LONG_TEMPLATE_ITEMS.length : SHORT_TEMPLATE_ITEMS.length;\n\n    FilePath originalFileName = HgUtil.getOriginalFileName(hgFile.toFilePath(), ChangeListManager.getInstance(project));\n    HgFile originalHgFile = new HgFile(hgFile.getRepo(), originalFileName);\n    HgCommandResult result = execute(\n      hgCommandExecutor, hgFile.getRepo(), template, limit, originalHgFile\n    );\n\n    final List<HgFileRevision> revisions = new LinkedList<HgFileRevision>();\n    if (result == null) {\n      return revisions;\n    }\n\n    String output = result.getRawOutput();\n    String[] changeSets = output.split(HgChangesetUtil.CHANGESET_SEPARATOR);\n    for (String line : changeSets) {\n      try {\n        String[] attributes = line.split(HgChangesetUtil.ITEM_SEPARATOR);\n        if (attributes.length != itemCount) {\n          LOG.debug(\"Wrong format. Skipping line \" + line);\n          continue;\n        }\n\n        String revisionString = attributes[REVISION_INDEX];\n        String changeset = attributes[CHANGESET_INDEX];\n        String parentsString = attributes[PARENTS_INDEX];\n\n        List<HgRevisionNumber> parents = new ArrayList<HgRevisionNumber>(2);\n        if (StringUtils.isEmpty(parentsString)) {\n          Long revision = Long.valueOf(revisionString);\n          HgRevisionNumber parentRevision = HgRevisionNumber.getLocalInstance(String.valueOf(revision - 1));\n          parents.add(parentRevision);\n        } else {\n          //hg returns parents in the format 'rev:node rev:node ' (note the trailing space)\n          String[] parentStrings = parentsString.trim().split(\" \");\n          for (String parentString : parentStrings) {\n            String[] parentParts = parentString.split(\":\");\n            parents.add(HgRevisionNumber.getInstance(parentParts[0], parentParts[1]));\n          }\n        }\n        final HgRevisionNumber vcsRevisionNumber = HgRevisionNumber.getInstance(\n          revisionString,\n          changeset,\n          parents\n        );\n\n        Date revisionDate = DATE_FORMAT.parse(attributes[DATE_INDEX]);\n        String author = attributes[AUTHOR_INDEX];\n        String branchName = attributes[BRANCH_INDEX];\n        String commitMessage = attributes[MESSAGE_INDEX];\n\n        Set<String> filesAdded;\n        Set<String> filesModified;\n        Set<String> filesDeleted;\n        Map<String, String> copies;\n        if (FILES_ADDED_INDEX < itemCount) {\n          filesAdded = parseFileList(attributes[FILES_ADDED_INDEX]);\n          filesModified = parseFileList(attributes[FILES_MODIFIED_INDEX]);\n          filesDeleted = parseFileList(attributes[FILES_DELETED_INDEX]);\n\n          copies = parseCopiesFileList(attributes[FILES_COPIED_INDEX]);\n          // Only keep renames, i.e. copies where the source file is also deleted.\n          Iterator<String> keys = copies.keySet().iterator();\n          while (keys.hasNext()) {\n            String s = keys.next();\n            if (!filesDeleted.contains(s)) {\n              keys.remove();\n            }\n          }\n        } else {\n          filesAdded = Collections.emptySet();\n          filesModified = Collections.emptySet();\n          filesDeleted = Collections.emptySet();\n          copies = Collections.emptyMap();\n        }\n\n        revisions.add(new HgFileRevision(project, hgFile, vcsRevisionNumber,\n          branchName, revisionDate, author, commitMessage, filesModified, filesAdded, filesDeleted, copies));\n      } catch (NumberFormatException e) {\n        LOG.warn(\"Error parsing rev in line \" + line);\n      } catch (ParseException e) {\n        LOG.warn(\"Error parsing date in line \" + line);\n      }\n    }\n    return revisions;\n  }","commit_id":"35ac30b6b96facd88fa641842e3ea1641d743be5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected User getUser(HttpServletRequest request, long companyId)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\tString emailAddress = GetterUtil.getString(\n\t\t\tsession.getAttribute(GoogleWebKeys.GOOGLE_USER_EMAIL_ADDRESS));\n\n\t\tif (Validator.isNull(emailAddress)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tsession.removeAttribute(GoogleWebKeys.GOOGLE_USER_EMAIL_ADDRESS);\n\n\t\tUser user = _userLocalService.getUserByEmailAddress(\n\t\t\tcompanyId, emailAddress);\n\n\t\treturn user;\n\t}","id":44797,"modified_method":"protected User getUser(HttpServletRequest request, long companyId)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\tString emailAddress = GetterUtil.getString(\n\t\t\tsession.getAttribute(GoogleWebKeys.GOOGLE_USER_EMAIL_ADDRESS));\n\n\t\tif (Validator.isNotNull(emailAddress)) {\n\t\t\tsession.removeAttribute(GoogleWebKeys.GOOGLE_USER_EMAIL_ADDRESS);\n\n\t\t\treturn _userLocalService.getUserByEmailAddress(\n\t\t\t\tcompanyId, emailAddress);\n\t\t}\n\t\telse {\n\t\t\tString googleId = GetterUtil.getString(\n\t\t\t\t(String)session.getAttribute(GoogleWebKeys.GOOGLE_USER_ID));\n\n\t\t\tif (Validator.isNotNull(googleId)) {\n\t\t\t\treturn _userLocalService.getUserByGoogleId(companyId, googleId);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"6721733cdcc1a533c787ec827452f43e9ac4137c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected User setCredential(\n\t\t\tHttpSession session, long companyId, Credential credential)\n\t\tthrows Exception {\n\n\t\tUserinfoplus userinfoplus = getUserinfoplus(credential);\n\n\t\tif (userinfoplus == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tUser user = null;\n\n\t\tString emailAddress = userinfoplus.getEmail();\n\n\t\tif ((user == null) && Validator.isNotNull(emailAddress)) {\n\t\t\tuser = _userLocalService.fetchUserByEmailAddress(\n\t\t\t\tcompanyId, emailAddress);\n\n\t\t\tif ((user != null) &&\n\t\t\t\t(user.getStatus() != WorkflowConstants.STATUS_INCOMPLETE)) {\n\n\t\t\t\tsession.setAttribute(\n\t\t\t\t\tGoogleWebKeys.GOOGLE_USER_EMAIL_ADDRESS, emailAddress);\n\t\t\t}\n\t\t}\n\n\t\tif (user != null) {\n\t\t\tif (user.getStatus() == WorkflowConstants.STATUS_INCOMPLETE) {\n\t\t\t\tsession.setAttribute(\n\t\t\t\t\tWebKeys.GOOGLE_INCOMPLETE_USER_ID, userinfoplus.getId());\n\n\t\t\t\tuser.setEmailAddress(userinfoplus.getEmail());\n\t\t\t\tuser.setFirstName(userinfoplus.getGivenName());\n\t\t\t\tuser.setLastName(userinfoplus.getFamilyName());\n\n\t\t\t\treturn user;\n\t\t\t}\n\n\t\t\tuser = updateUser(user, userinfoplus);\n\t\t}\n\t\telse {\n\t\t\tuser = addUser(session, companyId, userinfoplus);\n\t\t}\n\n\t\tif (DeployManagerUtil.isDeployed(_GOOGLE_DRIVE_CONTEXT)) {\n\t\t\tupdateExpandoValues(\n\t\t\t\tuser, userinfoplus, credential.getAccessToken(),\n\t\t\t\tcredential.getRefreshToken());\n\t\t}\n\n\t\treturn user;\n\t}","id":44798,"modified_method":"protected User setCredential(\n\t\t\tHttpSession session, long companyId, Credential credential)\n\t\tthrows Exception {\n\n\t\tUserinfoplus userinfoplus = getUserinfoplus(credential);\n\n\t\tif (userinfoplus == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tUser user = null;\n\n\t\tString googleId = userinfoplus.getId();\n\n\t\tif (Validator.isNotNull(googleId)) {\n\t\t\tuser = _userLocalService.fetchUserByGoogleId(companyId, googleId);\n\n\t\t\tif ((user != null) &&\n\t\t\t\t(user.getStatus() != WorkflowConstants.STATUS_INCOMPLETE)) {\n\n\t\t\t\tsession.setAttribute(\n\t\t\t\t\tGoogleWebKeys.GOOGLE_USER_ID, String.valueOf(googleId));\n\t\t\t}\n\t\t}\n\n\t\tString emailAddress = userinfoplus.getEmail();\n\n\t\tif ((user == null) && Validator.isNotNull(emailAddress)) {\n\t\t\tuser = _userLocalService.fetchUserByEmailAddress(\n\t\t\t\tcompanyId, emailAddress);\n\n\t\t\tif ((user != null) &&\n\t\t\t\t(user.getStatus() != WorkflowConstants.STATUS_INCOMPLETE)) {\n\n\t\t\t\tsession.setAttribute(\n\t\t\t\t\tGoogleWebKeys.GOOGLE_USER_EMAIL_ADDRESS, emailAddress);\n\t\t\t}\n\t\t}\n\n\t\tif (user != null) {\n\t\t\tif (user.getStatus() == WorkflowConstants.STATUS_INCOMPLETE) {\n\t\t\t\tsession.setAttribute(\n\t\t\t\t\tWebKeys.GOOGLE_INCOMPLETE_USER_ID, userinfoplus.getId());\n\n\t\t\t\tuser.setEmailAddress(userinfoplus.getEmail());\n\t\t\t\tuser.setFirstName(userinfoplus.getGivenName());\n\t\t\t\tuser.setLastName(userinfoplus.getFamilyName());\n\n\t\t\t\treturn user;\n\t\t\t}\n\n\t\t\tuser = updateUser(user, userinfoplus);\n\t\t}\n\t\telse {\n\t\t\tuser = addUser(session, companyId, userinfoplus);\n\t\t}\n\n\t\tif (DeployManagerUtil.isDeployed(_GOOGLE_DRIVE_CONTEXT)) {\n\t\t\tupdateExpandoValues(\n\t\t\t\tuser, userinfoplus, credential.getAccessToken(),\n\t\t\t\tcredential.getRefreshToken());\n\t\t}\n\n\t\treturn user;\n\t}","commit_id":"6721733cdcc1a533c787ec827452f43e9ac4137c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setUserId(String userId) {\n\t\tthis.userId = userId;\n\t}","id":44799,"modified_method":"public void setUserId(String userId) {\n\t\t_userId = userId;\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getPassword() {\n\t\treturn encryptedPassword;\n\t}","id":44800,"modified_method":"public String getPassword() {\n\t\treturn _password;\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Called every time a HTTP invocation is made.\n\t * This implementation allows the parent to setup the connection, and\n\t * then adds an <code>Authorization<\/code> HTTP header property for\n\t * BASIC authentication.\n\t */\n\tprotected void prepareConnection(HttpURLConnection con, int contentLength)\n\t\tthrows IOException {\n\n\t\tsuper.prepareConnection(con, contentLength);\n\n\t\tif (this.getUserId() != null) {\n\n\t\t\tString pw = this.getPassword();\n\t\t\tif (pw == null) {\n\t\t\t\tpw = \"\";\n\t\t\t}\n\n\t\t\tString base64 = this.getUserId() + \":\" + pw;\n\t\t\tcon.setRequestProperty(\n\t\t\t\t\"Authorization\",\n\t\t\t\t\"Basic \" + new String(Base64.encodeBase64(base64.getBytes())));\n\t\t}\n\t}","id":44801,"modified_method":"/**\n\t * Called every time a HTTP invocation is made. This implementation allows\n\t * the parent to setup the connection, and then adds an\n\t * <code>Authorization<\/code> HTTP header property for BASIC authentication.\n\t */\n\tprotected void prepareConnection(HttpURLConnection con, int contentLength)\n\t\tthrows IOException {\n\n\t\tprepareConnection(con, contentLength);\n\n\t\tif (getUserId() != null) {\n\t\t\tString password = GetterUtil.getString(getPassword());\n\n\t\t\tString base64 = getUserId() + StringPool.COLON + password;\n\n\t\t\tcon.setRequestProperty(\n\t\t\t\t\"Authorization\",\n\t\t\t\t\"Basic \" + new String(Base64.encodeBase64(base64.getBytes())));\n\t\t}\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setPassword(String unencryptedPassword) {\n\t\tthis.encryptedPassword = Digester.digest(unencryptedPassword);\n\t}","id":44802,"modified_method":"public void setPassword(String password) {\n\t\t_password = Digester.digest(password);\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getUserId() {\n\t\treturn userId;\n\t}","id":44803,"modified_method":"public String getUserId() {\n\t\treturn _userId;\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _updateRemotingXML() throws Exception {\n\t\tStringMaker sm = new StringMaker();\n\n\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\tDocument doc = reader.read(new File(\"classes/META-INF/ejb-jar.xml\"));\n\n\t\tIterator itr = doc.getRootElement().element(\"enterprise-beans\").elements(\"session\").iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tElement entity = (Element)itr.next();\n\n\t\t\tString displayName = entity.elementText(\"display-name\");\n\n\t\t\tif (!displayName.endsWith(\"LocalServiceEJB\") &&\n\t\t\t\t!displayName.endsWith(\"RemoteServiceEJB\")) {\n\n\t\t\t\tString serviceMapping = entity.elementText(\"ejb-name\");\n\t\t\t\tserviceMapping = serviceMapping.substring(\n\t\t\t\t\t0, serviceMapping.length() - 3);\n\t\t\t\tserviceMapping = StringUtil.replace(\n\t\t\t\t\tserviceMapping, \"_service_ejb_\", \"_service_spring_\");\n\n\t\t\t\tString serviceName = entity.elementText(\"ejb-class\");\n\t\t\t\tserviceName = serviceName.substring(\n\t\t\t\t\t0, serviceName.length() - 7);\n\t\t\t\tserviceName = StringUtil.replace(\n\t\t\t\t\tserviceName, \".service.ejb.\", \".service.\");\n\n\t\t\t\tSystem.out.println(\"writing transaction spring remoting for \" + serviceName);\n\t\t\t\tsm.append(\"\\t<bean name=\\\"/\").append(serviceMapping).append(\"-burlap\\\" class=\\\"org.springframework.remoting.caucho.BurlapServiceExporter\\\">\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"service\\\" ref=\\\"\").append(serviceName).append(\".transaction\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"serviceInterface\\\" value=\\\"\").append(serviceName).append(\"\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t<\/bean>\\n\");\n\n\t\t\t\tsm.append(\"\\t<bean name=\\\"/\").append(serviceMapping).append(\"-hessian\\\" class=\\\"org.springframework.remoting.caucho.HessianServiceExporter\\\">\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"service\\\" ref=\\\"\").append(serviceName).append(\".transaction\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"serviceInterface\\\" value=\\\"\").append(serviceName).append(\"\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t<\/bean>\\n\");\n\n\t\t\t\tsm.append(\"\\t<bean name=\\\"/\").append(serviceMapping).append(\"-http\\\" class=\\\"org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter\\\">\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"service\\\" ref=\\\"\").append(serviceName).append(\".transaction\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"serviceInterface\\\" value=\\\"\").append(serviceName).append(\"\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t<\/bean>\\n\");\n\t\t\t}\n\t\t}\n\n\t\tFile outputFile = new File(\n\t\t\t\"../tunnel-web/docroot/WEB-INF/remoting-servlet.xml\");\n\t\tif (!outputFile.exists()) {\n\t\t\toutputFile = new File(\n\t\t\t\t\"../ext-web/docroot/WEB-INF/remoting-servlet-ext.xml\");\n\t\t}\n\n\t\tString content = FileUtil.read(outputFile);\n\t\tString newContent = content;\n\n\t\tint x = content.indexOf(\"<bean \");\n\t\tint y = content.lastIndexOf(\"<\/bean>\") + 8;\n\n\t\tif (x != -1) {\n\t\t\tnewContent =\n\t\t\t\tcontent.substring(0, x - 1) + sm.toString() +\n\t\t\t\t\tcontent.substring(y, content.length());\n\t\t}\n\t\telse {\n\t\t\tx = content.indexOf(\"<\/beans>\");\n\n\t\t\tnewContent =\n\t\t\t\tcontent.substring(0, x) + sm.toString() +\n\t\t\t\t\tcontent.substring(x, content.length());\n\t\t}\n\n\t\tSystem.out.println(\"writing transaction spring remoting\");\n\t\tif (!content.equals(newContent)) {\n\t\t\tFileUtil.write(outputFile, newContent);\n\n\t\t\tSystem.out.println(outputFile.toString());\n\t\t}\n\t}","id":44804,"modified_method":"private void _updateRemotingXML() throws Exception {\n\t\tStringMaker sm = new StringMaker();\n\n\t\tSAXReader reader = SAXReaderFactory.getInstance();\n\n\t\tDocument doc = reader.read(new File(\"classes/META-INF/ejb-jar.xml\"));\n\n\t\tIterator itr = doc.getRootElement().element(\"enterprise-beans\").elements(\"session\").iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tElement entity = (Element)itr.next();\n\n\t\t\tString displayName = entity.elementText(\"display-name\");\n\n\t\t\tif (!displayName.endsWith(\"LocalServiceEJB\") &&\n\t\t\t\t!displayName.endsWith(\"RemoteServiceEJB\")) {\n\n\t\t\t\tString serviceMapping = entity.elementText(\"ejb-name\");\n\t\t\t\tserviceMapping = serviceMapping.substring(\n\t\t\t\t\t0, serviceMapping.length() - 3);\n\t\t\t\tserviceMapping = StringUtil.replace(\n\t\t\t\t\tserviceMapping, \"_service_ejb_\", \"_service_spring_\");\n\n\t\t\t\tString serviceName = entity.elementText(\"ejb-class\");\n\t\t\t\tserviceName = serviceName.substring(\n\t\t\t\t\t0, serviceName.length() - 7);\n\t\t\t\tserviceName = StringUtil.replace(\n\t\t\t\t\tserviceName, \".service.ejb.\", \".service.\");\n\n\t\t\t\tsm.append(\"\\t<bean name=\\\"/\").append(serviceMapping).append(\"-burlap\\\" class=\\\"org.springframework.remoting.caucho.BurlapServiceExporter\\\">\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"service\\\" ref=\\\"\").append(serviceName).append(\".transaction\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"serviceInterface\\\" value=\\\"\").append(serviceName).append(\"\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t<\/bean>\\n\");\n\n\t\t\t\tsm.append(\"\\t<bean name=\\\"/\").append(serviceMapping).append(\"-hessian\\\" class=\\\"org.springframework.remoting.caucho.HessianServiceExporter\\\">\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"service\\\" ref=\\\"\").append(serviceName).append(\".transaction\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"serviceInterface\\\" value=\\\"\").append(serviceName).append(\"\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t<\/bean>\\n\");\n\n\t\t\t\tsm.append(\"\\t<bean name=\\\"/\").append(serviceMapping).append(\"-http\\\" class=\\\"org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter\\\">\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"service\\\" ref=\\\"\").append(serviceName).append(\".transaction\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t\\t<property name=\\\"serviceInterface\\\" value=\\\"\").append(serviceName).append(\"\\\" />\\n\");\n\t\t\t\tsm.append(\"\\t<\/bean>\\n\");\n\t\t\t}\n\t\t}\n\n\t\tFile outputFile = new File(\n\t\t\t\"../tunnel-web/docroot/WEB-INF/remoting-servlet.xml\");\n\t\tif (!outputFile.exists()) {\n\t\t\toutputFile = new File(\n\t\t\t\t\"../ext-web/docroot/WEB-INF/remoting-servlet-ext.xml\");\n\t\t}\n\n\t\tString content = FileUtil.read(outputFile);\n\t\tString newContent = content;\n\n\t\tint x = content.indexOf(\"<bean \");\n\t\tint y = content.lastIndexOf(\"<\/bean>\") + 8;\n\n\t\tif (x != -1) {\n\t\t\tnewContent =\n\t\t\t\tcontent.substring(0, x - 1) + sm.toString() +\n\t\t\t\t\tcontent.substring(y, content.length());\n\t\t}\n\t\telse {\n\t\t\tx = content.indexOf(\"<\/beans>\");\n\n\t\t\tnewContent =\n\t\t\t\tcontent.substring(0, x) + sm.toString() +\n\t\t\t\t\tcontent.substring(x, content.length());\n\t\t}\n\n\t\tif (!content.equals(newContent)) {\n\t\t\tFileUtil.write(outputFile, newContent);\n\n\t\t\tSystem.out.println(outputFile.toString());\n\t\t}\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testUserCreationAndDeletion()\n\t\tthrows SystemException, PortalException, RemoteException {\n\t\tUserService userService = getUserService();\n\t\tUser user = userService.addUser(\n\t\t\tTestConstants.COMPANY_ID, autoPassword, password1, password2,\n\t\t\tpasswordReset, autoScreenName, screenName, emailAddress, locale,\n\t\t\tfirstName, middleName, lastName, nickName, prefixId, suffixId, male,\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, jobTitle, organizationId,\n\t\t\tlocationId, false);\n\n\t\tuser = userService.getUserByEmailAddress(\n\t\t\tTestConstants.COMPANY_ID, emailAddress);\n\n\t\tuserService.deleteUser(user.getUserId());\n\t}","id":44805,"modified_method":"public void testUserCreationAndDeletion() throws Exception {\n\t\tUserService userService = getUserService();\n\n\t\tboolean autoPassword = true;\n\t\tString password1 = null;\n\t\tString password2 = null;\n\t\tboolean passwordReset = false;\n\t\tboolean autoScreenName = true;\n\t\tString screenName = \"UserServiceSpringRemotingTest\";\n\t\tString emailAddress = \"UserServiceSpringRemotingTest@liferay.com\";\n\t\tLocale locale = Locale.getDefault();\n\t\tString firstName = \"UserServiceSpringRemotingTest\";\n\t\tString middleName = \"\";\n\t\tString lastName = \"UserServiceSpringRemotingTest\";\n\t\tString nickName = null;\n\t\tint prefixId = 0;\n\t\tint suffixId = 0;\n\t\tboolean male = true;\n\t\tint birthdayMonth = Calendar.JANUARY;\n\t\tint birthdayDay = 1;\n\t\tint birthdayYear = 1970;\n\t\tString jobTitle = null;\n\t\tString organizationId = null;\n\t\tString locationId = null;\n\t\tboolean sendMail = false;\n\n\t\tUser user = userService.addUser(\n\t\t\tTestConstants.COMPANY_ID, autoPassword, password1, password2,\n\t\t\tpasswordReset, autoScreenName, screenName, emailAddress, locale,\n\t\t\tfirstName, middleName, lastName, nickName, prefixId, suffixId, male,\n\t\t\tbirthdayMonth, birthdayDay, birthdayYear, jobTitle, organizationId,\n\t\t\tlocationId, sendMail);\n\n\t\tuser = userService.getUserByEmailAddress(\n\t\t\tTestConstants.COMPANY_ID, emailAddress);\n\n\t\tuserService.deleteUser(user.getUserId());\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private UserService getUserService() {\n\t\treturn (UserService) getBeanFactory().getBean(\n\t\t\t\"userService\" + SpringRemotingTests.getProtocol() + \"SecureProxy\");\n\t}","id":44806,"modified_method":"protected UserService getUserService() {\n\t\treturn (UserService)getBeanFactory().getBean(\n\t\t\t\"userService\" + SpringRemotingTests.getProtocol() + \"SecureProxy\");\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private XmlBeanFactory getBeanFactory() {\n\t\treturn new XmlBeanFactory(new ClassPathResource(\n\t\t\t\"/portal-services.xml\",\n\t\t\tPortalHttpTest.class));\n\t}","id":44807,"modified_method":"protected XmlBeanFactory getBeanFactory() {\n\t\treturn new XmlBeanFactory(new ClassPathResource(\n\t\t\t\"/portal-services.xml\", PortalHttpTest.class));\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void testUserRetrieval()\n\t\tthrows SystemException, PortalException, RemoteException {\n\t\tString address = null;\n\t\tUser user = null;\n\n\t\tUserService userService = getUserService();\n\n\t\taddress = \"test@\" + TestConstants.COMPANY_ID;\n\n\t\tuser = userService.getUserByEmailAddress(\n\t\t\tTestConstants.COMPANY_ID, address);\n\n\t\tassertEquals(address, user.getEmailAddress());\n\t}","id":44808,"modified_method":"public void testUserRetrieval() throws Exception {\n\t\tUserService userService = getUserService();\n\n\t\tString emailAddress = \"test@\" + TestConstants.COMPANY_ID;\n\n\t\tUser user = userService.getUserByEmailAddress(\n\t\t\tTestConstants.COMPANY_ID, emailAddress);\n\n\t\tassertEquals(emailAddress, user.getEmailAddress());\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void init(ServletConfig servletConfig)\n\t\tthrows ServletException {\n\t\tsuper.init(servletConfig);\n\t\t_companyId = getServletContext().getInitParameter(\"company_id\");\n\t}","id":44809,"modified_method":"public void init(ServletConfig config) throws ServletException {\n\t\tsuper.init(config);\n\n\t\tServletContext ctx = getServletContext();\n\n\t\t_companyId = ctx.getInitParameter(\"company_id\");\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void service(HttpServletRequest req, HttpServletResponse res)\n\t\tthrows IOException, ServletException {\n\t\tPermissionCheckerImpl permissionChecker = null;\n\t\tString remoteUser = req.getRemoteUser();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Remote user \" + remoteUser);\n\t\t}\n\n\t\tCompanyThreadLocal.setCompanyId(_companyId);\n\n\t\ttry {\n\t\t\tif (remoteUser != null) {\n\t\t\t\tPrincipalThreadLocal.setName(remoteUser);\n\n\t\t\t\tUser user = UserLocalServiceUtil.getUserById(remoteUser);\n\n\t\t\t\tpermissionChecker =\n\t\t\t\t\tPermissionCheckerFactory.create(user, true, true);\n\n\t\t\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"User id not provided. An exception will be thrown if \" +\n\t\t\t\t\t\"a protected service is accessed\");\n\t\t\t}\n\n\t\t\tsuper.service(req, res);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ServletException(e);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tPermissionCheckerFactory.recycle(permissionChecker);\n\t\t\t} catch (Exception e) {\n\t\t\t}\n\t\t}\n\t}","id":44810,"modified_method":"public void service(HttpServletRequest req, HttpServletResponse res)\n\t\tthrows IOException, ServletException {\n\n\t\tPermissionCheckerImpl permissionChecker = null;\n\n\t\ttry {\n\t\t\tString remoteUser = req.getRemoteUser();\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Remote user \" + remoteUser);\n\t\t\t}\n\n\t\t\tCompanyThreadLocal.setCompanyId(_companyId);\n\n\t\t\tif (remoteUser != null) {\n\t\t\t\tPrincipalThreadLocal.setName(remoteUser);\n\n\t\t\t\tUser user = UserLocalServiceUtil.getUserById(remoteUser);\n\n\t\t\t\tpermissionChecker =\n\t\t\t\t\tPermissionCheckerFactory.create(user, true, true);\n\n\t\t\t\tPermissionThreadLocal.setPermissionChecker(permissionChecker);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"User id is not provided. An exception will be \" +\n\t\t\t\t\t\t\t\"thrown  if a protected method is accessed.\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsuper.service(req, res);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ServletException(e);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tPermissionCheckerFactory.recycle(permissionChecker);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void main(String[] args) {\n\t\tif (args.length > 0) {\n\t\t\t_protocol = args[0];\n\t\t}\n\n\t\tTestRunner runner = new TestRunner(new ResultPrinter(System.out));\n\n\t\trunner.doRun(suite());\n\t}","id":44811,"modified_method":"public static void main(String[] args) {\n\t\tif (args.length > 0) {\n\t\t\t_protocol = args[0];\n\n\t\t\tif (Validator.isNotNull(_protocol)) {\n\t\t\t\t_protocol =\n\t\t\t\t\t_protocol.substring(0, 1).toUpperCase() +\n\t\t\t\t\t\t_protocol.substring(\n\t\t\t\t\t\t\t1, _protocol.length()).toLowerCase();\n\t\t\t}\n\t\t}\n\n\t\tTestRunner runner = new TestRunner(new ResultPrinter(System.out));\n\n\t\trunner.doRun(suite());\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doPost(HttpServletRequest req, HttpServletResponse res)\n\t\tthrows IOException, ServletException {\n\n\t\tPermissionCheckerImpl permissionChecker = null;\n\n\t\ttry {\n\t\t\tObjectInputStream ois = new ObjectInputStream(req.getInputStream());\n\n\t\t\tObject returnObj = null;\n\n\t\t\tCompanyThreadLocal.setCompanyId(_companyId);\n\n\t\t\ttry {\n\t\t\t\tObjectValuePair ovp = (ObjectValuePair)ois.readObject();\n\n\t\t\t\tHttpPrincipal httpPrincipal = (HttpPrincipal)ovp.getKey();\n\t\t\t\tMethodWrapper methodWrapper = (MethodWrapper)ovp.getValue();\n\n\t\t\t\tif (httpPrincipal.getUserId() != null) {\n\t\t\t\t\tPrincipalThreadLocal.setName(httpPrincipal.getUserId());\n\n\t\t\t\t\tUser user = UserLocalServiceUtil.getUserById(\n\t\t\t\t\t\thttpPrincipal.getUserId());\n\n\t\t\t\t\tpermissionChecker =\n\t\t\t\t\t\tPermissionCheckerFactory.create(user, true, true);\n\n\t\t\t\t\tPermissionThreadLocal.setPermissionChecker(\n\t\t\t\t\t\tpermissionChecker);\n\t\t\t\t}\n\n\t\t\t\tif (returnObj == null) {\n\t\t\t\t\treturnObj = MethodInvoker.invoke(methodWrapper);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ite) {\n\t\t\t\treturnObj = ite.getCause();\n\n\t\t\t\tif (!(returnObj instanceof PortalException)) {\n\t\t\t\t\tite.printStackTrace();\n\n\t\t\t\t\treturnObj = new SystemException();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\n\t\t\tif (returnObj != null) {\n\t\t\t\tObjectOutputStream oos =\n\t\t\t\t\tnew ObjectOutputStream(res.getOutputStream());\n\n\t\t\t\toos.writeObject(returnObj);\n\n\t\t\t\toos.flush();\n\t\t\t\toos.close();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tPermissionCheckerFactory.recycle(permissionChecker);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t}","id":44812,"modified_method":"public void doPost(HttpServletRequest req, HttpServletResponse res)\n\t\tthrows IOException, ServletException {\n\n\t\tPermissionCheckerImpl permissionChecker = null;\n\n\t\ttry {\n\t\t\tObjectInputStream ois = new ObjectInputStream(req.getInputStream());\n\n\t\t\tObject returnObj = null;\n\n\t\t\ttry {\n\t\t\t\tObjectValuePair ovp = (ObjectValuePair)ois.readObject();\n\n\t\t\t\tHttpPrincipal httpPrincipal = (HttpPrincipal)ovp.getKey();\n\t\t\t\tMethodWrapper methodWrapper = (MethodWrapper)ovp.getValue();\n\n\t\t\t\tCompanyThreadLocal.setCompanyId(_companyId);\n\n\t\t\t\tif (httpPrincipal.getUserId() != null) {\n\t\t\t\t\tPrincipalThreadLocal.setName(httpPrincipal.getUserId());\n\n\t\t\t\t\tUser user = UserLocalServiceUtil.getUserById(\n\t\t\t\t\t\thttpPrincipal.getUserId());\n\n\t\t\t\t\tpermissionChecker =\n\t\t\t\t\t\tPermissionCheckerFactory.create(user, true, true);\n\n\t\t\t\t\tPermissionThreadLocal.setPermissionChecker(\n\t\t\t\t\t\tpermissionChecker);\n\t\t\t\t}\n\n\t\t\t\tif (returnObj == null) {\n\t\t\t\t\treturnObj = MethodInvoker.invoke(methodWrapper);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ite) {\n\t\t\t\treturnObj = ite.getCause();\n\n\t\t\t\tif (!(returnObj instanceof PortalException)) {\n\t\t\t\t\tite.printStackTrace();\n\n\t\t\t\t\treturnObj = new SystemException();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\n\t\t\tif (returnObj != null) {\n\t\t\t\tObjectOutputStream oos =\n\t\t\t\t\tnew ObjectOutputStream(res.getOutputStream());\n\n\t\t\t\toos.writeObject(returnObj);\n\n\t\t\t\toos.flush();\n\t\t\t\toos.close();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tPermissionCheckerFactory.recycle(permissionChecker);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void init(ServletConfig servletConfig)\n\t\tthrows ServletException {\n\t\tsuper.init(servletConfig);\n\t\t_companyId = getServletContext().getInitParameter(\"company_id\");\n\t}","id":44813,"modified_method":"public void init(ServletConfig config) throws ServletException {\n\t\tsuper.init(config);\n\n\t\tServletContext ctx = getServletContext();\n\n\t\t_companyId = ctx.getInitParameter(\"company_id\");\n\t}","commit_id":"9cf3f82e6cf748db2efa9ce609828a94d4c3b605","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String[] login(\n\t\tHttpServletRequest request, HttpServletResponse response) {\n\n\t\tString[] credentials = null;\n\n\t\ttry {\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tString emailAddress =  (String)session.getAttribute(\n\t\t\t\tWebKeys.FACEBOOK_USER_EMAIL_ADDRESS);\n\n\t\t\tif (Validator.isNull(emailAddress)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tsession.removeAttribute(WebKeys.FACEBOOK_USER_EMAIL_ADDRESS);\n\n\t\t\tlong companyId = PortalUtil.getCompanyId(request);\n\n\t\t\tUser user = UserLocalServiceUtil.getUserByEmailAddress(\n\t\t\t\tcompanyId, emailAddress);\n\n\t\t\tcredentials = new String[3];\n\n\t\t\tcredentials[0] = String.valueOf(user.getUserId());\n\t\t\tcredentials[1] = user.getPassword();\n\t\t\tcredentials[2] = Boolean.FALSE.toString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn credentials;\n\t}","id":44814,"modified_method":"public String[] login(\n\t\tHttpServletRequest request, HttpServletResponse response) {\n\n\t\tString[] credentials = null;\n\n\t\ttry {\n\t\t\tHttpSession session = request.getSession();\n\n\t\t\tString emailAddress =  (String)session.getAttribute(\n\t\t\t\tWebKeys.FACEBOOK_USER_EMAIL_ADDRESS);\n\n\t\t\tUser user = null;\n\n\t\t\tlong companyId = PortalUtil.getCompanyId(request);\n\n\t\t\tif (Validator.isNotNull(emailAddress)) {\n\t\t\t\tsession.removeAttribute(WebKeys.FACEBOOK_USER_EMAIL_ADDRESS);\n\n\t\t\t\ttry {\n\t\t\t\t\tuser = UserLocalServiceUtil.getUserByEmailAddress(\n\t\t\t\t\t\tcompanyId, emailAddress);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong facebookId = GetterUtil.getLong((\n\t\t\t\t\tString) session.getAttribute(WebKeys.FACEBOOK_USER_ID));\n\n\t\t\t\tif (facebookId > 0) {\n\t\t\t\t\tsession.removeAttribute(WebKeys.FACEBOOK_USER_ID);\n\t\t\t\t\tuser = UserLocalServiceUtil.getUserByFacebookId(\n\t\t\t\t\t\tcompanyId, facebookId);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcredentials = new String[3];\n\n\t\t\tcredentials[0] = String.valueOf(user.getUserId());\n\t\t\tcredentials[1] = user.getPassword();\n\t\t\tcredentials[2] = Boolean.FALSE.toString();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\treturn credentials;\n\t}","commit_id":"432cabf41a605df6f2797119e265085ed63c9e34","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong companyId = themeDisplay.getCompanyId();\n\n\t\tif (!FacebookConnectUtil.isEnabled(companyId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString redirect = HttpUtil.addParameter(\n\t\t\tFacebookConnectUtil.getAuthURL(companyId), \"client_id\",\n\t\t\tFacebookConnectUtil.getAppId(companyId));\n\n\t\tredirect = HttpUtil.addParameter(\n\t\t\tredirect, \"redirect_uri\",\n\t\t\tFacebookConnectUtil.getRedirectURL(companyId));\n\n\t\tredirect = HttpUtil.addParameter(redirect, \"scope\", \"email\");\n\n\t\tactionResponse.sendRedirect(redirect);\n\t}","id":44815,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong companyId = themeDisplay.getCompanyId();\n\n\t\tif (!FacebookConnectUtil.isEnabled(companyId)) {\n\t\t\treturn;\n\t\t}\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\tif (cmd.equals(Constants.ADD)) {\n\t\t\tprocessAddUser(actionRequest, actionResponse);\n\t\t}\n\t\telse {\n\t\t\tString redirect = HttpUtil.addParameter(\n\t\t\t\tFacebookConnectUtil.getAuthURL(companyId), \"client_id\",\n\t\t\t\tFacebookConnectUtil.getAppId(companyId));\n\n\t\t\tredirect = HttpUtil.addParameter(\n\t\t\t\tredirect, \"redirect_uri\",\n\t\t\t\tFacebookConnectUtil.getRedirectURL(companyId));\n\n\t\t\tredirect = HttpUtil.addParameter(redirect, \"scope\", \"email\");\n\n\t\t\tactionResponse.sendRedirect(redirect);\n\t\t}\n\t}","commit_id":"432cabf41a605df6f2797119e265085ed63c9e34","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ActionForward strutsExecute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest request,\n\t\t\tHttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay) request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong companyId = themeDisplay.getCompanyId();\n\n\t\tString code = ParamUtil.get(request, \"code\", StringPool.BLANK);\n\n\t\tString token = getAccessToken(companyId, code);\n\n\t\tif (Validator.isNotNull(token)) {\n\t\t\tString emailAddress = getEmailAddress(companyId, token);\n\n\t\t\tif (Validator.isNotNull(emailAddress)) {\n\t\t\t\tHttpSession session = request.getSession();\n\n\t\t\t\tsession.setAttribute(\n\t\t\t\t\tWebKeys.FACEBOOK_USER_EMAIL_ADDRESS, emailAddress);\n\t\t\t}\n\t\t}\n\n\t\tresponse.sendRedirect(themeDisplay.getPathContext());\n\n\t\treturn null;\n\t}","id":44816,"modified_method":"public ActionForward strutsExecute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest request,\n\t\t\tHttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay) request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong companyId = themeDisplay.getCompanyId();\n\n\t\tString code = ParamUtil.get(request, \"code\", StringPool.BLANK);\n\n\t\tString token = getAccessToken(companyId, code);\n\n\t\tHttpSession session = request.getSession();\n\n\t\tif (Validator.isNotNull(token)) {\n\t\t\tsession.setAttribute(WebKeys.FACEBOOK_ACCESS_TOKEN, token);\n\n\t\t\tgetFacebookCredentials(session, companyId, token);\n\t\t}\n\n\t\tresponse.sendRedirect(getRedirect(request, themeDisplay));\n\n\t\treturn null;\n\t}","commit_id":"432cabf41a605df6f2797119e265085ed63c9e34","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected User getUser(ActionRequest actionRequest) throws Exception {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString emailAddress = ParamUtil.getString(\n\t\t\tactionRequest, \"emailAddress\");\n\n\t\tUser user = UserLocalServiceUtil.getUserByEmailAddress(\n\t\t\tthemeDisplay.getCompanyId(), emailAddress);\n\n\t\tactionRequest.setAttribute(ForgotPasswordAction.class.getName(), user);\n\n\t\treturn user;\n\t}","id":44817,"modified_method":"protected User getUser(ActionRequest actionRequest) throws Exception {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString emailAddress = ParamUtil.getString(\n\t\t\tactionRequest, \"emailAddress\");\n\t\tString screenName = ParamUtil.getString(actionRequest, \"screenName\");\n\t\tlong userId = ParamUtil.getLong(actionRequest, \"userId\");\n\n\t\tUser user = null;\n\n\t\tif (Validator.isNotNull(emailAddress)) {\n\t\t\tuser = UserLocalServiceUtil.getUserByEmailAddress(\n\t\t\t\tthemeDisplay.getCompanyId(), emailAddress);\n\t\t}\n\t\telse if (Validator.isNotNull(screenName)) {\n\t\t\tuser = UserLocalServiceUtil.getUserByScreenName(\n\t\t\t\tthemeDisplay.getCompanyId(), screenName);\n\t\t}\n\t\telse if (userId > 0) {\n\t\t\tuser = UserLocalServiceUtil.getUserById(userId);\n\t\t}\n\n\t\tactionRequest.setAttribute(ForgotPasswordAction.class.getName(), user);\n\n\t\treturn user;\n\t}","commit_id":"ad9e032a76282099587149abe33d5819c9e3c811","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Use {@link GenModelAccess#getGenPackage(EPackage)}}\n\t */\n\t@Deprecated\n\tprotected List<GenPackage> loadReferencedGenModels(ResourceSet rs) {\n\t\tList<GenPackage> result = Lists.newArrayList();\n\t\tif (getReferencedGenModels() != null) {\n\t\t\tfor (String uri : getReferencedGenModels().split(\",\")) {\n\t\t\t\ttry {\n\t\t\t\t\tResource resource = rs.getResource(URI.createURI(uri.trim()), true);\n\t\t\t\t\tGenModel genmodel = (GenModel) resource.getContents().get(0);\n\t\t\t\t\tEList<GenPackage> genPackages = genmodel.getGenPackages();\n\t\t\t\t\tfor (GenPackage genPackage : genPackages) {\n\t\t\t\t\t\tgenPackage.getEcorePackage().getEClassifiers();\n\t\t\t\t\t\tresult.add(genPackage);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlog.error(\"Couldn't find genmodel for uri '\" + uri + \"'\");\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":44818,"modified_method":"/**\n\t * Use {@link GenModelAccess#getGenPackage(EPackage)}\n\t */\n\t@Deprecated\n\tprotected List<GenPackage> loadReferencedGenModels(ResourceSet rs) {\n\t\tList<GenPackage> result = Lists.newArrayList();\n\t\tif (getReferencedGenModels() != null) {\n\t\t\tfor (String uri : getReferencedGenModels().split(\",\")) {\n\t\t\t\ttry {\n\t\t\t\t\tResource resource = rs.getResource(URI.createURI(uri.trim()), true);\n\t\t\t\t\tGenModel genmodel = (GenModel) resource.getContents().get(0);\n\t\t\t\t\tEList<GenPackage> genPackages = genmodel.getGenPackages();\n\t\t\t\t\tfor (GenPackage genPackage : genPackages) {\n\t\t\t\t\t\tgenPackage.getEcorePackage().getEClassifiers();\n\t\t\t\t\t\tresult.add(genPackage);\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlog.error(\"Couldn't find genmodel for uri '\" + uri + \"'\");\n\t\t\t\t\tthrow new WrappedException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"ac4552f1e7228632e702f84db86247d4e3c5aaca","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @since 2.0\n\t */\n\tprotected List<GenPackage> getGenPackagesForPackages(Collection<EPackage> packs) {\n\t\tList<GenPackage> result = Lists.newArrayList();\n\t\tfor (EPackage pkg : packs)\n\t\t\tif (EcorePlugin.getEPackageNsURIToGenModelLocationMap().containsKey(pkg.getNsURI()))\n\t\t\t\tresult.add(GenModelAccess.getGenPackage(pkg));\n\t\t\telse\n\t\t\t\tlog.warn(\"Could not find GenModel for '\" + pkg.getNsURI()\n\t\t\t\t\t\t+ \"'; Adding the package to generated GenModel instead.\");\n\t\treturn result;\n\t}","id":44819,"modified_method":"/**\n\t * @since 2.0\n\t */\n\tprotected List<GenPackage> getGenPackagesForPackages(GenModel existingGenModel, Collection<EPackage> packs) {\n\t\tList<GenPackage> result = Lists.newArrayList();\n\t\tfor (EPackage pkg : packs) {\n\t\t\tboolean found = false;\n\t\t\tfor (GenPackage gp : existingGenModel.getGenPackages())\n\t\t\t\tif (gp.getEcorePackage() != null && gp.getEcorePackage().getNsURI() != null\n\t\t\t\t\t\t&& gp.getEcorePackage().getNsURI().equals(pkg.getNsURI()))\n\t\t\t\t\tfound = true;\n\t\t\tif (!found)\n\t\t\t\tresult.add(GenModelAccess.getGenPackage(pkg));\n\t\t}\n\t\treturn result;\n\t}","commit_id":"ac4552f1e7228632e702f84db86247d4e3c5aaca","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void generate(Grammar grammar, XpandExecutionContext ctx) {\n\t\ttry {\n\t\t\tregisterReferencedGenModels();\n\t\t\t\n\t\t\t// create a defensive clone\n\t\t\tResourceSet copiedResourceSet = EcoreUtil2.clone(new XtextResourceSet(), grammar.eResource()\n\t\t\t\t\t.getResourceSet());\n\t\t\tGrammar copiedGrammar = (Grammar) copiedResourceSet.getResource(grammar.eResource().getURI(), true)\n\t\t\t\t\t.getContents().get(0);\n\n\t\t\tList<EPackage> packs = getGeneratedEPackages(copiedGrammar);\n\t\t\tif (!packs.isEmpty()) {\n\t\t\t\tremoveFromResource(packs);\n\t\t\t\tproxifyExternalReferences(packs);\n\t\t\t\tXtextResourceSet resourceSet = getNsUriMappingResourceSet();\n\n\t\t\t\tResource ePackages = createResourceForEPackages(copiedGrammar, ctx, packs, resourceSet);\n\t\t\t\tList<GenPackage> genPackages = getGenPackagesForPackages(getReferencedEPackages(packs));\n\t\t\t\tif (!skipGenerate) {\n\t\t\t\t\tGenModel genModel = getSaveAndReconcileGenModel(resourceSet, copiedGrammar, ctx, packs, genPackages);\n\t\t\t\t\tgenModel.reconcile();\n\t\t\t\t\tdoGenerate(genModel);\n\t\t\t\t\tif (basePackage == null)\n\t\t\t\t\t\tbasePackage = genModel.getGenPackages().get(0).getBasePackage();\n\t\t\t\t\tsuper.generate(copiedGrammar, ctx);\n\t\t\t\t}\n\t\t\t\tresolveAll(resourceSet);\n\t\t\t\tePackages.save(singletonMap(XMLResource.OPTION_URI_HANDLER,\n\t\t\t\t\t\tnew ToPlatformResourceDeresolvingURIHandler()));\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":44820,"modified_method":"@Override\n\tpublic void generate(Grammar grammar, XpandExecutionContext ctx) {\n\t\ttry {\n\t\t\tregisterReferencedGenModels();\n\n\t\t\t// create a defensive clone\n\t\t\tResourceSet copiedResourceSet = EcoreUtil2.clone(new XtextResourceSet(), grammar.eResource()\n\t\t\t\t\t.getResourceSet());\n\t\t\tGrammar copiedGrammar = (Grammar) copiedResourceSet.getResource(grammar.eResource().getURI(), true)\n\t\t\t\t\t.getContents().get(0);\n\n\t\t\tList<EPackage> packs = getGeneratedEPackages(copiedGrammar);\n\t\t\tif (!packs.isEmpty()) {\n\t\t\t\tremoveFromResource(packs);\n\t\t\t\tproxifyExternalReferences(packs);\n\t\t\t\tXtextResourceSet resourceSet = getNsUriMappingResourceSet();\n\n\t\t\t\tResource ePackages = createResourceForEPackages(copiedGrammar, ctx, packs, resourceSet);\n\t\t\t\tif (!skipGenerate) {\n\t\t\t\t\tGenModel genModel = getSaveAndReconcileGenModel(resourceSet, copiedGrammar, ctx, packs);\n\t\t\t\t\tgenModel.reconcile();\n\t\t\t\t\tdoGenerate(genModel);\n\t\t\t\t\tif (basePackage == null)\n\t\t\t\t\t\tbasePackage = genModel.getGenPackages().get(0).getBasePackage();\n\t\t\t\t\tsuper.generate(copiedGrammar, ctx);\n\t\t\t\t}\n\t\t\t\tresolveAll(resourceSet);\n\t\t\t\tePackages.save(singletonMap(XMLResource.OPTION_URI_HANDLER,\n\t\t\t\t\t\tnew ToPlatformResourceDeresolvingURIHandler()));\n\t\t\t}\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"ac4552f1e7228632e702f84db86247d4e3c5aaca","url":"https://github.com/eclipse/xtext"},{"original_method":"protected GenModel getSaveAndReconcileGenModel(ResourceSet rs, Grammar grammar, XpandExecutionContext ctx,\n\t\t\tList<EPackage> packs, List<GenPackage> usedGenPackages) throws ConfigurationException {\n\t\tGenModel genModel = null;\n\n\t\tgenModel = getGenModel(rs, grammar, ctx, packs);\n\t\tgenModel.initialize(packs);\n\t\tfor (GenPackage genPackage : genModel.getGenPackages()) {\n\t\t\tgenPackage.setBasePackage(getBasePackage(grammar));\n\t\t\tif (getFileExtensions() != null && packs.contains(genPackage.getEcorePackage())) {\n\t\t\t\tgenPackage.setFileExtensions(getFileExtensions());\n\t\t\t}\n\t\t}\n\t\tgenModel.getUsedGenPackages().addAll(usedGenPackages);\n\t\tresolveAll(rs);\n\t\ttry {\n\t\t\tgenModel.eResource().save(\n\t\t\t\t\tsingletonMap(XMLResource.OPTION_URI_HANDLER, new ToPlatformResourceDeresolvingURIHandler()));\n\t\t} catch (IOException e) {\n\t\t\tthrow new WrappedException(e);\n\t\t}\n\t\tnew GenModelHelper().registerGenModel(genModel);\n\t\treturn genModel;\n\t}","id":44821,"modified_method":"@Deprecated\n\tprotected GenModel getSaveAndReconcileGenModel(ResourceSet rs, Grammar grammar, XpandExecutionContext ctx,\n\t\t\tList<EPackage> packs, List<GenPackage> usedGenPackages) throws ConfigurationException {\n\t\treturn getSaveAndReconcileGenModel(rs, grammar, ctx, packs);\n\t}","commit_id":"ac4552f1e7228632e702f84db86247d4e3c5aaca","url":"https://github.com/eclipse/xtext"},{"original_method":"public static GenPackage getGenPackage(EPackage pkg) {\n\t\tURI genModelURI = EcorePlugin.getEPackageNsURIToGenModelLocationMap().get(pkg.getNsURI());\n\t\tif (genModelURI == null)\n\t\t\tthrow new RuntimeException(\"No GenModel for EPackage '\" + pkg.getNsURI() + \"' is registered.\");\n\t\tResourceSet resourceSet = pkg.eResource().getResourceSet();\n\t\tif (resourceSet == null)\n\t\t\tthrow new RuntimeException(\"There is no ResourceSet for EPackage '\" + pkg.getNsURI() + \"'. \"\n\t\t\t\t\t+ \"Please make sure the EPackage has been loaded from a .ecore file \"\n\t\t\t\t\t+ \"and not from the generated Java file.\");\n\t\tResource genModelResource = resourceSet.getResource(genModelURI, true);\n\t\tif (genModelResource == null)\n\t\t\tthrow new RuntimeException(\"Error loading GenModel \" + genModelURI);\n\t\tfor (EObject model : genModelResource.getContents())\n\t\t\tif (model instanceof GenModel)\n\t\t\t\tfor (GenPackage genPkg : ((GenModel) model).getGenPackages())\n\t\t\t\t\tif (pkg.getNsURI().equals(genPkg.getEcorePackage().getNsURI())) {\n\t\t\t\t\t\tgenPkg.getEcorePackage().getEClassifiers();\n\t\t\t\t\t\treturn genPkg;\n\t\t\t\t\t}\n\t\tthrow new RuntimeException(\"No GenPackage for NsURI \" + pkg.getNsURI() + \" found in \" + genModelURI);\n\t}","id":44822,"modified_method":"public static GenPackage getGenPackage(EPackage pkg) {\n\t\tURI genModelURI = EcorePlugin.getEPackageNsURIToGenModelLocationMap().get(pkg.getNsURI());\n\t\tif (genModelURI == null) {\n\t\t\tString from = pkg.eResource() != null ? \" from \" + pkg.eResource().getURI() : \"\";\n\t\t\tStringBuilder buf = new StringBuilder();\n\t\t\tbuf.append(\"Could not find a GenModel for EPackage '\" + pkg.getNsURI() + \"'\" + from + \"\\n\");\n\t\t\tbuf.append(\"If the missing GenModel has been generated via \" + EcoreGeneratorFragment.class.getSimpleName());\n\t\t\tbuf.append(\" make sure to run it first in the workflow.\\n\");\n\t\t\tbuf.append(\"If you have a *.genmodel-file, make sure to register it via StandaloneSetup.registerGenModelFile(String)\");\n\t\t\tthrow new RuntimeException(buf.toString());\n\t\t}\n\t\tResourceSet resourceSet = pkg.eResource().getResourceSet();\n\t\tif (resourceSet == null)\n\t\t\tthrow new RuntimeException(\"There is no ResourceSet for EPackage '\" + pkg.getNsURI() + \"'. \"\n\t\t\t\t\t+ \"Please make sure the EPackage has been loaded from a .ecore file \"\n\t\t\t\t\t+ \"and not from the generated Java file.\");\n\t\tResource genModelResource = resourceSet.getResource(genModelURI, true);\n\t\tif (genModelResource == null)\n\t\t\tthrow new RuntimeException(\"Error loading GenModel \" + genModelURI);\n\t\tfor (EObject model : genModelResource.getContents())\n\t\t\tif (model instanceof GenModel)\n\t\t\t\tfor (GenPackage genPkg : ((GenModel) model).getGenPackages())\n\t\t\t\t\tif (pkg.getNsURI().equals(genPkg.getEcorePackage().getNsURI())) {\n\t\t\t\t\t\tgenPkg.getEcorePackage().getEClassifiers();\n\t\t\t\t\t\treturn genPkg;\n\t\t\t\t\t}\n\t\tthrow new RuntimeException(\"No GenPackage for NsURI \" + pkg.getNsURI() + \" found in \" + genModelURI);\n\t}","commit_id":"ac4552f1e7228632e702f84db86247d4e3c5aaca","url":"https://github.com/eclipse/xtext"},{"original_method":"public IScope getScope(EObject context, EReference reference) {\n\t\treturn cache.get(new Pair<Resource, EClass>(context.eResource(), reference != null ? reference\n\t\t\t\t.getEReferenceType() : context.eClass().eClass()));\n\t}","id":44823,"modified_method":"public IScope getScope(EObject context, EReference reference) {\n\t\treturn cache.get(Tuples.create(context.eResource(), reference != null ? reference\n\t\t\t\t.getEReferenceType() : context.eClass().eClass()));\n\t}","commit_id":"94a43334e91eb963c02f8b1071573c1a0b355827","url":"https://github.com/eclipse/xtext"},{"original_method":"private Pair<String, String> getKey(AbstractMetamodelDeclaration metamodelDecl, String name) {\n\t\tif (metamodelDecl == null || name == null)\n\t\t\tthrow new NullPointerException(\"metamodelDecl: \" + metamodelDecl + \" / name: \" + name);\n\t\treturn new Pair<String, String>(metamodelDecl.getEPackage().getNsURI(), name);\n\t}","id":44824,"modified_method":"private Pair<String, String> getKey(AbstractMetamodelDeclaration metamodelDecl, String name) {\n\t\tif (metamodelDecl == null || name == null)\n\t\t\tthrow new NullPointerException(\"metamodelDecl: \" + metamodelDecl + \" / name: \" + name);\n\t\treturn Tuples.create(metamodelDecl.getEPackage().getNsURI(), name);\n\t}","commit_id":"94a43334e91eb963c02f8b1071573c1a0b355827","url":"https://github.com/eclipse/xtext"},{"original_method":"private static Pair<String, String> getURIAliasPair(AbstractMetamodelDeclaration decl) {\n\t\treturn new Pair<String, String>(decl.getEPackage().getNsURI(), Strings.emptyIfNull(decl.getAlias()));\n\t}","id":44825,"modified_method":"private static Pair<String, String> getURIAliasPair(AbstractMetamodelDeclaration decl) {\n\t\treturn Tuples.create(decl.getEPackage().getNsURI(), Strings.emptyIfNull(decl.getAlias()));\n\t}","commit_id":"94a43334e91eb963c02f8b1071573c1a0b355827","url":"https://github.com/eclipse/xtext"},{"original_method":"public void consume(Diagnostic diagnostic) {\n\t\tfinal Pair<Integer, Integer> newRange = new Pair<Integer, Integer>(diagnostic.getOffset(), diagnostic.getLength());\n\t\tif (coveredNodes.add(newRange)) {\n\t\t\tboolean changed = this.diagnostics.add(diagnostic);\n\t\t\tdiagnosticsConsumed |= changed;\n\t\t}\n\t}","id":44826,"modified_method":"public void consume(Diagnostic diagnostic) {\n\t\tfinal Pair<Integer, Integer> newRange = Tuples.create(diagnostic.getOffset(), diagnostic.getLength());\n\t\tif (coveredNodes.add(newRange)) {\n\t\t\tboolean changed = this.diagnostics.add(diagnostic);\n\t\t\tdiagnosticsConsumed |= changed;\n\t\t}\n\t}","commit_id":"94a43334e91eb963c02f8b1071573c1a0b355827","url":"https://github.com/eclipse/xtext"},{"original_method":"public T getFirstElement() {\n        return firstElement;\n    }","id":44827,"modified_method":"public T getFirst() {\n        return first;\n    }","commit_id":"94a43334e91eb963c02f8b1071573c1a0b355827","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean equals(Object other) {\n        if(other instanceof Pair<?,?>) {\n            Pair<?,?> otherPair = (Pair<?, ?>)other;\n            return firstElement.equals(otherPair.getFirstElement()) && secondElement.equals(otherPair.getSecondElement());\n        }\n        return false;\n    }","id":44828,"modified_method":"public boolean equals(Object other) {\n        if(this.getClass().equals(other.getClass())) {\n            Pair<?,?> otherPair = (Pair<?, ?>)other;\n            return first.equals(otherPair.getFirst()) && second.equals(otherPair.getSecond());\n        }\n        return false;\n    }","commit_id":"94a43334e91eb963c02f8b1071573c1a0b355827","url":"https://github.com/eclipse/xtext"},{"original_method":"public U getSecondElement() {\n        return secondElement;\n    }","id":44829,"modified_method":"public U getSecond() {\n        return second;\n    }","commit_id":"94a43334e91eb963c02f8b1071573c1a0b355827","url":"https://github.com/eclipse/xtext"},{"original_method":"public Pair(T firstElement, U secondElement) {\n        if(firstElement == null || secondElement == null) {\n            throw new IllegalArgumentException(\"Elements of Pair cannot be null\");\n        }\n        this.firstElement = firstElement;\n        this.secondElement = secondElement;\n    }","id":44830,"modified_method":"Pair(final T firstElement, final U secondElement) {\n        this.first = firstElement;\n        this.second = secondElement;\n    }","commit_id":"94a43334e91eb963c02f8b1071573c1a0b355827","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public int hashCode() {\n        return firstElement.hashCode() + 17*secondElement.hashCode();\n    }","id":44831,"modified_method":"@Override\n    public int hashCode() {\n        return first.hashCode() + 17*second.hashCode();\n    }","commit_id":"94a43334e91eb963c02f8b1071573c1a0b355827","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public String toString() {\n    \treturn \"<\" + firstElement + \", \" + secondElement + \">\";\n    }","id":44832,"modified_method":"@Override\n    public String toString() {\n    \treturn \"Pair(\" + first + \", \" + second + \")\";\n    }","commit_id":"94a43334e91eb963c02f8b1071573c1a0b355827","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public void close() throws IOException {\n    if (!mClosed) {\n      if (mCurrentBlockOutStream != null) {\n        mPreviousBlockOutStreams.add(mCurrentBlockOutStream);\n      }\n\n      if (WRITE_TYPE.isCache()) {\n        try {\n          if(mCancel){\n            for (BlockOutStream bos : mPreviousBlockOutStreams) {\n              bos.cancel();\n            }\n          }else {\n            for (BlockOutStream bos : mPreviousBlockOutStreams) {\n              bos.close();\n            }\n            TFS.completeFile(FILE.FID);\n          }\n        } catch (IOException ioe) {\n          if (WRITE_TYPE.isMustCache()) {\n            LOG.error(ioe.getMessage());\n            throw new IOException(\"Fail to cache: \" + WRITE_TYPE);\n          } else {\n            LOG.warn(\"Fail to cache for: \" + ioe.getMessage());\n          }\n        }\n      }\n\n      if (WRITE_TYPE.isThrough()) {\n        if (mCancel) {\n          mCheckpointOutputStream.close();\n          UnderFileSystem underFsClient = UnderFileSystem.get(mUnderFsFile);\n          underFsClient.delete(mUnderFsFile, false);\n        } else {\n          mCheckpointOutputStream.flush();\n          mCheckpointOutputStream.close();\n          TFS.addCheckpoint(FILE.FID);\n          TFS.completeFile(FILE.FID);\n        }\n      }\n    }\n\n    mClosed = true;\n  }","id":44833,"modified_method":"@Override\n  public void close() throws IOException {\n    if (!mClosed) {\n      if (mCurrentBlockOutStream != null) {\n        mPreviousBlockOutStreams.add(mCurrentBlockOutStream);\n      }\n\n      Boolean canComplete = false;\n      if (WRITE_TYPE.isThrough()) {\n        if (mCancel) {\n          mCheckpointOutputStream.close();\n          UnderFileSystem underFsClient = UnderFileSystem.get(mUnderFsFile);\n          underFsClient.delete(mUnderFsFile, false);\n        } else {\n          mCheckpointOutputStream.flush();\n          mCheckpointOutputStream.close();\n          TFS.addCheckpoint(FILE.FID);\n          canComplete = true;\n        }\n      }\n      \n      if (WRITE_TYPE.isCache()) {\n        try {\n          if(mCancel){\n            for (BlockOutStream bos : mPreviousBlockOutStreams) {\n              bos.cancel();\n            }\n          }else {\n            for (BlockOutStream bos : mPreviousBlockOutStreams) {\n              bos.close();\n            }\n            canComplete = true;\n          }\n        } catch (IOException ioe) {\n          if (WRITE_TYPE.isMustCache()) {\n            LOG.error(ioe.getMessage());\n            throw new IOException(\"Fail to cache: \" + WRITE_TYPE);\n          } else {\n            LOG.warn(\"Fail to cache for: \" + ioe.getMessage());\n          }\n        }\n      }   \n      \n      if (canComplete) {\n        TFS.completeFile(FILE.FID);\n      }\n    }\n\n    mClosed = true;\n  }","commit_id":"7c4ad439b42909085358f04f9fbce0674a2147dd","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n     * Create validation report.\n     */\n    static public NodeImpl writeReport(ValidationReport report, MemTreeBuilder builder) {\n\n        // start root element\n        int nodeNr = builder.startElement(\"\", \"report\", \"report\", null);\n\n        // validation status: valid or invalid\n        builder.startElement(\"\", \"status\", \"status\", null);\n        if (report.isValid()) {\n            builder.characters(\"valid\");\n        } else {\n            builder.characters(\"invalid\");\n        }\n        builder.endElement();\n\n        // namespace when available\n        if (report.getNamespaceUri() != null) {\n            builder.startElement(\"\", \"namespace\", \"namespace\", null);\n            builder.characters(report.getNamespaceUri());\n            builder.endElement();\n        }\n\n        // validation duration\n        builder.startElement(\"\", \"time\", \"time\", null);\n        builder.characters(\"\" + report.getValidationDuration());\n        builder.endElement();\n\n        // print exceptions if any\n        if (report.getThrowable() != null) {\n            builder.startElement(\"\", \"exception\", \"exception\", null);\n\n            builder.startElement(\"\", \"message\", \"exception\", null);\n            builder.characters(\"\" + report.getThrowable().getMessage());\n            builder.endElement();\n            \n            builder.startElement(\"\", \"stacktrace\", \"stacktrace\", null);\n            builder.characters(\"\" + report.getStackTrace());\n            builder.endElement();\n\n            builder.endElement();\n        }\n\n        // reusable attributes\n        AttributesImpl attribs = new AttributesImpl();\n\n        // iterate validation report items, write message\n        List cr = report.getValidationReportItemList();\n        for (Iterator iter = cr.iterator(); iter.hasNext();) {\n            ValidationReportItem vri = (ValidationReportItem) iter.next();\n\n            // construct attributes\n            attribs.addAttribute(\"\", \"level\", \"level\", \"CDATA\", vri.getTypeText());\n            attribs.addAttribute(\"\", \"line\", \"line\", \"CDATA\", Integer.toString(vri.getLineNumber()));\n            attribs.addAttribute(\"\", \"column\", \"column\", \"CDATA\", Integer.toString(vri.getColumnNumber()));\n\n            if (vri.getRepeat() > 1) {\n                attribs.addAttribute(\"\", \"repeat\", \"repeat\", \"CDATA\", Integer.toString(vri.getRepeat()));\n            }\n\n            // write message\n            builder.startElement(\"\", \"message\", \"message\", attribs);\n            builder.characters(vri.getMessage());\n            builder.endElement();\n\n            // Reuse attributes\n            attribs.clear();\n        }\n\n        // finish root element\n        builder.endElement();\n\n        // return result\n        return ((DocumentImpl) builder.getDocument()).getNode(nodeNr);\n\n    }","id":44834,"modified_method":"/**\n     * Create validation report.\n     */\n    static public NodeImpl writeReport(ValidationReport report, MemTreeBuilder builder) {\n\n        // start root element\n        int nodeNr = builder.startElement(\"\", \"report\", \"report\", null);\n\n        // validation status: valid or invalid\n        builder.startElement(\"\", \"status\", \"status\", null);\n        if (report.isValid()) {\n            builder.characters(\"valid\");\n        } else {\n            builder.characters(\"invalid\");\n        }\n        builder.endElement();\n\n        // namespace when available\n        if (report.getNamespaceUri() != null) {\n            builder.startElement(\"\", \"namespace\", \"namespace\", null);\n            builder.characters(report.getNamespaceUri());\n            builder.endElement();\n        }\n\n        // validation duration\n        builder.startElement(\"\", \"time\", \"time\", null);\n        builder.characters(\"\" + report.getValidationDuration());\n        builder.endElement();\n\n        // print exceptions if any\n        if (report.getThrowable() != null) {\n            builder.startElement(\"\", \"exception\", \"exception\", null);\n\n            String className = report.getThrowable().getClass().getName();\n            if (className != null) {\n                builder.startElement(\"\", \"class\", \"class\", null);\n                builder.characters(className);\n                builder.endElement();\n            }\n\n            String message = report.getThrowable().getMessage();\n            if (message != null) {\n                builder.startElement(\"\", \"message\", \"exception\", null);\n                builder.characters(message);\n                builder.endElement();\n            }\n\n            String stacktrace = report.getStackTrace();\n            if (stacktrace != null) {\n                builder.startElement(\"\", \"stacktrace\", \"stacktrace\", null);\n                builder.characters(stacktrace);\n                builder.endElement();\n            }\n\n            builder.endElement();\n        }\n\n        // reusable attributes\n        AttributesImpl attribs = new AttributesImpl();\n\n        // iterate validation report items, write message\n        List cr = report.getValidationReportItemList();\n        for (Iterator iter = cr.iterator(); iter.hasNext();) {\n            ValidationReportItem vri = (ValidationReportItem) iter.next();\n\n            // construct attributes\n            attribs.addAttribute(\"\", \"level\", \"level\", \"CDATA\", vri.getTypeText());\n            attribs.addAttribute(\"\", \"line\", \"line\", \"CDATA\", Integer.toString(vri.getLineNumber()));\n            attribs.addAttribute(\"\", \"column\", \"column\", \"CDATA\", Integer.toString(vri.getColumnNumber()));\n\n            if (vri.getRepeat() > 1) {\n                attribs.addAttribute(\"\", \"repeat\", \"repeat\", \"CDATA\", Integer.toString(vri.getRepeat()));\n            }\n\n            // write message\n            builder.startElement(\"\", \"message\", \"message\", attribs);\n            builder.characters(vri.getMessage());\n            builder.endElement();\n\n            // Reuse attributes\n            attribs.clear();\n        }\n\n        // finish root element\n        builder.endElement();\n\n        // return result\n        return ((DocumentImpl) builder.getDocument()).getNode(nodeNr);\n\n    }","commit_id":"f4a12947fb876e55f1e0ebbd8da531040331d258","url":"https://github.com/eXist-db/exist"},{"original_method":"public String getStackTrace(){\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        if(throwed !=null){\n            PrintStream ps = new PrintStream(baos);\n            throwed.printStackTrace(ps);\n        }\n        return baos.toString();\n    }","id":44835,"modified_method":"public String getStackTrace() {\n\n        if (throwed == null) {\n            return null;\n        }\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        PrintStream ps = new PrintStream(baos);\n        throwed.printStackTrace(ps);\n\n        return baos.toString();\n    }","commit_id":"f4a12947fb876e55f1e0ebbd8da531040331d258","url":"https://github.com/eXist-db/exist"},{"original_method":"private int similarity(ThreadInfo threadInfo, ThreadInfo threadInfo0) {\n        StackTraceElement[] s1 = threadInfo.getStackTrace();\n        StackTraceElement[] s2 = threadInfo0.getStackTrace();\n        int i = s1.length - 1;\n        int j = s2.length - 1;\n        int rslt = 0;\n        while (i >= 0 && j >= 0 && s1[i].equals(s2[j])) {\n            rslt++;\n            i--;\n            j--;\n        }\n        return rslt;\n    }","id":44836,"modified_method":"private int similarity(ThreadInfo threadInfo, ThreadInfo threadInfo0) {\n        StackTraceElement[] s1 = threadInfo == null ? EMPTY : threadInfo.getStackTrace();\n        StackTraceElement[] s2 = threadInfo0 == null ? EMPTY : threadInfo0.getStackTrace();\n        int i = s1.length - 1;\n        int j = s2.length - 1;\n        int rslt = 0;\n        while (i >= 0 && j >= 0 && s1[i].equals(s2[j])) {\n            rslt++;\n            i--;\n            j--;\n        }\n        return rslt;\n    }","commit_id":"42377db084f96e75fcbc28b76c45d96315ac2959","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private String innerDetect() throws Exception {\n        StringBuilder sb = new StringBuilder();\n        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n        boolean enabledCpu = false;\n        try {\n            if (threadBean.isThreadCpuTimeSupported()) {\n                if (!threadBean.isThreadCpuTimeEnabled()) {\n                    enabledCpu = true;\n                    threadBean.setThreadCpuTimeEnabled(true);\n                }\n            } else {\n                throw new IllegalStateException(\"MBean doesn't support thread CPU Time\");\n            }\n            Map<Long, MyThreadInfo> threadInfos = new HashMap<Long, MyThreadInfo>();\n            for (long threadId : threadBean.getAllThreadIds()) {\n                // ignore our own thread...\n                if (Thread.currentThread().getId() == threadId) {\n                    continue;\n                }\n                long cpu = threadBean.getThreadCpuTime(threadId);\n                if (cpu == -1) {\n                    continue;\n                }\n                ThreadInfo info = threadBean.getThreadInfo(threadId, 0);\n                if (info == null) {\n                    continue;\n                }\n                threadInfos.put(threadId, new MyThreadInfo(cpu, info));\n            }\n            Thread.sleep(interval.millis());\n            for (long threadId : threadBean.getAllThreadIds()) {\n                // ignore our own thread...\n                if (Thread.currentThread().getId() == threadId) {\n                    continue;\n                }\n                long cpu = threadBean.getThreadCpuTime(threadId);\n                if (cpu == -1) {\n                    threadInfos.remove(threadId);\n                    continue;\n                }\n                ThreadInfo info = threadBean.getThreadInfo(threadId, 0);\n                if (info == null) {\n                    threadInfos.remove(threadId);\n                    continue;\n                }\n                MyThreadInfo data = threadInfos.get(threadId);\n                if (data != null) {\n                    data.setDelta(cpu, info);\n                } else {\n                    threadInfos.remove(threadId);\n                }\n            }\n            // sort by delta CPU time on thread.\n            List<MyThreadInfo> hotties = new ArrayList<MyThreadInfo>(threadInfos.values());\n            // skip that for now\n            CollectionUtil.introSort(hotties, new Comparator<MyThreadInfo>() {\n                public int compare(MyThreadInfo o1, MyThreadInfo o2) {\n                    if (\"cpu\".equals(type)) {\n                        return (int) (o2.cpuTime - o1.cpuTime);\n                    } else if (\"wait\".equals(type)) {\n                        return (int) (o2.waitedTime - o1.waitedTime);\n                    } else if (\"block\".equals(type)) {\n                        return (int) (o2.blockedTime - o1.blockedTime);\n                    }\n                    throw new IllegalArgumentException();\n                }\n            });\n            // analyse N stack traces for M busiest threads\n            long[] ids = new long[busiestThreads];\n            for (int i = 0; i < busiestThreads; i++) {\n                MyThreadInfo info = hotties.get(i);\n                ids[i] = info.info.getThreadId();\n            }\n            ThreadInfo[][] allInfos = new ThreadInfo[threadElementsSnapshotCount][];\n            for (int j = 0; j < threadElementsSnapshotCount; j++) {\n                allInfos[j] = threadBean.getThreadInfo(ids, Integer.MAX_VALUE);\n                Thread.sleep(threadElementsSnapshotDelay.millis());\n            }\n            for (int t = 0; t < busiestThreads; t++) {\n                long time = 0;\n                if (\"cpu\".equals(type)) {\n                    time = hotties.get(t).cpuTime;\n                } else if (\"wait\".equals(type)) {\n                    time = hotties.get(t).waitedTime;\n                } else if (\"block\".equals(type)) {\n                    time = hotties.get(t).blockedTime;\n                }\n                double percent = (((double) time) / interval.nanos()) * 100;\n                sb.append(String.format(Locale.ROOT, \"%n%4.1f%% (%s out of %s) %s usage by thread '%s'%n\", percent, TimeValue.timeValueNanos(time), interval, type, allInfos[0][t].getThreadName()));\n                // for each snapshot (2nd array index) find later snapshot for same thread with max number of\n                // identical StackTraceElements (starting from end of each)\n                boolean[] done = new boolean[threadElementsSnapshotCount];\n                for (int i = 0; i < threadElementsSnapshotCount; i++) {\n                    if (done[i]) continue;\n                    int maxSim = 1;\n                    boolean[] similars = new boolean[threadElementsSnapshotCount];\n                    for (int j = i + 1; j < threadElementsSnapshotCount; j++) {\n                        if (done[j]) continue;\n                        int similarity = similarity(allInfos[i][t], allInfos[j][t]);\n                        if (similarity > maxSim) {\n                            maxSim = similarity;\n                            similars = new boolean[threadElementsSnapshotCount];\n                        }\n                        if (similarity == maxSim) similars[j] = true;\n                    }\n                    // print out trace maxSim levels of i, and mark similar ones as done\n                    int count = 1;\n                    for (int j = i + 1; j < threadElementsSnapshotCount; j++) {\n                        if (similars[j]) {\n                            done[j] = true;\n                            count++;\n                        }\n                    }\n                    StackTraceElement[] show = allInfos[i][t].getStackTrace();\n                    if (count == 1) {\n                        sb.append(String.format(Locale.ROOT, \"  unique snapshot%n\"));\n                        for (int l = 0; l < show.length; l++) {\n                            sb.append(String.format(Locale.ROOT, \"    %s%n\", show[l]));\n                        }\n                    } else {\n                        sb.append(String.format(Locale.ROOT, \"  %d/%d snapshots sharing following %d elements%n\", count, threadElementsSnapshotCount, maxSim));\n                        for (int l = show.length - maxSim; l < show.length; l++) {\n                            sb.append(String.format(Locale.ROOT, \"    %s%n\", show[l]));\n                        }\n                    }\n                }\n            }\n            return sb.toString();\n        } finally {\n            if (enabledCpu) {\n                threadBean.setThreadCpuTimeEnabled(false);\n            }\n        }\n    }","id":44837,"modified_method":"private String innerDetect() throws Exception {\n        StringBuilder sb = new StringBuilder();\n        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n        boolean enabledCpu = false;\n        try {\n            if (threadBean.isThreadCpuTimeSupported()) {\n                if (!threadBean.isThreadCpuTimeEnabled()) {\n                    enabledCpu = true;\n                    threadBean.setThreadCpuTimeEnabled(true);\n                }\n            } else {\n                throw new IllegalStateException(\"MBean doesn't support thread CPU Time\");\n            }\n            Map<Long, MyThreadInfo> threadInfos = new HashMap<Long, MyThreadInfo>();\n            for (long threadId : threadBean.getAllThreadIds()) {\n                // ignore our own thread...\n                if (Thread.currentThread().getId() == threadId) {\n                    continue;\n                }\n                long cpu = threadBean.getThreadCpuTime(threadId);\n                if (cpu == -1) {\n                    continue;\n                }\n                ThreadInfo info = threadBean.getThreadInfo(threadId, 0);\n                if (info == null) {\n                    continue;\n                }\n                threadInfos.put(threadId, new MyThreadInfo(cpu, info));\n            }\n            Thread.sleep(interval.millis());\n            for (long threadId : threadBean.getAllThreadIds()) {\n                // ignore our own thread...\n                if (Thread.currentThread().getId() == threadId) {\n                    continue;\n                }\n                long cpu = threadBean.getThreadCpuTime(threadId);\n                if (cpu == -1) {\n                    threadInfos.remove(threadId);\n                    continue;\n                }\n                ThreadInfo info = threadBean.getThreadInfo(threadId, 0);\n                if (info == null) {\n                    threadInfos.remove(threadId);\n                    continue;\n                }\n                MyThreadInfo data = threadInfos.get(threadId);\n                if (data != null) {\n                    data.setDelta(cpu, info);\n                } else {\n                    threadInfos.remove(threadId);\n                }\n            }\n            // sort by delta CPU time on thread.\n            List<MyThreadInfo> hotties = new ArrayList<MyThreadInfo>(threadInfos.values());\n            // skip that for now\n            CollectionUtil.introSort(hotties, new Comparator<MyThreadInfo>() {\n                public int compare(MyThreadInfo o1, MyThreadInfo o2) {\n                    if (\"cpu\".equals(type)) {\n                        return (int) (o2.cpuTime - o1.cpuTime);\n                    } else if (\"wait\".equals(type)) {\n                        return (int) (o2.waitedTime - o1.waitedTime);\n                    } else if (\"block\".equals(type)) {\n                        return (int) (o2.blockedTime - o1.blockedTime);\n                    }\n                    throw new IllegalArgumentException();\n                }\n            });\n            // analyse N stack traces for M busiest threads\n            long[] ids = new long[busiestThreads];\n            for (int i = 0; i < busiestThreads; i++) {\n                MyThreadInfo info = hotties.get(i);\n                ids[i] = info.info.getThreadId();\n            }\n            ThreadInfo[][] allInfos = new ThreadInfo[threadElementsSnapshotCount][];\n            for (int j = 0; j < threadElementsSnapshotCount; j++) {\n                // NOTE, javadoc of getThreadInfo says: If a thread of the given ID is not alive or does not exist,\n                // null will be set in the corresponding element in the returned array. A thread is alive if it has\n                // been started and has not yet died.\n                allInfos[j] = threadBean.getThreadInfo(ids, Integer.MAX_VALUE);\n                Thread.sleep(threadElementsSnapshotDelay.millis());\n            }\n            for (int t = 0; t < busiestThreads; t++) {\n                long time = 0;\n                if (\"cpu\".equals(type)) {\n                    time = hotties.get(t).cpuTime;\n                } else if (\"wait\".equals(type)) {\n                    time = hotties.get(t).waitedTime;\n                } else if (\"block\".equals(type)) {\n                    time = hotties.get(t).blockedTime;\n                }\n                String threadName = null;\n                if (allInfos[0][t] == null) {\n                    for (ThreadInfo[] info : allInfos) {\n                        if (info != null && info[t] != null) {\n                            threadName = info[t].getThreadName();\n                            break;\n                        }\n                    }\n                    if (threadName == null) {\n                        continue; // thread is not alive yet or died before the first snapshot - ignore it!\n                    }\n                } else {\n                    threadName = allInfos[0][t].getThreadName();\n                }\n                double percent = (((double) time) / interval.nanos()) * 100;\n                sb.append(String.format(Locale.ROOT, \"%n%4.1f%% (%s out of %s) %s usage by thread '%s'%n\", percent, TimeValue.timeValueNanos(time), interval, type, threadName));\n                // for each snapshot (2nd array index) find later snapshot for same thread with max number of\n                // identical StackTraceElements (starting from end of each)\n                boolean[] done = new boolean[threadElementsSnapshotCount];\n                for (int i = 0; i < threadElementsSnapshotCount; i++) {\n                    if (done[i]) continue;\n                    int maxSim = 1;\n                    boolean[] similars = new boolean[threadElementsSnapshotCount];\n                    for (int j = i + 1; j < threadElementsSnapshotCount; j++) {\n                        if (done[j]) continue;\n                        int similarity = similarity(allInfos[i][t], allInfos[j][t]);\n                        if (similarity > maxSim) {\n                            maxSim = similarity;\n                            similars = new boolean[threadElementsSnapshotCount];\n                        }\n                        if (similarity == maxSim) similars[j] = true;\n                    }\n                    // print out trace maxSim levels of i, and mark similar ones as done\n                    int count = 1;\n                    for (int j = i + 1; j < threadElementsSnapshotCount; j++) {\n                        if (similars[j]) {\n                            done[j] = true;\n                            count++;\n                        }\n                    }\n                    if (allInfos[i][t] != null) {\n                        final StackTraceElement[] show = allInfos[i][t].getStackTrace();\n                        if (count == 1) {\n                            sb.append(String.format(Locale.ROOT, \"  unique snapshot%n\"));\n                            for (int l = 0; l < show.length; l++) {\n                                sb.append(String.format(Locale.ROOT, \"    %s%n\", show[l]));\n                            }\n                        } else {\n                            sb.append(String.format(Locale.ROOT, \"  %d/%d snapshots sharing following %d elements%n\", count, threadElementsSnapshotCount, maxSim));\n                            for (int l = show.length - maxSim; l < show.length; l++) {\n                                sb.append(String.format(Locale.ROOT, \"    %s%n\", show[l]));\n                            }\n                        }\n                    }\n                }\n            }\n            return sb.toString();\n        } finally {\n            if (enabledCpu) {\n                threadBean.setThreadCpuTimeEnabled(false);\n            }\n        }\n    }","commit_id":"42377db084f96e75fcbc28b76c45d96315ac2959","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** Receives a message from the router (blocking mode). If the connection is down,\n     false is returned, otherwise true */\n    public Message receive() {\n        Message ret=null;\n        byte[] buf=null;\n        int len;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub.receive()\", \"No connection to router\");\n            connected=false;\n            return null;\n        }\n        try {\n            len=input.readInt();\n            if(len == 0) {\n                ret=null;\n            }\n            else {\n                buf=new byte[len];\n                input.readFully(buf, 0, len);\n                ret=(Message)Util.objectFromByteBuffer(buf);\n            }\n        }\n        catch(Exception e) {\n            if (connected) {\n                Trace.error(\"RouterStub.receive()\", Trace.getStackTrace(e));                \n            }\n            connected=false;\n            return null;\n        }\n        return ret;\n    }","id":44838,"modified_method":"/** Receives a message from the router (blocking mode). If the connection is down,\n     false is returned, otherwise true */\n    public Message receive() {\n        Message ret=null;\n        byte[] buf=null;\n        int len;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub\", \"receive(): No connection to router\");\n            connected=false;\n            return null;\n        }\n        try {\n            len=input.readInt();\n            if(len == 0) {\n                ret=null;\n            }\n            else {\n                buf=new byte[len];\n                input.readFully(buf, 0, len);\n                ret=(Message)Util.objectFromByteBuffer(buf);\n            }\n        }\n        catch(Exception e) {\n            if (connected) {\n                Trace.error(\"RouterStub\", \"receive(): \"+Trace.getStackTrace(e));                \n            }\n            connected=false;\n            return null;\n        }\n\n        if (Trace.debug) {\n            Trace.debug(\"RouterStub\", \"received \"+ret);\n        }\n        return ret;\n    }","commit_id":"dc6dbfb9f57d521e523e6896e580c49c06b3f173","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Sends a message to the router. Returns false if message cannot be sent (e.g. no connection to\n     router, true otherwise. */\n    public boolean send(Message msg, String groupname) {\n        byte[] msg_buf=null;\n        byte[] dst_buf=null;\n        Object dst_addr=null;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub.send()\", \"No connection to router (groupname=\" + groupname + \")\");\n            connected=false;\n            return false;\n        }\n\n        if(msg == null) {\n            Trace.error(\"RouterStub.send()\", \"Message is null\");\n            return false;\n        }\n\n        try {\n            dst_addr=msg.getDest(); // could be null in case of mcast\n            if(dst_addr != null)\n                dst_buf=Util.objectToByteBuffer(dst_addr);\n\n            msg_buf=Util.objectToByteBuffer(msg);\n\n            output.writeUTF(groupname);\n\n            if(dst_buf != null && dst_buf.length > 0) {\n                output.writeInt(dst_buf.length);\n                output.write(dst_buf, 0, dst_buf.length);\n            }\n            else\n                output.writeInt(0);\n\n            output.writeInt(msg_buf.length);\n            output.write(msg_buf, 0, msg_buf.length);\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub.send()\", Trace.getStackTrace(e));\n            connected=false;\n            return false;\n        }\n        return true;\n    }","id":44839,"modified_method":"/** Sends a message to the router. Returns false if message cannot be sent (e.g. no connection to\n     router, true otherwise. */\n    public boolean send(Message msg, String groupname) {\n        byte[] msg_buf=null;\n        byte[] dst_buf=null;\n        Object dst_addr=null;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub\", \"send(): No connection to router (groupname=\" + groupname + \")\");\n            connected=false;\n            return false;\n        }\n\n        if(msg == null) {\n            Trace.error(\"RouterStub\", \"send(): Message is null\");\n            return false;\n        }\n\n        try {\n            dst_addr=msg.getDest(); // could be null in case of mcast\n            if(dst_addr != null)\n                dst_buf=Util.objectToByteBuffer(dst_addr);\n\n            msg_buf=Util.objectToByteBuffer(msg);\n\n            output.writeUTF(groupname);\n\n            if(dst_buf != null && dst_buf.length > 0) {\n                output.writeInt(dst_buf.length);\n                output.write(dst_buf, 0, dst_buf.length);\n            }\n            else\n                output.writeInt(0);\n\n            output.writeInt(msg_buf.length);\n            output.write(msg_buf, 0, msg_buf.length);\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub\", \"send(): \"+Trace.getStackTrace(e));\n            connected=false;\n            return false;\n        }\n        return true;\n    }","commit_id":"dc6dbfb9f57d521e523e6896e580c49c06b3f173","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Tries to establish connection to router. Tries until router is up again. */\n    public synchronized boolean reconnect() {\n        Address new_addr=null;\n\n        if(connected) return false;\n\n        disconnect();\n        reconnect=true;\n        while(reconnect) {\n            try {\n                if((new_addr=connect()) != null)\n                    break;\n            }\n            catch(Exception ex) {\n                Trace.warn(\"RouterStub.reconnect()\", \"exception is \" + ex);\n            }\n            Util.sleep(RECONNECT_TIMEOUT);\n        }\n        if(new_addr == null) {\n            return false;\n        }\n        Trace.warn(\"RouterStub.reconnect()\", \"Client reconnected, new addess is \" + new_addr);\n        return true;\n    }","id":44840,"modified_method":"/** Tries to establish connection to router. Tries until router is up again. */\n    public synchronized boolean reconnect() {\n        Address new_addr=null;\n\n        if(connected) return false;\n\n        disconnect();\n        reconnect=true;\n        while(reconnect) {\n            try {\n                if((new_addr=connect()) != null)\n                    break;\n            }\n            catch(Exception ex) {\n                Trace.warn(\"RouterStub\", \"reconnect(): exception is \" + ex);\n            }\n            Util.sleep(RECONNECT_TIMEOUT);\n        }\n        if(new_addr == null) {\n            return false;\n        }\n        Trace.warn(\"RouterStub\", \"reconnect(): Client reconnected, new addess is \" + new_addr);\n        return true;\n    }","commit_id":"dc6dbfb9f57d521e523e6896e580c49c06b3f173","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Register this process with the router under <code>groupname<\/code>.\n     @param groupname The name of the group under which to register\n     @return boolean False if connection down, true if registration successful.\n     */\n    public boolean register(String groupname) {\n        byte[] buf=null;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub.register()\", \"No connection to router (groupname=\" + groupname + \")\");\n            connected=false;\n            return false;\n        }\n\n        if(groupname == null || groupname.length() == 0) {\n            Trace.error(\"RouterStub.register()\", \"groupname is null\");\n            return false;\n        }\n\n        if(local_addr == null) {\n            Trace.error(\"RouterStub.register()\", \"local_addr is null\");\n            return false;\n        }\n\n        try {\n            buf=Util.objectToByteBuffer(local_addr);\n            output.writeInt(Router.REGISTER);\n            output.writeUTF(groupname);\n            output.writeInt(buf.length);\n            output.write(buf, 0, buf.length);  // local_addr\n            output.flush();\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub.register()\", Trace.getStackTrace(e));\n            connected=false;\n            return false;\n        }\n        return true;\n    }","id":44841,"modified_method":"/**\n     Register this process with the router under <code>groupname<\/code>.\n     @param groupname The name of the group under which to register\n     @return boolean False if connection down, true if registration successful.\n     */\n    public boolean register(String groupname) {\n        byte[] buf=null;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub\", \".register(): No connection to router (groupname=\" + groupname + \")\");\n            connected=false;\n            return false;\n        }\n\n        if(groupname == null || groupname.length() == 0) {\n            Trace.error(\"RouterStub\", \"register(): groupname is null\");\n            return false;\n        }\n\n        if(local_addr == null) {\n            Trace.error(\"RouterStub\", \"register(): local_addr is null\");\n            return false;\n        }\n\n        try {\n            buf=Util.objectToByteBuffer(local_addr);\n            output.writeInt(Router.REGISTER);\n            output.writeUTF(groupname);\n            output.writeInt(buf.length);\n            output.write(buf, 0, buf.length);  // local_addr\n            output.flush();\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub\", \"register(): \"+Trace.getStackTrace(e));\n            connected=false;\n            return false;\n        }\n        return true;\n    }","commit_id":"dc6dbfb9f57d521e523e6896e580c49c06b3f173","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Retrieves the membership (list of Addresses) for a given group. This is mainly used by the PING\n     protocol to obtain its initial membership. This is used infrequently, so don't maintain socket\n     for the entire time, but create/delete it on demand.\n     */\n    public List get(String groupname) {\n        List ret=null;\n        Socket tmpsock=null;\n        DataOutputStream output=null;\n        DataInputStream input=null;\n        int len;\n        byte[] buf;\n\n\n        if(groupname == null || groupname.length() == 0) {\n            Trace.error(\"RouterStub.get()\", \"groupname is null\");\n            return null;\n        }\n\n        try {\n            tmpsock=new Socket(router_host, router_port);\n            tmpsock.setSoLinger(true, 500);\n            input=new DataInputStream(tmpsock.getInputStream());\n\n            len=input.readInt();     // discard my own address\n            buf=new byte[len];       // (first thing returned by router on acept())\n            input.readFully(buf);\n            output=new DataOutputStream(tmpsock.getOutputStream());\n\n            // request membership for groupname\n            output.writeInt(Router.GET);\n            output.writeUTF(groupname);\n\n            // wait for response (List)\n            len=input.readInt();\n            if(len == 0)\n                return null;\n\n            buf=new byte[len];\n            input.readFully(buf);\n            ret=(List)Util.objectFromByteBuffer(buf);\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub.get()\", \"exception=\" + e);\n        }\n        finally {\n            try {\n                if(output != null) output.close();\n            }\n            catch(Exception e) {\n            }\n            try {\n                if(input != null) input.close();\n            }\n            catch(Exception e) {\n            }\n            try {\n                if(tmpsock != null) tmpsock.close();\n            }\n            catch(Exception e) {\n            }\n        }\n        return ret;\n    }","id":44842,"modified_method":"/**\n     Retrieves the membership (list of Addresses) for a given group. This is mainly used by the PING\n     protocol to obtain its initial membership. This is used infrequently, so don't maintain socket\n     for the entire time, but create/delete it on demand.\n     */\n    public List get(String groupname) {\n        List ret=null;\n        Socket tmpsock=null;\n        DataOutputStream output=null;\n        DataInputStream input=null;\n        int len;\n        byte[] buf;\n\n\n        if(groupname == null || groupname.length() == 0) {\n            Trace.error(\"RouterStub\", \"get(): groupname is null\");\n            return null;\n        }\n\n        try {\n            tmpsock=new Socket(router_host, router_port);\n            tmpsock.setSoLinger(true, 500);\n            input=new DataInputStream(tmpsock.getInputStream());\n\n            len=input.readInt();     // discard my own address\n            buf=new byte[len];       // (first thing returned by router on acept())\n            input.readFully(buf);\n            output=new DataOutputStream(tmpsock.getOutputStream());\n\n            // request membership for groupname\n            output.writeInt(Router.GET);\n            output.writeUTF(groupname);\n\n            // wait for response (List)\n            len=input.readInt();\n            if(len == 0)\n                return null;\n\n            buf=new byte[len];\n            input.readFully(buf);\n            ret=(List)Util.objectFromByteBuffer(buf);\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub\", \"get(): exception=\" + e);\n        }\n        finally {\n            try {\n                if(output != null) output.close();\n            }\n            catch(Exception e) {\n            }\n            try {\n                if(input != null) input.close();\n            }\n            catch(Exception e) {\n            }\n            try {\n                if(tmpsock != null) tmpsock.close();\n            }\n            catch(Exception e) {\n            }\n        }\n        return ret;\n    }","commit_id":"dc6dbfb9f57d521e523e6896e580c49c06b3f173","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Retrieves the membership (list of Addresses) for a given group. This is mainly used by the PING\n     protocol to obtain its initial membership. This is used infrequently, so don't maintain socket\n     for the entire time, but create/delete it on demand.\n     */\n    public List get(String groupname) {\n        List ret=null;\n        Socket tmpsock=null;\n        DataOutputStream output=null;\n        DataInputStream input=null;\n        int len;\n        byte[] buf;\n\n\n        if(groupname == null || groupname.length() == 0) {\n            Trace.error(\"RouterStub.get()\", \"groupname is null\");\n            return null;\n        }\n\n        try {\n            tmpsock=new Socket(router_host, router_port);\n            tmpsock.setSoLinger(true, 500);\n            input=new DataInputStream(tmpsock.getInputStream());\n\n            len=input.readInt();     // discard my own address\n            buf=new byte[len];       // (first thing returned by router on acept())\n            input.readFully(buf);\n            output=new DataOutputStream(tmpsock.getOutputStream());\n\n            // request membership for groupname\n            output.writeInt(Router.GET);\n            output.writeUTF(groupname);\n\n            // wait for response (List)\n            len=input.readInt();\n            if(len == 0)\n                return null;\n\n            buf=new byte[len];\n            input.readFully(buf);\n            ret=(List)Util.objectFromByteBuffer(buf);\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub.get()\", \"exception=\" + e);\n        }\n        finally {\n            try {\n                if(output != null) output.close();\n            }\n            catch(Exception e) {\n            }\n            try {\n                if(input != null) input.close();\n            }\n            catch(Exception e) {\n            }\n            try {\n                if(tmpsock != null) tmpsock.close();\n            }\n            catch(Exception e) {\n            }\n        }\n        return ret;\n    }","id":44843,"modified_method":"/**\n     Retrieves the membership (list of Addresses) for a given group. This is mainly used by the PING\n     protocol to obtain its initial membership. This is used infrequently, so don't maintain socket\n     for the entire time, but create/delete it on demand.\n     */\n    public List get(String groupname) {\n        List ret=null;\n        Socket tmpsock=null;\n        DataOutputStream output=null;\n        DataInputStream input=null;\n        int len;\n        byte[] buf;\n\n\n        if(groupname == null || groupname.length() == 0) {\n            Trace.error(\"RouterStub\", \"get(): groupname is null\");\n            return null;\n        }\n\n        try {\n            tmpsock=new Socket(router_host, router_port);\n            tmpsock.setSoLinger(true, 500);\n            input=new DataInputStream(tmpsock.getInputStream());\n\n            len=input.readInt();     // discard my own address\n            buf=new byte[len];       // (first thing returned by router on acept())\n            input.readFully(buf);\n            output=new DataOutputStream(tmpsock.getOutputStream());\n\n            // request membership for groupname\n            output.writeInt(Router.GET);\n            output.writeUTF(groupname);\n\n            // wait for response (List)\n            len=input.readInt();\n            if(len == 0)\n                return null;\n\n            buf=new byte[len];\n            input.readFully(buf);\n            ret=(List)Util.objectFromByteBuffer(buf);\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub\", \"get(): exception=\" + e);\n        }\n        finally {\n            try {\n                if(output != null) output.close();\n            }\n            catch(Exception e) {\n            }\n            try {\n                if(input != null) input.close();\n            }\n            catch(Exception e) {\n            }\n            try {\n                if(tmpsock != null) tmpsock.close();\n            }\n            catch(Exception e) {\n            }\n        }\n        return ret;\n    }","commit_id":"38f6babf6dc697845686ccbbb711b3b4ac699469","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     Register this process with the router under <code>groupname<\/code>.\n     @param groupname The name of the group under which to register\n     @return boolean False if connection down, true if registration successful.\n     */\n    public boolean register(String groupname) {\n        byte[] buf=null;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub.register()\", \"No connection to router (groupname=\" + groupname + \")\");\n            connected=false;\n            return false;\n        }\n\n        if(groupname == null || groupname.length() == 0) {\n            Trace.error(\"RouterStub.register()\", \"groupname is null\");\n            return false;\n        }\n\n        if(local_addr == null) {\n            Trace.error(\"RouterStub.register()\", \"local_addr is null\");\n            return false;\n        }\n\n        try {\n            buf=Util.objectToByteBuffer(local_addr);\n            output.writeInt(Router.REGISTER);\n            output.writeUTF(groupname);\n            output.writeInt(buf.length);\n            output.write(buf, 0, buf.length);  // local_addr\n            output.flush();\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub.register()\", Trace.getStackTrace(e));\n            connected=false;\n            return false;\n        }\n        return true;\n    }","id":44844,"modified_method":"/**\n     Register this process with the router under <code>groupname<\/code>.\n     @param groupname The name of the group under which to register\n     @return boolean False if connection down, true if registration successful.\n     */\n    public boolean register(String groupname) {\n        byte[] buf=null;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub\", \".register(): No connection to router (groupname=\" + groupname + \")\");\n            connected=false;\n            return false;\n        }\n\n        if(groupname == null || groupname.length() == 0) {\n            Trace.error(\"RouterStub\", \"register(): groupname is null\");\n            return false;\n        }\n\n        if(local_addr == null) {\n            Trace.error(\"RouterStub\", \"register(): local_addr is null\");\n            return false;\n        }\n\n        try {\n            buf=Util.objectToByteBuffer(local_addr);\n            output.writeInt(Router.REGISTER);\n            output.writeUTF(groupname);\n            output.writeInt(buf.length);\n            output.write(buf, 0, buf.length);  // local_addr\n            output.flush();\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub\", \"register(): \"+Trace.getStackTrace(e));\n            connected=false;\n            return false;\n        }\n        return true;\n    }","commit_id":"38f6babf6dc697845686ccbbb711b3b4ac699469","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Tries to establish connection to router. Tries until router is up again. */\n    public synchronized boolean reconnect() {\n        Address new_addr=null;\n\n        if(connected) return false;\n\n        disconnect();\n        reconnect=true;\n        while(reconnect) {\n            try {\n                if((new_addr=connect()) != null)\n                    break;\n            }\n            catch(Exception ex) {\n                Trace.warn(\"RouterStub.reconnect()\", \"exception is \" + ex);\n            }\n            Util.sleep(RECONNECT_TIMEOUT);\n        }\n        if(new_addr == null) {\n            return false;\n        }\n        Trace.warn(\"RouterStub.reconnect()\", \"Client reconnected, new addess is \" + new_addr);\n        return true;\n    }","id":44845,"modified_method":"/** Tries to establish connection to router. Tries until router is up again. */\n    public synchronized boolean reconnect() {\n        Address new_addr=null;\n\n        if(connected) return false;\n\n        disconnect();\n        reconnect=true;\n        while(reconnect) {\n            try {\n                if((new_addr=connect()) != null)\n                    break;\n            }\n            catch(Exception ex) {\n                Trace.warn(\"RouterStub\", \"reconnect(): exception is \" + ex);\n            }\n            Util.sleep(RECONNECT_TIMEOUT);\n        }\n        if(new_addr == null) {\n            return false;\n        }\n        Trace.warn(\"RouterStub\", \"reconnect(): Client reconnected, new addess is \" + new_addr);\n        return true;\n    }","commit_id":"38f6babf6dc697845686ccbbb711b3b4ac699469","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Receives a message from the router (blocking mode). If the connection is down,\n     false is returned, otherwise true */\n    public Message receive() {\n        Message ret=null;\n        byte[] buf=null;\n        int len;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub.receive()\", \"No connection to router\");\n            connected=false;\n            return null;\n        }\n        try {\n            len=input.readInt();\n            if(len == 0) {\n                ret=null;\n            }\n            else {\n                buf=new byte[len];\n                input.readFully(buf, 0, len);\n                ret=(Message)Util.objectFromByteBuffer(buf);\n            }\n        }\n        catch(Exception e) {\n            if (connected) {\n                Trace.error(\"RouterStub.receive()\", Trace.getStackTrace(e));                \n            }\n            connected=false;\n            return null;\n        }\n        return ret;\n    }","id":44846,"modified_method":"/** Receives a message from the router (blocking mode). If the connection is down,\n     false is returned, otherwise true */\n    public Message receive() {\n        Message ret=null;\n        byte[] buf=null;\n        int len;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub\", \"receive(): No connection to router\");\n            connected=false;\n            return null;\n        }\n        try {\n            len=input.readInt();\n            if(len == 0) {\n                ret=null;\n            }\n            else {\n                buf=new byte[len];\n                input.readFully(buf, 0, len);\n                ret=(Message)Util.objectFromByteBuffer(buf);\n            }\n        }\n        catch(Exception e) {\n            if (connected) {\n                Trace.error(\"RouterStub\", \"receive(): \"+Trace.getStackTrace(e));                \n            }\n            connected=false;\n            return null;\n        }\n\n        if (Trace.debug) {\n            Trace.debug(\"RouterStub\", \"received \"+ret);\n        }\n        return ret;\n    }","commit_id":"38f6babf6dc697845686ccbbb711b3b4ac699469","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Sends a message to the router. Returns false if message cannot be sent (e.g. no connection to\n     router, true otherwise. */\n    public boolean send(Message msg, String groupname) {\n        byte[] msg_buf=null;\n        byte[] dst_buf=null;\n        Object dst_addr=null;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub.send()\", \"No connection to router (groupname=\" + groupname + \")\");\n            connected=false;\n            return false;\n        }\n\n        if(msg == null) {\n            Trace.error(\"RouterStub.send()\", \"Message is null\");\n            return false;\n        }\n\n        try {\n            dst_addr=msg.getDest(); // could be null in case of mcast\n            if(dst_addr != null)\n                dst_buf=Util.objectToByteBuffer(dst_addr);\n\n            msg_buf=Util.objectToByteBuffer(msg);\n\n            output.writeUTF(groupname);\n\n            if(dst_buf != null && dst_buf.length > 0) {\n                output.writeInt(dst_buf.length);\n                output.write(dst_buf, 0, dst_buf.length);\n            }\n            else\n                output.writeInt(0);\n\n            output.writeInt(msg_buf.length);\n            output.write(msg_buf, 0, msg_buf.length);\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub.send()\", Trace.getStackTrace(e));\n            connected=false;\n            return false;\n        }\n        return true;\n    }","id":44847,"modified_method":"/** Sends a message to the router. Returns false if message cannot be sent (e.g. no connection to\n     router, true otherwise. */\n    public boolean send(Message msg, String groupname) {\n        byte[] msg_buf=null;\n        byte[] dst_buf=null;\n        Object dst_addr=null;\n\n        if(sock == null || output == null || input == null) {\n            Trace.error(\"RouterStub\", \"send(): No connection to router (groupname=\" + groupname + \")\");\n            connected=false;\n            return false;\n        }\n\n        if(msg == null) {\n            Trace.error(\"RouterStub\", \"send(): Message is null\");\n            return false;\n        }\n\n        try {\n            dst_addr=msg.getDest(); // could be null in case of mcast\n            if(dst_addr != null)\n                dst_buf=Util.objectToByteBuffer(dst_addr);\n\n            msg_buf=Util.objectToByteBuffer(msg);\n\n            output.writeUTF(groupname);\n\n            if(dst_buf != null && dst_buf.length > 0) {\n                output.writeInt(dst_buf.length);\n                output.write(dst_buf, 0, dst_buf.length);\n            }\n            else\n                output.writeInt(0);\n\n            output.writeInt(msg_buf.length);\n            output.write(msg_buf, 0, msg_buf.length);\n        }\n        catch(Exception e) {\n            Trace.error(\"RouterStub\", \"send(): \"+Trace.getStackTrace(e));\n            connected=false;\n            return false;\n        }\n        return true;\n    }","commit_id":"38f6babf6dc697845686ccbbb711b3b4ac699469","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n   * Runs the block worker. The thread calling this will be blocked until the thrift server shuts\n   * down.\n   */\n  public void process() {\n    mWorkerMetricsSystem.start();\n\n    // Add the metrics servlet to the web server, this must be done after the metrics system starts\n    mWebServer.addHandler(mWorkerMetricsSystem.getServletHandler());\n\n    mSyncExecutorService.submit(mBlockMasterSync);\n\n    // Start the pinlist syncer to perform the periodical fetching\n    mSyncExecutorService.submit(mPinListSync);\n\n    // Start the session cleanup checker to perform the periodical checking\n    mSyncExecutorService.submit(mSessionCleanerThread);\n\n    // Start the lineage worker\n    if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n      mLineageWorker.start();\n    }\n\n    // Start the space reserver\n    if (mSpaceReserver != null) {\n      mSyncExecutorService.submit(mSpaceReserver);\n    }\n\n    mWebServer.startWebServer();\n    mThriftServer.serve();\n  }","id":44848,"modified_method":"/**\n   * Runs the block worker. The thread calling this will be blocked until the thrift server shuts\n   * down.\n   */\n  public void process() {\n    mWorkerMetricsSystem.start();\n\n    // Add the metrics servlet to the web server, this must be done after the metrics system starts\n    mWebServer.addHandler(mWorkerMetricsSystem.getServletHandler());\n\n    getExecutorService().submit(mBlockMasterSync);\n\n    // Start the pinlist syncer to perform the periodical fetching\n    getExecutorService().submit(mPinListSync);\n\n    // Start the session cleanup checker to perform the periodical checking\n    getExecutorService().submit(mSessionCleanerThread);\n\n    // Start the space reserver\n    if (mSpaceReserver != null) {\n      getExecutorService().submit(mSpaceReserver);\n    }\n\n    mWebServer.startWebServer();\n    mThriftServer.serve();\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Stops the block worker. This method should only be called to terminate the worker.\n   *\n   * @throws IOException if the data server fails to close\n   */\n  public void stop() throws IOException {\n    mDataServer.close();\n    mThriftServer.stop();\n    mThriftServerSocket.close();\n    if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n      mLineageWorker.stop();\n    }\n    mBlockMasterSync.stop();\n    mPinListSync.stop();\n    mSessionCleanerThread.stop();\n    mBlockMasterClient.close();\n    if (mSpaceReserver != null) {\n      mSpaceReserver.stop();\n    }\n    mFileSystemMasterClient.close();\n    mSyncExecutorService.shutdown();\n    mWorkerMetricsSystem.stop();\n    try {\n      mWebServer.shutdownWebServer();\n    } catch (Exception e) {\n      LOG.error(\"Failed to stop web server\", e);\n    }\n    mBlockDataManager.stop();\n    while (!mDataServer.isClosed() || mThriftServer.isServing()) {\n      // The reason to stop and close again is due to some issues in Thrift.\n      mDataServer.close();\n      mThriftServer.stop();\n      mThriftServerSocket.close();\n      CommonUtils.sleepMs(100);\n    }\n  }","id":44849,"modified_method":"/**\n   * Stops the block worker. This method should only be called to terminate the worker.\n   *\n   * @throws IOException if the data server fails to close\n   */\n  public void stop() throws IOException {\n    mDataServer.close();\n    mThriftServer.stop();\n    mThriftServerSocket.close();\n    mBlockMasterSync.stop();\n    mPinListSync.stop();\n    mSessionCleanerThread.stop();\n    mBlockMasterClient.close();\n    if (mSpaceReserver != null) {\n      mSpaceReserver.stop();\n    }\n    mFileSystemMasterClient.close();\n    getExecutorService().shutdown();\n    mWorkerMetricsSystem.stop();\n    try {\n      mWebServer.shutdownWebServer();\n    } catch (Exception e) {\n      LOG.error(\"Failed to stop web server\", e);\n    }\n    mBlockDataManager.stop();\n    while (!mDataServer.isClosed() || mThriftServer.isServing()) {\n      // The reason to stop and close again is due to some issues in Thrift.\n      mDataServer.close();\n      mThriftServer.stop();\n      mThriftServerSocket.close();\n      CommonUtils.sleepMs(100);\n    }\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a Tachyon Block Worker.\n   *\n   * @throws IOException for other exceptions\n   */\n  public BlockWorker() throws IOException {\n    mTachyonConf = WorkerContext.getConf();\n    mStartTimeMs = System.currentTimeMillis();\n\n    // Setup MasterClientBase\n    mBlockMasterClient = new WorkerBlockMasterClient(\n        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, mTachyonConf), mTachyonConf);\n\n    mFileSystemMasterClient = new WorkerFileSystemMasterClient(\n        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, mTachyonConf), mTachyonConf);\n\n    // Set up BlockDataManager\n    WorkerSource workerSource = new WorkerSource();\n    mBlockDataManager =\n        new BlockDataManager(workerSource, mBlockMasterClient, mFileSystemMasterClient,\n            new TieredBlockStore());\n\n    // Setup metrics collection\n    mWorkerMetricsSystem = new MetricsSystem(\"worker\", mTachyonConf);\n    workerSource.registerGauges(mBlockDataManager);\n    mWorkerMetricsSystem.registerSource(workerSource);\n\n    // Set up DataServer\n    mDataServer =\n        DataServer.Factory.createDataServer(\n            NetworkAddressUtils.getBindAddress(ServiceType.WORKER_DATA, mTachyonConf),\n            mBlockDataManager, mTachyonConf);\n    // reset data server port\n    mTachyonConf.set(Constants.WORKER_DATA_PORT, Integer.toString(mDataServer.getPort()));\n\n    // Setup RPC Server\n    mServiceHandler = new BlockServiceHandler(mBlockDataManager);\n    mThriftServerSocket = createThriftServerSocket();\n    mPort = NetworkAddressUtils.getThriftPort(mThriftServerSocket);\n    // reset worker RPC port\n    mTachyonConf.set(Constants.WORKER_PORT, Integer.toString(mPort));\n    mThriftServer = createThriftServer();\n    mWorkerNetAddress =\n        new NetAddress(NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC, mTachyonConf),\n            mPort, mDataServer.getPort());\n    // Get the worker id\n    WorkerIdRegistry.registerWithBlockMaster(mBlockMasterClient, mWorkerNetAddress);\n\n    // Set up web server\n    mWebServer =\n        new WorkerUIWebServer(ServiceType.WORKER_WEB, NetworkAddressUtils.getBindAddress(\n            ServiceType.WORKER_WEB, mTachyonConf), mBlockDataManager,\n            NetworkAddressUtils.getConnectAddress(ServiceType.WORKER_RPC, mTachyonConf),\n            mStartTimeMs, mTachyonConf);\n\n    // Setup Worker to Master Syncer\n    // We create four threads for two syncers, one cleaner and one asynchronous evictor:\n    // mBlockMasterSync, mPinListSync, mSessionCleanerThread, mSpaceReserver\n    mSyncExecutorService =\n        Executors.newFixedThreadPool(4, ThreadFactoryUtils.build(\"worker-heartbeat-%d\", true));\n\n    mBlockMasterSync = new BlockMasterSync(mBlockDataManager, mWorkerNetAddress,\n        mBlockMasterClient);\n\n    // Setup PinListSyncer\n    mPinListSync = new PinListSync(mBlockDataManager, mFileSystemMasterClient);\n\n    // Setup session cleaner\n    mSessionCleanerThread = new SessionCleaner(mBlockDataManager);\n\n    // Setup space reserver\n    if (mTachyonConf.getBoolean(Constants.WORKER_TIERED_STORE_RESERVER_ENABLED)) {\n      mSpaceReserver = new SpaceReserver(mBlockDataManager);\n    }\n\n    // Setup the lineage worker\n    LOG.info(\"Started lineage worker at worker with ID {}\", WorkerIdRegistry.getWorkerId());\n\n    if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n      mLineageWorker = new LineageWorker(mBlockDataManager);\n    }\n  }","id":44850,"modified_method":"/**\n   * Creates a Tachyon Block Worker.\n   *\n   * @throws IOException for other exceptions\n   */\n  public BlockWorker() throws IOException {\n    super(Executors.newFixedThreadPool(4, ThreadFactoryUtils.build(\"worker-heartbeat-%d\", true)));\n    mTachyonConf = WorkerContext.getConf();\n    mStartTimeMs = System.currentTimeMillis();\n\n    // Setup MasterClientBase\n    mBlockMasterClient = new WorkerBlockMasterClient(\n        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, mTachyonConf), mTachyonConf);\n\n    mFileSystemMasterClient = new WorkerFileSystemMasterClient(\n        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, mTachyonConf), mTachyonConf);\n\n    // Set up BlockDataManager\n    WorkerSource workerSource = new WorkerSource();\n    mBlockDataManager =\n        new BlockDataManager(workerSource, mBlockMasterClient, mFileSystemMasterClient,\n            new TieredBlockStore());\n\n    // Setup metrics collection\n    mWorkerMetricsSystem = new MetricsSystem(\"worker\", mTachyonConf);\n    workerSource.registerGauges(mBlockDataManager);\n    mWorkerMetricsSystem.registerSource(workerSource);\n\n    // Set up DataServer\n    mDataServer =\n        DataServer.Factory.createDataServer(\n            NetworkAddressUtils.getBindAddress(ServiceType.WORKER_DATA, mTachyonConf),\n            mBlockDataManager, mTachyonConf);\n    // reset data server port\n    mTachyonConf.set(Constants.WORKER_DATA_PORT, Integer.toString(mDataServer.getPort()));\n\n    // Setup RPC Server\n    mServiceHandler = new BlockServiceHandler(mBlockDataManager);\n    mThriftServerSocket = createThriftServerSocket();\n    mPort = NetworkAddressUtils.getThriftPort(mThriftServerSocket);\n    // reset worker RPC port\n    mTachyonConf.set(Constants.WORKER_PORT, Integer.toString(mPort));\n    mThriftServer = createThriftServer();\n    mWorkerNetAddress =\n        new NetAddress(NetworkAddressUtils.getConnectHost(ServiceType.WORKER_RPC, mTachyonConf),\n            mPort, mDataServer.getPort());\n    // Get the worker id\n    WorkerIdRegistry.registerWithBlockMaster(mBlockMasterClient, mWorkerNetAddress);\n\n    // Set up web server\n    mWebServer =\n        new WorkerUIWebServer(ServiceType.WORKER_WEB, NetworkAddressUtils.getBindAddress(\n            ServiceType.WORKER_WEB, mTachyonConf), mBlockDataManager,\n            NetworkAddressUtils.getConnectAddress(ServiceType.WORKER_RPC, mTachyonConf),\n            mStartTimeMs, mTachyonConf);\n\n    mBlockMasterSync = new BlockMasterSync(mBlockDataManager, mWorkerNetAddress,\n        mBlockMasterClient);\n\n    // Setup PinListSyncer\n    mPinListSync = new PinListSync(mBlockDataManager, mFileSystemMasterClient);\n\n    // Setup session cleaner\n    mSessionCleanerThread = new SessionCleaner(mBlockDataManager);\n\n    // Setup space reserver\n    if (mTachyonConf.getBoolean(Constants.WORKER_TIERED_STORE_RESERVER_ENABLED)) {\n      mSpaceReserver = new SpaceReserver(mBlockDataManager);\n    }\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"public void stop() {\n    if (mFilePersistenceService != null) {\n      mFilePersistenceService.cancel(true);\n    }\n    mLineageMasterWorkerClient.close();\n    mSyncExecutorService.shutdown();\n  }","id":44851,"modified_method":"public void stop() {\n    if (mFilePersistenceService != null) {\n      mFilePersistenceService.cancel(true);\n    }\n    mLineageMasterWorkerClient.close();\n    getExecutorService().shutdown();\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"public LineageWorker(BlockDataManager blockDataManager) {\n    Preconditions.checkState(WorkerIdRegistry.getWorkerId() != 0, \"Failed to register worker\");\n\n    mTachyonConf = WorkerContext.getConf();\n    mLineageDataManager =\n        new LineageDataManager(Preconditions.checkNotNull(blockDataManager));\n\n    // Setup MasterClientBase\n    mLineageMasterWorkerClient = new LineageMasterWorkerClient(\n        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, mTachyonConf), mTachyonConf);\n\n    mSyncExecutorService = Executors.newFixedThreadPool(3,\n        ThreadFactoryUtils.build(\"lineage-worker-heartbeat-%d\", true));\n  }","id":44852,"modified_method":"public LineageWorker(BlockDataManager blockDataManager) throws IOException {\n    super(Executors.newFixedThreadPool(3, ThreadFactoryUtils.build(\"lineage-worker-heartbeat-%d\",\n        true)));\n    Preconditions.checkState(WorkerIdRegistry.getWorkerId() != 0, \"Failed to register worker\");\n\n    mTachyonConf = WorkerContext.getConf();\n    mLineageDataManager =\n        new LineageDataManager(Preconditions.checkNotNull(blockDataManager));\n\n    // Setup MasterClientBase\n    mLineageMasterWorkerClient = new LineageMasterWorkerClient(\n        NetworkAddressUtils.getConnectAddress(ServiceType.MASTER_RPC, mTachyonConf), mTachyonConf);\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"public void start() {\n    mFilePersistenceService =\n        mSyncExecutorService.submit(new HeartbeatThread(HeartbeatContext.WORKER_LINEAGE_SYNC,\n            new LineageWorkerMasterSyncExecutor(mLineageDataManager, mLineageMasterWorkerClient),\n            mTachyonConf.getInt(Constants.WORKER_LINEAGE_HEARTBEAT_INTERVAL_MS)));\n  }","id":44853,"modified_method":"public void start() {\n    mFilePersistenceService =\n        getExecutorService().submit(new HeartbeatThread(HeartbeatContext.WORKER_LINEAGE_SYNC,\n            new LineageWorkerMasterSyncExecutor(mLineageDataManager, mLineageMasterWorkerClient),\n            mTachyonConf.getInt(Constants.WORKER_LINEAGE_HEARTBEAT_INTERVAL_MS)));\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Stop the tachyon filesystem's service thread only.\n   *\n   * @throws Exception when the operation fails\n   */\n  public void stopTFS() throws Exception {\n    LOG.info(\"stop Tachyon filesytstem\");\n\n    // Stopping Worker before stopping master speeds up tests\n    mWorker.stop();\n    mMaster.stop();\n  }","id":44854,"modified_method":"/**\n   * Stop the tachyon filesystem's service thread only.\n   *\n   * @throws Exception when the operation fails\n   */\n  public void stopTFS() throws Exception {\n    LOG.info(\"stop Tachyon filesytstem\");\n\n    // Stopping Worker before stopping master speeds up tests\n    mWorker.stop();\n    if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n      mLineageWorker.stop();\n    }\n    mMaster.stop();\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Cleanup the worker state from the master and stop the worker.\n   *\n   * @throws Exception when the operation fails\n   */\n  public void stopWorker() throws Exception {\n    mMaster.clearClients();\n    mWorker.stop();\n  }","id":44855,"modified_method":"/**\n   * Cleanup the worker state from the master and stop the worker.\n   *\n   * @throws Exception when the operation fails\n   */\n  public void stopWorker() throws Exception {\n    mMaster.clearClients();\n    mWorker.stop();\n    if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n      mLineageWorker.stop();\n    }\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Configure and start worker.\n   *\n   * @throws IOException when the operation fails\n   */\n  private void startWorker(TachyonConf testConf) throws IOException {\n    // We need to update the worker context with the most recent configuration so they know the\n    // correct port to connect to master.\n    mWorkerConf = new TachyonConf(testConf.getInternalProperties());\n    WorkerContext.reset(mWorkerConf);\n\n    mWorker = new BlockWorker();\n    Runnable runWorker = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          mWorker.process();\n        } catch (Exception e) {\n          throw new RuntimeException(e + \" \\n Start Worker Error \\n\" + e.getMessage(), e);\n        }\n      }\n    };\n    mWorkerThread = new Thread(runWorker);\n    mWorkerThread.start();\n  }","id":44856,"modified_method":"/**\n   * Configure and start worker.\n   *\n   * @throws IOException when the operation fails\n   */\n  private void startWorker(TachyonConf testConf) throws IOException {\n    // We need to update the worker context with the most recent configuration so they know the\n    // correct port to connect to master.\n    mWorkerConf = new TachyonConf(testConf.getInternalProperties());\n    WorkerContext.reset(mWorkerConf);\n\n    mWorker = new BlockWorker();\n    if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n      // Setup the lineage worker\n      LOG.info(\"Started lineage worker at worker with ID {}\", WorkerIdRegistry.getWorkerId());\n      mLineageWorker = new LineageWorker(mWorker.getBlockDataManager());\n    }\n\n    Runnable runWorker = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          mWorker.process();\n          // Start the lineage worker\n          if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n            mLineageWorker.start();\n          }\n\n        } catch (Exception e) {\n          throw new RuntimeException(e + \" \\n Start Worker Error \\n\" + e.getMessage(), e);\n        }\n      }\n    };\n    mWorkerThread = new Thread(runWorker);\n    mWorkerThread.start();\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"public void stopTFS() throws Exception {\n    mClientPool.close();\n\n    mWorker.stop();\n    for (int k = 0; k < mNumOfMasters; k ++) {\n      mMasters.get(k).stop();\n    }\n    mCuratorServer.stop();\n  }","id":44857,"modified_method":"public void stopTFS() throws Exception {\n    mClientPool.close();\n\n    mWorker.stop();\n    if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n      mLineageWorker.stop();\n    }\n    for (int k = 0; k < mNumOfMasters; k ++) {\n      mMasters.get(k).stop();\n    }\n    mCuratorServer.stop();\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"public void start() throws IOException {\n    int numLevels = 1;\n    mTachyonHome =\n        File.createTempFile(\"Tachyon\", \"U\" + System.currentTimeMillis()).getAbsolutePath();\n    mWorkerDataFolder = \"/datastore\";\n\n    mHostname = NetworkAddressUtils.getLocalHostName(100);\n\n    mMasterConf = MasterContext.getConf();\n    mMasterConf.set(Constants.IN_TEST_MODE, \"true\");\n    mMasterConf.set(Constants.TACHYON_HOME, mTachyonHome);\n    mMasterConf.set(Constants.ZOOKEEPER_ENABLED, \"true\");\n    mMasterConf.set(Constants.MASTER_HOSTNAME, mHostname);\n    mMasterConf.set(Constants.MASTER_BIND_HOST, mHostname);\n    mMasterConf.set(Constants.MASTER_PORT, \"0\");\n    mMasterConf.set(Constants.MASTER_WEB_BIND_HOST, mHostname);\n    mMasterConf.set(Constants.MASTER_WEB_PORT, \"0\");\n    mMasterConf.set(Constants.ZOOKEEPER_ADDRESS, mCuratorServer.getConnectString());\n    mMasterConf.set(Constants.ZOOKEEPER_ELECTION_PATH, \"/election\");\n    mMasterConf.set(Constants.ZOOKEEPER_LEADER_PATH, \"/leader\");\n    mMasterConf.set(Constants.USER_QUOTA_UNIT_BYTES, \"10000\");\n    mMasterConf.set(Constants.USER_BLOCK_SIZE_BYTES_DEFAULT, Integer.toString(mUserBlockSize));\n    mMasterConf.set(Constants.MASTER_TTLCHECKER_INTERVAL_MS, Integer.toString(1000));\n    // Since tests are always running on a single host keep the resolution timeout low as otherwise\n    // people running with strange network configurations will see very slow tests\n    mMasterConf.set(Constants.NETWORK_HOST_RESOLUTION_TIMEOUT_MS, \"250\");\n\n    // Disable hdfs client caching to avoid file system close() affecting other clients\n    System.setProperty(\"fs.hdfs.impl.disable.cache\", \"true\");\n\n    // re-build the dir to set permission to 777\n    deleteDir(mTachyonHome);\n    mkdir(mTachyonHome);\n\n    for (int k = 0; k < mNumOfMasters; k ++) {\n      final LocalTachyonMaster master = LocalTachyonMaster.create(mTachyonHome);\n      master.start();\n      LOG.info(\"master NO.\" + k + \" started, isServing: \" + master.isServing() + \", address: \"\n          + master.getAddress());\n      mMasters.add(master);\n      // Each master should generate a new port for binding\n      mMasterConf.set(Constants.MASTER_PORT, \"0\");\n    }\n\n    // Create the UFS directory after LocalTachyonMaster construction, because LocalTachyonMaster\n    // sets UNDERFS_ADDRESS.\n    mkdir(mMasterConf.get(Constants.UNDERFS_ADDRESS));\n\n    LOG.info(\"all \" + mNumOfMasters + \" masters started.\");\n    LOG.info(\"waiting for a leader.\");\n    boolean hasLeader = false;\n    while (!hasLeader) {\n      for (int i = 0; i < mMasters.size(); i ++) {\n        if (mMasters.get(i).isServing()) {\n          LOG.info(\"master NO.\" + i + \" is selected as leader. address: \"\n              + mMasters.get(i).getAddress());\n          hasLeader = true;\n          break;\n        }\n      }\n    }\n    // Use first master port\n    mMasterConf.set(Constants.MASTER_PORT, getMasterPort() + \"\");\n\n    CommonUtils.sleepMs(10);\n\n    mWorkerConf = WorkerContext.getConf();\n    mWorkerConf.merge(mMasterConf);\n    mWorkerConf.set(Constants.WORKER_DATA_FOLDER, mWorkerDataFolder);\n    mWorkerConf.set(Constants.WORKER_MEMORY_SIZE, mWorkerCapacityBytes + \"\");\n    mWorkerConf.set(Constants.WORKER_BLOCK_HEARTBEAT_INTERVAL_MS, 15 + \"\");\n\n    // Setup conf for worker\n    mWorkerConf.set(Constants.WORKER_TIERED_STORE_LEVELS, Integer.toString(numLevels));\n    mWorkerConf.set(String.format(Constants.WORKER_TIERED_STORE_LEVEL_ALIAS_FORMAT, 0), \"MEM\");\n    mWorkerConf.set(String.format(Constants.WORKER_TIERED_STORE_LEVEL_DIRS_PATH_FORMAT, 0),\n        mTachyonHome + \"/ramdisk\");\n    mWorkerConf.set(String.format(Constants.WORKER_TIERED_STORE_LEVEL_DIRS_QUOTA_FORMAT, 0),\n        mWorkerCapacityBytes + \"\");\n\n    // Since tests are always running on a single host keep the resolution timeout low as otherwise\n    // people running with strange network configurations will see very slow tests\n    mWorkerConf.set(Constants.NETWORK_HOST_RESOLUTION_TIMEOUT_MS, \"250\");\n\n    for (int level = 1; level < numLevels; level ++) {\n      String tierLevelDirPath =\n          String.format(Constants.WORKER_TIERED_STORE_LEVEL_DIRS_PATH_FORMAT, level);\n      String[] dirPaths = mWorkerConf.get(tierLevelDirPath).split(\",\");\n      String newPath = \"\";\n      for (String dirPath : dirPaths) {\n        newPath += mTachyonHome + dirPath + \",\";\n      }\n      mWorkerConf.set(String.format(Constants.WORKER_TIERED_STORE_LEVEL_DIRS_PATH_FORMAT, level),\n          newPath.substring(0, newPath.length() - 1));\n    }\n\n    mWorkerConf.set(Constants.WORKER_BIND_HOST, mHostname);\n    mWorkerConf.set(Constants.WORKER_PORT, \"0\");\n    mWorkerConf.set(Constants.WORKER_DATA_BIND_HOST, mHostname);\n    mWorkerConf.set(Constants.WORKER_DATA_PORT, \"0\");\n    mWorkerConf.set(Constants.WORKER_WEB_BIND_HOST, mHostname);\n    mWorkerConf.set(Constants.WORKER_WEB_PORT, \"0\");\n    mWorkerConf.set(Constants.WORKER_WORKER_BLOCK_THREADS_MIN, \"1\");\n    mWorkerConf.set(Constants.WORKER_WORKER_BLOCK_THREADS_MAX, \"100\");\n\n    // Perform immediate shutdown of data server. Graceful shutdown is unnecessary and slow\n    mWorkerConf.set(Constants.WORKER_NETWORK_NETTY_SHUTDOWN_QUIET_PERIOD, Integer.toString(0));\n    mWorkerConf.set(Constants.WORKER_NETWORK_NETTY_SHUTDOWN_TIMEOUT, Integer.toString(0));\n\n    mWorker = new BlockWorker();\n    Runnable runWorker = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          mWorker.process();\n        } catch (Exception e) {\n          throw new RuntimeException(e + \" \\n Start Master Error \\n\" + e.getMessage(), e);\n        }\n      }\n    };\n    mWorkerThread = new Thread(runWorker);\n    mWorkerThread.start();\n    // The client context should reflect the updates to the conf.\n    ClientContext.reset(mWorkerConf);\n  }","id":44858,"modified_method":"public void start() throws IOException {\n    int numLevels = 1;\n    mTachyonHome =\n        File.createTempFile(\"Tachyon\", \"U\" + System.currentTimeMillis()).getAbsolutePath();\n    mWorkerDataFolder = \"/datastore\";\n\n    mHostname = NetworkAddressUtils.getLocalHostName(100);\n\n    mMasterConf = MasterContext.getConf();\n    mMasterConf.set(Constants.IN_TEST_MODE, \"true\");\n    mMasterConf.set(Constants.TACHYON_HOME, mTachyonHome);\n    mMasterConf.set(Constants.ZOOKEEPER_ENABLED, \"true\");\n    mMasterConf.set(Constants.MASTER_HOSTNAME, mHostname);\n    mMasterConf.set(Constants.MASTER_BIND_HOST, mHostname);\n    mMasterConf.set(Constants.MASTER_PORT, \"0\");\n    mMasterConf.set(Constants.MASTER_WEB_BIND_HOST, mHostname);\n    mMasterConf.set(Constants.MASTER_WEB_PORT, \"0\");\n    mMasterConf.set(Constants.ZOOKEEPER_ADDRESS, mCuratorServer.getConnectString());\n    mMasterConf.set(Constants.ZOOKEEPER_ELECTION_PATH, \"/election\");\n    mMasterConf.set(Constants.ZOOKEEPER_LEADER_PATH, \"/leader\");\n    mMasterConf.set(Constants.USER_QUOTA_UNIT_BYTES, \"10000\");\n    mMasterConf.set(Constants.USER_BLOCK_SIZE_BYTES_DEFAULT, Integer.toString(mUserBlockSize));\n    mMasterConf.set(Constants.MASTER_TTLCHECKER_INTERVAL_MS, Integer.toString(1000));\n    // Since tests are always running on a single host keep the resolution timeout low as otherwise\n    // people running with strange network configurations will see very slow tests\n    mMasterConf.set(Constants.NETWORK_HOST_RESOLUTION_TIMEOUT_MS, \"250\");\n\n    // Disable hdfs client caching to avoid file system close() affecting other clients\n    System.setProperty(\"fs.hdfs.impl.disable.cache\", \"true\");\n\n    // re-build the dir to set permission to 777\n    deleteDir(mTachyonHome);\n    mkdir(mTachyonHome);\n\n    for (int k = 0; k < mNumOfMasters; k ++) {\n      final LocalTachyonMaster master = LocalTachyonMaster.create(mTachyonHome);\n      master.start();\n      LOG.info(\"master NO.\" + k + \" started, isServing: \" + master.isServing() + \", address: \"\n          + master.getAddress());\n      mMasters.add(master);\n      // Each master should generate a new port for binding\n      mMasterConf.set(Constants.MASTER_PORT, \"0\");\n    }\n\n    // Create the UFS directory after LocalTachyonMaster construction, because LocalTachyonMaster\n    // sets UNDERFS_ADDRESS.\n    mkdir(mMasterConf.get(Constants.UNDERFS_ADDRESS));\n\n    LOG.info(\"all \" + mNumOfMasters + \" masters started.\");\n    LOG.info(\"waiting for a leader.\");\n    boolean hasLeader = false;\n    while (!hasLeader) {\n      for (int i = 0; i < mMasters.size(); i ++) {\n        if (mMasters.get(i).isServing()) {\n          LOG.info(\"master NO.\" + i + \" is selected as leader. address: \"\n              + mMasters.get(i).getAddress());\n          hasLeader = true;\n          break;\n        }\n      }\n    }\n    // Use first master port\n    mMasterConf.set(Constants.MASTER_PORT, getMasterPort() + \"\");\n\n    CommonUtils.sleepMs(10);\n\n    mWorkerConf = WorkerContext.getConf();\n    mWorkerConf.merge(mMasterConf);\n    mWorkerConf.set(Constants.WORKER_DATA_FOLDER, mWorkerDataFolder);\n    mWorkerConf.set(Constants.WORKER_MEMORY_SIZE, mWorkerCapacityBytes + \"\");\n    mWorkerConf.set(Constants.WORKER_BLOCK_HEARTBEAT_INTERVAL_MS, 15 + \"\");\n\n    // Setup conf for worker\n    mWorkerConf.set(Constants.WORKER_TIERED_STORE_LEVELS, Integer.toString(numLevels));\n    mWorkerConf.set(String.format(Constants.WORKER_TIERED_STORE_LEVEL_ALIAS_FORMAT, 0), \"MEM\");\n    mWorkerConf.set(String.format(Constants.WORKER_TIERED_STORE_LEVEL_DIRS_PATH_FORMAT, 0),\n        mTachyonHome + \"/ramdisk\");\n    mWorkerConf.set(String.format(Constants.WORKER_TIERED_STORE_LEVEL_DIRS_QUOTA_FORMAT, 0),\n        mWorkerCapacityBytes + \"\");\n\n    // Since tests are always running on a single host keep the resolution timeout low as otherwise\n    // people running with strange network configurations will see very slow tests\n    mWorkerConf.set(Constants.NETWORK_HOST_RESOLUTION_TIMEOUT_MS, \"250\");\n\n    for (int level = 1; level < numLevels; level ++) {\n      String tierLevelDirPath =\n          String.format(Constants.WORKER_TIERED_STORE_LEVEL_DIRS_PATH_FORMAT, level);\n      String[] dirPaths = mWorkerConf.get(tierLevelDirPath).split(\",\");\n      String newPath = \"\";\n      for (String dirPath : dirPaths) {\n        newPath += mTachyonHome + dirPath + \",\";\n      }\n      mWorkerConf.set(String.format(Constants.WORKER_TIERED_STORE_LEVEL_DIRS_PATH_FORMAT, level),\n          newPath.substring(0, newPath.length() - 1));\n    }\n\n    mWorkerConf.set(Constants.WORKER_BIND_HOST, mHostname);\n    mWorkerConf.set(Constants.WORKER_PORT, \"0\");\n    mWorkerConf.set(Constants.WORKER_DATA_BIND_HOST, mHostname);\n    mWorkerConf.set(Constants.WORKER_DATA_PORT, \"0\");\n    mWorkerConf.set(Constants.WORKER_WEB_BIND_HOST, mHostname);\n    mWorkerConf.set(Constants.WORKER_WEB_PORT, \"0\");\n    mWorkerConf.set(Constants.WORKER_WORKER_BLOCK_THREADS_MIN, \"1\");\n    mWorkerConf.set(Constants.WORKER_WORKER_BLOCK_THREADS_MAX, \"100\");\n\n    // Perform immediate shutdown of data server. Graceful shutdown is unnecessary and slow\n    mWorkerConf.set(Constants.WORKER_NETWORK_NETTY_SHUTDOWN_QUIET_PERIOD, Integer.toString(0));\n    mWorkerConf.set(Constants.WORKER_NETWORK_NETTY_SHUTDOWN_TIMEOUT, Integer.toString(0));\n\n    mWorker = new BlockWorker();\n    if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n      // Setup the lineage worker\n      LOG.info(\"Started lineage worker at worker with ID {}\", WorkerIdRegistry.getWorkerId());\n      mLineageWorker = new LineageWorker(mWorker.getBlockDataManager());\n    }\n    Runnable runWorker = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          mWorker.process();\n          // Start the lineage worker\n          if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n            mLineageWorker.start();\n          }\n        } catch (Exception e) {\n          throw new RuntimeException(e + \" \\n Start Master Error \\n\" + e.getMessage(), e);\n        }\n      }\n    };\n    mWorkerThread = new Thread(runWorker);\n    mWorkerThread.start();\n    // The client context should reflect the updates to the conf.\n    ClientContext.reset(mWorkerConf);\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Main method for Tachyon Worker. A Block Worker will be started and the Tachyon Worker will\n   * continue to run until the Block Worker thread exits.\n   *\n   * @param args command line arguments, should be empty\n   */\n  public static void main(String[] args) {\n    checkArgs(args);\n    BlockWorker worker = null;\n\n    try {\n      worker = new BlockWorker();\n    } catch (Exception e) {\n      LOG.error(\"Failed to initialize the block worker, exiting.\", e);\n      System.exit(-1);\n    }\n\n    try {\n      worker.process();\n    } catch (Exception e) {\n      LOG.error(\"Uncaught exception while running worker, shutting down and exiting.\", e);\n      try {\n        worker.stop();\n      } catch (Exception ex) {\n        LOG.error(\"Failed to stop block worker. Exiting.\", ex);\n      }\n      System.exit(-1);\n    }\n\n    System.exit(0);\n  }","id":44859,"modified_method":"/**\n   * Main method for Tachyon Worker. A Block Worker will be started and the Tachyon Worker will\n   * continue to run until the Block Worker thread exits.\n   *\n   * @param args command line arguments, should be empty\n   */\n  public static void main(String[] args) {\n    checkArgs(args);\n    BlockWorker worker = null;\n    LineageWorker lineageWorker = null;\n\n    try {\n      worker = new BlockWorker();\n      if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n        // Setup the lineage worker\n        LOG.info(\"Started lineage worker at worker with ID {}\", WorkerIdRegistry.getWorkerId());\n        lineageWorker = new LineageWorker(worker.getBlockDataManager());\n      }\n\n    } catch (Exception e) {\n      LOG.error(\"Failed to initialize the block worker, exiting.\", e);\n      System.exit(-1);\n    }\n\n    try {\n      worker.process();\n      // Start the lineage worker\n      if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n        lineageWorker.start();\n      }\n\n    } catch (Exception e) {\n      LOG.error(\"Uncaught exception while running worker, shutting down and exiting.\", e);\n      try {\n        worker.stop();\n        if (LineageUtils.isLineageEnabled(WorkerContext.getConf())) {\n          lineageWorker.stop();\n        }\n      } catch (Exception ex) {\n        LOG.error(\"Failed to stop block worker. Exiting.\", ex);\n      }\n      System.exit(-1);\n    }\n\n    System.exit(0);\n  }","commit_id":"f97e58238a34435e12a1726bd6604505e536a446","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link LineageMaster}.\n   *\n   * @param fileSystemMaster the file system master\n   * @param journal the journal\n   */\n  public LineageMaster(FileSystemMaster fileSystemMaster, Journal journal) {\n    super(journal, new SystemClock(),\n        Executors.newFixedThreadPool(2, ThreadFactoryUtils.build(\"LineageMaster-%d\", true)));\n\n    mFileSystemMaster = Preconditions.checkNotNull(fileSystemMaster);\n    mLineageIdGenerator = new LineageIdGenerator();\n    mLineageStore = new LineageStore(mLineageIdGenerator);\n  }","id":44860,"modified_method":"/**\n   * Creates a new instance of {@link LineageMaster}.\n   *\n   * @param fileSystemMaster the file system master\n   * @param journal the journal\n   */\n  public LineageMaster(FileSystemMaster fileSystemMaster, Journal journal) {\n    this(fileSystemMaster, journal,\n        Executors.newFixedThreadPool(2, ThreadFactoryUtils.build(\"LineageMaster-%d\", true)));\n  }","commit_id":"bce29cfaf3bd64f8c74fd853a8082b0824d9797a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Sets up all dependencies before a test runs.\n   */\n  @Before\n  public void before() throws Exception {\n    Journal journal = new ReadWriteJournal(mTestFolder.newFolder().getAbsolutePath());\n    mFileSystemMaster = Mockito.mock(FileSystemMaster.class);\n    mLineageMaster = new LineageMaster(mFileSystemMaster, journal);\n    mLineageMaster.start(true);\n    mJob = new CommandLineJob(\"test\", new JobConf(\"output\"));\n  }","id":44861,"modified_method":"/**\n   * Sets up all dependencies before a test runs.\n   */\n  @Before\n  public void before() throws Exception {\n    Journal journal = new ReadWriteJournal(mTestFolder.newFolder().getAbsolutePath());\n    mFileSystemMaster = Mockito.mock(FileSystemMaster.class);\n    mExecutorService =\n        Executors.newFixedThreadPool(2, ThreadFactoryUtils.build(\"LineageMasterTest-%d\", true));\n    mLineageMaster = new LineageMaster(mFileSystemMaster, journal, mExecutorService);\n    mLineageMaster.start(true);\n    mJob = new CommandLineJob(\"test\", new JobConf(\"output\"));\n  }","commit_id":"bce29cfaf3bd64f8c74fd853a8082b0824d9797a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests the {@link LineageMaster#stop()} method.\n   */\n  @Test\n  public void stopTest() throws Exception {\n    ExecutorService service =\n        (ExecutorService) Whitebox.getInternalState(mLineageMaster, \"mExecutorService\");\n    Future<?> checkpointThread =\n        (Future<?>) Whitebox.getInternalState(mLineageMaster, \"mCheckpointExecutionService\");\n    Future<?> recomputeThread =\n        (Future<?>) Whitebox.getInternalState(mLineageMaster, \"mRecomputeExecutionService\");\n    Assert.assertFalse(checkpointThread.isDone());\n    Assert.assertFalse(recomputeThread.isDone());\n    Assert.assertFalse(service.isShutdown());\n    mLineageMaster.stop();\n    Assert.assertTrue(checkpointThread.isDone());\n    Assert.assertTrue(recomputeThread.isDone());\n    Assert.assertTrue(service.isShutdown());\n  }","id":44862,"modified_method":"@Test\n  public void stopTest() throws Exception {\n    mLineageMaster.stop();\n    Assert.assertTrue(mExecutorService.isShutdown());\n    Assert.assertTrue(mExecutorService.isTerminated());\n  }","commit_id":"bce29cfaf3bd64f8c74fd853a8082b0824d9797a","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link BlockMaster}.\n   *\n   * @param journal the journal to use for tracking master operations\n   * @param clock the clock to use for determining the time\n   */\n  public BlockMaster(Journal journal, Clock clock, ExecutorService executorService) {\n    super(journal, clock, executorService);\n  }","id":44863,"modified_method":"/**\n   * Creates a new instance of {@link BlockMaster}.\n   *\n   * @param journal the journal to use for tracking master operations\n   * @param clock the clock to use for determining the time\n   * @param executorService the executor service to use for launching maintenance threads\n   */\n  public BlockMaster(Journal journal, Clock clock, ExecutorService executorService) {\n    super(journal, clock, executorService);\n  }","commit_id":"c9a52ed56c8ad53f39c5a30e87e4b919a9cedb33","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Creates a new instance of {@link BlockMaster}.\n   *\n   * @param journal the journal to use for tracking master operations\n   */\n  public BlockMaster(Journal journal) {\n    this(journal, new SystemClock(), Executors.newFixedThreadPool(2,\n        ThreadFactoryUtils.build(\"BlockMaster-%d\", true)));\n  }","id":44864,"modified_method":"/**\n   * Creates a new instance of {@link BlockMaster}.\n   *\n   * @param journal the journal to use for tracking master operations\n   */\n  public BlockMaster(Journal journal) {\n    super(journal, new SystemClock(), Executors.newFixedThreadPool(2,\n        ThreadFactoryUtils.build(\"BlockMaster-%d\", true)));\n  }","commit_id":"c9a52ed56c8ad53f39c5a30e87e4b919a9cedb33","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n     * Creates metrics for given {@link ColumnFamilyStore}.\n     *\n     * @param cfs ColumnFamilyStore to measure metrics\n     */\n    public ColumnFamilyMetrics(final ColumnFamilyStore cfs)\n    {\n        factory = new ColumnFamilyMetricNameFactory(cfs);\n\n        memtableColumnsCount = Metrics.newGauge(factory.createMetricName(\"MemtableColumnsCount\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                return cfs.getDataTracker().getMemtable().getOperations();\n            }\n        });\n        memtableDataSize = Metrics.newGauge(factory.createMetricName(\"MemtableDataSize\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                return cfs.getDataTracker().getMemtable().getLiveSize();\n            }\n        });\n        memtableSwitchCount = Metrics.newCounter(factory.createMetricName(\"MemtableSwitchCount\"));\n        estimatedRowSizeHistogram = Metrics.newGauge(factory.createMetricName(\"EstimatedRowSizeHistogram\"), new Gauge<long[]>()\n        {\n            public long[] value()\n            {\n                long[] histogram = new long[90];\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    long[] rowSize = sstable.getEstimatedRowSize().getBuckets(false);\n                    for (int i = 0; i < histogram.length; i++)\n                        histogram[i] += rowSize[i];\n                }\n                return histogram;\n            }\n        });\n        estimatedColumnCountHistogram = Metrics.newGauge(factory.createMetricName(\"EstimatedColumnCountHistogram\"), new Gauge<long[]>()\n        {\n            public long[] value()\n            {\n                long[] histogram = new long[90];\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    long[] columnSize = sstable.getEstimatedColumnCount().getBuckets(false);\n                    for (int i = 0; i < histogram.length; i++)\n                        histogram[i] += columnSize[i];\n                }\n                return histogram;\n            }\n        });\n        sstablesPerReadHistogram = Metrics.newHistogram(factory.createMetricName(\"SSTablesPerReadHistogram\"), true);\n        compressionRatio = Metrics.newGauge(factory.createMetricName(\"CompressionRatio\"), new Gauge<Double>()\n        {\n            public Double value()\n            {\n                double sum = 0;\n                int total = 0;\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    if (sstable.getCompressionRatio() != SSTableMetadata.NO_COMPRESSION_RATIO)\n                    {\n                        sum += sstable.getCompressionRatio();\n                        total++;\n                    }\n                }\n                return total != 0 ? (double)sum/total: 0;\n            }\n        });\n        readLatency = new LatencyMetrics(factory, \"Read\");\n        writeLatency = new LatencyMetrics(factory, \"Write\");\n        pendingTasks = Metrics.newGauge(factory.createMetricName(\"PendingTasks\"), new Gauge<Integer>()\n        {\n            public Integer value()\n            {\n                // TODO this actually isn't a good measure of pending tasks\n                return Table.switchLock.getQueueLength();\n            }\n        });\n        liveSSTableCount = Metrics.newGauge(factory.createMetricName(\"LiveSSTableCount\"), new Gauge<Integer>()\n        {\n            public Integer value()\n            {\n                return cfs.getDataTracker().getSSTables().size();\n            }\n        });\n        liveDiskSpaceUsed = Metrics.newCounter(factory.createMetricName(\"LiveDiskSpaceUsed\"));\n        totalDiskSpaceUsed = Metrics.newCounter(factory.createMetricName(\"TotalDiskSpaceUsed\"));\n        minRowSize = Metrics.newGauge(factory.createMetricName(\"MinRowSize\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long min = 0;\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    if (min == 0 || sstable.getEstimatedRowSize().min() < min)\n                        min = sstable.getEstimatedRowSize().min();\n                }\n                return min;\n            }\n        });\n        maxRowSize = Metrics.newGauge(factory.createMetricName(\"MaxRowSize\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long max = 0;\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    if (sstable.getEstimatedRowSize().max() > max)\n                        max = sstable.getEstimatedRowSize().max();\n                }\n                return max;\n            }\n        });\n        meanRowSize = Metrics.newGauge(factory.createMetricName(\"MeanRowSize\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long sum = 0;\n                long count = 0;\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    sum += sstable.getEstimatedRowSize().mean();\n                    count++;\n                }\n                return count > 0 ? sum / count : 0;\n            }\n        });\n        bloomFilterFalsePositives = Metrics.newGauge(factory.createMetricName(\"BloomFilterFalsePositives\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long count = 0L;\n                for (SSTableReader sstable: cfs.getSSTables())\n                    count += sstable.getBloomFilterFalsePositiveCount();\n                return count;\n            }\n        });\n        recentBloomFilterFalsePositives = Metrics.newGauge(factory.createMetricName(\"RecentBloomFilterFalsePositives\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long count = 0L;\n                for (SSTableReader sstable: cfs.getSSTables())\n                    count += sstable.getRecentBloomFilterFalsePositiveCount();\n                return count;\n            }\n        });\n        bloomFilterFalseRatio = Metrics.newGauge(factory.createMetricName(\"BloomFilterFalseRatio\"), new Gauge<Double>()\n        {\n            public Double value()\n            {\n                long falseCount = 0L;\n                long trueCount = 0L;\n                for (SSTableReader sstable: cfs.getSSTables())\n                {\n                    falseCount += sstable.getBloomFilterFalsePositiveCount();\n                    trueCount += sstable.getBloomFilterTruePositiveCount();\n                }\n                if (falseCount == 0L && trueCount == 0L)\n                    return 0d;\n                return (double) falseCount / (trueCount + falseCount);\n            }\n        });\n        recentBloomFilterFalseRatio = Metrics.newGauge(factory.createMetricName(\"RecentBloomFilterFalseRatio\"), new Gauge<Double>()\n        {\n            public Double value()\n            {\n                long falseCount = 0L;\n                long trueCount = 0L;\n                for (SSTableReader sstable: cfs.getSSTables())\n                {\n                    falseCount += sstable.getRecentBloomFilterFalsePositiveCount();\n                    trueCount += sstable.getRecentBloomFilterTruePositiveCount();\n                }\n                if (falseCount == 0L && trueCount == 0L)\n                    return 0d;\n                return (double) falseCount / (trueCount + falseCount);\n            }\n        });\n        bloomFilterDiskSpaceUsed = Metrics.newGauge(factory.createMetricName(\"BloomFilterDiskSpaceUsed\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long total = 0;\n                for (SSTableReader sst : cfs.getSSTables())\n                    total += sst.getBloomFilterSerializedSize();\n                return total;\n            }\n        });\n        keyCacheHitRate = Metrics.newGauge(factory.createMetricName(\"KeyCacheHitRate\"), new RatioGauge()\n        {\n            protected double getNumerator()\n            {\n                long hits = 0L;\n                for (SSTableReader sstable : cfs.getSSTables())\n                    hits += sstable.getKeyCacheHit();\n                return hits;\n            }\n\n            protected double getDenominator()\n            {\n                long requests = 0L;\n                for (SSTableReader sstable : cfs.getSSTables())\n                    requests += sstable.getKeyCacheRequest();\n                return Math.max(requests, 1); // to avoid NaN.\n            }\n        });\n        tombstoneScannedHistogram = Metrics.newHistogram(factory.createMetricName(\"TombstoneScannedHistogram\"), true);\n        liveScannedHistogram = Metrics.newHistogram(factory.createMetricName(\"LiveScannedHistogram\"), true);\n    }","id":44865,"modified_method":"/**\n     * Creates metrics for given {@link ColumnFamilyStore}.\n     *\n     * @param cfs ColumnFamilyStore to measure metrics\n     */\n    public ColumnFamilyMetrics(final ColumnFamilyStore cfs)\n    {\n        factory = new ColumnFamilyMetricNameFactory(cfs);\n\n        memtableColumnsCount = Metrics.newGauge(factory.createMetricName(\"MemtableColumnsCount\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                return cfs.getDataTracker().getMemtable().getOperations();\n            }\n        });\n        memtableDataSize = Metrics.newGauge(factory.createMetricName(\"MemtableDataSize\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                return cfs.getDataTracker().getMemtable().getLiveSize();\n            }\n        });\n        memtableSwitchCount = Metrics.newCounter(factory.createMetricName(\"MemtableSwitchCount\"));\n        estimatedRowSizeHistogram = Metrics.newGauge(factory.createMetricName(\"EstimatedRowSizeHistogram\"), new Gauge<long[]>()\n        {\n            public long[] value()\n            {\n                long[] histogram = new long[90];\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    long[] rowSize = sstable.getEstimatedRowSize().getBuckets(false);\n                    for (int i = 0; i < histogram.length; i++)\n                        histogram[i] += rowSize[i];\n                }\n                return histogram;\n            }\n        });\n        estimatedColumnCountHistogram = Metrics.newGauge(factory.createMetricName(\"EstimatedColumnCountHistogram\"), new Gauge<long[]>()\n        {\n            public long[] value()\n            {\n                long[] histogram = new long[90];\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    long[] columnSize = sstable.getEstimatedColumnCount().getBuckets(false);\n                    for (int i = 0; i < histogram.length; i++)\n                        histogram[i] += columnSize[i];\n                }\n                return histogram;\n            }\n        });\n        sstablesPerReadHistogram = Metrics.newHistogram(factory.createMetricName(\"SSTablesPerReadHistogram\"), true);\n        compressionRatio = Metrics.newGauge(factory.createMetricName(\"CompressionRatio\"), new Gauge<Double>()\n        {\n            public Double value()\n            {\n                double sum = 0;\n                int total = 0;\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    if (sstable.getCompressionRatio() != SSTableMetadata.NO_COMPRESSION_RATIO)\n                    {\n                        sum += sstable.getCompressionRatio();\n                        total++;\n                    }\n                }\n                return total != 0 ? (double)sum/total: 0;\n            }\n        });\n        readLatency = new LatencyMetrics(factory, \"Read\");\n        writeLatency = new LatencyMetrics(factory, \"Write\");\n        pendingTasks = Metrics.newGauge(factory.createMetricName(\"PendingTasks\"), new Gauge<Integer>()\n        {\n            public Integer value()\n            {\n                // TODO this actually isn't a good measure of pending tasks\n                return Table.switchLock.getQueueLength();\n            }\n        });\n        liveSSTableCount = Metrics.newGauge(factory.createMetricName(\"LiveSSTableCount\"), new Gauge<Integer>()\n        {\n            public Integer value()\n            {\n                return cfs.getDataTracker().getSSTables().size();\n            }\n        });\n        liveDiskSpaceUsed = Metrics.newCounter(factory.createMetricName(\"LiveDiskSpaceUsed\"));\n        totalDiskSpaceUsed = Metrics.newCounter(factory.createMetricName(\"TotalDiskSpaceUsed\"));\n        minRowSize = Metrics.newGauge(factory.createMetricName(\"MinRowSize\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long min = 0;\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    if (min == 0 || sstable.getEstimatedRowSize().min() < min)\n                        min = sstable.getEstimatedRowSize().min();\n                }\n                return min;\n            }\n        });\n        maxRowSize = Metrics.newGauge(factory.createMetricName(\"MaxRowSize\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long max = 0;\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    if (sstable.getEstimatedRowSize().max() > max)\n                        max = sstable.getEstimatedRowSize().max();\n                }\n                return max;\n            }\n        });\n        meanRowSize = Metrics.newGauge(factory.createMetricName(\"MeanRowSize\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long sum = 0;\n                long count = 0;\n                for (SSTableReader sstable : cfs.getSSTables())\n                {\n                    long n = sstable.getEstimatedRowSize().count();\n                    sum += sstable.getEstimatedRowSize().mean() * n;\n                    count += n;\n                }\n                return count > 0 ? sum / count : 0;\n            }\n        });\n        bloomFilterFalsePositives = Metrics.newGauge(factory.createMetricName(\"BloomFilterFalsePositives\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long count = 0L;\n                for (SSTableReader sstable: cfs.getSSTables())\n                    count += sstable.getBloomFilterFalsePositiveCount();\n                return count;\n            }\n        });\n        recentBloomFilterFalsePositives = Metrics.newGauge(factory.createMetricName(\"RecentBloomFilterFalsePositives\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long count = 0L;\n                for (SSTableReader sstable: cfs.getSSTables())\n                    count += sstable.getRecentBloomFilterFalsePositiveCount();\n                return count;\n            }\n        });\n        bloomFilterFalseRatio = Metrics.newGauge(factory.createMetricName(\"BloomFilterFalseRatio\"), new Gauge<Double>()\n        {\n            public Double value()\n            {\n                long falseCount = 0L;\n                long trueCount = 0L;\n                for (SSTableReader sstable: cfs.getSSTables())\n                {\n                    falseCount += sstable.getBloomFilterFalsePositiveCount();\n                    trueCount += sstable.getBloomFilterTruePositiveCount();\n                }\n                if (falseCount == 0L && trueCount == 0L)\n                    return 0d;\n                return (double) falseCount / (trueCount + falseCount);\n            }\n        });\n        recentBloomFilterFalseRatio = Metrics.newGauge(factory.createMetricName(\"RecentBloomFilterFalseRatio\"), new Gauge<Double>()\n        {\n            public Double value()\n            {\n                long falseCount = 0L;\n                long trueCount = 0L;\n                for (SSTableReader sstable: cfs.getSSTables())\n                {\n                    falseCount += sstable.getRecentBloomFilterFalsePositiveCount();\n                    trueCount += sstable.getRecentBloomFilterTruePositiveCount();\n                }\n                if (falseCount == 0L && trueCount == 0L)\n                    return 0d;\n                return (double) falseCount / (trueCount + falseCount);\n            }\n        });\n        bloomFilterDiskSpaceUsed = Metrics.newGauge(factory.createMetricName(\"BloomFilterDiskSpaceUsed\"), new Gauge<Long>()\n        {\n            public Long value()\n            {\n                long total = 0;\n                for (SSTableReader sst : cfs.getSSTables())\n                    total += sst.getBloomFilterSerializedSize();\n                return total;\n            }\n        });\n        keyCacheHitRate = Metrics.newGauge(factory.createMetricName(\"KeyCacheHitRate\"), new RatioGauge()\n        {\n            protected double getNumerator()\n            {\n                long hits = 0L;\n                for (SSTableReader sstable : cfs.getSSTables())\n                    hits += sstable.getKeyCacheHit();\n                return hits;\n            }\n\n            protected double getDenominator()\n            {\n                long requests = 0L;\n                for (SSTableReader sstable : cfs.getSSTables())\n                    requests += sstable.getKeyCacheRequest();\n                return Math.max(requests, 1); // to avoid NaN.\n            }\n        });\n        tombstoneScannedHistogram = Metrics.newHistogram(factory.createMetricName(\"TombstoneScannedHistogram\"), true);\n        liveScannedHistogram = Metrics.newHistogram(factory.createMetricName(\"LiveScannedHistogram\"), true);\n    }","commit_id":"beefd0b8cc91054a559cdecfe5d972dffb20e0e7","url":"https://github.com/apache/cassandra"},{"original_method":"public int getMeanColumns()\n    {\n        long sum = 0;\n        int count = 0;\n        for (SSTableReader sstable : getSSTables())\n        {\n            sum += sstable.getEstimatedColumnCount().mean();\n            count++;\n        }\n        return count > 0 ? (int) (sum / count) : 0;\n    }","id":44866,"modified_method":"public int getMeanColumns()\n    {\n        long sum = 0;\n        long count = 0;\n        for (SSTableReader sstable : getSSTables())\n        {\n            long n = sstable.getEstimatedColumnCount().count();\n            sum += sstable.getEstimatedColumnCount().mean() * n;\n            count += n;\n        }\n        return count > 0 ? (int) (sum / count) : 0;\n    }","commit_id":"beefd0b8cc91054a559cdecfe5d972dffb20e0e7","url":"https://github.com/apache/cassandra"},{"original_method":"public int getMeanColumns()\n    {\n        long sum = 0;\n        int count = 0;\n        for (SSTableReader sstable : getSSTables())\n        {\n            sum += sstable.getEstimatedColumnCount().mean();\n            count++;\n        }\n        return count > 0 ? (int) (sum / count) : 0;\n    }","id":44867,"modified_method":"public int getMeanColumns()\n    {\n        long sum = 0;\n        long count = 0;\n        for (SSTableReader sstable : getSSTables())\n        {\n            long n = sstable.getEstimatedColumnCount().count();\n            sum += sstable.getEstimatedColumnCount().mean() * n;\n            count += n;\n        }\n        return count > 0 ? (int) (sum / count) : 0;\n    }","commit_id":"5fe0600744cba01d8e238746c0bd363f2059320c","url":"https://github.com/apache/cassandra"},{"original_method":"/**\n     * Signal all waiting threads\n     */\n    public void signalAll()\n    {\n        if (!hasWaiters())\n            return;\n        List<Thread> woke = null;\n        if (logger.isTraceEnabled())\n            woke = new ArrayList<>();\n        long start = System.nanoTime();\n        // we wake up only a snapshot of the queue, to avoid a race where the condition is not met and the woken thread\n        // immediately waits on the queue again\n        RegisteredSignal last = queue.getLast();\n        Iterator<RegisteredSignal> iter = queue.iterator();\n        while (iter.hasNext())\n        {\n            RegisteredSignal signal = iter.next();\n            if (logger.isTraceEnabled())\n            {\n                Thread thread = signal.thread;\n                if (signal.signal())\n                    woke.add(thread);\n            }\n            else\n                signal.signal();\n\n            iter.remove();\n\n            if (signal == last)\n                break;\n        }\n        long end = System.nanoTime();\n        if (woke != null)\n            logger.trace(\"Woke up {} in {}ms from {}\", woke, (end - start) * 0.000001d, Thread.currentThread().getStackTrace()[2]);\n    }","id":44868,"modified_method":"/**\n     * Signal all waiting threads\n     */\n    public void signalAll()\n    {\n        RegisteredSignal last = queue.peekLast();\n        if (last == null)\n            return;\n        List<Thread> woke = null;\n        if (logger.isTraceEnabled())\n            woke = new ArrayList<>();\n        long start = System.nanoTime();\n        // we wake up only a snapshot of the queue, to avoid a race where the condition is not met and the woken thread\n        // immediately waits on the queue again\n        Iterator<RegisteredSignal> iter = queue.iterator();\n        while (iter.hasNext())\n        {\n            RegisteredSignal signal = iter.next();\n            if (logger.isTraceEnabled())\n            {\n                Thread thread = signal.thread;\n                if (signal.signal())\n                    woke.add(thread);\n            }\n            else\n                signal.signal();\n\n            iter.remove();\n\n            if (signal == last)\n                break;\n        }\n        long end = System.nanoTime();\n        if (woke != null)\n            logger.trace(\"Woke up {} in {}ms from {}\", woke, (end - start) * 0.000001d, Thread.currentThread().getStackTrace()[2]);\n    }","commit_id":"5fe0600744cba01d8e238746c0bd363f2059320c","url":"https://github.com/apache/cassandra"},{"original_method":"/** Initialize the ModelBuilder, validating all arguments and preparing the\n   *  training frame.  This call is expected to be overridden in the subclasses\n   *  and each subclass will start with \"super.init();\".  This call is made\n   *  by the front-end whenever the GUI is clicked, and needs to be fast;\n   *  heavy-weight prep needs to wait for the trainModel() call.\n   *\n   *  Validate the learning rate and loss family. */\n  @Override public void init(boolean expensive) {\n    super.init(expensive);\n\n    // Initialize response based on given loss function.\n    // Regression: initially predict the response mean\n    // Binomial: just class 0 (class 1 in the exact inverse prediction)\n    // Multinomial: Class distribution which is not a single value.\n\n    // However there is this weird tension on the initial value for\n    // classification: If you guess 0's (no class is favored over another),\n    // then with your first GBM tree you'll typically move towards the correct\n    // answer a little bit (assuming you have decent predictors) - and\n    // immediately the Confusion Matrix shows good results which gradually\n    // improve... BUT the Means Squared Error will suck for unbalanced sets,\n    // even as the CM is good.  That's because we want the predictions for the\n    // common class to be large and positive, and the rare class to be negative\n    // and instead they start around 0.  Guessing initial zero's means the MSE\n    // is so bad, that the R^2 metric is typically negative (usually it's\n    // between 0 and 1).\n\n    // If instead you guess the mean (reversed through the loss function), then\n    // the zero-tree GBM model reports an MSE equal to the response variance -\n    // and an initial R^2 of zero.  More trees gradually improves the R^2 as\n    // expected.  However, all the minority classes have large guesses in the\n    // wrong direction, and it takes a long time (lotsa trees) to correct that\n    // - so your CM sucks for a long time.\n    double mean = _response.mean();\n    _initialPrediction = _nclass == 1 ? mean\n            : (_nclass==2 ? -0.5*Math.log(mean/(1.0-mean))/*0.0*/ : 0.0/*not a single value*/);\n\n    switch( _parms._loss ) {\n    case AUTO:               // Guess the loss by examining the response column\n      _parms._convert_to_enum = couldBeBool(_response);\n      break; \n    case bernoulli:\n      if( _parms._convert_to_enum && _nclass != 2 && !couldBeBool(_response))\n        error(\"_loss\", \"Bernoulli requires the response to be a 2-class categorical\");\n      else if( _response != null ) {\n        // Bernoulli: initial prediction is log( mean(y)/(1-mean(y)) )\n        _initialPrediction = Math.log(mean / (1.0f - mean));\n      }\n      _parms._convert_to_enum = true;\n      break;\n    case multinomial:  \n      _parms._convert_to_enum = true;   \n      break;\n    case gaussian:     \n      if( _nclass != 1 ) error(\"_loss\",\"Gaussian requires the response to be numeric\");\n      _parms._convert_to_enum = false;  \n      break;\n    default:\n      error(\"_loss\",\"Loss must be specified\");\n    }\n    \n    if( !(0. < _parms._learn_rate && _parms._learn_rate <= 1.0) )\n      error(\"_learn_rate\", \"learn_rate must be between 0 and 1\");\n  }","id":44869,"modified_method":"/** Initialize the ModelBuilder, validating all arguments and preparing the\n   *  training frame.  This call is expected to be overridden in the subclasses\n   *  and each subclass will start with \"super.init();\".  This call is made\n   *  by the front-end whenever the GUI is clicked, and needs to be fast;\n   *  heavy-weight prep needs to wait for the trainModel() call.\n   *\n   *  Validate the learning rate and loss family. */\n  @Override public void init(boolean expensive) {\n    super.init(expensive);\n\n    // Initialize response based on given loss function.\n    // Regression: initially predict the response mean\n    // Binomial: just class 0 (class 1 in the exact inverse prediction)\n    // Multinomial: Class distribution which is not a single value.\n\n    // However there is this weird tension on the initial value for\n    // classification: If you guess 0's (no class is favored over another),\n    // then with your first GBM tree you'll typically move towards the correct\n    // answer a little bit (assuming you have decent predictors) - and\n    // immediately the Confusion Matrix shows good results which gradually\n    // improve... BUT the Means Squared Error will suck for unbalanced sets,\n    // even as the CM is good.  That's because we want the predictions for the\n    // common class to be large and positive, and the rare class to be negative\n    // and instead they start around 0.  Guessing initial zero's means the MSE\n    // is so bad, that the R^2 metric is typically negative (usually it's\n    // between 0 and 1).\n\n    // If instead you guess the mean (reversed through the loss function), then\n    // the zero-tree GBM model reports an MSE equal to the response variance -\n    // and an initial R^2 of zero.  More trees gradually improves the R^2 as\n    // expected.  However, all the minority classes have large guesses in the\n    // wrong direction, and it takes a long time (lotsa trees) to correct that\n    // - so your CM sucks for a long time.\n    double mean = 0;\n    if (expensive) {\n      mean = _response.mean();\n      _initialPrediction = _nclass == 1 ? mean\n              : (_nclass == 2 ? -0.5 * Math.log(mean / (1.0 - mean))/*0.0*/ : 0.0/*not a single value*/);\n    }\n\n    switch( _parms._loss ) {\n    case AUTO:               // Guess the loss by examining the response column\n      _parms._convert_to_enum = couldBeBool(_response);\n      break; \n    case bernoulli:\n      if( _parms._convert_to_enum && _nclass != 2 && !couldBeBool(_response))\n        error(\"_loss\", \"Bernoulli requires the response to be a 2-class categorical\");\n      else if( _response != null ) {\n        // Bernoulli: initial prediction is log( mean(y)/(1-mean(y)) )\n        _initialPrediction = Math.log(mean / (1.0f - mean));\n      }\n      _parms._convert_to_enum = true;\n      break;\n    case multinomial:  \n      _parms._convert_to_enum = true;   \n      break;\n    case gaussian:     \n      if( _nclass != 1 ) error(\"_loss\",\"Gaussian requires the response to be numeric\");\n      _parms._convert_to_enum = false;  \n      break;\n    default:\n      error(\"_loss\",\"Loss must be specified\");\n    }\n    \n    if( !(0. < _parms._learn_rate && _parms._learn_rate <= 1.0) )\n      error(\"_learn_rate\", \"learn_rate must be between 0 and 1\");\n  }","commit_id":"f729fe2461d2bfdada1eec5286616e79d2d356a4","url":"https://github.com/h2oai/h2o-3"},{"original_method":"protected JSONObject getContactsJSONObject(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString redirect = ParamUtil.getString(portletRequest, \"redirect\");\n\n\t\tString filterBy = ParamUtil.getString(portletRequest, \"filterBy\");\n\t\tString keywords = ParamUtil.getString(portletRequest, \"keywords\");\n\t\tint start = ParamUtil.getInteger(portletRequest, \"start\");\n\t\tint end = ParamUtil.getInteger(portletRequest, \"end\");\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tJSONObject optionsJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\toptionsJSONObject.put(\"end\", end);\n\t\toptionsJSONObject.put(\"filterBy\", filterBy);\n\t\toptionsJSONObject.put(\"keywords\", keywords);\n\t\toptionsJSONObject.put(\"start\", start);\n\n\t\tjsonObject.put(\"options\", optionsJSONObject);\n\n\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\tString portletId = portletDisplay.getId();\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tif (filterBy.equals(ContactsConstants.FILTER_BY_DEFAULT) &&\n\t\t\t!portletId.equals(PortletKeys.MEMBERS)) {\n\n\t\t\tList<BaseModel<?>> contacts =\n\t\t\t\tEntryLocalServiceUtil.searchUsersAndContacts(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\tkeywords, start, end);\n\n\t\t\tint contactsCount =\n\t\t\t\tEntryLocalServiceUtil.searchUsersAndContactsCount(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\tkeywords);\n\n\t\t\tjsonObject.put(\"count\", contactsCount);\n\n\t\t\tfor (BaseModel<?> contact : contacts) {\n\t\t\t\tJSONObject contactJSONObject = null;\n\n\t\t\t\tif (contact instanceof User) {\n\t\t\t\t\tcontactJSONObject = getUserJSONObject(\n\t\t\t\t\t\tportletResponse, themeDisplay, (User)contact);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontactJSONObject = getEntryJSONObject(\n\t\t\t\t\t\tportletResponse, themeDisplay, (Entry)contact,\n\t\t\t\t\t\tredirect);\n\t\t\t\t}\n\n\t\t\t\tjsonArray.put(contactJSONObject);\n\t\t\t}\n\t\t}\n\t\telse if (filterBy.equals(\n\t\t\t\t\tContactsConstants.FILTER_BY_FOLLOWERS) &&\n\t\t\t\t !portletId.equals(PortletKeys.MEMBERS)) {\n\n\t\t\tList<SocialRelation> socialRelations =\n\t\t\t\tSocialRelationLocalServiceUtil.getInverseRelations(\n\t\t\t\t\tthemeDisplay.getUserId(),\n\t\t\t\t\tSocialRelationConstants.TYPE_UNI_FOLLOWER, start, end);\n\n\t\t\tfor (SocialRelation socialRelation : socialRelations) {\n\t\t\t\tjsonArray.put(\n\t\t\t\t\tgetUserJSONObject(\n\t\t\t\t\t\tportletResponse, themeDisplay,\n\t\t\t\t\t\tsocialRelation.getUserId1()));\n\t\t\t}\n\t\t}\n\t\telse if (filterBy.equals(\n\t\t\t\t\tContactsConstants.FILTER_BY_TYPE_MY_CONTACTS) &&\n\t\t\t\t !portletId.equals(PortletKeys.MEMBERS)) {\n\n\t\t\tList<Entry> entries = EntryLocalServiceUtil.search(\n\t\t\t\tthemeDisplay.getUserId(), keywords, start, end);\n\n\t\t\tint entriesCount = EntryLocalServiceUtil.searchCount(\n\t\t\t\tthemeDisplay.getUserId(), keywords);\n\n\t\t\tjsonObject.put(\"count\", entriesCount);\n\n\t\t\tfor (Entry entry : entries) {\n\t\t\t\tJSONObject contactJSONObject = getEntryJSONObject(\n\t\t\t\t\tportletResponse, themeDisplay, entry, redirect);\n\n\t\t\t\tjsonArray.put(contactJSONObject);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tLinkedHashMap<String, Object> params = new LinkedHashMap<>();\n\n\t\t\tparams.put(\"inherit\", Boolean.TRUE);\n\n\t\t\tGroup group = themeDisplay.getScopeGroup();\n\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\tif (group.isUser() && layout.isPublicLayout()) {\n\t\t\t\tparams.put(\n\t\t\t\t\t\"socialRelationType\",\n\t\t\t\t\tnew Long[] {\n\t\t\t\t\t\tgroup.getClassPK(),\n\t\t\t\t\t\t(long)SocialRelationConstants.TYPE_BI_CONNECTION\n\t\t\t\t\t});\n\t\t\t}\n\t\t\telse if (filterBy.startsWith(ContactsConstants.FILTER_BY_TYPE)) {\n\t\t\t\tparams.put(\n\t\t\t\t\t\"socialRelationType\",\n\t\t\t\t\tnew Long[] {\n\t\t\t\t\t\tthemeDisplay.getUserId(),\n\t\t\t\t\t\tContactsUtil.getSocialRelationType(filterBy)\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (portletId.equals(PortletKeys.MEMBERS)) {\n\t\t\t\tparams.put(\"usersGroups\", group.getGroupId());\n\t\t\t}\n\t\t\telse if (filterBy.startsWith(ContactsConstants.FILTER_BY_GROUP)) {\n\t\t\t\tparams.put(\"usersGroups\", ContactsUtil.getGroupId(filterBy));\n\t\t\t}\n\n\t\t\tList<User> usersList = null;\n\n\t\t\tif (filterBy.equals(ContactsConstants.FILTER_BY_ADMINS)) {\n\t\t\t\tRole siteAdministratorRole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tgroup.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t\t\tparams.put(\n\t\t\t\t\t\"userGroupRole\",\n\t\t\t\t\tnew Long[] {\n\t\t\t\t\t\tnew Long(group.getGroupId()),\n\t\t\t\t\t\tnew Long(siteAdministratorRole.getRoleId())\n\t\t\t\t\t});\n\n\t\t\t\tSet<User> users = new HashSet<>();\n\n\t\t\t\tusers.addAll(\n\t\t\t\t\tUserLocalServiceUtil.search(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(), keywords,\n\t\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, params,\n\t\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\t\t(OrderByComparator)null));\n\n\t\t\t\tRole siteOwnerRole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tgroup.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t\t\tparams.put(\n\t\t\t\t\t\"userGroupRole\",\n\t\t\t\t\tnew Long[] {\n\t\t\t\t\t\tnew Long(group.getGroupId()),\n\t\t\t\t\t\tnew Long(siteOwnerRole.getRoleId())\n\t\t\t\t\t});\n\n\t\t\t\tusers.addAll(\n\t\t\t\t\tUserLocalServiceUtil.search(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(), keywords,\n\t\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, params,\n\t\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\t\t(OrderByComparator)null));\n\n\t\t\t\tusersList = new ArrayList<>(users);\n\n\t\t\t\tListUtil.sort(usersList, new UserLastNameComparator(true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint usersCount = UserLocalServiceUtil.searchCount(\n\t\t\t\t\tthemeDisplay.getCompanyId(), keywords,\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, params);\n\n\t\t\t\tjsonObject.put(\"count\", usersCount);\n\n\t\t\t\tusersList = UserLocalServiceUtil.search(\n\t\t\t\t\tthemeDisplay.getCompanyId(), keywords,\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, params, start, end,\n\t\t\t\t\tnew UserLastNameComparator(true));\n\t\t\t}\n\n\t\t\tfor (User user : usersList) {\n\t\t\t\tJSONObject userJSONObject = getUserJSONObject(\n\t\t\t\t\tportletResponse, themeDisplay, user);\n\n\t\t\t\tjsonArray.put(userJSONObject);\n\t\t\t}\n\t\t}\n\n\t\tjsonObject.put(\"users\", jsonArray);\n\n\t\treturn jsonObject;\n\t}","id":44870,"modified_method":"protected JSONObject getContactsJSONObject(\n\t\t\tPortletRequest portletRequest, PortletResponse portletResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)portletRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString redirect = ParamUtil.getString(portletRequest, \"redirect\");\n\n\t\tString filterBy = ParamUtil.getString(portletRequest, \"filterBy\");\n\t\tString keywords = ParamUtil.getString(portletRequest, \"keywords\");\n\t\tint start = ParamUtil.getInteger(portletRequest, \"start\");\n\t\tint end = ParamUtil.getInteger(portletRequest, \"end\");\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tJSONObject optionsJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\toptionsJSONObject.put(\"end\", end);\n\t\toptionsJSONObject.put(\"filterBy\", filterBy);\n\t\toptionsJSONObject.put(\"keywords\", keywords);\n\t\toptionsJSONObject.put(\"start\", start);\n\n\t\tjsonObject.put(\"options\", optionsJSONObject);\n\n\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\tString portletId = portletDisplay.getId();\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tif (filterBy.equals(ContactsConstants.FILTER_BY_DEFAULT) &&\n\t\t\t!portletId.equals(PortletKeys.MEMBERS)) {\n\n\t\t\tList<BaseModel<?>> contacts =\n\t\t\t\tEntryLocalServiceUtil.searchUsersAndContacts(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\tkeywords, start, end);\n\n\t\t\tint contactsCount =\n\t\t\t\tEntryLocalServiceUtil.searchUsersAndContactsCount(\n\t\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getUserId(),\n\t\t\t\t\tkeywords);\n\n\t\t\tjsonObject.put(\"count\", contactsCount);\n\n\t\t\tfor (BaseModel<?> contact : contacts) {\n\t\t\t\tJSONObject contactJSONObject = null;\n\n\t\t\t\tif (contact instanceof User) {\n\t\t\t\t\tcontactJSONObject = getUserJSONObject(\n\t\t\t\t\t\tportletResponse, themeDisplay, (User)contact);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcontactJSONObject = getEntryJSONObject(\n\t\t\t\t\t\tportletResponse, themeDisplay, (Entry)contact,\n\t\t\t\t\t\tredirect);\n\t\t\t\t}\n\n\t\t\t\tjsonArray.put(contactJSONObject);\n\t\t\t}\n\t\t}\n\t\telse if (filterBy.equals(\n\t\t\t\t\tContactsConstants.FILTER_BY_FOLLOWERS) &&\n\t\t\t\t !portletId.equals(PortletKeys.MEMBERS)) {\n\n\t\t\tList<SocialRelation> socialRelations =\n\t\t\t\tSocialRelationLocalServiceUtil.getInverseRelations(\n\t\t\t\t\tthemeDisplay.getUserId(),\n\t\t\t\t\tSocialRelationConstants.TYPE_UNI_FOLLOWER, start, end);\n\n\t\t\tfor (SocialRelation socialRelation : socialRelations) {\n\t\t\t\tjsonArray.put(\n\t\t\t\t\tgetUserJSONObject(\n\t\t\t\t\t\tportletResponse, themeDisplay,\n\t\t\t\t\t\tsocialRelation.getUserId1()));\n\t\t\t}\n\t\t}\n\t\telse if (filterBy.equals(\n\t\t\t\t\tContactsConstants.FILTER_BY_TYPE_MY_CONTACTS) &&\n\t\t\t\t !portletId.equals(PortletKeys.MEMBERS)) {\n\n\t\t\tList<Entry> entries = EntryLocalServiceUtil.search(\n\t\t\t\tthemeDisplay.getUserId(), keywords, start, end);\n\n\t\t\tint entriesCount = EntryLocalServiceUtil.searchCount(\n\t\t\t\tthemeDisplay.getUserId(), keywords);\n\n\t\t\tjsonObject.put(\"count\", entriesCount);\n\n\t\t\tfor (Entry entry : entries) {\n\t\t\t\tJSONObject contactJSONObject = getEntryJSONObject(\n\t\t\t\t\tportletResponse, themeDisplay, entry, redirect);\n\n\t\t\t\tjsonArray.put(contactJSONObject);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tLinkedHashMap<String, Object> params = new LinkedHashMap<>();\n\n\t\t\tparams.put(\"inherit\", Boolean.TRUE);\n\n\t\t\tGroup group = themeDisplay.getScopeGroup();\n\t\t\tLayout layout = themeDisplay.getLayout();\n\n\t\t\tif (group.isUser() && layout.isPublicLayout()) {\n\t\t\t\tparams.put(\n\t\t\t\t\t\"socialRelationType\",\n\t\t\t\t\tnew Long[] {\n\t\t\t\t\t\tgroup.getClassPK(),\n\t\t\t\t\t\t(long)SocialRelationConstants.TYPE_BI_CONNECTION\n\t\t\t\t\t});\n\t\t\t}\n\t\t\telse if (filterBy.startsWith(ContactsConstants.FILTER_BY_TYPE)) {\n\t\t\t\tparams.put(\n\t\t\t\t\t\"socialRelationType\",\n\t\t\t\t\tnew Long[] {\n\t\t\t\t\t\tthemeDisplay.getUserId(),\n\t\t\t\t\t\tContactsUtil.getSocialRelationType(filterBy)\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (portletId.equals(PortletKeys.MEMBERS)) {\n\t\t\t\tparams.put(\"usersGroups\", group.getGroupId());\n\t\t\t}\n\t\t\telse if (filterBy.startsWith(ContactsConstants.FILTER_BY_GROUP)) {\n\t\t\t\tparams.put(\"usersGroups\", ContactsUtil.getGroupId(filterBy));\n\t\t\t}\n\n\t\t\tList<User> usersList = null;\n\n\t\t\tif (filterBy.equals(ContactsConstants.FILTER_BY_ADMINS)) {\n\t\t\t\tRole siteAdministratorRole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tgroup.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t\t\tparams.put(\n\t\t\t\t\t\"userGroupRole\",\n\t\t\t\t\tnew Long[] {\n\t\t\t\t\t\tgroup.getGroupId(), siteAdministratorRole.getRoleId()\n\t\t\t\t\t});\n\n\t\t\t\tSet<User> users = new HashSet<>();\n\n\t\t\t\tusers.addAll(\n\t\t\t\t\tUserLocalServiceUtil.search(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(), keywords,\n\t\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, params,\n\t\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\t\t(OrderByComparator)null));\n\n\t\t\t\tRole siteOwnerRole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tgroup.getCompanyId(), RoleConstants.SITE_OWNER);\n\n\t\t\t\tparams.put(\n\t\t\t\t\t\"userGroupRole\",\n\t\t\t\t\tnew Long[] {\n\t\t\t\t\t\tgroup.getGroupId(), siteOwnerRole.getRoleId()\n\t\t\t\t\t});\n\n\t\t\t\tusers.addAll(\n\t\t\t\t\tUserLocalServiceUtil.search(\n\t\t\t\t\t\tthemeDisplay.getCompanyId(), keywords,\n\t\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, params,\n\t\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\t\t(OrderByComparator)null));\n\n\t\t\t\tusersList = new ArrayList<>(users);\n\n\t\t\t\tListUtil.sort(usersList, new UserLastNameComparator(true));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint usersCount = UserLocalServiceUtil.searchCount(\n\t\t\t\t\tthemeDisplay.getCompanyId(), keywords,\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, params);\n\n\t\t\t\tjsonObject.put(\"count\", usersCount);\n\n\t\t\t\tusersList = UserLocalServiceUtil.search(\n\t\t\t\t\tthemeDisplay.getCompanyId(), keywords,\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, params, start, end,\n\t\t\t\t\tnew UserLastNameComparator(true));\n\t\t\t}\n\n\t\t\tfor (User user : usersList) {\n\t\t\t\tJSONObject userJSONObject = getUserJSONObject(\n\t\t\t\t\tportletResponse, themeDisplay, user);\n\n\t\t\t\tjsonArray.put(userJSONObject);\n\t\t\t}\n\t\t}\n\n\t\tjsonObject.put(\"users\", jsonArray);\n\n\t\treturn jsonObject;\n\t}","commit_id":"1298c7ea9a9495013b48c905e5a16b12a8d33bc3","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static void deleteFoodItem(long foodItemId) throws Exception {\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = HibernateUtil.openSession();\n\n\t\t\tsession.beginTransaction();\n\n\t\t\tFoodItem foodItem = (FoodItem)session.get(\n\t\t\t\tFoodItem.class, new Long(foodItemId));\n\n\t\t\tif (foodItem != null) {\n\t\t\t\tsession.delete(foodItem);\n\n\t\t\t\tsession.flush();\n\t\t\t}\n\n\t\t\tsession.getTransaction().commit();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new Exception(e);\n\t\t}\n\t\tfinally {\n\t\t\tHibernateUtil.closeSession(session);\n\t\t}\n\t}","id":44871,"modified_method":"public static void deleteFoodItem(long foodItemId) throws Exception {\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = HibernateUtil.openSession();\n\n\t\t\tsession.beginTransaction();\n\n\t\t\tFoodItem foodItem = (FoodItem)session.get(\n\t\t\t\tFoodItem.class, Long.valueOf(foodItemId));\n\n\t\t\tif (foodItem != null) {\n\t\t\t\tsession.delete(foodItem);\n\n\t\t\t\tsession.flush();\n\t\t\t}\n\n\t\t\tsession.getTransaction().commit();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new Exception(e);\n\t\t}\n\t\tfinally {\n\t\t\tHibernateUtil.closeSession(session);\n\t\t}\n\t}","commit_id":"b7015d1c668816c6e3529f4f95cae61c69e32c12","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static FoodItem getFoodItem(long foodItemId) throws Exception {\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = HibernateUtil.openSession();\n\n\t\t\tsession.beginTransaction();\n\n\t\t\tFoodItem foodItem = (FoodItem)session.get(\n\t\t\t\tFoodItem.class, new Long(foodItemId));\n\n\t\t\tsession.getTransaction().commit();\n\n\t\t\treturn foodItem;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new Exception(e);\n\t\t}\n\t\tfinally {\n\t\t\tHibernateUtil.closeSession(session);\n\t\t}\n\t}","id":44872,"modified_method":"public static FoodItem getFoodItem(long foodItemId) throws Exception {\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = HibernateUtil.openSession();\n\n\t\t\tsession.beginTransaction();\n\n\t\t\tFoodItem foodItem = (FoodItem)session.get(\n\t\t\t\tFoodItem.class, Long.valueOf(foodItemId));\n\n\t\t\tsession.getTransaction().commit();\n\n\t\t\treturn foodItem;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new Exception(e);\n\t\t}\n\t\tfinally {\n\t\t\tHibernateUtil.closeSession(session);\n\t\t}\n\t}","commit_id":"b7015d1c668816c6e3529f4f95cae61c69e32c12","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\t\tpublic Serializable call() throws ProcessException {\n\t\t\ttry {\n\t\t\t\tif (_oldFriendlyURL.equals(_group.getFriendlyURL())) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (!GoogleMailGroupsUtil.isSync(_group)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tGoogleDirectoryUtil.deleteGroup(_oldGroupEmailAddress);\n\n\t\t\t\tString groupEmailAddress =\n\t\t\t\t\tGoogleMailGroupsUtil.getGroupEmailAddress(_group);\n\n\t\t\t\tGoogleDirectoryUtil.addGroup(\n\t\t\t\t\t_group.getDescriptiveName(), groupEmailAddress);\n\n\t\t\t\tLinkedHashMap<String, Object> userParams =\n\t\t\t\t\tnew LinkedHashMap<>();\n\n\t\t\t\tuserParams.put(\"inherit\", Boolean.TRUE);\n\t\t\t\tuserParams.put(\"usersGroups\", new Long(_group.getGroupId()));\n\n\t\t\t\tList<User> users = UserLocalServiceUtil.search(\n\t\t\t\t\t_group.getCompanyId(), null,\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, userParams,\n\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\t(OrderByComparator)null);\n\n\t\t\t\tfor (User user : users) {\n\t\t\t\t\tGoogleDirectoryUtil.addGroupMember(\n\t\t\t\t\t\tgroupEmailAddress,\n\t\t\t\t\t\tGoogleMailGroupsUtil.getUserEmailAddress(user));\n\t\t\t\t}\n\n\t\t\t\tGoogleMailGroupsUtil.checkLargeGroup(_group);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new ProcessException(e);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}","id":44873,"modified_method":"@Override\n\t\tpublic Serializable call() throws ProcessException {\n\t\t\ttry {\n\t\t\t\tif (_oldFriendlyURL.equals(_group.getFriendlyURL())) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (!GoogleMailGroupsUtil.isSync(_group)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tGoogleDirectoryUtil.deleteGroup(_oldGroupEmailAddress);\n\n\t\t\t\tString groupEmailAddress =\n\t\t\t\t\tGoogleMailGroupsUtil.getGroupEmailAddress(_group);\n\n\t\t\t\tGoogleDirectoryUtil.addGroup(\n\t\t\t\t\t_group.getDescriptiveName(), groupEmailAddress);\n\n\t\t\t\tLinkedHashMap<String, Object> userParams =\n\t\t\t\t\tnew LinkedHashMap<>();\n\n\t\t\t\tuserParams.put(\"inherit\", Boolean.TRUE);\n\t\t\t\tuserParams.put(\n\t\t\t\t\t\"usersGroups\", Long.valueOf(_group.getGroupId()));\n\n\t\t\t\tList<User> users = UserLocalServiceUtil.search(\n\t\t\t\t\t_group.getCompanyId(), null,\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, userParams,\n\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\t(OrderByComparator)null);\n\n\t\t\t\tfor (User user : users) {\n\t\t\t\t\tGoogleDirectoryUtil.addGroupMember(\n\t\t\t\t\t\tgroupEmailAddress,\n\t\t\t\t\t\tGoogleMailGroupsUtil.getUserEmailAddress(user));\n\t\t\t\t}\n\n\t\t\t\tGoogleMailGroupsUtil.checkLargeGroup(_group);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new ProcessException(e);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}","commit_id":"b7015d1c668816c6e3529f4f95cae61c69e32c12","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static void syncGroups() throws Exception {\n\t\tActionableDynamicQuery actionableDynamicQuery =\n\t\t\tnew GroupActionableDynamicQuery() {\n\n\t\t\t@Override\n\t\t\tprotected void performAction(Object object) throws PortalException {\n\t\t\t\tGroup group = (Group)object;\n\n\t\t\t\tif (!isSync(group)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tList<String> groupMemberEmailAddresses = new ArrayList<>();\n\t\t\t\tMembers members = null;\n\n\t\t\t\tString groupEmailAddress = getGroupEmailAddress(group);\n\n\t\t\t\tif (GoogleDirectoryUtil.getGroup(groupEmailAddress) == null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tGoogleDirectoryUtil.addGroup(\n\t\t\t\t\t\t\tgroup.getDescriptiveName(), groupEmailAddress);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"Unable to add Google group for \" +\n\t\t\t\t\t\t\t\tgroup.getDescriptiveName(),\n\t\t\t\t\t\t\te);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmembers = GoogleDirectoryUtil.getGroupMembers(\n\t\t\t\t\t\tgroupEmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif ((members != null) && (members.getMembers() != null)) {\n\t\t\t\t\tfor (Member member : members.getMembers()) {\n\t\t\t\t\t\tgroupMemberEmailAddresses.add(member.getEmail());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tList<String> emailAddresses = new ArrayList<>();\n\n\t\t\t\tLinkedHashMap<String, Object> userParams =\n\t\t\t\t\tnew LinkedHashMap<>();\n\n\t\t\t\tuserParams.put(\"inherit\", Boolean.TRUE);\n\t\t\t\tuserParams.put(\"usersGroups\", new Long(group.getGroupId()));\n\n\t\t\t\tList<User> users = UserLocalServiceUtil.search(\n\t\t\t\t\tgroup.getCompanyId(), null,\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, userParams,\n\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\t(OrderByComparator)null);\n\n\t\t\t\tfor (User user : users) {\n\t\t\t\t\temailAddresses.add(getUserEmailAddress(user));\n\t\t\t\t}\n\n\t\t\t\tfor (String groupMemberEmailAddress :\n\t\t\t\t\t\tgroupMemberEmailAddresses) {\n\n\t\t\t\t\tif (emailAddresses.contains(groupMemberEmailAddress)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tGoogleDirectoryUtil.deleteGroupMember(\n\t\t\t\t\t\t\tgroupEmailAddress, groupMemberEmailAddress);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\t\t\tsb.append(\"Unable to delete \");\n\t\t\t\t\t\tsb.append(groupMemberEmailAddress);\n\t\t\t\t\t\tsb.append(\" from Google group \");\n\t\t\t\t\t\tsb.append(groupEmailAddress);\n\n\t\t\t\t\t\t_log.error(sb.toString(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (String emailAddress : emailAddresses) {\n\t\t\t\t\tif (groupMemberEmailAddresses.contains(emailAddress)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tGoogleDirectoryUtil.addGroupMember(\n\t\t\t\t\t\t\tgroupEmailAddress, emailAddress);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\t\t\tsb.append(\"Unable to add \");\n\t\t\t\t\t\tsb.append(emailAddress);\n\t\t\t\t\t\tsb.append(\" to Google group \");\n\t\t\t\t\t\tsb.append(groupEmailAddress);\n\n\t\t\t\t\t\t_log.error(sb.toString(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcheckLargeGroup(group);\n\t\t\t}\n\t\t};\n\n\t\tactionableDynamicQuery.performActions();\n\t}","id":44874,"modified_method":"public static void syncGroups() throws Exception {\n\t\tActionableDynamicQuery actionableDynamicQuery =\n\t\t\tnew GroupActionableDynamicQuery() {\n\n\t\t\t@Override\n\t\t\tprotected void performAction(Object object) throws PortalException {\n\t\t\t\tGroup group = (Group)object;\n\n\t\t\t\tif (!isSync(group)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tList<String> groupMemberEmailAddresses = new ArrayList<>();\n\t\t\t\tMembers members = null;\n\n\t\t\t\tString groupEmailAddress = getGroupEmailAddress(group);\n\n\t\t\t\tif (GoogleDirectoryUtil.getGroup(groupEmailAddress) == null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tGoogleDirectoryUtil.addGroup(\n\t\t\t\t\t\t\tgroup.getDescriptiveName(), groupEmailAddress);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"Unable to add Google group for \" +\n\t\t\t\t\t\t\t\tgroup.getDescriptiveName(),\n\t\t\t\t\t\t\te);\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmembers = GoogleDirectoryUtil.getGroupMembers(\n\t\t\t\t\t\tgroupEmailAddress);\n\t\t\t\t}\n\n\t\t\t\tif ((members != null) && (members.getMembers() != null)) {\n\t\t\t\t\tfor (Member member : members.getMembers()) {\n\t\t\t\t\t\tgroupMemberEmailAddresses.add(member.getEmail());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tList<String> emailAddresses = new ArrayList<>();\n\n\t\t\t\tLinkedHashMap<String, Object> userParams =\n\t\t\t\t\tnew LinkedHashMap<>();\n\n\t\t\t\tuserParams.put(\"inherit\", Boolean.TRUE);\n\t\t\t\tuserParams.put(\"usersGroups\", Long.valueOf(group.getGroupId()));\n\n\t\t\t\tList<User> users = UserLocalServiceUtil.search(\n\t\t\t\t\tgroup.getCompanyId(), null,\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, userParams,\n\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\t(OrderByComparator)null);\n\n\t\t\t\tfor (User user : users) {\n\t\t\t\t\temailAddresses.add(getUserEmailAddress(user));\n\t\t\t\t}\n\n\t\t\t\tfor (String groupMemberEmailAddress :\n\t\t\t\t\t\tgroupMemberEmailAddresses) {\n\n\t\t\t\t\tif (emailAddresses.contains(groupMemberEmailAddress)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tGoogleDirectoryUtil.deleteGroupMember(\n\t\t\t\t\t\t\tgroupEmailAddress, groupMemberEmailAddress);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\t\t\tsb.append(\"Unable to delete \");\n\t\t\t\t\t\tsb.append(groupMemberEmailAddress);\n\t\t\t\t\t\tsb.append(\" from Google group \");\n\t\t\t\t\t\tsb.append(groupEmailAddress);\n\n\t\t\t\t\t\t_log.error(sb.toString(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (String emailAddress : emailAddresses) {\n\t\t\t\t\tif (groupMemberEmailAddresses.contains(emailAddress)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tGoogleDirectoryUtil.addGroupMember(\n\t\t\t\t\t\t\tgroupEmailAddress, emailAddress);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\t\t\tsb.append(\"Unable to add \");\n\t\t\t\t\t\tsb.append(emailAddress);\n\t\t\t\t\t\tsb.append(\" to Google group \");\n\t\t\t\t\t\tsb.append(groupEmailAddress);\n\n\t\t\t\t\t\t_log.error(sb.toString(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcheckLargeGroup(group);\n\t\t\t}\n\t\t};\n\n\t\tactionableDynamicQuery.performActions();\n\t}","commit_id":"b7015d1c668816c6e3529f4f95cae61c69e32c12","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic Object getNewValue(Object oldValue) throws Exception {\n\t\tLong resourcePrimKey = (Long)_resourcePrimKeyColumn.getOldValue();\n\n\t\tKBArticle kbArticle = KBArticleLocalServiceUtil.getLatestKBArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\twhile (!kbArticle.isRoot()) {\n\t\t\tkbArticle = KBArticleLocalServiceUtil.getLatestKBArticle(\n\t\t\t\tkbArticle.getParentResourcePrimKey(),\n\t\t\t\tWorkflowConstants.STATUS_ANY);\n\t\t}\n\n\t\treturn new Long(kbArticle.getResourcePrimKey());\n\t}","id":44875,"modified_method":"@Override\n\tpublic Object getNewValue(Object oldValue) throws Exception {\n\t\tLong resourcePrimKey = (Long)_resourcePrimKeyColumn.getOldValue();\n\n\t\tKBArticle kbArticle = KBArticleLocalServiceUtil.getLatestKBArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\twhile (!kbArticle.isRoot()) {\n\t\t\tkbArticle = KBArticleLocalServiceUtil.getLatestKBArticle(\n\t\t\t\tkbArticle.getParentResourcePrimKey(),\n\t\t\t\tWorkflowConstants.STATUS_ANY);\n\t\t}\n\n\t\treturn Long.valueOf(kbArticle.getResourcePrimKey());\n\t}","commit_id":"b7015d1c668816c6e3529f4f95cae61c69e32c12","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected Person getUserPerson(\n\t\t\tUser user, Set<String> fields, SecurityToken securityToken)\n\t\tthrows Exception {\n\n\t\tName name = new NameImpl(user.getFullName());\n\n\t\tPerson person = new PersonImpl(\n\t\t\tString.valueOf(user.getUserId()), user.getScreenName(), name);\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(securityToken.getDomain());\n\t\tsb.append(PortalUtil.getPathFriendlyURLPublic());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(user.getScreenName());\n\n\t\tperson.setProfileUrl(sb.toString());\n\n\t\tsb.setIndex(0);\n\n\t\tsb.append(securityToken.getDomain());\n\t\tsb.append(PortalUtil.getPathImage());\n\t\tsb.append(\"/user_\");\n\t\tsb.append(user.isFemale() ? \"female\" : \"male\");\n\t\tsb.append(\"_portrait?img_id=\");\n\t\tsb.append(user.getPortraitId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(WebServerServletTokenUtil.getToken(user.getPortraitId()));\n\n\t\tperson.setThumbnailUrl(sb.toString());\n\n\t\tif (fields.contains(Person.Field.ABOUT_ME.toString())) {\n\t\t\tperson.setAboutMe(user.getComments());\n\t\t}\n\n\t\tif (fields.contains(Person.Field.AGE.toString())) {\n\t\t\tCalendar birthday = new GregorianCalendar();\n\n\t\t\tbirthday.setTime(user.getBirthday());\n\n\t\t\tCalendar today = Calendar.getInstance();\n\n\t\t\tint age = today.get(Calendar.YEAR) - birthday.get(Calendar.YEAR);\n\n\t\t\tbirthday.add(Calendar.YEAR, age);\n\n\t\t\tif (today.before(birthday)) {\n\t\t\t\tage--;\n\t\t\t}\n\n\t\t\tperson.setAge(age);\n\t\t}\n\n\t\tif (fields.contains(Person.Field.BIRTHDAY.toString())) {\n\t\t\tperson.setBirthday(user.getBirthday());\n\t\t}\n\n\t\tif (fields.contains(Person.Field.EMAILS)) {\n\t\t\tperson.setEmails(getEmails(user));\n\t\t}\n\n\t\tif (fields.contains(Person.Field.GENDER.toString())) {\n\t\t\tif (user.isFemale()) {\n\t\t\t\tperson.setGender(Gender.female);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tperson.setGender(Gender.male);\n\t\t\t}\n\t\t}\n\n\t\tif (fields.contains(Person.Field.NICKNAME.toString())) {\n\t\t\tperson.setNickname(user.getScreenName());\n\t\t}\n\n\t\tif (fields.contains(Person.Field.PHONE_NUMBERS.toString())) {\n\t\t\tList<ListField> phoneNumbers = getPhoneNumbers(\n\t\t\t\tContact.class.getName(), user.getContactId());\n\n\t\t\tperson.setPhoneNumbers(phoneNumbers);\n\t\t}\n\n\t\tif (fields.contains(Person.Field.UTC_OFFSET.toString())) {\n\t\t\tperson.setUtcOffset(new Long(user.getTimeZone().getRawOffset()));\n\t\t}\n\n\t\tif (securityToken.getOwnerId().equals(person.getId())) {\n\t\t\tperson.setIsOwner(true);\n\t\t}\n\n\t\tif (securityToken.getViewerId().equals(person.getId())) {\n\t\t\tperson.setIsViewer(true);\n\t\t}\n\n\t\treturn person;\n\t}","id":44876,"modified_method":"protected Person getUserPerson(\n\t\t\tUser user, Set<String> fields, SecurityToken securityToken)\n\t\tthrows Exception {\n\n\t\tName name = new NameImpl(user.getFullName());\n\n\t\tPerson person = new PersonImpl(\n\t\t\tString.valueOf(user.getUserId()), user.getScreenName(), name);\n\n\t\tStringBundler sb = new StringBundler(4);\n\n\t\tsb.append(securityToken.getDomain());\n\t\tsb.append(PortalUtil.getPathFriendlyURLPublic());\n\t\tsb.append(StringPool.SLASH);\n\t\tsb.append(user.getScreenName());\n\n\t\tperson.setProfileUrl(sb.toString());\n\n\t\tsb.setIndex(0);\n\n\t\tsb.append(securityToken.getDomain());\n\t\tsb.append(PortalUtil.getPathImage());\n\t\tsb.append(\"/user_\");\n\t\tsb.append(user.isFemale() ? \"female\" : \"male\");\n\t\tsb.append(\"_portrait?img_id=\");\n\t\tsb.append(user.getPortraitId());\n\t\tsb.append(\"&t=\");\n\t\tsb.append(WebServerServletTokenUtil.getToken(user.getPortraitId()));\n\n\t\tperson.setThumbnailUrl(sb.toString());\n\n\t\tif (fields.contains(Person.Field.ABOUT_ME.toString())) {\n\t\t\tperson.setAboutMe(user.getComments());\n\t\t}\n\n\t\tif (fields.contains(Person.Field.AGE.toString())) {\n\t\t\tCalendar birthday = new GregorianCalendar();\n\n\t\t\tbirthday.setTime(user.getBirthday());\n\n\t\t\tCalendar today = Calendar.getInstance();\n\n\t\t\tint age = today.get(Calendar.YEAR) - birthday.get(Calendar.YEAR);\n\n\t\t\tbirthday.add(Calendar.YEAR, age);\n\n\t\t\tif (today.before(birthday)) {\n\t\t\t\tage--;\n\t\t\t}\n\n\t\t\tperson.setAge(age);\n\t\t}\n\n\t\tif (fields.contains(Person.Field.BIRTHDAY.toString())) {\n\t\t\tperson.setBirthday(user.getBirthday());\n\t\t}\n\n\t\tif (fields.contains(Person.Field.EMAILS)) {\n\t\t\tperson.setEmails(getEmails(user));\n\t\t}\n\n\t\tif (fields.contains(Person.Field.GENDER.toString())) {\n\t\t\tif (user.isFemale()) {\n\t\t\t\tperson.setGender(Gender.female);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tperson.setGender(Gender.male);\n\t\t\t}\n\t\t}\n\n\t\tif (fields.contains(Person.Field.NICKNAME.toString())) {\n\t\t\tperson.setNickname(user.getScreenName());\n\t\t}\n\n\t\tif (fields.contains(Person.Field.PHONE_NUMBERS.toString())) {\n\t\t\tList<ListField> phoneNumbers = getPhoneNumbers(\n\t\t\t\tContact.class.getName(), user.getContactId());\n\n\t\t\tperson.setPhoneNumbers(phoneNumbers);\n\t\t}\n\n\t\tif (fields.contains(Person.Field.UTC_OFFSET.toString())) {\n\t\t\tperson.setUtcOffset(\n\t\t\t\tLong.valueOf(user.getTimeZone().getRawOffset()));\n\t\t}\n\n\t\tif (securityToken.getOwnerId().equals(person.getId())) {\n\t\t\tperson.setIsOwner(true);\n\t\t}\n\n\t\tif (securityToken.getViewerId().equals(person.getId())) {\n\t\t\tperson.setIsViewer(true);\n\t\t}\n\n\t\treturn person;\n\t}","commit_id":"b7015d1c668816c6e3529f4f95cae61c69e32c12","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Message getRemoteMessage(long folderId, boolean oldest)\n\t\tthrows PortalException {\n\n\t\tDynamicQuery dynamicQuery = DynamicQueryFactoryUtil.forClass(\n\t\t\tMessage.class, getClassLoader());\n\n\t\tdynamicQuery.add(RestrictionsFactoryUtil.eq(\"folderId\", folderId));\n\t\tdynamicQuery.add(\n\t\t\tRestrictionsFactoryUtil.gt(\"remoteMessageId\", new Long(0)));\n\n\t\tif (oldest) {\n\t\t\tdynamicQuery.addOrder(OrderFactoryUtil.asc(\"remoteMessageId\"));\n\t\t}\n\t\telse {\n\t\t\tdynamicQuery.addOrder(OrderFactoryUtil.desc(\"remoteMessageId\"));\n\t\t}\n\n\t\tList<Message> messages = messagePersistence.findWithDynamicQuery(\n\t\t\tdynamicQuery, 0, 1);\n\n\t\tif (messages.isEmpty()) {\n\t\t\tthrow new NoSuchMessageException();\n\t\t}\n\n\t\treturn messages.get(0);\n\t}","id":44877,"modified_method":"public Message getRemoteMessage(long folderId, boolean oldest)\n\t\tthrows PortalException {\n\n\t\tDynamicQuery dynamicQuery = DynamicQueryFactoryUtil.forClass(\n\t\t\tMessage.class, getClassLoader());\n\n\t\tdynamicQuery.add(RestrictionsFactoryUtil.eq(\"folderId\", folderId));\n\t\tdynamicQuery.add(\n\t\t\tRestrictionsFactoryUtil.gt(\"remoteMessageId\", Long.valueOf(0)));\n\n\t\tif (oldest) {\n\t\t\tdynamicQuery.addOrder(OrderFactoryUtil.asc(\"remoteMessageId\"));\n\t\t}\n\t\telse {\n\t\t\tdynamicQuery.addOrder(OrderFactoryUtil.desc(\"remoteMessageId\"));\n\t\t}\n\n\t\tList<Message> messages = messagePersistence.findWithDynamicQuery(\n\t\t\tdynamicQuery, 0, 1);\n\n\t\tif (messages.isEmpty()) {\n\t\t\tthrow new NoSuchMessageException();\n\t\t}\n\n\t\treturn messages.get(0);\n\t}","commit_id":"b7015d1c668816c6e3529f4f95cae61c69e32c12","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public static JSONObject getJSONRecipients(\n\t\t\tlong userId, String type, String keywords, int start, int end)\n\t\tthrows PortalException {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\tLinkedHashMap<String, Object> params = new LinkedHashMap<>();\n\n\t\tif (type.equals(\"site\")) {\n\t\t\tparams.put(\"inherit\", Boolean.TRUE);\n\n\t\t\tLinkedHashMap<String, Object> groupParams = new LinkedHashMap<>();\n\n\t\t\tgroupParams.put(\"inherit\", Boolean.FALSE);\n\t\t\tgroupParams.put(\"site\", Boolean.TRUE);\n\t\t\tgroupParams.put(\"usersGroups\", userId);\n\n\t\t\tList<Group> groups = GroupLocalServiceUtil.search(\n\t\t\t\tuser.getCompanyId(), groupParams, QueryUtil.ALL_POS,\n\t\t\t\tQueryUtil.ALL_POS);\n\n\t\t\tparams.put(\n\t\t\t\t\"usersGroups\",\n\t\t\t\tSitesUtil.filterGroups(\n\t\t\t\t\tgroups,\n\t\t\t\t\tPortletPropsValues.AUTOCOMPLETE_RECIPIENT_SITE_EXCLUDES));\n\t\t}\n\t\telse if (!type.equals(\"all\")) {\n\t\t\tparams.put(\n\t\t\t\t\"socialRelationType\",\n\t\t\t\tnew Long[] {\n\t\t\t\t\tuserId, new Long(SocialRelationConstants.TYPE_BI_CONNECTION)\n\t\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\t\tuser.getCompanyId(), RoleConstants.SOCIAL_OFFICE_USER);\n\n\t\t\tif (role != null) {\n\t\t\t\tparams.put(\"inherit\", Boolean.TRUE);\n\t\t\t\tparams.put(\"usersRoles\", new Long(role.getRoleId()));\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchRoleException nsre) {\n\t\t}\n\n\t\tList<User> users = new ArrayList<>();\n\n\t\tif (_USERS_INDEXER_ENABLED && _USERS_SEARCH_WITH_INDEX) {\n\t\t\tSort sort = SortFactoryUtil.getSort(User.class, \"firstName\", \"asc\");\n\n\t\t\tBaseModelSearchResult<User> baseModelSearchResult =\n\t\t\t\tUserLocalServiceUtil.searchUsers(\n\t\t\t\t\tuser.getCompanyId(), keywords, keywords, keywords, keywords,\n\t\t\t\t\tkeywords, WorkflowConstants.STATUS_APPROVED, params, false,\n\t\t\t\t\tstart, end, sort);\n\n\t\t\tjsonObject.put(\"total\", baseModelSearchResult.getLength());\n\n\t\t\tusers = baseModelSearchResult.getBaseModels();\n\t\t}\n\t\telse {\n\t\t\tint total = UserLocalServiceUtil.searchCount(\n\t\t\t\tuser.getCompanyId(), keywords,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, params);\n\n\t\t\tjsonObject.put(\"total\", total);\n\n\t\t\tusers = UserLocalServiceUtil.search(\n\t\t\t\tuser.getCompanyId(), keywords,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, params, start, end,\n\t\t\t\tnew UserFirstNameComparator(true));\n\t\t}\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (User curUser : users) {\n\t\t\tJSONObject userJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(curUser.getFullName());\n\t\t\tsb.append(CharPool.SPACE);\n\t\t\tsb.append(CharPool.LESS_THAN);\n\t\t\tsb.append(curUser.getScreenName());\n\t\t\tsb.append(CharPool.GREATER_THAN);\n\n\t\t\tuserJSONObject.put(\"name\", sb.toString());\n\n\t\t\tjsonArray.put(userJSONObject);\n\t\t}\n\n\t\tjsonObject.put(\"users\", jsonArray);\n\n\t\treturn jsonObject;\n\t}","id":44878,"modified_method":"public static JSONObject getJSONRecipients(\n\t\t\tlong userId, String type, String keywords, int start, int end)\n\t\tthrows PortalException {\n\n\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\tUser user = UserLocalServiceUtil.getUser(userId);\n\n\t\tLinkedHashMap<String, Object> params = new LinkedHashMap<>();\n\n\t\tif (type.equals(\"site\")) {\n\t\t\tparams.put(\"inherit\", Boolean.TRUE);\n\n\t\t\tLinkedHashMap<String, Object> groupParams = new LinkedHashMap<>();\n\n\t\t\tgroupParams.put(\"inherit\", Boolean.FALSE);\n\t\t\tgroupParams.put(\"site\", Boolean.TRUE);\n\t\t\tgroupParams.put(\"usersGroups\", userId);\n\n\t\t\tList<Group> groups = GroupLocalServiceUtil.search(\n\t\t\t\tuser.getCompanyId(), groupParams, QueryUtil.ALL_POS,\n\t\t\t\tQueryUtil.ALL_POS);\n\n\t\t\tparams.put(\n\t\t\t\t\"usersGroups\",\n\t\t\t\tSitesUtil.filterGroups(\n\t\t\t\t\tgroups,\n\t\t\t\t\tPortletPropsValues.AUTOCOMPLETE_RECIPIENT_SITE_EXCLUDES));\n\t\t}\n\t\telse if (!type.equals(\"all\")) {\n\t\t\tparams.put(\n\t\t\t\t\"socialRelationType\",\n\t\t\t\tnew Long[] {\n\t\t\t\t\tuserId,\n\t\t\t\t\tLong.valueOf(SocialRelationConstants.TYPE_BI_CONNECTION)\n\t\t\t\t});\n\t\t}\n\n\t\ttry {\n\t\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\t\tuser.getCompanyId(), RoleConstants.SOCIAL_OFFICE_USER);\n\n\t\t\tif (role != null) {\n\t\t\t\tparams.put(\"inherit\", Boolean.TRUE);\n\t\t\t\tparams.put(\"usersRoles\", Long.valueOf(role.getRoleId()));\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchRoleException nsre) {\n\t\t}\n\n\t\tList<User> users = new ArrayList<>();\n\n\t\tif (_USERS_INDEXER_ENABLED && _USERS_SEARCH_WITH_INDEX) {\n\t\t\tSort sort = SortFactoryUtil.getSort(User.class, \"firstName\", \"asc\");\n\n\t\t\tBaseModelSearchResult<User> baseModelSearchResult =\n\t\t\t\tUserLocalServiceUtil.searchUsers(\n\t\t\t\t\tuser.getCompanyId(), keywords, keywords, keywords, keywords,\n\t\t\t\t\tkeywords, WorkflowConstants.STATUS_APPROVED, params, false,\n\t\t\t\t\tstart, end, sort);\n\n\t\t\tjsonObject.put(\"total\", baseModelSearchResult.getLength());\n\n\t\t\tusers = baseModelSearchResult.getBaseModels();\n\t\t}\n\t\telse {\n\t\t\tint total = UserLocalServiceUtil.searchCount(\n\t\t\t\tuser.getCompanyId(), keywords,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, params);\n\n\t\t\tjsonObject.put(\"total\", total);\n\n\t\t\tusers = UserLocalServiceUtil.search(\n\t\t\t\tuser.getCompanyId(), keywords,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, params, start, end,\n\t\t\t\tnew UserFirstNameComparator(true));\n\t\t}\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tfor (User curUser : users) {\n\t\t\tJSONObject userJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tStringBundler sb = new StringBundler(5);\n\n\t\t\tsb.append(curUser.getFullName());\n\t\t\tsb.append(CharPool.SPACE);\n\t\t\tsb.append(CharPool.LESS_THAN);\n\t\t\tsb.append(curUser.getScreenName());\n\t\t\tsb.append(CharPool.GREATER_THAN);\n\n\t\t\tuserJSONObject.put(\"name\", sb.toString());\n\n\t\t\tjsonArray.put(userJSONObject);\n\t\t}\n\n\t\tjsonObject.put(\"users\", jsonArray);\n\n\t\treturn jsonObject;\n\t}","commit_id":"b7015d1c668816c6e3529f4f95cae61c69e32c12","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private CategoryDataset _getDataset() throws Exception {\n\t\tDefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n\t\tString seriesName = \"\";\n\n\t\tdataset.addValue(new Integer(9), seriesName, \"Coke\");\n\t\tdataset.addValue(new Integer(21), seriesName, \"Pepsi\");\n\n\t\treturn dataset;\n\t}","id":44879,"modified_method":"private CategoryDataset _getDataset() throws Exception {\n\t\tDefaultCategoryDataset dataset = new DefaultCategoryDataset();\n\n\t\tString seriesName = \"\";\n\n\t\tdataset.addValue(Integer.valueOf(9), seriesName, \"Coke\");\n\t\tdataset.addValue(Integer.valueOf(21), seriesName, \"Pepsi\");\n\n\t\treturn dataset;\n\t}","commit_id":"b7015d1c668816c6e3529f4f95cae61c69e32c12","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void joinGroup(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\tthemeDisplay.getScopeGroupId());\n\n\t\tif (group.getType() == GroupConstants.TYPE_SITE_OPEN) {\n\t\t\tUserLocalServiceUtil.addGroupUsers(\n\t\t\t\tgroup.getGroupId(), new long[] {themeDisplay.getUserId()});\n\t\t}\n\t\telse {\n\t\t\tRole siteAdminRole = RoleLocalServiceUtil.getRole(\n\t\t\t\tthemeDisplay.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t\tLinkedHashMap<String, Object> userParams =\n\t\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\t\tuserParams.put(\n\t\t\t\t\"userGroupRole\",\n\t\t\t\tnew Long[] {new Long(group.getGroupId()),\n\t\t\t\tnew Long(siteAdminRole.getRoleId())});\n\n\t\t\tList<User> users = UserLocalServiceUtil.search(\n\t\t\t\tthemeDisplay.getCompanyId(), null,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, userParams,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS, (OrderByComparator)null);\n\n\t\t\tif (users.size() == 0) {\n\t\t\t\tRole portalAdminRole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tthemeDisplay.getCompanyId(), RoleConstants.ADMINISTRATOR);\n\n\t\t\t\tuserParams.clear();\n\n\t\t\t\tuserParams.put(\"usersRoles\", portalAdminRole.getRoleId());\n\n\t\t\t\tusers = UserLocalServiceUtil.search(\n\t\t\t\t\tthemeDisplay.getCompanyId(), null,\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, userParams,\n\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\t(OrderByComparator)null);\n\t\t\t}\n\n\t\t\tfor (User user : users) {\n\t\t\t\tSocialRequestLocalServiceUtil.addRequest(\n\t\t\t\t\tthemeDisplay.getUserId(), 0, Group.class.getName(),\n\t\t\t\t\tgroup.getGroupId(), MembersRequestKeys.ADD_MEMBER,\n\t\t\t\t\tStringPool.BLANK, user.getUserId());\n\t\t\t}\n\t\t}\n\t}","id":44880,"modified_method":"public void joinGroup(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\tthemeDisplay.getScopeGroupId());\n\n\t\tif (group.getType() == GroupConstants.TYPE_SITE_OPEN) {\n\t\t\tUserLocalServiceUtil.addGroupUsers(\n\t\t\t\tgroup.getGroupId(), new long[] {themeDisplay.getUserId()});\n\t\t}\n\t\telse {\n\t\t\tRole siteAdminRole = RoleLocalServiceUtil.getRole(\n\t\t\t\tthemeDisplay.getCompanyId(), RoleConstants.SITE_ADMINISTRATOR);\n\n\t\t\tLinkedHashMap<String, Object> userParams =\n\t\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\t\tuserParams.put(\n\t\t\t\t\"userGroupRole\",\n\t\t\t\tnew Long[] {group.getGroupId(), siteAdminRole.getRoleId()});\n\n\t\t\tList<User> users = UserLocalServiceUtil.search(\n\t\t\t\tthemeDisplay.getCompanyId(), null,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, userParams,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS, (OrderByComparator)null);\n\n\t\t\tif (users.isEmpty()) {\n\t\t\t\tRole adminRole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tthemeDisplay.getCompanyId(), RoleConstants.ADMINISTRATOR);\n\n\t\t\t\tuserParams.clear();\n\n\t\t\t\tuserParams.put(\"usersRoles\", adminRole.getRoleId());\n\n\t\t\t\tusers = UserLocalServiceUtil.search(\n\t\t\t\t\tthemeDisplay.getCompanyId(), null,\n\t\t\t\t\tWorkflowConstants.STATUS_APPROVED, userParams,\n\t\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t\t(OrderByComparator)null);\n\t\t\t}\n\n\t\t\tfor (User user : users) {\n\t\t\t\tSocialRequestLocalServiceUtil.addRequest(\n\t\t\t\t\tthemeDisplay.getUserId(), 0, Group.class.getName(),\n\t\t\t\t\tgroup.getGroupId(), MembersRequestKeys.ADD_MEMBER,\n\t\t\t\t\tStringPool.BLANK, user.getUserId());\n\t\t\t}\n\t\t}\n\t}","commit_id":"6fd66c101db6faa14524ba59fbfec65547ec43b2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void joinOrganization(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\tthemeDisplay.getScopeGroupId());\n\n\t\tOrganization organization =\n\t\t\tOrganizationLocalServiceUtil.getOrganization(group.getClassPK());\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tthemeDisplay.getCompanyId(), \"Organization Administrator\");\n\n\t\tLinkedHashMap<String, Object> userParams =\n\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\tuserParams.put(\n\t\t\t\"userGroupRole\",\n\t\t\tnew Long[] {new Long(group.getGroupId()),\n\t\t\tnew Long(role.getRoleId())});\n\n\t\tList<User> users = UserLocalServiceUtil.search(\n\t\t\tthemeDisplay.getCompanyId(), null,\n\t\t\tWorkflowConstants.STATUS_APPROVED, userParams, QueryUtil.ALL_POS,\n\t\t\tQueryUtil.ALL_POS, (OrderByComparator)null);\n\n\t\tif (users.size() == 0) {\n\t\t\tRole portalAdminRole = RoleLocalServiceUtil.getRole(\n\t\t\t\tthemeDisplay.getCompanyId(), RoleConstants.ADMINISTRATOR);\n\n\t\t\tuserParams.clear();\n\n\t\t\tuserParams.put(\"usersRoles\", portalAdminRole.getRoleId());\n\n\t\t\tusers = UserLocalServiceUtil.search(\n\t\t\t\tthemeDisplay.getCompanyId(), null,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, userParams,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t(OrderByComparator)null);\n\t\t}\n\n\t\tfor (User user : users) {\n\t\t\tSocialRequestLocalServiceUtil.addRequest(\n\t\t\t\tthemeDisplay.getUserId(), 0, Organization.class.getName(),\n\t\t\t\torganization.getOrganizationId(), MembersRequestKeys.ADD_MEMBER,\n\t\t\t\tStringPool.BLANK, user.getUserId());\n\t\t}\n\t}","id":44881,"modified_method":"public void joinOrganization(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tGroup group = GroupLocalServiceUtil.getGroup(\n\t\t\tthemeDisplay.getScopeGroupId());\n\n\t\tOrganization organization =\n\t\t\tOrganizationLocalServiceUtil.getOrganization(group.getClassPK());\n\n\t\tRole role = RoleLocalServiceUtil.getRole(\n\t\t\tthemeDisplay.getCompanyId(), \"Organization Administrator\");\n\n\t\tLinkedHashMap<String, Object> userParams =\n\t\t\tnew LinkedHashMap<String, Object>();\n\n\t\tuserParams.put(\n\t\t\t\"userGroupRole\", new Long[] {group.getGroupId(), role.getRoleId()});\n\n\t\tList<User> users = UserLocalServiceUtil.search(\n\t\t\tthemeDisplay.getCompanyId(), null,\n\t\t\tWorkflowConstants.STATUS_APPROVED, userParams, QueryUtil.ALL_POS,\n\t\t\tQueryUtil.ALL_POS, (OrderByComparator)null);\n\n\t\tif (users.isEmpty()) {\n\t\t\tRole adminRole = RoleLocalServiceUtil.getRole(\n\t\t\t\tthemeDisplay.getCompanyId(), RoleConstants.ADMINISTRATOR);\n\n\t\t\tuserParams.clear();\n\n\t\t\tuserParams.put(\"usersRoles\", adminRole.getRoleId());\n\n\t\t\tusers = UserLocalServiceUtil.search(\n\t\t\t\tthemeDisplay.getCompanyId(), null,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED, userParams,\n\t\t\t\tQueryUtil.ALL_POS, QueryUtil.ALL_POS,\n\t\t\t\t(OrderByComparator)null);\n\t\t}\n\n\t\tfor (User user : users) {\n\t\t\tSocialRequestLocalServiceUtil.addRequest(\n\t\t\t\tthemeDisplay.getUserId(), 0, Organization.class.getName(),\n\t\t\t\torganization.getOrganizationId(), MembersRequestKeys.ADD_MEMBER,\n\t\t\t\tStringPool.BLANK, user.getUserId());\n\t\t}\n\t}","commit_id":"6fd66c101db6faa14524ba59fbfec65547ec43b2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"private Map getJarResources( List resources )\n        throws Exception\n    {\n        Map resourceEntries = new TreeMap();\n\n        for ( Iterator i = resources.iterator(); i.hasNext(); )\n        {\n            Resource resource = (Resource) i.next();\n\n            String targetPath = resource.getTargetPath();\n\n            File resourceDirectory = new File( resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() )\n            {\n                continue;\n            }\n\n            // If we only have a directory then we want to include\n            // everything we can find within that path.\n\n            String includesAsString = \"**/**\";\n\n            java.util.List includes = resource.getIncludes();\n            if ( includes != null && includes.size() > 0 )\n            {\n                includesAsString = StringUtils.join( includes.iterator(), \",\" );\n            }\n\n            List excludes = resource.getExcludes();\n\n            if ( excludes == null )\n            {\n                excludes = resource.getDefaultExcludes();\n            }\n            else\n            {\n                excludes = new ArrayList( excludes );\n                excludes.addAll( resource.getDefaultExcludes() );\n            }\n\n            String excludesAsString = StringUtils.join( excludes.iterator(), \",\" );\n\n            List files = FileUtils.getFileNames( resourceDirectory, includesAsString, excludesAsString, false );\n\n            for ( Iterator j = files.iterator(); j.hasNext(); )\n            {\n                String name = (String) j.next();\n\n                String entryName = name;\n\n                if ( targetPath != null )\n                {\n                    entryName = targetPath + \"/\" + name;\n                }\n\n                String resourcePath = new File( resource.getDirectory(), name ).getPath();\n\n                resourceEntries.put( resourcePath, entryName );\n            }\n        }\n\n        return resourceEntries;\n    }","id":44882,"modified_method":"private Map getJarResources( List resources )\n        throws Exception\n    {\n        Map resourceEntries = new TreeMap();\n\n        for ( Iterator i = resources.iterator(); i.hasNext(); )\n        {\n            Resource resource = (Resource) i.next();\n\n            String targetPath = resource.getTargetPath();\n\n            File resourceDirectory = new File( resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() )\n            {\n                continue;\n            }\n\n            DirectoryScanner scanner = new DirectoryScanner();\n            scanner.addDefaultExcludes();\n\n            scanner.setBasedir( resource.getDirectory() );\n            if ( resource.getIncludes() != null && !resource.getIncludes().isEmpty() )\n            {\n                scanner.setIncludes( (String[]) resource.getIncludes().toArray( EMPTY_STRING_ARRAY ) );\n            }\n            else\n            {\n                scanner.setIncludes( DEFAULT_INCLUDES );\n            }\n            if ( resource.getExcludes() != null && !resource.getExcludes().isEmpty() )\n            {\n                scanner.setExcludes( (String[]) resource.getExcludes().toArray( EMPTY_STRING_ARRAY ) );\n            }\n\n            scanner.scan();\n\n            List includedFiles = Arrays.asList( scanner.getIncludedFiles() );\n            for ( Iterator j = includedFiles.iterator(); j.hasNext(); )\n            {\n                String name = (String) j.next();\n\n                String entryName = name;\n\n                if ( targetPath != null )\n                {\n                    entryName = targetPath + \"/\" + name;\n                }\n\n                resourceEntries.put( new File( resource.getDirectory(), name ), entryName );\n            }\n        }\n\n        return resourceEntries;\n    }","commit_id":"5e14491f597c7e0e17a2c043e8e2639f6085900d","url":"https://github.com/apache/maven"},{"original_method":"protected void copyResources( List resources, String outputDirectory )\n        throws MojoExecutionException\n    {\n        try\n        {\n            for ( Iterator i = getJarResources( resources ).entrySet().iterator(); i.hasNext(); )\n            {\n                Map.Entry entry = (Map.Entry) i.next();\n                String source = (String) entry.getKey();\n                String destination = (String) entry.getValue();\n\n                File destinationFile = new File( outputDirectory, destination );\n\n                if ( !destinationFile.getParentFile().exists() )\n                {\n                    destinationFile.getParentFile().mkdirs();\n                }\n\n                fileCopy( source, destinationFile.getPath() );\n            }\n        }\n        catch ( Exception e )\n        {\n            // TODO: handle exception\n            throw new MojoExecutionException( \"Error copying resources\", e );\n        }\n    }","id":44883,"modified_method":"protected void copyResources( List resources, String outputDirectory )\n        throws MojoExecutionException\n    {\n        try\n        {\n            for ( Iterator i = getJarResources( resources ).entrySet().iterator(); i.hasNext(); )\n            {\n                Map.Entry entry = (Map.Entry) i.next();\n                File source = (File) entry.getKey();\n                String destination = (String) entry.getValue();\n\n                File destinationFile = new File( outputDirectory, destination );\n\n                if ( !destinationFile.getParentFile().exists() )\n                {\n                    destinationFile.getParentFile().mkdirs();\n                }\n\n                FileUtils.copyFile( source, destinationFile );\n            }\n        }\n        catch ( Exception e )\n        {\n            // TODO: handle exception\n            throw new MojoExecutionException( \"Error copying resources\", e );\n        }\n    }","commit_id":"5e14491f597c7e0e17a2c043e8e2639f6085900d","url":"https://github.com/apache/maven"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response ) throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactDeployer artifactDeployer = (ArtifactDeployer) request.getParameter( \"deployer\" );\n\n        DistributionManagement distributionManagement = project.getDistributionManagement();\n\n        if ( distributionManagement == null )\n        {\n            String msg = \"Deployment failed: distributionManagement element\" + \" was not specified in the pom\";\n            throw new Exception( msg );\n        }\n\n        Repository repository = distributionManagement.getRepository();\n\n        if ( repository == null )\n        {\n            String msg = \"Deployment failed: repository element\" + \" was not specified in the pom inside\"\n                + \" distributionManagement element\";\n            throw new Exception( msg );\n        }\n\n        ArtifactRepository deploymentRepository = new ArtifactRepository( repository.getId(), repository.getUrl() );\n\n        // Deploy the POM\n        Artifact pomArtifact = new DefaultArtifact( project.getGroupId(),\n                                                    project.getArtifactId(),\n                                                    project.getVersion(),\n                                                    \"pom\" );\n\n        File pom = new File( project.getFile().getParentFile(), \"pom.xml\" );\n\n        artifactDeployer.deploy( pom, pomArtifact, deploymentRepository );\n\n        //Deploy artifact\n        if ( !isPom() )\n        {\n            Artifact artifact = new DefaultArtifact( project.getGroupId(),\n                                                     project.getArtifactId(),\n                                                     project.getVersion(),\n                                                     project.getType() );\n\n            artifactDeployer.deploy( project.getBuild().getDirectory(), artifact, deploymentRepository );\n        }\n    }","id":44884,"modified_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactDeployer artifactDeployer = (ArtifactDeployer) request.getParameter( \"deployer\" );\n\n        DistributionManagement distributionManagement = project.getDistributionManagement();\n\n        if ( distributionManagement == null )\n        {\n            String msg = \"Deployment failed: distributionManagement element\" + \" was not specified in the pom\";\n            throw new Exception( msg );\n        }\n\n        Repository repository = distributionManagement.getRepository();\n\n        if ( repository == null )\n        {\n            String msg = \"Deployment failed: repository element\" + \" was not specified in the pom inside\" +\n                \" distributionManagement element\";\n            throw new Exception( msg );\n        }\n\n        ArtifactRepository deploymentRepository = new ArtifactRepository( repository.getId(), repository.getUrl() );\n\n        // Deploy the POM\n        Artifact pomArtifact = new DefaultArtifact( project.getGroupId(), project.getArtifactId(),\n                                                    project.getVersion(), \"pom\" );\n\n        File pom = new File( project.getFile().getParentFile(), \"pom.xml\" );\n\n        artifactDeployer.deploy( pom, pomArtifact, deploymentRepository );\n\n        //Deploy artifact\n        if ( !isPom() )\n        {\n            Artifact artifact = new DefaultArtifact( project.getGroupId(), project.getArtifactId(),\n                                                     project.getVersion(), project.getPackaging() );\n\n            artifactDeployer.deploy( project.getBuild().getDirectory(), artifact, deploymentRepository );\n        }\n    }","commit_id":"cd89f32322e5bbd0eafed5ae21601e93adb22f2b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactInstaller artifactInstaller = (ArtifactInstaller) request.getParameter( \"installer\" );\n\n        ArtifactRepository localRepository = (ArtifactRepository) request.getParameter( \"localRepository\" );\n\n        // Install the POM\n        Artifact pomArtifact = new DefaultArtifact( project.getGroupId(),\n                                                 project.getArtifactId(),\n                                                 project.getVersion(),\n                                                 \"pom\" );\n\n        File pom = new File( project.getFile().getParentFile(), \"pom.xml\" );\n\n        artifactInstaller.install( pom, pomArtifact, localRepository );\n\n        //Install artifact\n        if ( ! isPom() )\n        {\n            Artifact artifact = new DefaultArtifact( project.getGroupId(),\n                                                     project.getArtifactId(),\n                                                     project.getVersion(),\n                                                     project.getType() );\n\n            artifactInstaller.install( project.getBuild().getDirectory(), artifact, localRepository );\n        }\n    }","id":44885,"modified_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactInstaller artifactInstaller = (ArtifactInstaller) request.getParameter( \"installer\" );\n\n        ArtifactRepository localRepository = (ArtifactRepository) request.getParameter( \"localRepository\" );\n\n        // Install the POM\n        Artifact pomArtifact = new DefaultArtifact( project.getGroupId(), project.getArtifactId(),\n                                                    project.getVersion(), \"pom\" );\n\n        File pom = new File( project.getFile().getParentFile(), \"pom.xml\" );\n\n        artifactInstaller.install( pom, pomArtifact, localRepository );\n\n        //Install artifact\n        if ( !isPom() )\n        {\n            Artifact artifact = new DefaultArtifact( project.getGroupId(), project.getArtifactId(),\n                                                     project.getVersion(), project.getPackaging() );\n\n            artifactInstaller.install( project.getBuild().getDirectory(), artifact, localRepository );\n        }\n    }","commit_id":"cd89f32322e5bbd0eafed5ae21601e93adb22f2b","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Return a pre-configured manifest\n     * @todo Add user attributes list and user groups list\n     */\n    public Manifest getManifest( PluginExecutionRequest request )\n        throws Exception\n    {\n        MavenProject project = (MavenProject)request.getParameter(\"project\");\n\n        String mainClass = (String) request.getParameter( \"mainClass\" );\n\n        boolean addClasspath = new Boolean( (String) request.getParameter( \"addClasspath\" ) ).booleanValue();\n\n        boolean addExtensions = new Boolean( (String) request.getParameter( \"addExtensions\" ) ).booleanValue();\n\n        // Added basic entries\n        Manifest m = new Manifest();\n        Manifest.Attribute buildAttr = new Manifest.Attribute( \"Built-By\", System.getProperty( \"user.name\" ) );\n        m.addConfiguredAttribute( buildAttr );\n        Manifest.Attribute createdAttr = new Manifest.Attribute( \"Created-By\", \"Apache Maven\" );\n        m.addConfiguredAttribute( createdAttr );\n        Manifest.Attribute packageAttr = new Manifest.Attribute( \"Package\", project.getPackage() );\n        m.addConfiguredAttribute( packageAttr );\n        Manifest.Attribute buildJdkAttr = new Manifest.Attribute( \"Build-Jdk\", System.getProperty( \"java.version\" ) );\n        m.addConfiguredAttribute( buildJdkAttr );\n\n        if ( addClasspath )\n        {\n            StringBuffer classpath = new StringBuffer();\n            List dependencies = project.getDependencies();\n    \n            for ( Iterator iter = dependencies.iterator(); iter.hasNext(); )\n            {\n                Dependency dependency = (Dependency) iter.next();\n                Properties properties = dependency.getProperties();\n                if ( Boolean.valueOf(properties.getProperty(\"jar.manifest.classpath\")).booleanValue())\n                {\n                    if (classpath.length() > 0 )\n                    {\n                        classpath.append( \" \" );\n                    }\n\n                    // TODO replace dependency by artifact\n                    classpath.append( dependency.getArtifactId() + \"-\" + dependency.getVersion() + \".jar\");\n                }\n            }\n            \n            Manifest.Attribute classpathAttr = new Manifest.Attribute( \"Class-Path\", classpath.toString() );\n            m.addConfiguredAttribute( classpathAttr );\n        }\n\n        // Added supplementary entries\n        Manifest.Attribute extensionNameAttr = new Manifest.Attribute( \"Extension-Name\", project.getArtifactId() );\n        m.addConfiguredAttribute( extensionNameAttr );\n        \n        if ( project.getShortDescription() != null )\n        {\n            Manifest.Attribute specificationTitleAttr = new Manifest.Attribute( \"Specification-Title\", project.getShortDescription() );\n            m.addConfiguredAttribute( specificationTitleAttr );\n        }\n        \n        if ( project.getOrganization() != null )\n        {\n            Manifest.Attribute specificationVendor = new Manifest.Attribute( \"Specification-Vendor\", project.getOrganization().getName() );\n            m.addConfiguredAttribute( specificationVendor );\n            Manifest.Attribute implementationVendorAttr = new Manifest.Attribute( \"Implementation-Vendor\", project.getOrganization().getName() );\n            m.addConfiguredAttribute( implementationVendorAttr );\n        }\n\n        Manifest.Attribute implementationTitleAttr = new Manifest.Attribute( \"Implementation-Title\", project.getArtifactId() );\n        m.addConfiguredAttribute( implementationTitleAttr );\n        Manifest.Attribute implementationVersionAttr = new Manifest.Attribute( \"Implementation-Version\", project.getVersion() );\n        m.addConfiguredAttribute( implementationVersionAttr );\n\n        if ( mainClass != null && ! \"\".equals( mainClass ) )\n        {\n            Manifest.Attribute mainClassAttr = new Manifest.Attribute( \"Main-Class\", mainClass );\n            m.addConfiguredAttribute( mainClassAttr );\n        }\n\n        // Added extensions\n        if ( addExtensions )\n        {\n            StringBuffer extensionsList = new StringBuffer();\n            Set artifacts = project.getArtifacts();\n\n            for ( Iterator iter = artifacts.iterator(); iter.hasNext(); )\n            {\n                Artifact artifact = (Artifact) iter.next();\n                if ( \"jar\".equals( artifact.getType() ) )\n                {\n                    if (extensionsList.length() > 0 )\n                    {\n                        extensionsList.append( \" \" );\n                    }\n                    extensionsList.append( artifact.getArtifactId() );\n                }\n            }\n\n            if (extensionsList.length() > 0 )\n            {\n                Manifest.Attribute extensionsListAttr = new Manifest.Attribute( \"Extension-List\", extensionsList.toString() );\n                m.addConfiguredAttribute( extensionsListAttr );\n            }\n            \n            for ( Iterator iter = artifacts.iterator(); iter.hasNext(); )\n            {\n                Artifact artifact = (Artifact) iter.next();\n                if ( \"jar\".equals( artifact.getType() ) )\n                {\n                    Manifest.Attribute archExtNameAttr = new Manifest.Attribute( artifact.getArtifactId()\n                        + \"-Extension-Name\", artifact.getArtifactId() );\n                    m.addConfiguredAttribute( archExtNameAttr );\n                    Manifest.Attribute archImplVersionAttr = new Manifest.Attribute( artifact.getArtifactId()\n                        + \"-Implementation-Version\", artifact.getVersion() );\n                    m.addConfiguredAttribute( archImplVersionAttr );\n                    Manifest.Attribute archImplUrlAttr = new Manifest.Attribute( artifact.getArtifactId()\n                        + \"-Implementation-URL\", \"http://www.ibiblio.org/maven/\" + artifact.toString() );\n                    m.addConfiguredAttribute( archImplUrlAttr );\n                }\n            }\n        }\n\n        return m;\n    }","id":44886,"modified_method":"/**\n     * Return a pre-configured manifest\n     *\n     * @todo Add user attributes list and user groups list\n     */\n    public Manifest getManifest( PluginExecutionRequest request )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        String mainClass = (String) request.getParameter( \"mainClass\" );\n\n        boolean addClasspath = new Boolean( (String) request.getParameter( \"addClasspath\" ) ).booleanValue();\n\n        boolean addExtensions = new Boolean( (String) request.getParameter( \"addExtensions\" ) ).booleanValue();\n\n        // Added basic entries\n        Manifest m = new Manifest();\n        Manifest.Attribute buildAttr = new Manifest.Attribute( \"Built-By\", System.getProperty( \"user.name\" ) );\n        m.addConfiguredAttribute( buildAttr );\n        Manifest.Attribute createdAttr = new Manifest.Attribute( \"Created-By\", \"Apache Maven\" );\n        m.addConfiguredAttribute( createdAttr );\n/* TODO: property on plugin\n        Manifest.Attribute packageAttr = new Manifest.Attribute( \"Package\", project.getPackage() );\n        m.addConfiguredAttribute( packageAttr );\n*/\n        Manifest.Attribute buildJdkAttr = new Manifest.Attribute( \"Build-Jdk\", System.getProperty( \"java.version\" ) );\n        m.addConfiguredAttribute( buildJdkAttr );\n\n        if ( addClasspath )\n        {\n            StringBuffer classpath = new StringBuffer();\n            List dependencies = project.getDependencies();\n\n            for ( Iterator iter = dependencies.iterator(); iter.hasNext(); )\n            {\n                Dependency dependency = (Dependency) iter.next();\n/* TODO: property on plugin\n                Properties properties = dependency.getProperties();\n                if ( Boolean.valueOf(properties.getProperty(\"jar.manifest.classpath\")).booleanValue())\n                {\n                    if (classpath.length() > 0 )\n                    {\n                        classpath.append( \" \" );\n                    }\n\n                    // TODO replace dependency by artifact\n                    classpath.append( dependency.getArtifactId() + \"-\" + dependency.getVersion() + \".jar\");\n                }\n*/\n            }\n\n            Manifest.Attribute classpathAttr = new Manifest.Attribute( \"Class-Path\", classpath.toString() );\n            m.addConfiguredAttribute( classpathAttr );\n        }\n\n        // Added supplementary entries\n        Manifest.Attribute extensionNameAttr = new Manifest.Attribute( \"Extension-Name\", project.getArtifactId() );\n        m.addConfiguredAttribute( extensionNameAttr );\n\n        if ( project.getDescription() != null )\n        {\n            Manifest.Attribute specificationTitleAttr = new Manifest.Attribute( \"Specification-Title\",\n                                                                                project.getDescription() );\n            m.addConfiguredAttribute( specificationTitleAttr );\n        }\n\n        if ( project.getOrganization() != null )\n        {\n            Manifest.Attribute specificationVendor = new Manifest.Attribute( \"Specification-Vendor\",\n                                                                             project.getOrganization().getName() );\n            m.addConfiguredAttribute( specificationVendor );\n            Manifest.Attribute implementationVendorAttr = new Manifest.Attribute( \"Implementation-Vendor\",\n                                                                                  project.getOrganization().getName() );\n            m.addConfiguredAttribute( implementationVendorAttr );\n        }\n\n        Manifest.Attribute implementationTitleAttr = new Manifest.Attribute( \"Implementation-Title\",\n                                                                             project.getArtifactId() );\n        m.addConfiguredAttribute( implementationTitleAttr );\n        Manifest.Attribute implementationVersionAttr = new Manifest.Attribute( \"Implementation-Version\",\n                                                                               project.getVersion() );\n        m.addConfiguredAttribute( implementationVersionAttr );\n\n        if ( mainClass != null && !\"\".equals( mainClass ) )\n        {\n            Manifest.Attribute mainClassAttr = new Manifest.Attribute( \"Main-Class\", mainClass );\n            m.addConfiguredAttribute( mainClassAttr );\n        }\n\n        // Added extensions\n        if ( addExtensions )\n        {\n            StringBuffer extensionsList = new StringBuffer();\n            Set artifacts = project.getArtifacts();\n\n            for ( Iterator iter = artifacts.iterator(); iter.hasNext(); )\n            {\n                Artifact artifact = (Artifact) iter.next();\n                if ( \"jar\".equals( artifact.getType() ) )\n                {\n                    if ( extensionsList.length() > 0 )\n                    {\n                        extensionsList.append( \" \" );\n                    }\n                    extensionsList.append( artifact.getArtifactId() );\n                }\n            }\n\n            if ( extensionsList.length() > 0 )\n            {\n                Manifest.Attribute extensionsListAttr = new Manifest.Attribute( \"Extension-List\",\n                                                                                extensionsList.toString() );\n                m.addConfiguredAttribute( extensionsListAttr );\n            }\n\n            for ( Iterator iter = artifacts.iterator(); iter.hasNext(); )\n            {\n                Artifact artifact = (Artifact) iter.next();\n                if ( \"jar\".equals( artifact.getType() ) )\n                {\n                    Manifest.Attribute archExtNameAttr = new Manifest.Attribute( artifact.getArtifactId() +\n                                                                                 \"-Extension-Name\",\n                                                                                 artifact.getArtifactId() );\n                    m.addConfiguredAttribute( archExtNameAttr );\n                    Manifest.Attribute archImplVersionAttr = new Manifest.Attribute( artifact.getArtifactId() +\n                                                                                     \"-Implementation-Version\",\n                                                                                     artifact.getVersion() );\n                    m.addConfiguredAttribute( archImplVersionAttr );\n                    Manifest.Attribute archImplUrlAttr = new Manifest.Attribute( artifact.getArtifactId() +\n                                                                                 \"-Implementation-URL\",\n                                                                                 \"http://www.ibiblio.org/maven/\" +\n                                                                                 artifact.toString() );\n                    m.addConfiguredAttribute( archImplUrlAttr );\n                }\n            }\n        }\n\n        return m;\n    }","commit_id":"cd89f32322e5bbd0eafed5ae21601e93adb22f2b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response ) throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactDeployer artifactDeployer = (ArtifactDeployer) request.getParameter( \"deployer\" );\n\n        //@todo this will be duplicated in case of every mojo which implements\n        // deploy goal\n        // this should be pushed into the ArtifactDeployer component\n        DistributionManagement distributionManagement = project.getDistributionManagement();\n\n        if ( distributionManagement == null )\n        {\n            String msg = \"Deployment failed: distributionManagement element\" + \" was not specified in the pom\";\n            throw new Exception( msg );\n        }\n\n        Repository repository = distributionManagement.getRepository();\n\n        if ( repository == null )\n        {\n            String msg = \"Deployment failed: repository element\" + \" was not specified in the pom inside\"\n                + \" distributionManagement element\";\n            throw new Exception( msg );\n        }\n\n        ArtifactRepository deploymentRepository = new ArtifactRepository( repository.getId(), repository.getUrl() );\n\n        Artifact artifact = new DefaultArtifact( project.getGroupId(),\n                                                 project.getArtifactId(),\n                                                 project.getVersion(),\n                                                 project.getType() );\n\n        artifactDeployer.deploy( project.getBuild().getDirectory(), artifact, deploymentRepository );\n    }","id":44887,"modified_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactDeployer artifactDeployer = (ArtifactDeployer) request.getParameter( \"deployer\" );\n\n        //@todo this will be duplicated in case of every mojo which implements\n        // deploy goal\n        // this should be pushed into the ArtifactDeployer component\n        DistributionManagement distributionManagement = project.getDistributionManagement();\n\n        if ( distributionManagement == null )\n        {\n            String msg = \"Deployment failed: distributionManagement element\" + \" was not specified in the pom\";\n            throw new Exception( msg );\n        }\n\n        Repository repository = distributionManagement.getRepository();\n\n        if ( repository == null )\n        {\n            String msg = \"Deployment failed: repository element\" + \" was not specified in the pom inside\" +\n                \" distributionManagement element\";\n            throw new Exception( msg );\n        }\n\n        ArtifactRepository deploymentRepository = new ArtifactRepository( repository.getId(), repository.getUrl() );\n\n        Artifact artifact = new DefaultArtifact( project.getGroupId(), project.getArtifactId(), project.getVersion(),\n                                                 project.getPackaging() );\n\n        artifactDeployer.deploy( project.getBuild().getDirectory(), artifact, deploymentRepository );\n    }","commit_id":"cd89f32322e5bbd0eafed5ae21601e93adb22f2b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactInstaller artifactInstaller = (ArtifactInstaller) request.getParameter( \"installer\" );\n\n        ArtifactRepository localRepository = (ArtifactRepository) request.getParameter( \"localRepository\" );\n\n        Artifact artifact = new DefaultArtifact( project.getGroupId(),\n                                                 project.getArtifactId(),\n                                                 project.getVersion(),\n                                                 project.getType() );\n\n        artifactInstaller.install( project.getBuild().getDirectory(), artifact, localRepository );\n\n        // ----------------------------------------------------------------------\n        // This is not the way to do this, but in order to get the integration\n        // tests working this is what I'm doing. jvz.\n        // ----------------------------------------------------------------------\n\n        Artifact pomArtifact = new DefaultArtifact( project.getGroupId(),\n                                                    project.getArtifactId(),\n                                                    project.getVersion(),\n                                                    \"pom\" );\n\n        artifactInstaller.install( project.getFile(), pomArtifact, localRepository );\n\n    }","id":44888,"modified_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactInstaller artifactInstaller = (ArtifactInstaller) request.getParameter( \"installer\" );\n\n        ArtifactRepository localRepository = (ArtifactRepository) request.getParameter( \"localRepository\" );\n\n        Artifact artifact = new DefaultArtifact( project.getGroupId(), project.getArtifactId(), project.getVersion(),\n                                                 project.getPackaging() );\n\n        artifactInstaller.install( project.getBuild().getDirectory(), artifact, localRepository );\n\n        // ----------------------------------------------------------------------\n        // This is not the way to do this, but in order to get the integration\n        // tests working this is what I'm doing. jvz.\n        // ----------------------------------------------------------------------\n\n        Artifact pomArtifact = new DefaultArtifact( project.getGroupId(), project.getArtifactId(),\n                                                    project.getVersion(), \"pom\" );\n\n        artifactInstaller.install( project.getFile(), pomArtifact, localRepository );\n\n    }","commit_id":"cd89f32322e5bbd0eafed5ae21601e93adb22f2b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactInstaller artifactInstaller = (ArtifactInstaller) request.getParameter( \"installer\" );\n\n        ArtifactRepository localRepository = (ArtifactRepository) request.getParameter( \"localRepository\" );\n\n        if ( ! \"plugin\".equals( project.getType() ) )\n        {\n            response.setExecutionFailure( new PluginFailureResponse( \"This project isn't a plugin.\" ) );\n\n            return;\n        }\n\n        Artifact artifact = new DefaultArtifact( project.getGroupId(),\n                                                 project.getArtifactId(),\n                                                 project.getVersion(),\n                                                 project.getType() );\n\n        artifactInstaller.install( project.getBuild().getDirectory(), artifact, localRepository );\n\n        // ----------------------------------------------------------------------\n        // This is not the way to do this, but in order to get the integration\n        // tests working this is what I'm doing. jvz.\n        // ----------------------------------------------------------------------\n\n        Artifact pomArtifact = new DefaultArtifact( project.getGroupId(),\n                                                    project.getArtifactId(),\n                                                    project.getVersion(),\n                                                    \"pom\" );\n\n        artifactInstaller.install( project.getFile(), pomArtifact, localRepository );\n    }","id":44889,"modified_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        MavenProject project = (MavenProject) request.getParameter( \"project\" );\n\n        ArtifactInstaller artifactInstaller = (ArtifactInstaller) request.getParameter( \"installer\" );\n\n        ArtifactRepository localRepository = (ArtifactRepository) request.getParameter( \"localRepository\" );\n\n        if ( !\"plugin\".equals( project.getPackaging() ) )\n        {\n            response.setExecutionFailure( new PluginFailureResponse( \"This project isn't a plugin.\" ) );\n\n            return;\n        }\n\n        Artifact artifact = new DefaultArtifact( project.getGroupId(), project.getArtifactId(), project.getVersion(),\n                                                 project.getPackaging() );\n\n        artifactInstaller.install( project.getBuild().getDirectory(), artifact, localRepository );\n\n        // ----------------------------------------------------------------------\n        // This is not the way to do this, but in order to get the integration\n        // tests working this is what I'm doing. jvz.\n        // ----------------------------------------------------------------------\n\n        Artifact pomArtifact = new DefaultArtifact( project.getGroupId(), project.getArtifactId(),\n                                                    project.getVersion(), \"pom\" );\n\n        artifactInstaller.install( project.getFile(), pomArtifact, localRepository );\n    }","commit_id":"cd89f32322e5bbd0eafed5ae21601e93adb22f2b","url":"https://github.com/apache/maven-plugins"},{"original_method":"private List getJarResources( List resources )\n        throws Exception\n    {\n        List resourceEntries = new ArrayList();\n\n        for ( Iterator i = resources.iterator(); i.hasNext(); )\n        {\n            Resource resource = (Resource) i.next();\n\n            String targetPath = resource.getTargetPath();\n\n            File resourceDirectory = new File( resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() )\n            {\n                continue;\n            }\n\n            // If we only have a directory then we want to include\n            // everything we can find within that path.\n\n            String includes;\n\n            if ( resource.getIncludes().size() > 0 )\n            {\n                includes = listToString( resource.getIncludes() );\n            }\n            else\n            {\n                includes = \"**/**\";\n            }\n\n            List excludes = resource.getExcludes();\n\n            excludes.addAll( resource.getDefaultExcludes() );\n\n            List files = FileUtils.getFileNames( resourceDirectory,\n                                                 includes,\n                                                 listToString( excludes ),\n                                                 false );\n\n            for ( Iterator j = files.iterator(); j.hasNext(); )\n            {\n                String name = (String) j.next();\n\n                String entryName = name;\n\n                if ( targetPath != null )\n                {\n                    entryName = targetPath + \"/\" + name;\n                }\n\n                ResourceEntry je = new ResourceEntry( new File( resource.getDirectory(), name ).getPath(), entryName );\n\n                resourceEntries.add( je );\n            }\n        }\n\n        return resourceEntries;\n    }","id":44890,"modified_method":"private List getJarResources( List resources )\n        throws Exception\n    {\n        List resourceEntries = new ArrayList();\n\n        for ( Iterator i = resources.iterator(); i.hasNext(); )\n        {\n            Resource resource = (Resource) i.next();\n\n            String targetPath = resource.getTargetPath();\n\n            File resourceDirectory = new File( resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() )\n            {\n                continue;\n            }\n\n            // If we only have a directory then we want to include\n            // everything we can find within that path.\n\n            String includes = resource.getIncludes();\n\n            if ( includes == null || includes.length() == 0 )\n            {\n                includes = \"**/**\";\n            }\n\n            String excludes = resource.getExcludes();\n\n            if ( excludes != null && excludes.length() > 0 )\n            {\n                excludes += \",\";\n            }\n            excludes += listToString( resource.getDefaultExcludes() );\n\n            List files = FileUtils.getFileNames( resourceDirectory, includes, excludes, false );\n\n            for ( Iterator j = files.iterator(); j.hasNext(); )\n            {\n                String name = (String) j.next();\n\n                String entryName = name;\n\n                if ( targetPath != null )\n                {\n                    entryName = targetPath + \"/\" + name;\n                }\n\n                ResourceEntry je = new ResourceEntry( new File( resource.getDirectory(), name ).getPath(), entryName );\n\n                resourceEntries.add( je );\n            }\n        }\n\n        return resourceEntries;\n    }","commit_id":"cd89f32322e5bbd0eafed5ae21601e93adb22f2b","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        String mavenRepoLocal = (String) request.getParameter( \"mavenRepoLocal\" );\n\n        String basedir = (String) request.getParameter( \"basedir\" );\n\n        String classesDirectory = (String) request.getParameter( \"classesDirectory\" );\n\n        String testClassesDirectory = (String) request.getParameter( \"testClassesDirectory\" );\n\n        List testClasspathElements = (List) request.getParameter( \"classpathElements\" );\n\n        String reportsDirectory = (String) request.getParameter( \"reportsDirectory\" );\n\n        String test = (String) request.getParameter( \"test\" );\n\n        // ----------------------------------------------------------------------\n        // Setup the surefire booter\n        // ----------------------------------------------------------------------\n\n        SurefireBooter surefireBooter = new SurefireBooter();\n\n        surefireBooter.setReportsDirectory( reportsDirectory );\n\n        // ----------------------------------------------------------------------\n        // Check to see if we are running a single test. The raw parameter will\n        // come through if it has not been set.\n        // ----------------------------------------------------------------------\n\n        if ( test != null )\n        {\n            // FooTest -> **/FooTest.java\n\n            List includes = new ArrayList();\n\n            List excludes = new ArrayList();\n\n            String[] testRegexes = split( test, \",\", -1 );\n\n            for ( int i = 0; i < testRegexes.length; i++ )\n            {\n                includes.add( \"**/\" + testRegexes[i] + \".java\" );\n            }\n\n            surefireBooter.addBattery( \"org.codehaus.surefire.battery.DirectoryBattery\", new Object[]{basedir, includes, excludes} );\n        }\n        else\n        {\n            List includes = (List) request.getParameter( \"includes\" );\n\n            List excludes = (List) request.getParameter( \"excludes\" );\n\n            surefireBooter.addBattery( \"org.codehaus.surefire.battery.DirectoryBattery\", new Object[]{basedir, includes, excludes} );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        System.setProperty( \"basedir\", basedir );\n\n        surefireBooter.addClassPathUrl( new File( mavenRepoLocal, \"junit/jars/junit-3.8.1.jar\" ).getPath() );\n\n        surefireBooter.addClassPathUrl( new File( mavenRepoLocal, \"surefire/jars/surefire-1.2-SNAPSHOT.jar\" ).getPath() );\n\n        surefireBooter.addClassPathUrl( new File( classesDirectory ).getPath() );\n\n        surefireBooter.addClassPathUrl( new File( testClassesDirectory ).getPath() );\n\n        for ( Iterator i = testClasspathElements.iterator(); i.hasNext(); )\n        {\n            surefireBooter.addClassPathUrl( (String) i.next() );\n        }\n\n        surefireBooter.addReport( \"org.codehaus.surefire.report.ConsoleReporter\" );\n\n        surefireBooter.addReport( \"org.codehaus.surefire.report.FileReporter\" );\n\n        boolean success = surefireBooter.run();\n\n        if ( !success )\n        {\n            response.setExecutionFailure( new SurefireFailureResponse( null ) );\n        }\n    }","id":44891,"modified_method":"public void execute( PluginExecutionRequest request, PluginExecutionResponse response )\n        throws Exception\n    {\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        String mavenRepoLocal = (String) request.getParameter( \"mavenRepoLocal\" );\n\n        String basedir = (String) request.getParameter( \"basedir\" );\n\n        String classesDirectory = (String) request.getParameter( \"classesDirectory\" );\n\n        String testClassesDirectory = (String) request.getParameter( \"testClassesDirectory\" );\n\n        List testClasspathElements = (List) request.getParameter( \"classpathElements\" );\n\n        String reportsDirectory = (String) request.getParameter( \"reportsDirectory\" );\n\n        String test = (String) request.getParameter( \"test\" );\n\n        // ----------------------------------------------------------------------\n        // Setup the surefire booter\n        // ----------------------------------------------------------------------\n\n        SurefireBooter surefireBooter = new SurefireBooter();\n\n        surefireBooter.setReportsDirectory( reportsDirectory );\n\n        // ----------------------------------------------------------------------\n        // Check to see if we are running a single test. The raw parameter will\n        // come through if it has not been set.\n        // ----------------------------------------------------------------------\n\n        if ( test != null )\n        {\n            // FooTest -> **/FooTest.java\n\n            List includes = new ArrayList();\n\n            List excludes = new ArrayList();\n\n            String[] testRegexes = split( test, \",\", -1 );\n\n            for ( int i = 0; i < testRegexes.length; i++ )\n            {\n                includes.add( \"**/\" + testRegexes[i] + \".java\" );\n            }\n\n            surefireBooter.addBattery( \"org.codehaus.surefire.battery.DirectoryBattery\",\n                                       new Object[]{basedir, includes, excludes} );\n        }\n        else\n        {\n            List includes = (List) request.getParameter( \"includes\" );\n\n            List excludes = (List) request.getParameter( \"excludes\" );\n\n            // defaults here, qdox doesn't like the end javadoc value\n            if ( includes == null )\n            {\n                includes = new ArrayList();\n                includes.add( \"**/*Test.java\" );\n            }\n            if ( excludes == null )\n            {\n                excludes = new ArrayList();\n                excludes.add( \"**/Abstract*Test.java\" );\n            }\n\n            surefireBooter.addBattery( \"org.codehaus.surefire.battery.DirectoryBattery\",\n                                       new Object[]{basedir, includes, excludes} );\n        }\n\n        // ----------------------------------------------------------------------\n        //\n        // ----------------------------------------------------------------------\n\n        System.setProperty( \"basedir\", basedir );\n\n        surefireBooter.addClassPathUrl( new File( mavenRepoLocal, \"junit/jars/junit-3.8.1.jar\" ).getPath() );\n\n        surefireBooter.addClassPathUrl(\n            new File( mavenRepoLocal, \"surefire/jars/surefire-1.2-SNAPSHOT.jar\" ).getPath() );\n\n        surefireBooter.addClassPathUrl( new File( classesDirectory ).getPath() );\n\n        surefireBooter.addClassPathUrl( new File( testClassesDirectory ).getPath() );\n\n        for ( Iterator i = testClasspathElements.iterator(); i.hasNext(); )\n        {\n            surefireBooter.addClassPathUrl( (String) i.next() );\n        }\n\n        surefireBooter.addReport( \"org.codehaus.surefire.report.ConsoleReporter\" );\n\n        surefireBooter.addReport( \"org.codehaus.surefire.report.FileReporter\" );\n\n        boolean success = surefireBooter.run();\n\n        if ( !success )\n        {\n            response.setExecutionFailure( new SurefireFailureResponse( null ) );\n        }\n    }","commit_id":"cd89f32322e5bbd0eafed5ae21601e93adb22f2b","url":"https://github.com/apache/maven-plugins"},{"original_method":"private Map getJarResources( List resources )\n        throws Exception\n    {\n        Map resourceEntries = new TreeMap();\n\n        for ( Iterator i = resources.iterator(); i.hasNext(); )\n        {\n            Resource resource = (Resource) i.next();\n\n            String targetPath = resource.getTargetPath();\n\n            File resourceDirectory = new File( resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() )\n            {\n                continue;\n            }\n\n            // If we only have a directory then we want to include\n            // everything we can find within that path.\n\n            String includesAsString = \"**/**\";\n\n            java.util.List includes = resource.getIncludes();\n            if ( includes != null && includes.size() > 0 )\n            {\n                includesAsString = StringUtils.join( includes.iterator(), \",\" );\n            }\n\n            List excludes = resource.getExcludes();\n\n            if ( excludes == null )\n            {\n                excludes = resource.getDefaultExcludes();\n            }\n            else\n            {\n                excludes = new ArrayList( excludes );\n                excludes.addAll( resource.getDefaultExcludes() );\n            }\n\n            String excludesAsString = StringUtils.join( excludes.iterator(), \",\" );\n\n            List files = FileUtils.getFileNames( resourceDirectory, includesAsString, excludesAsString, false );\n\n            for ( Iterator j = files.iterator(); j.hasNext(); )\n            {\n                String name = (String) j.next();\n\n                String entryName = name;\n\n                if ( targetPath != null )\n                {\n                    entryName = targetPath + \"/\" + name;\n                }\n\n                String resourcePath = new File( resource.getDirectory(), name ).getPath();\n\n                resourceEntries.put( resourcePath, entryName );\n            }\n        }\n\n        return resourceEntries;\n    }","id":44892,"modified_method":"private Map getJarResources( List resources )\n        throws Exception\n    {\n        Map resourceEntries = new TreeMap();\n\n        for ( Iterator i = resources.iterator(); i.hasNext(); )\n        {\n            Resource resource = (Resource) i.next();\n\n            String targetPath = resource.getTargetPath();\n\n            File resourceDirectory = new File( resource.getDirectory() );\n\n            if ( !resourceDirectory.exists() )\n            {\n                continue;\n            }\n\n            DirectoryScanner scanner = new DirectoryScanner();\n            scanner.addDefaultExcludes();\n\n            scanner.setBasedir( resource.getDirectory() );\n            if ( resource.getIncludes() != null && !resource.getIncludes().isEmpty() )\n            {\n                scanner.setIncludes( (String[]) resource.getIncludes().toArray( EMPTY_STRING_ARRAY ) );\n            }\n            else\n            {\n                scanner.setIncludes( DEFAULT_INCLUDES );\n            }\n            if ( resource.getExcludes() != null && !resource.getExcludes().isEmpty() )\n            {\n                scanner.setExcludes( (String[]) resource.getExcludes().toArray( EMPTY_STRING_ARRAY ) );\n            }\n\n            scanner.scan();\n\n            List includedFiles = Arrays.asList( scanner.getIncludedFiles() );\n            for ( Iterator j = includedFiles.iterator(); j.hasNext(); )\n            {\n                String name = (String) j.next();\n\n                String entryName = name;\n\n                if ( targetPath != null )\n                {\n                    entryName = targetPath + \"/\" + name;\n                }\n\n                resourceEntries.put( new File( resource.getDirectory(), name ), entryName );\n            }\n        }\n\n        return resourceEntries;\n    }","commit_id":"b4a06766d18e2e2a727e40f406f9cc5666eb4dfe","url":"https://github.com/apache/maven-plugins"},{"original_method":"protected void copyResources( List resources, String outputDirectory )\n        throws MojoExecutionException\n    {\n        try\n        {\n            for ( Iterator i = getJarResources( resources ).entrySet().iterator(); i.hasNext(); )\n            {\n                Map.Entry entry = (Map.Entry) i.next();\n                String source = (String) entry.getKey();\n                String destination = (String) entry.getValue();\n\n                File destinationFile = new File( outputDirectory, destination );\n\n                if ( !destinationFile.getParentFile().exists() )\n                {\n                    destinationFile.getParentFile().mkdirs();\n                }\n\n                fileCopy( source, destinationFile.getPath() );\n            }\n        }\n        catch ( Exception e )\n        {\n            // TODO: handle exception\n            throw new MojoExecutionException( \"Error copying resources\", e );\n        }\n    }","id":44893,"modified_method":"protected void copyResources( List resources, String outputDirectory )\n        throws MojoExecutionException\n    {\n        try\n        {\n            for ( Iterator i = getJarResources( resources ).entrySet().iterator(); i.hasNext(); )\n            {\n                Map.Entry entry = (Map.Entry) i.next();\n                File source = (File) entry.getKey();\n                String destination = (String) entry.getValue();\n\n                File destinationFile = new File( outputDirectory, destination );\n\n                if ( !destinationFile.getParentFile().exists() )\n                {\n                    destinationFile.getParentFile().mkdirs();\n                }\n\n                FileUtils.copyFile( source, destinationFile );\n            }\n        }\n        catch ( Exception e )\n        {\n            // TODO: handle exception\n            throw new MojoExecutionException( \"Error copying resources\", e );\n        }\n    }","commit_id":"b4a06766d18e2e2a727e40f406f9cc5666eb4dfe","url":"https://github.com/apache/maven-plugins"},{"original_method":"static int getDistance(final ClassNode receiver, final ClassNode compare) {\n        if (receiver.equals(compare)||receiver == UNKNOWN_PARAMETER_TYPE) return 0;\n        if (compare.isInterface() && receiver.implementsInterface(compare)) {\n            int dist = getMaximumInterfaceDistance(receiver, compare);\n            return dist;\n        }\n        ClassNode superClass = compare.getSuperClass();\n        if (superClass ==null) return 2;\n        return 1+getDistance(receiver, superClass);\n    }","id":44894,"modified_method":"static int getDistance(final ClassNode receiver, final ClassNode compare) {\n        int dist = 0;\n        ClassNode ref = compare;\n        while (ref!=null) {\n            if (receiver.equals(ref) || receiver == UNKNOWN_PARAMETER_TYPE) {\n                break;\n            }\n            if (ref.isInterface() && receiver.implementsInterface(ref)) {\n                dist += getMaximumInterfaceDistance(receiver, ref);\n                break;\n            }\n            ref = ref.getSuperClass();\n            if (ref == null) dist += 2;\n            dist++;\n        }\n        return dist;\n    }","commit_id":"a175626b8aabac6f4f8cd885fe99195b5d31a5c2","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        ClassNode actualReceiver;\n        for (MethodNode m : methods) {\n            actualReceiver = receiver!=null?receiver:m.getDeclaringClass();\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = parameterizeArguments(actualReceiver, m);\n            if (params.length > args.length && ! isVargs(params)) {\n                // GROOVY-5231\n                int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (params.length == args.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, args);\n                int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;\n                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (args.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length + 1) {\n                        if (bestDist > 1) {\n                            bestChoices.clear();\n                            bestChoices.add(m);\n                            bestDist = 1;\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int dist = excessArgumentsMatchesVargsParameter(params, args);\n                        if (dist >= 0 && !actualReceiver.equals(m.getDeclaringClass())) dist++;\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist++;\n                        if (params.length < args.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(m);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(m);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }","id":44895,"modified_method":"/**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        ClassNode actualReceiver;\n        Collection<MethodNode> choicesLeft = removeCovariants(methods);\n        for (MethodNode m : choicesLeft) {\n            actualReceiver = receiver!=null?receiver:m.getDeclaringClass();\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = parameterizeArguments(actualReceiver, m);\n            if (params.length > args.length && ! isVargs(params)) {\n                // GROOVY-5231\n                int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (params.length == args.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, args);\n                int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;\n                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (args.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length + 1) {\n                        if (bestDist > 1) {\n                            bestChoices.clear();\n                            bestChoices.add(m);\n                            bestDist = 1;\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int dist = excessArgumentsMatchesVargsParameter(params, args);\n                        if (dist >= 0 && !actualReceiver.equals(m.getDeclaringClass())) dist++;\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist++;\n                        if (params.length < args.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(m);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(m);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }","commit_id":"a175626b8aabac6f4f8cd885fe99195b5d31a5c2","url":"https://github.com/apache/groovy"},{"original_method":"/**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        ClassNode actualReceiver;\n        for (MethodNode m : methods) {\n            actualReceiver = receiver!=null?receiver:m.getDeclaringClass();\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = parameterizeArguments(actualReceiver, m);\n            if (params.length > args.length && ! isVargs(params)) {\n                // GROOVY-5231\n                int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (params.length == args.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, args);\n                int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;\n                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (args.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length + 1) {\n                        if (bestDist > 1) {\n                            bestChoices.clear();\n                            bestChoices.add(m);\n                            bestDist = 1;\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int dist = excessArgumentsMatchesVargsParameter(params, args);\n                        if (dist >= 0 && !actualReceiver.equals(m.getDeclaringClass())) dist++;\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist++;\n                        if (params.length < args.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(m);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(m);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }","id":44896,"modified_method":"/**\n     * Given a list of candidate methods, returns the one which best matches the argument types\n     *\n     * @param receiver\n     * @param methods candidate methods\n     * @param args argument types\n     * @return the list of methods which best matches the argument types. It is still possible that multiple\n     * methods match the argument types.\n     */\n    public static List<MethodNode> chooseBestMethod(final ClassNode receiver, Collection<MethodNode> methods, ClassNode... args) {\n        if (methods.isEmpty()) return Collections.emptyList();\n        List<MethodNode> bestChoices = new LinkedList<MethodNode>();\n        int bestDist = Integer.MAX_VALUE;\n        ClassNode actualReceiver;\n        Collection<MethodNode> choicesLeft = removeCovariants(methods);\n        for (MethodNode m : choicesLeft) {\n            actualReceiver = receiver!=null?receiver:m.getDeclaringClass();\n            // todo : corner case\n            /*\n                class B extends A {}\n\n                Animal foo(A o) {...}\n                Person foo(B i){...}\n\n                B  a = new B()\n                Person p = foo(b)\n             */\n\n            Parameter[] params = parameterizeArguments(actualReceiver, m);\n            if (params.length > args.length && ! isVargs(params)) {\n                // GROOVY-5231\n                int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (params.length == args.length) {\n                int allPMatch = allParametersAndArgumentsMatch(params, args);\n                int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;\n                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs\n                int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;\n                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());\n                if (dist>=0 && dist<bestDist) {\n                    bestChoices.clear();\n                    bestChoices.add(m);\n                    bestDist = dist;\n                } else if (dist>=0 && dist==bestDist) {\n                    bestChoices.add(m);\n                }\n            } else if (isVargs(params)) {\n                boolean firstParamMatches = true;\n                // check first parameters\n                if (args.length > 0) {\n                    Parameter[] firstParams = new Parameter[params.length - 1];\n                    System.arraycopy(params, 0, firstParams, 0, firstParams.length);\n                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;\n                }\n                if (firstParamMatches) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length + 1) {\n                        if (bestDist > 1) {\n                            bestChoices.clear();\n                            bestChoices.add(m);\n                            bestDist = 1;\n                        }\n                    } else {\n                        // (2) last argument is put in the vargs array\n                        //      that case is handled above already\n                        // (3) there is more than one argument for the vargs array\n                        int dist = excessArgumentsMatchesVargsParameter(params, args);\n                        if (dist >= 0 && !actualReceiver.equals(m.getDeclaringClass())) dist++;\n                        // varargs methods must not be preferred to methods without varargs\n                        // for example :\n                        // int sum(int x) should be preferred to int sum(int x, int... y)\n                        dist++;\n                        if (params.length < args.length && dist >= 0) {\n                            if (dist >= 0 && dist < bestDist) {\n                                bestChoices.clear();\n                                bestChoices.add(m);\n                                bestDist = dist;\n                            } else if (dist >= 0 && dist == bestDist) {\n                                bestChoices.add(m);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return bestChoices;\n    }","commit_id":"7bebe355a9fc32bea05c05f5906e795abb175049","url":"https://github.com/apache/groovy"},{"original_method":"static int getDistance(final ClassNode receiver, final ClassNode compare) {\n        if (receiver.equals(compare)||receiver == UNKNOWN_PARAMETER_TYPE) return 0;\n        if (compare.isInterface() && receiver.implementsInterface(compare)) {\n            int dist = getMaximumInterfaceDistance(receiver, compare);\n            return dist;\n        }\n        ClassNode superClass = compare.getSuperClass();\n        if (superClass ==null) return 2;\n        return 1+getDistance(receiver, superClass);\n    }","id":44897,"modified_method":"static int getDistance(final ClassNode receiver, final ClassNode compare) {\n        int dist = 0;\n        ClassNode ref = compare;\n        while (ref!=null) {\n            if (receiver.equals(ref) || receiver == UNKNOWN_PARAMETER_TYPE) {\n                break;\n            }\n            if (ref.isInterface() && receiver.implementsInterface(ref)) {\n                dist += getMaximumInterfaceDistance(receiver, ref);\n                break;\n            }\n            ref = ref.getSuperClass();\n            if (ref == null) dist += 2;\n            dist++;\n        }\n        return dist;\n    }","commit_id":"7bebe355a9fc32bea05c05f5906e795abb175049","url":"https://github.com/apache/groovy"},{"original_method":"private void writeNumberNumberCall(final Expression receiver, final String message, final Expression arguments) {\n        OperandStack operandStack = controller.getOperandStack();\n        int m1 = operandStack.getStackLength();\n        //slow Path\n        prepareSiteAndReceiver(receiver, message, false, controller.getCompileStack().isLHS());\n        controller.getOperandStack().doGroovyCast(ClassHelper.Number_TYPE);\n        visitBoxedArgument(arguments);\n        controller.getOperandStack().doGroovyCast(ClassHelper.Number_TYPE);\n        int m2 = operandStack.getStackLength();\n        MethodVisitor mv = controller.getMethodVisitor();\n        mv.visitMethodInsn(INVOKESTATIC,\n                \"org/codehaus/groovy/runtime/dgmimpl/NumberNumber\" + MetaClassHelper.capitalize(message),\n                message,\n                \"(Ljava/lang/Number;Ljava/lang/Number;)Ljava/lang/Number;\");\n        controller.getOperandStack().replace(ClassHelper.Number_TYPE, m2 - m1);\n    }","id":44898,"modified_method":"private void writeNumberNumberCall(final Expression receiver, final String message, final Expression arguments) {\n        OperandStack operandStack = controller.getOperandStack();\n        int m1 = operandStack.getStackLength();\n        //slow Path\n        prepareSiteAndReceiver(receiver, message, false, controller.getCompileStack().isLHS());\n        controller.getOperandStack().doGroovyCast(Number_TYPE);\n        visitBoxedArgument(arguments);\n        controller.getOperandStack().doGroovyCast(Number_TYPE);\n        int m2 = operandStack.getStackLength();\n        MethodVisitor mv = controller.getMethodVisitor();\n        mv.visitMethodInsn(INVOKESTATIC,\n                \"org/codehaus/groovy/runtime/dgmimpl/NumberNumber\" + MetaClassHelper.capitalize(message),\n                message,\n                \"(Ljava/lang/Number;Ljava/lang/Number;)Ljava/lang/Number;\");\n        controller.getOperandStack().replace(Number_TYPE, m2 - m1);\n    }","commit_id":"4a1a3cdf1b06d57647fcf9cc9c49a512043da7ff","url":"https://github.com/apache/groovy"},{"original_method":"private void writeArrayGet(final Expression receiver, final Expression arguments, final ClassNode rType, final ClassNode aType) {\n        OperandStack operandStack = controller.getOperandStack();\n        int m1 = operandStack.getStackLength();\n        // visit receiver\n        receiver.visit(controller.getAcg());\n        // visit arguments as array index\n        arguments.visit(controller.getAcg());\n        operandStack.doGroovyCast(ClassHelper.int_TYPE);\n        int m2 = operandStack.getStackLength();\n        // array access\n        controller.getMethodVisitor().visitInsn(AALOAD);\n        operandStack.replace(rType.getComponentType(), m2-m1);\n    }","id":44899,"modified_method":"private void writeArrayGet(final Expression receiver, final Expression arguments, final ClassNode rType, final ClassNode aType) {\n        OperandStack operandStack = controller.getOperandStack();\n        int m1 = operandStack.getStackLength();\n        // visit receiver\n        receiver.visit(controller.getAcg());\n        // visit arguments as array index\n        arguments.visit(controller.getAcg());\n        operandStack.doGroovyCast(int_TYPE);\n        int m2 = operandStack.getStackLength();\n        // array access\n        controller.getMethodVisitor().visitInsn(AALOAD);\n        operandStack.replace(rType.getComponentType(), m2-m1);\n    }","commit_id":"4a1a3cdf1b06d57647fcf9cc9c49a512043da7ff","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void makeGetPropertySite(Expression receiver, final String methodName, final boolean safe, final boolean implicitThis) {\n        TypeChooser typeChooser = controller.getTypeChooser();\n        ClassNode classNode = controller.getClassNode();\n        ClassNode receiverType = typeChooser.resolveType(receiver, classNode);\n        Object type = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n        if (type==null && receiver instanceof VariableExpression) {\n            Variable variable = ((VariableExpression) receiver).getAccessedVariable();\n            if (variable instanceof Expression) {\n                type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n            }\n        }\n        if (type!=null) {\n            // in case a \"flow type\" is found, it is preferred to use it instead of\n            // the declaration type\n            receiverType = (ClassNode) type;\n        }\n        boolean isClassReceiver = false;\n        if (receiverType.equals(ClassHelper.CLASS_Type)\n                && receiverType.getGenericsTypes()!=null\n                && !receiverType.getGenericsTypes()[0].isPlaceholder()) {\n            isClassReceiver = true;\n            receiverType = receiverType.getGenericsTypes()[0].getType();\n        }\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        boolean isStaticProperty = receiver instanceof ClassExpression\n                && (receiverType.isDerivedFrom(receiver.getType()) || receiverType.implementsInterface(receiver.getType()));\n\n        if (!isStaticProperty) {\n            if (receiverType.implementsInterface(ClassHelper.MAP_TYPE)) {\n                // for maps, replace map.foo with map.get('foo')\n                writeMapDotProperty(receiver, methodName, mv);\n                return;\n            }\n            if (receiverType.implementsInterface(ClassHelper.LIST_TYPE)) {\n                writeListDotProperty(receiver, methodName, mv);\n                return;\n            }\n        }\n\n        if (receiverType.isArray() && methodName.equals(\"length\")) {\n            receiver.visit(controller.getAcg());\n            mv.visitInsn(ARRAYLENGTH);\n            controller.getOperandStack().replace(ClassHelper.int_TYPE);\n            return;\n        } else if (receiverType.implementsInterface(COLLECTION_TYPE) && (\"size\".equals(methodName) || \"length\".equals(methodName))) {\n            MethodCallExpression expr = new MethodCallExpression(\n                    receiver,\n                    \"size\",\n                    ArgumentListExpression.EMPTY_ARGUMENTS\n            );\n            expr.setMethodTarget(COLLECTION_SIZE_METHOD);\n            expr.setImplicitThis(implicitThis);\n            expr.setSafe(safe);\n            expr.visit(controller.getAcg());\n            return;\n        }\n        if (makeGetPropertyWithGetter(receiver, receiverType, methodName, safe, implicitThis)) return;\n        if (makeGetField(receiver, receiverType, methodName, implicitThis, samePackages(receiverType.getPackageName(), classNode.getPackageName()))) return;\n        if (receiverType.isEnum()) {\n            mv.visitFieldInsn(GETSTATIC, BytecodeHelper.getClassInternalName(receiverType), methodName, BytecodeHelper.getTypeDescription(receiverType));\n            controller.getOperandStack().push(receiverType);\n            return;\n        }\n        if (receiver instanceof ClassExpression) {\n            if (makeGetField(receiver, receiver.getType(), methodName, implicitThis, samePackages(receiver.getType().getPackageName(), classNode.getPackageName()))) return;\n            if (makeGetPropertyWithGetter(receiver, receiver.getType(), methodName, safe, implicitThis)) return;\n        }\n        if (isClassReceiver) {\n            // we are probably looking for a property of the class\n            if (makeGetPropertyWithGetter(receiver, ClassHelper.CLASS_Type, methodName, safe, implicitThis)) return;\n            if (makeGetField(receiver, ClassHelper.CLASS_Type, methodName, false, true)) return;\n        }\n        if (makeGetPrivateFieldWithBridgeMethod(receiver, receiverType, methodName, safe, implicitThis)) return;\n\n        // GROOVY-5580, it is still possible that we're calling a superinterface property\n        String getterName = \"get\" + MetaClassHelper.capitalize(methodName);\n        if (receiverType.isInterface()) {\n            Set<ClassNode> allInterfaces = receiverType.getAllInterfaces();\n            MethodNode getterMethod = null;\n            for (ClassNode anInterface : allInterfaces) {\n                getterMethod = anInterface.getGetterMethod(getterName);\n                if (getterMethod!=null) break;\n            }\n            // GROOVY-5585\n            if (getterMethod==null) {\n                getterMethod = ClassHelper.OBJECT_TYPE.getGetterMethod(getterName);\n            }\n\n            if (getterMethod!=null) {\n                MethodCallExpression call = new MethodCallExpression(\n                        receiver,\n                        getterName,\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                call.setMethodTarget(getterMethod);\n                call.setImplicitThis(false);\n                call.setSourcePosition(receiver);\n                call.visit(controller.getAcg());\n                return;\n            }\n\n        }\n\n        // GROOVY-5568, we would be facing a DGM call, but instead of foo.getText(), have foo.text\n        List<MethodNode> methods = findDGMMethodsByNameAndArguments(receiverType, getterName, ClassNode.EMPTY_ARRAY);\n        if (!methods.isEmpty()) {\n            List<MethodNode> methodNodes = chooseBestMethod(receiverType, methods, ClassNode.EMPTY_ARRAY);\n            if (methodNodes.size()==1) {\n                MethodNode getter = methodNodes.get(0);\n                MethodCallExpression call = new MethodCallExpression(\n                        receiver,\n                        getterName,\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                call.setMethodTarget(getter);\n                call.setImplicitThis(false);\n                call.setSourcePosition(receiver);\n                call.visit(controller.getAcg());\n                return;\n            }\n        }\n\n        controller.getSourceUnit().addError(\n                new SyntaxException(\"Access to \"+\n                                                (receiver instanceof ClassExpression ?receiver.getType():receiverType).toString(false)\n                                                +\"#\"+methodName+\" is forbidden\", receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber())\n        );\n        controller.getMethodVisitor().visitInsn(ACONST_NULL);\n        controller.getOperandStack().push(ClassHelper.OBJECT_TYPE);\n    }","id":44900,"modified_method":"@Override\n    public void makeGetPropertySite(Expression receiver, final String methodName, final boolean safe, final boolean implicitThis) {\n        TypeChooser typeChooser = controller.getTypeChooser();\n        ClassNode classNode = controller.getClassNode();\n        ClassNode receiverType = typeChooser.resolveType(receiver, classNode);\n        Object type = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n        if (type==null && receiver instanceof VariableExpression) {\n            Variable variable = ((VariableExpression) receiver).getAccessedVariable();\n            if (variable instanceof Expression) {\n                type = ((Expression) variable).getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);\n            }\n        }\n        if (type!=null) {\n            // in case a \"flow type\" is found, it is preferred to use it instead of\n            // the declaration type\n            receiverType = (ClassNode) type;\n        }\n        boolean isClassReceiver = false;\n        if (receiverType.equals(CLASS_Type)\n                && receiverType.getGenericsTypes()!=null\n                && !receiverType.getGenericsTypes()[0].isPlaceholder()) {\n            isClassReceiver = true;\n            receiverType = receiverType.getGenericsTypes()[0].getType();\n        }\n        MethodVisitor mv = controller.getMethodVisitor();\n\n        boolean isStaticProperty = receiver instanceof ClassExpression\n                && (receiverType.isDerivedFrom(receiver.getType()) || receiverType.implementsInterface(receiver.getType()));\n\n        if (!isStaticProperty) {\n            if (receiverType.implementsInterface(MAP_TYPE) || MAP_TYPE.equals(receiverType)) {\n                // for maps, replace map.foo with map.get('foo')\n                writeMapDotProperty(receiver, methodName, mv);\n                return;\n            }\n            if (receiverType.implementsInterface(LIST_TYPE) || LIST_TYPE.equals(receiverType)) {\n                writeListDotProperty(receiver, methodName, mv);\n                return;\n            }\n        }\n\n        if (receiverType.isArray() && methodName.equals(\"length\")) {\n            receiver.visit(controller.getAcg());\n            mv.visitInsn(ARRAYLENGTH);\n            controller.getOperandStack().replace(int_TYPE);\n            return;\n        } else if (\n                (receiverType.implementsInterface(COLLECTION_TYPE)\n                        || COLLECTION_TYPE.equals(receiverType)) && (\"size\".equals(methodName) || \"length\".equals(methodName))) {\n            MethodCallExpression expr = new MethodCallExpression(\n                    receiver,\n                    \"size\",\n                    ArgumentListExpression.EMPTY_ARGUMENTS\n            );\n            expr.setMethodTarget(COLLECTION_SIZE_METHOD);\n            expr.setImplicitThis(implicitThis);\n            expr.setSafe(safe);\n            expr.visit(controller.getAcg());\n            return;\n        }\n        if (makeGetPropertyWithGetter(receiver, receiverType, methodName, safe, implicitThis)) return;\n        if (makeGetField(receiver, receiverType, methodName, implicitThis, samePackages(receiverType.getPackageName(), classNode.getPackageName()))) return;\n        if (receiverType.isEnum()) {\n            mv.visitFieldInsn(GETSTATIC, BytecodeHelper.getClassInternalName(receiverType), methodName, BytecodeHelper.getTypeDescription(receiverType));\n            controller.getOperandStack().push(receiverType);\n            return;\n        }\n        if (receiver instanceof ClassExpression) {\n            if (makeGetField(receiver, receiver.getType(), methodName, implicitThis, samePackages(receiver.getType().getPackageName(), classNode.getPackageName()))) return;\n            if (makeGetPropertyWithGetter(receiver, receiver.getType(), methodName, safe, implicitThis)) return;\n        }\n        if (isClassReceiver) {\n            // we are probably looking for a property of the class\n            if (makeGetPropertyWithGetter(receiver, CLASS_Type, methodName, safe, implicitThis)) return;\n            if (makeGetField(receiver, CLASS_Type, methodName, false, true)) return;\n        }\n        if (makeGetPrivateFieldWithBridgeMethod(receiver, receiverType, methodName, safe, implicitThis)) return;\n\n        // GROOVY-5580, it is still possible that we're calling a superinterface property\n        String getterName = \"get\" + MetaClassHelper.capitalize(methodName);\n        if (receiverType.isInterface()) {\n            Set<ClassNode> allInterfaces = receiverType.getAllInterfaces();\n            MethodNode getterMethod = null;\n            for (ClassNode anInterface : allInterfaces) {\n                getterMethod = anInterface.getGetterMethod(getterName);\n                if (getterMethod!=null) break;\n            }\n            // GROOVY-5585\n            if (getterMethod==null) {\n                getterMethod = OBJECT_TYPE.getGetterMethod(getterName);\n            }\n\n            if (getterMethod!=null) {\n                MethodCallExpression call = new MethodCallExpression(\n                        receiver,\n                        getterName,\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                call.setMethodTarget(getterMethod);\n                call.setImplicitThis(false);\n                call.setSourcePosition(receiver);\n                call.visit(controller.getAcg());\n                return;\n            }\n\n        }\n\n        // GROOVY-5568, we would be facing a DGM call, but instead of foo.getText(), have foo.text\n        List<MethodNode> methods = findDGMMethodsByNameAndArguments(receiverType, getterName, ClassNode.EMPTY_ARRAY);\n        if (!methods.isEmpty()) {\n            List<MethodNode> methodNodes = chooseBestMethod(receiverType, methods, ClassNode.EMPTY_ARRAY);\n            if (methodNodes.size()==1) {\n                MethodNode getter = methodNodes.get(0);\n                MethodCallExpression call = new MethodCallExpression(\n                        receiver,\n                        getterName,\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                call.setMethodTarget(getter);\n                call.setImplicitThis(false);\n                call.setSourcePosition(receiver);\n                call.visit(controller.getAcg());\n                return;\n            }\n        }\n\n        controller.getSourceUnit().addError(\n                new SyntaxException(\"Access to \"+\n                                                (receiver instanceof ClassExpression ?receiver.getType():receiverType).toString(false)\n                                                +\"#\"+methodName+\" is forbidden\", receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber())\n        );\n        controller.getMethodVisitor().visitInsn(ACONST_NULL);\n        controller.getOperandStack().push(OBJECT_TYPE);\n    }","commit_id":"4a1a3cdf1b06d57647fcf9cc9c49a512043da7ff","url":"https://github.com/apache/groovy"},{"original_method":"private void writeStringPlusCall(final Expression receiver, final String message, final Expression arguments) {\n        // todo: performance would be better if we created a StringBuilder\n        OperandStack operandStack = controller.getOperandStack();\n        int m1 = operandStack.getStackLength();\n        //slow Path\n        prepareSiteAndReceiver(receiver, message, false, controller.getCompileStack().isLHS());\n        visitBoxedArgument(arguments);\n        int m2 = operandStack.getStackLength();\n        MethodVisitor mv = controller.getMethodVisitor();\n        mv.visitMethodInsn(INVOKESTATIC,\n                \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                \"plus\",\n                \"(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/String;\");\n        controller.getOperandStack().replace(ClassHelper.STRING_TYPE, m2-m1);\n    }","id":44901,"modified_method":"private void writeStringPlusCall(final Expression receiver, final String message, final Expression arguments) {\n        // todo: performance would be better if we created a StringBuilder\n        OperandStack operandStack = controller.getOperandStack();\n        int m1 = operandStack.getStackLength();\n        //slow Path\n        prepareSiteAndReceiver(receiver, message, false, controller.getCompileStack().isLHS());\n        visitBoxedArgument(arguments);\n        int m2 = operandStack.getStackLength();\n        MethodVisitor mv = controller.getMethodVisitor();\n        mv.visitMethodInsn(INVOKESTATIC,\n                \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                \"plus\",\n                \"(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/String;\");\n        controller.getOperandStack().replace(STRING_TYPE, m2-m1);\n    }","commit_id":"4a1a3cdf1b06d57647fcf9cc9c49a512043da7ff","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n    public void makeSingleArgumentCall(final Expression receiver, final String message, final Expression arguments) {\n        TypeChooser typeChooser = controller.getTypeChooser();\n        ClassNode classNode = controller.getClassNode();\n        ClassNode rType = typeChooser.resolveType(receiver, classNode);\n        ClassNode aType = typeChooser.resolveType(arguments, classNode);\n        if (ClassHelper.getWrapper(rType).isDerivedFrom(ClassHelper.Number_TYPE)\n                && ClassHelper.getWrapper(aType).isDerivedFrom(ClassHelper.Number_TYPE)) {\n            if (\"plus\".equals(message) || \"minus\".equals(message) || \"multiply\".equals(message) || \"div\".equals(message)) {\n                writeNumberNumberCall(receiver, message, arguments);\n                return;\n            } else if (\"power\".equals(message)) {\n                writePowerCall(receiver, arguments, rType, aType);\n                return;\n            }\n        } else if (ClassHelper.STRING_TYPE.equals(rType) && \"plus\".equals(message)) {\n            writeStringPlusCall(receiver, message, arguments);\n            return;\n        } else if (rType.isArray() && \"getAt\".equals(message)) {\n            writeArrayGet(receiver, arguments, rType, aType);\n            return;\n        }\n\n        // check if a getAt method can be found on the receiver\n        ClassNode current = rType;\n        MethodNode getAtNode = null;\n        while (current!=null && getAtNode==null) {\n            getAtNode = current.getMethod(\"getAt\", new Parameter[]{new Parameter(aType, \"index\")});\n            current = current.getSuperClass();\n        }\n        if (getAtNode!=null) {\n            MethodCallExpression call = new MethodCallExpression(\n                    receiver,\n                    \"getAt\",\n                    arguments\n            );\n            call.setSourcePosition(arguments);\n            call.setImplicitThis(false);\n            call.setMethodTarget(getAtNode);\n            call.visit(controller.getAcg());\n            return;\n        }\n\n        // make sure Map#getAt() and List#getAt handled with the bracket syntax are properly compiled\n        ClassNode[] args = {aType};\n        boolean acceptAnyMethod =\n                ClassHelper.MAP_TYPE.equals(rType) || rType.implementsInterface(ClassHelper.MAP_TYPE)\n                || ClassHelper.LIST_TYPE.equals(rType) || rType.implementsInterface(ClassHelper.LIST_TYPE);\n        List<MethodNode> nodes = StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments(rType, message, args);\n        nodes = StaticTypeCheckingSupport.chooseBestMethod(rType, nodes, args);\n        if (nodes.size()==1 || nodes.size()>1 && acceptAnyMethod) {\n            MethodNode methodNode = nodes.get(0);\n            MethodCallExpression call = new MethodCallExpression(\n                    receiver,\n                    message,\n                    arguments\n            );\n            call.setSourcePosition(arguments);\n            call.setImplicitThis(false);\n            call.setMethodTarget(methodNode);\n            call.visit(controller.getAcg());\n            return;\n        }\n        // todo: more cases\n        throw new GroovyBugError(\n                \"At line \"+receiver.getLineNumber() + \" column \" + receiver.getColumnNumber() + \"\\n\" +\n                \"On receiver: \"+receiver.getText() + \" with message: \"+message+\" and arguments: \"+arguments.getText()+\"\\n\"+\n                \"This method should not have been called. Please try to create a simple example reproducing this error and file\" +\n                \"a bug report at http://jira.codehaus.org/browse/GROOVY\");\n    }","id":44902,"modified_method":"@Override\n    public void makeSingleArgumentCall(final Expression receiver, final String message, final Expression arguments) {\n        TypeChooser typeChooser = controller.getTypeChooser();\n        ClassNode classNode = controller.getClassNode();\n        ClassNode rType = typeChooser.resolveType(receiver, classNode);\n        ClassNode aType = typeChooser.resolveType(arguments, classNode);\n        if (getWrapper(rType).isDerivedFrom(Number_TYPE)\n                && getWrapper(aType).isDerivedFrom(Number_TYPE)) {\n            if (\"plus\".equals(message) || \"minus\".equals(message) || \"multiply\".equals(message) || \"div\".equals(message)) {\n                writeNumberNumberCall(receiver, message, arguments);\n                return;\n            } else if (\"power\".equals(message)) {\n                writePowerCall(receiver, arguments, rType, aType);\n                return;\n            }\n        } else if (STRING_TYPE.equals(rType) && \"plus\".equals(message)) {\n            writeStringPlusCall(receiver, message, arguments);\n            return;\n        } else if (rType.isArray() && \"getAt\".equals(message)) {\n            writeArrayGet(receiver, arguments, rType, aType);\n            return;\n        }\n\n        // check if a getAt method can be found on the receiver\n        ClassNode current = rType;\n        MethodNode getAtNode = null;\n        while (current!=null && getAtNode==null) {\n            getAtNode = current.getMethod(\"getAt\", new Parameter[]{new Parameter(aType, \"index\")});\n            current = current.getSuperClass();\n        }\n        if (getAtNode!=null) {\n            MethodCallExpression call = new MethodCallExpression(\n                    receiver,\n                    \"getAt\",\n                    arguments\n            );\n            call.setSourcePosition(arguments);\n            call.setImplicitThis(false);\n            call.setMethodTarget(getAtNode);\n            call.visit(controller.getAcg());\n            return;\n        }\n\n        // make sure Map#getAt() and List#getAt handled with the bracket syntax are properly compiled\n        ClassNode[] args = {aType};\n        boolean acceptAnyMethod =\n                MAP_TYPE.equals(rType) || rType.implementsInterface(MAP_TYPE)\n                || LIST_TYPE.equals(rType) || rType.implementsInterface(LIST_TYPE);\n        List<MethodNode> nodes = StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments(rType, message, args);\n        nodes = StaticTypeCheckingSupport.chooseBestMethod(rType, nodes, args);\n        if (nodes.size()==1 || nodes.size()>1 && acceptAnyMethod) {\n            MethodNode methodNode = nodes.get(0);\n            MethodCallExpression call = new MethodCallExpression(\n                    receiver,\n                    message,\n                    arguments\n            );\n            call.setSourcePosition(arguments);\n            call.setImplicitThis(false);\n            call.setMethodTarget(methodNode);\n            call.visit(controller.getAcg());\n            return;\n        }\n        // todo: more cases\n        throw new GroovyBugError(\n                \"At line \"+receiver.getLineNumber() + \" column \" + receiver.getColumnNumber() + \"\\n\" +\n                \"On receiver: \"+receiver.getText() + \" with message: \"+message+\" and arguments: \"+arguments.getText()+\"\\n\"+\n                \"This method should not have been called. Please try to create a simple example reproducing this error and file\" +\n                \"a bug report at http://jira.codehaus.org/browse/GROOVY\");\n    }","commit_id":"4a1a3cdf1b06d57647fcf9cc9c49a512043da7ff","url":"https://github.com/apache/groovy"},{"original_method":"private void writePowerCall(Expression receiver, Expression arguments, final ClassNode rType, ClassNode aType) {\n        OperandStack operandStack = controller.getOperandStack();\n        int m1 = operandStack.getStackLength();\n        //slow Path\n        prepareSiteAndReceiver(receiver, \"power\", false, controller.getCompileStack().isLHS());\n        visitBoxedArgument(arguments);\n        int m2 = operandStack.getStackLength();\n        MethodVisitor mv = controller.getMethodVisitor();\n        if (ClassHelper.BigDecimal_TYPE.equals(rType) && ClassHelper.Integer_TYPE.equals(ClassHelper.getWrapper(aType))) {\n            mv.visitMethodInsn(INVOKESTATIC,\n                    \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                    \"power\",\n                    \"(Ljava/math/BigDecimal;Ljava/lang/Integer;)Ljava/lang/Number;\");\n        } else if (ClassHelper.BigInteger_TYPE.equals(rType) && ClassHelper.Integer_TYPE.equals(ClassHelper.getWrapper(aType))) {\n            mv.visitMethodInsn(INVOKESTATIC,\n                    \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                    \"power\",\n                    \"(Ljava/math/BigInteger;Ljava/lang/Integer;)Ljava/lang/Number;\");\n        } else if (ClassHelper.Long_TYPE.equals(ClassHelper.getWrapper(rType)) && ClassHelper.Integer_TYPE.equals(ClassHelper.getWrapper(aType))) {\n            mv.visitMethodInsn(INVOKESTATIC,\n                    \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                    \"power\",\n                    \"(Ljava/lang/Long;Ljava/lang/Integer;)Ljava/lang/Number;\");\n        } else if (ClassHelper.Integer_TYPE.equals(ClassHelper.getWrapper(rType)) && ClassHelper.Integer_TYPE.equals(ClassHelper.getWrapper(aType))) {\n            mv.visitMethodInsn(INVOKESTATIC,\n                    \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                    \"power\",\n                    \"(Ljava/lang/Integer;Ljava/lang/Integer;)Ljava/lang/Number;\");\n        } else {\n            mv.visitMethodInsn(INVOKESTATIC,\n                    \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                    \"power\",\n                    \"(Ljava/lang/Number;Ljava/lang/Number;)Ljava/lang/Number;\");\n        }\n        controller.getOperandStack().replace(ClassHelper.Number_TYPE, m2 - m1);\n    }","id":44903,"modified_method":"private void writePowerCall(Expression receiver, Expression arguments, final ClassNode rType, ClassNode aType) {\n        OperandStack operandStack = controller.getOperandStack();\n        int m1 = operandStack.getStackLength();\n        //slow Path\n        prepareSiteAndReceiver(receiver, \"power\", false, controller.getCompileStack().isLHS());\n        visitBoxedArgument(arguments);\n        int m2 = operandStack.getStackLength();\n        MethodVisitor mv = controller.getMethodVisitor();\n        if (BigDecimal_TYPE.equals(rType) && Integer_TYPE.equals(getWrapper(aType))) {\n            mv.visitMethodInsn(INVOKESTATIC,\n                    \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                    \"power\",\n                    \"(Ljava/math/BigDecimal;Ljava/lang/Integer;)Ljava/lang/Number;\");\n        } else if (BigInteger_TYPE.equals(rType) && Integer_TYPE.equals(getWrapper(aType))) {\n            mv.visitMethodInsn(INVOKESTATIC,\n                    \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                    \"power\",\n                    \"(Ljava/math/BigInteger;Ljava/lang/Integer;)Ljava/lang/Number;\");\n        } else if (Long_TYPE.equals(getWrapper(rType)) && Integer_TYPE.equals(getWrapper(aType))) {\n            mv.visitMethodInsn(INVOKESTATIC,\n                    \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                    \"power\",\n                    \"(Ljava/lang/Long;Ljava/lang/Integer;)Ljava/lang/Number;\");\n        } else if (Integer_TYPE.equals(getWrapper(rType)) && Integer_TYPE.equals(getWrapper(aType))) {\n            mv.visitMethodInsn(INVOKESTATIC,\n                    \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                    \"power\",\n                    \"(Ljava/lang/Integer;Ljava/lang/Integer;)Ljava/lang/Number;\");\n        } else {\n            mv.visitMethodInsn(INVOKESTATIC,\n                    \"org/codehaus/groovy/runtime/DefaultGroovyMethods\",\n                    \"power\",\n                    \"(Ljava/lang/Number;Ljava/lang/Number;)Ljava/lang/Number;\");\n        }\n        controller.getOperandStack().replace(Number_TYPE, m2 - m1);\n    }","commit_id":"4a1a3cdf1b06d57647fcf9cc9c49a512043da7ff","url":"https://github.com/apache/groovy"},{"original_method":"private void writeListDotProperty(final Expression receiver, final String methodName, final MethodVisitor mv) {\n        ClassNode componentType = (ClassNode) receiver.getNodeMetaData(StaticCompilationMetadataKeys.COMPONENT_TYPE);\n        if (componentType==null) {\n            componentType = ClassHelper.OBJECT_TYPE;\n        }\n        // for lists, replace list.foo with:\n        // def result = new ArrayList(list.size())\n        // for (e in list) { result.add (e.foo) }\n        // result\n        CompileStack compileStack = controller.getCompileStack();\n        Variable tmpList = new VariableExpression(\"tmpList\", ClassHelper.make(ArrayList.class));\n        int var = compileStack.defineTemporaryVariable(tmpList, false);\n        Variable iterator = new VariableExpression(\"iterator\", ClassHelper.Iterator_TYPE);\n        int it = compileStack.defineTemporaryVariable(iterator, false);\n        Variable nextVar = new VariableExpression(\"next\", componentType);\n        final int next = compileStack.defineTemporaryVariable(nextVar, false);\n\n        mv.visitTypeInsn(NEW, \"java/util/ArrayList\");\n        mv.visitInsn(DUP);\n        receiver.visit(controller.getAcg());\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/List\", \"size\", \"()I\");\n        controller.getOperandStack().remove(1);\n        mv.visitMethodInsn(INVOKESPECIAL, \"java/util/ArrayList\", \"<init>\", \"(I)V\");\n        mv.visitVarInsn(ASTORE, var);\n        Label l1 = new Label();\n        mv.visitLabel(l1);\n        receiver.visit(controller.getAcg());\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/List\", \"iterator\", \"()Ljava/util/Iterator;\");\n        controller.getOperandStack().remove(1);\n        mv.visitVarInsn(ASTORE, it);\n        Label l2 = new Label();\n        mv.visitLabel(l2);\n        mv.visitVarInsn(ALOAD, it);\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Iterator\", \"hasNext\", \"()Z\");\n        Label l3 = new Label();\n        mv.visitJumpInsn(IFEQ, l3);\n        mv.visitVarInsn(ALOAD, it);\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Iterator\", \"next\", \"()Ljava/lang/Object;\");\n        mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(componentType));\n        mv.visitVarInsn(ASTORE, next);\n        Label l4 = new Label();\n        mv.visitLabel(l4);\n        mv.visitVarInsn(ALOAD, var);\n        final ClassNode finalComponentType = componentType;\n        PropertyExpression pexp = new PropertyExpression(new BytecodeExpression() {\n            @Override\n            public void visit(final MethodVisitor mv) {\n                mv.visitVarInsn(ALOAD, next);\n            }\n\n            @Override\n            public ClassNode getType() {\n                return finalComponentType;\n            }\n        }, methodName);\n        pexp.visit(controller.getAcg());\n        controller.getOperandStack().box();\n        controller.getOperandStack().remove(1);\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/List\", \"add\", \"(Ljava/lang/Object;)Z\");\n        mv.visitInsn(POP);\n        Label l5 = new Label();\n        mv.visitLabel(l5);\n        mv.visitJumpInsn(GOTO, l2);\n        mv.visitLabel(l3);\n        mv.visitVarInsn(ALOAD, var);\n        controller.getOperandStack().push(ClassHelper.make(ArrayList.class));\n        controller.getCompileStack().removeVar(next);\n        controller.getCompileStack().removeVar(it);\n        controller.getCompileStack().removeVar(var);\n    }","id":44904,"modified_method":"private void writeListDotProperty(final Expression receiver, final String methodName, final MethodVisitor mv) {\n        ClassNode componentType = (ClassNode) receiver.getNodeMetaData(StaticCompilationMetadataKeys.COMPONENT_TYPE);\n        if (componentType==null) {\n            componentType = OBJECT_TYPE;\n        }\n        // for lists, replace list.foo with:\n        // def result = new ArrayList(list.size())\n        // for (e in list) { result.add (e.foo) }\n        // result\n        CompileStack compileStack = controller.getCompileStack();\n        Variable tmpList = new VariableExpression(\"tmpList\", make(ArrayList.class));\n        int var = compileStack.defineTemporaryVariable(tmpList, false);\n        Variable iterator = new VariableExpression(\"iterator\", Iterator_TYPE);\n        int it = compileStack.defineTemporaryVariable(iterator, false);\n        Variable nextVar = new VariableExpression(\"next\", componentType);\n        final int next = compileStack.defineTemporaryVariable(nextVar, false);\n\n        mv.visitTypeInsn(NEW, \"java/util/ArrayList\");\n        mv.visitInsn(DUP);\n        receiver.visit(controller.getAcg());\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/List\", \"size\", \"()I\");\n        controller.getOperandStack().remove(1);\n        mv.visitMethodInsn(INVOKESPECIAL, \"java/util/ArrayList\", \"<init>\", \"(I)V\");\n        mv.visitVarInsn(ASTORE, var);\n        Label l1 = new Label();\n        mv.visitLabel(l1);\n        receiver.visit(controller.getAcg());\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/List\", \"iterator\", \"()Ljava/util/Iterator;\");\n        controller.getOperandStack().remove(1);\n        mv.visitVarInsn(ASTORE, it);\n        Label l2 = new Label();\n        mv.visitLabel(l2);\n        mv.visitVarInsn(ALOAD, it);\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Iterator\", \"hasNext\", \"()Z\");\n        Label l3 = new Label();\n        mv.visitJumpInsn(IFEQ, l3);\n        mv.visitVarInsn(ALOAD, it);\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Iterator\", \"next\", \"()Ljava/lang/Object;\");\n        mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(componentType));\n        mv.visitVarInsn(ASTORE, next);\n        Label l4 = new Label();\n        mv.visitLabel(l4);\n        mv.visitVarInsn(ALOAD, var);\n        final ClassNode finalComponentType = componentType;\n        PropertyExpression pexp = new PropertyExpression(new BytecodeExpression() {\n            @Override\n            public void visit(final MethodVisitor mv) {\n                mv.visitVarInsn(ALOAD, next);\n            }\n\n            @Override\n            public ClassNode getType() {\n                return finalComponentType;\n            }\n        }, methodName);\n        pexp.visit(controller.getAcg());\n        controller.getOperandStack().box();\n        controller.getOperandStack().remove(1);\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/List\", \"add\", \"(Ljava/lang/Object;)Z\");\n        mv.visitInsn(POP);\n        Label l5 = new Label();\n        mv.visitLabel(l5);\n        mv.visitJumpInsn(GOTO, l2);\n        mv.visitLabel(l3);\n        mv.visitVarInsn(ALOAD, var);\n        controller.getOperandStack().push(make(ArrayList.class));\n        controller.getCompileStack().removeVar(next);\n        controller.getCompileStack().removeVar(it);\n        controller.getCompileStack().removeVar(var);\n    }","commit_id":"4a1a3cdf1b06d57647fcf9cc9c49a512043da7ff","url":"https://github.com/apache/groovy"},{"original_method":"private void writeMapDotProperty(final Expression receiver, final String methodName, final MethodVisitor mv) {\n        receiver.visit(controller.getAcg()); // load receiver\n        mv.visitLdcInsn(methodName); // load property name\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n        controller.getOperandStack().replace(ClassHelper.OBJECT_TYPE);\n    }","id":44905,"modified_method":"private void writeMapDotProperty(final Expression receiver, final String methodName, final MethodVisitor mv) {\n        receiver.visit(controller.getAcg()); // load receiver\n        mv.visitLdcInsn(methodName); // load property name\n        mv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\", \"(Ljava/lang/Object;)Ljava/lang/Object;\");\n        controller.getOperandStack().replace(OBJECT_TYPE);\n    }","commit_id":"4a1a3cdf1b06d57647fcf9cc9c49a512043da7ff","url":"https://github.com/apache/groovy"},{"original_method":"private boolean makeGetPropertyWithGetter(final Expression receiver, final ClassNode receiverType, final String methodName, final boolean safe, final boolean implicitThis) {\n        // does a getter exists ?\n        String getterName = \"get\" + MetaClassHelper.capitalize(methodName);\n        MethodNode getterNode = receiverType.getGetterMethod(getterName);\n        if (getterNode==null) {\n            getterName = \"is\" + MetaClassHelper.capitalize(methodName);\n            getterNode = receiverType.getGetterMethod(getterName);\n        }\n\n        // GROOVY-5561: if two files are compiled in the same source unit\n        // and that one references the other, the getters for properties have not been\n        // generated by the compiler yet (generated by the Verifier)\n        PropertyNode propertyNode = receiverType.getProperty(methodName);\n        if (propertyNode!=null) {\n            // it is possible to use a getter\n            String prefix = \"get\";\n            if (ClassHelper.boolean_TYPE.equals(propertyNode.getOriginType())) {\n                prefix = \"is\";\n            }\n            getterName = prefix + MetaClassHelper.capitalize(methodName);\n            getterNode = new MethodNode(\n                    getterName,\n                    ACC_PUBLIC,\n                    propertyNode.getOriginType(),\n                    Parameter.EMPTY_ARRAY,\n                    ClassNode.EMPTY_ARRAY,\n                    EmptyStatement.INSTANCE);\n            getterNode.setDeclaringClass(receiverType);\n            if (propertyNode.isStatic()) getterNode.setModifiers(ACC_PUBLIC + ACC_STATIC);\n        }\n        if (getterNode!=null) {\n            MethodCallExpression call = new MethodCallExpression(\n                    receiver,\n                    getterName,\n                    ArgumentListExpression.EMPTY_ARGUMENTS\n            );\n            call.setSourcePosition(receiver);\n            call.setMethodTarget(getterNode);\n            call.setImplicitThis(implicitThis);\n            call.setSafe(safe);\n            call.visit(controller.getAcg());\n            return true;\n        }\n\n        // go upper level\n        ClassNode superClass = receiverType.getSuperClass();\n        if (superClass !=null) {\n            return makeGetPropertyWithGetter(receiver, superClass, methodName, safe, implicitThis);\n        }\n        return false;\n    }","id":44906,"modified_method":"private boolean makeGetPropertyWithGetter(final Expression receiver, final ClassNode receiverType, final String methodName, final boolean safe, final boolean implicitThis) {\n        // does a getter exists ?\n        String getterName = \"get\" + MetaClassHelper.capitalize(methodName);\n        MethodNode getterNode = receiverType.getGetterMethod(getterName);\n        if (getterNode==null) {\n            getterName = \"is\" + MetaClassHelper.capitalize(methodName);\n            getterNode = receiverType.getGetterMethod(getterName);\n        }\n\n        // GROOVY-5561: if two files are compiled in the same source unit\n        // and that one references the other, the getters for properties have not been\n        // generated by the compiler yet (generated by the Verifier)\n        PropertyNode propertyNode = receiverType.getProperty(methodName);\n        if (propertyNode!=null) {\n            // it is possible to use a getter\n            String prefix = \"get\";\n            if (boolean_TYPE.equals(propertyNode.getOriginType())) {\n                prefix = \"is\";\n            }\n            getterName = prefix + MetaClassHelper.capitalize(methodName);\n            getterNode = new MethodNode(\n                    getterName,\n                    ACC_PUBLIC,\n                    propertyNode.getOriginType(),\n                    Parameter.EMPTY_ARRAY,\n                    ClassNode.EMPTY_ARRAY,\n                    EmptyStatement.INSTANCE);\n            getterNode.setDeclaringClass(receiverType);\n            if (propertyNode.isStatic()) getterNode.setModifiers(ACC_PUBLIC + ACC_STATIC);\n        }\n        if (getterNode!=null) {\n            MethodCallExpression call = new MethodCallExpression(\n                    receiver,\n                    getterName,\n                    ArgumentListExpression.EMPTY_ARGUMENTS\n            );\n            call.setSourcePosition(receiver);\n            call.setMethodTarget(getterNode);\n            call.setImplicitThis(implicitThis);\n            call.setSafe(safe);\n            call.visit(controller.getAcg());\n            return true;\n        }\n\n        // go upper level\n        ClassNode superClass = receiverType.getSuperClass();\n        if (superClass !=null) {\n            return makeGetPropertyWithGetter(receiver, superClass, methodName, safe, implicitThis);\n        }\n        return false;\n    }","commit_id":"4a1a3cdf1b06d57647fcf9cc9c49a512043da7ff","url":"https://github.com/apache/groovy"},{"original_method":"public static Map asMutableMap(Object obj) {\n        Map result = null;\n        try {\n            result = (Map) obj;\n        }\n        catch (ClassCastException e) {\n            throwCce(e);\n        }\n        if ((obj instanceof KMappedMarker) && !(obj instanceof KMutableMap)) {\n            throwCce(obj, \"kotlin.MutableMap\");\n        }\n        return result;\n    }","id":44907,"modified_method":"public static Map asMutableMap(Object obj) {\n        if (obj instanceof KMappedMarker && !(obj instanceof KMutableMap)) {\n            throwCce(obj, \"kotlin.MutableMap\");\n        }\n        try {\n            return (Map) obj;\n        }\n        catch (ClassCastException e) {\n            throw throwCce(e);\n        }\n    }","commit_id":"8f6f6f78078fa091041bd985279d22e687db7fd9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static Iterator asMutableIterator(Object obj) {\n        Iterator result = null;\n        try {\n            result = (Iterator) obj;\n        }\n        catch (ClassCastException e) {\n            throwCce(e);\n        }\n        if ((obj instanceof KMappedMarker) && !(obj instanceof KMutableIterator)) {\n            throwCce(obj, \"kotlin.MutableIterator\");\n        }\n        return result;\n    }","id":44908,"modified_method":"public static Iterator asMutableIterator(Object obj) {\n        if (obj instanceof KMappedMarker && !(obj instanceof KMutableIterator)) {\n            throwCce(obj, \"kotlin.MutableIterator\");\n        }\n        try {\n            return (Iterator) obj;\n        }\n        catch (ClassCastException e) {\n            throw throwCce(e);\n        }\n    }","commit_id":"8f6f6f78078fa091041bd985279d22e687db7fd9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static List asMutableList(Object obj) {\n        List result = null;\n        try {\n            result = (List) obj;\n        }\n        catch (ClassCastException e) {\n            throwCce(e);\n        }\n        if ((obj instanceof KMappedMarker) && !(obj instanceof KMutableList)) {\n            throwCce(obj, \"kotlin.MutableList\");\n        }\n        return result;\n    }","id":44909,"modified_method":"public static List asMutableList(Object obj) {\n        if (obj instanceof KMappedMarker && !(obj instanceof KMutableList)) {\n            throwCce(obj, \"kotlin.MutableList\");\n        }\n        try {\n            return (List) obj;\n        }\n        catch (ClassCastException e) {\n            throw throwCce(e);\n        }\n    }","commit_id":"8f6f6f78078fa091041bd985279d22e687db7fd9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static Collection asMutableCollection(Object obj) {\n        Collection result = null;\n        try {\n            result = (Collection) obj;\n        }\n        catch (ClassCastException e) {\n            throwCce(e);\n        }\n        if ((obj instanceof KMappedMarker) && !(obj instanceof KMutableCollection)) {\n            throwCce(obj, \"kotlin.MutableCollection\");\n        }\n        return result;\n    }","id":44910,"modified_method":"public static Collection asMutableCollection(Object obj) {\n        if (obj instanceof KMappedMarker && !(obj instanceof KMutableCollection)) {\n            throwCce(obj, \"kotlin.MutableCollection\");\n        }\n        try {\n            return (Collection) obj;\n        }\n        catch (ClassCastException e) {\n            throw throwCce(e);\n        }\n    }","commit_id":"8f6f6f78078fa091041bd985279d22e687db7fd9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void throwCce(ClassCastException e) {\n        throw Intrinsics.sanitizeStackTrace(e, TypeIntrinsics.class.getName());\n    }","id":44911,"modified_method":"public static ClassCastException throwCce(ClassCastException e) {\n        throw sanitizeStackTrace(e);\n    }","commit_id":"8f6f6f78078fa091041bd985279d22e687db7fd9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static ListIterator asMutableListIterator(Object obj) {\n        ListIterator result = null;\n        try {\n            result = (ListIterator) obj;\n        }\n        catch (ClassCastException e) {\n            throwCce(e);\n        }\n        if ((obj instanceof KMappedMarker) && !(obj instanceof KMutableListIterator)) {\n            throwCce(obj, \"kotlin.MutableListIterator\");\n        }\n        return result;\n    }","id":44912,"modified_method":"public static ListIterator asMutableListIterator(Object obj) {\n        if (obj instanceof KMappedMarker && !(obj instanceof KMutableListIterator)) {\n            throwCce(obj, \"kotlin.MutableListIterator\");\n        }\n        try {\n            return (ListIterator) obj;\n        }\n        catch (ClassCastException e) {\n            throw throwCce(e);\n        }\n    }","commit_id":"8f6f6f78078fa091041bd985279d22e687db7fd9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static Map.Entry asMutableMapEntry(Object obj) {\n        Map.Entry result = null;\n        try {\n            result = (Map.Entry) obj;\n        }\n        catch (ClassCastException e) {\n            throwCce(e);\n        }\n        if ((obj instanceof KMappedMarker) && !(obj instanceof KMutableMap.Entry)) {\n            throwCce(obj, \"kotlin.MutableMap.MutableEntry\");\n        }\n        return result;\n    }","id":44913,"modified_method":"public static Map.Entry asMutableMapEntry(Object obj) {\n        if (obj instanceof KMappedMarker && !(obj instanceof KMutableMap.Entry)) {\n            throwCce(obj, \"kotlin.MutableMap.MutableEntry\");\n        }\n        try {\n            return (Map.Entry) obj;\n        }\n        catch (ClassCastException e) {\n            throw throwCce(e);\n        }\n    }","commit_id":"8f6f6f78078fa091041bd985279d22e687db7fd9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static Iterable asMutableIterable(Object obj) {\n        Iterable result = null;\n        try {\n            result = (Iterable) obj;\n        }\n        catch (ClassCastException e) {\n            throwCce(e);\n        }\n        if ((obj instanceof KMappedMarker) && !(obj instanceof KMutableIterable)) {\n            throwCce(obj, \"kotlin.MutableIterable\");\n        }\n        return result;\n    }","id":44914,"modified_method":"public static Iterable asMutableIterable(Object obj) {\n        if (obj instanceof KMappedMarker && !(obj instanceof KMutableIterable)) {\n            throwCce(obj, \"kotlin.MutableIterable\");\n        }\n        try {\n            return (Iterable) obj;\n        }\n        catch (ClassCastException e) {\n            throw throwCce(e);\n        }\n    }","commit_id":"8f6f6f78078fa091041bd985279d22e687db7fd9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static Set asMutableSet(Object obj) {\n        Set result = null;\n        try {\n            result = (Set) obj;\n        }\n        catch (ClassCastException e) {\n            throwCce(e);\n        }\n        if ((obj instanceof KMappedMarker) && !(obj instanceof KMutableSet)) {\n            throwCce(obj, \"kotlin.MutableSet\");\n        }\n        return result;\n    }","id":44915,"modified_method":"public static Set asMutableSet(Object obj) {\n        if (obj instanceof KMappedMarker && !(obj instanceof KMutableSet)) {\n            throwCce(obj, \"kotlin.MutableSet\");\n        }\n        try {\n            return (Set) obj;\n        }\n        catch (ClassCastException e) {\n            throw throwCce(e);\n        }\n    }","commit_id":"8f6f6f78078fa091041bd985279d22e687db7fd9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static Client initClient( String hostNameOrIp, int port )\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect(\n//                new InetSocketAddress( hostNameOrIp, port ) );\n                new InetSocketAddress( port ) );\n        Client client = new Client( blockingReadHandler, channelFuture );\n        try\n        {\n            channelFuture.await();\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n        }\n        return client;\n    }","id":44916,"modified_method":"private static Client initClient( String hostNameOrIp, int port )\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect(\n                new InetSocketAddress( hostNameOrIp, port ) );\n//                new InetSocketAddress( port ) );\n        Client client = new Client( blockingReadHandler, channelFuture );\n        try\n        {\n            channelFuture.await();\n            System.out.println( \"Client connected to \" + hostNameOrIp + \":\" + port );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n        }\n        return client;\n    }","commit_id":"7074d4ad10d00b2ca7c84f4384b6cf68404ae73d","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        return new MasterServer( new MasterImpl( graphDb ), getHaServerPort( getMyMachineId() ) );\n    }","id":44917,"modified_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        return new MasterServer( new MasterImpl( graphDb ),\n                getHaServer( getMyMachineId() ).other() );\n    }","commit_id":"7074d4ad10d00b2ca7c84f4384b6cf68404ae73d","url":"https://github.com/neo4j/neo4j"},{"original_method":"private int getHaServerPort( int machineId )\n    {\n        String host = haServers.get( getMyMachineId() );\n        return Integer.parseInt( host.substring( host.indexOf( \":\" ) + 1 ) );\n    }","id":44918,"modified_method":"private Pair<String, Integer> getHaServer( int machineId )\n    {\n        String host = haServers.get( getMyMachineId() );\n        int pos = host.indexOf( \":\" );\n        return new Pair<String, Integer>( host.substring( 0, pos ),\n                Integer.parseInt( host.substring( pos + 1 ) ) );\n    }","commit_id":"7074d4ad10d00b2ca7c84f4384b6cf68404ae73d","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Master getAndCacheMaster( int masterId )\n    {\n        if ( masterClient == null || masterId != machineIdForMasterClient )\n        {\n            String host = haServers.get( masterId );\n            machineIdForMasterClient = masterId;\n            // TODO synchronization\n            masterClient = new MasterClient( host, getHaServerPort( masterId ) );\n        }\n        return masterClient;\n    }","id":44919,"modified_method":"private Master getAndCacheMaster( int masterId )\n    {\n        if ( masterClient == null || masterId != machineIdForMasterClient )\n        {\n            machineIdForMasterClient = masterId;\n            // TODO synchronization\n            Pair<String, Integer> host = getHaServer( masterId );\n            masterClient = new MasterClient( host.first(), host.other() );\n        }\n        return masterClient;\n    }","commit_id":"7074d4ad10d00b2ca7c84f4384b6cf68404ae73d","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Client initClient( String hostNameOrIp, int port )\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect(\n//                new InetSocketAddress( hostNameOrIp, port ) );\n                new InetSocketAddress( port ) );\n        Client client = new Client( blockingReadHandler, channelFuture );\n        try\n        {\n            channelFuture.await();\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n        }\n        return client;\n    }","id":44920,"modified_method":"private static Client initClient( String hostNameOrIp, int port )\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect(\n                new InetSocketAddress( hostNameOrIp, port ) );\n//                new InetSocketAddress( port ) );\n        Client client = new Client( blockingReadHandler, channelFuture );\n        try\n        {\n            channelFuture.await();\n            System.out.println( \"Client connected to \" + hostNameOrIp + \":\" + port );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n        }\n        return client;\n    }","commit_id":"98cf638604a65d2d2a21e083a062ceb20e069467","url":"https://github.com/neo4j/neo4j"},{"original_method":"private int getHaServerPort( int machineId )\n    {\n        String host = haServers.get( getMyMachineId() );\n        return Integer.parseInt( host.substring( host.indexOf( \":\" ) + 1 ) );\n    }","id":44921,"modified_method":"private Pair<String, Integer> getHaServer( int machineId )\n    {\n        String host = haServers.get( getMyMachineId() );\n        int pos = host.indexOf( \":\" );\n        return new Pair<String, Integer>( host.substring( 0, pos ),\n                Integer.parseInt( host.substring( pos + 1 ) ) );\n    }","commit_id":"98cf638604a65d2d2a21e083a062ceb20e069467","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        return new MasterServer( new MasterImpl( graphDb ), getHaServerPort( getMyMachineId() ) );\n    }","id":44922,"modified_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        return new MasterServer( new MasterImpl( graphDb ),\n                getHaServer( getMyMachineId() ).other() );\n    }","commit_id":"98cf638604a65d2d2a21e083a062ceb20e069467","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Master getAndCacheMaster( int masterId )\n    {\n        if ( masterClient == null || masterId != machineIdForMasterClient )\n        {\n            String host = haServers.get( masterId );\n            machineIdForMasterClient = masterId;\n            // TODO synchronization\n            masterClient = new MasterClient( host, getHaServerPort( masterId ) );\n        }\n        return masterClient;\n    }","id":44923,"modified_method":"private Master getAndCacheMaster( int masterId )\n    {\n        if ( masterClient == null || masterId != machineIdForMasterClient )\n        {\n            machineIdForMasterClient = masterId;\n            // TODO synchronization\n            Pair<String, Integer> host = getHaServer( masterId );\n            masterClient = new MasterClient( host.first(), host.other() );\n        }\n        return masterClient;\n    }","commit_id":"98cf638604a65d2d2a21e083a062ceb20e069467","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static Client initClient( String hostNameOrIp, int port )\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect(\n//                new InetSocketAddress( hostNameOrIp, port ) );\n                new InetSocketAddress( port ) );\n        Client client = new Client( blockingReadHandler, channelFuture );\n        try\n        {\n            channelFuture.await();\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n        }\n        return client;\n    }","id":44924,"modified_method":"private static Client initClient( String hostNameOrIp, int port )\n    {\n        ExecutorService executor = Executors.newCachedThreadPool();\n        ClientBootstrap bootstrap = new ClientBootstrap( new NioClientSocketChannelFactory(\n                executor, executor ) );\n        BlockingReadHandler<ChannelBuffer> blockingReadHandler = new BlockingReadHandler<ChannelBuffer>();\n        bootstrap.setPipelineFactory( new ClientPipelineFactory( blockingReadHandler ) );\n        ChannelFuture channelFuture = bootstrap.connect(\n                new InetSocketAddress( hostNameOrIp, port ) );\n//                new InetSocketAddress( port ) );\n        Client client = new Client( blockingReadHandler, channelFuture );\n        try\n        {\n            channelFuture.await();\n            System.out.println( \"Client connected to \" + hostNameOrIp + \":\" + port );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n        }\n        return client;\n    }","commit_id":"ab5cd373087dc594e937cdf2dcc569531eae67d4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private int getHaServerPort( int machineId )\n    {\n        String host = haServers.get( getMyMachineId() );\n        return Integer.parseInt( host.substring( host.indexOf( \":\" ) + 1 ) );\n    }","id":44925,"modified_method":"private Pair<String, Integer> getHaServer( int machineId )\n    {\n        String host = haServers.get( getMyMachineId() );\n        int pos = host.indexOf( \":\" );\n        return new Pair<String, Integer>( host.substring( 0, pos ),\n                Integer.parseInt( host.substring( pos + 1 ) ) );\n    }","commit_id":"ab5cd373087dc594e937cdf2dcc569531eae67d4","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Master getAndCacheMaster( int masterId )\n    {\n        if ( masterClient == null || masterId != machineIdForMasterClient )\n        {\n            String host = haServers.get( masterId );\n            machineIdForMasterClient = masterId;\n            // TODO synchronization\n            masterClient = new MasterClient( host, getHaServerPort( masterId ) );\n        }\n        return masterClient;\n    }","id":44926,"modified_method":"private Master getAndCacheMaster( int masterId )\n    {\n        if ( masterClient == null || masterId != machineIdForMasterClient )\n        {\n            machineIdForMasterClient = masterId;\n            // TODO synchronization\n            Pair<String, Integer> host = getHaServer( masterId );\n            masterClient = new MasterClient( host.first(), host.other() );\n        }\n        return masterClient;\n    }","commit_id":"ab5cd373087dc594e937cdf2dcc569531eae67d4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        return new MasterServer( new MasterImpl( graphDb ), getHaServerPort( getMyMachineId() ) );\n    }","id":44927,"modified_method":"public Object instantiateMasterServer( GraphDatabaseService graphDb )\n    {\n        return new MasterServer( new MasterImpl( graphDb ),\n                getHaServer( getMyMachineId() ).other() );\n    }","commit_id":"ab5cd373087dc594e937cdf2dcc569531eae67d4","url":"https://github.com/neo4j/neo4j"},{"original_method":"public int compare(CardView a, CardView b) {\n        Comparable aCom = null;\n        Comparable bCom = null;\n\n        if (column == 0)// #skip\n        {\n            aCom = Integer.valueOf(1);\n            bCom = Integer.valueOf(1);\n        } else if (column == 1)// Name\n        {\n            aCom = a.getName();\n            bCom = b.getName();\n            if (aCom.equals(bCom) && a.getExpansionSetCode().equals(b.getExpansionSetCode())) {\n                aCom = a.getCardNumber();\n                bCom = b.getCardNumber();\n            }\n        } else if (column == 2)// Cost\n        {\n            aCom = a.getConvertedManaCost();\n            bCom = b.getConvertedManaCost();\n        } else if (column == 3)// Color\n        {\n            aCom = CardHelper.getColor(a);\n            bCom = CardHelper.getColor(b);\n        } else if (column == 4)// Type\n        {\n            aCom = CardHelper.getType(a);\n            bCom = CardHelper.getType(b);\n        } else if (column == 5)// Stats, attack and defense\n        {\n            aCom = new Float(-1);\n            bCom = new Float(-1);\n\n            if (CardHelper.isCreature(a))\n                aCom = new Float(a.getPower() + \".\" + a.getToughness());\n            if (CardHelper.isCreature(b))\n                bCom = new Float(b.getPower() + \".\" + b.getToughness());\n        } else if (column == 6)// Rarity\n        {\n            aCom = a.getRarity().toString();\n            bCom = b.getRarity().toString();\n        } else if (column == 7)// Set name\n        {\n            aCom = a.getExpansionSetCode();\n            bCom = b.getExpansionSetCode();\n        }\n\n        if (ascending)\n            return aCom.compareTo(bCom);\n        else\n            return bCom.compareTo(aCom);\n    }","id":44928,"modified_method":"@Override\n    public int compare(CardView a, CardView b) {\n        Comparable aCom = null;\n        Comparable bCom = null;\n\n        if (column == 0)// #skip\n        {\n            aCom = 1;\n            bCom = 1;\n        } else if (column == 1)// Name\n        {\n            aCom = a.getName();\n            bCom = b.getName();\n            if (aCom.equals(bCom) && a.getExpansionSetCode().equals(b.getExpansionSetCode())) {\n                aCom = a.getCardNumber();\n                bCom = b.getCardNumber();\n            }\n        } else if (column == 2)// Cost\n        {\n            aCom = a.getConvertedManaCost();\n            bCom = b.getConvertedManaCost();\n        } else if (column == 3)// Color\n        {\n            aCom = CardHelper.getColor(a);\n            bCom = CardHelper.getColor(b);\n        } else if (column == 4)// Type\n        {\n            aCom = CardHelper.getType(a);\n            bCom = CardHelper.getType(b);\n        } else if (column == 5)// Stats, attack and defense\n        {\n            aCom = (float) -1;\n            bCom = (float) -1;\n\n            if (CardHelper.isCreature(a)) {\n                aCom = new Float(a.getPower() + \".\" + (a.getToughness().startsWith(\"-\") ? \"0\" : a.getToughness()));\n            }\n            if (CardHelper.isCreature(b)) {\n                bCom = new Float(b.getPower() + \".\" + (b.getToughness().startsWith(\"-\") ? \"0\" : b.getToughness()));\n            }\n        } else if (column == 6)// Rarity\n        {\n            aCom = a.getRarity().toString();\n            bCom = b.getRarity().toString();\n        } else if (column == 7)// Set name\n        {\n            aCom = a.getExpansionSetCode();\n            bCom = b.getExpansionSetCode();\n        }\n\n        if (ascending) {\n            return aCom.compareTo(bCom);\n        } else {\n            return bCom.compareTo(aCom);\n        }\n    }","commit_id":"ea0ba767368fef5e6f817462377455361d88f6a2","url":"https://github.com/magefree/mage"},{"original_method":"public DoIfCostPaid(final DoIfCostPaid effect) {\r\n        super(effect);\r\n        this.executingEffect = (OneShotEffect) effect.executingEffect.copy();\r\n        this.cost = effect.cost.copy();\r\n    }","id":44929,"modified_method":"public DoIfCostPaid(final DoIfCostPaid effect) {\r\n        super(effect);\r\n        this.executingEffect = (OneShotEffect) effect.executingEffect.copy();\r\n        this.cost = effect.cost.copy();\r\n        this.chooseUseText = effect.chooseUseText;\r\n    }","commit_id":"022587e6f97a362869bc10dec06c03ffb8937e16","url":"https://github.com/magefree/mage"},{"original_method":"public DoIfCostPaid(OneShotEffect effect, Cost cost) {\r\n        super(Outcome.Benefit);\r\n        this.executingEffect = effect;\r\n        this.cost = cost;\r\n    }","id":44930,"modified_method":"public DoIfCostPaid(OneShotEffect effect, Cost cost) {\r\n        this(effect, cost, null);\r\n    }","commit_id":"022587e6f97a362869bc10dec06c03ffb8937e16","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        MageObject mageObject = game.getObject(source.getSourceId());\r\n        if (player != null && mageObject != null) {\r\n            String message = new StringBuilder(getCostText()).append(\" and \").append(executingEffect.getText(source.getModes().getMode())).append(\"?\").toString();\r\n            message = CardUtil.replaceSourceName(message, mageObject.getName());\r\n            if (player.chooseUse(executingEffect.getOutcome(), message, game)) {\r\n                cost.clearPaid();\r\n                if (cost.pay(source, game, source.getSourceId(), source.getControllerId(), false)) {\r\n                    executingEffect.setTargetPointer(this.targetPointer);\r\n                    return executingEffect.apply(game, source);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":44931,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        MageObject mageObject = game.getObject(source.getSourceId());\r\n        if (player != null && mageObject != null) {\r\n            String message;\r\n            if (chooseUseText == null) {\r\n                message = new StringBuilder(getCostText()).append(\" and \").append(executingEffect.getText(source.getModes().getMode())).append(\"?\").toString();\r\n            } else {\r\n                message = chooseUseText;\r\n            }\r\n            message = CardUtil.replaceSourceName(message, mageObject.getName());\r\n            if (player.chooseUse(executingEffect.getOutcome(), message, game)) {\r\n                cost.clearPaid();\r\n                if (cost.pay(source, game, source.getSourceId(), source.getControllerId(), false)) {\r\n                    executingEffect.setTargetPointer(this.targetPointer);\r\n                    return executingEffect.apply(game, source);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"022587e6f97a362869bc10dec06c03ffb8937e16","url":"https://github.com/magefree/mage"},{"original_method":"public FelhideSpiritbinder(UUID ownerId) {\n        super(ownerId, 96, \"Felhide Spiritbinder\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{3}{R}\");\n        this.expansionSetCode = \"BNG\";\n        this.subtype.add(\"Minotaur\");\n        this.subtype.add(\"Shaman\");\n\n        this.color.setRed(true);\n        this.power = new MageInt(3);\n        this.toughness = new MageInt(4);\n\n        // <i>Inspired<\/i> - Whenever Felhide Spiritbinder becomes untapped, you may pay {1}{R}. If you do, put a token onto the battlefield that's a copy of another target creature except it's an enchantment in addition to its other types. It gains haste. Exile it at the beginning of the next end step.\n        Ability ability = new InspiredAbility(new DoIfCostPaid(new FelhideSpiritbinderEffect(), new ManaCostsImpl(\"{1}{R}\")));\n        ability.addTarget(new TargetCreaturePermanent(filter, true));\n        this.addAbility(ability);\n    }","id":44932,"modified_method":"public FelhideSpiritbinder(UUID ownerId) {\n        super(ownerId, 96, \"Felhide Spiritbinder\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{3}{R}\");\n        this.expansionSetCode = \"BNG\";\n        this.subtype.add(\"Minotaur\");\n        this.subtype.add(\"Shaman\");\n\n        this.color.setRed(true);\n        this.power = new MageInt(3);\n        this.toughness = new MageInt(4);\n\n        // <i>Inspired<\/i> - Whenever Felhide Spiritbinder becomes untapped, you may pay {1}{R}. If you do, put a token onto the battlefield that's a copy of another target creature except it's an enchantment in addition to its other types. It gains haste. Exile it at the beginning of the next end step.\n        Ability ability = new InspiredAbility(new DoIfCostPaid(new FelhideSpiritbinderEffect(), new ManaCostsImpl(\"{1}{R}\"),\"Use effect of {source}?\"));\n        ability.addTarget(new TargetCreaturePermanent(filter, true));\n        this.addAbility(ability);\n    }","commit_id":"022587e6f97a362869bc10dec06c03ffb8937e16","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Card card = game.getCard(source.getFirstTarget());\n        if (card != null) {\n            EmptyToken token = new EmptyToken();\n            CardUtil.copyTo(token).from(card);\n\n            if (!token.getCardType().contains(CardType.ENCHANTMENT)) {\n                token.getCardType().add(CardType.ENCHANTMENT);\n            }\n            token.addAbility(HasteAbility.getInstance());\n            token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());\n\n            ExileTargetEffect exileEffect = new ExileTargetEffect();\n            exileEffect.setTargetPointer(new FixedTarget(token.getLastAddedToken()));\n            DelayedTriggeredAbility delayedAbility = new AtEndOfTurnDelayedTriggeredAbility(exileEffect);\n            delayedAbility.setSourceId(source.getSourceId());\n            delayedAbility.setControllerId(source.getControllerId());\n            game.addDelayedTriggeredAbility(delayedAbility);\n\n            return true;\n        }\n\n        return false;\n    }","id":44933,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanent(source.getFirstTarget());\n        if (permanent == null) {\n            permanent = (Permanent) game.getLastKnownInformation(source.getFirstTarget(), Zone.BATTLEFIELD);\n        }\n        if (permanent != null) {\n            EmptyToken token = new EmptyToken();\n            CardUtil.copyTo(token).from(permanent);\n\n            if (!token.getCardType().contains(CardType.ENCHANTMENT)) {\n                token.getCardType().add(CardType.ENCHANTMENT);\n            }\n            token.addAbility(HasteAbility.getInstance());\n            token.putOntoBattlefield(1, game, source.getSourceId(), source.getControllerId());\n\n            ExileTargetEffect exileEffect = new ExileTargetEffect();\n            exileEffect.setTargetPointer(new FixedTarget(token.getLastAddedToken()));\n            DelayedTriggeredAbility delayedAbility = new AtEndOfTurnDelayedTriggeredAbility(exileEffect);\n            delayedAbility.setSourceId(source.getSourceId());\n            delayedAbility.setControllerId(source.getControllerId());\n            game.addDelayedTriggeredAbility(delayedAbility);\n\n            return true;\n        }\n\n        return false;\n    }","commit_id":"022587e6f97a362869bc10dec06c03ffb8937e16","url":"https://github.com/magefree/mage"},{"original_method":"private void copyFromToken(Token token, Game game) {\n        this.name = token.getName();\n        this.abilities.clear();\n        for (Ability ability : token.getAbilities()) {\n            this.addAbility(ability, game);\n        }\n        this.manaCost.clear();\n        for (ManaCost cost: token.getManaCost()) {\n            this.getManaCost().add(cost.copy());\n        }\n        this.cardType = token.getCardType();\n        this.color = token.getColor();\n        this.power = token.getPower();\n        this.toughness = token.getToughness();\n        this.subtype = token.getSubtype();\n    }","id":44934,"modified_method":"private void copyFromToken(Token token, Game game) {\n        this.name = token.getName();\n        this.abilities.clear();\n        for (Ability ability : token.getAbilities()) {\n            this.addAbility(ability, game);\n        }\n        this.manaCost.clear();\n        for (ManaCost cost: token.getManaCost()) {\n            this.getManaCost().add(cost.copy());\n        }\n        this.cardType.addAll(token.getCardType());\n        this.color = token.getColor().copy();\n        this.power.initValue(token.getPower().getValue());\n        this.toughness.initValue(token.getToughness().getValue());\n        this.supertype.addAll(token.getSupertype());\n        this.subtype.addAll(token.getSubtype());\n    }","commit_id":"022587e6f97a362869bc10dec06c03ffb8937e16","url":"https://github.com/magefree/mage"},{"original_method":"public boolean putOntoBattlefield(int amount, Game game, UUID sourceId, UUID controllerId, boolean tapped, boolean attacking) {\r\n        Card source = game.getCard(sourceId);\r\n        String setCode = source != null ? source.getExpansionSetCode() : null;\r\n        GameEvent event = GameEvent.getEvent(EventType.CREATE_TOKEN, null, sourceId, controllerId, amount);\r\n        if (!game.replaceEvent(event)) {\r\n            amount = event.getAmount();\r\n            for (int i = 0; i < amount; i++) {\r\n                PermanentToken newToken = new PermanentToken(this, controllerId, setCode, game);\r\n                game.getState().addCard(newToken);\r\n                game.addPermanent(newToken);\r\n                if (tapped) {\r\n                    newToken.setTapped(true);\r\n                }\r\n                this.lastAddedTokenId = newToken.getId();\r\n                game.setScopeRelevant(true);\r\n                game.applyEffects();\r\n                newToken.entersBattlefield(sourceId, game, Zone.OUTSIDE, true);\r\n                game.setScopeRelevant(false);\r\n                game.applyEffects();\r\n                game.fireEvent(new ZoneChangeEvent(newToken, controllerId, Zone.OUTSIDE, Zone.BATTLEFIELD));\r\n                if (attacking && game.getCombat() != null) {\r\n                    game.getCombat().addAttackingCreature(newToken.getId(), game);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":44935,"modified_method":"public boolean putOntoBattlefield(int amount, Game game, UUID sourceId, UUID controllerId, boolean tapped, boolean attacking) {\r\n        Card source = game.getCard(sourceId);\r\n        String setCode;\r\n        if (this.getOriginalExpansionSetCode() != null && !this.getOriginalExpansionSetCode().isEmpty()) {\r\n            setCode = this.getOriginalExpansionSetCode();\r\n        } else {\r\n            setCode = source != null ? source.getExpansionSetCode() : null;\r\n        }\r\n        GameEvent event = GameEvent.getEvent(EventType.CREATE_TOKEN, null, sourceId, controllerId, amount);\r\n        if (!game.replaceEvent(event)) {\r\n            amount = event.getAmount();\r\n            for (int i = 0; i < amount; i++) {\r\n                PermanentToken newToken = new PermanentToken(this, controllerId, setCode, game);\r\n                game.getState().addCard(newToken);\r\n                game.addPermanent(newToken);\r\n                if (tapped) {\r\n                    newToken.setTapped(true);\r\n                }\r\n                this.lastAddedTokenId = newToken.getId();\r\n                game.setScopeRelevant(true);\r\n                game.applyEffects();\r\n                newToken.entersBattlefield(sourceId, game, Zone.OUTSIDE, true);\r\n                game.setScopeRelevant(false);\r\n                game.applyEffects();\r\n                game.fireEvent(new ZoneChangeEvent(newToken, controllerId, Zone.OUTSIDE, Zone.BATTLEFIELD));\r\n                if (attacking && game.getCombat() != null) {\r\n                    game.getCombat().addAttackingCreature(newToken.getId(), game);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"022587e6f97a362869bc10dec06c03ffb8937e16","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public void changeAdded(@NotNull ModelChange change) {\n      ListSequence.fromList(myAffectedModels).addElement(change.getChangeSet().getNewModel());\n    }","id":44936,"modified_method":"@Override\n    public void changeAdded(@NotNull ModelChange change) {\n      addAffectedRoot(change);\n    }","commit_id":"97689bcf250f8ed8457504b078c98e93f39231b4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void changeUpdateFinished() {\n      List<SNodePointer> nodePointers = ModelAccess.instance().runReadAction(new Computable<IListSequence<SNodePointer>>() {\n        public IListSequence<SNodePointer> compute() {\n          return ListSequence.fromList(myAffectedModels).translate(new ITranslator2<SModel, SNode>() {\n            public Iterable<SNode> translate(SModel m) {\n              return m.roots();\n            }\n          }).select(new ISelector<SNode, SNodePointer>() {\n            public SNodePointer select(SNode r) {\n              return new SNodePointer(r);\n            }\n          }).toListSequence();\n        }\n      });\n      ListSequence.fromList(myAffectedModels).clear();\n      // TODO change this stupid logic \n      ListSequence.fromList(nodePointers).visitAll(new IVisitor<SNodePointer>() {\n        public void visit(SNodePointer np) {\n          invalidateNodeStatus(np);\n        }\n      });\n    }","id":44937,"modified_method":"@Override\n    public void changeUpdateFinished() {\n      ListSequence.fromList(myAffectedRoots).visitAll(new IVisitor<SNodePointer>() {\n        public void visit(SNodePointer np) {\n          invalidateNodeStatus(np);\n        }\n      });\n      ListSequence.fromList(myAffectedRoots).clear();\n    }","commit_id":"97689bcf250f8ed8457504b078c98e93f39231b4","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void changeRemoved(@NotNull ModelChange change) {\n      ListSequence.fromList(myAffectedModels).addElement(change.getChangeSet().getNewModel());\n    }","id":44938,"modified_method":"@Override\n    public void changeRemoved(@NotNull ModelChange change) {\n      addAffectedRoot(change);\n    }","commit_id":"97689bcf250f8ed8457504b078c98e93f39231b4","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean eq_qq1g71_a0a0a0a0a0a0a2a1(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","id":44939,"modified_method":"private static boolean eq_qq1g71_a0a0a0a0a0a2a1(Object a, Object b) {\n    return (a != null ?\n      a.equals(b) :\n      a == b\n    );\n  }","commit_id":"f25edb31a5cc2cc06868df74e96d8e6488b305ff","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode annotationInstance, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(annotationInstance), \"jetbrains.mps.baseLanguage.structure.HasAnnotation\"))) {\n      return;\n    }\n    SNode parent = SNodeOperations.cast(SNodeOperations.getParent(annotationInstance), \"jetbrains.mps.baseLanguage.structure.HasAnnotation\");\n    ListSequence.fromList(SLinkOperations.getTargets(parent, \"annotation\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.getIndexInParent(it) > SNodeOperations.getIndexInParent(annotationInstance);\n      }\n    }).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return eq_qq1g71_a0a0a0a0a0a0a2a1(SLinkOperations.getTarget(it, \"annotation\", false), SLinkOperations.getTarget(annotationInstance, \"annotation\", false)) && ListSequence.fromList(SLinkOperations.getTargets(it, \"value\", true)).count() == ListSequence.fromList(SLinkOperations.getTargets(annotationInstance, \"value\", true)).count();\n      }\n    }).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode otherAnnotation) {\n        return ListSequence.fromList(SLinkOperations.getTargets(otherAnnotation, \"value\", true)).all(new IWhereFilter<SNode>() {\n          public boolean accept(final SNode otherValue) {\n            return ListSequence.fromList(SLinkOperations.getTargets(annotationInstance, \"value\", true)).any(new IWhereFilter<SNode>() {\n              public boolean accept(SNode it) {\n                return eq_qq1g71_a0a0a0a0a0a0a0a0a0a0a0a0a0a0c0b(SLinkOperations.getTarget(it, \"key\", false), SLinkOperations.getTarget(otherValue, \"key\", false)) && ((SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"value\", true), \"jetbrains.mps.baseLanguage.structure.StringLiteral\") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(otherValue, \"value\", true), \"jetbrains.mps.baseLanguage.structure.StringLiteral\") && SPropertyOperations.getString(SNodeOperations.cast(SLinkOperations.getTarget(it, \"value\", true), \"jetbrains.mps.baseLanguage.structure.StringLiteral\"), \"value\").equals(SPropertyOperations.getString(SNodeOperations.cast(SLinkOperations.getTarget(otherValue, \"value\", true), \"jetbrains.mps.baseLanguage.structure.StringLiteral\"), \"value\"))) || (SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"value\", true), \"jetbrains.mps.baseLanguage.structure.IntegerConstant\") && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(otherValue, \"value\", true), \"jetbrains.mps.baseLanguage.structure.IntegerConstant\") && SPropertyOperations.getInteger(SNodeOperations.cast(SLinkOperations.getTarget(it, \"value\", true), \"jetbrains.mps.baseLanguage.structure.IntegerConstant\"), \"value\") == SPropertyOperations.getInteger(SNodeOperations.cast(SLinkOperations.getTarget(otherValue, \"value\", true), \"jetbrains.mps.baseLanguage.structure.IntegerConstant\"), \"value\")));\n              }\n            });\n          }\n        });\n      }\n    }).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(it, \"Duplicate annotation\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"543866787085723337\", null, errorTarget);\n        }\n      }\n    });\n  }","id":44940,"modified_method":"public void applyRule(final SNode annotationInstance, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (!(SNodeOperations.isInstanceOf(SNodeOperations.getParent(annotationInstance), \"jetbrains.mps.baseLanguage.structure.HasAnnotation\"))) {\n      return;\n    }\n    SNode parent = SNodeOperations.cast(SNodeOperations.getParent(annotationInstance), \"jetbrains.mps.baseLanguage.structure.HasAnnotation\");\n    ListSequence.fromList(SLinkOperations.getTargets(parent, \"annotation\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.getIndexInParent(it) > SNodeOperations.getIndexInParent(annotationInstance);\n      }\n    }).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return eq_qq1g71_a0a0a0a0a0a2a1(SLinkOperations.getTarget(it, \"annotation\", false), SLinkOperations.getTarget(annotationInstance, \"annotation\", false));\n      }\n    }).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(it, \"Duplicate annotation\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"543866787085723337\", null, errorTarget);\n        }\n      }\n    });\n  }","commit_id":"f25edb31a5cc2cc06868df74e96d8e6488b305ff","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode classConcept, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (!(SNodeOperations.isInstanceOf(classConcept, \"jetbrains.mps.baseLanguage.structure.IAnonymousClass\"))) {\n      if (!(Sequence.fromIterable(ClassConcept_Behavior.call_constructors_5292274854859503373(classConcept)).isNotEmpty() || DefaultConstructorUtils.containsDefaultConstructor(classConcept))) {\n        MessageTarget errorTarget = new NodeMessageTarget();\n        errorTarget = new PropertyMessageTarget(\"name\");\n        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(classConcept, \"There is no default constructor available in super class\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"8974945326827961340\", null, errorTarget);\n        {\n          BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.baseLanguage.typesystem.CreateDefaultConstructor_QuickFix\", false);\n          intentionProvider.putArgument(\"classConcept\", classConcept);\n          _reporter_2309309498.addIntentionProvider(intentionProvider);\n        }\n      }\n    }\n  }","id":44941,"modified_method":"public void applyRule(final SNode classConcept, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    if (!(SNodeOperations.isInstanceOf(classConcept, \"jetbrains.mps.baseLanguage.structure.IAnonymousClass\") || SNodeOperations.isInstanceOf(classConcept, \"jetbrains.mps.baseLanguage.structure.EnumClass\"))) {\n      if (!(Sequence.fromIterable(ClassConcept_Behavior.call_constructors_5292274854859503373(classConcept)).isNotEmpty() || DefaultConstructorUtils.containsDefaultConstructor(classConcept))) {\n        MessageTarget errorTarget = new NodeMessageTarget();\n        errorTarget = new PropertyMessageTarget(\"name\");\n        IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(classConcept, \"There is no default constructor available in super class\", \"r:00000000-0000-4000-0000-011c895902c5(jetbrains.mps.baseLanguage.typesystem)\", \"8974945326827961340\", null, errorTarget);\n        {\n          BaseQuickFixProvider intentionProvider = new BaseQuickFixProvider(\"jetbrains.mps.baseLanguage.typesystem.CreateDefaultConstructor_QuickFix\", false);\n          intentionProvider.putArgument(\"classConcept\", classConcept);\n          _reporter_2309309498.addIntentionProvider(intentionProvider);\n        }\n      }\n    }\n  }","commit_id":"f25edb31a5cc2cc06868df74e96d8e6488b305ff","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode execute(SModule m) {\n    Sequence.fromIterable(SNodeOperations.ofConcept(Sequence.fromIterable(((Iterable<SModel>) m.getModels())).translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel it) {\n        return SModelOperations.nodes(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93c84351fL, \"jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration\"));\n      }\n    }), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf93c84351fL, \"jetbrains.mps.baseLanguage.structure.StaticFieldDeclaration\"))).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode n) {\n        return true;\n      }\n    }).sort(new ISelector<SNode, Integer>() {\n      public Integer select(SNode it) {\n        return ListSequence.fromList(SNodeOperations.getNodeAncestors(it, null, false)).count();\n      }\n    }, false).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        final GeneratedMatchingPattern pattern = new MoveDocTagsIntoTagsChildCollection.Pattern_i7tkk0_a0a0a0a0a0a0a1();\n        if (!(pattern.match(it))) {\n          return;\n        }\n\n        {\n          SNode migratedNode = new _FunctionTypes._return_P1_E0<SNode, SNode>() {\n            public SNode invoke(SNode node) {\n              SNode clone = SNodeOperations.copyNode(node);\n              SNode comment = AttributeOperations.getAttribute(clone, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf280165065d5424eL, 0xbb1b463a8781b786L, 0x5ed0d79d7dc44bf2L, \"jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment\")));\n              if (comment != null) {\n                JavaDocConverter.convertTags(comment);\n              }\n              return clone;\n            }\n          }.invoke(it);\n        }\n      }\n    });\n    Sequence.fromIterable(SNodeOperations.ofConcept(Sequence.fromIterable(((Iterable<SModel>) m.getModels())).translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel it) {\n        return SModelOperations.nodes(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca68L, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\"));\n      }\n    }), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8c108ca68L, \"jetbrains.mps.baseLanguage.structure.FieldDeclaration\"))).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode n) {\n        return true;\n      }\n    }).sort(new ISelector<SNode, Integer>() {\n      public Integer select(SNode it) {\n        return ListSequence.fromList(SNodeOperations.getNodeAncestors(it, null, false)).count();\n      }\n    }, false).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        final GeneratedMatchingPattern pattern = new MoveDocTagsIntoTagsChildCollection.Pattern_i7tkk0_a0a0a0a0a0a1a1();\n        if (!(pattern.match(it))) {\n          return;\n        }\n\n        {\n          SNode migratedNode = new _FunctionTypes._return_P1_E0<SNode, SNode>() {\n            public SNode invoke(SNode node) {\n              SNode clone = SNodeOperations.copyNode(node);\n              SNode comment = AttributeOperations.getAttribute(clone, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf280165065d5424eL, 0xbb1b463a8781b786L, 0x5ed0d79d7dc44bf2L, \"jetbrains.mps.baseLanguage.javadoc.structure.FieldDocComment\")));\n              if (comment != null) {\n                JavaDocConverter.convertTags(comment);\n              }\n              return clone;\n            }\n          }.invoke(it);\n        }\n      }\n    });\n    Sequence.fromIterable(SNodeOperations.ofConcept(Sequence.fromIterable(((Iterable<SModel>) m.getModels())).translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel it) {\n        return SModelOperations.nodes(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, \"jetbrains.mps.baseLanguage.structure.Classifier\"));\n      }\n    }), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0x101d9d3ca30L, \"jetbrains.mps.baseLanguage.structure.Classifier\"))).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode n) {\n        return true;\n      }\n    }).sort(new ISelector<SNode, Integer>() {\n      public Integer select(SNode it) {\n        return ListSequence.fromList(SNodeOperations.getNodeAncestors(it, null, false)).count();\n      }\n    }, false).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        final GeneratedMatchingPattern pattern = new MoveDocTagsIntoTagsChildCollection.Pattern_i7tkk0_a0a0a0a0a0a2a1();\n        if (!(pattern.match(it))) {\n          return;\n        }\n\n        {\n          SNode migratedNode = new _FunctionTypes._return_P1_E0<SNode, SNode>() {\n            public SNode invoke(SNode node) {\n              SNode clone = SNodeOperations.copyNode(node);\n              SNode comment = AttributeOperations.getAttribute(clone, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf280165065d5424eL, 0xbb1b463a8781b786L, 0x1cb65d9fe66a764cL, \"jetbrains.mps.baseLanguage.javadoc.structure.ClassifierDocComment\")));\n              if (comment != null) {\n                JavaDocConverter.convertTags(comment);\n              }\n              return clone;\n            }\n          }.invoke(it);\n        }\n      }\n    });\n    Sequence.fromIterable(SNodeOperations.ofConcept(Sequence.fromIterable(((Iterable<SModel>) m.getModels())).translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel it) {\n        return SModelOperations.nodes(it, MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\"));\n      }\n    }), MetaAdapterFactory.getConcept(0xf3061a5392264cc5L, 0xa443f952ceaf5816L, 0xf8cc56b1fcL, \"jetbrains.mps.baseLanguage.structure.BaseMethodDeclaration\"))).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode n) {\n        return true;\n      }\n    }).sort(new ISelector<SNode, Integer>() {\n      public Integer select(SNode it) {\n        return ListSequence.fromList(SNodeOperations.getNodeAncestors(it, null, false)).count();\n      }\n    }, false).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        final GeneratedMatchingPattern pattern = new MoveDocTagsIntoTagsChildCollection.Pattern_i7tkk0_a0a0a0a0a0a3a1();\n        if (!(pattern.match(it))) {\n          return;\n        }\n\n        {\n          SNode migratedNode = new _FunctionTypes._return_P1_E0<SNode, SNode>() {\n            public SNode invoke(SNode node) {\n              SNode clone = SNodeOperations.copyNode(node);\n              SNode comment = AttributeOperations.getAttribute(clone, new IAttributeDescriptor.NodeAttribute(MetaAdapterFactory.getConcept(0xf280165065d5424eL, 0xbb1b463a8781b786L, 0x4a3c146b7faeeb34L, \"jetbrains.mps.baseLanguage.javadoc.structure.MethodDocComment\")));\n              if (comment != null) {\n                JavaDocConverter.convertTags(comment);\n              }\n              return clone;\n            }\n          }.invoke(it);\n        }\n      }\n    });\n    return null;\n  }","id":44942,"modified_method":"public SNode execute(SModule m) {\n    Iterable<SModel> models = m.getModels();\n    Sequence.fromIterable(models).ofType(SModel.class).translate(new ITranslator2<SModel, SNode>() {\n      public Iterable<SNode> translate(SModel model) {\n        return SModelOperations.nodes(model, MetaAdapterFactory.getConcept(0xf280165065d5424eL, 0xbb1b463a8781b786L, 0x4a3c146b7fae70d3L, \"jetbrains.mps.baseLanguage.javadoc.structure.BaseDocComment\"));\n      }\n    }).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        JavaDocConverter.convertTags(it);\n      }\n    });\n    return null;\n  }","commit_id":"79167ae319fe169b9749daf74ad5525cafcb6966","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static Collection<LanguageMissingProblem> findMissingLanguages(Iterable<SModule> modules, int maxErrors) {\n    // we can add here an additional chank for \"used\", \"exported\", \"generated into\" languages etc.,  \n    // but I'm not sure this is needed. All we need in migration is working concepts. \n\n    // the node in the map is an example of language use to show it to the user \n    final Map<SLanguage, SNode> problemLangs = MapSequence.fromMap(new HashMap<SLanguage, SNode>());\n    Sequence.fromIterable(allNodes(Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {\n      public Iterable<SModel> translate(SModule it) {\n        return it.getModels();\n      }\n    }))).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode it) {\n        SLanguage lang = it.getConcept().getLanguage();\n        if (((SLanguageAdapter) lang).getLanguageDescriptor() == null) {\n          MapSequence.fromMap(problemLangs).put(lang, it);\n        }\n      }\n    });\n\n    final Set<LanguageMissingProblem> problems = SetSequence.fromSet(new HashSet<LanguageMissingProblem>());\n    MapSequence.fromMap(problemLangs).take(maxErrors).visitAll(new IVisitor<IMapping<SLanguage, SNode>>() {\n      public void visit(IMapping<SLanguage, SNode> it) {\n        if (it.key().getSourceModule() == null) {\n          SetSequence.fromSet(problems).addElement(new LanguageAbsentInRepoProblem(it.key(), it.value()));\n        } else {\n          SetSequence.fromSet(problems).addElement(new LanguageNotLoadedProblem(it.key(), it.value()));\n        }\n      }\n    });\n    return problems;\n  }","id":44943,"modified_method":"private static Collection<LanguageMissingProblem> findMissingLanguages(Iterable<SModule> modules, int maxErrors, @Nullable _FunctionTypes._void_P1_E0<? super Double> progressCallback) {\n    // we can add here an additional chank for \"used\", \"exported\", \"generated into\" languages etc.,  \n    // but I'm not sure this is needed. All we need in migration is working concepts. \n\n    // the node in the map is an example of language use to show it to the user \n    final Map<SLanguage, SNode> problemLangs = MapSequence.fromMap(new HashMap<SLanguage, SNode>());\n    int modulesCount = Sequence.fromIterable(modules).count();\n    int processedModules = 0;\n    for (SModule module : Sequence.fromIterable(modules)) {\n      Sequence.fromIterable(allNodes(module.getModels())).visitAll(new IVisitor<SNode>() {\n        public void visit(SNode it) {\n          SLanguage lang = it.getConcept().getLanguage();\n          if (((SLanguageAdapter) lang).getLanguageDescriptor() == null) {\n            MapSequence.fromMap(problemLangs).put(lang, it);\n          }\n        }\n      });\n      processedModules++;\n      progressCallback.invoke(1.0 * processedModules / modulesCount);\n    }\n\n    final Set<LanguageMissingProblem> problems = SetSequence.fromSet(new HashSet<LanguageMissingProblem>());\n    MapSequence.fromMap(problemLangs).take(maxErrors).visitAll(new IVisitor<IMapping<SLanguage, SNode>>() {\n      public void visit(IMapping<SLanguage, SNode> it) {\n        if (it.key().getSourceModule() == null) {\n          SetSequence.fromSet(problems).addElement(new LanguageAbsentInRepoProblem(it.key(), it.value()));\n        } else {\n          SetSequence.fromSet(problems).addElement(new LanguageNotLoadedProblem(it.key(), it.value()));\n        }\n      }\n    });\n    return problems;\n  }","commit_id":"4a27ff016dd05d0c2d515994d539376da3f2ab89","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Collection<Problem> getProblems(Iterable<SModule> modules, @Nullable _FunctionTypes._void_P1_E0<? super Double> progressCallback, int maxErrors) {\n    List<Problem> result = ListSequence.fromList(new ArrayList<Problem>());\n\n    Collection<DependencyProblem> badModuleProblems = findBadModules(modules, maxErrors);\n    ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(badModuleProblems));\n\n    maxErrors -= CollectionSequence.fromCollection(badModuleProblems).count();\n    if (maxErrors == 0) {\n      return result;\n    }\n\n    Collection<BinaryModelProblem> badModelProblems = findBinaryModels(modules, maxErrors);\n    ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(badModelProblems));\n\n    maxErrors -= CollectionSequence.fromCollection(badModelProblems).count();\n    if (maxErrors == 0) {\n      return result;\n    }\n\n    // find missing languages \n    Collection<LanguageMissingProblem> missingLangProblems = findMissingLanguages(modules, maxErrors);\n    ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(missingLangProblems));\n\n    maxErrors -= CollectionSequence.fromCollection(missingLangProblems).count();\n    if (maxErrors == 0) {\n      return result;\n    }\n\n    Set<SLanguage> missingLangs = SetSequence.fromSet(new HashSet<SLanguage>());\n    SetSequence.fromSet(missingLangs).addSequence(CollectionSequence.fromCollection(missingLangProblems).select(new ISelector<LanguageMissingProblem, SLanguage>() {\n      public SLanguage select(LanguageMissingProblem it) {\n        return it.getLanguage();\n      }\n    }));\n\n    if (progressCallback != null) {\n      progressCallback.invoke(0.1);\n    }\n\n    // find missing concepts, when language's not missing \n    // find missing concept features when concept's not mising \n    Set<SAbstractConcept> missingConcepts = SetSequence.fromSet(new HashSet<SAbstractConcept>());\n    Set<SConceptFeature> missingFeatures = SetSequence.fromSet(new HashSet<SConceptFeature>());\n\n    int modulesCount = Sequence.fromIterable(modules).count();\n    int processedModules = 0;\n    for (SModule module : Sequence.fromIterable(modules)) {\n      for (SNode node : Sequence.fromIterable(allNodes(module.getModels()))) {\n        SConcept concept = node.getConcept();\n        if (!(concept.isValid())) {\n          if (SetSequence.fromSet(missingLangs).contains(concept.getLanguage()) || SetSequence.fromSet(missingConcepts).contains(concept)) {\n            continue;\n          }\n          SetSequence.fromSet(missingConcepts).addElement(concept);\n          ListSequence.fromList(result).addElement(new ConceptMissingProblem(concept, node));\n\n          maxErrors--;\n          if (maxErrors == 0) {\n            return result;\n          }\n\n          continue;\n        }\n\n        // in case of props, refs, links, list should be better than set \n        List<SProperty> props = IterableUtil.asList(concept.getProperties());\n        for (SProperty p : Sequence.fromIterable(node.getProperties())) {\n          if (props.contains(p) || SetSequence.fromSet(missingFeatures).contains(p)) {\n            continue;\n          }\n          SetSequence.fromSet(missingFeatures).addElement(p);\n          ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(p, node));\n\n          maxErrors--;\n          if (maxErrors == 0) {\n            return result;\n          }\n        }\n\n        List<SContainmentLink> links = IterableUtil.asList(concept.getContainmentLinks());\n        for (SNode n : Sequence.fromIterable(node.getChildren())) {\n          SContainmentLink l = n.getContainmentLink();\n          if (links.contains(l) || SetSequence.fromSet(missingFeatures).contains(l)) {\n            continue;\n          }\n          SetSequence.fromSet(missingFeatures).addElement(l);\n          ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(l, node));\n\n          maxErrors--;\n          if (maxErrors == 0) {\n            return result;\n          }\n        }\n\n        List<SReferenceLink> refs = IterableUtil.asList(concept.getReferenceLinks());\n        for (SReference r : Sequence.fromIterable(node.getReferences())) {\n          SReferenceLink l = r.getLink();\n          if (refs.contains(l) || SetSequence.fromSet(missingFeatures).contains(l)) {\n            continue;\n          }\n          SetSequence.fromSet(missingFeatures).addElement(l);\n          ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(l, node));\n\n          maxErrors--;\n          if (maxErrors == 0) {\n            return result;\n          }\n        }\n      }\n\n      processedModules++;\n      if (progressCallback != null) {\n        progressCallback.invoke(0.9 * processedModules / modulesCount);\n      }\n    }\n\n    return result;\n  }","id":44944,"modified_method":"public static Collection<Problem> getProblems(Iterable<SModule> modules, @Nullable final _FunctionTypes._void_P1_E0<? super Double> progressCallback, int maxErrors) {\n    List<Problem> result = ListSequence.fromList(new ArrayList<Problem>());\n\n    Collection<DependencyProblem> badModuleProblems = findBadModules(modules, maxErrors);\n    ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(badModuleProblems));\n\n    maxErrors -= CollectionSequence.fromCollection(badModuleProblems).count();\n    if (maxErrors == 0) {\n      return result;\n    }\n\n    Collection<BinaryModelProblem> badModelProblems = findBinaryModels(modules, maxErrors);\n    ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(badModelProblems));\n\n    maxErrors -= CollectionSequence.fromCollection(badModelProblems).count();\n    if (maxErrors == 0) {\n      return result;\n    }\n\n    if (progressCallback != null) {\n      progressCallback.invoke(0.1);\n    }\n\n    // find missing languages \n    Collection<LanguageMissingProblem> missingLangProblems = findMissingLanguages(modules, maxErrors, new _FunctionTypes._void_P1_E0<Double>() {\n      public void invoke(Double fraction) {\n        progressCallback.invoke(0.1 + 0.45 * fraction);\n      }\n    });\n    ListSequence.fromList(result).addSequence(CollectionSequence.fromCollection(missingLangProblems));\n\n    maxErrors -= CollectionSequence.fromCollection(missingLangProblems).count();\n    if (maxErrors == 0) {\n      return result;\n    }\n\n    Set<SLanguage> missingLangs = SetSequence.fromSet(new HashSet<SLanguage>());\n    SetSequence.fromSet(missingLangs).addSequence(CollectionSequence.fromCollection(missingLangProblems).select(new ISelector<LanguageMissingProblem, SLanguage>() {\n      public SLanguage select(LanguageMissingProblem it) {\n        return it.getLanguage();\n      }\n    }));\n\n    // find missing concepts, when language's not missing \n    // find missing concept features when concept's not mising \n    Set<SAbstractConcept> missingConcepts = SetSequence.fromSet(new HashSet<SAbstractConcept>());\n    Set<SConceptFeature> missingFeatures = SetSequence.fromSet(new HashSet<SConceptFeature>());\n\n    int modulesCount = Sequence.fromIterable(modules).count();\n    int processedModules = 0;\n    for (SModule module : Sequence.fromIterable(modules)) {\n      for (SNode node : Sequence.fromIterable(allNodes(module.getModels()))) {\n        SConcept concept = node.getConcept();\n        if (!(concept.isValid())) {\n          if (SetSequence.fromSet(missingLangs).contains(concept.getLanguage()) || SetSequence.fromSet(missingConcepts).contains(concept)) {\n            continue;\n          }\n          SetSequence.fromSet(missingConcepts).addElement(concept);\n          ListSequence.fromList(result).addElement(new ConceptMissingProblem(concept, node));\n\n          maxErrors--;\n          if (maxErrors == 0) {\n            return result;\n          }\n\n          continue;\n        }\n\n        // in case of props, refs, links, list should be better than set \n        List<SProperty> props = IterableUtil.asList(concept.getProperties());\n        for (SProperty p : Sequence.fromIterable(node.getProperties())) {\n          if (props.contains(p) || SetSequence.fromSet(missingFeatures).contains(p)) {\n            continue;\n          }\n          SetSequence.fromSet(missingFeatures).addElement(p);\n          ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(p, node));\n\n          maxErrors--;\n          if (maxErrors == 0) {\n            return result;\n          }\n        }\n\n        List<SContainmentLink> links = IterableUtil.asList(concept.getContainmentLinks());\n        for (SNode n : Sequence.fromIterable(node.getChildren())) {\n          SContainmentLink l = n.getContainmentLink();\n          if (links.contains(l) || SetSequence.fromSet(missingFeatures).contains(l)) {\n            continue;\n          }\n          SetSequence.fromSet(missingFeatures).addElement(l);\n          ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(l, node));\n\n          maxErrors--;\n          if (maxErrors == 0) {\n            return result;\n          }\n        }\n\n        List<SReferenceLink> refs = IterableUtil.asList(concept.getReferenceLinks());\n        for (SReference r : Sequence.fromIterable(node.getReferences())) {\n          SReferenceLink l = r.getLink();\n          if (refs.contains(l) || SetSequence.fromSet(missingFeatures).contains(l)) {\n            continue;\n          }\n          SetSequence.fromSet(missingFeatures).addElement(l);\n          ListSequence.fromList(result).addElement(new ConceptFeatureMissingProblem(l, node));\n\n          maxErrors--;\n          if (maxErrors == 0) {\n            return result;\n          }\n        }\n      }\n\n      processedModules++;\n      if (progressCallback != null) {\n        progressCallback.invoke(0.45 * processedModules / modulesCount);\n      }\n    }\n\n    return result;\n  }","commit_id":"4a27ff016dd05d0c2d515994d539376da3f2ab89","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n\t * Deletes the user's subscription to the entity. A social activity with the\n\t * unsubscribe action is created.\n\t *\n\t * @param  userId the primary key of the user\n\t * @param  className the entity's class name\n\t * @param  classPK the primary key of the entity's instance\n\t * @throws PortalException if a matching user or subscription could not be\n\t *         found\n\t * @throws SystemException if a system exception occurred\n\t */\n\t@Override\n\tpublic void deleteSubscription(long userId, String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = classNameLocalService.getClassNameId(className);\n\n\t\tSubscription subscription = subscriptionPersistence.findByC_U_C_C(\n\t\t\tuser.getCompanyId(), userId, classNameId, classPK);\n\n\t\tdeleteSubscription(subscription);\n\t}","id":44945,"modified_method":"/**\n\t * Deletes the user's subscription to the entity. A social activity with the\n\t * unsubscribe action is created.\n\t *\n\t * @param  userId the primary key of the user\n\t * @param  className the entity's class name\n\t * @param  classPK the primary key of the entity's instance\n\t * @throws PortalException if a matching user or subscription could not be\n\t *         found\n\t * @throws SystemException if a system exception occurred\n\t */\n\t@Override\n\tpublic void deleteSubscription(long userId, String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = classNameLocalService.getClassNameId(className);\n\n\t\tSubscription subscription = subscriptionPersistence.fetchByC_U_C_C(\n\t\t\tuser.getCompanyId(), userId, classNameId, classPK);\n\n\t\tif (subscription != null) {\n\t\t\tdeleteSubscription(subscription);\n\t\t}\n\t}","commit_id":"de9a45eb6ce7fba017b52132c8069a7023f359f5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void unsubscribe(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (!themeDisplay.isSignedIn()) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong[] subscriptionIds = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"subscriptionIds\"), 0L);\n\n\t\tfor (long subscriptionId : subscriptionIds) {\n\t\t\tif (subscriptionId > 0) {\n\t\t\t\tSubscriptionLocalServiceUtil.deleteSubscription(subscriptionId);\n\t\t\t}\n\t\t}\n\t}","id":44946,"modified_method":"public void unsubscribe(\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (!themeDisplay.isSignedIn()) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong[] subscriptionIds = StringUtil.split(\n\t\t\tParamUtil.getString(actionRequest, \"subscriptionIds\"), 0L);\n\n\t\tfor (long subscriptionId : subscriptionIds) {\n\t\t\tif (subscriptionId > 0) {\n\t\t\t\tSubscription subscription =\n\t\t\t\t\tSubscriptionLocalServiceUtil.getSubscription(\n\t\t\t\t\t\tsubscriptionId);\n\n\t\t\t\tPermissionChecker permissionChecker =\n\t\t\t\t\tthemeDisplay.getPermissionChecker();\n\n\t\t\t\tif (permissionChecker.getUserId() != subscription.getUserId()) {\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\n\t\t\t\tSubscriptionLocalServiceUtil.deleteSubscription(subscription);\n\t\t\t}\n\t\t}\n\t}","commit_id":"93b35275efc954e9be789619d83f917fad557736","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n\t * Deletes the user's subscription to the entity. A social activity with the\n\t * unsubscribe action is created.\n\t *\n\t * @param  userId the primary key of the user\n\t * @param  className the entity's class name\n\t * @param  classPK the primary key of the entity's instance\n\t * @throws PortalException if a matching user or subscription could not be\n\t *         found\n\t * @throws SystemException if a system exception occurred\n\t */\n\t@Override\n\tpublic void deleteSubscription(long userId, String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = classNameLocalService.getClassNameId(className);\n\n\t\tSubscription subscription = subscriptionPersistence.fetchByC_U_C_C(\n\t\t\tuser.getCompanyId(), userId, classNameId, classPK);\n\n\t\tdeleteSubscription(subscription);\n\t}","id":44947,"modified_method":"/**\n\t * Deletes the user's subscription to the entity. A social activity with the\n\t * unsubscribe action is created.\n\t *\n\t * @param  userId the primary key of the user\n\t * @param  className the entity's class name\n\t * @param  classPK the primary key of the entity's instance\n\t * @throws PortalException if a matching user or subscription could not be\n\t *         found\n\t * @throws SystemException if a system exception occurred\n\t */\n\t@Override\n\tpublic void deleteSubscription(long userId, String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tlong classNameId = classNameLocalService.getClassNameId(className);\n\n\t\tSubscription subscription = subscriptionPersistence.fetchByC_U_C_C(\n\t\t\tuser.getCompanyId(), userId, classNameId, classPK);\n\n\t\tif (subscription != null) {\n\t\t\tdeleteSubscription(subscription);\n\t\t}\n\t}","commit_id":"753524e39f47a2b0f2a8eb63aa1c727faf33f4eb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player == null) {\n            return false;\n        }\n\n        for (UUID playerId : player.getInRange()) {\n            FilterCreaturePermanent filter = new FilterCreaturePermanent();\n            filter.add(new ControllerIdPredicate(playerId));\n\n            List<Permanent> creatures = game.getBattlefield().getActivePermanents(filter, player.getId(), source.getSourceId(), game);\n            for (Permanent creature : creatures) {\n                creature.tap(game);\n            }\n        }\n\n        return true;\n    }","id":44948,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player == null) {\n            return false;\n        }\n        for (Permanent creature : game.getBattlefield().getActivePermanents(filter, player.getId(), source.getSourceId(), game)) {\n            creature.tap(game);\n        }\n        return true;\n    }","commit_id":"6f1ed24e955d77c088e96484b4cbafd28ff24803","url":"https://github.com/magefree/mage"},{"original_method":"protected List<Permanent> threats(UUID playerId, UUID sourceId, FilterPermanent filter, Game game, List<UUID> targets) {\n        List<Permanent> threats = (playerId == null || sourceId ==null) ?\n                game.getBattlefield().getActivePermanents(filter, this.getId(), sourceId, game) : // all permanents within the range of the player\n                game.getBattlefield().getActivePermanents(filter, playerId, sourceId, game);\n\n        Iterator<Permanent> it = threats.iterator();\n        while (it.hasNext()) { // remove permanents already targeted\n            Permanent test = it.next();\n            if (targets.contains(test.getId()) || (playerId != null && !test.getControllerId().equals(playerId))) {\n                it.remove();\n            }\n        }\n        Collections.sort(threats, new PermanentComparator(game));\n        Collections.reverse(threats);\n        return threats;\n    }","id":44949,"modified_method":"protected List<Permanent> threats(UUID playerId, UUID sourceId, FilterPermanent filter, Game game, List<UUID> targets) {\n        List<Permanent> threats;\n        if (playerId == null) {\n            threats = game.getBattlefield().getActivePermanents(filter, this.getId(), sourceId, game); // all permanents within the range of the player\n        } else {\n            FilterPermanent filterCopy = filter.copy();\n            filterCopy.add(new PlayerIdPredicate(playerId));\n            threats = game.getBattlefield().getActivePermanents(filter, this.getId(), sourceId, game);\n        } \n        Iterator<Permanent> it = threats.iterator();\n        while (it.hasNext()) { // remove permanents already targeted\n            Permanent test = it.next();\n            if (targets.contains(test.getId()) || (playerId != null && !test.getControllerId().equals(playerId))) {\n                it.remove();\n            }\n        }\n        Collections.sort(threats, new PermanentComparator(game));\n        Collections.reverse(threats);\n        return threats;\n    }","commit_id":"80d3e6bd9a4ffb6fcb090f03fc3059675535dc74","url":"https://github.com/magefree/mage"},{"original_method":"/**\n   * Sets up dictionary of valid verbs and their POS info from an input file.\n   * The input file must be a list of tab-seperated verb-POS pairs, one verb\n   * per line.\n   *\n   * @param dictPath the path to the dictionary file\n   */  \n  private void setupDictionary(String dictPath) {\n    try {\n      dict = new HashMap<String, String>();\n      BufferedReader br = new BufferedReader(new InputStreamReader(\n        IOUtils.getInputStreamFromURLOrClasspathOrFileSystem(dictPath), \"UTF-8\"));\n      String line = br.readLine();\n      for(; line != null; line = br.readLine()) {\n        String[] words = line.trim().split(\"\\\\s\");\n        if(words.length < 3) {\n          System.err.printf(\"SpanishVerbStripper: addings words to dict, missing word, ignoring line\\n\");\n        }\n        dict.put(words[0], words[2]);\n      }\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    } catch (FileNotFoundException e) {\n      System.err.println(\"Could not load Spanish data file \" + dictPath);\n    } catch (IOException e) {\n      System.err.println(\"Could not load Spanish data file \" + dictPath);\n    }\n  }","id":44950,"modified_method":"/**\n   * Sets up dictionary of valid verbs and their POS info from an input file.\n   * The input file must be a list of tab-separated verb-POS pairs, one verb\n   * per line.\n   *\n   * @param dictPath the path to the dictionary file\n   */\n  private void setupDictionary(String dictPath) {\n    try {\n      dict = new HashMap<String, String>();\n      BufferedReader br = IOUtils.readerFromString(dictPath);\n      for(String line; (line = br.readLine()) != null; ) {\n        String[] words = line.trim().split(\"\\\\s\");\n        if(words.length < 3) {\n          System.err.printf(\"SpanishVerbStripper: addings words to dict, missing word, ignoring line%n\");\n        }\n        dict.put(words[0], words[2]);\n      }\n      IOUtils.closeIgnoringExceptions(br);\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    } catch (FileNotFoundException e) {\n      System.err.println(\"Could not load Spanish data file \" + dictPath);\n    } catch (IOException e) {\n      System.err.println(\"Could not load Spanish data file \" + dictPath);\n    }\n  }","commit_id":"7c1667afac4f124f106014b3ba2c265b3b6466f0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void loadModelFile(String modelFile)\n\t{\n\t\ttry\n\t\t{\n            System.out.println(CONST.SEPARATOR);\n\t\t\tSystem.out.println(\"Loading Model File: \" + modelFile);\n\t\t\tString s;\n\t\t\tBufferedReader input = new BufferedReader(new InputStreamReader(\n          IOUtils.getInputStreamFromURLOrClasspathOrFileSystem(modelFile)));\n\t\t\t\n\t\t\tint nDict, nPOS, nLabel;\n\t\t\tint eSize, hSize, nTokens, nPreComputed;\n            nDict = nPOS = nLabel = eSize = hSize = nTokens = nPreComputed = 0;\n\n\t\t\tfor (int k = 0; k < 7; ++ k)\n\t\t\t{\n\t\t\t\ts = input.readLine();\n\t\t\t\tSystem.out.println(s);\n\t\t\t\tint number = Integer.parseInt(s.substring(s.indexOf(\"=\") + 1, s.length()));\n\t\t\t\tswitch (k)\n\t\t\t\t{\n\t\t\t\t\tcase 0: nDict = number;\n\t\t\t\t\tcase 1: nPOS = number;\n\t\t\t\t\tcase 2: nLabel = number;\n\t\t\t\t\tcase 3: eSize = number;\n\t\t\t\t\tcase 4: hSize = number;\n\t\t\t\t\tcase 5: nTokens = number;\n                    case 6: nPreComputed = number;\n\t\t\t\t\tdefault: break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twordDict = new ArrayList<String>();\n\t\t\tposDict = new ArrayList<String>();\n\t\t\tlabelDict = new ArrayList<String>();\n            double[][] E = new double[nDict + nPOS + nLabel][eSize];\n            String[] splits;\n            int index = 0;\n\n\t\t\tfor (int k = 0; k < nDict; ++ k)\n\t\t\t{\n\t\t\t\ts = input.readLine();\n                splits = s.split(\" \");\n\t\t\t\twordDict.add(splits[0]);\n                for (int i = 0; i < eSize; ++ i)\n                    E[index][i] = Double.parseDouble(splits[i + 1]);\n                index = index + 1;\n\t\t\t}\n\t\t\tfor (int k = 0; k < nPOS; ++ k)\n\t\t\t{\n                s = input.readLine();\n                splits = s.split(\" \");\n                posDict.add(splits[0]);\n                for (int i = 0; i < eSize; ++ i)\n                    E[index][i] = Double.parseDouble(splits[i + 1]);\n                index = index + 1;\n\t\t\t}\n\t\t\tfor (int k = 0; k < nLabel; ++ k)\n\t\t\t{\n                s = input.readLine();\n                splits = s.split(\" \");\n                labelDict.add(splits[0]);\n                for (int i = 0; i < eSize; ++ i)\n                    E[index][i] = Double.parseDouble(splits[i + 1]);\n                index = index + 1;\n\t\t\t}\n            genMapping();\n\n\t\t\tdouble[][] W1 = new double[hSize][eSize * nTokens];\n\t\t\tfor (int j = 0; j < W1[0].length; ++ j)\n\t\t\t{\n\t\t\t\ts = input.readLine();\n\t\t\t\tsplits = s.split(\" \");\n\t\t\t\tfor (int i = 0; i < W1.length; ++ i)\n\t\t\t\t\tW1[i][j] = Double.parseDouble(splits[i]);\n\t\t\t}\n\n\t\t\tdouble[] b1 = new double[hSize];\n\t\t\ts = input.readLine();\n\t\t\tsplits = s.split(\" \");\n\t\t\tfor (int i = 0; i < b1.length; ++ i)\n\t\t\t\tb1[i] = Double.parseDouble(splits[i]);\n\n\t\t\tdouble[][] W2 = new double[nLabel * 2 - 1][hSize];\n\t\t\tfor (int j = 0; j < W2[0].length; ++ j)\n\t\t\t{\n\t\t\t\ts = input.readLine();\n\t\t\t\tsplits = s.split(\" \");\n\t\t\t\tfor (int i = 0; i < W2.length; ++ i)\n\t\t\t\t\tW2[i][j] = Double.parseDouble(splits[i]);\n\t\t\t}\n\n            preComputed = new ArrayList<Integer>();\n            while (preComputed.size() < nPreComputed)\n            {\n                s = input.readLine();\n                splits = s.split(\" \");\n                for (int i = 0; i < splits.length; ++ i)\n                    preComputed.add(Integer.parseInt(splits[i]));\n            }\n\t\t\tinput.close();\n            classifier = new Classifier(E, W1, b1, W2, preComputed);\n\t\t}\n\t\tcatch (Exception e) { System.out.println(e); }\n\t}","id":44951,"modified_method":"public void loadModelFile(String modelFile) {\n    try {\n      System.out.println(CONST.SEPARATOR);\n      System.out.println(\"Loading Model File: \" + modelFile);\n      String s;\n      BufferedReader input = IOUtils.readerFromString(modelFile);\n\n      int nDict, nPOS, nLabel;\n      int eSize, hSize, nTokens, nPreComputed;\n      nDict = nPOS = nLabel = eSize = hSize = nTokens = nPreComputed = 0;\n\n      for (int k = 0; k < 7; ++k) {\n        s = input.readLine();\n        System.out.println(s);\n        int number = Integer.parseInt(s.substring(s.indexOf(\"=\") + 1, s.length()));\n        switch (k) {\n          case 0:\n            nDict = number;\n          case 1:\n            nPOS = number;\n          case 2:\n            nLabel = number;\n          case 3:\n            eSize = number;\n          case 4:\n            hSize = number;\n          case 5:\n            nTokens = number;\n          case 6:\n            nPreComputed = number;\n          default:\n            break;\n        }\n      }\n\n      wordDict = new ArrayList<String>();\n      posDict = new ArrayList<String>();\n      labelDict = new ArrayList<String>();\n      double[][] E = new double[nDict + nPOS + nLabel][eSize];\n      String[] splits;\n      int index = 0;\n\n      for (int k = 0; k < nDict; ++k) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        wordDict.add(splits[0]);\n        for (int i = 0; i < eSize; ++i)\n          E[index][i] = Double.parseDouble(splits[i + 1]);\n        index = index + 1;\n      }\n      for (int k = 0; k < nPOS; ++k) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        posDict.add(splits[0]);\n        for (int i = 0; i < eSize; ++i)\n          E[index][i] = Double.parseDouble(splits[i + 1]);\n        index = index + 1;\n      }\n      for (int k = 0; k < nLabel; ++k) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        labelDict.add(splits[0]);\n        for (int i = 0; i < eSize; ++i)\n          E[index][i] = Double.parseDouble(splits[i + 1]);\n        index = index + 1;\n      }\n      genMapping();\n\n      double[][] W1 = new double[hSize][eSize * nTokens];\n      for (int j = 0; j < W1[0].length; ++j) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        for (int i = 0; i < W1.length; ++i)\n          W1[i][j] = Double.parseDouble(splits[i]);\n      }\n\n      double[] b1 = new double[hSize];\n      s = input.readLine();\n      splits = s.split(\" \");\n      for (int i = 0; i < b1.length; ++i)\n        b1[i] = Double.parseDouble(splits[i]);\n\n      double[][] W2 = new double[nLabel * 2 - 1][hSize];\n      for (int j = 0; j < W2[0].length; ++j) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        for (int i = 0; i < W2.length; ++i)\n          W2[i][j] = Double.parseDouble(splits[i]);\n      }\n\n      preComputed = new ArrayList<Integer>();\n      while (preComputed.size() < nPreComputed) {\n        s = input.readLine();\n        splits = s.split(\" \");\n        for (int i = 0; i < splits.length; ++i)\n          preComputed.add(Integer.parseInt(splits[i]));\n      }\n      input.close();\n      classifier = new Classifier(E, W1, b1, W2, preComputed);\n    } catch (Exception e) {\n      System.out.println(e);\n    }\n  }","commit_id":"c8fe4e10353e02a6994c4b59ffafec9a2cf8ef27","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static AnnotatorFactory truecase(Properties properties, final AnnotatorImplementations annotatorImplementation) {\n    return new AnnotatorFactory(TrueCaseAnnotator.class, properties) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        String model = properties.getProperty(\"truecase.model\", DefaultPaths.DEFAULT_TRUECASE_MODEL);\n        String bias = properties.getProperty(\"truecase.bias\", TrueCaseAnnotator.DEFAULT_MODEL_BIAS);\n        String mixed = properties.getProperty(\"truecase.mixedcasefile\", DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n        return annotatorImplementation.trueCase(properties, model, bias, mixed, false);\n      }\n\n      @Override\n      public String additionalSignature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n            properties.getProperty(\"truecase.model\",\n                DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n            \"truecase.bias:\" +\n            properties.getProperty(\"truecase.bias\",\n                TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n            \"truecase.mixedcasefile:\" +\n            properties.getProperty(\"truecase.mixedcasefile\",\n                DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    };\n  }","id":44952,"modified_method":"public static AnnotatorFactory truecase(Properties properties, final AnnotatorImplementations annotatorImplementation) {\n    return new AnnotatorFactory(TrueCaseAnnotator.class, properties) {\n      private static final long serialVersionUID = 1L;\n      @Override\n      public Annotator create() {\n        return annotatorImplementation.trueCase(properties);\n      }\n\n      @Override\n      public String additionalSignature() {\n        // keep track of all relevant properties for this annotator here!\n        return \"truecase.model:\" +\n            properties.getProperty(\"truecase.model\",\n                DefaultPaths.DEFAULT_TRUECASE_MODEL) +\n            \"truecase.bias:\" +\n            properties.getProperty(\"truecase.bias\",\n                TrueCaseAnnotator.DEFAULT_MODEL_BIAS) +\n            \"truecase.mixedcasefile:\" +\n            properties.getProperty(\"truecase.mixedcasefile\",\n                DefaultPaths.DEFAULT_TRUECASE_DISAMBIGUATION_LIST);\n      }\n    };\n  }","commit_id":"49c6e52f4c27fe76871e537ebc363d00b1409fa0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Infer the original casing of tokens\n   */\n  public Annotator trueCase(Properties properties, String modelLoc,\n                               String classBias,\n                               String mixedCaseFileName,\n                               boolean verbose) {\n    return new TrueCaseAnnotator(modelLoc, classBias, mixedCaseFileName, verbose);\n  }","id":44953,"modified_method":"/**\n   * Infer the original casing of tokens\n   */\n  public Annotator trueCase(Properties properties) {\n    return new TrueCaseAnnotator(properties);\n  }","commit_id":"49c6e52f4c27fe76871e537ebc363d00b1409fa0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public SingletonAnnotator(String host, int port,\n                              Properties properties,\n                              String annotator) {\n      Properties forClient = new Properties();\n      Enumeration<Object> keys = properties.keys();\n      while (keys.hasMoreElements()) {\n        String key = keys.nextElement().toString();\n        String value = properties.getProperty(key);\n        forClient.setProperty(key, value);\n        forClient.setProperty(annotator + \".\" + key, value);\n      }\n      forClient.setProperty(\"annotators\", annotator);\n      forClient.setProperty(\"enforceRequirements\", \"false\");\n      this.client = new StanfordCoreNLPClient(forClient, host, port);\n    }","id":44954,"modified_method":"public SingletonAnnotator(String host, int port,\n                              Properties properties,\n                              String annotator) {\n      Properties forClient = new Properties();\n      for (Object o : properties.keySet()) {\n        String key = o.toString();\n        String value = properties.getProperty(key);\n        forClient.setProperty(key, value);\n        forClient.setProperty(annotator + '.' + key, value);\n      }\n      forClient.setProperty(\"annotators\", annotator);\n      forClient.setProperty(\"enforceRequirements\", \"false\");\n      this.client = new StanfordCoreNLPClient(forClient, host, port);\n    }","commit_id":"49c6e52f4c27fe76871e537ebc363d00b1409fa0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** {@inheritDoc} */\n  @Override\n  public Annotator trueCase(Properties properties, String modelLoc,\n                            String classBias,\n                            String mixedCaseFileName,\n                            boolean verbose) {\n    return new SingletonAnnotator(host, port, properties, Annotator.STANFORD_TRUECASE);\n  }","id":44955,"modified_method":"/** {@inheritDoc} */\n  @Override\n  public Annotator trueCase(Properties properties) {\n    return new SingletonAnnotator(host, port, properties, Annotator.STANFORD_TRUECASE);\n  }","commit_id":"49c6e52f4c27fe76871e537ebc363d00b1409fa0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static Map<String,String> loadMixedCaseMap(String mapFile) {\n    Map<String,String> map = Generics.newHashMap();\n    try {\n      InputStream is = IOUtils.getInputStreamFromURLOrClasspathOrFileSystem(mapFile);\n      BufferedReader br = new BufferedReader(new InputStreamReader(is));\n      for(String line : ObjectBank.getLineIterator(br)) {\n        line = line.trim();\n        String[] els = line.split(\"\\\\s+\");\n        if(els.length != 2)\n          throw new RuntimeException(\"Wrong format: \"+mapFile);\n        map.put(els[0],els[1]);\n      }\n      br.close();\n      is.close();\n    } catch(IOException e){\n      throw new RuntimeException(e);\n    }\n    return map;\n  }","id":44956,"modified_method":"private static Map<String,String> loadMixedCaseMap(String mapFile) {\n    Map<String,String> map = Generics.newHashMap();\n    try {\n      BufferedReader br = IOUtils.readerFromString(mapFile);\n      for (String line : ObjectBank.getLineIterator(br)) {\n        line = line.trim();\n        String[] els = line.split(\"\\\\s+\");\n        if (els.length != 2) {\n          throw new RuntimeException(\"Wrong format: \" + mapFile);\n        }\n        map.put(els[0],els[1]);\n      }\n      br.close();\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n    return map;\n  }","commit_id":"49c6e52f4c27fe76871e537ebc363d00b1409fa0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public TrueCaseAnnotator(String modelLoc,\n      String classBias,\n      String mixedCaseFileName,\n      boolean verbose){\n    this.VERBOSE = verbose;\n\n    Properties props = new Properties();\n    props.setProperty(\"loadClassifier\", modelLoc);\n    props.setProperty(\"mixedCaseMapFile\", mixedCaseFileName);\n    props.setProperty(\"classBias\", classBias);\n    trueCaser = new CRFBiasedClassifier(props);\n\n    if (modelLoc != null) {\n      trueCaser.loadClassifierNoExceptions(modelLoc, props);\n    } else {\n      throw new RuntimeException(\"Model location not specified for true-case classifier!\");\n    }\n\n    if(classBias != null) {\n      StringTokenizer biases = new java.util.StringTokenizer(classBias,\",\");\n      while (biases.hasMoreTokens()) {\n        StringTokenizer bias = new java.util.StringTokenizer(biases.nextToken(),\":\");\n        String cname = bias.nextToken();\n        double w = Double.parseDouble(bias.nextToken());\n        trueCaser.setBiasWeight(cname,w);\n        if(VERBOSE) log.info(\"Setting bias for class \"+cname+\" to \"+w);\n      }\n    }\n\n    // Load map containing mixed-case words:\n    mixedCaseMap = loadMixedCaseMap(mixedCaseFileName);\n  }","id":44957,"modified_method":"public TrueCaseAnnotator(String modelLoc,\n                           String classBias,\n                           String mixedCaseFileName,\n                           boolean verbose) {\n    this.verbose = verbose;\n\n    Properties props = PropertiesUtils.asProperties(\n            \"loadClassifier\", modelLoc,\n            \"mixedCaseMapFile\", mixedCaseFileName,\n            \"classBias\", classBias);\n    trueCaser = new CRFBiasedClassifier<>(props);\n\n    if (modelLoc != null) {\n      trueCaser.loadClassifierNoExceptions(modelLoc, props);\n    } else {\n      throw new RuntimeException(\"Model location not specified for true-case classifier!\");\n    }\n\n    if (classBias != null) {\n      StringTokenizer biases = new java.util.StringTokenizer(classBias,\",\");\n      while (biases.hasMoreTokens()) {\n        StringTokenizer bias = new java.util.StringTokenizer(biases.nextToken(),\":\");\n        String cname = bias.nextToken();\n        double w = Double.parseDouble(bias.nextToken());\n        trueCaser.setBiasWeight(cname,w);\n        if (this.verbose) log.info(\"Setting bias for class \" + cname + \" to \" + w);\n      }\n    }\n\n    // Load map containing mixed-case words:\n    mixedCaseMap = loadMixedCaseMap(mixedCaseFileName);\n  }","commit_id":"49c6e52f4c27fe76871e537ebc363d00b1409fa0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public void annotate(Annotation annotation) {\n    if (VERBOSE) {\n      log.info(\"Adding true-case annotation...\");\n    }\n\n    if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n      // classify tokens for each sentence\n      for (CoreMap sentence: annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n        List<CoreLabel> output = this.trueCaser.classifySentence(tokens);\n        for (int i = 0; i < tokens.size(); ++i) {\n\n          // add the named entity tag to each token\n          String neTag = output.get(i).get(CoreAnnotations.AnswerAnnotation.class);\n          tokens.get(i).set(CoreAnnotations.TrueCaseAnnotation.class, neTag);\n          setTrueCaseText(tokens.get(i));\n        }\n      }\n    } else {\n      throw new RuntimeException(\"unable to find sentences in: \" + annotation);\n    }\n  }","id":44958,"modified_method":"@Override\n  public void annotate(Annotation annotation) {\n    if (verbose) {\n      log.info(\"Adding true-case annotation...\");\n    }\n\n    if (annotation.containsKey(CoreAnnotations.SentencesAnnotation.class)) {\n      // classify tokens for each sentence\n      for (CoreMap sentence: annotation.get(CoreAnnotations.SentencesAnnotation.class)) {\n        List<CoreLabel> tokens = sentence.get(CoreAnnotations.TokensAnnotation.class);\n        List<CoreLabel> output = this.trueCaser.classifySentence(tokens);\n        for (int i = 0; i < tokens.size(); ++i) {\n\n          // add the named entity tag to each token\n          String neTag = output.get(i).get(CoreAnnotations.AnswerAnnotation.class);\n          tokens.get(i).set(CoreAnnotations.TrueCaseAnnotation.class, neTag);\n          setTrueCaseText(tokens.get(i));\n        }\n      }\n    } else {\n      throw new RuntimeException(\"unable to find sentences in: \" + annotation);\n    }\n  }","commit_id":"49c6e52f4c27fe76871e537ebc363d00b1409fa0","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public List<org.sakaiproject.service.gradebook.shared.Assignment> getViewableAssignmentsForCurrentUser(String gradebookUid)\n  \tthrows GradebookNotFoundException {\n\t  if (!getAuthz().isUserAbleToGrade(gradebookUid)) {\n\t\t\t  return null;\n\t  }\n\t  \n\t if (getAuthz().isUserAbleToGradeAll(gradebookUid) || !getAuthz().isUserHasGraderPermissions(gradebookUid)) {\n\t\t  return getAssignments(gradebookUid);\n\t  }\n\t  \n\t  // if this gradebook has categories enabled, we need to check for category-specific restrictions\n\t  Gradebook gradebook = getGradebook(gradebookUid);\n\t  if (gradebook.getCategory_type() == GradebookService.CATEGORY_TYPE_NO_CATEGORY) {\n\t\t  return getAssignments(gradebookUid);\n\t  }\n\t  \n\t  String userUid = getUserUid();\n\t  if (getGradebookPermissionService().getPermissionForUserForAllAssignment(gradebook.getId(), userUid)) {\n\t\t  return getAssignments(gradebookUid);\n\t  }\n\t  \n\t  List<Assignment> viewableAssignments = new ArrayList();\n\t  \n\t  // categories are enabled, so we need to check the category restrictions\n\t  List allCategories = getCategoriesWithAssignments(gradebook.getId());\n\t  if (allCategories != null && !allCategories.isEmpty()) {\n\t\t  List<Category> viewableCategories = getGradebookPermissionService().getCategoriesForUser(gradebook.getId(), userUid, allCategories, gradebook.getCategory_type());\n\t\t  \n\t\t  for (Iterator catIter = viewableCategories.iterator(); catIter.hasNext();) {\n\t\t\t  Category cat = (Category) catIter.next();\n\t\t\t  if (cat != null) {\n\t\t\t\t  List assignments = cat.getAssignmentList();\n\t\t\t\t  if (assignments != null && !assignments.isEmpty()) {\n\t\t\t\t\t  viewableAssignments.addAll(assignments);\n\t\t\t\t  }\n\t\t\t  }\n\t\t  }\n\t  }\n\t  \n\t  // Now we need to convert these to the assignment template objects\n\t  if (viewableAssignments == null || viewableAssignments.isEmpty())\n\t\t  return new ArrayList();\n\t  \n\t  List assignmentsToReturn = new ArrayList();\n\t  for (Iterator assignIter = viewableAssignments.iterator(); assignIter.hasNext();) {\n\t\t  Assignment assignment = (Assignment) assignIter.next();\n\t\t  assignmentsToReturn.add(getAssignmentDefinition(assignment));\n\t  }\n\t  \n\t  return assignmentsToReturn;\n\t  \n  }","id":44959,"modified_method":"public List<org.sakaiproject.service.gradebook.shared.Assignment> getViewableAssignmentsForCurrentUser(String gradebookUid)\n  throws GradebookNotFoundException {\n\n\t  List<Assignment> viewableAssignments = new ArrayList();\n\t  List<org.sakaiproject.service.gradebook.shared.Assignment> assignmentsToReturn = new ArrayList();\n\n\t  Gradebook gradebook = getGradebook(gradebookUid);\n\n\t  // will send back all assignments if user can grade all\n\t  if (getAuthz().isUserAbleToGradeAll(gradebookUid)) {\n\t\t  viewableAssignments = getAssignments(gradebook.getId(), null, true);\n\t  } else if (!getAuthz().isUserHasGraderPermissions(gradebookUid)) {  \n\t\t  // user doesn't have grader permissions, so check to see if able to grade or view own grades\n\t\t  if (getAuthz().isUserAbleToGrade(gradebookUid) || getAuthz().isUserAbleToViewOwnGrades(gradebookUid)) {\n\t\t\t  viewableAssignments = getAssignments(gradebook.getId(), null, true);\n\t\t  }\n\t  } else {  \n\t\t  // this user has grader perms, so we need to filter the items returned\n\t\t  // if this gradebook has categories enabled, we need to check for category-specific restrictions\n\n\t\t  if (gradebook.getCategory_type() == GradebookService.CATEGORY_TYPE_NO_CATEGORY) {\n\t\t\t  assignmentsToReturn = getAssignments(gradebookUid);\n\t\t  } else {\n\n\t\t\t  String userUid = getUserUid();\n\t\t\t  if (getGradebookPermissionService().getPermissionForUserForAllAssignment(gradebook.getId(), userUid)) {\n\t\t\t\t  assignmentsToReturn = getAssignments(gradebookUid);\n\t\t\t  }\n\n\t\t\t  // categories are enabled, so we need to check the category restrictions\n\t\t\t  List allCategories = getCategoriesWithAssignments(gradebook.getId());\n\t\t\t  if (allCategories != null && !allCategories.isEmpty()) {\n\t\t\t\t  List<Category> viewableCategories = getGradebookPermissionService().getCategoriesForUser(gradebook.getId(), userUid, allCategories, gradebook.getCategory_type());\n\n\t\t\t\t  for (Iterator catIter = viewableCategories.iterator(); catIter.hasNext();) {\n\t\t\t\t\t  Category cat = (Category) catIter.next();\n\t\t\t\t\t  if (cat != null) {\n\t\t\t\t\t\t  List assignments = cat.getAssignmentList();\n\t\t\t\t\t\t  if (assignments != null && !assignments.isEmpty()) {\n\t\t\t\t\t\t\t  viewableAssignments.addAll(assignments);\n\t\t\t\t\t\t  }\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t  }\n\t  }\n\n\t  // Now we need to convert these to the assignment template objects\n\t  if (viewableAssignments != null && !viewableAssignments.isEmpty()) {\n\t\t  for (Iterator assignIter = viewableAssignments.iterator(); assignIter.hasNext();) {\n\t\t\t  Assignment assignment = (Assignment) assignIter.next();\n\t\t\t  assignmentsToReturn.add(getAssignmentDefinition(assignment));\n\t\t  }\n\t  }\n\n\t  return assignmentsToReturn;\n\n  }","commit_id":"7580735d17a0b3f4a6a3c22a9012eb5d35d4f5aa","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Update the order of an assignment.\n     * \n     * @param siteId\tthe siteId\n     * @param assignmentId the assignment we are reordering\n     * @param order the new order\n     * @throws JAXBException\n     * @throws IdUnusedException\n     * @throws PermissionException\n     */\n    public void updateAssignmentOrder(String siteId, long assignmentId, int order) throws JAXBException, IdUnusedException, PermissionException {\n    \t\n    \tSite site = null;\n\t\ttry {\n\t\t\tsite = this.siteService.getSite(siteId);\n\t\t} catch (IdUnusedException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tResourcePropertiesEdit props = site.getPropertiesEdit();\n    \tString xml = props.getProperty(ASSIGNMENT_ORDER_PROP);\n    \t\n    \tList<AssignmentOrder> assignmentOrder = new ArrayList<>();\n    \tif(StringUtils.isNotBlank(xml)) {\n    \t\tXmlList<AssignmentOrder> xmlList = (XmlList<AssignmentOrder>) XmlMarshaller.unmarshall(xml);\n    \t\tif(xmlList != null) {\n    \t\t\tassignmentOrder = xmlList.getItems();\n    \t\t}\n    \t}\n    \t\n    \t//try to update an existing order\n    \tboolean matched = false;\n    \tfor(AssignmentOrder as: assignmentOrder) {\n    \t\tif(as.getAssignmentId() == assignmentId) {\n    \t\t\tmatched = true;\n    \t\t\tas.setOrder(order);\n    \t\t}\n    \t}\n    \t\n    \t//otherwise add it\n    \tif(!matched) {\n    \t\tassignmentOrder.add(new AssignmentOrder(assignmentId, order));\n    \t}\n    \t\n    \t//serialise the XmlList back to xml\n    \tXmlList<AssignmentOrder> updatedXmlList = new XmlList<AssignmentOrder>(assignmentOrder);\n    \tString updatedXml = XmlMarshaller.marshal(updatedXmlList);\n\t\t\n\t\t//and save it\n\t\tprops.addProperty(ASSIGNMENT_ORDER_PROP, updatedXml);\n\t\t\n\t\tlog.debug(\"Updated assignment order: \" + updatedXml);\n\t\t\n\t\tthis.siteService.save(site);\n    \t\n    }","id":44960,"modified_method":"/**\n     * Update the order of an assignment.\n     * \n     * @param siteId\tthe siteId\n     * @param assignmentId the assignment we are reordering\n     * @param order the new order\n     * @throws JAXBException\n     * @throws IdUnusedException\n     * @throws PermissionException\n     */\n    public void updateAssignmentOrder(String siteId, long assignmentId, int order) throws JAXBException, IdUnusedException, PermissionException {\n    \t\n\t\tGradebook gradebook = this.getGradebook(siteId); //this is called from an entity provider so must provide the siteId\n\t\tthis.gradebookService.updateAssignmentOrder(gradebook.getUid(), assignmentId, order);\n    }","commit_id":"f9611920e0852e2e60741b99c93bec1f4c9a6128","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Get a list of assignments in the gradebook in the specified site\n\t * \n\t * @param siteId the siteId\n\t * @return a list of assignments or null if no gradebook\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic List<Assignment> getGradebookAssignments(String siteId) {\n\t\tGradebook gradebook = getGradebook(siteId);\n\t\tif(gradebook != null) {\n\t\t\tList<Assignment> assignments = gradebookService.getAssignments(gradebook.getUid());\n\t\t\tassignments = sortAssignments(siteId,assignments);\t\t\t\n\t\t\treturn assignments;\n\t\t}\n\t\treturn null;\n\t}","id":44961,"modified_method":"/**\n\t * Get a list of assignments in the gradebook in the specified site, sorted by sort order\n\t * \n\t * @param siteId the siteId\n\t * @return a list of assignments or null if no gradebook\n\t */\n\tpublic List<Assignment> getGradebookAssignments(String siteId) {\n\t\tGradebook gradebook = getGradebook(siteId);\n\t\tif(gradebook != null) {\n\t\t\treturn gradebookService.getAssignments(gradebook.getUid(), SortType.SORT_BY_SORTING);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"f9611920e0852e2e60741b99c93bec1f4c9a6128","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public static void main(String[] args) throws Exception {\n        OptionParser parser = new OptionParser();\n        OptionSpec<Integer> clusterId = parser.accepts(\"clusterId\", \"MongoMK clusterId\")\n                .withRequiredArg().ofType(Integer.class).defaultsTo(0);\n        OptionSpec quiet = parser.accepts(\"quiet\", \"be less chatty\");\n        OptionSpec shell = parser.accepts(\"shell\", \"run the shell after executing files\");\n        OptionSpec help = parser.acceptsAll(asList(\"h\", \"?\", \"help\"), \"show help\").forHelp();\n        OptionSpec<String> nonOption = parser.nonOptions(\"console {<path-to-repository> | <mongodb-uri>}\");\n\n        OptionSet options = parser.parse(args);\n        List<String> nonOptions = nonOption.values(options);\n\n        if (options.has(help)) {\n            parser.printHelpOn(System.out);\n            System.exit(0);\n        }\n\n        if (nonOptions.isEmpty()) {\n            parser.printHelpOn(System.err);\n            System.exit(1);\n        }\n\n        NodeStore store;\n        if (nonOptions.get(0).startsWith(MongoURI.MONGODB_PREFIX)) {\n            MongoClientURI uri = new MongoClientURI(nonOptions.get(0));\n            if (uri.getDatabase() == null) {\n                System.err.println(\"Database missing in MongoDB URI: \" + uri.getURI());\n                System.exit(1);\n            }\n            MongoConnection mongo = new MongoConnection(uri.getURI());\n            store = new DocumentMK.Builder().\n                    setMongoDB(mongo.getDB()).\n                    setClusterId(clusterId.value(options)).getNodeStore();\n        } else {\n            store = new SegmentNodeStore(new FileStore(\n                    new File(nonOptions.get(0)), 256));\n        }\n        \n        \n\n        List<String> scriptArgs = nonOptions.size() > 1 ?\n                nonOptions.subList(1, nonOptions.size()) : Collections.<String>emptyList();\n        IO io = new IO();\n\n        if(options.has(quiet)){\n            io.setVerbosity(IO.Verbosity.QUIET);\n        }\n\n        GroovyConsole console =\n                new GroovyConsole(ConsoleSession.create(store), new IO());\n\n        int code = 0;\n        if(!scriptArgs.isEmpty()){\n            code = console.execute(scriptArgs);\n        }\n\n        if(scriptArgs.isEmpty() || options.has(shell)){\n            code = console.run();\n        }\n\n        System.exit(code);\n    }","id":44962,"modified_method":"public static void main(String[] args) throws Exception {\n        OptionParser parser = new OptionParser();\n        OptionSpec<Integer> clusterId = parser.accepts(\"clusterId\", \"MongoMK clusterId\")\n                .withRequiredArg().ofType(Integer.class).defaultsTo(0);\n        OptionSpec quiet = parser.accepts(\"quiet\", \"be less chatty\");\n        OptionSpec shell = parser.accepts(\"shell\", \"run the shell after executing files\");\n        OptionSpec help = parser.acceptsAll(asList(\"h\", \"?\", \"help\"), \"show help\").forHelp();\n        OptionSpec<String> nonOption = parser.nonOptions(\"console {<path-to-repository> | <mongodb-uri>}\");\n\n        OptionSet options = parser.parse(args);\n        List<String> nonOptions = nonOption.values(options);\n\n        if (options.has(help)) {\n            parser.printHelpOn(System.out);\n            System.exit(0);\n        }\n\n        if (nonOptions.isEmpty()) {\n            parser.printHelpOn(System.err);\n            System.exit(1);\n        }\n\n        NodeStoreFixture fixture;\n        if (nonOptions.get(0).startsWith(MongoURI.MONGODB_PREFIX)) {\n            MongoClientURI uri = new MongoClientURI(nonOptions.get(0));\n            if (uri.getDatabase() == null) {\n                System.err.println(\"Database missing in MongoDB URI: \" + uri.getURI());\n                System.exit(1);\n            }\n            MongoConnection mongo = new MongoConnection(uri.getURI());\n            DocumentNodeStore store = new DocumentMK.Builder().\n                    setMongoDB(mongo.getDB()).\n                    setClusterId(clusterId.value(options)).getNodeStore();\n            fixture = new MongoFixture(store);\n        } else {\n            fixture = new SegmentFixture(new FileStore(\n                    new File(nonOptions.get(0)), 256));\n        }\n        \n        \n\n        List<String> scriptArgs = nonOptions.size() > 1 ?\n                nonOptions.subList(1, nonOptions.size()) : Collections.<String>emptyList();\n        IO io = new IO();\n\n        if(options.has(quiet)){\n            io.setVerbosity(IO.Verbosity.QUIET);\n        }\n\n        GroovyConsole console =\n                new GroovyConsole(ConsoleSession.create(fixture.getStore()), new IO(), fixture);\n\n        int code = 0;\n        if(!scriptArgs.isEmpty()){\n            code = console.execute(scriptArgs);\n        }\n\n        if(scriptArgs.isEmpty() || options.has(shell)){\n            code = console.run();\n        }\n\n        System.exit(code);\n    }","commit_id":"ea4cc5a5729928233db423814ee5c535d7be2772","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws GridException If example execution failed.\n     */\n    public static void main(String[] args) throws GridException, InterruptedException {\n        try (Grid g = GridGain.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache events example started.\");\n\n            final GridCache<Integer, String> cache = g.cache(CACHE_NAME);\n\n            // Clean up caches on all nodes before run.\n            cache.globalClearAll(0);\n\n            // This optional local callback is called for each event notification\n            // that passed remote predicate listener.\n            GridBiPredicate<UUID, GridCacheEvent> locLsnr = new GridBiPredicate<UUID, GridCacheEvent>() {\n                @Override public boolean apply(UUID uuid, GridCacheEvent evt) {\n                    System.out.println(\"Received event [evt=\" + evt.name() + \", key=\" + evt.key() +\n                        \", oldVal=\" + evt.oldValue() + \", newVal=\" + evt.newValue());\n\n                    return true; // Continue listening.\n                }\n            };\n\n            // Remote listener which only accepts events for keys that are\n            // greater or equal than 10 and if event node is primary for this key.\n            GridPredicate<GridCacheEvent> rmtLsnr = new GridPredicate<GridCacheEvent>() {\n                @Override public boolean apply(GridCacheEvent evt) {\n                    System.out.println(\"Cache event [name=\" + evt.name() + \", key=\" + evt.key() + ']');\n\n                    int key = evt.key();\n\n                    return key >= 10 && cache.affinity().isPrimary(g.localNode(), key);\n                }\n            };\n\n            // Subscribe to specified cache events on all nodes that have cache running.\n            // Cache events are explicitly enabled in examples/config/example-cache.xml file.\n            GridFuture<UUID> fut = g.forCache(CACHE_NAME).events().remoteListen(locLsnr, rmtLsnr,\n                EVT_CACHE_OBJECT_PUT, EVT_CACHE_OBJECT_READ, EVT_CACHE_OBJECT_REMOVED);\n\n            // Wait until event listeners are subscribed on all nodes.\n            fut.get();\n\n            // Generate cache events.\n            for (int i = 0; i < 20; i++)\n                cache.putx(i, Integer.toString(i));\n\n            // Wait for a while while callback is notified about remaining puts.\n            Thread.sleep(2000);\n        }\n    }","id":44963,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws GridException If example execution failed.\n     */\n    public static void main(String[] args) throws GridException, InterruptedException {\n        try (Grid g = GridGain.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache events example started.\");\n\n            final GridCache<Integer, String> cache = g.cache(CACHE_NAME);\n\n            // Clean up caches on all nodes before run.\n            cache.globalClearAll(0);\n\n            // This optional local callback is called for each event notification\n            // that passed remote predicate listener.\n            GridBiPredicate<UUID, GridCacheEvent> locLsnr = new GridBiPredicate<UUID, GridCacheEvent>() {\n                @Override public boolean apply(UUID uuid, GridCacheEvent evt) {\n                    System.out.println(\"Received event [evt=\" + evt.name() + \", key=\" + evt.key() +\n                        \", oldVal=\" + evt.oldValue() + \", newVal=\" + evt.newValue());\n\n                    return true; // Continue listening.\n                }\n            };\n\n            // Remote listener which only accepts events for keys that are\n            // greater or equal than 10 and if event node is primary for this key.\n            GridPredicate<GridCacheEvent> rmtLsnr = new GridPredicate<GridCacheEvent>() {\n                @Override public boolean apply(GridCacheEvent evt) {\n                    System.out.println(\"Cache event [name=\" + evt.name() + \", key=\" + evt.key() + ']');\n\n                    int key = evt.key();\n\n                    return key >= 10 && cache.affinity().isPrimary(g.localNode(), key);\n                }\n            };\n\n            // Subscribe to specified cache events on all nodes that have cache running.\n            // Cache events are explicitly enabled in examples/config/example-cache.xml file.\n            g.forCache(CACHE_NAME).events().remoteListen(locLsnr, rmtLsnr,\n                EVT_CACHE_OBJECT_PUT, EVT_CACHE_OBJECT_READ, EVT_CACHE_OBJECT_REMOVED);\n\n            // Generate cache events.\n            for (int i = 0; i < 20; i++)\n                cache.putx(i, Integer.toString(i));\n\n            // Wait for a while while callback is notified about remaining puts.\n            Thread.sleep(2000);\n        }\n    }","commit_id":"eeb272527046a5363aa4bc5dff2866aa08bbabf2","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Listen to events coming from all grid nodes.\n     *\n     * @throws GridException If failed.\n     */\n    private static void remoteListen() throws GridException {\n        System.out.println();\n        System.out.println(\">>> Remote event listener example.\");\n\n        // This optional local callback is called for each event notification\n        // that passed remote predicate listener.\n        GridBiPredicate<UUID, GridTaskEvent> locLsnr = new GridBiPredicate<UUID, GridTaskEvent>() {\n            @Override public boolean apply(UUID nodeId, GridTaskEvent evt) {\n                // Remote filter only accepts tasks whose name being with \"good-task\" prefix.\n                assert evt.taskName().startsWith(\"good-task\");\n\n                System.out.println(\"Received task event [evt=\" + evt.name() + \", taskName=\" + evt.taskName());\n\n                return true; // Return true to continue listening.\n            }\n        };\n\n        // Remote filter which only accepts tasks whose name begins with \"good-task\" prefix.\n        GridPredicate<GridTaskEvent> rmtLsnr = new GridPredicate<GridTaskEvent>() {\n            @Override public boolean apply(GridTaskEvent evt) {\n                return evt.taskName().startsWith(\"good-task\");\n            }\n        };\n\n        Grid g = GridGain.grid();\n\n        // Register event listeners on all nodes to listen for task events.\n        GridFuture<?> fut = g.events().remoteListen(locLsnr, rmtLsnr, EVTS_TASK_EXECUTION);\n\n        // Wait until event listeners are subscribed on all nodes.\n        fut.get();\n\n        // Generate task events.\n        for (int i = 0; i < 10; i++) {\n            g.compute().withName(i < 5 ? \"good-task-\" + i : \"bad-task-\" + i).run(new GridRunnable() {\n                // Auto-inject task session.\n                @GridTaskSessionResource\n                private GridComputeTaskSession ses;\n\n                @Override public void run() {\n                    System.out.println(\"Executing sample job for task: \" + ses.getTaskName());\n                }\n            });\n        }\n    }","id":44964,"modified_method":"/**\n     * Listen to events coming from all grid nodes.\n     *\n     * @throws GridException If failed.\n     */\n    private static void remoteListen() throws GridException {\n        System.out.println();\n        System.out.println(\">>> Remote event listener example.\");\n\n        // This optional local callback is called for each event notification\n        // that passed remote predicate listener.\n        GridBiPredicate<UUID, GridTaskEvent> locLsnr = new GridBiPredicate<UUID, GridTaskEvent>() {\n            @Override public boolean apply(UUID nodeId, GridTaskEvent evt) {\n                // Remote filter only accepts tasks whose name being with \"good-task\" prefix.\n                assert evt.taskName().startsWith(\"good-task\");\n\n                System.out.println(\"Received task event [evt=\" + evt.name() + \", taskName=\" + evt.taskName());\n\n                return true; // Return true to continue listening.\n            }\n        };\n\n        // Remote filter which only accepts tasks whose name begins with \"good-task\" prefix.\n        GridPredicate<GridTaskEvent> rmtLsnr = new GridPredicate<GridTaskEvent>() {\n            @Override public boolean apply(GridTaskEvent evt) {\n                return evt.taskName().startsWith(\"good-task\");\n            }\n        };\n\n        Grid g = GridGain.grid();\n\n        // Register event listeners on all nodes to listen for task events.\n        g.events().remoteListen(locLsnr, rmtLsnr, EVTS_TASK_EXECUTION);\n\n        // Generate task events.\n        for (int i = 0; i < 10; i++) {\n            g.compute().withName(i < 5 ? \"good-task-\" + i : \"bad-task-\" + i).run(new GridRunnable() {\n                // Auto-inject task session.\n                @GridTaskSessionResource\n                private GridComputeTaskSession ses;\n\n                @Override public void run() {\n                    System.out.println(\"Executing sample job for task: \" + ses.getTaskName());\n                }\n            });\n        }\n    }","commit_id":"eeb272527046a5363aa4bc5dff2866aa08bbabf2","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings( {\"AssignmentToCatchBlockParameter\"})\n    public void testCancel() throws Exception {\n        Grid grid = G.grid(getTestGridName());\n\n        grid.compute().localDeployTask(GridCancelTestTask.class, GridCancelTestTask.class.getClassLoader());\n\n        GridComputeTaskFuture<?> res0 =\n            grid.compute().withTimeout(maxJobExecTime * 2).execute(GridCancelTestTask.class.getName(), null);\n\n        try {\n            Object res = res0.get();\n\n            info(\"Cancel test result: \" + res);\n\n            synchronized (mux) {\n                // Every execute must be called.\n                assert execCnt <= SPLIT_COUNT : \"Invalid execute count: \" + execCnt;\n\n                // Job returns 1 if was cancelled.\n                assert (Integer)res <= SPLIT_COUNT  : \"Invalid task result: \" + res;\n\n                // Should be exactly the same as Jobs number.\n                assert cancelCnt <= SPLIT_COUNT : \"Invalid cancel count: \" + cancelCnt;\n\n                // One per start and one per stop and some that come with heartbeats.\n                assert colResolutionCnt > SPLIT_COUNT + 1:\n                    \"Invalid collision resolution count: \" + colResolutionCnt;\n            }\n        }\n        catch (GridComputeTaskTimeoutException e) {\n            error(\"Task execution got timed out.\", e);\n        }\n        catch (Exception e) {\n            assert e.getCause() != null;\n\n            if (e.getCause() instanceof GridException)\n                e = (Exception)e.getCause();\n\n            if (e.getCause() instanceof IOException)\n                e = (Exception)e.getCause();\n\n            assert e.getCause() instanceof InterruptedException : \"Invalid exception cause: \" + e.getCause();\n        }\n    }","id":44965,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    @SuppressWarnings( {\"AssignmentToCatchBlockParameter\"})\n    public void testCancel() throws Exception {\n        Grid grid = G.grid(getTestGridName());\n\n        grid.compute().localDeployTask(GridCancelTestTask.class, GridCancelTestTask.class.getClassLoader());\n\n        GridComputeTaskFuture<?> res0 =\n            executeAsync(grid.compute().withTimeout(maxJobExecTime * 2), GridCancelTestTask.class.getName(), null);\n\n        try {\n            Object res = res0.get();\n\n            info(\"Cancel test result: \" + res);\n\n            synchronized (mux) {\n                // Every execute must be called.\n                assert execCnt <= SPLIT_COUNT : \"Invalid execute count: \" + execCnt;\n\n                // Job returns 1 if was cancelled.\n                assert (Integer)res <= SPLIT_COUNT  : \"Invalid task result: \" + res;\n\n                // Should be exactly the same as Jobs number.\n                assert cancelCnt <= SPLIT_COUNT : \"Invalid cancel count: \" + cancelCnt;\n\n                // One per start and one per stop and some that come with heartbeats.\n                assert colResolutionCnt > SPLIT_COUNT + 1:\n                    \"Invalid collision resolution count: \" + colResolutionCnt;\n            }\n        }\n        catch (GridComputeTaskTimeoutException e) {\n            error(\"Task execution got timed out.\", e);\n        }\n        catch (Exception e) {\n            assert e.getCause() != null;\n\n            if (e.getCause() instanceof GridException)\n                e = (Exception)e.getCause();\n\n            if (e.getCause() instanceof IOException)\n                e = (Exception)e.getCause();\n\n            assert e.getCause() instanceof InterruptedException : \"Invalid exception cause: \" + e.getCause();\n        }\n    }","commit_id":"eeb272527046a5363aa4bc5dff2866aa08bbabf2","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected void beforeTestsStarted() throws Exception {\n        super.beforeTestsStarted();\n\n        startGrid(0);\n\n        startGrid(1).services().deployNodeSingleton(SERVICE_NAME, new DummyService()).get();\n\n        assertEquals(2, grid(0).nodes().size());\n        assertEquals(2, grid(1).nodes().size());\n    }","id":44966,"modified_method":"/** {@inheritDoc} */\n    @Override protected void beforeTestsStarted() throws Exception {\n        super.beforeTestsStarted();\n\n        startGrid(0);\n\n        startGrid(1).services().deployNodeSingleton(SERVICE_NAME, new DummyService());\n\n        assertEquals(2, grid(0).nodes().size());\n        assertEquals(2, grid(1).nodes().size());\n    }","commit_id":"eeb272527046a5363aa4bc5dff2866aa08bbabf2","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Start listening to messages on all grid nodes within passed in projection.\n     *\n     * @param prj Grid projection.\n     * @throws GridException If failed.\n     */\n    private static void startListening(GridProjection prj) throws GridException {\n        // Add ordered message listener.\n        prj.message().remoteListen(TOPIC.ORDERED, new GridBiPredicate<UUID, String>() {\n            @GridInstanceResource\n            private Grid g;\n\n            @Override public boolean apply(UUID nodeId, String msg) {\n                System.out.println(\"Received ordered message [msg=\" + msg + \", fromNodeId=\" + nodeId + ']');\n\n                try {\n                    g.forNodeId(nodeId).message().send(TOPIC.ORDERED, msg);\n                }\n                catch (GridException e) {\n                    e.printStackTrace();\n                }\n\n                return true; // Return true to continue listening.\n            }\n        }).get();\n\n        // Add unordered message listener.\n        prj.message().remoteListen(TOPIC.UNORDERED, new GridBiPredicate<UUID, String>() {\n            @GridInstanceResource\n            private Grid g;\n\n            @Override public boolean apply(UUID nodeId, String msg) {\n                System.out.println(\"Received unordered message [msg=\" + msg + \", fromNodeId=\" + nodeId + ']');\n\n                try {\n                    g.forNodeId(nodeId).message().send(TOPIC.UNORDERED, msg);\n                }\n                catch (GridException e) {\n                    e.printStackTrace();\n                }\n\n                return true; // Return true to continue listening.\n            }\n        }).get();\n    }","id":44967,"modified_method":"/**\n     * Start listening to messages on all grid nodes within passed in projection.\n     *\n     * @param prj Grid projection.\n     * @throws GridException If failed.\n     */\n    private static void startListening(GridProjection prj) throws GridException {\n        // Add ordered message listener.\n        prj.message().remoteListen(TOPIC.ORDERED, new GridBiPredicate<UUID, String>() {\n            @GridInstanceResource\n            private Grid g;\n\n            @Override public boolean apply(UUID nodeId, String msg) {\n                System.out.println(\"Received ordered message [msg=\" + msg + \", fromNodeId=\" + nodeId + ']');\n\n                try {\n                    g.forNodeId(nodeId).message().send(TOPIC.ORDERED, msg);\n                }\n                catch (GridException e) {\n                    e.printStackTrace();\n                }\n\n                return true; // Return true to continue listening.\n            }\n        });\n\n        // Add unordered message listener.\n        prj.message().remoteListen(TOPIC.UNORDERED, new GridBiPredicate<UUID, String>() {\n            @GridInstanceResource\n            private Grid g;\n\n            @Override public boolean apply(UUID nodeId, String msg) {\n                System.out.println(\"Received unordered message [msg=\" + msg + \", fromNodeId=\" + nodeId + ']');\n\n                try {\n                    g.forNodeId(nodeId).message().send(TOPIC.UNORDERED, msg);\n                }\n                catch (GridException e) {\n                    e.printStackTrace();\n                }\n\n                return true; // Return true to continue listening.\n            }\n        });\n    }","commit_id":"eeb272527046a5363aa4bc5dff2866aa08bbabf2","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws GridException If example execution failed.\n     */\n    public static void main(String[] args) throws GridException {\n        // Game is played over the default grid.\n        try (Grid g = GridGain.start(\"examples/config/example-compute.xml\")) {\n            if (!ExamplesUtils.checkMinTopologySize(g, 2))\n                return;\n\n            System.out.println();\n            System.out.println(\">>> Messaging ping-pong example started.\");\n\n            // Pick random remote node as a partner.\n            GridProjection nodeB = g.forRemotes().forRandom();\n\n            // Note that both nodeA and nodeB will always point to\n            // same nodes regardless of whether they were implicitly\n            // serialized and deserialized on another node as part of\n            // anonymous closure's state during its remote execution.\n\n            // Set up remote player.\n            nodeB.message().remoteListen(null, new GridBiPredicate<UUID, String>() {\n                /** This will be injected on node listener comes to. */\n                @GridInstanceResource\n                private Grid grid;\n\n                @Override public boolean apply(UUID nodeId, String rcvMsg) {\n                    System.out.println(\"Received message [msg=\" + rcvMsg + \", sender=\" + nodeId + ']');\n\n                    try {\n                        if (\"PING\".equals(rcvMsg)) {\n                            grid.forNodeId(nodeId).message().send(null, \"PONG\");\n\n                            return true; // Continue listening.\n                        }\n\n                        return false; // Unsubscribe.\n                    }\n                    catch (GridException e) {\n                        throw new GridClosureException(e);\n                    }\n                }\n            }).get();\n\n            int MAX_PLAYS = 10;\n\n            final CountDownLatch cnt = new CountDownLatch(MAX_PLAYS);\n\n            // Set up local player.\n            g.message().localListen(null, new GridBiPredicate<UUID, String>() {\n                @Override public boolean apply(UUID nodeId, String rcvMsg) {\n                    System.out.println(\"Received message [msg=\" + rcvMsg + \", sender=\" + nodeId + ']');\n\n                    try {\n                        if (cnt.getCount() == 1) {\n                            g.forNodeId(nodeId).message().send(null, \"STOP\");\n\n                            cnt.countDown();\n\n                            return false; // Stop listening.\n                        }\n                        else if (\"PONG\".equals(rcvMsg))\n                            g.forNodeId(nodeId).message().send(null, \"PING\");\n                        else\n                            throw new RuntimeException(\"Received unexpected message: \" + rcvMsg);\n\n                        cnt.countDown();\n\n                        return true; // Continue listening.\n                    }\n                    catch (GridException e) {\n                        throw new GridClosureException(e);\n                    }\n                }\n            });\n\n            // Serve!\n            nodeB.message().send(null, \"PING\");\n\n            // Wait til the game is over.\n            try {\n                cnt.await();\n            }\n            catch (InterruptedException e) {\n                System.err.println(\"Hm... let us finish the game!\\n\" + e);\n            }\n        }\n    }","id":44968,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws GridException If example execution failed.\n     */\n    public static void main(String[] args) throws GridException {\n        // Game is played over the default grid.\n        try (Grid g = GridGain.start(\"examples/config/example-compute.xml\")) {\n            if (!ExamplesUtils.checkMinTopologySize(g, 2))\n                return;\n\n            System.out.println();\n            System.out.println(\">>> Messaging ping-pong example started.\");\n\n            // Pick random remote node as a partner.\n            GridProjection nodeB = g.forRemotes().forRandom();\n\n            // Note that both nodeA and nodeB will always point to\n            // same nodes regardless of whether they were implicitly\n            // serialized and deserialized on another node as part of\n            // anonymous closure's state during its remote execution.\n\n            // Set up remote player.\n            nodeB.message().remoteListen(null, new GridBiPredicate<UUID, String>() {\n                /** This will be injected on node listener comes to. */\n                @GridInstanceResource\n                private Grid grid;\n\n                @Override public boolean apply(UUID nodeId, String rcvMsg) {\n                    System.out.println(\"Received message [msg=\" + rcvMsg + \", sender=\" + nodeId + ']');\n\n                    try {\n                        if (\"PING\".equals(rcvMsg)) {\n                            grid.forNodeId(nodeId).message().send(null, \"PONG\");\n\n                            return true; // Continue listening.\n                        }\n\n                        return false; // Unsubscribe.\n                    }\n                    catch (GridException e) {\n                        throw new GridClosureException(e);\n                    }\n                }\n            });\n\n            int MAX_PLAYS = 10;\n\n            final CountDownLatch cnt = new CountDownLatch(MAX_PLAYS);\n\n            // Set up local player.\n            g.message().localListen(null, new GridBiPredicate<UUID, String>() {\n                @Override public boolean apply(UUID nodeId, String rcvMsg) {\n                    System.out.println(\"Received message [msg=\" + rcvMsg + \", sender=\" + nodeId + ']');\n\n                    try {\n                        if (cnt.getCount() == 1) {\n                            g.forNodeId(nodeId).message().send(null, \"STOP\");\n\n                            cnt.countDown();\n\n                            return false; // Stop listening.\n                        }\n                        else if (\"PONG\".equals(rcvMsg))\n                            g.forNodeId(nodeId).message().send(null, \"PING\");\n                        else\n                            throw new RuntimeException(\"Received unexpected message: \" + rcvMsg);\n\n                        cnt.countDown();\n\n                        return true; // Continue listening.\n                    }\n                    catch (GridException e) {\n                        throw new GridClosureException(e);\n                    }\n                }\n            });\n\n            // Serve!\n            nodeB.message().send(null, \"PING\");\n\n            // Wait til the game is over.\n            try {\n                cnt.await();\n            }\n            catch (InterruptedException e) {\n                System.err.println(\"Hm... let us finish the game!\\n\" + e);\n            }\n        }\n    }","commit_id":"eeb272527046a5363aa4bc5dff2866aa08bbabf2","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws GridException If example execution failed.\n     */\n    public static void main(String[] args) throws GridException {\n        // Game is played over the default grid.\n        try (Grid g = GridGain.start(\"examples/config/example-compute.xml\")) {\n            if (!ExamplesUtils.checkMinTopologySize(g, 2))\n                return;\n\n            System.out.println();\n            System.out.println(\">>> Messaging ping-pong listen actor example started.\");\n\n            // Pick first remote node as a partner.\n            Collection<GridNode> rmtNodes = g.forRemotes().nodes();\n\n            GridProjection nodeB = g.forNode(rmtNodes.iterator().next());\n\n            // Note that both nodeA and nodeB will always point to\n            // same nodes regardless of whether they were implicitly\n            // serialized and deserialized on another node as part of\n            // anonymous closure's state during its remote execution.\n\n            // Set up remote player.\n            nodeB.message().remoteListen(null, new GridMessagingListenActor<String>() {\n                @Override public void receive(UUID nodeId, String rcvMsg) throws GridException {\n                    System.out.println(rcvMsg);\n\n                    if (\"PING\".equals(rcvMsg))\n                        respond(\"PONG\");\n                    else if (\"STOP\".equals(rcvMsg))\n                        stop();\n                }\n            }).get();\n\n            int MAX_PLAYS = 10;\n\n            final CountDownLatch cnt = new CountDownLatch(MAX_PLAYS);\n\n            // Set up local player.\n            g.message().localListen(null, new GridMessagingListenActor<String>() {\n                @Override protected void receive(UUID nodeId, String rcvMsg) throws GridException {\n                    System.out.println(rcvMsg);\n\n                    if (cnt.getCount() == 1)\n                        stop(\"STOP\");\n                    else if (\"PONG\".equals(rcvMsg))\n                        respond(\"PING\");\n\n                    cnt.countDown();\n                }\n            });\n\n            // Serve!\n            nodeB.message().send(null, \"PING\");\n\n            // Wait til the game is over.\n            try {\n                cnt.await();\n            }\n            catch (InterruptedException e) {\n                System.err.println(\"Hm... let us finish the game!\\n\" + e);\n            }\n        }\n    }","id":44969,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws GridException If example execution failed.\n     */\n    public static void main(String[] args) throws GridException {\n        // Game is played over the default grid.\n        try (Grid g = GridGain.start(\"examples/config/example-compute.xml\")) {\n            if (!ExamplesUtils.checkMinTopologySize(g, 2))\n                return;\n\n            System.out.println();\n            System.out.println(\">>> Messaging ping-pong listen actor example started.\");\n\n            // Pick first remote node as a partner.\n            Collection<GridNode> rmtNodes = g.forRemotes().nodes();\n\n            GridProjection nodeB = g.forNode(rmtNodes.iterator().next());\n\n            // Note that both nodeA and nodeB will always point to\n            // same nodes regardless of whether they were implicitly\n            // serialized and deserialized on another node as part of\n            // anonymous closure's state during its remote execution.\n\n            // Set up remote player.\n            nodeB.message().remoteListen(null, new GridMessagingListenActor<String>() {\n                @Override public void receive(UUID nodeId, String rcvMsg) throws GridException {\n                    System.out.println(rcvMsg);\n\n                    if (\"PING\".equals(rcvMsg))\n                        respond(\"PONG\");\n                    else if (\"STOP\".equals(rcvMsg))\n                        stop();\n                }\n            });\n\n            int MAX_PLAYS = 10;\n\n            final CountDownLatch cnt = new CountDownLatch(MAX_PLAYS);\n\n            // Set up local player.\n            g.message().localListen(null, new GridMessagingListenActor<String>() {\n                @Override protected void receive(UUID nodeId, String rcvMsg) throws GridException {\n                    System.out.println(rcvMsg);\n\n                    if (cnt.getCount() == 1)\n                        stop(\"STOP\");\n                    else if (\"PONG\".equals(rcvMsg))\n                        respond(\"PING\");\n\n                    cnt.countDown();\n                }\n            });\n\n            // Serve!\n            nodeB.message().send(null, \"PING\");\n\n            // Wait til the game is over.\n            try {\n                cnt.await();\n            }\n            catch (InterruptedException e) {\n                System.err.println(\"Hm... let us finish the game!\\n\" + e);\n            }\n        }\n    }","commit_id":"eeb272527046a5363aa4bc5dff2866aa08bbabf2","url":"https://github.com/apache/ignite"},{"original_method":"@Override\n  public void registerReferenceProviders(PsiReferenceRegistrar registrar) {\n    registrar.registerReferenceProvider(literalExpression().and(new FilterPattern(new ElementFilter() {\n      public boolean isAcceptable(Object element, PsiElement context) {\n        final PsiLiteralExpression literalExpression = (PsiLiteralExpression)context;\n        PsiMethodCallExpression callExpression = PsiTreeUtil.getParentOfType(literalExpression, PsiMethodCallExpression.class);\n        if (callExpression != null && \"getResource\".equals(callExpression.getMethodExpression().getReferenceName())) {\n          final PsiCallExpression superCall = PsiTreeUtil.getParentOfType(callExpression, PsiCallExpression.class, true);\n          if (superCall instanceof PsiMethodCallExpression) {\n            final PsiReferenceExpression methodExpression = ((PsiMethodCallExpression)superCall).getMethodExpression();\n            if (\"load\".equals(methodExpression.getReferenceName())) {\n              final PsiExpression qualifierExpression = methodExpression.getQualifierExpression();\n              PsiClass psiClass = null;\n              if (qualifierExpression instanceof PsiReferenceExpression) {\n                final PsiElement resolve = ((PsiReferenceExpression)qualifierExpression).resolve();\n                if (resolve instanceof PsiClass) {\n                  psiClass = (PsiClass)resolve;\n                }\n              } else if (qualifierExpression != null) {\n                psiClass = PsiUtil.resolveClassInType(qualifierExpression.getType());\n              }\n              if (psiClass != null && JavaFxCommonClassNames.JAVAFX_FXML_FXMLLOADER.equals(psiClass.getQualifiedName())) {\n                return true;\n              }\n            }\n          } else if (superCall instanceof PsiNewExpression) {\n            final PsiJavaCodeReferenceElement reference = ((PsiNewExpression)superCall).getClassOrAnonymousClassReference();\n            if (reference != null) {\n              final PsiElement resolve = reference.resolve();\n              if (resolve instanceof PsiClass && JavaFxCommonClassNames.JAVAFX_FXML_FXMLLOADER.equals(((PsiClass)resolve).getQualifiedName())) {\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      }\n\n      public boolean isClassAcceptable(Class hintClass) {\n        return true;\n      }\n    })), new JavaFxFileReferenceProvider());\n  }","id":44970,"modified_method":"@Override\n  public void registerReferenceProviders(PsiReferenceRegistrar registrar) {\n    registrar.registerReferenceProvider(FXML_PATTERN, new JavaFxFileReferenceProvider());\n    registrar.registerReferenceProvider(STYLESHEET_PATTERN, new JavaFxFileReferenceProvider());\n  }","commit_id":"2e10288e3ccec2834389f2814ede059864d54952","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isClassAcceptable(Class hintClass) {\n      return true;\n    }","id":44971,"modified_method":"public boolean isClassAcceptable(Class hintClass) {\n      return !isInitialized();\n    }","commit_id":"a98d75a759932f47dddb0f161223678e5f437635","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void registerFileDescription(final DomFileDescription description) {\n    for (final Map.Entry<Class<? extends DomElement>, Class<? extends DomElement>> entry : ((DomFileDescription<?>)description).getImplementations().entrySet()) {\n      registerImplementation((Class)entry.getKey(), entry.getValue());\n    }\n    final DomElementsAnnotator annotator = description.createAnnotator();\n    final Class<? extends DomElement> rootClass = description.getRootElementClass();\n    if (annotator != null) {\n      myAnnotationsManager.registerDomElementsAnnotator(annotator, rootClass);\n    }\n\n    myFileDescriptions.add(description);\n    final MyElementFilter filter = new MyElementFilter(description);\n\n    myReferenceProvidersRegistry.registerReferenceProvider(filter, XmlTag.class, new DomLazyReferenceProvider(description) {\n      protected void registerTrueReferenceProvider(final String[] names) {\n        myReferenceProvidersRegistry.registerXmlTagReferenceProvider(names, filter, true, myGenericValueReferenceProvider);\n      }\n\n      protected Set<String> getReferenceElementNames(final GenericInfoImpl info) {\n        return info.getReferenceTagNames();\n      }\n    });\n    myReferenceProvidersRegistry.registerReferenceProvider(filter, XmlAttributeValue.class, new DomLazyReferenceProvider(description) {\n      protected void registerTrueReferenceProvider(final String[] names) {\n        myReferenceProvidersRegistry.registerXmlAttributeValueReferenceProvider(names, filter, true, myGenericValueReferenceProvider);\n      }\n\n      protected Set<String> getReferenceElementNames(final GenericInfoImpl info) {\n        return info.getReferenceAttributeNames();\n      }\n    });\n\n\n  }","id":44972,"modified_method":"public final void registerFileDescription(final DomFileDescription description) {\n    for (final Map.Entry<Class<? extends DomElement>, Class<? extends DomElement>> entry : ((DomFileDescription<?>)description).getImplementations().entrySet()) {\n      registerImplementation((Class)entry.getKey(), entry.getValue());\n    }\n    final DomElementsAnnotator annotator = description.createAnnotator();\n    final Class<? extends DomElement> rootClass = description.getRootElementClass();\n    if (annotator != null) {\n      myAnnotationsManager.registerDomElementsAnnotator(annotator, rootClass);\n    }\n\n    myFileDescriptions.add(description);\n\n    final DomLazyReferenceProvider tagReferenceProvider = new DomLazyReferenceProvider(description) {\n      protected void registerTrueReferenceProvider(final String[] names) {\n        myReferenceProvidersRegistry.registerXmlTagReferenceProvider(names, new MyElementFilter(description), true,\n                                                                     myGenericValueReferenceProvider);\n      }\n\n      protected Set<String> getReferenceElementNames(final GenericInfoImpl info) {\n        return info.getReferenceTagNames();\n      }\n    };\n    myReferenceProvidersRegistry.registerReferenceProvider(new MyElementFilter(description) {\n      protected boolean isInitialized() {\n        return tagReferenceProvider.myInitialized;\n      }\n    }, XmlTag.class, tagReferenceProvider);\n\n\n    final DomLazyReferenceProvider attributeReferenceProvider = new DomLazyReferenceProvider(description) {\n      protected void registerTrueReferenceProvider(final String[] names) {\n        myReferenceProvidersRegistry.registerXmlAttributeValueReferenceProvider(names, new MyElementFilter(description), true,\n                                                                                myGenericValueReferenceProvider);\n      }\n\n      protected Set<String> getReferenceElementNames(final GenericInfoImpl info) {\n        return info.getReferenceAttributeNames();\n      }\n    };\n    myReferenceProvidersRegistry.registerReferenceProvider(new MyElementFilter(description) {\n      protected boolean isInitialized() {\n        return attributeReferenceProvider.myInitialized;\n      }\n    }, XmlAttributeValue.class, attributeReferenceProvider);\n\n\n  }","commit_id":"a98d75a759932f47dddb0f161223678e5f437635","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAcceptable(Object element, PsiElement context) {\n      return element instanceof XmlElement && getDomFileDescription((XmlElement)element) == myDescription;\n    }","id":44973,"modified_method":"public boolean isAcceptable(Object element, PsiElement context) {\n      return !isInitialized() && element instanceof XmlElement && getDomFileDescription((XmlElement)element) == myDescription;\n    }","commit_id":"a98d75a759932f47dddb0f161223678e5f437635","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\r\n     * Split the given text string into ngrams. The size of an ngram is determined\r\n     * by counting the codepoints, not the characters. The resulting strings may\r\n     * thus be longer than the ngram size.\r\n     *\r\n     * @param text\r\n     * @return\r\n     */\r\n    public String[] tokenize(String text) {\r\n        int len = text.codePointCount(0, text.length());\r\n        int gramSize = index.getN();\r\n        String[] ngrams = new String[len];\r\n        int next = 0;\r\n        int pos = 0;\r\n        StringBuilder bld = new StringBuilder(gramSize);\r\n        for (int i = 0; i < len; i++) {\r\n            bld.setLength(0);\r\n            int offset = pos;\r\n            for (int count = 0; count < gramSize && offset < text.length(); count++) {\r\n                int codepoint = text.codePointAt(offset);\r\n                offset += Character.charCount(codepoint);\r\n                if (count == 0)\r\n                    pos = offset;   // advance pos to next character\r\n                bld.appendCodePoint(codepoint);\r\n            }\r\n            ngrams[next++] = bld.toString();\r\n        }\r\n        return ngrams;\r\n    }","id":44974,"modified_method":"/**\r\n     * Split the given text string into ngrams. The size of an ngram is determined\r\n     * by counting the codepoints, not the characters. The resulting strings may\r\n     * thus be longer than the ngram size.\r\n     *\r\n     * @param text\r\n     * @return\r\n     */\r\n    public String[] tokenize(String text) {\r\n        int len = text.codePointCount(0, text.length());\r\n        int gramSize = index.getN();\r\n        String[] ngrams = new String[len];\r\n        int next = 0;\r\n        int pos = 0;\r\n        StringBuilder bld = new StringBuilder(gramSize);\r\n        for (int i = 0; i < len; i++) {\r\n            bld.setLength(0);\r\n            int offset = pos;\r\n            for (int count = 0; count < gramSize && offset < text.length(); count++) {\r\n                int codepoint = Character.toLowerCase(text.codePointAt(offset));\r\n                offset += Character.charCount(codepoint);\r\n                if (count == 0)\r\n                    pos = offset;   // advance pos to next character\r\n                bld.appendCodePoint(codepoint);\r\n            }\r\n            ngrams[next++] = bld.toString();\r\n        }\r\n        return ngrams;\r\n    }","commit_id":"0e7a11bb84fc7c18fa7695fed9b10cebc1edc3bf","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\r\n     * Split the specified string into a sequence of ngrams to be used for querying the index. For example, if we have a\r\n     * 3-gram index, the string 'distinct' will be split into the ngrams 'dis', 'tin' and 'ct'.\r\n     *\r\n     * @param text\r\n     *            the character sequence to split\r\n     * @return a sequence of ngrams. the last item might be shorter than n.\r\n     */\r\n    private static String[] getDistinctNGrams(final String text, final int ngramSize) {\r\n        int len = text.codePointCount(0, text.length());\r\n        int count = len / ngramSize;\r\n        int remainder = len % ngramSize;\r\n\r\n        String[] n = new String[(remainder > 0 ? count + 1 : count)];\r\n        int pos = 0;\r\n        for (int i = 0; i < count; i++) {\r\n            StringBuilder bld = new StringBuilder(ngramSize);\r\n            for (int j = 0; j < ngramSize; j++) {\r\n                int next = text.codePointAt(pos);\r\n                pos += Character.charCount(next);\r\n                bld.appendCodePoint(next);\r\n            }\r\n            n[i] = bld.toString();\r\n        }\r\n        if (remainder > 0) {\r\n            StringBuilder bld = new StringBuilder(remainder);\r\n            for (int j = 0; j < remainder; j++) {\r\n                int next = text.codePointAt(pos);\r\n                pos += Character.charCount(next);\r\n                bld.appendCodePoint(next);\r\n            }\r\n            n[count] = bld.toString();\r\n        }\r\n        return n;\r\n    }","id":44975,"modified_method":"/**\r\n     * Split the specified string into a sequence of ngrams to be used for querying the index. For example, if we have a\r\n     * 3-gram index, the string 'distinct' will be split into the ngrams 'dis', 'tin' and 'ct'.\r\n     *\r\n     * @param text\r\n     *            the character sequence to split\r\n     * @return a sequence of ngrams. the last item might be shorter than n.\r\n     */\r\n    private static String[] getDistinctNGrams(final String text, final int ngramSize) {\r\n        int len = text.codePointCount(0, text.length());\r\n        int count = len / ngramSize;\r\n        int remainder = len % ngramSize;\r\n\r\n        String[] n = new String[(remainder > 0 ? count + 1 : count)];\r\n        int pos = 0;\r\n        for (int i = 0; i < count; i++) {\r\n            StringBuilder bld = new StringBuilder(ngramSize);\r\n            for (int j = 0; j < ngramSize; j++) {\r\n                int next = Character.toLowerCase(text.codePointAt(pos));\r\n                pos += Character.charCount(next);\r\n                bld.appendCodePoint(next);\r\n            }\r\n            n[i] = bld.toString();\r\n        }\r\n        if (remainder > 0) {\r\n            StringBuilder bld = new StringBuilder(remainder);\r\n            for (int j = 0; j < remainder; j++) {\r\n                int next = Character.toLowerCase(text.codePointAt(pos));\r\n                pos += Character.charCount(next);\r\n                bld.appendCodePoint(next);\r\n            }\r\n            n[count] = bld.toString();\r\n        }\r\n        return n;\r\n    }","commit_id":"0e7a11bb84fc7c18fa7695fed9b10cebc1edc3bf","url":"https://github.com/eXist-db/exist"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event) {\n    try {\n      final Wrappers._T<SModelDescriptor> result = new Wrappers._T<SModelDescriptor>();\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        public void run() {\n          String namespace = NewSubTestModel_Action.this.model.getLongName();\n          String name = NewSubTestModel_Action.this.getTestModelName();\n          SModelFqName newModelFqName = new SModelFqName(namespace, name, SModelStereotype.TESTS);\n          result.value = NewSubTestModel_Action.this.model.getModule().createModel(newModelFqName, NewSubTestModel_Action.this.model.getSModelRoot());\n        }\n      });\n      if (result.value != null) {\n        SModelDescriptor modelDescriptor = result.value;\n        ProjectPane.getInstance(NewSubTestModel_Action.this.ideaProject).selectModel(modelDescriptor);\n      }\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewSubTestModel\", t);\n      }\n    }\n  }","id":44976,"modified_method":"public void doExecute(@NotNull final AnActionEvent event) {\n    try {\n      final Wrappers._T<SModelDescriptor> result = new Wrappers._T<SModelDescriptor>();\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        public void run() {\n          String namespace = NewSubTestModel_Action.this.getNamespace();\n          String name = NewSubTestModel_Action.this.getTestModelName();\n          SModelFqName newModelFqName = new SModelFqName(namespace, name, SModelStereotype.TESTS);\n          result.value = NewSubTestModel_Action.this.model.getModule().createModel(newModelFqName, NewSubTestModel_Action.this.model.getSModelRoot());\n          SModel createdModel = result.value.getSModel();\n          SModel sourceModel = NewSubTestModel_Action.this.model.getSModel();\n          createdModel.addImportedModel(sourceModel.getSModelReference());\n          for (SModel.ImportElement importElement : sourceModel.getImportElements()) {\n            createdModel.addImportedModel(importElement.getModelReference());\n          }\n          for (ModuleReference importedLanguage : sourceModel.getExplicitlyImportedLanguages()) {\n            createdModel.addLanguage(importedLanguage);\n          }\n          for (ModuleReference devKit : sourceModel.getDevKitRefs()) {\n            createdModel.addDevKit(devKit);\n          }\n        }\n      });\n      ProjectPane.getInstance(NewSubTestModel_Action.this.ideaProject).selectModel(result.value);\n    } catch (Throwable t) {\n      if (log.isErrorEnabled()) {\n        log.error(\"User's action execute method failed. Action:\" + \"NewSubTestModel\", t);\n      }\n    }\n  }","commit_id":"5ea9db648dc8cdef682e3cd47ae3e7b845eb8217","url":"https://github.com/JetBrains/MPS"},{"original_method":"String getTestModelName() {\n    SModelTreeNode modelTreeNode = (SModelTreeNode) NewSubTestModel_Action.this.treeNode;\n    int testModelCount = 0;\n    List<SModelTreeNode> subModels = modelTreeNode.getSubfolderSModelTreeNodes();\n    for (SModelTreeNode subModel : subModels) {\n      if (SModelStereotype.TESTS.equals(subModel.getSModelDescriptor().getStereotype())) {\n        testModelCount++;\n      }\n    }\n    StringBuilder builder = new StringBuilder();\n    builder.append(NewSubTestModel_Action.this.model.getName()).append(\"_test\");\n    if (testModelCount > 0) {\n      builder.append(testModelCount + \"\");\n    }\n    return builder.toString();\n  }","id":44977,"modified_method":"String getTestModelName() {\n    StringBuilder builder = new StringBuilder();\n    builder.append(NewSubTestModel_Action.this.model.getName());\n    int testModelCount = 0;\n    List<SModelDescriptor> models = NewSubTestModel_Action.this.model.getModule().getOwnModelDescriptors();\n    List<SModelDescriptor> sortedModels = SortUtil.sortModels(models);\n    for (SModelDescriptor md : sortedModels) {\n      if (!(SModelStereotype.TESTS.equals(md.getStereotype()))) {\n        continue;\n      }\n      String name = NewSubTestModel_Action.this.model.getLongName() + ((testModelCount == 0 ?\n        \"\" :\n        testModelCount\n      ));\n      if (name.equals(md.getLongName())) {\n        testModelCount++;\n      }\n    }\n    if (testModelCount != 0) {\n      builder.append(testModelCount + \"\");\n    }\n    return builder.toString();\n  }","commit_id":"5ea9db648dc8cdef682e3cd47ae3e7b845eb8217","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final ModelAccess modelAccess = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository().getModelAccess();\n      if (!(((SModule) MapSequence.fromMap(_params).get(\"module\")).getModelRoots().iterator().hasNext())) {\n        int code = JOptionPane.showConfirmDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), \"There are no model roots. Do you want to create one?\", \"\", JOptionPane.YES_NO_OPTION);\n        if (code == JOptionPane.YES_OPTION) {\n          MPSPropertiesConfigurable configurable = new ModulePropertiesConfigurable(((SModule) MapSequence.fromMap(_params).get(\"module\")), ((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n          final SingleConfigurableEditor configurableEditor = new SingleConfigurableEditor(((Project) MapSequence.fromMap(_params).get(\"ideaProject\")), configurable, \"#MPSPropertiesConfigurable\");\n          configurableEditor.show();\n        }\n        return;\n      }\n      if (!(((SModule) MapSequence.fromMap(_params).get(\"module\")).getModelRoots().iterator().hasNext())) {\n        JOptionPane.showMessageDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), \"Can't create a model in solution with no model roots\", \"Can't create model\", JOptionPane.ERROR_MESSAGE);\n        return;\n      }\n\n      final Wrappers._T<NewModelDialog> dialog = new Wrappers._T<NewModelDialog>();\n      modelAccess.runReadAction(new Runnable() {\n        public void run() {\n          String stereotype = NewModelFromSource_Action.this.getStereotype(_params);\n          dialog.value = new NewModelDialog(((MPSProject) MapSequence.fromMap(_params).get(\"project\")), (AbstractModule) ((SModule) MapSequence.fromMap(_params).get(\"module\")), NewModelFromSource_Action.this.getNamespace(_params), stereotype, NewModelFromSource_Action.this.isStrict(_params));\n        }\n      });\n\n      dialog.value.show();\n      SModel result = dialog.value.getResult();\n\n      if (result == null) {\n        return;\n      }\n\n      TreeFileChooser treeFileChooser = new TreeFileChooser();\n      treeFileChooser.setDirectoriesAreAlwaysVisible(true);\n      treeFileChooser.setMode(TreeFileChooser.MODE_DIRECTORIES);\n      final SModel sModel = result;\n      File initial = ImportSourcesIntoModelUtils.getInitialDirectoryForImport((AbstractModule) ((SModule) MapSequence.fromMap(_params).get(\"module\")), SNodeOperations.getModelLongName(sModel));\n      if (initial != null) {\n        treeFileChooser.setInitialFile(FileSystem.getInstance().getFileByPath(initial.getAbsolutePath()));\n      }\n      IFile resultFile = treeFileChooser.showDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n      if (resultFile != null) {\n\n        IFileUtils.getAllFiles(FileSystem.getInstance().getFileByPath(resultFile.getPath()));\n        final MultipleFilesParser parser = new MultipleFilesParser(((SModule) MapSequence.fromMap(_params).get(\"module\")), ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository());\n        final List<IFile> files = IFileUtils.getAllFiles(FileSystem.getInstance().getFileByPath(resultFile.getPath()));\n\n        final Ref<JavaParseException> parseException = new Ref<JavaParseException>();\n\n        ProgressManager.getInstance().run(new Task.Modal(((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getProject(), \"Converting Java to MPS\", true) {\n          public void run(@NotNull ProgressIndicator progress) {\n            try {\n              parser.convertToMps(files, new ProgressMonitorAdapter(progress));\n            } catch (JavaParseException e) {\n              parseException.set(e);\n            } catch (IOException e) {\n              // FIXME this exception will be gone \n              throw new RuntimeException(e);\n            }\n\n          }\n        });\n\n        if (!(parseException.isNull())) {\n          JOptionPane.showMessageDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), parseException.get().getMessage(), \"Parse error\", JOptionPane.ERROR_MESSAGE);\n        }\n      }\n      SModel modelDescriptor = result;\n      ProjectPane.getInstance(((MPSProject) MapSequence.fromMap(_params).get(\"project\"))).selectModel(modelDescriptor, false);\n\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"NewModelFromSource\", t);\n      }\n    }\n  }","id":44978,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final SRepository repository = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getRepository();\n      final ModelAccess modelAccess = repository.getModelAccess();\n\n      if (!(((SModule) MapSequence.fromMap(_params).get(\"module\")).getModelRoots().iterator().hasNext())) {\n        int code = JOptionPane.showConfirmDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), \"There are no model roots. Do you want to create one?\", \"\", JOptionPane.YES_NO_OPTION);\n        if (code == JOptionPane.YES_OPTION) {\n          MPSPropertiesConfigurable configurable = new ModulePropertiesConfigurable(((SModule) MapSequence.fromMap(_params).get(\"module\")), ((MPSProject) MapSequence.fromMap(_params).get(\"project\")));\n          final SingleConfigurableEditor configurableEditor = new SingleConfigurableEditor(((Project) MapSequence.fromMap(_params).get(\"ideaProject\")), configurable, \"#MPSPropertiesConfigurable\");\n          configurableEditor.show();\n        }\n        return;\n      }\n\n      if (!(((SModule) MapSequence.fromMap(_params).get(\"module\")).getModelRoots().iterator().hasNext())) {\n        JOptionPane.showMessageDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), \"Can't create a model in solution with no model roots\", \"Can't create model\", JOptionPane.ERROR_MESSAGE);\n        return;\n      }\n\n      final Wrappers._T<NewModelDialog> dialog = new Wrappers._T<NewModelDialog>();\n      modelAccess.runReadAction(new Runnable() {\n        public void run() {\n          String stereotype = NewModelFromSource_Action.this.getStereotype(_params);\n          dialog.value = new NewModelDialog(((MPSProject) MapSequence.fromMap(_params).get(\"project\")), (AbstractModule) ((SModule) MapSequence.fromMap(_params).get(\"module\")), NewModelFromSource_Action.this.getNamespace(_params), stereotype, NewModelFromSource_Action.this.isStrict(_params));\n        }\n      });\n\n      dialog.value.show();\n      SModel ignored = dialog.value.getResult();\n\n      if (ignored == null) {\n        return;\n      }\n\n      FileChooserDescriptor descriptor = new FileChooserDescriptor(true, true, false, false, false, true);\n      FileChooserDialog fileDialog = FileChooserFactory.getInstance().createFileChooser(descriptor, ((Project) MapSequence.fromMap(_params).get(\"ideaProject\")), ((Frame) MapSequence.fromMap(_params).get(\"frame\")));\n\n      VirtualFile[] chosen = fileDialog.choose(null, ((Project) MapSequence.fromMap(_params).get(\"ideaProject\")));\n\n      if (chosen.length == 0) {\n        return;\n      }\n\n      List<IFile> chosenIFiles = ListSequence.fromList(new ArrayList<IFile>(chosen.length));\n      for (VirtualFile vfile : chosen) {\n        ListSequence.fromList(chosenIFiles).addElement(FileSystem.getInstance().getFileByPath(vfile.getPath()));\n      }\n      final List<IFile> ifilesToParse = Sequence.fromIterable(JavaConvertUtil.openDirs(chosenIFiles)).toListSequence();\n\n      final MultipleFilesParser parser = new MultipleFilesParser(((SModule) MapSequence.fromMap(_params).get(\"module\")), repository);\n      final Ref<JavaParseException> parseException = new Ref<JavaParseException>();\n\n      ProgressManager.getInstance().run(new Task.Modal(null, \"Convert to MPS\", false) {\n        public void run(@NotNull ProgressIndicator indicator) {\n\n          try {\n            parser.convertToMps(ifilesToParse, new ProgressMonitorAdapter(indicator));\n\n          } catch (JavaParseException e) {\n            parseException.set(e);\n\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n\n      if (!(parseException.isNull())) {\n        JOptionPane.showMessageDialog(((Frame) MapSequence.fromMap(_params).get(\"frame\")), parseException.get().getMessage(), \"Parse error\", JOptionPane.ERROR_MESSAGE);\n      }\n\n      List<SModel> resulting = parser.getModels();\n      if (ListSequence.fromList(resulting).isNotEmpty()) {\n        SModel firstModel = ListSequence.fromList(resulting).first();\n        ProjectPane.getInstance(((MPSProject) MapSequence.fromMap(_params).get(\"project\"))).selectModel(firstModel, false);\n      }\n\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"NewModelFromSource\", t);\n      }\n    }\n  }","commit_id":"38f3d22d5047b30d93bf1fb11396e211d74bc73f","url":"https://github.com/JetBrains/MPS"},{"original_method":"public AddRequiredModelImportsDialog(Frame frame, SModel model,\n                                       Set<SModelUID> necessaryImports,\n                                       Set<String> necessaryLanguages,\n                                       Set<String> necessaryDevKits) {\n    super(frame, \"Imports and Languages\");\n    myImports = new ArrayList<SModelUID>(necessaryImports);\n    myLanguages = new ArrayList<String>(necessaryLanguages);\n    myDevKits = new ArrayList<String>(necessaryDevKits);\n    myLanguagesToAdd = new ArrayList<String>(necessaryLanguages);\n    myImportsToAdd = new ArrayList<SModelUID>(necessaryImports);\n    myDevKitsToAdd = new ArrayList<String>(necessaryDevKits);\n\n    myModel = model;\n\n    myMainComponent = new JPanel(new BorderLayout());\n    JLabel header = new JLabel(\"Do you want to add imported models or languages to the model \" + myModel + \" ?\", JLabel.LEFT);\n    myMainComponent.add(header, BorderLayout.NORTH);\n\n    JPanel panel = new JPanel(new GridLayout(3, 1, 5, 5));\n\n    if (!myImports.isEmpty()) {\n      MyImportsTableModel importsTableModel = new MyImportsTableModel(myImports, myImportsToAdd);\n      JPanel innerPanel = new JPanel(new BorderLayout());\n      JTable importsTable = new JTable(importsTableModel);\n      importsTable.getColumnModel().getColumn(0).setWidth(30);\n      importsTable.getColumnModel().getColumn(1).setPreferredWidth(300);\n      innerPanel.add(new JScrollPane(importsTable), BorderLayout.CENTER);\n      innerPanel.add(new JLabel(\"Add Imported Models\", SwingConstants.CENTER), BorderLayout.NORTH);\n      panel.add(innerPanel);\n    }\n    if (!myLanguages.isEmpty()) {\n      MyImportsTableModel languagesTableModel = new MyImportsTableModel(myLanguages, myLanguagesToAdd);\n      JPanel innerPanel = new JPanel(new BorderLayout());\n      JTable languagesTable = new JTable(languagesTableModel);\n      languagesTable.getColumnModel().getColumn(0).setWidth(30);\n      languagesTable.getColumnModel().getColumn(1).setPreferredWidth(300);\n      innerPanel.add(new JScrollPane(languagesTable), BorderLayout.CENTER);\n      innerPanel.add(new JLabel(\"Add Languages\", SwingConstants.CENTER), BorderLayout.NORTH);\n      panel.add(innerPanel);\n    }\n    if (!myDevKits.isEmpty()) {\n      JPanel innerPanel = new JPanel(new BorderLayout());\n      MyImportsTableModel devKitTableModel = new MyImportsTableModel(myDevKits, myDevKitsToAdd);\n      JTable devkitTable = new JTable(devKitTableModel);\n      devkitTable.getColumnModel().getColumn(0).setWidth(30);\n      devkitTable.getColumnModel().getColumn(1).setPreferredWidth(300);\n      innerPanel.add(new JScrollPane(devkitTable), BorderLayout.CENTER);\n      innerPanel.add(new JLabel(\"Add DevKits\", SwingConstants.CENTER), BorderLayout.NORTH);\n      panel.add(innerPanel);\n    }\n\n    myMainComponent.add(panel, BorderLayout.CENTER);\n  }","id":44979,"modified_method":"public AddRequiredModelImportsDialog(Frame frame, SModel model,\n                                       Set<SModelUID> necessaryImports,\n                                       Set<String> necessaryLanguages,\n                                       Set<String> necessaryDevKits) {\n    super(frame, \"Imports And Languages\");\n    myImports = new ArrayList<SModelUID>(necessaryImports);\n    myLanguages = new ArrayList<String>(necessaryLanguages);\n    myDevKits = new ArrayList<String>(necessaryDevKits);\n    myLanguagesToAdd = new ArrayList<String>(necessaryLanguages);\n    myImportsToAdd = new ArrayList<SModelUID>(necessaryImports);\n    myDevKitsToAdd = new ArrayList<String>(necessaryDevKits);\n\n    myModel = model;\n\n    myMainComponent = new JPanel(new BorderLayout());\n    JLabel header = new JLabel(\"Do you want to add imported models or languages to the model \" + myModel + \" ?\", JLabel.LEFT);\n    myMainComponent.add(header, BorderLayout.NORTH);\n\n    JPanel panel = new JPanel(new GridLayout(3, 1, 5, 5));\n\n    if (!myImports.isEmpty()) {\n      MyImportsTableModel importsTableModel = new MyImportsTableModel(myImports, myImportsToAdd);\n      JPanel innerPanel = new JPanel(new BorderLayout());\n      JTable importsTable = new JTable(importsTableModel);\n      importsTable.getColumnModel().getColumn(0).setWidth(30);\n      importsTable.getColumnModel().getColumn(1).setPreferredWidth(300);\n      innerPanel.add(new JScrollPane(importsTable), BorderLayout.CENTER);\n      innerPanel.add(new JLabel(\"Add Imported Models\", SwingConstants.CENTER), BorderLayout.NORTH);\n      panel.add(innerPanel);\n    }\n    if (!myLanguages.isEmpty()) {\n      MyImportsTableModel languagesTableModel = new MyImportsTableModel(myLanguages, myLanguagesToAdd);\n      JPanel innerPanel = new JPanel(new BorderLayout());\n      JTable languagesTable = new JTable(languagesTableModel);\n      languagesTable.getColumnModel().getColumn(0).setWidth(30);\n      languagesTable.getColumnModel().getColumn(1).setPreferredWidth(300);\n      innerPanel.add(new JScrollPane(languagesTable), BorderLayout.CENTER);\n      innerPanel.add(new JLabel(\"Add Languages\", SwingConstants.CENTER), BorderLayout.NORTH);\n      panel.add(innerPanel);\n    }\n    if (!myDevKits.isEmpty()) {\n      JPanel innerPanel = new JPanel(new BorderLayout());\n      MyImportsTableModel devKitTableModel = new MyImportsTableModel(myDevKits, myDevKitsToAdd);\n      JTable devkitTable = new JTable(devKitTableModel);\n      devkitTable.getColumnModel().getColumn(0).setWidth(30);\n      devkitTable.getColumnModel().getColumn(1).setPreferredWidth(300);\n      innerPanel.add(new JScrollPane(devkitTable), BorderLayout.CENTER);\n      innerPanel.add(new JLabel(\"Add DevKits\", SwingConstants.CENTER), BorderLayout.NORTH);\n      panel.add(innerPanel);\n    }\n\n    myMainComponent.add(panel, BorderLayout.CENTER);\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public FindUsagesDialog(final FindUsagesOptions defaultOptions, final SNode node, final ActionEventData data) {\n    super(data.getOperationContext().getMainFrame(), \"Find usages\");\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myQueryEditor = new QueryEditor(defaultOptions.getOption(QueryOptions.class), node, data);\n        myFindersEditor = new MyFindersEditor(defaultOptions, node, data);\n        myViewOptionsEditor = new ViewOptionsEditor(defaultOptions.getOption(ViewOptions.class), node, data);\n      }\n    });\n\n    JPanel centerPanel = new JPanel(new BorderLayout());\n    centerPanel.add(myFindersEditor.getComponent(), BorderLayout.CENTER);\n    centerPanel.add(myViewOptionsEditor.getComponent(), BorderLayout.EAST);\n\n    myPanel = new JPanel(new BorderLayout());\n    myPanel.add(centerPanel, BorderLayout.CENTER);\n    myPanel.add(myQueryEditor.getComponent(), BorderLayout.SOUTH);\n  }","id":44980,"modified_method":"public FindUsagesDialog(final FindUsagesOptions defaultOptions, final SNode node, final ActionEventData data) {\n    super(data.getOperationContext().getMainFrame(), \"Find Usages\");\n\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myQueryEditor = new QueryEditor(defaultOptions.getOption(QueryOptions.class), node, data);\n        myFindersEditor = new MyFindersEditor(defaultOptions, node, data);\n        myViewOptionsEditor = new ViewOptionsEditor(defaultOptions.getOption(ViewOptions.class), node, data);\n      }\n    });\n\n    JPanel centerPanel = new JPanel(new BorderLayout());\n    centerPanel.add(myFindersEditor.getComponent(), BorderLayout.CENTER);\n    centerPanel.add(myViewOptionsEditor.getComponent(), BorderLayout.EAST);\n\n    myPanel = new JPanel(new BorderLayout());\n    myPanel.add(centerPanel, BorderLayout.CENTER);\n    myPanel.add(myQueryEditor.getComponent(), BorderLayout.SOUTH);\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void showDialog() {\n    if (myError != null) {\n      setErrorText(\"TYPE ERROR! Message: \" + myError.reportError());\n    }\n    super.showDialog();\n  }","id":44981,"modified_method":"public void showDialog() {\n    if (myError != null) {\n      setErrorText(\"Type error! Message: \" + myError.reportError());\n    }\n    super.showDialog();\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MyBaseNodeDialog(IOperationContext operationContext, SNode node, SNode type, IErrorReporter error) throws HeadlessException {\n    super(\"Type For Node \" + node, operationContext);\n\n    SupertypesViewTool supertypesView = operationContext.getMPSProject().getComponent(SupertypesViewTool.class);\n\n    myMainComponent = new JSplitPaneWithoutBorders(JSplitPane.HORIZONTAL_SPLIT, getSuperMainComponent(), supertypesView.getComponent());\n    myMainComponent.setDividerSize(6);\n    myMainComponent.setResizeWeight(0.8);\n\n    myNode = node;\n    myType = type;\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        if (!myType.isRegistered()) {\n          myWasRegistered = false;\n          myType.getModel().addRoot(myType.getTopmostAncestor());\n        }\n      }\n    });\n    myError = error;\n    supertypesView.showConceptInHierarchy(myType.getAdapter(), operationContext);\n  }","id":44982,"modified_method":"public MyBaseNodeDialog(IOperationContext operationContext, SNode node, SNode type, IErrorReporter error) throws HeadlessException {\n    super(\"Type For Node \" + node, operationContext);\n\n    SupertypesViewTool supertypesView = operationContext.getMPSProject().getComponent(SupertypesViewTool.class);\n\n    myMainComponent = new JSplitPaneWithoutBorders(JSplitPane.HORIZONTAL_SPLIT, getSuperMainComponent(), supertypesView.getComponent());\n    myMainComponent.setDividerSize(6);\n    myMainComponent.setResizeWeight(0.8);\n\n    myType = type;\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        if (!myType.isRegistered()) {\n          myWasRegistered = false;\n          myType.getModel().addRoot(myType.getTopmostAncestor());\n        }\n      }\n    });\n    myError = error;\n    supertypesView.showConceptInHierarchy(myType.getAdapter(), operationContext);\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NewDevKitDialog(Frame frame) {\n    super(frame, \"New Dev Kit\");\n  }","id":44983,"modified_method":"public NewDevKitDialog(Frame frame) {\n    super(frame, \"New DevKit\");\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NewFileDialog(Frame mainFrame) throws HeadlessException {\n    super(mainFrame, \"Select name\");\n\n    myPanel = new JPanel(new BorderLayout());\n\n    myTextArea = new JTextField(\"New Folder\", 20);\n\n    myPanel.add(myTextArea, BorderLayout.CENTER);\n\n    setPreferredSize(getDefaultDimensionSettings().getDimensions());\n    setSize(getDefaultDimensionSettings().getDimensions());\n    setModal(true);\n  }","id":44984,"modified_method":"public NewFileDialog(Frame mainFrame) throws HeadlessException {\n    super(mainFrame, \"New Folder\");\n\n    myPanel = new JPanel(new BorderLayout());\n\n    myTextArea = new JTextField(\"New Folder\", 20);\n    JLabel label = new JLabel(\"Name:\");\n\n    myPanel.add(myTextArea, BorderLayout.CENTER);\n    myPanel.add(label, BorderLayout.WEST);\n\n    setPreferredSize(getDefaultDimensionSettings().getDimensions());\n    setSize(getDefaultDimensionSettings().getDimensions());\n    setModal(true);\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NewGeneratorDialog(Frame mainFrame, Language sourceLanguage, IOperationContext context) throws HeadlessException {\n    super(mainFrame, \"New Generator\");\n    mySourceLanguage = sourceLanguage;\n    myContext = context;\n    initContentPane();\n  }","id":44985,"modified_method":"public NewGeneratorDialog(Frame mainFrame, Language sourceLanguage) throws HeadlessException {\n    super(mainFrame, \"New Generator\");\n    mySourceLanguage = sourceLanguage;\n    myContenetPane = new JPanel(new BorderLayout());\n    initContentPane();\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected JComponent getMainComponent() {\n    return myMainComponentPane;\n  }","id":44986,"modified_method":"protected JComponent getMainComponent() {\n    return myContenetPane;\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initContentPane() {\n    JPanel internalPanel = new JPanel(new GridLayout(0, 1));\n    internalPanel.setBorder(BorderFactory.createEmptyBorder(0, 4, 10, 4));\n    myContenetPane.setLayout(new BorderLayout());\n    myContenetPane.add(internalPanel, BorderLayout.NORTH);\n\n    //TODO: constraints\n    internalPanel.add(new JLabel(\"Generator name :\"));\n    myGeneratorName = new JTextField();\n    internalPanel.add(myGeneratorName);\n\n    internalPanel.add(new JLabel(\"Template models root :\"));\n    myTemplateModelsDir = new JTextField();\n\n    updateTemplateModelsDir();\n\n    JButton chooseButton = new JButton(new AbstractAction(\"...\") {\n      public void actionPerformed(ActionEvent e) {\n        String oldPath = myTemplateModelsDir.getText();\n\n        TreeFileChooser chooser = new TreeFileChooser();\n\n        chooser.setMode(TreeFileChooser.MODE_DIRECTORIES);\n\n        if (oldPath != null && oldPath.length() != 0) {\n          chooser.setInitialFile(new FileSystemFile(oldPath));\n        }\n\n        IFile result = chooser.showDialog();\n        if (result != null) {\n          myTemplateModelsDir.setText(result.getAbsolutePath());\n        }\n      }\n    });\n\n    JPanel rootChooser = new JPanel(new BorderLayout());\n    rootChooser.add(myTemplateModelsDir, BorderLayout.CENTER);\n    rootChooser.add(chooseButton, BorderLayout.EAST);\n    internalPanel.add(rootChooser);\n  }","id":44987,"modified_method":"private void initContentPane() {\n    JPanel innerPanel = new JPanel(new BorderLayout());\n    innerPanel.setLayout(new BoxLayout(innerPanel, BoxLayout.Y_AXIS));\n    innerPanel.setBorder(new EmptyBorder(10, 10, 10, 10));\n\n    myGeneratorName = new JTextField();\n    JPanel namePanel = new JPanel(new BorderLayout());\n    namePanel.add(new JLabel(\"Generator name\"), BorderLayout.WEST);\n    namePanel.add(myGeneratorName, BorderLayout.CENTER);\n    namePanel.setBorder(new EmptyBorder(0, 0, 5, 0));\n\n    myTemplateModelsDir = new JTextField();\n    JPanel templatesPanel = new JPanel(new BorderLayout());\n    updateTemplateModelsDir();\n    JButton chooseButton = new JButton(new AbstractAction(\"...\") {\n      public void actionPerformed(ActionEvent e) {\n        String oldPath = myTemplateModelsDir.getText();\n\n        TreeFileChooser chooser = new TreeFileChooser();\n\n        chooser.setMode(TreeFileChooser.MODE_DIRECTORIES);\n\n        if (oldPath != null && oldPath.length() != 0) {\n          chooser.setInitialFile(new FileSystemFile(oldPath));\n        }\n\n        IFile result = chooser.showDialog();\n        if (result != null) {\n          myTemplateModelsDir.setText(result.getAbsolutePath());\n        }\n      }\n    });\n    templatesPanel.add(new JLabel(\"Templates root\"), BorderLayout.WEST);\n    templatesPanel.add(myTemplateModelsDir, BorderLayout.CENTER);\n    templatesPanel.add(chooseButton, BorderLayout.EAST);\n\n    innerPanel.add(namePanel);\n    innerPanel.add(templatesPanel);\n\n    myContenetPane.add(innerPanel, BorderLayout.NORTH);\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Button(position = 0, name = \"OK\", defaultButton = true)\n  public void buttonOK() {\n    String templateModelsPath = myTemplateModelsDir.getText();\n    if (templateModelsPath.length() == 0) {\n      setErrorText(\"No template models root\");\n      return;\n    }\n\n    final File dir = new File(templateModelsPath);\n    if (!dir.isAbsolute()) {\n      setErrorText(\"Path should be absolute\");\n      return;\n    }\n    if (!dir.exists()) {\n      dir.mkdirs();\n    }\n\n    dispose();\n\n    final String name = myGeneratorName.getText();\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        createNewGenerator(mySourceLanguage, dir, name);\n      }\n    });\n  }","id":44988,"modified_method":"@Button(position = 0, name = \"OK\", defaultButton = true)\n  public void buttonOK() {\n    String templateModelsPath = myTemplateModelsDir.getText();\n    if (templateModelsPath.length() == 0) {\n      setErrorText(\"No template models root\");\n      return;\n    }\n\n    final File dir = new File(templateModelsPath);\n    if (!dir.isAbsolute()) {\n      setErrorText(\"Path should be absolute\");\n      return;\n    }\n    if (!dir.exists()) {\n      dir.mkdirs();\n    }\n\n    final String name = myGeneratorName.getText();\n    if (!isValidName(name)) {\n      setErrorText(\"Only letters, digits and '_' can be used in generator name.\");\n      return;\n    }\n\n    dispose();\n\n    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n      public void run() {\n        createNewGenerator(mySourceLanguage, dir, name);\n      }\n    });\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override()\n  protected boolean collectActionData(AnActionEvent event) {\n    try {\n      if (!(super.collectActionData(event))) {\n        return false;\n      }\n      this.frame = event.getData(MPSDataKeys.FRAME);\n      if (this.frame == null) {\n        return false;\n      }\n      this.context = event.getData(MPSDataKeys.OPERATION_CONTEXT);\n      if (this.context == null) {\n        return false;\n      }\n    } catch (Throwable t) {\n      return false;\n    }\n    return true;\n  }","id":44989,"modified_method":"@Override()\n  protected boolean collectActionData(AnActionEvent event) {\n    try {\n      if (!(super.collectActionData(event))) {\n        return false;\n      }\n      this.frame = event.getData(MPSDataKeys.FRAME);\n      if (this.frame == null) {\n        return false;\n      }\n    } catch (Throwable t) {\n      return false;\n    }\n    return true;\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initContentPane() {\n    JPanel mainPanel = new JPanel(new GridLayout(0, 1));\n    mainPanel.add(new JLabel(\"Model Name:\"));\n    mainPanel.add(myModelName);\n\n    mainPanel.add(new JLabel(\"Stereotype:\"));\n\n    myModelStereotype.setEditable(true);\n    myModelStereotype.setModel(new DefaultComboBoxModel(SModelStereotype.values));\n\n    mainPanel.add(myModelStereotype);\n\n    mainPanel.add(new JLabel(\"Model Root:\"));\n    mainPanel.add(myModelRoots);\n\n    DefaultComboBoxModel model = new DefaultComboBoxModel();\n    for (ModelRoot root : myModule.getModelRoots()) {\n      model.addElement(new ModelRootWrapper(root, myNamespace));\n    }\n\n    myModelRoots.addItemListener(new ItemListener() {\n      public void itemStateChanged(ItemEvent e) {\n        completePrefix();\n      }\n    });\n    myModelRoots.setModel(model);\n    completePrefix();\n\n    myContentPane.add(mainPanel, BorderLayout.NORTH);\n    myContentPane.add(new JPanel(), BorderLayout.CENTER);\n  }","id":44990,"modified_method":"private void initContentPane() {\n    JPanel mainPanel = new JPanel(new GridLayout(0, 1));\n    mainPanel.add(new JLabel(\"Model name:\"));\n    mainPanel.add(myModelName);\n\n    mainPanel.add(new JLabel(\"Stereotype:\"));\n\n    myModelStereotype.setEditable(true);\n    myModelStereotype.setModel(new DefaultComboBoxModel(SModelStereotype.values));\n\n    mainPanel.add(myModelStereotype);\n\n    mainPanel.add(new JLabel(\"Model root:\"));\n    mainPanel.add(myModelRoots);\n\n    DefaultComboBoxModel model = new DefaultComboBoxModel();\n    for (ModelRoot root : myModule.getModelRoots()) {\n      model.addElement(new ModelRootWrapper(root, myNamespace));\n    }\n\n    myModelRoots.addItemListener(new ItemListener() {\n      public void itemStateChanged(ItemEvent e) {\n        completePrefix();\n      }\n    });\n    myModelRoots.setModel(model);\n    completePrefix();\n\n    myContentPane.add(mainPanel, BorderLayout.NORTH);\n    myContentPane.add(new JPanel(), BorderLayout.CENTER);\n  }","commit_id":"edaa309cb18403f2d32e4bf5623ec0a941db42d6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public File getClassesGen() {\n    if (getDescriptorFile() == null) {\n      return null;\n    }\n    return new File(getDescriptorFile().getParent().toFile(), \"classes_gen\");\n  }","id":44991,"modified_method":"public IFile getClassesGen() {\n    if (getDescriptorFile() == null) {\n      return null;\n    }\n    return getDescriptorFile().getParent().child(\"classes_gen\");\n  }","commit_id":"54d9da8d56f524282508daa4704418d5b186c6a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  public File getClassesGen() {\n    return mySourceLanguage.getClassesGen();\n  }","id":44992,"modified_method":"@Nullable\n  public IFile getClassesGen() {\n    return mySourceLanguage.getClassesGen();\n  }","commit_id":"54d9da8d56f524282508daa4704418d5b186c6a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private jetbrains.mps.plugin.CompilationResult compile(Set<IModule> modules) {\n    if (modules.isEmpty()) {\n      return new jetbrains.mps.plugin.CompilationResult(0, 0, false);\n    }\n\n    IClassPathItem classPathItems = computeDependenciesClassPath(modules);\n    JavaCompiler compiler = new JavaCompiler(classPathItems);\n\n    for (IModule m : modules) {\n      if (!m.isCompileInMPS()) {\n        LOG.error(\"Module which isn't compiled in MPS depend on module which has to be compiled in MPS:\", m);\n        continue;\n      }\n      \n      for (String sp : m.getSourcePaths()) {\n        addSource(compiler, new File(sp), \"\", m);\n      }\n\n      FileUtil.delete(m.getClassesGen());\n    }\n\n    compiler.compile();\n\n    int errorCount = 0;\n\n    for (CompilationResult cr : compiler.getCompilationResults()) {\n      if (cr.getErrors() != null) {              \n        for (CategorizedProblem cp : cr.getErrors()) {\n\n\n          String messageStirng = new String(cp.getOriginatingFileName()) + \" : \" + cp.getMessage();\n\n          if (cp.isWarning()) {\n            LOG.warning(messageStirng);            \n          } else {\n            LOG.error(messageStirng);\n          }\n        }\n        \n        errorCount += cr.getErrors().length;\n      }\n\n      for (ClassFile cf : cr.getClassFiles()) {\n        String name = getName(cf.getCompoundName());\n        String containerClassName = name;\n        if (containerClassName.contains(\"$\")) {\n          int index = containerClassName.indexOf('$');\n          containerClassName = containerClassName.substring(0, index);\n        }\n        if (myContainingModules.containsKey(containerClassName)) {\n          IModule m = myContainingModules.get(containerClassName);\n          File classesGen = m.getClassesGen();\n          String packageName = NameUtil.namespaceFromLongName(name);\n          File outputDir = new File(classesGen + File.separator + packageName.replace('.', File.separatorChar));\n          outputDir.mkdirs();                    \n          String className = NameUtil.shortNameFromLongName(name);\n          File output = new File(outputDir, className + \".class\");\n          try {\n            FileOutputStream os = new FileOutputStream(output);\n            os.write(cf.getBytes());\n            os.close();\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        } else {\n          LOG.error(\"I don't know in which module's output path I should place class file for \" + name);\n        }\n      }\n    }\n\n    return new jetbrains.mps.plugin.CompilationResult(errorCount, 0, false);\n  }","id":44993,"modified_method":"private jetbrains.mps.plugin.CompilationResult compile(Set<IModule> modules) {\n    if (modules.isEmpty()) {\n      return new jetbrains.mps.plugin.CompilationResult(0, 0, false);\n    }\n\n    IClassPathItem classPathItems = computeDependenciesClassPath(modules);\n    JavaCompiler compiler = new JavaCompiler(classPathItems);\n\n    for (IModule m : modules) {\n      if (!m.isCompileInMPS()) {\n        LOG.error(\"Module which isn't compiled in MPS depend on module which has to be compiled in MPS:\", m);\n        continue;\n      }\n      \n      for (String sp : m.getSourcePaths()) {\n        addSource(compiler, new File(sp), \"\", m);\n      }\n\n      FileUtil.delete(m.getClassesGen().toFile());\n    }\n\n    compiler.compile();\n\n    int errorCount = 0;\n\n    for (CompilationResult cr : compiler.getCompilationResults()) {\n      if (cr.getErrors() != null) {              \n        for (CategorizedProblem cp : cr.getErrors()) {\n\n\n          String messageStirng = new String(cp.getOriginatingFileName()) + \" : \" + cp.getMessage();\n\n          if (cp.isWarning()) {\n            LOG.warning(messageStirng);            \n          } else {\n            LOG.error(messageStirng);\n          }\n        }\n        \n        errorCount += cr.getErrors().length;\n      }\n\n      for (ClassFile cf : cr.getClassFiles()) {\n        String name = getName(cf.getCompoundName());\n        String containerClassName = name;\n        if (containerClassName.contains(\"$\")) {\n          int index = containerClassName.indexOf('$');\n          containerClassName = containerClassName.substring(0, index);\n        }\n        if (myContainingModules.containsKey(containerClassName)) {\n          IModule m = myContainingModules.get(containerClassName);\n          File classesGen = m.getClassesGen().toFile();\n          String packageName = NameUtil.namespaceFromLongName(name);\n          File outputDir = new File(classesGen + File.separator + packageName.replace('.', File.separatorChar));\n          outputDir.mkdirs();                    \n          String className = NameUtil.shortNameFromLongName(name);\n          File output = new File(outputDir, className + \".class\");\n          try {\n            FileOutputStream os = new FileOutputStream(output);\n            os.write(cf.getBytes());\n            os.close();\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        } else {\n          LOG.error(\"I don't know in which module's output path I should place class file for \" + name);\n        }\n      }\n    }\n\n    return new jetbrains.mps.plugin.CompilationResult(errorCount, 0, false);\n  }","commit_id":"54d9da8d56f524282508daa4704418d5b186c6a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean isClassesUpToDate(IModule m) {\n    if (myClassesUpToDateStatus.containsKey(m)) {\n      return myClassesUpToDateStatus.get(m);\n    }\n\n    if (!m.isCompileInMPS()) {\n      myClassesUpToDateStatus.put(m, true);      \n      return true;\n    }\n\n    File classesGen = m.getClassesGen();\n\n    long classesTimeStamp = FileUtil.getNewestFileTime(classesGen);\n    long sourcesTimeStamp = 0;\n\n    for (String s : m.getSourcePaths()) {\n      sourcesTimeStamp = Math.max(sourcesTimeStamp, FileUtil.getNewestFileTime(new File(s)));\n    }\n\n    boolean result = classesTimeStamp >= sourcesTimeStamp;\n    myClassesUpToDateStatus.put(m, result);\n    return result;\n  }","id":44994,"modified_method":"private boolean isClassesUpToDate(IModule m) {\n    if (myClassesUpToDateStatus.containsKey(m)) {\n      return myClassesUpToDateStatus.get(m);\n    }\n\n    if (!m.isCompileInMPS()) {\n      myClassesUpToDateStatus.put(m, true);      \n      return true;\n    }\n\n    File classesGen = m.getClassesGen().toFile();\n\n    long classesTimeStamp = FileUtil.getNewestFileTime(classesGen);\n    long sourcesTimeStamp = 0;\n\n    for (String s : m.getSourcePaths()) {\n      sourcesTimeStamp = Math.max(sourcesTimeStamp, FileUtil.getNewestFileTime(new File(s)));\n    }\n\n    boolean result = classesTimeStamp >= sourcesTimeStamp;\n    myClassesUpToDateStatus.put(m, result);\n    return result;\n  }","commit_id":"54d9da8d56f524282508daa4704418d5b186c6a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void clean(final Set<IModule> modules, final IAdaptiveProgressMonitor monitor) {\n    try {\n      monitor.start(\"Clean\", 2000);\n      for (IModule m : modules) {\n        monitor.addText(\"Cleaning \" + m.getModuleUID() + \"...\");\n        FileUtil.delete(m.getClassesGen());\n      }\n      monitor.addText(\"Done\");\n    } finally {\n      monitor.finish();\n    }\n  }","id":44995,"modified_method":"public void clean(final Set<IModule> modules, final IAdaptiveProgressMonitor monitor) {\n    try {\n      monitor.start(\"Clean\", 2000);\n      for (IModule m : modules) {\n        monitor.addText(\"Cleaning \" + m.getModuleUID() + \"...\");\n        FileUtil.delete(m.getClassesGen().toFile());\n      }\n      monitor.addText(\"Done\");\n    } finally {\n      monitor.finish();\n    }\n  }","commit_id":"54d9da8d56f524282508daa4704418d5b186c6a2","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Opens all TopComponent windows that are needed ({@link DataExplorer}, {@link DataResult}, and\n     * {@link DataContent})\n     */\n    public static void openCoreWindows() {\n        // TODO: there has to be a better way to do this.\n\n        // find the data explorer top components\n        Collection<? extends DataExplorer> dataExplorers = Lookup.getDefault().lookupAll(DataExplorer.class);\n        for (DataExplorer de : dataExplorers) {\n            TopComponent explorerWin = de.getTopComponent();\n            Mode m = WindowManager.getDefault().findMode(\"explorer\");\n            m.dockInto(explorerWin); // redock into the explorer mode\n            explorerWin.open(); // open that top component\n        }\n\n        // find the data content top component\n        DataContent dc = Lookup.getDefault().lookup(DataContent.class);\n        TopComponent contentWin = dc.getTopComponent();\n        Mode m = WindowManager.getDefault().findMode(\"output\");\n        m.dockInto(contentWin); // redock into the output mode\n        contentWin.open(); // open that top component\n    }","id":44996,"modified_method":"/**\n     * Opens all TopComponent windows that are needed ({@link DataExplorer}, {@link DataResult}, and\n     * {@link DataContent})\n     */\n    public static void openCoreWindows() {\n        // TODO: there has to be a better way to do this.\n\n        // find the data explorer top components\n        Collection<? extends DataExplorer> dataExplorers = Lookup.getDefault().lookupAll(DataExplorer.class);\n        for (DataExplorer de : dataExplorers) {\n            TopComponent explorerWin = de.getTopComponent();\n            Mode m = WindowManager.getDefault().findMode(\"explorer\");\n            if (m != null) {\n                m.dockInto(explorerWin); // redock into the explorer mode\n            } else {\n                logger.log(Level.WARNING, \"Could not find explorer mode and dock explorer window\");\n            }\n            explorerWin.open(); // open that top component\n        }\n\n        // find the data content top component\n        DataContent dc = Lookup.getDefault().lookup(DataContent.class);\n        TopComponent contentWin = dc.getTopComponent();\n        Mode m = WindowManager.getDefault().findMode(\"output\");\n        if (m != null) {\n            m.dockInto(contentWin); // redock into the output mode\n        } else {\n            logger.log(Level.WARNING, \"Could not find output mode and dock content window\");\n        }\n\n        contentWin.open(); // open that top component\n    }","commit_id":"28b08a056687e39e6d9f379facb72309ba8085c6","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    protected void componentShowing() {\n        logger.log(Level.INFO, \"SHOWING\");\n\n        Mode mode = WindowManager.getDefault().findMode(\"floatingLeftBottom\");\n        if (mode != null) {\n            mode.dockInto(this);\n            this.open();\n        }\n    }","id":44997,"modified_method":"@Override\n    protected void componentShowing() {\n        //logger.log(Level.INFO, \"SHOWING\");\n\n        Mode mode = WindowManager.getDefault().findMode(\"floatingLeftBottom\");\n        if (mode != null) {\n            TopComponent [] tcs = mode.getTopComponents();\n            for (int i = 0; i<tcs.length; ++i) {\n                if (tcs[i] == this)\n                    //already floating\n                    return;\n            }\n            mode.dockInto(this);\n            this.open();\n        }\n    }","commit_id":"1759121453eb244cdb36c0e352d953e9a5a8b97e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void componentClosed() {\n        logger.log(Level.INFO, \"CLOSED\");\n        // TODO add custom code on component closing\n        // WindowManager.getDefault().findMode(\"bottomSlidingSide\").dockInto(this);\n        if (manager.isIngestRunning()) {\n            /*\n            Mode mode = WindowManager.getDefault().findMode(\"floatingLeftBottom\");\n            //Mode mode = WindowManager.getDefault().findMode(\"bottomSlidingSide\");\n            if (mode != null) {\n                mode.dockInto(this);\n                this.open();\n            }\n            \n            return;\n            */\n        }\n\n        Mode mode = WindowManager.getDefault().findMode(\"dockedBottom\");\n        if (mode != null) {\n            mode.dockInto(this);\n            this.open();\n        }\n\n    }","id":44998,"modified_method":"@Override\n    public void componentClosed() {\n        //logger.log(Level.INFO, \"CLOSED\");\n        Mode mode = WindowManager.getDefault().findMode(\"dockedBottom\");\n        if (mode != null) {\n            mode.dockInto(this);\n            this.open();\n        }\n    }","commit_id":"1759121453eb244cdb36c0e352d953e9a5a8b97e","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"@Override\n    public void componentOpened() {\n        logger.log(Level.INFO, \"OPENED\");\n        //create manager instance\n        if (manager == null)\n            manager = IngestManager.getDefault();\n    }","id":44999,"modified_method":"@Override\n    public void componentOpened() {\n        //logger.log(Level.INFO, \"OPENED\");\n        //create manager instance\n        if (manager == null) {\n            manager = IngestManager.getDefault();\n        }\n    }","commit_id":"1759121453eb244cdb36c0e352d953e9a5a8b97e","url":"https://github.com/sleuthkit/autopsy"}]